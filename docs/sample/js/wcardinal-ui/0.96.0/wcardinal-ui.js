/*
 Winter Cardinal UI v0.96.0
 Copyright (C) 2019 Toshiba Corporation
 SPDX-License-Identifier: Apache-2.0

 Material Design icons by Google
 Apache license version 2.0.
*/
(function (pixi_js) {
    'use strict';

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDeserializers = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeType;
    (function (EShapeType) {
        EShapeType[EShapeType["CIRCLE"] = 0] = "CIRCLE";
        EShapeType[EShapeType["RECTANGLE"] = 1] = "RECTANGLE";
        EShapeType[EShapeType["RECTANGLE_ROUNDED"] = 2] = "RECTANGLE_ROUNDED";
        EShapeType[EShapeType["TRIANGLE"] = 3] = "TRIANGLE";
        EShapeType[EShapeType["TRIANGLE_ROUNDED"] = 4] = "TRIANGLE_ROUNDED";
        EShapeType[EShapeType["LINE"] = 5] = "LINE";
        EShapeType[EShapeType["IMAGE"] = 6] = "IMAGE";
        EShapeType[EShapeType["IMAGE_SDF"] = 7] = "IMAGE_SDF";
        EShapeType[EShapeType["GROUP"] = 8] = "GROUP";
        EShapeType[EShapeType["BAR"] = 9] = "BAR";
        EShapeType[EShapeType["LABEL"] = 10] = "LABEL";
        EShapeType[EShapeType["NULL"] = 11] = "NULL";
        EShapeType[EShapeType["GROUP_SHADOWED"] = 12] = "GROUP_SHADOWED";
        EShapeType[EShapeType["LINE_OF_CIRCLES"] = 13] = "LINE_OF_CIRCLES";
        EShapeType[EShapeType["LINE_OF_RECTANGLES"] = 14] = "LINE_OF_RECTANGLES";
        EShapeType[EShapeType["LINE_OF_RECTANGLE_ROUNDEDS"] = 15] = "LINE_OF_RECTANGLE_ROUNDEDS";
        EShapeType[EShapeType["LINE_OF_TRIANGLES"] = 16] = "LINE_OF_TRIANGLES";
        EShapeType[EShapeType["LINE_OF_TRIANGLE_ROUNDEDS"] = 17] = "LINE_OF_TRIANGLE_ROUNDEDS";
        EShapeType[EShapeType["EMBEDDED"] = 18] = "EMBEDDED";
        EShapeType[EShapeType["LAYER"] = 19] = "LAYER";
        EShapeType[EShapeType["EXTENSION"] = 1000] = "EXTENSION";
    })(EShapeType || (EShapeType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUploadeds = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStrokeStyle;
    (function (EShapeStrokeStyle) {
        EShapeStrokeStyle[EShapeStrokeStyle["NONE"] = 0] = "NONE";
        EShapeStrokeStyle[EShapeStrokeStyle["NON_EXPANDING_WIDTH"] = 2] = "NON_EXPANDING_WIDTH";
        EShapeStrokeStyle[EShapeStrokeStyle["NON_SHRINKING_WIDTH"] = 4] = "NON_SHRINKING_WIDTH";
        EShapeStrokeStyle[EShapeStrokeStyle["NON_SCALING_DOT_AND_DASH"] = 8] = "NON_SCALING_DOT_AND_DASH";
        EShapeStrokeStyle[EShapeStrokeStyle["NON_SCALING"] = 14] = "NON_SCALING";
        EShapeStrokeStyle[EShapeStrokeStyle["NON_SCALING_MASK"] = 14] = "NON_SCALING_MASK";
        EShapeStrokeStyle[EShapeStrokeStyle["DOTTED"] = 16] = "DOTTED";
        EShapeStrokeStyle[EShapeStrokeStyle["DOTTED_DENSELY"] = 32] = "DOTTED_DENSELY";
        EShapeStrokeStyle[EShapeStrokeStyle["DOTTED_LOOSELY"] = 64] = "DOTTED_LOOSELY";
        EShapeStrokeStyle[EShapeStrokeStyle["DOTTED_MASK"] = 112] = "DOTTED_MASK";
        EShapeStrokeStyle[EShapeStrokeStyle["DASHED"] = 128] = "DASHED";
        EShapeStrokeStyle[EShapeStrokeStyle["DASHED_DENSELY"] = 256] = "DASHED_DENSELY";
        EShapeStrokeStyle[EShapeStrokeStyle["DASHED_LOOSELY"] = 512] = "DASHED_LOOSELY";
        EShapeStrokeStyle[EShapeStrokeStyle["DASHED_MASK"] = 896] = "DASHED_MASK";
    })(EShapeStrokeStyle || (EShapeStrokeStyle = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toDash = function (length, strokeWidth, style, result) {
        if (style & EShapeStrokeStyle.DOTTED_MASK) {
            if (style & EShapeStrokeStyle.DOTTED) {
                result.set(strokeWidth, strokeWidth);
            }
            else if (style & EShapeStrokeStyle.DOTTED_DENSELY) {
                result.set(strokeWidth, strokeWidth * 0.5);
            }
            else {
                result.set(strokeWidth, strokeWidth * 2);
            }
        }
        else if (style & EShapeStrokeStyle.DASHED_MASK) {
            if (style & EShapeStrokeStyle.DASHED) {
                result.set(strokeWidth * 2, strokeWidth);
            }
            else if (style & EShapeStrokeStyle.DASHED_DENSELY) {
                result.set(strokeWidth * 2, strokeWidth * 0.5);
            }
            else {
                result.set(strokeWidth * 2, strokeWidth * 2);
            }
        }
        else {
            result.set(2 * length, 0);
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toScaleInvariant = function (style) {
        var nonExpandingWidth = style & EShapeStrokeStyle.NON_EXPANDING_WIDTH ? 1 : 0;
        var nonShrinkingWidth = style & EShapeStrokeStyle.NON_SHRINKING_WIDTH ? 2 : 0;
        var nonScalingDotAndDash = style & EShapeStrokeStyle.NON_SCALING_DOT_AND_DASH ? 4 : 0;
        if (style & (EShapeStrokeStyle.DOTTED_MASK || EShapeStrokeStyle.DASHED_MASK)) {
            return nonExpandingWidth | nonShrinkingWidth | nonScalingDotAndDash;
        }
        else {
            return nonExpandingWidth | nonShrinkingWidth;
        }
    };

    var BAR_VERTEX_COUNT = 4;
    var BAR_INDEX_COUNT = 2;
    var BAR_FMIN = 0.00001;
    var BAR_WORK_POINT = new pixi_js.Point();
    var buildBarClipping = function (clippings, voffset) {
        var ic = voffset * 3 - 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 3;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 5;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 3;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 5;
    };
    var buildBarIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
    };
    var buildBarVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, pointValues, pointsSize, strokeWidth, strokeStyle, internalTransform) {
        // First point
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var tx = internalTransform.tx;
        var ty = internalTransform.ty;
        var pv0 = pointValues[0];
        var pv1 = pointValues[1];
        var p1x = a * pv0 + c * pv1 + tx;
        var p1y = b * pv0 + d * pv1 + ty;
        // Last point
        var pv2 = pointValues[2];
        var pv3 = pointValues[3];
        var p2x = a * pv2 + c * pv3 + tx;
        var p2y = b * pv2 + d * pv3 + ty;
        // Normal
        var dx = p2x - p1x;
        var dy = p2y - p1y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        var l = distance;
        if (0 <= pointsSize && BAR_FMIN < distance) {
            var ratio = pointsSize / distance;
            dx *= ratio;
            dy *= ratio;
            p2x = p1x + dx;
            p2y = p1y + dy;
            l = pointsSize;
        }
        // Other points
        var p0x = p1x - dx;
        var p0y = p1y - dy;
        var p3x = p2x + dx;
        var p3y = p2y + dy;
        //
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var dash = toDash(l, strokeWidth, strokeStyle, BAR_WORK_POINT);
        var dash0 = dash.x;
        var dash1 = dash.y;
        var iv = (voffset << 1) - 1;
        var icf = (voffset << 2) - 1;
        var is = voffset * 6 - 1;
        vertices[++iv] = p1x;
        vertices[++iv] = p1y;
        vertices[++iv] = p1x;
        vertices[++iv] = p1y;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = p0x;
        steps[++is] = p0y;
        steps[++is] = p2x;
        steps[++is] = p2y;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = p0x;
        steps[++is] = p0y;
        steps[++is] = p2x;
        steps[++is] = p2y;
        colorFills[++icf] = 0;
        colorFills[++icf] = dash0;
        colorFills[++icf] = dash1;
        colorFills[++icf] = l;
        colorFills[++icf] = 0;
        colorFills[++icf] = dash0;
        colorFills[++icf] = dash1;
        colorFills[++icf] = l;
        vertices[++iv] = p2x;
        vertices[++iv] = p2y;
        vertices[++iv] = p2x;
        vertices[++iv] = p2y;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = p1x;
        steps[++is] = p1y;
        steps[++is] = p3x;
        steps[++is] = p3y;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = p1x;
        steps[++is] = p1y;
        steps[++is] = p3x;
        steps[++is] = p3y;
        colorFills[++icf] = l;
        colorFills[++icf] = dash0;
        colorFills[++icf] = dash1;
        colorFills[++icf] = l;
        colorFills[++icf] = l;
        colorFills[++icf] = dash0;
        colorFills[++icf] = dash1;
        colorFills[++icf] = l;
    };
    var buildBarUv = function (uvs, voffset, textureUvs) {
        var iuv = (voffset << 1) - 1;
        uvs[++iuv] = textureUvs.x0;
        uvs[++iuv] = textureUvs.y0;
        uvs[++iuv] = textureUvs.x3;
        uvs[++iuv] = textureUvs.y3;
        uvs[++iuv] = textureUvs.x1;
        uvs[++iuv] = textureUvs.y1;
        uvs[++iuv] = textureUvs.x2;
        uvs[++iuv] = textureUvs.y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilCharacterIterator = /** @class */ (function () {
        function UtilCharacterIterator() {
            this._target = "";
            this._position = 0;
        }
        Object.defineProperty(UtilCharacterIterator.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this._position = position;
            },
            enumerable: false,
            configurable: true
        });
        UtilCharacterIterator.prototype.init = function (target) {
            this._target = target;
            this._position = 0;
        };
        UtilCharacterIterator.prototype.hasNext = function () {
            return this._position < this._target.length;
        };
        UtilCharacterIterator.prototype.findNextBreak = function (target, istart) {
            var iend = target.length;
            for (var i = istart; i < iend; ++i) {
                var code = target.charCodeAt(i);
                if (!this.isLowSurrogate(code) && !this.isVariationSelector(code)) {
                    return i;
                }
            }
            return iend;
        };
        UtilCharacterIterator.prototype.isHighSurrogate = function (code) {
            return 0xd800 <= code && code <= 0xdbff;
        };
        UtilCharacterIterator.prototype.isLowSurrogate = function (code) {
            return 0xdc00 <= code && code <= 0xdfff;
        };
        UtilCharacterIterator.prototype.isVariationSelector = function (code) {
            return 0xfe00 <= code && code <= 0xfe0f;
        };
        UtilCharacterIterator.prototype.next = function () {
            var target = this._target;
            var position = this._position;
            var nextBreak = this.findNextBreak(target, position + 1);
            var result = target.substring(position, nextBreak);
            this._position = nextBreak;
            return result;
        };
        /**
         * Advances the position if the next character is not equal to
         * the given `except`.
         *
         * @param except
         * @return true if the position is advanced
         */
        UtilCharacterIterator.prototype.advance = function (except) {
            var target = this._target;
            var position = this._position;
            var nextBreak = this.findNextBreak(target, position + 1);
            if (target.substring(position, nextBreak) !== except) {
                this._position = nextBreak;
                return true;
            }
            return false;
        };
        UtilCharacterIterator.from = function (target) {
            if (UtilCharacterIterator._instance == null) {
                UtilCharacterIterator._instance = new UtilCharacterIterator();
            }
            var instance = UtilCharacterIterator._instance;
            instance.init(target);
            return instance;
        };
        UtilCharacterIterator._instance = null;
        return UtilCharacterIterator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextWeight;
    (function (EShapeTextWeight) {
        EShapeTextWeight[EShapeTextWeight["NORMAL"] = 0] = "NORMAL";
        EShapeTextWeight[EShapeTextWeight["BOLD"] = 1] = "BOLD";
    })(EShapeTextWeight || (EShapeTextWeight = {}));
    var EShapeTextStyle;
    (function (EShapeTextStyle) {
        EShapeTextStyle[EShapeTextStyle["NORMAL"] = 0] = "NORMAL";
        EShapeTextStyle[EShapeTextStyle["ITALIC"] = 1] = "ITALIC";
    })(EShapeTextStyle || (EShapeTextStyle = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignHorizontal;
    (function (EShapeTextAlignHorizontal) {
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["LEFT"] = 0] = "LEFT";
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["CENTER"] = 1] = "CENTER";
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["RIGHT"] = 2] = "RIGHT";
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["OUTSIDE_LEFT"] = 3] = "OUTSIDE_LEFT";
        EShapeTextAlignHorizontal[EShapeTextAlignHorizontal["OUTSIDE_RIGHT"] = 4] = "OUTSIDE_RIGHT";
    })(EShapeTextAlignHorizontal || (EShapeTextAlignHorizontal = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignVertical;
    (function (EShapeTextAlignVertical) {
        EShapeTextAlignVertical[EShapeTextAlignVertical["TOP"] = 0] = "TOP";
        EShapeTextAlignVertical[EShapeTextAlignVertical["MIDDLE"] = 1] = "MIDDLE";
        EShapeTextAlignVertical[EShapeTextAlignVertical["BOTTOM"] = 2] = "BOTTOM";
        EShapeTextAlignVertical[EShapeTextAlignVertical["OUTSIDE_TOP"] = 3] = "OUTSIDE_TOP";
        EShapeTextAlignVertical[EShapeTextAlignVertical["OUTSIDE_BOTTOM"] = 4] = "OUTSIDE_BOTTOM";
    })(EShapeTextAlignVertical || (EShapeTextAlignVertical = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextDirection;
    (function (EShapeTextDirection) {
        EShapeTextDirection[EShapeTextDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
        EShapeTextDirection[EShapeTextDirection["TOP_TO_BOTTOM"] = 1] = "TOP_TO_BOTTOM";
        EShapeTextDirection[EShapeTextDirection["BOTTOM_TO_TOP"] = 2] = "BOTTOM_TO_TOP";
    })(EShapeTextDirection || (EShapeTextDirection = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLength = function (p0x, p0y, p1x, p1y) {
        var dx01 = p1x - p0x;
        var dy01 = p1y - p0y;
        return Math.sqrt(dx01 * dx01 + dy01 * dy01);
    };

    var TEXT_VERTEX_COUNT = 4;
    var TEXT_INDEX_COUNT = 2;
    var TEXT_FMIN = 0.00001;
    var TEXT_WORK_POINT = new pixi_js.Point();
    var toTextBufferCount = function (shape) {
        return Math.ceil(shape.text.value.length / 12) * 12;
    };
    var buildTextClipping = function (clippings, voffset, vcount) {
        var ic = voffset * 3 - 1;
        var icmax = (voffset + vcount) * 3 - 1;
        for (; ic < icmax;) {
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 2;
        }
    };
    var buildTextIndex = function (indices, voffset, ioffset, icount) {
        var ii = ioffset * 3 - 1;
        var iimax = (ioffset + icount) * 3 - 1;
        var iv = voffset;
        for (; ii < iimax;) {
            indices[++ii] = iv;
            indices[++ii] = iv + 1;
            indices[++ii] = iv + 3;
            indices[++ii] = iv + 1;
            indices[++ii] = iv + 2;
            indices[++ii] = iv + 3;
            iv += 4;
        }
    };
    var buildTextStep = function (steps, voffset, vcount, textAtlas, textSize, textOutlineWidth, textWeight) {
        var is = voffset * 6 - 1;
        var ismax = (voffset + vcount) * 6 - 1;
        var scaleInvariant = toScaleInvariant(EShapeStrokeStyle.NONE);
        if (textAtlas != null) {
            var scale = textAtlas.font.size / textSize;
            var position = textWeight === EShapeTextWeight.NORMAL ? 0.0 : 0.05;
            for (; is < ismax;) {
                steps[++is] = textOutlineWidth;
                steps[++is] = scaleInvariant;
                steps[++is] = scale;
                steps[++is] = 1;
                steps[++is] = 0;
                steps[++is] = position;
            }
        }
        else {
            for (; is < ismax;) {
                steps[++is] = 0;
                steps[++is] = scaleInvariant;
                steps[++is] = 0;
                steps[++is] = 1;
                steps[++is] = 0;
                steps[++is] = 0;
            }
        }
    };
    var getTextBBox = function (halign, valign, hoffset, voffset, hpadding, vpadding, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, result) {
        switch (halign) {
            case EShapeTextAlignHorizontal.LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y0 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x3) +
                                hnx * (hoffset + hpadding) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y3) +
                                hny * (hoffset + hpadding) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x3 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y3 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x0 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y0 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y3 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.CENTER:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x =
                            0.5 * (x0 + x1) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset + vpadding);
                        result.y =
                            0.5 * (y0 + y1) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            0.5 * (x3 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            0.5 * (y3 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            0.5 * (x0 + x1) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            0.5 * (y0 + y1) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x =
                            0.5 * (x3 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset + vpadding);
                        result.y =
                            0.5 * (y3 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y1 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x1 + x2) +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y1 + y2) +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x2 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y2 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x1 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y1 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y2 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y0 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x3) +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y3) +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x3 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y3 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x0 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y0 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y3 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y1 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x1 + x2) +
                                hnx * (hoffset + hpadding) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y1 + y2) +
                                hny * (hoffset + hpadding) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x2 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y2 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x1 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y1 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y2 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                }
                break;
        }
    };
    var toNormalized = function (dx, dy, defx, defy, result) {
        var d = dx * dx + dy * dy;
        if (TEXT_FMIN < d) {
            var l = Math.sqrt(d);
            var li = 1 / l;
            result.set(dx * li, dy * li);
            return l;
        }
        else {
            result.set(defx, defy);
            return 0;
        }
    };
    var rotateAlignHorizontalRight = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
        }
    };
    var rotateAlignVerticalRight = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
        }
    };
    var rotateAlignHorizontalLeft = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
        }
    };
    var rotateAlignVerticalLeft = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
        }
    };
    var buildTextVertex = function (vertices, uvs, voffset, vcount, originX, originY, sizeX, sizeY, textAtlas, textSize, textValue, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textWorld, textureUvs, internalTransform) {
        // Calculate the transformed positions
        //
        //  0               1
        // |---------------|
        // |               |
        // |3              |2
        // |---------------|
        //
        var sx = sizeX * 0.5;
        var sy = sizeY * 0.5;
        var work = TEXT_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        var x2 = work.x;
        var y2 = work.y;
        var x3 = x0 + (x2 - x1);
        var y3 = y0 + (y2 - y1);
        // Horizontal normal
        var hl = toLength(x0, y0, x1, y1);
        toNormalized(internalTransform.a, internalTransform.b, 1, 0, work);
        var hnx = work.x;
        var hny = work.y;
        // Vertical normal
        var vl = toLength(x0, y0, x3, y3);
        toNormalized(internalTransform.c, internalTransform.d, 0, 1, work);
        var vnx = work.x;
        var vny = work.y;
        // Calculate the width / height
        var width = 0;
        var height = 0;
        var heightChar = 0;
        var lineHeight = Math.max(0, textSize + textSpacingVertical);
        var lineWidth = 0;
        var textAtlasCharacters = textAtlas.characters;
        var iterator = UtilCharacterIterator.from(textValue);
        var advancePrevious = 0;
        while (iterator.hasNext()) {
            var character = iterator.next();
            if (character !== "\n") {
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                var data = textAtlasCharacters[character];
                if (data) {
                    advancePrevious = data.advance;
                    heightChar = data.height;
                }
                else {
                    advancePrevious = 0;
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                width = Math.max(width, lineWidth);
                lineWidth = 0;
                height += lineHeight;
            }
        }
        var scale = textSize / textAtlas.font.size;
        lineWidth += advancePrevious;
        width = Math.max(width, lineWidth) * scale;
        lineWidth = 0;
        heightChar *= scale;
        height += textSize;
        //
        var tx0 = 0;
        var ty0 = 0;
        var lineWidthMaximum = NaN;
        switch (textDirection) {
            case EShapeTextDirection.LEFT_TO_RIGHT:
                getTextBBox(textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textPaddingHorizontal, textPaddingVertical, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping) {
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.LEFT:
                        case EShapeTextAlignHorizontal.CENTER:
                        case EShapeTextAlignHorizontal.RIGHT:
                            switch (textAlignVertical) {
                                case EShapeTextAlignVertical.TOP:
                                case EShapeTextAlignVertical.MIDDLE:
                                case EShapeTextAlignVertical.BOTTOM:
                                    lineWidthMaximum = hl - textPaddingHorizontal * 2;
                                    break;
                            }
                            break;
                    }
                }
                break;
            case EShapeTextDirection.TOP_TO_BOTTOM:
                // Swap normals
                work.set(vnx, vny);
                vnx = -hnx;
                vny = -hny;
                hnx = work.x;
                hny = work.y;
                // Get text bbox
                getTextBBox(rotateAlignVerticalRight(textAlignVertical), rotateAlignHorizontalRight(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x1, y1, x2, y2, x3, y3, x0, y0, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping) {
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.TOP:
                        case EShapeTextAlignVertical.MIDDLE:
                        case EShapeTextAlignVertical.BOTTOM:
                            switch (textAlignHorizontal) {
                                case EShapeTextAlignHorizontal.LEFT:
                                case EShapeTextAlignHorizontal.CENTER:
                                case EShapeTextAlignHorizontal.RIGHT:
                                    lineWidthMaximum = vl - textPaddingVertical * 2;
                                    break;
                            }
                            break;
                    }
                }
                break;
            case EShapeTextDirection.BOTTOM_TO_TOP:
                // Swap normals
                work.set(vnx, vny);
                vnx = hnx;
                vny = hny;
                hnx = -work.x;
                hny = -work.y;
                // Get text bbox
                getTextBBox(rotateAlignVerticalLeft(textAlignVertical), rotateAlignHorizontalLeft(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x3, y3, x0, y0, x1, y1, x2, y2, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping) {
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.TOP:
                        case EShapeTextAlignVertical.MIDDLE:
                        case EShapeTextAlignVertical.BOTTOM:
                            switch (textAlignHorizontal) {
                                case EShapeTextAlignHorizontal.LEFT:
                                case EShapeTextAlignHorizontal.CENTER:
                                case EShapeTextAlignHorizontal.RIGHT:
                                    lineWidthMaximum = vl - textPaddingVertical * 2;
                                    break;
                            }
                            break;
                    }
                }
                break;
        }
        //
        if (lineWidthMaximum < width) {
            var dwidth = (width - lineWidthMaximum) * 0.5;
            textWorld[0] = tx0 + hnx * dwidth;
            textWorld[1] = ty0 + hny * dwidth;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = lineWidthMaximum;
            textWorld[7] = height;
        }
        else {
            textWorld[0] = tx0;
            textWorld[1] = ty0;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = width;
            textWorld[7] = height;
        }
        // Texture
        var uvx0 = textureUvs.x0;
        var uvx1 = textureUvs.x1;
        var uvx3 = textureUvs.x3;
        var uvy0 = textureUvs.y0;
        var uvy1 = textureUvs.y1;
        var uvy3 = textureUvs.y3;
        var duvx01 = uvx1 - uvx0;
        var duvy01 = uvy1 - uvy0;
        var duvx03 = uvx3 - uvx0;
        var duvy03 = uvy3 - uvy0;
        // Vertices & UVs
        var lhx = lineHeight * vnx;
        var lhy = lineHeight * vny;
        var snx = scale * hnx;
        var sny = scale * hny;
        var offsetY = (heightChar - textSize) * 0.5;
        var oyx = offsetY * vnx;
        var oyy = offsetY * vny;
        var offsetItalic = textStyle === EShapeTextStyle.NORMAL ? 0 : textSize * 0.25;
        var bx0 = tx0 - oyx + offsetItalic * snx;
        var by0 = ty0 - oyy + offsetItalic * sny;
        var bx3 = tx0 + oyx + textSize * vnx;
        var by3 = ty0 + oyy + textSize * vny;
        var cx0 = bx0;
        var cy0 = by0;
        var cx3 = bx3;
        var cy3 = by3;
        lineWidth = 0;
        advancePrevious = 0;
        iterator.position = 0;
        var lineCount = 0;
        var iv = voffset * 2;
        for (; iterator.hasNext(); iv += 8) {
            var character = iterator.next();
            if (character !== "\n") {
                var lineWidthPrevious = lineWidth;
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                var ax = lineWidth * snx;
                var ay = lineWidth * sny;
                cx0 = bx0 + ax;
                cy0 = by0 + ay;
                cx3 = bx3 + ax;
                cy3 = by3 + ay;
                var data = textAtlasCharacters[character];
                lineCount += 1;
                if (data) {
                    var advance = data.advance;
                    if (lineWidthMaximum < (lineWidth + advance) * scale) {
                        var dots = textAtlasCharacters["..."];
                        if (dots) {
                            if (1 < lineCount &&
                                lineWidthMaximum < (lineWidth + dots.advance) * scale) {
                                lineWidth = lineWidthPrevious;
                                iv -= 8;
                                lineCount -= 1;
                                var bx = lineWidth * snx;
                                var by = lineWidth * sny;
                                cx0 = bx0 + bx;
                                cy0 = by0 + by;
                                cx3 = bx3 + bx;
                                cy3 = by3 + by;
                            }
                            advancePrevious = dots.advance;
                            writeCharacter(vertices, uvs, iv, dots, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                            for (iv += 8; true; iv += 8) {
                                if (iterator.hasNext() && iterator.advance("\n")) {
                                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                                    lineCount += 1;
                                }
                                else {
                                    iv -= 8;
                                    break;
                                }
                            }
                        }
                        else {
                            advancePrevious = advance;
                            writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                        }
                    }
                    else {
                        advancePrevious = advance;
                        writeCharacter(vertices, uvs, iv, data, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                    }
                }
                else {
                    advancePrevious = 0;
                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                bx0 += lhx;
                by0 += lhy;
                bx3 += lhx;
                by3 += lhy;
                cx0 = bx0;
                cy0 = by0;
                cx3 = bx3;
                cy3 = by3;
                writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scale, textDirection, textAlignHorizontal, textAlignVertical);
                lineWidth = 0;
                lineCount = 0;
            }
        }
        lineWidth += advancePrevious;
        adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scale, textDirection, textAlignHorizontal, textAlignVertical);
        for (var ivmax = (voffset + vcount) * 2; iv < ivmax; iv += 2) {
            vertices[iv + 0] = tx0;
            vertices[iv + 1] = ty0;
            uvs[iv + 0] = uvx0;
            uvs[iv + 1] = uvy0;
        }
    };
    var writeCharacterEmpty = function (vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3) {
        vertices[iv + 0] = cx0;
        vertices[iv + 1] = cy0;
        vertices[iv + 2] = cx0;
        vertices[iv + 3] = cy0;
        vertices[iv + 4] = cx3;
        vertices[iv + 5] = cy3;
        vertices[iv + 6] = cx3;
        vertices[iv + 7] = cy3;
        uvs[iv + 0] = uvx0;
        uvs[iv + 1] = uvy0;
        uvs[iv + 2] = uvx0;
        uvs[iv + 3] = uvy0;
        uvs[iv + 4] = uvx3;
        uvs[iv + 5] = uvy3;
        uvs[iv + 6] = uvx3;
        uvs[iv + 7] = uvy3;
    };
    var writeCharacter = function (vertices, uvs, iv, data, atlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0) {
        // Vertices
        var dataOffsetX = data.x - data.origin.x;
        var dataWidth = data.width;
        var dx0 = dataOffsetX * snx;
        var dy0 = dataOffsetX * sny;
        var dx1 = (dataOffsetX + dataWidth) * snx;
        var dy1 = (dataOffsetX + dataWidth) * sny;
        vertices[iv + 0] = cx0 + dx0;
        vertices[iv + 1] = cy0 + dy0;
        vertices[iv + 2] = cx0 + dx1;
        vertices[iv + 3] = cy0 + dy1;
        vertices[iv + 4] = cx3 + dx1;
        vertices[iv + 5] = cy3 + dy1;
        vertices[iv + 6] = cx3 + dx0;
        vertices[iv + 7] = cy3 + dy0;
        // UVs
        var px0 = data.x / atlas.width;
        var py0 = data.y / atlas.height;
        var px1 = (data.x + data.width) / atlas.width;
        var py1 = (data.y + data.height) / atlas.height;
        var dux0 = duvx01 * px0;
        var duy0 = duvy01 * px0;
        var dux1 = duvx01 * px1;
        var duy1 = duvy01 * px1;
        var dvx0 = duvx03 * py0;
        var dvy0 = duvy03 * py0;
        var dvx1 = duvx03 * py1;
        var dvy1 = duvy03 * py1;
        uvs[iv + 0] = uvx0 + dux0 + dvx0;
        uvs[iv + 1] = uvy0 + duy0 + dvy0;
        uvs[iv + 2] = uvx0 + dux1 + dvx0;
        uvs[iv + 3] = uvy0 + duy1 + dvy0;
        uvs[iv + 4] = uvx0 + dux1 + dvx1;
        uvs[iv + 5] = uvy0 + duy1 + dvy1;
        uvs[iv + 6] = uvx0 + dux0 + dvx1;
        uvs[iv + 7] = uvy0 + duy0 + dvy1;
    };
    var moveText = function (vertices, vertexIndex, textCount, dx, dy) {
        var iv = vertexIndex - 8 * textCount - 1;
        for (var i = 0; i < textCount; ++i) {
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
        }
    };
    var moveTextHalf = function (vertices, vertexIndex, textCount, offset, nx, ny) {
        offset *= 0.5;
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    var moveTextFull = function (vertices, vertexIndex, textCount, offset, nx, ny) {
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    var adjustTextAlignment = function (vertices, nx, ny, lineCount, vertexIndex, offset, textDirection, textAlignHorizontal, textAlignVertical) {
        if (TEXT_FMIN < offset) {
            switch (textDirection) {
                case EShapeTextDirection.LEFT_TO_RIGHT:
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                        case EShapeTextAlignHorizontal.LEFT:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignHorizontal.CENTER:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                        case EShapeTextAlignHorizontal.RIGHT:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.TOP_TO_BOTTOM:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.BOTTOM_TO_TOP:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            // DO NOTHING
                            break;
                    }
                    break;
            }
        }
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsStyle;
    (function (EShapePointsStyle) {
        EShapePointsStyle[EShapePointsStyle["NONE"] = 0] = "NONE";
        EShapePointsStyle[EShapePointsStyle["CLOSED"] = 1] = "CLOSED";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["NON_EXPANDING_WIDTH"] = 2] = "NON_EXPANDING_WIDTH";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["NON_SHRINKING_WIDTH"] = 4] = "NON_SHRINKING_WIDTH";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["NON_SCALING_DOT_AND_DASH"] = 8] = "NON_SCALING_DOT_AND_DASH";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["NON_SCALING_MASK"] = 14] = "NON_SCALING_MASK";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["DOTTED"] = 16] = "DOTTED";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["DOTTED_DENSELY"] = 32] = "DOTTED_DENSELY";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["DOTTED_LOOSELY"] = 64] = "DOTTED_LOOSELY";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["DOTTED_MASK"] = 112] = "DOTTED_MASK";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["DASHED"] = 128] = "DASHED";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["DASHED_DENSELY"] = 256] = "DASHED_DENSELY";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["DASHED_LOOSELY"] = 512] = "DASHED_LOOSELY";
        /** @deprecated in favor of EShapeStrokeStyle. */
        EShapePointsStyle[EShapePointsStyle["DASHED_MASK"] = 896] = "DASHED_MASK";
        EShapePointsStyle[EShapePointsStyle["CURVE"] = 1024] = "CURVE";
        EShapePointsStyle[EShapePointsStyle["FORMATTER_MASK"] = 1024] = "FORMATTER_MASK";
    })(EShapePointsStyle || (EShapePointsStyle = {}));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCopyPart;
    (function (EShapeCopyPart) {
        EShapeCopyPart[EShapeCopyPart["NONE"] = 0] = "NONE";
        EShapeCopyPart[EShapeCopyPart["TRANSFORM"] = 1] = "TRANSFORM";
        EShapeCopyPart[EShapeCopyPart["SIZE"] = 2] = "SIZE";
        EShapeCopyPart[EShapeCopyPart["STYLE"] = 4] = "STYLE";
        EShapeCopyPart[EShapeCopyPart["ACTION"] = 8] = "ACTION";
        EShapeCopyPart[EShapeCopyPart["POINTS"] = 16] = "POINTS";
        EShapeCopyPart[EShapeCopyPart["STATE"] = 32] = "STATE";
        EShapeCopyPart[EShapeCopyPart["IMAGE"] = 64] = "IMAGE";
        EShapeCopyPart[EShapeCopyPart["TAG"] = 128] = "TAG";
        EShapeCopyPart[EShapeCopyPart["ALL"] = 255] = "ALL";
    })(EShapeCopyPart || (EShapeCopyPart = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarPosition;
    (function (EShapeBarPosition) {
        EShapeBarPosition[EShapeBarPosition["TOP"] = 0] = "TOP";
        EShapeBarPosition[EShapeBarPosition["LEFT"] = 1] = "LEFT";
        EShapeBarPosition[EShapeBarPosition["RIGHT"] = 2] = "RIGHT";
        EShapeBarPosition[EShapeBarPosition["BOTTOM"] = 3] = "BOTTOM";
    })(EShapeBarPosition || (EShapeBarPosition = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarPoints = /** @class */ (function () {
        function EShapeBarPoints(parent, position, size, style) {
            this._parent = parent;
            this._id = 0;
            this._values = [0, 0, 0, 0];
            this._segments = [];
            this._style = style !== null && style !== void 0 ? style : EShapePointsStyle.NONE;
            this._size = size !== null && size !== void 0 ? size : -1;
            this._position = position;
            this._updatedSize = NaN;
            this._updatedParentSizeX = NaN;
            this._updatedParentSizeY = NaN;
            this._updatedPosition = NaN;
        }
        EShapeBarPoints.prototype.getComputedSize = function (size, position, sizeX, sizeY) {
            if (0 <= size) {
                return size;
            }
            else {
                switch (position) {
                    case EShapeBarPosition.TOP:
                    case EShapeBarPosition.BOTTOM:
                        return Math.abs(sizeY);
                    case EShapeBarPosition.RIGHT:
                    case EShapeBarPosition.LEFT:
                        return Math.abs(sizeX);
                }
                return 0;
            }
        };
        EShapeBarPoints.prototype.update = function () {
            var parentSize = this._parent.size;
            var parentSizeX = parentSize.x;
            var parentSizeY = parentSize.y;
            var position = this._position;
            var size = this._size;
            if (this._updatedSize !== size ||
                this._updatedParentSizeX !== parentSizeX ||
                this._updatedParentSizeY !== parentSizeY ||
                this._updatedPosition !== position) {
                this._id += 1;
                this._updatedSize = size;
                this._updatedParentSizeX = parentSizeX;
                this._updatedParentSizeY = parentSizeY;
                this._updatedPosition = position;
                var psxh = parentSizeX * 0.5;
                var psyh = parentSizeY * 0.5;
                var computedSize = this.getComputedSize(size, position, parentSizeX, parentSizeY);
                var values = this._values;
                switch (position) {
                    case EShapeBarPosition.TOP:
                        values[0] = 0;
                        values[1] = -psyh;
                        values[2] = 0;
                        values[3] = -psyh + computedSize;
                        break;
                    case EShapeBarPosition.RIGHT:
                        values[0] = psxh;
                        values[1] = 0;
                        values[2] = psxh - computedSize;
                        values[3] = 0;
                        break;
                    case EShapeBarPosition.BOTTOM:
                        values[0] = 0;
                        values[1] = psyh;
                        values[2] = 0;
                        values[3] = psyh - computedSize;
                        break;
                    case EShapeBarPosition.LEFT:
                        values[0] = -psxh;
                        values[1] = 0;
                        values[2] = -psxh + computedSize;
                        values[3] = 0;
                        break;
                }
            }
        };
        Object.defineProperty(EShapeBarPoints.prototype, "length", {
            get: function () {
                return 2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "id", {
            get: function () {
                this.update();
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "values", {
            get: function () {
                this.update();
                return this._values;
            },
            set: function (values) {
                // SUPPOSED NOT TO BE CALLED
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            set: function (segments) {
                // SUPPOSED NOT TO BE CALLED
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                this.moveTo(undefined, size, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this.moveTo(position, undefined, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                this.moveTo(undefined, undefined, style);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "formatter", {
            get: function () {
                return null;
            },
            set: function (formatter) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "formatted", {
            get: function () {
                return this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBarPoints.prototype.copy = function (source) {
            if (source instanceof EShapeBarPoints) {
                return this.moveTo(source.position, source.size, source.style);
            }
            else {
                return this.moveTo(undefined, undefined, source.style);
            }
        };
        EShapeBarPoints.prototype.set = function (newValues, newSegments, newStyle) {
            var newPosition;
            var newSize;
            if (newValues != null) {
                var x0 = newValues[0];
                if (x0 === 0) {
                    var y0 = newValues[1];
                    newPosition = y0 <= 0 ? EShapeBarPosition.TOP : EShapeBarPosition.BOTTOM;
                    newSize = Math.abs(newValues[3] - y0);
                }
                else {
                    newPosition = x0 <= 0 ? EShapeBarPosition.LEFT : EShapeBarPosition.RIGHT;
                    newSize = Math.abs(newValues[2] - x0);
                }
            }
            return this.moveTo(newPosition, newSize, newStyle);
        };
        EShapeBarPoints.prototype.moveTo = function (position, size, style) {
            var isChanged = false;
            if (style != null && this._style !== style) {
                this._style = style;
                isChanged = true;
            }
            if (position != null && this._position !== position) {
                this._position = position;
                isChanged = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeBarPoints.prototype.clone = function (parent) {
            return new EShapeBarPoints(parent, this._position, this._size, this._style);
        };
        EShapeBarPoints.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeBarPoints.prototype.serialize = function (manager) {
            return manager.addResource("[" + this._position + "," + this._size + "," + this._style + "]");
        };
        EShapeBarPoints.prototype.deserialize = function (resourceId, manager) {
            if (0 <= resourceId && resourceId < manager.resources.length) {
                var resource = manager.resources[resourceId];
                var parsed = JSON.parse(resource);
                this.moveTo(parsed[0], parsed[1], parsed[2]);
            }
        };
        EShapeBarPoints.prototype.calcHitPointAbs = function (x, y, ax, ay, threshold, toRange, tester, result) {
            var length = this.length;
            if (2 <= length) {
                var values = this._values;
                var v0x = values[0];
                var v0y = values[1];
                var v1x = values[2];
                var v1y = values[3];
                if (tester(x, y, v0x, v0y, v1x, v1y, 0, threshold, result)) {
                    return true;
                }
            }
            return false;
        };
        return EShapeBarPoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCorner;
    (function (EShapeCorner) {
        EShapeCorner[EShapeCorner["NONE"] = 0] = "NONE";
        EShapeCorner[EShapeCorner["TOP_LEFT"] = 1] = "TOP_LEFT";
        EShapeCorner[EShapeCorner["TOP_RIGHT"] = 2] = "TOP_RIGHT";
        EShapeCorner[EShapeCorner["BOTTOM_LEFT"] = 4] = "BOTTOM_LEFT";
        EShapeCorner[EShapeCorner["BOTTOM_RIGHT"] = 8] = "BOTTOM_RIGHT";
        EShapeCorner[EShapeCorner["TOP"] = 3] = "TOP";
        EShapeCorner[EShapeCorner["BOTTOM"] = 12] = "BOTTOM";
        EShapeCorner[EShapeCorner["LEFT"] = 5] = "LEFT";
        EShapeCorner[EShapeCorner["RIGHT"] = 10] = "RIGHT";
        EShapeCorner[EShapeCorner["ALL"] = 15] = "ALL";
    })(EShapeCorner || (EShapeCorner = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DThemes = /** @class */ (function () {
        function DThemes() {
        }
        DThemes.setDefaultThemeClass = function (theme) {
            this.DEFAULT_THEME_CLASS = theme;
        };
        DThemes.getDefaultThemeClass = function () {
            return this.DEFAULT_THEME_CLASS;
        };
        DThemes.getInstance = function () {
            if (this.INSTANCE == null) {
                var defaultThemeClass = this.getDefaultThemeClass();
                if (defaultThemeClass == null) {
                    throw new Error("No default theme class found");
                }
                this.INSTANCE = new defaultThemeClass();
            }
            return this.INSTANCE;
        };
        DThemes.setInstance = function (instance) {
            var result = this.INSTANCE;
            this.INSTANCE = instance;
            return result;
        };
        DThemes.DEFAULT_THEME_CLASS = null;
        DThemes.INSTANCE = null;
        return DThemes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDefaults = /** @class */ (function () {
        function EShapeDefaults() {
        }
        Object.defineProperty(EShapeDefaults, "THEME", {
            get: function () {
                var theme = this._THEME;
                if (theme != null) {
                    return theme;
                }
                var newTheme = DThemes.getInstance().get("EShape");
                this._THEME = newTheme;
                return newTheme;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "FILL_COLOR", {
            get: function () {
                return this.THEME.getFillColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "FILL_ALPHA", {
            get: function () {
                return this.THEME.getFillAlpha();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_COLOR", {
            get: function () {
                return this.THEME.getStrokeColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_ALPHA", {
            get: function () {
                return this.THEME.getStrokeAlpha();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_WIDTH", {
            get: function () {
                return this.THEME.getStrokeWidth();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_ALIGN", {
            get: function () {
                return this.THEME.getStrokeAlign();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_SIDE", {
            get: function () {
                return this.THEME.getStrokeSide();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_STYLE", {
            get: function () {
                return this.THEME.getStrokeStyle();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_VALUE", {
            get: function () {
                return this.THEME.getTextValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_COLOR", {
            get: function () {
                return this.THEME.getTextColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_ALPHA", {
            get: function () {
                return this.THEME.getTextAlpha();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_FAMILY", {
            get: function () {
                return this.THEME.getTextFamily();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_SIZE", {
            get: function () {
                return this.THEME.getTextSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "CURSOR", {
            get: function () {
                return this.THEME.getCursor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "RADIUS", {
            get: function () {
                return this.THEME.getRadius();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "SIZE_X", {
            get: function () {
                return this.THEME.getSizeX();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "SIZE_Y", {
            get: function () {
                return this.THEME.getSizeY();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "HIGHLIGHT_COLOR", {
            get: function () {
                return this.THEME.getHighlightColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "CURVE_SEGMENT_COUNT", {
            get: function () {
                return this.THEME.getCurveSegmentCount();
            },
            enumerable: false,
            configurable: true
        });
        return EShapeDefaults;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplications = /** @class */ (function () {
        function DApplications() {
        }
        DApplications.add = function (instance) {
            var instances = DApplications.INSTANCES;
            instances.push(instance);
        };
        DApplications.first = function () {
            var instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[0];
            }
            throw new Error("No application found.");
        };
        DApplications.last = function () {
            var instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[instances.length - 1];
            }
            throw new Error("No application found.");
        };
        DApplications.get = function (index) {
            var instances = DApplications.INSTANCES;
            if (0 <= index && index < instances.length) {
                return instances[index];
            }
            return null;
        };
        DApplications.indexOf = function (instance) {
            return DApplications.INSTANCES.indexOf(instance);
        };
        DApplications.size = function () {
            return DApplications.INSTANCES.length;
        };
        DApplications.getStage = function (target) {
            var stage = target;
            while (stage.parent) {
                stage = stage.parent;
            }
            if ("application" in stage && "layer" in stage) {
                return stage;
            }
            return null;
        };
        DApplications.find = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer.application;
            }
            return null;
        };
        DApplications.getLayerBase = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer.application.getLayerBase();
            }
            return null;
        };
        DApplications.getLayerOverlay = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer.application.getLayerOverlay();
            }
            return null;
        };
        DApplications.getLayer = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer;
            }
            return null;
        };
        DApplications.getResolution = function (target) {
            var _a;
            var layer = this.getLayer(target);
            if (layer) {
                return layer.renderer.resolution;
            }
            return (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        };
        DApplications.update = function (target) {
            if (target) {
                var stage = this.getStage(target);
                if (stage) {
                    stage.layer.update();
                }
            }
            else {
                var instances = DApplications.INSTANCES;
                for (var i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].update();
                }
            }
        };
        DApplications.render = function (target) {
            if (target) {
                var stage = this.getStage(target);
                if (stage) {
                    stage.layer.render();
                }
            }
            else {
                var instances = DApplications.INSTANCES;
                for (var i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].render();
                }
            }
        };
        DApplications.INSTANCES = [];
        return DApplications;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAction = /** @class */ (function () {
        function EShapeAction() {
            this.values = [];
        }
        EShapeAction.prototype.add = function (value, index) {
            var values = this.values;
            if (index != null) {
                values.splice(index, 0, value);
            }
            else {
                values.push(value);
            }
            return this;
        };
        EShapeAction.prototype.addAll = function (values) {
            var destination = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                destination.push(values[i]);
            }
            return this;
        };
        EShapeAction.prototype.clearAndAdd = function (value) {
            this.clear();
            this.add(value);
            return this;
        };
        EShapeAction.prototype.clearAndAddAll = function (values) {
            this.clear();
            this.addAll(values);
            return this;
        };
        EShapeAction.prototype.indexOf = function (target) {
            var values = this.values;
            // Instance-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value.isEquals(target)) {
                    return i;
                }
            }
            return -1;
        };
        EShapeAction.prototype.get = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values[index];
            }
            return null;
        };
        EShapeAction.prototype.set = function (index, value) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                var result = values[index];
                values[index] = value;
                return result;
            }
            return null;
        };
        EShapeAction.prototype.remove = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values.splice(index, 1)[0];
            }
            return null;
        };
        EShapeAction.prototype.clear = function () {
            this.values.length = 0;
            return this;
        };
        EShapeAction.prototype.size = function () {
            return this.values.length;
        };
        EShapeAction.prototype.swap = function (indexA, indexB) {
            var values = this.values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
            return this;
        };
        EShapeAction.prototype.serialize = function (manager) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                result.push(values[i].serialize(manager));
            }
            return result;
        };
        return EShapeAction;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseState = {
        HOVERED: "HOVERED",
        ACTIVE: "ACTIVE",
        FOCUSED: "FOCUSED",
        UNFOCUSABLE: "UNFOCUSABLE",
        FOCUS_ROOT: "FOCUS_ROOT",
        FOCUS_REVERSE: "FOCUS_REVERSE",
        READ_ONLY: "READ_ONLY",
        DISABLED: "DISABLED",
        DRAGGING: "DRAGGING",
        PRESSED: "PRESSED",
        INVALID: "INVALID",
        SUCCEEDED: "SUCCEEDED",
        FAILED: "FAILED",
        WARNED: "WARNED",
        CHANGED: "CHANGED",
        ALTERNATED: "ALTERNATED",
        NEW_WINDOW: "NEW_WINDOW"
    };

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseStateSetDataImpl = /** @class */ (function () {
        function DBaseStateSetDataImpl() {
            this._data = new Map();
        }
        DBaseStateSetDataImpl.prototype.set = function (key, data) {
            this._data.set(key, data);
            return this;
        };
        DBaseStateSetDataImpl.prototype.get = function (key) {
            return this._data.get(key);
        };
        DBaseStateSetDataImpl.prototype.delete = function (key) {
            return this._data.delete(key);
        };
        DBaseStateSetDataImpl.prototype.clear = function () {
            this._data.clear();
            return this;
        };
        DBaseStateSetDataImpl.prototype.each = function (iteratee) {
            this._data.forEach(function (data, key) {
                iteratee(data, key);
            });
            return this;
        };
        DBaseStateSetDataImpl.prototype.size = function () {
            return this._data.size;
        };
        DBaseStateSetDataImpl.prototype.copy = function (other) {
            if (other instanceof DBaseStateSetDataImpl) {
                var otherData = other._data;
                var thisData_1 = this._data;
                thisData_1.clear();
                otherData.forEach(function (data, key) {
                    thisData_1.set(key, data);
                });
            }
            return this;
        };
        DBaseStateSetDataImpl.prototype.toArray = function () {
            var result = [];
            this._data.forEach(function (data, key) {
                result.push([data, key]);
            });
            return result;
        };
        DBaseStateSetDataImpl.prototype.toString = function () {
            return JSON.stringify(this.toArray());
        };
        return DBaseStateSetDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    var isFunction = function (target) {
        return typeof target === "function";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isString = function (target) {
        return (typeof target === "string" || Object.prototype.toString.call(target) === "[object String]");
    };

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseStateSetImpl = /** @class */ (function () {
        function DBaseStateSetImpl() {
            this._local = new Set();
            this._parent = null;
        }
        DBaseStateSetImpl.prototype.is = function (state) {
            return this._local.has(state);
        };
        DBaseStateSetImpl.prototype.in = function (state) {
            return this.is(state) || this.under(state);
        };
        DBaseStateSetImpl.prototype.on = function (state) {
            var _a, _b;
            return (_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a.is(state)) !== null && _b !== void 0 ? _b : false;
        };
        DBaseStateSetImpl.prototype.under = function (state) {
            var _a, _b;
            return (_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a.in(state)) !== null && _b !== void 0 ? _b : false;
        };
        DBaseStateSetImpl.prototype.lock = function (callOnChange) {
            return this;
        };
        DBaseStateSetImpl.prototype.unlock = function () {
            return this;
        };
        DBaseStateSetImpl.prototype.begin = function () {
            return this;
        };
        DBaseStateSetImpl.prototype.end = function () {
            return this;
        };
        DBaseStateSetImpl.prototype.checkAdded = function (added) {
            return !this._local.has(added);
        };
        DBaseStateSetImpl.prototype.add = function (state) {
            if (this.checkAdded(state)) {
                this.begin();
                this._local.add(state);
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.checkAddeds = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                if (!local.has(states[i])) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.addAll = function (stateOrStates) {
            var states = isString(stateOrStates)
                ? arguments // eslint-disable-line prefer-rest-params
                : stateOrStates;
            if (this.checkAddeds(states)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = states.length; i < imax; ++i) {
                    local.add(states[i]);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.checkRemoved = function (removed) {
            return this._local.has(removed);
        };
        DBaseStateSetImpl.prototype.remove = function (state) {
            if (this.checkRemoved(state)) {
                this.begin();
                this._local.delete(state);
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.checkRemoveds = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                if (local.has(states[i])) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.removeAll = function (stateOrStatesOrMatcher) {
            var _this = this;
            var local = this._local;
            if (isFunction(stateOrStatesOrMatcher)) {
                var isDirty_1 = false;
                local.forEach(function (state) {
                    if (stateOrStatesOrMatcher(state)) {
                        if (!isDirty_1) {
                            isDirty_1 = true;
                            _this.begin();
                        }
                        local.delete(state);
                    }
                });
                if (isDirty_1) {
                    this.end();
                }
            }
            else {
                var states = isString(stateOrStatesOrMatcher)
                    ? arguments // eslint-disable-line prefer-rest-params
                    : stateOrStatesOrMatcher;
                if (this.checkRemoveds(states)) {
                    this.begin();
                    for (var i = 0, imax = states.length; i < imax; ++i) {
                        local.delete(states[i]);
                    }
                    this.end();
                }
            }
            return this;
        };
        DBaseStateSetImpl.prototype.clear = function () {
            var local = this._local;
            if (0 < local.size) {
                this.begin();
                local.clear();
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.set = function (stateOrAdded, isOnOrRemoved) {
            if (isOnOrRemoved === true) {
                if (stateOrAdded != null) {
                    this.add(stateOrAdded);
                }
            }
            else if (isOnOrRemoved === false) {
                if (stateOrAdded != null) {
                    this.remove(stateOrAdded);
                }
            }
            else {
                var added = stateOrAdded;
                var removed = isOnOrRemoved;
                if (added != null) {
                    if (removed != null) {
                        if (this.checkAdded(added) || this.checkRemoved(removed)) {
                            this.begin();
                            this._local.add(added).delete(removed);
                            this.end();
                        }
                    }
                    else {
                        this.add(added);
                    }
                }
                else if (removed != null) {
                    this.remove(removed);
                }
            }
            return this;
        };
        DBaseStateSetImpl.prototype.setAll = function (statesOrAddeds, isOnOrRemoveds) {
            if (isOnOrRemoveds === true) {
                if (statesOrAddeds != null) {
                    this.addAll(statesOrAddeds);
                }
            }
            else if (isOnOrRemoveds === false) {
                if (statesOrAddeds != null) {
                    this.removeAll(statesOrAddeds);
                }
            }
            else {
                var addeds = statesOrAddeds;
                var removeds = isOnOrRemoveds;
                if (addeds != null) {
                    if (removeds != null) {
                        if (this.checkAddeds(addeds) || this.checkRemoveds(removeds)) {
                            this.begin();
                            var local = this._local;
                            for (var i = 0, imax = addeds.length; i < imax; ++i) {
                                local.add(addeds[i]);
                            }
                            for (var i = 0, imax = removeds.length; i < imax; ++i) {
                                local.delete(removeds[i]);
                            }
                            this.end();
                        }
                    }
                    else {
                        this.addAll(addeds);
                    }
                }
                else if (removeds != null) {
                    this.removeAll(removeds);
                }
            }
            return this;
        };
        DBaseStateSetImpl.prototype.each = function (iteratee) {
            this._local.forEach(function (state) {
                iteratee(state);
            });
            return this;
        };
        DBaseStateSetImpl.prototype.size = function () {
            return this._local.size;
        };
        DBaseStateSetImpl.prototype.copy = function (other) {
            if (other instanceof DBaseStateSetImpl) {
                this.begin();
                var local_1 = this._local;
                local_1.clear();
                other.local.forEach(function (value) {
                    local_1.add(value);
                });
                this._parent = other.parent;
                var otherData = other._data;
                if (otherData != null) {
                    this.data.copy(otherData);
                }
                this.end();
            }
            return this;
        };
        Object.defineProperty(DBaseStateSetImpl.prototype, "local", {
            get: function () {
                return this._local;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                if (this._parent !== parent) {
                    this.begin();
                    this._parent = parent;
                    this.end();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "data", {
            get: function () {
                var result = this._data;
                if (result == null) {
                    result = new DBaseStateSetDataImpl();
                    this._data = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.onParentChange = function (newState, oldState) {
            this._parent = oldState;
            this.begin();
            this._parent = newState;
            this.end();
        };
        Object.defineProperty(DBaseStateSetImpl.prototype, "isHovered", {
            get: function () {
                return this.is(DBaseState.HOVERED);
            },
            set: function (isHovered) {
                this.set(DBaseState.HOVERED, isHovered);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inHovered", {
            get: function () {
                return this.in(DBaseState.HOVERED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onHovered", {
            get: function () {
                return this.on(DBaseState.HOVERED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underHovered", {
            get: function () {
                return this.under(DBaseState.HOVERED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isActive", {
            get: function () {
                return this.is(DBaseState.ACTIVE);
            },
            set: function (isActive) {
                this.set(DBaseState.ACTIVE, isActive);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inActive", {
            get: function () {
                return this.in(DBaseState.ACTIVE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onActive", {
            get: function () {
                return this.on(DBaseState.ACTIVE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underActive", {
            get: function () {
                return this.under(DBaseState.ACTIVE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isPressed", {
            get: function () {
                return this.is(DBaseState.PRESSED);
            },
            set: function (isPressed) {
                this.set(DBaseState.PRESSED, isPressed);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inPressed", {
            get: function () {
                return this.in(DBaseState.PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onPressed", {
            get: function () {
                return this.on(DBaseState.PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underPressed", {
            get: function () {
                return this.under(DBaseState.PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isReadOnly", {
            get: function () {
                return this.is(DBaseState.READ_ONLY);
            },
            set: function (isReadOnly) {
                this.set(DBaseState.READ_ONLY, isReadOnly);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inReadOnly", {
            get: function () {
                return this.in(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onReadOnly", {
            get: function () {
                return this.on(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underReadOnly", {
            get: function () {
                return this.under(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isEnabled", {
            get: function () {
                return !this.is(DBaseState.DISABLED);
            },
            set: function (isEnabled) {
                this.set(DBaseState.DISABLED, !isEnabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inEnabled", {
            get: function () {
                return !this.in(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onEnabled", {
            get: function () {
                return !this.on(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underEnabled", {
            get: function () {
                return !this.under(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isDisabled", {
            get: function () {
                return this.is(DBaseState.DISABLED);
            },
            set: function (isDisabled) {
                this.set(DBaseState.DISABLED, isDisabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inDisabled", {
            get: function () {
                return this.in(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onDisabled", {
            get: function () {
                return this.on(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underDisabled", {
            get: function () {
                return this.under(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isActionable", {
            get: function () {
                return !this.in(DBaseState.DISABLED) && !this.in(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isDragging", {
            get: function () {
                return this.is(DBaseState.DRAGGING);
            },
            set: function (isDragging) {
                this.set(DBaseState.DRAGGING, isDragging);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inDragging", {
            get: function () {
                return this.in(DBaseState.DRAGGING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onDragging", {
            get: function () {
                return this.on(DBaseState.DRAGGING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underDragging", {
            get: function () {
                return this.under(DBaseState.DRAGGING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocused", {
            get: function () {
                return this.is(DBaseState.FOCUSED);
            },
            set: function (isFocused) {
                this.set(DBaseState.FOCUSED, isFocused);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocused", {
            get: function () {
                return this.in(DBaseState.FOCUSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocused", {
            get: function () {
                return this.on(DBaseState.FOCUSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocused", {
            get: function () {
                return this.under(DBaseState.FOCUSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocusRoot", {
            get: function () {
                return this.is(DBaseState.FOCUS_ROOT);
            },
            set: function (isFocusRoot) {
                this.set(DBaseState.FOCUS_ROOT, isFocusRoot);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocusRoot", {
            get: function () {
                return this.in(DBaseState.FOCUS_ROOT);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocusRoot", {
            get: function () {
                return this.on(DBaseState.FOCUS_ROOT);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocusRoot", {
            get: function () {
                return this.under(DBaseState.FOCUS_ROOT);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocusReverse", {
            get: function () {
                return this.is(DBaseState.FOCUS_REVERSE);
            },
            set: function (isFocusReverse) {
                this.set(DBaseState.FOCUS_REVERSE, isFocusReverse);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocusReverse", {
            get: function () {
                return this.in(DBaseState.FOCUS_REVERSE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocusReverse", {
            get: function () {
                return this.on(DBaseState.FOCUS_REVERSE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocusReverse", {
            get: function () {
                return this.under(DBaseState.FOCUS_REVERSE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocusable", {
            get: function () {
                return !this.is(DBaseState.UNFOCUSABLE);
            },
            set: function (isFocusable) {
                this.set(DBaseState.UNFOCUSABLE, !isFocusable);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocusable", {
            get: function () {
                return !this.in(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocusable", {
            get: function () {
                return !this.on(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocusable", {
            get: function () {
                return !this.under(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isUnfocusable", {
            get: function () {
                return this.is(DBaseState.UNFOCUSABLE);
            },
            set: function (unfocusable) {
                this.set(DBaseState.UNFOCUSABLE, unfocusable);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inUnfocusable", {
            get: function () {
                return this.in(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onUnfocusable", {
            get: function () {
                return this.on(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underUnfocusable", {
            get: function () {
                return this.under(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isInvalid", {
            get: function () {
                return this.is(DBaseState.INVALID);
            },
            set: function (invalid) {
                this.set(DBaseState.INVALID, invalid);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inInvalid", {
            get: function () {
                return this.in(DBaseState.INVALID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onInvalid", {
            get: function () {
                return this.on(DBaseState.INVALID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underInvalid", {
            get: function () {
                return this.on(DBaseState.INVALID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isSucceeded", {
            get: function () {
                return this.is(DBaseState.SUCCEEDED);
            },
            set: function (succeeded) {
                this.set(DBaseState.SUCCEEDED, succeeded);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inSucceeded", {
            get: function () {
                return this.in(DBaseState.SUCCEEDED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onSucceeded", {
            get: function () {
                return this.on(DBaseState.SUCCEEDED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underSucceeded", {
            get: function () {
                return this.under(DBaseState.SUCCEEDED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFailed", {
            get: function () {
                return this.is(DBaseState.FAILED);
            },
            set: function (failed) {
                this.set(DBaseState.FAILED, failed);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFailed", {
            get: function () {
                return this.in(DBaseState.FAILED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFailed", {
            get: function () {
                return this.on(DBaseState.FAILED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFailed", {
            get: function () {
                return this.under(DBaseState.FAILED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isWarned", {
            get: function () {
                return this.is(DBaseState.WARNED);
            },
            set: function (isWarned) {
                this.set(DBaseState.WARNED, isWarned);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inWarned", {
            get: function () {
                return this.in(DBaseState.WARNED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onWarned", {
            get: function () {
                return this.on(DBaseState.WARNED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underWarned", {
            get: function () {
                return this.on(DBaseState.WARNED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isChanged", {
            get: function () {
                return this.is(DBaseState.CHANGED);
            },
            set: function (isChanged) {
                this.set(DBaseState.CHANGED, isChanged);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inChanged", {
            get: function () {
                return this.in(DBaseState.CHANGED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onChanged", {
            get: function () {
                return this.on(DBaseState.CHANGED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underChanged", {
            get: function () {
                return this.on(DBaseState.CHANGED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isAlternated", {
            get: function () {
                return this.is(DBaseState.ALTERNATED);
            },
            set: function (isAlternated) {
                this.set(DBaseState.ALTERNATED, isAlternated);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inAlternated", {
            get: function () {
                return this.in(DBaseState.ALTERNATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onAlternated", {
            get: function () {
                return this.on(DBaseState.ALTERNATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underAlternated", {
            get: function () {
                return this.on(DBaseState.ALTERNATED);
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.toObject = function () {
            var _a, _b;
            var states = [];
            this._local.forEach(function (value) {
                states.push(value);
            });
            return {
                local: states,
                data: (_b = (_a = this._data) === null || _a === void 0 ? void 0 : _a.toArray()) !== null && _b !== void 0 ? _b : []
            };
        };
        DBaseStateSetImpl.prototype.toString = function () {
            return JSON.stringify(this.toObject());
        };
        return DBaseStateSetImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseStateSetImplObservable = /** @class */ (function (_super) {
        __extends(DBaseStateSetImplObservable, _super);
        function DBaseStateSetImplObservable(onChange) {
            var _this = _super.call(this) || this;
            _this._onChange = onChange;
            _this._isLocked = 0;
            _this._isSaved = false;
            _this._doSave = true;
            return _this;
        }
        DBaseStateSetImplObservable.prototype.lock = function (callOnChange) {
            this._isLocked += 1;
            if (callOnChange === false) {
                this._doSave = false;
            }
            return this;
        };
        DBaseStateSetImplObservable.prototype.unlock = function () {
            this._isLocked -= 1;
            return this.end();
        };
        Object.defineProperty(DBaseStateSetImplObservable.prototype, "saved", {
            get: function () {
                var result = this._saved;
                if (result == null) {
                    result = new DBaseStateSetImpl();
                    this._saved = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImplObservable.prototype.begin = function () {
            if (this._doSave && !this._isSaved) {
                this._isSaved = true;
                this.saved.copy(this);
            }
            return this;
        };
        DBaseStateSetImplObservable.prototype.end = function () {
            if (this._isLocked <= 0) {
                this._doSave = true;
                if (this._isSaved) {
                    this._isSaved = false;
                    this._onChange(this, this.saved);
                }
            }
            return this;
        };
        return DBaseStateSetImplObservable;
    }(DBaseStateSetImpl));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeState = {
        CLICKED: "CLICKED",
        DOWN: "DOWN",
        UP: "UP"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStateSetImplObservable = /** @class */ (function (_super) {
        __extends(EShapeStateSetImplObservable, _super);
        function EShapeStateSetImplObservable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isClicked", {
            get: function () {
                return this.is(EShapeState.CLICKED);
            },
            set: function (isClicked) {
                this.set(EShapeState.CLICKED, isClicked);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inClicked", {
            get: function () {
                return this.in(EShapeState.CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onClicked", {
            get: function () {
                return this.on(EShapeState.CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underClicked", {
            get: function () {
                return this.under(EShapeState.CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isDown", {
            get: function () {
                return this.is(EShapeState.DOWN);
            },
            set: function (isDown) {
                this.set(EShapeState.DOWN, isDown);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inDown", {
            get: function () {
                return this.in(EShapeState.DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onDown", {
            get: function () {
                return this.on(EShapeState.DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underDown", {
            get: function () {
                return this.under(EShapeState.DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isUp", {
            get: function () {
                return this.is(EShapeState.UP);
            },
            set: function (isUp) {
                this.set(EShapeState.UP, isUp);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inUp", {
            get: function () {
                return this.in(EShapeState.UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onUp", {
            get: function () {
                return this.on(EShapeState.UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underUp", {
            get: function () {
                return this.under(EShapeState.UP);
            },
            enumerable: false,
            configurable: true
        });
        return EShapeStateSetImplObservable;
    }(DBaseStateSetImplObservable));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTransformImpl = /** @class */ (function (_super) {
        __extends(EShapeTransformImpl, _super);
        function EShapeTransformImpl(parent) {
            var _this = _super.call(this) || this;
            _this.internalTransform = new pixi_js.Matrix();
            _this._parent = parent;
            return _this;
        }
        EShapeTransformImpl.prototype.onChange = function () {
            _super.prototype.onChange.call(this);
            this._parent.onTransformChange();
        };
        EShapeTransformImpl.prototype.updateSkew = function () {
            _super.prototype.updateSkew.call(this);
            this._parent.onTransformChange();
        };
        EShapeTransformImpl.prototype.getLocalIdCurrent = function () {
            return this._currentLocalID;
        };
        EShapeTransformImpl.prototype.getLocalId = function () {
            return this._localID;
        };
        EShapeTransformImpl.prototype.getParentId = function () {
            return this._parentID;
        };
        EShapeTransformImpl.prototype.getWorldId = function () {
            return this._worldID;
        };
        EShapeTransformImpl.prototype.updateTransform = function (parentTransform) {
            var oldLocalId = this._currentLocalID;
            var oldWorldId = this._worldID;
            _super.prototype.updateTransform.call(this, parentTransform);
            var newLocalId = this._currentLocalID;
            var newWorldId = this._worldID;
            if (oldLocalId !== newLocalId) {
                var localTransform = this.localTransform;
                var internalTransform = this.internalTransform;
                localTransform.copyTo(internalTransform);
                if (parentTransform instanceof EShapeTransformImpl) {
                    internalTransform.prepend(parentTransform.internalTransform);
                }
            }
            else if (oldWorldId !== newWorldId) {
                var localTransform = this.localTransform;
                var internalTransform = this.internalTransform;
                if (parentTransform instanceof EShapeTransformImpl) {
                    localTransform.copyTo(internalTransform).prepend(parentTransform.internalTransform);
                    this._currentLocalID += 1;
                    this._localID = this._currentLocalID;
                }
            }
        };
        return EShapeTransformImpl;
    }(pixi_js.Transform));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBaseHitTestData = /** @class */ (function () {
        function EShapeBaseHitTestData() {
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            this.strokeWidth = 0;
            this.strokeScale = 1;
        }
        EShapeBaseHitTestData.prototype.set = function (x, y, width, height, strokeWidth, strokeScale) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.strokeWidth = strokeWidth;
            this.strokeScale = strokeScale;
            return this;
        };
        return EShapeBaseHitTestData;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSvgUrl = function (svg) {
        return "data:image/svg+xml;base64," + btoa(svg);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toPadded = function (str, length, c) {
        var strLength = str.length;
        if (length < strLength) {
            return str;
        }
        var padding = "";
        for (var i = 0, imax = length - strLength; i < imax; ++i) {
            padding += c;
        }
        return padding + str;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilRgb = /** @class */ (function () {
        function UtilRgb() {
        }
        UtilRgb.toCode = function (color) {
            return toPadded(color.toString(16).toUpperCase(), 6, "0");
        };
        UtilRgb.fromCode = function (code) {
            var trimmed = code.trim().toLowerCase();
            if (trimmed.length === 6) {
                var color = Number("0x" + trimmed);
                if (color === color) {
                    return color;
                }
            }
            return null;
        };
        UtilRgb.fromRgb = function (r, g, b) {
            return ((r * 0xff) << 16) + ((g * 0xff) << 8) + ((b * 0xff) | 0);
        };
        UtilRgb.blend = function (colorA, colorB, t) {
            var ar = (colorA >> 16) & 0xff;
            var ag = (colorA >> 8) & 0xff;
            var ab = (colorA | 0) & 0xff;
            var br = (colorB >> 16) & 0xff;
            var bg = (colorB >> 8) & 0xff;
            var bb = (colorB | 0) & 0xff;
            var w1 = Math.max(0, Math.min(1, t));
            var w0 = 1 - w1;
            var cr = Math.max(0, Math.min(0xff, ar * w0 + br * w1));
            var cg = Math.max(0, Math.min(0xff, ag * w0 + bg * w1));
            var cb = Math.max(0, Math.min(0xff, ab * w0 + bb * w1));
            return (cr << 16) + (cg << 8) + (cb | 0);
        };
        UtilRgb.brighten = function (color, amount) {
            return this.blend(color, 0xffffff, amount);
        };
        UtilRgb.darken = function (color, amount) {
            return this.blend(color, 0x000000, amount);
        };
        return UtilRgb;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGradients = /** @class */ (function () {
        function EShapeGradients() {
        }
        EShapeGradients.serializeGradient = function (gradient) {
            var points = gradient.points;
            var result = "[" + gradient.direction;
            for (var i = 0, imax = points.length, j = 1; i < imax; i += 1, j += 3) {
                var point = points[i];
                result += "," + point.color + "," + point.alpha + "," + point.position;
            }
            result += "]";
            return result;
        };
        EShapeGradients.parseGradient = function (target) {
            try {
                return JSON.parse(target);
            }
            catch (e) {
                return null;
            }
        };
        EShapeGradients.deserializeGradient = function (target) {
            var parsed = this.parseGradient(target);
            if (parsed == null || parsed.length < 7) {
                return undefined;
            }
            else {
                var direction = parsed[0];
                var points = [];
                for (var i = 1, imax = parsed.length; i < imax; i += 3) {
                    points.push({
                        color: parsed[i + 0],
                        alpha: parsed[i + 1],
                        position: parsed[i + 2]
                    });
                }
                return {
                    points: points,
                    direction: direction
                };
            }
        };
        EShapeGradients.toGradientId = function (gradient, manager) {
            if (gradient != null) {
                if (gradient.serialized == null) {
                    gradient.serialized = this.serializeGradient(gradient);
                }
                return manager.addResource(gradient.serialized);
            }
            return -1;
        };
        EShapeGradients.toGradientImageUrl = function (gradient) {
            var direction = gradient.direction;
            var points = gradient.points;
            var stops = "";
            for (var i = 0, imax = points.length; i < imax; ++i) {
                var point = points[i];
                var color = UtilRgb.toCode(point.color);
                var alpha = point.alpha;
                var offset = point.position * 100;
                stops += "<stop offset=\"" + offset + "%\" stop-color=\"#" + color + "\" stop-opacity=\"" + alpha + "\" />";
            }
            var radian = (direction * Math.PI) / 180;
            var dx = 0.5 * Math.cos(radian);
            var dy = -0.5 * Math.sin(radian);
            var url = toSvgUrl(
            /* eslint-disable prettier/prettier */
            "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">" +
                "<defs>" +
                ("<linearGradient id=\"o2glkm3aeu2oio\" x1=\"" + (0.5 - dx) + "\" x2=\"" + (0.5 + dx) + "\" y1=\"" + (0.5 - dy) + "\" y2=\"" + (0.5 + dy) + "\">") +
                stops +
                "</linearGradient>" +
                "</defs>" +
                "<rect x=\"0\" y=\"0\" width=\"32\" height=\"32\" stroke=\"none\" fill=\"url(#o2glkm3aeu2oio)\" />" +
                "</svg>"
            /* eslint-enable prettier/prettier */
            );
            return url;
        };
        return EShapeGradients;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBase = /** @class */ (function (_super) {
        __extends(EShapeBase, _super);
        function EShapeBase(type) {
            var _this = _super.call(this) || this;
            _this.id = "";
            _this.uuid = 0;
            _this.type = type;
            _this.transform = _this.newTransform();
            _this._onTransformChangeLock = 0;
            _this._isOnTransformChanged = false;
            _this.action = new EShapeAction();
            _this._visible = true;
            _this._uploadedUpdateLock = 0;
            _this._isUploadedUpdated = false;
            _this._isUploadedUpdatedRecursively = false;
            _this._boundsTransformId = NaN;
            _this._boundsInternalTransformId = NaN;
            _this._boundsLocalTransformId = NaN;
            _this.interactive = false;
            //
            _this.parent = null;
            _this.children = [];
            //
            _this.selected = false;
            _this.index = 0;
            _this.reference = 0;
            return _this;
        }
        EShapeBase.prototype.newTransform = function () {
            return new EShapeTransformImpl(this);
        };
        EShapeBase.prototype.onSizeChange = function () {
            this._boundsTransformId = NaN;
            this._boundsInternalTransformId = NaN;
            this._boundsLocalTransformId = NaN;
            this.onTransformChange_();
            this.updateUploaded();
        };
        EShapeBase.prototype.onTransformChange = function () {
            this.onTransformChange_();
            this.updateUploadedRecursively();
        };
        EShapeBase.prototype.onTransformChange_ = function () {
            if (this._onTransformChangeLock === 0) {
                var parent_1 = this.parent;
                if (parent_1 != null) {
                    parent_1.onChildTransformChange();
                }
            }
            else {
                this._isOnTransformChanged = true;
            }
        };
        EShapeBase.prototype.disallowOnTransformChange = function () {
            this._onTransformChangeLock += 1;
            if (this._onTransformChangeLock === 1) {
                this._isOnTransformChanged = false;
            }
        };
        EShapeBase.prototype.allowOnTransformChange = function (invokeOnTransformChange) {
            this._onTransformChangeLock -= 1;
            if (this._onTransformChangeLock === 0) {
                if (this._isOnTransformChanged) {
                    this._isOnTransformChanged = false;
                    if (invokeOnTransformChange) {
                        this.onTransformChange();
                    }
                }
            }
        };
        EShapeBase.prototype.onChildTransformChange = function () {
            //
        };
        EShapeBase.prototype.disallowUploadedUpdate = function () {
            this._uploadedUpdateLock += 1;
            if (this._uploadedUpdateLock === 1) {
                this._isUploadedUpdated = false;
                this._isUploadedUpdatedRecursively = false;
            }
        };
        EShapeBase.prototype.allowUploadedUpdate = function () {
            this._uploadedUpdateLock -= 1;
            if (this._uploadedUpdateLock === 0) {
                if (this._isUploadedUpdatedRecursively) {
                    this._isUploadedUpdatedRecursively = false;
                    this._isUploadedUpdated = false;
                    this.updateUploadedRecursively();
                }
                else if (this._isUploadedUpdated) {
                    this._isUploadedUpdated = false;
                    this.updateUploaded();
                }
            }
        };
        EShapeBase.prototype.updateUploadedRecursively = function () {
            if (this._uploadedUpdateLock === 0) {
                this.updateUploaded();
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].updateUploadedRecursively();
                }
            }
            else {
                this._isUploadedUpdatedRecursively = true;
            }
        };
        EShapeBase.prototype.updateUploaded = function () {
            if (this._uploadedUpdateLock === 0) {
                var uploaded = this.uploaded;
                if (uploaded != null) {
                    uploaded.update(this);
                }
            }
            else {
                this._isUploadedUpdated = true;
            }
        };
        Object.defineProperty(EShapeBase.prototype, "image", {
            get: function () {
                return this._image;
            },
            set: function (image) {
                this._image = image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "root", {
            //
            get: function () {
                var root = this;
                while (root.parent instanceof EShapeBase) {
                    root = root.parent;
                }
                return root;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "visible", {
            //
            get: function () {
                if (this._visible) {
                    var parent_2 = this.parent;
                    if (parent_2 instanceof EShapeBase) {
                        return parent_2.visible;
                    }
                    return true;
                }
                return false;
            },
            set: function (visible) {
                if (this._visible !== visible) {
                    this._visible = visible;
                    this.updateUploadedRecursively();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "worldVisible", {
            get: function () {
                if (this._visible) {
                    var parent_3 = this.parent;
                    if (parent_3) {
                        return parent_3.worldVisible;
                    }
                    return true;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        //
        EShapeBase.prototype.toDirty = function () {
            var _a;
            (_a = this.parent) === null || _a === void 0 ? void 0 : _a.toDirty();
        };
        // Hierarchy
        EShapeBase.prototype.attach = function (parent, at) {
            this.detach();
            this.parent = parent;
            var children = parent.children;
            if (at != null && 0 <= at && at < children.length) {
                children.splice(at, 0, this);
            }
            else {
                children.push(this);
            }
            this.uploaded = undefined;
            parent.onChildTransformChange();
            parent.toDirty();
            return this;
        };
        EShapeBase.prototype.detach = function () {
            var parent = this.parent;
            if (parent) {
                this.parent = null;
                this.uploaded = undefined;
                var children = parent.children;
                var index = children.indexOf(this);
                if (0 <= index) {
                    children.splice(index, 1);
                    parent.onChildTransformChange();
                    parent.toDirty();
                }
            }
            return this;
        };
        // Transform
        EShapeBase.prototype.updateTransform = function () {
            var parent = this.parent;
            if (parent) {
                if (parent.parent) {
                    parent.updateTransform();
                }
                this.transform.updateTransform(parent.transform);
            }
            else {
                this.transform.updateTransform(pixi_js.Transform.IDENTITY);
            }
        };
        // Serialization
        EShapeBase.prototype.serializeChildren = function (manager) {
            var children = this.children;
            var childrenSerialized = [];
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                childrenSerialized.push(child.serialize(manager));
            }
            return childrenSerialized;
        };
        EShapeBase.prototype.serializeImage = function (manager) {
            var image = this._image;
            return image != null ? manager.addResource(image.src) : -1;
        };
        EShapeBase.prototype.serializeGradient = function (manager) {
            return EShapeGradients.toGradientId(this.gradient, manager);
        };
        EShapeBase.prototype.serialize = function (manager) {
            var transform = this.transform;
            var position = transform.position;
            var pivot = transform.pivot;
            var size = this.size;
            var shortcut = this.shortcut;
            var shortcutId = shortcut != null ? manager.addResource(shortcut) : -1;
            var title = this.title;
            var titleId = title != null ? manager.addResource(title) : -1;
            return [
                this.type,
                manager.addResource(this.id),
                position.x,
                position.y,
                size.x,
                size.y,
                transform.rotation,
                transform.skew.x,
                this.fill.serialize(manager),
                this.stroke.serialize(manager),
                manager.addResource(this.cursor.trim()),
                this.text.serialize(manager),
                this.tag.serialize(manager),
                this.radius,
                this.corner,
                -1,
                -1,
                this.action.serialize(manager),
                this.serializeImage(manager),
                this.serializeGradient(manager),
                this.serializeChildren(manager),
                pivot.x,
                pivot.y,
                (this.interactive ? 1 : 0) | (this.state.isFocusable ? 0 : 2),
                shortcutId,
                titleId,
                this.uuid
            ];
        };
        EShapeBase.prototype.addUuid = function (manager) {
            this.uuid = manager.addUuid(this.uuid);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
        };
        EShapeBase.prototype.updateUuid = function (manager) {
            this.uuid = manager.updateUuid(this.uuid);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
        };
        // Hit test
        EShapeBase.prototype.getShapeScale = function () {
            var container = this.root.parent;
            if (container != null && container.getShapeScale != null) {
                return container.getShapeScale();
            }
            return 1.0;
        };
        EShapeBase.prototype.getStrokeWidthScale = function (style) {
            if (style & EShapeStrokeStyle.NON_EXPANDING_WIDTH) {
                if (style & EShapeStrokeStyle.NON_SHRINKING_WIDTH) {
                    return this.getShapeScale();
                }
                else {
                    return Math.min(1.0, this.getShapeScale());
                }
            }
            else {
                if (style & EShapeStrokeStyle.NON_SHRINKING_WIDTH) {
                    return Math.max(1.0, this.getShapeScale());
                }
                else {
                    return 1.0;
                }
            }
        };
        EShapeBase.prototype.getHitTestSize = function (result) {
            var size = this.size;
            result.width = 0.5 * size.x;
            result.height = 0.5 * size.y;
            return result;
        };
        EShapeBase.prototype.toHitTestData = function (point) {
            var _a;
            var x = point.x;
            var y = point.y;
            var result = this.getHitTestSize(((_a = EShapeBase.WORK_HIT_TEST_DATA) !== null && _a !== void 0 ? _a : (EShapeBase.WORK_HIT_TEST_DATA = new EShapeBaseHitTestData())));
            var sx = result.width;
            var sy = result.height;
            var pivot = this.transform.pivot;
            var dx = x - pivot.x;
            var dy = y - pivot.y;
            var stroke = this.stroke;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeScale = this.getStrokeWidthScale(stroke.style);
            var s = strokeWidth * strokeScale * stroke.align;
            return result.set(0 <= sx ? +dx : -dx, 0 <= sy ? +dy : -dy, Math.abs(sx) + s, Math.abs(sy) + s, strokeWidth, strokeScale);
        };
        EShapeBase.prototype.contains = function (point) {
            var data = this.toHitTestData(point);
            if (this.containsAbs(data.x, data.y, data.width, data.height, data.strokeWidth, data.strokeScale)) {
                return this;
            }
            var x = point.x;
            var y = point.y;
            return this.containsText(x, y, point) || this.containsChildren(x, y, point);
        };
        EShapeBase.prototype.containsText = function (x, y, work) {
            var text = this.text;
            var textAtlas = text.atlas;
            if (textAtlas != null) {
                var textWorld = text.world;
                if (textWorld != null) {
                    work.set(x, y);
                    this.transform.internalTransform.apply(work, work);
                    var tx = work.x - textWorld[0];
                    var ty = work.y - textWorld[1];
                    var th = textWorld[2] * tx + textWorld[3] * ty;
                    var tv = textWorld[4] * tx + textWorld[5] * ty;
                    if (0 <= th && th <= textWorld[6] && 0 <= tv && tv <= textWorld[7]) {
                        return this;
                    }
                }
            }
            return null;
        };
        EShapeBase.prototype.containsChildren = function (x, y, work) {
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                work.set(x, y);
                child.updateTransform();
                child.transform.localTransform.applyInverse(work, work);
                var childResult = child.contains(work);
                if (childResult != null) {
                    return childResult;
                }
            }
            return null;
        };
        EShapeBase.prototype.containsBBox = function (point) {
            var data = this.toHitTestData(point);
            return this.containsAbsBBox(data.x, data.y, data.width, data.height);
        };
        EShapeBase.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            return this.containsAbsBBox(x, y, ax, ay);
        };
        EShapeBase.prototype.containsAbsBBox = function (x, y, ax, ay) {
            return -ax <= x && x <= +ax && -ay <= y && y <= +ay;
        };
        EShapeBase.prototype.select = function (point) {
            return false;
        };
        //
        EShapeBase.prototype.toGlobal = function (position, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            result.copyFrom(position);
            this.transform.worldTransform.apply(result, result);
            return result;
        };
        EShapeBase.prototype.toLocal = function (position, from, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            if (result === undefined) {
                result = new pixi_js.Point();
            }
            result.copyFrom(position);
            this.transform.worldTransform.applyInverse(result, result);
            return result;
        };
        EShapeBase.prototype.getBounds = function (work, skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var bounds = this._bounds || new pixi_js.Rectangle();
            this._bounds = bounds;
            var worldId = this.transform.getWorldId();
            if (worldId !== this._boundsTransformId) {
                this._boundsTransformId = worldId;
                this.getBounds_(this.transform.worldTransform, work, bounds);
            }
            result.copyFrom(bounds);
            return result;
        };
        EShapeBase.prototype.getBoundsInternal = function (work, skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var boundsInternal = this._boundsInternal || new pixi_js.Rectangle();
            this._boundsInternal = boundsInternal;
            var currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsInternalTransformId) {
                this._boundsInternalTransformId = currentLocalId;
                this.getBounds_(this.transform.internalTransform, work, boundsInternal);
            }
            result.copyFrom(boundsInternal);
            return result;
        };
        EShapeBase.prototype.getBoundsLocal = function (work, skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var boundsLocal = this._boundsLocal || new pixi_js.Rectangle();
            this._boundsLocal = boundsLocal;
            var currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsLocalTransformId) {
                this._boundsLocalTransformId = currentLocalId;
                this.getBounds_(this.transform.localTransform, work, boundsLocal);
            }
            result.copyFrom(boundsLocal);
            return result;
        };
        EShapeBase.prototype.getBoundsSize = function () {
            return this.size;
        };
        EShapeBase.prototype.getBounds_ = function (transform, work, result) {
            var pivot = this.transform.pivot;
            var px = pivot.x;
            var py = pivot.y;
            var size = this.getBoundsSize();
            var sx = 0.5 * size.x;
            var sy = 0.5 * size.y;
            var a = transform.a;
            var b = transform.b;
            var c = transform.c;
            var d = transform.d;
            var x = -sx + px;
            var y = -sy + py;
            var x0 = a * x + c * y;
            var y0 = b * x + d * y;
            x = +sx + px;
            y = -sy + py;
            var x1 = a * x + c * y;
            var y1 = b * x + d * y;
            x = -sx + px;
            y = +sy + py;
            var x2 = a * x + c * y;
            var y2 = b * x + d * y;
            x = +sx + px;
            y = +sy + py;
            var x3 = a * x + c * y;
            var y3 = b * x + d * y;
            var xmin = Math.min(x0, x1, x2, x3);
            var ymin = Math.min(y0, y1, y2, y3);
            var xmax = Math.max(x0, x1, x2, x3);
            var ymax = Math.max(y0, y1, y2, y3);
            result.x = xmin + transform.tx;
            result.y = ymin + transform.ty;
            result.width = xmax - xmin;
            result.height = ymax - ymin;
            return result;
        };
        //
        EShapeBase.prototype.destroy = function () {
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
        };
        //
        EShapeBase.prototype.onStateChange = function (newState, oldState) {
            var _a;
            (_a = this.runtime) === null || _a === void 0 ? void 0 : _a.onStateChange(this, newState, oldState);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof EShapeBase) {
                    child.state.onParentChange(newState, oldState);
                }
            }
        };
        Object.defineProperty(EShapeBase.prototype, "state", {
            get: function () {
                var _this = this;
                var result = this._state;
                if (result == null) {
                    result = new EShapeStateSetImplObservable(function (newState, oldState) {
                        _this.onStateChange(newState, oldState);
                    });
                    this._state = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBase.prototype.focus = function () {
            this.setFocused(true);
            return this;
        };
        EShapeBase.prototype.blur = function () {
            this.setFocused(false);
            return this;
        };
        EShapeBase.prototype.setFocused = function (isFocused) {
            if (this.state.isFocused !== isFocused) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().set(this, isFocused);
                }
            }
        };
        Object.defineProperty(EShapeBase.prototype, "shadowed", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBase.prototype.onKeyDown = function (e) {
            var runtime = this.runtime;
            if (runtime) {
                return runtime.onKeyDown(this, e);
            }
            return false;
        };
        EShapeBase.prototype.onKeyUp = function (e) {
            var runtime = this.runtime;
            if (runtime) {
                return runtime.onKeyUp(this, e);
            }
            return false;
        };
        //
        EShapeBase.prototype.update = function (time) {
            var runtime = this.runtime;
            if (runtime) {
                runtime.update(this, time);
            }
        };
        EShapeBase.prototype.onRender = function (time, renderer) {
            var runtime = this.runtime;
            if (runtime) {
                runtime.onRender(this, time, renderer);
            }
        };
        EShapeBase.prototype.updateRecursively = function (time) {
            this.update(time);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].update(time);
            }
        };
        EShapeBase.prototype.copy = function (source, part) {
            if (part === void 0) { part = EShapeCopyPart.ALL; }
            this.id = source.id;
            this.uuid = source.uuid;
            if (part & EShapeCopyPart.TRANSFORM) {
                var transform = this.transform;
                var sourceTransform = source.transform;
                transform.position.copyFrom(sourceTransform.position);
                transform.rotation = sourceTransform.rotation;
                transform.skew.copyFrom(sourceTransform.skew);
                transform.pivot.copyFrom(sourceTransform.pivot);
                transform.scale.copyFrom(sourceTransform.scale);
            }
            if (part & EShapeCopyPart.SIZE) {
                this.size.copyFrom(source.size);
            }
            if (part & EShapeCopyPart.STYLE) {
                this.fill.copy(source.fill);
                this.stroke.copy(source.stroke);
                this.text.copy(source.text);
                this.radius = source.radius;
                this.corner = source.corner;
            }
            if (part & EShapeCopyPart.TAG) {
                this.tag.copy(source.tag);
            }
            if (part & EShapeCopyPart.IMAGE) {
                this.image = source.image;
            }
            if (part & EShapeCopyPart.ACTION) {
                this.action.clearAndAddAll(source.action.values);
                this.interactive = source.interactive;
                this.cursor = source.cursor;
                this.shortcut = source.shortcut;
            }
            if (part & EShapeCopyPart.POINTS) {
                var sourcePoints = source.points;
                if (sourcePoints != null) {
                    var points = this.points;
                    if (points != null) {
                        points.copy(sourcePoints);
                    }
                }
            }
            if (part & EShapeCopyPart.STATE) {
                this.state.lock(false).copy(source.state).unlock();
            }
            return this;
        };
        return EShapeBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeFillImpl = /** @class */ (function () {
        function EShapeFillImpl(parent, enable, color, alpha) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
        }
        Object.defineProperty(EShapeFillImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeFillImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeFillImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeFillImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha);
            }
        };
        EShapeFillImpl.prototype.set = function (enable, color, alpha) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeFillImpl.prototype.clone = function () {
            return new EShapeFillImpl(this._parent, this._enable, this._color, this._alpha);
        };
        EShapeFillImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha
            };
        };
        EShapeFillImpl.prototype.serialize = function (manager) {
            var stringified = "[" + (this._enable ? 1 : 0) + "," + this._color + "," + this._alpha + "]";
            return manager.addResource(stringified);
        };
        EShapeFillImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getFill(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setFill(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2]);
                }
            }
        };
        return EShapeFillImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStrokeImpl = /** @class */ (function () {
        function EShapeStrokeImpl(parent, enable, color, alpha, width, align, side, style) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
            this._align = align;
            this._side = side;
            this._style = style;
        }
        Object.defineProperty(EShapeStrokeImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "side", {
            get: function () {
                return this._side;
            },
            set: function (side) {
                if (this._side !== side) {
                    this._side = side;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                if (this._style !== style) {
                    this._style = style;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeStrokeImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width, target.align, target.side, target.style);
            }
        };
        EShapeStrokeImpl.prototype.set = function (enable, color, alpha, width, align, side, style) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (align !== undefined && this._align !== align) {
                this._align = align;
                isChanged = true;
            }
            if (side !== undefined && this._side !== side) {
                this._side = side;
                isChanged = true;
            }
            if (style !== undefined && this._style !== style) {
                this._style = style;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeStrokeImpl.prototype.clone = function () {
            return new EShapeStrokeImpl(this._parent, this._enable, this._color, this._alpha, this._width, this._align, this._side, this._style);
        };
        EShapeStrokeImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width,
                align: this._align,
                side: this._side,
                style: this._style
            };
        };
        EShapeStrokeImpl.prototype.serialize = function (manager) {
            var enable = this._enable ? 1 : 0;
            var serialized = "[" + enable + "," + this._color + "," + this._alpha + "," + this._width + "," + this._align + "," + this._side + "," + this._style + "]";
            return manager.addResource(serialized);
        };
        EShapeStrokeImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getStroke(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2], parsed[3], parsed[4], parsed[5], parsed[6]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setStroke(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2], deserialized[3], deserialized[4], deserialized[5], deserialized[6]);
                }
            }
        };
        return EShapeStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTagValueOrder;
    (function (EShapeTagValueOrder) {
        EShapeTagValueOrder[EShapeTagValueOrder["ASCENDING"] = 0] = "ASCENDING";
        EShapeTagValueOrder[EShapeTagValueOrder["DESCENDING"] = 1] = "DESCENDING";
    })(EShapeTagValueOrder || (EShapeTagValueOrder = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTagValueRangeType;
    (function (EShapeTagValueRangeType) {
        EShapeTagValueRangeType[EShapeTagValueRangeType["NONE"] = 0] = "NONE";
        EShapeTagValueRangeType[EShapeTagValueRangeType["FROM"] = 1] = "FROM";
        EShapeTagValueRangeType[EShapeTagValueRangeType["TO"] = 2] = "TO";
        EShapeTagValueRangeType[EShapeTagValueRangeType["FROM_TO"] = 3] = "FROM_TO";
    })(EShapeTagValueRangeType || (EShapeTagValueRangeType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTagValueRangeImpl = /** @class */ (function () {
        function EShapeTagValueRangeImpl() {
            this._type = EShapeTagValueRangeType.NONE;
            this._from = 0;
            this._to = 1;
        }
        Object.defineProperty(EShapeTagValueRangeImpl.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (type) {
                if (this._type !== type) {
                    this._type = type;
                    var parent_1 = this.parent;
                    if (parent_1 != null) {
                        parent_1.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueRangeImpl.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                if (this._from !== from) {
                    this._from = from;
                    var parent_2 = this.parent;
                    if (parent_2 != null) {
                        parent_2.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueRangeImpl.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                if (this._to !== to) {
                    this._to = to;
                    var parent_3 = this.parent;
                    if (parent_3 != null) {
                        parent_3.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTagValueRangeImpl.prototype.set = function (from, to) {
            var result = false;
            if (from !== undefined && to !== undefined) {
                if (from !== null && to !== null) {
                    var type = this._type | EShapeTagValueRangeType.FROM | EShapeTagValueRangeType.TO;
                    if (this._type !== type || this._from !== from || this._to !== to) {
                        this._type = type;
                        this._from = from;
                        this._to = to;
                        result = true;
                    }
                }
                else if (from !== null) {
                    var type = (this._type | EShapeTagValueRangeType.FROM) & ~EShapeTagValueRangeType.TO;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else if (to !== null) {
                    var type = (this._type | EShapeTagValueRangeType.TO) & ~EShapeTagValueRangeType.FROM;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    var type = this._type & ~(EShapeTagValueRangeType.TO | EShapeTagValueRangeType.FROM);
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (from !== undefined) {
                if (from !== null) {
                    var type = this._type | EShapeTagValueRangeType.FROM;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else {
                    var type = this._type & ~EShapeTagValueRangeType.FROM;
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (to !== undefined) {
                if (to !== null) {
                    var type = this._type | EShapeTagValueRangeType.TO;
                    if (this._type !== type || this._to !== to) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    var type = this._type & ~EShapeTagValueRangeType.TO;
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            if (result) {
                var parent_4 = this.parent;
                if (parent_4 != null) {
                    parent_4.isChanged = true;
                }
            }
            return result;
        };
        EShapeTagValueRangeImpl.prototype.normalize = function (value) {
            var type = this._type;
            var from = this._from;
            var to = this._to;
            switch (type) {
                case EShapeTagValueRangeType.FROM_TO:
                    return (value - from) / (to - from);
                case EShapeTagValueRangeType.FROM:
                    return value - from;
                case EShapeTagValueRangeType.TO:
                    return to - value;
                case EShapeTagValueRangeType.NONE:
                default:
                    return value;
            }
        };
        EShapeTagValueRangeImpl.prototype.isEquals = function (target) {
            return this._type === target.type && this._from === target.from && this._to === target.to;
        };
        EShapeTagValueRangeImpl.prototype.copy = function (target) {
            return this.copy_(target.type, target.from, target.to);
        };
        EShapeTagValueRangeImpl.prototype.copy_ = function (type, from, to) {
            var isChanged = false;
            if (this._type !== type) {
                this._type = type;
                isChanged = true;
            }
            if (this._from !== from) {
                this._from = from;
                isChanged = true;
            }
            if (this._to !== to) {
                this._to = to;
                isChanged = true;
            }
            if (isChanged) {
                var parent_5 = this.parent;
                if (parent_5 != null) {
                    parent_5.isChanged = true;
                }
            }
            return this;
        };
        EShapeTagValueRangeImpl.prototype.toObject = function () {
            return {
                type: this.type,
                from: this.from,
                to: this.to
            };
        };
        EShapeTagValueRangeImpl.prototype.serialize = function (manager) {
            var serialized = "[" + this._type + "," + this._from + "," + this._to + "]";
            return manager.addResource(serialized);
        };
        EShapeTagValueRangeImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getRange(target);
                if (parsed != null) {
                    this.copy_(parsed[0], parsed[1], parsed[2]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setRange(target, deserialized);
                    this.copy_(deserialized[0], deserialized[1], deserialized[2]);
                }
            }
        };
        return EShapeTagValueRangeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var INDEX_COMPARATOR = function (a, b) {
        return a - b;
    };
    var EShapeTagValueImpl = /** @class */ (function () {
        function EShapeTagValueImpl() {
            this.id = "";
            this.initial = "";
            this.format = "";
            this.range = new EShapeTagValueRangeImpl();
            this._value = 0;
            this._time = 0;
            this._capacity = 0;
            this._order = EShapeTagValueOrder.ASCENDING;
        }
        Object.defineProperty(EShapeTagValueImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                if (this._parent !== parent) {
                    this._parent = parent;
                    this.range.parent = parent;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (newValue) {
                var formatter = this.formatter;
                if (formatter != null) {
                    newValue = formatter(newValue);
                }
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._value !== newValue) {
                        this._value = newValue;
                        var parent_1 = this.parent;
                        if (parent_1 != null) {
                            parent_1.isChanged = true;
                        }
                    }
                }
                else {
                    var values = this._values;
                    if (values == null) {
                        values = [];
                        this._values = values;
                    }
                    // Update the value
                    this._value = newValue;
                    // Update the values
                    var order = this._order;
                    if (order === EShapeTagValueOrder.ASCENDING) {
                        values.push(newValue);
                    }
                    else {
                        values.unshift(newValue);
                    }
                    // Remove the unnecessary values
                    var count = values.length - capacity;
                    if (0 < count) {
                        if (order === EShapeTagValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                values.shift();
                            }
                        }
                        else {
                            values.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_2 = this.parent;
                    if (parent_2 != null) {
                        parent_2.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "nvalue", {
            get: function () {
                return this.range.normalize(this._value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "values", {
            get: function () {
                var result = this._values;
                if (result == null) {
                    result = [];
                    this._values = result;
                }
                return result;
            },
            set: function (newValues) {
                if (0 < newValues.length) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newValue = newValues[newValues.length - 1];
                        var formatter = this.formatter;
                        if (formatter != null) {
                            newValue = formatter(newValue);
                        }
                        if (this._value !== newValue) {
                            this._value = newValue;
                            var parent_3 = this.parent;
                            if (parent_3 != null) {
                                parent_3.isChanged = true;
                            }
                        }
                    }
                    else {
                        var values = this._values;
                        if (values == null) {
                            values = [];
                            this._values = values;
                        }
                        var order = this._order;
                        var formatter = this.formatter;
                        if (formatter != null) {
                            // Update the value
                            this._value = formatter(newValues[newValues.length - 1]);
                            // Update the values
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0, imax = newValues.length; i < imax; ++i) {
                                    values.push(formatter(newValues[i]));
                                }
                            }
                            else {
                                for (var i = 0, imax = newValues.length; i < imax; ++i) {
                                    values.unshift(formatter(newValues[i]));
                                }
                            }
                        }
                        else {
                            // Update the value
                            this._value = newValues[newValues.length - 1];
                            // Update the values
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0, imax = newValues.length; i < imax; ++i) {
                                    values.push(newValues[i]);
                                }
                            }
                            else {
                                for (var i = 0, imax = newValues.length; i < imax; ++i) {
                                    values.unshift(newValues[i]);
                                }
                            }
                        }
                        // Remove the unnecessary values
                        var count = values.length - capacity;
                        if (0 < count) {
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    values.shift();
                                }
                            }
                            else {
                                values.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_4 = this.parent;
                        if (parent_4 != null) {
                            parent_4.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "time", {
            get: function () {
                return this._time;
            },
            set: function (newTime) {
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._time !== newTime) {
                        this._time = newTime;
                        var parent_5 = this.parent;
                        if (parent_5 != null) {
                            parent_5.isChanged = true;
                        }
                    }
                }
                else {
                    // Update the times
                    var times = this._times;
                    if (times == null) {
                        times = [];
                        this._times = times;
                    }
                    // Update the time
                    this._time = newTime;
                    // Update the times
                    var order = this._order;
                    if (order === EShapeTagValueOrder.ASCENDING) {
                        times.push(newTime);
                    }
                    else {
                        times.unshift(newTime);
                    }
                    // Remove the unnecessary times
                    var count = times.length - capacity;
                    if (0 < count) {
                        if (order === EShapeTagValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                times.shift();
                            }
                        }
                        else {
                            times.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_6 = this.parent;
                    if (parent_6 != null) {
                        parent_6.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "times", {
            get: function () {
                var result = this._times;
                if (result == null) {
                    result = [];
                    this._times = result;
                }
                return result;
            },
            set: function (newTimes) {
                if (0 < newTimes.length) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newTime = newTimes[newTimes.length - 1];
                        if (this._time !== newTime) {
                            this._time = newTime;
                            var parent_7 = this.parent;
                            if (parent_7 != null) {
                                parent_7.isChanged = true;
                            }
                        }
                    }
                    else {
                        // Update the times
                        var times = this._times;
                        if (times == null) {
                            times = [];
                            this._times = times;
                        }
                        // Update the value
                        this._time = newTimes[newTimes.length - 1];
                        //
                        var order = this._order;
                        if (order === EShapeTagValueOrder.ASCENDING) {
                            for (var i = 0, imax = newTimes.length; i < imax; ++i) {
                                times.push(newTimes[i]);
                            }
                        }
                        else {
                            for (var i = 0, imax = newTimes.length; i < imax; ++i) {
                                times.unshift(newTimes[i]);
                            }
                        }
                        //
                        var count = times.length - capacity;
                        if (0 < count) {
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    times.shift();
                                }
                            }
                            else {
                                times.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_8 = this.parent;
                        if (parent_8 != null) {
                            parent_8.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "capacity", {
            get: function () {
                return this._capacity;
            },
            set: function (capacity) {
                if (this._capacity < capacity) {
                    this._capacity = capacity;
                }
                else if (capacity < this._capacity) {
                    this._capacity = capacity;
                    var isChanged = false;
                    // Values
                    var order = this._order;
                    var values = this._values;
                    if (values != null) {
                        var count = values.length - capacity;
                        if (0 < count) {
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    values.shift();
                                }
                            }
                            else {
                                values.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    // Times
                    var times = this._times;
                    if (times != null) {
                        var count = times.length - capacity;
                        if (0 < count) {
                            if (order === EShapeTagValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    times.shift();
                                }
                            }
                            else {
                                times.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    if (isChanged) {
                        var parent_9 = this.parent;
                        if (parent_9 != null) {
                            parent_9.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagValueImpl.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (order) {
                this._order = order;
            },
            enumerable: false,
            configurable: true
        });
        EShapeTagValueImpl.prototype.remove = function (index) {
            var isChanged = false;
            // Values
            var values = this._values;
            if (values != null) {
                if (0 <= index && index < values.length) {
                    values.splice(index, 1);
                    isChanged = true;
                }
            }
            // Times
            var times = this._times;
            if (times != null) {
                if (0 <= index && index < times.length) {
                    times.splice(index, 1);
                    isChanged = true;
                }
            }
            if (isChanged) {
                var parent_10 = this.parent;
                if (parent_10 != null) {
                    parent_10.isChanged = true;
                }
            }
        };
        EShapeTagValueImpl.prototype.removeAll = function (indices) {
            var isChanged = false;
            var values = this._values;
            var times = this._times;
            var sorted = indices.slice(0).sort(INDEX_COMPARATOR);
            if (values != null) {
                if (times != null) {
                    for (var i = sorted.length - 1; 0 <= i; --i) {
                        var index = sorted[i];
                        if (0 <= index) {
                            if (index < values.length) {
                                values.splice(index, 1);
                                isChanged = true;
                            }
                            if (index < times.length) {
                                times.splice(index, 1);
                                isChanged = true;
                            }
                        }
                    }
                }
                else {
                    for (var i = sorted.length - 1; 0 <= i; --i) {
                        var index = sorted[i];
                        if (0 <= index && index < values.length) {
                            values.splice(index, 1);
                            isChanged = true;
                        }
                    }
                }
            }
            else {
                if (times != null) {
                    for (var i = sorted.length - 1; 0 <= i; --i) {
                        var index = sorted[i];
                        if (0 <= index && index < times.length) {
                            times.splice(index, 1);
                            isChanged = true;
                        }
                    }
                }
            }
            if (isChanged) {
                var parent_11 = this.parent;
                if (parent_11 != null) {
                    parent_11.isChanged = true;
                }
            }
        };
        EShapeTagValueImpl.prototype.clear = function () {
            var isChanged = false;
            // Values
            var values = this._values;
            if (values != null) {
                values.length = 0;
                isChanged = true;
            }
            // Times
            var times = this._times;
            if (times != null) {
                times.length = 0;
                isChanged = true;
            }
            // Change flag
            if (isChanged) {
                var parent_12 = this.parent;
                if (parent_12 != null) {
                    parent_12.isChanged = true;
                }
            }
        };
        /**
         * This method does not copy the `#values` and `#times` for the performance.
         *
         * @param target a copy target
         */
        EShapeTagValueImpl.prototype.copy = function (target) {
            this.id = target.id;
            this.initial = target.initial;
            this.format = target.format;
            this.formatter = target.formatter;
            this.range.copy(target.range);
            this._value = target.value;
            this._time = target.time;
            this._capacity = target.capacity;
            return this;
        };
        EShapeTagValueImpl.prototype.isEquals = function (target) {
            return (this.id === target.id &&
                this.initial === target.initial &&
                this.formatter === target.formatter &&
                this.range.isEquals(target.range));
        };
        EShapeTagValueImpl.prototype.serialize = function (manager) {
            var idSerialized = manager.addTag(this.id);
            var initialSerialized = manager.addResource(this.initial);
            var formatSerialized = manager.addResource(this.format.trim());
            var rangeSerialized = this.range.serialize(manager);
            return manager.addResource("[" + idSerialized + "," + initialSerialized + "," + formatSerialized + "," + rangeSerialized + "," + this._capacity + "," + this._order + "]");
        };
        EShapeTagValueImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getTagValue(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setTagValue(target, parsed);
                }
                this.id = manager.tags[parsed[0]] || "";
                this.initial = resources[parsed[1]] || "";
                this.format = resources[parsed[2]] || "";
                this.range.deserialize(parsed[3], manager);
                this._capacity = parsed[4];
                this._order = parsed[5];
            }
            return this;
        };
        return EShapeTagValueImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var RANGE_DUMMY;
    var EShapeTagImpl = /** @class */ (function () {
        function EShapeTagImpl() {
            this._values = [];
            this._isChanged = true;
        }
        Object.defineProperty(EShapeTagImpl.prototype, "values", {
            get: function () {
                return this._values;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "isChanged", {
            get: function () {
                return this._isChanged;
            },
            set: function (isChanged) {
                this._isChanged = isChanged;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "id", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].id;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "initial", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].initial;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "format", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].format;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "range", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].range;
                }
                return (RANGE_DUMMY !== null && RANGE_DUMMY !== void 0 ? RANGE_DUMMY : (RANGE_DUMMY = new EShapeTagValueRangeImpl()));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "value", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].value;
                }
                return 0;
            },
            set: function (value) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].value = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "nvalue", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].nvalue;
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "time", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].time;
                }
                return 0;
            },
            set: function (time) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].time = time;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTagImpl.prototype, "capacity", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].capacity;
                }
                return 0;
            },
            set: function (capacity) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].capacity = capacity;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTagImpl.prototype.add = function (value, index) {
            var values = this._values;
            value.parent = this;
            if (index === undefined) {
                values.push(value);
            }
            else {
                values.splice(index, 0, value);
            }
        };
        EShapeTagImpl.prototype.set = function (index, value) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                var result = values[index];
                value.parent = this;
                values[index] = value;
                result.parent = undefined;
                return result;
            }
            return null;
        };
        EShapeTagImpl.prototype.remove = function (index) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1)[0].parent = undefined;
            }
        };
        EShapeTagImpl.prototype.indexOf = function (target) {
            var values = this._values;
            var valuesLength = values.length;
            // Instance-based matching
            for (var i = 0; i < valuesLength; ++i) {
                if (values[i] === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0; i < valuesLength; ++i) {
                if (values[i].isEquals(target)) {
                    return i;
                }
            }
            // ID-based matching
            for (var i = 0; i < valuesLength; ++i) {
                if (values[i].id === target.id) {
                    return i;
                }
            }
            return -1;
        };
        EShapeTagImpl.prototype.get = function (index) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                return values[index];
            }
            return null;
        };
        EShapeTagImpl.prototype.size = function () {
            return this._values.length;
        };
        EShapeTagImpl.prototype.swap = function (indexA, indexB) {
            var values = this._values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
        };
        EShapeTagImpl.prototype.copy = function (target) {
            var values = this._values;
            values.length = 0;
            for (var i = 0, imax = target.size(); i < imax; ++i) {
                var value = target.get(i);
                if (value != null) {
                    var newValue = new EShapeTagValueImpl().copy(value);
                    newValue.parent = this;
                    values.push(newValue);
                }
            }
            return this;
        };
        EShapeTagImpl.prototype.serialize = function (manager) {
            var values = this._values;
            if (values.length <= 0) {
                return manager.addResource("[]");
            }
            else {
                var serialized = "[" + values[0].serialize(manager);
                for (var i = 1, imax = values.length; i < imax; ++i) {
                    serialized += "," + values[i].serialize(manager);
                }
                serialized += "]";
                return manager.addResource(serialized);
            }
        };
        EShapeTagImpl.prototype.deserialize = function (target, manager) {
            if (0 <= target && target < manager.resources.length) {
                var deserialized = manager.getTag(target);
                if (deserialized == null) {
                    deserialized = JSON.parse(manager.resources[target]);
                    manager.setTag(target, deserialized);
                }
                var values = this._values;
                values.length = 0;
                var deserializedLength = deserialized.length;
                for (var i = 0; i < deserializedLength; ++i) {
                    var index = deserialized[i];
                    var value = new EShapeTagValueImpl();
                    value.parent = this;
                    value.deserialize(index, manager);
                    values.push(value);
                }
            }
        };
        return EShapeTagImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignImpl = /** @class */ (function () {
        function EShapeTextAlignImpl(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        Object.defineProperty(EShapeTextAlignImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextAlignImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextAlignImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        };
        EShapeTextAlignImpl.prototype.set = function (horizontal, vertical) {
            var isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextAlignImpl.prototype.toObject = function () {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        };
        EShapeTextAlignImpl.prototype.serialize = function (manager) {
            return manager.addResource("[" + this._horizontal + "," + this._vertical + "]");
        };
        EShapeTextAlignImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getAlign(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setAlign(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        };
        return EShapeTextAlignImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextOffsetImpl = /** @class */ (function () {
        function EShapeTextOffsetImpl(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        Object.defineProperty(EShapeTextOffsetImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOffsetImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextOffsetImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        };
        EShapeTextOffsetImpl.prototype.set = function (horizontal, vertical) {
            var isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextOffsetImpl.prototype.toObject = function () {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        };
        EShapeTextOffsetImpl.prototype.serialize = function (manager) {
            return manager.addResource("[" + this._horizontal + "," + this._vertical + "]");
        };
        EShapeTextOffsetImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getMargin(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setMargin(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        };
        return EShapeTextOffsetImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextOutlineImpl = /** @class */ (function () {
        function EShapeTextOutlineImpl(parent, enable, color, alpha, width) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
        }
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextOutlineImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width);
            }
        };
        EShapeTextOutlineImpl.prototype.set = function (enable, color, alpha, width) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextOutlineImpl.prototype.clone = function () {
            return new EShapeTextOutlineImpl(this._parent, this._enable, this._color, this._alpha, this._width);
        };
        EShapeTextOutlineImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width
            };
        };
        EShapeTextOutlineImpl.prototype.serialize = function (manager) {
            var serialized = "[" + (this._enable ? 1 : 0) + "," + this._color + "," + this._alpha + "," + this._width + "]";
            return manager.addResource(serialized);
        };
        EShapeTextOutlineImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getTextOutline(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2], parsed[3]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setTextOutline(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2], deserialized[3]);
                }
            }
        };
        return EShapeTextOutlineImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextImpl = /** @class */ (function () {
        function EShapeTextImpl(parent, value, color, alpha, family, size) {
            this._parent = parent;
            this._enable = true;
            this._value = value;
            this._color = color;
            this._alpha = alpha;
            this._family = family;
            this._size = size;
            this._weight = EShapeTextWeight.NORMAL;
            this.align = new EShapeTextAlignImpl(parent, EShapeTextAlignHorizontal.CENTER, EShapeTextAlignVertical.MIDDLE);
            this.offset = new EShapeTextOffsetImpl(parent, 0, 0);
            this._style = EShapeTextStyle.NORMAL;
            this.spacing = new EShapeTextOffsetImpl(parent, 0, 0);
            this.outline = new EShapeTextOutlineImpl(parent, false, 0xffffff, 1.0, 0.5);
            this._direction = EShapeTextDirection.LEFT_TO_RIGHT;
            this.padding = new EShapeTextOffsetImpl(parent, 10, 10);
            this._clipping = false;
        }
        Object.defineProperty(EShapeTextImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                if (this._value !== value) {
                    this._value = value;
                    // Compatibility check
                    var parent_1 = this._parent;
                    var uploaded = parent_1.uploaded;
                    if (uploaded == null || !uploaded.isCompatible(parent_1)) {
                        this.atlas = undefined;
                        parent_1.toDirty();
                        return;
                    }
                    // Character code check
                    var atlas = this.atlas;
                    var characters = atlas && atlas.characters;
                    if (characters != null) {
                        for (var i = 0, imax = value.length; i < imax; ++i) {
                            var char = value[i];
                            if (!(char in characters)) {
                                this.atlas = undefined;
                                parent_1.toDirty();
                                return;
                            }
                        }
                    }
                    else {
                        this.atlas = undefined;
                        parent_1.toDirty();
                        return;
                    }
                    // Update uploaded
                    parent_1.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "family", {
            get: function () {
                return this._family;
            },
            set: function (family) {
                if (this._family !== family) {
                    this._family = family;
                    this._parent.toDirty();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                if (this._size !== size) {
                    this._size = size;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            set: function (weight) {
                if (this._weight !== weight) {
                    this._weight = weight;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                if (this._style !== style) {
                    this._style = style;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "direction", {
            get: function () {
                return this._direction;
            },
            set: function (direction) {
                if (this._direction !== direction) {
                    this._direction = direction;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "clipping", {
            get: function () {
                return this._clipping;
            },
            set: function (clipping) {
                if (this._clipping !== clipping) {
                    this._clipping = clipping;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.value, target.color, target.alpha, target.family, target.size, target.weight, target.style, target.direction, target.clipping);
                this.align.copy(target.align);
                this.offset.copy(target.offset);
                this.outline.copy(target.outline);
                this.spacing.copy(target.spacing);
                this.padding.copy(target.padding);
            }
            return this;
        };
        EShapeTextImpl.prototype.set = function (value, color, alpha, family, size, weight, style, direction, clipping) {
            var isChangedDirty = false;
            var isChangedUploaded = false;
            if (value != null && this._value !== value) {
                this._value = value;
                isChangedDirty = true;
            }
            if (color != null && this._color !== color) {
                this._color = color;
                isChangedUploaded = true;
            }
            if (alpha != null && this._alpha !== alpha) {
                this._alpha = alpha;
                isChangedUploaded = true;
            }
            if (family != null && this._family !== family) {
                this._family = family;
                isChangedDirty = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChangedUploaded = true;
            }
            if (weight != null && this._weight !== weight) {
                this._weight = weight;
                isChangedUploaded = true;
            }
            if (style != null && this._style !== style) {
                this._style = style;
                isChangedUploaded = true;
            }
            if (direction != null && this._direction !== direction) {
                this._direction = direction;
                isChangedUploaded = true;
            }
            if (clipping != null && this._clipping !== clipping) {
                this._clipping = clipping;
                isChangedUploaded = true;
            }
            if (isChangedDirty) {
                this._parent.toDirty();
            }
            else if (isChangedUploaded) {
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeTextImpl.prototype.toObject = function () {
            return {
                value: this._value,
                color: this._color,
                alpha: this._alpha,
                family: this._family,
                size: this._size,
                weight: this._weight,
                align: this.align.toObject(),
                offset: this.offset.toObject(),
                style: this._style,
                outline: this.outline.toObject(),
                direction: this._direction,
                spacing: this.spacing.toObject(),
                padding: this.padding.toObject(),
                clipping: this._clipping
            };
        };
        EShapeTextImpl.prototype.serialize = function (manager) {
            var valueId = manager.addResource(this._value);
            var familyId = manager.addResource(this._family);
            var alignId = this.align.serialize(manager);
            var offsetId = this.offset.serialize(manager);
            var outlineId = this.outline.serialize(manager);
            var spacingId = this.spacing.serialize(manager);
            var paddingId = this.padding.serialize(manager);
            var serialized = "[" + valueId + "," + this._color + "," + this._alpha + "," + familyId + "," + this._size + "," +
                (this._weight + "," + alignId + "," + offsetId + "," + this._style + "," + outlineId + ",") +
                (spacingId + "," + this._direction + "," + paddingId + "," + (this._clipping ? 1 : 0) + "]");
            return manager.addResource(serialized);
        };
        EShapeTextImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getText(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setText(target, parsed);
                }
                this.set(resources[parsed[0]] || "", parsed[1], parsed[2], resources[parsed[3]] || "auto", parsed[4], parsed[5], parsed[8], parsed[11], !!parsed[13]);
                this.align.deserialize(parsed[6], manager);
                this.offset.deserialize(parsed[7], manager);
                this.outline.deserialize(parsed[9], manager);
                this.spacing.deserialize(parsed[10], manager);
                this.padding.deserialize(parsed[12], manager);
            }
        };
        return EShapeTextImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePrimitive = /** @class */ (function (_super) {
        __extends(EShapePrimitive, _super);
        function EShapePrimitive(type) {
            var _this = _super.call(this, type) || this;
            _this.size = _this.newSize();
            _this.fill = _this.newFill();
            _this.stroke = _this.newStroke();
            _this._radius = EShapeDefaults.RADIUS;
            _this._corner = EShapeCorner.ALL;
            _this.tag = new EShapeTagImpl();
            _this.text = _this.newText();
            _this.cursor = EShapeDefaults.CURSOR;
            return _this;
        }
        EShapePrimitive.prototype.newSize = function () {
            var _this = this;
            return new pixi_js.ObservablePoint(function () {
                _this.onSizeChange();
            }, undefined, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
        };
        EShapePrimitive.prototype.newFill = function () {
            return new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, EShapeDefaults.FILL_ALPHA);
        };
        EShapePrimitive.prototype.newStroke = function () {
            return new EShapeStrokeImpl(this, true, EShapeDefaults.STROKE_COLOR, EShapeDefaults.STROKE_ALPHA, EShapeDefaults.STROKE_WIDTH, EShapeDefaults.STROKE_ALIGN, EShapeDefaults.STROKE_SIDE, EShapeDefaults.STROKE_STYLE);
        };
        EShapePrimitive.prototype.newText = function () {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.STROKE_COLOR, EShapeDefaults.STROKE_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        };
        Object.defineProperty(EShapePrimitive.prototype, "corner", {
            get: function () {
                return this._corner;
            },
            set: function (corner) {
                if (this._corner !== corner) {
                    this._corner = corner;
                    this.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePrimitive.prototype, "radius", {
            get: function () {
                return this._radius;
            },
            set: function (radius) {
                if (this._radius !== radius) {
                    this._radius = radius;
                    this.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePrimitive.prototype, "image", {
            get: function () {
                return this._image;
            },
            set: function (image) {
                if (this._image !== image) {
                    if (image != null) {
                        this._image = image;
                        this.imageSrc = image.src;
                    }
                    else {
                        this._image = undefined;
                        this.imageSrc = undefined;
                    }
                    var parent_1 = this.parent;
                    if (parent_1 != null) {
                        parent_1.toDirty();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        return EShapePrimitive;
    }(EShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toThresholdDefault = function (size, scale, offset) {
        return 0.5 * (offset + size * scale);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineBase = /** @class */ (function (_super) {
        __extends(EShapeLineBase, _super);
        function EShapeLineBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineBase.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = this._points.serialize(manager);
            return result;
        };
        EShapeLineBase.prototype.getHitTestSize = function (result) {
            var formatted = this._points.formatted;
            if ("boundary" in formatted) {
                var boundary = formatted.boundary;
                result.width = Math.max(Math.abs(boundary[0]), Math.abs(boundary[2]));
                result.height = Math.max(Math.abs(boundary[1]), Math.abs(boundary[3]));
            }
            else {
                _super.prototype.getHitTestSize.call(this, result);
            }
            return result;
        };
        EShapeLineBase.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            var points = this._points;
            var threshold = toThresholdDefault(sw, ss, 0);
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return points.calcHitPointAbs(x, y, ax, ay, threshold, null, this.calcHitPointAbsHitTester, null);
            }
            return false;
        };
        EShapeLineBase.prototype.calcHitPoint = function (point, toThreshold, toRange, tester, result) {
            var points = this._points;
            var data = this.toHitTestData(point);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, 0);
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return points.calcHitPointAbs(data.x, data.y, data.width, data.height, threshold, toRange, tester, result);
            }
            return false;
        };
        EShapeLineBase.prototype.calcHitPointAbsHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            // (x, y) = p0 + (p1 - p0) * t where 0 <= t <= 1
            // d0 := p1 - p0
            // d1 := v - p0
            // (p0.x + d0.x * t - x)^2 + (p0.y + d0.y * t - y)^2
            // (d0.x t - d1.x)^2 + (d0.y t - d1.y)^2
            // (d0.x^2 + d0.y^2) t^2 - 2 (d0.x * d1.x + d0.y * d1.y) t + (d1.x^2 + d1.y^2)
            // a := dot( d0, d0 )
            // b := dot( d0, d1 )
            // c := dot( d1, d1 )
            // a t^2 - 2 b t + c = a (t - b / a)^2 + c - b * b / a
            // t0 = b / a  min = c - b * b / a
            var d0x = p1x - p0x;
            var d0y = p1y - p0y;
            var d1x = x - p0x;
            var d1y = y - p0y;
            var a = d0x * d0x + d0y * d0y;
            var b = d0x * d1x + d0y * d1y;
            var c = d1x * d1x + d1y * d1y;
            if (0.0001 < a) {
                var t = Math.max(0, Math.min(1, b / a));
                var d = a * t * t - 2 * b * t + c;
                if (d < threshold * threshold) {
                    return true;
                }
            }
            return false;
        };
        EShapeLineBase.WORK_RANGE = [0, 0];
        return EShapeLineBase;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBar = /** @class */ (function (_super) {
        __extends(EShapeBar, _super);
        function EShapeBar(position, size, width, style) {
            var _this = _super.call(this, EShapeType.BAR) || this;
            _this.fill.enable = false;
            _this.stroke.set(true, undefined, undefined, width);
            _this._points = new EShapeBarPoints(_this, position, size, style);
            return _this;
        }
        Object.defineProperty(EShapeBar.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBar.prototype.clone = function () {
            var points = this._points;
            return new EShapeBar(points.position, points.size, this.stroke.width, points.style).copy(this, EShapeCopyPart.ALL & ~EShapeCopyPart.POINTS);
        };
        EShapeBar.prototype.containsAbsBBox = function (x, y, ax, ay) {
            var size = Math.max(0, this._points.size);
            return _super.prototype.containsAbsBBox.call(this, x, y, ax + size, ay + size);
        };
        return EShapeBar;
    }(EShapeLineBase));

    var buildColor = function (color, alpha, voffset, vcount, colors) {
        var r = (((color >> 16) & 0xff) / 255.0) * alpha;
        var g = (((color >> 8) & 0xff) / 255.0) * alpha;
        var b = (((color >> 0) & 0xff) / 255.0) * alpha;
        var a = alpha;
        var ic = (voffset << 2) - 1;
        var icmax = ((voffset + vcount) << 2) - 1;
        for (; ic < icmax;) {
            colors[++ic] = r;
            colors[++ic] = g;
            colors[++ic] = b;
            colors[++ic] = a;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUploadedBase = /** @class */ (function () {
        function EShapeUploadedBase(buffer, voffset, ioffset, vcount, icount, antialiasWeight) {
            this.buffer = buffer;
            this.transformLocalId = -1;
            this.vertexOffset = voffset;
            this.vertexCount = vcount;
            this.indexOffset = ioffset;
            this.indexCount = icount;
            this.colorFill = NaN;
            this.alphaFill = -1;
            this.colorStroke = NaN;
            this.alphaStroke = -1;
            this.sizeX = NaN;
            this.sizeY = NaN;
            this.strokeAlign = NaN;
            this.strokeWidth = NaN;
            this.strokeSide = NaN;
            this.strokeStyle = NaN;
            this.radius = NaN;
            this.corner = NaN;
            this.texture = null;
            this.textureTransformId = NaN;
            this.antialiasWeight = antialiasWeight;
        }
        EShapeUploadedBase.prototype.init = function (shape) {
            shape.uploaded = this;
            return this;
        };
        EShapeUploadedBase.prototype.isCompatible = function (shape) {
            return true;
        };
        EShapeUploadedBase.prototype.getBuffer = function () {
            return this.buffer;
        };
        EShapeUploadedBase.prototype.getVertexOffset = function () {
            return this.vertexOffset;
        };
        EShapeUploadedBase.prototype.getVertexCount = function () {
            return this.vertexCount;
        };
        EShapeUploadedBase.prototype.getIndexOffset = function () {
            return this.indexOffset;
        };
        EShapeUploadedBase.prototype.getIndexCount = function () {
            return this.indexCount;
        };
        EShapeUploadedBase.prototype.toTransformLocalId = function (shape) {
            shape.updateTransform();
            return shape.transform.getLocalId();
        };
        EShapeUploadedBase.prototype.toTexture = function (shape) {
            return shape.texture || pixi_js.Texture.WHITE;
        };
        EShapeUploadedBase.prototype.toTextureTransformId = function (texture) {
            var textureAny = texture;
            if (textureAny._uvs == null) {
                texture.updateUvs();
            }
            return textureAny._updateID;
        };
        EShapeUploadedBase.prototype.toTextureUvs = function (texture) {
            return texture._uvs;
        };
        EShapeUploadedBase.prototype.updateColorFill = function (buffer, shape, vertexCount) {
            var fill = shape.fill;
            var isEnabled = shape.visible && fill.enable;
            var color = fill.color;
            var alpha = isEnabled ? fill.alpha : 0;
            if (color !== this.colorFill || alpha !== this.alphaFill) {
                this.colorFill = color;
                this.alphaFill = alpha;
                buffer.updateColorFills();
                buildColor(color, alpha, this.vertexOffset, vertexCount, buffer.colorFills);
            }
        };
        EShapeUploadedBase.prototype.updateColorStroke = function (buffer, shape, vertexCount) {
            var stroke = shape.stroke;
            var isEnabled = shape.visible && stroke.enable && 0 < stroke.width;
            var color = stroke.color;
            var alpha = isEnabled ? stroke.alpha : 0;
            if (color !== this.colorStroke || alpha !== this.alphaStroke) {
                this.colorStroke = color;
                this.alphaStroke = alpha;
                buffer.updateColorStrokes();
                buildColor(color, alpha, this.vertexOffset, vertexCount, buffer.colorStrokes);
            }
        };
        EShapeUploadedBase.prototype.updateColorFillAndStroke = function (buffer, shape, vertexCount) {
            this.updateColorFill(buffer, shape, vertexCount);
            this.updateColorStroke(buffer, shape, vertexCount);
        };
        EShapeUploadedBase.prototype.buildUnit = function (builder) {
            var texture = this.texture || pixi_js.Texture.WHITE;
            var baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                var indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        };
        return EShapeUploadedBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextUploaded = /** @class */ (function (_super) {
        __extends(EShapeTextUploaded, _super);
        function EShapeTextUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) {
            var _this = _super.call(this, buffer, voffset, ioffset, vcount, icount, antialiasWeight) || this;
            _this.textSize = NaN;
            _this.textFamily = "auto";
            _this.textValue = "";
            _this.textTexture = null;
            _this.textTextureTransformId = NaN;
            _this.textColor = NaN;
            _this.textAlpha = NaN;
            _this.textWeight = NaN;
            _this.textStyle = NaN;
            _this.textAlignHorizontal = NaN;
            _this.textAlignVertical = NaN;
            _this.textOffsetHorizontal = NaN;
            _this.textOffsetVertical = NaN;
            _this.textOutlineWidth = NaN;
            _this.textOutlineColor = NaN;
            _this.textOutlineAlpha = NaN;
            _this.textSpacingHorizontal = NaN;
            _this.textSpacingVertical = NaN;
            _this.textDirection = NaN;
            _this.textPaddingHorizontal = NaN;
            _this.textPaddingVertical = NaN;
            _this.textClipping = false;
            _this.textVertexOffset = _this.vertexOffset + _this.vertexCount - tvcount;
            _this.textIndexOffset = _this.indexOffset + _this.indexCount - ticount;
            _this.textVertexCount = tvcount;
            _this.textIndexCount = ticount;
            return _this;
        }
        EShapeTextUploaded.prototype.initText = function () {
            var vcount = this.textVertexCount;
            if (0 < vcount) {
                // Clippings
                var buffer = this.buffer;
                var voffset = this.textVertexOffset;
                buffer.updateClippings();
                buildTextClipping(buffer.clippings, voffset, vcount);
                // Indices
                buffer.updateIndices();
                buildTextIndex(buffer.indices, voffset, this.textIndexOffset, this.textIndexCount);
            }
        };
        EShapeTextUploaded.prototype.isCompatible = function (shape) {
            if (_super.prototype.isCompatible.call(this, shape)) {
                return toTextBufferCount(shape) * TEXT_VERTEX_COUNT === this.textVertexCount;
            }
            return false;
        };
        EShapeTextUploaded.prototype.updateText = function (buffer, shape) {
            var vcount = this.textVertexCount;
            if (0 < vcount) {
                var textAtlas = shape.text.atlas;
                if (textAtlas != null) {
                    this.updateTextVertex(buffer, shape, textAtlas);
                    this.updateTextColorFill(buffer, shape);
                    this.updateTextColorStroke(buffer, shape);
                    this.updateTextStep(buffer, shape);
                }
            }
        };
        EShapeTextUploaded.prototype.updateColor = function (buffer, shape) {
            var vertexCount = this.vertexCount - this.textVertexCount;
            this.updateColorFillAndStroke(buffer, shape, vertexCount);
        };
        EShapeTextUploaded.prototype.updateTextVertex = function (buffer, shape, textAtlas) {
            var text = shape.text;
            var textSize = text.size;
            var textFamily = text.family;
            var textValue = text.value;
            var textStyle = text.style;
            var textAlignHorizontal = text.align.horizontal;
            var textAlignVertical = text.align.vertical;
            var textOffsetHorizontal = text.offset.horizontal;
            var textOffsetVertical = text.offset.vertical;
            var textSpacingHorizontal = text.spacing.horizontal;
            var textSpacingVertical = text.spacing.vertical;
            var textDirection = text.direction;
            var textPaddingHorizontal = text.padding.horizontal;
            var textPaddingVertical = text.padding.vertical;
            var textClipping = text.clipping;
            var textTexture = text.texture || pixi_js.Texture.WHITE;
            var textTextureTransformId = this.toTextureTransformId(textTexture);
            var isCharChanged = textValue !== this.textValue || textFamily !== this.textFamily;
            var isCharSizeChanged = textSize !== this.textSize;
            var isCharStyleChanged = textStyle !== this.textStyle;
            var isCharAlignChanged = textAlignHorizontal !== this.textAlignHorizontal ||
                textAlignVertical !== this.textAlignVertical;
            var isCharOffsetChanged = textOffsetHorizontal !== this.textOffsetHorizontal ||
                textOffsetVertical !== this.textOffsetVertical;
            var isCharSpacingChanged = textSpacingHorizontal !== this.textSpacingHorizontal ||
                textSpacingVertical !== this.textSpacingVertical ||
                textPaddingHorizontal !== this.textPaddingHorizontal ||
                textPaddingVertical !== this.textPaddingVertical;
            var isCharDirectionChanged = textDirection !== this.textDirection;
            var isClippingChanged = this.textClipping !== textClipping;
            var isTextureChanged = textTexture !== this.textTexture ||
                textTextureTransformId !== this.textTextureTransformId;
            if (isCharChanged ||
                isCharSizeChanged ||
                isCharStyleChanged ||
                isCharAlignChanged ||
                isCharOffsetChanged ||
                isCharSpacingChanged ||
                isCharDirectionChanged ||
                isClippingChanged ||
                isTextureChanged) {
                this.textSize = textSize;
                this.textFamily = textFamily;
                this.textValue = textValue;
                this.textStyle = textStyle;
                this.textAlignHorizontal = textAlignHorizontal;
                this.textAlignVertical = textAlignVertical;
                this.textOffsetHorizontal = textOffsetHorizontal;
                this.textOffsetVertical = textOffsetVertical;
                this.textSpacingHorizontal = textSpacingHorizontal;
                this.textSpacingVertical = textSpacingVertical;
                this.textDirection = textDirection;
                this.textPaddingHorizontal = textPaddingHorizontal;
                this.textPaddingVertical = textPaddingVertical;
                this.textClipping = textClipping;
                this.textTexture = textTexture;
                this.textTextureTransformId = textTextureTransformId;
                if (isCharSizeChanged) {
                    // Invalidate the text weight to update the text steps.
                    this.textWeight = NaN;
                }
                // Vertices & UVs
                buffer.updateVertices();
                buffer.updateUvs();
                var shapeSize = shape.size;
                var textWorld = text.world;
                if (textWorld == null) {
                    textWorld = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    text.world = textWorld;
                }
                buildTextVertex(buffer.vertices, buffer.uvs, this.textVertexOffset, this.textVertexCount, 0, 0, shapeSize.x, shapeSize.y, textAtlas, textSize, textValue, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textWorld, this.toTextureUvs(textTexture), shape.transform.internalTransform);
            }
        };
        EShapeTextUploaded.prototype.updateTextColorFill = function (buffer, shape) {
            var text = shape.text;
            var color = text.color;
            var alpha = shape.visible && text.enable ? text.alpha : 0;
            if (color !== this.textColor || alpha !== this.textAlpha) {
                this.textColor = color;
                this.textAlpha = alpha;
                buffer.updateColorFills();
                buildColor(color, alpha, this.textVertexOffset, this.textVertexCount, buffer.colorFills);
            }
        };
        EShapeTextUploaded.prototype.updateTextColorStroke = function (buffer, shape) {
            var text = shape.text;
            var outline = text.outline;
            var color = outline.color;
            var alpha = shape.visible && text.enable ? outline.alpha : 0;
            if (color !== this.textOutlineColor || alpha !== this.textOutlineAlpha) {
                this.textOutlineColor = color;
                this.textOutlineAlpha = alpha;
                buffer.updateColorStrokes();
                buildColor(color, alpha, this.textVertexOffset, this.textVertexCount, buffer.colorStrokes);
            }
        };
        EShapeTextUploaded.prototype.updateTextStep = function (buffer, shape) {
            var text = shape.text;
            var textOutline = text.outline;
            var textOutlineWidth = textOutline.enable ? textOutline.width : 0;
            var textWeight = text.weight;
            if (textWeight !== this.textWeight || textOutlineWidth !== this.textOutlineWidth) {
                this.textWeight = textWeight;
                this.textOutlineWidth = textOutlineWidth;
                buffer.updateSteps();
                buildTextStep(buffer.steps, this.textVertexOffset, this.textVertexCount, text.atlas, text.size, textOutlineWidth, textWeight);
            }
        };
        EShapeTextUploaded.prototype.buildUnit = function (builder) {
            _super.prototype.buildUnit.call(this, builder);
            if (0 < this.textVertexCount) {
                var textTexture = this.textTexture || pixi_js.Texture.WHITE;
                var textBaseTexture = textTexture.baseTexture;
                if (textBaseTexture !== builder.baseTexture) {
                    builder.baseTexture = textBaseTexture;
                    builder.push(textTexture, this.textIndexOffset);
                }
            }
        };
        return EShapeTextUploaded;
    }(EShapeUploadedBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarUploaded = /** @class */ (function (_super) {
        __extends(EShapeBarUploaded, _super);
        function EShapeBarUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) {
            var _this = _super.call(this, buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) || this;
            _this.pointsId = NaN;
            _this.pointsStyle = EShapePointsStyle.NONE;
            return _this;
        }
        EShapeBarUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clipping & indices
            var buffer = this.buffer;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            buffer.updateClippings();
            buffer.updateIndices();
            buildBarClipping(buffer.clippings, voffset);
            buildBarIndex(buffer.indices, voffset, ioffset);
            // Text
            this.initText();
            //
            this.update(shape);
            return this;
        };
        EShapeBarUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndColorFill(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeBarUploaded.prototype.updateVertexStepAndColorFill = function (buffer, shape) {
            if (shape instanceof EShapeBar) {
                var size = shape.size;
                var sizeX = size.x;
                var sizeY = size.y;
                var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
                var stroke = shape.stroke;
                var strokeWidth = stroke.enable ? stroke.width : 0;
                var strokeStyle = stroke.style;
                var isStrokeWidthChanged = strokeWidth !== this.strokeWidth || strokeStyle !== this.strokeStyle;
                var transformLocalId = this.toTransformLocalId(shape);
                var isTransformChanged = this.transformLocalId !== transformLocalId;
                var points = shape.points;
                var pointsId = points.id;
                var isPointsIdChanged = pointsId !== this.pointsId;
                var pointsStyle = points.style;
                var isPointsStyleChanged = pointsStyle !== this.pointsStyle;
                if (isSizeChanged ||
                    isTransformChanged ||
                    isStrokeWidthChanged ||
                    isPointsIdChanged ||
                    isPointsStyleChanged) {
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                    this.strokeWidth = strokeWidth;
                    this.strokeStyle = strokeStyle;
                    this.transformLocalId = transformLocalId;
                    this.pointsId = pointsId;
                    this.pointsStyle = pointsStyle;
                    if (isSizeChanged || isTransformChanged) {
                        // Invalidate the text layout to update the text layout.
                        this.textSpacingHorizontal = NaN;
                    }
                    if (isPointsIdChanged) {
                        // Invalidate the texture transform ID to update the UVs
                        this.textureTransformId = NaN;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    buffer.updateColorFills();
                    buildBarVertexStepAndColorFill(buffer.vertices, buffer.steps, buffer.colorFills, this.vertexOffset, points.values, points.size, strokeWidth, strokeStyle, shape.transform.internalTransform);
                }
            }
        };
        EShapeBarUploaded.prototype.updateColorFillAndStroke = function (buffer, shape, vertexCount) {
            this.updateColorStroke(buffer, shape, vertexCount);
        };
        EShapeBarUploaded.prototype.updateUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildBarUv(buffer.uvs, this.vertexOffset, this.toTextureUvs(texture));
            }
        };
        return EShapeBarUploaded;
    }(EShapeTextUploaded));

    var createBarUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = BAR_VERTEX_COUNT + tvcount;
        var icount = BAR_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeBarUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isArray = Array.isArray ||
        (function (target) {
            return Object.prototype.toString.call(target) === "[object Array]";
        });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isNumber = function (target) {
        return (typeof target === "number" || Object.prototype.toString.call(target) === "[object Number]");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var setShortcutKeyAndWhich = function (shortcut) {
        var key = shortcut.key;
        if (key.length <= 1) {
            if (shortcut.shift) {
                shortcut.key = key.toUpperCase();
            }
            var code = key.charCodeAt(0);
            if (97 <= code && code <= 122) {
                // a ... z
                shortcut.which = code - 32;
            }
            else {
                shortcut.which = code;
            }
        }
        else {
            switch (key) {
                case "Enter":
                    shortcut.which = 13;
                    break;
                case "Space":
                    shortcut.key = " ";
                    shortcut.which = 32;
                    break;
                case "Escape":
                    shortcut.which = 27;
                    break;
                case "F1":
                    shortcut.which = 112;
                    break;
                case "F2":
                    shortcut.which = 113;
                    break;
                case "F3":
                    shortcut.which = 114;
                    break;
                case "F4":
                    shortcut.which = 115;
                    break;
                case "F5":
                    shortcut.which = 116;
                    break;
                case "F6":
                    shortcut.which = 117;
                    break;
                case "F7":
                    shortcut.which = 118;
                    break;
                case "F8":
                    shortcut.which = 119;
                    break;
                case "F9":
                    shortcut.which = 120;
                    break;
                case "F10":
                    shortcut.which = 121;
                    break;
                case "F11":
                    shortcut.which = 122;
                    break;
                case "F12":
                    shortcut.which = 123;
                    break;
                case "CapsLock":
                    if (shortcut.shift) {
                        shortcut.which = 20;
                    }
                    else {
                        shortcut.which = 240;
                    }
                    break;
                case "ArrowUp":
                    shortcut.which = 38;
                    break;
                case "ArrowDown":
                    shortcut.which = 40;
                    break;
                case "ArrowLeft":
                    shortcut.which = 37;
                    break;
                case "ArrowRight":
                    shortcut.which = 39;
                    break;
                case "Insert":
                    shortcut.which = 45;
                    break;
                case "Delete":
                    shortcut.which = 46;
                    break;
                case "PageUp":
                    shortcut.which = 33;
                    break;
                case "PageDown":
                    shortcut.which = 34;
                    break;
                case "Backspace":
                    shortcut.which = 8;
                    break;
                case ";":
                    shortcut.which = 187;
                    break;
                case "Pause":
                    shortcut.which = 19;
                    break;
                case "ScrollLock":
                    shortcut.which = 145;
                    break;
                case "Tab":
                    shortcut.which = 9;
                    break;
            }
        }
        return shortcut;
    };
    var UtilKeyboardEvent = /** @class */ (function () {
        function UtilKeyboardEvent() {
        }
        UtilKeyboardEvent.isActivateKey = function (e) {
            return e.key === "Space" || e.key === "Enter" || e.which === 32 || e.which === 13;
        };
        UtilKeyboardEvent.isArrowUpKey = function (e) {
            return e.key === "ArrowUp" || e.which === 38;
        };
        UtilKeyboardEvent.isArrowDownKey = function (e) {
            return e.key === "ArrowDown" || e.which === 40;
        };
        UtilKeyboardEvent.isArrowLeftKey = function (e) {
            return e.key === "ArrowLeft" || e.which === 37;
        };
        UtilKeyboardEvent.isArrowRightKey = function (e) {
            return e.key === "ArrowRight" || e.which === 39;
        };
        UtilKeyboardEvent.isCancelKey = function (e) {
            return e.key === "Esc" || e.which === 27;
        };
        UtilKeyboardEvent.isFocusKey = function (e) {
            return e.key === "Tab" || e.which === 9;
        };
        UtilKeyboardEvent.isUndoKey = function (e) {
            return e.ctrlKey && (e.key === "z" || e.which === 90);
        };
        UtilKeyboardEvent.isRedoKey = function (e) {
            return e.ctrlKey && (e.key === "y" || e.which === 89);
        };
        UtilKeyboardEvent.isSaveKey = function (e) {
            return e.ctrlKey && !e.shiftKey && (e.key === "s" || e.which === 83);
        };
        UtilKeyboardEvent.isSaveAsKey = function (e) {
            return e.ctrlKey && e.shiftKey && (e.key === "S" || e.which === 83);
        };
        UtilKeyboardEvent.isDeleteKey = function (e) {
            return e.key === "Delete" || e.which === 46;
        };
        UtilKeyboardEvent.isSelectAllKey = function (e) {
            return e.ctrlKey && !e.shiftKey && (e.key === "a" || e.which === 65);
        };
        UtilKeyboardEvent.isOkKey = function (e) {
            return e.key === "Enter" || e.which === 13;
        };
        UtilKeyboardEvent.getFocusDirection = function (e) {
            return e.shiftKey !== true;
        };
        UtilKeyboardEvent.toShortcut = function (expressionOrShortcut) {
            if (!isString(expressionOrShortcut)) {
                return expressionOrShortcut;
            }
            else {
                var expression = expressionOrShortcut;
                var arrowIndex = expression.indexOf("->");
                var keyExpression = void 0;
                var event_1;
                if (0 <= arrowIndex) {
                    keyExpression = expression.substring(0, arrowIndex).trim();
                    event_1 = expression.substring(arrowIndex + 2).trim();
                }
                else {
                    keyExpression = expression.trim();
                }
                var keys = keyExpression.toLowerCase().split("+");
                var alt = 0 <= keys.indexOf("alt");
                var ctrl = 0 <= keys.indexOf("ctrl");
                var shift = 0 <= keys.indexOf("shift");
                var key = keys[keys.length - 1];
                return setShortcutKeyAndWhich({
                    alt: alt,
                    ctrl: ctrl,
                    shift: shift,
                    key: key,
                    which: 0,
                    event: event_1
                });
            }
        };
        UtilKeyboardEvent.toString = function (shortcut) {
            var parts = [];
            if (shortcut.ctrl) {
                parts.push("Ctrl");
            }
            if (shortcut.shift) {
                parts.push("Shift");
            }
            if (shortcut.alt) {
                parts.push("Alt");
            }
            parts.push(shortcut.key.toUpperCase());
            return parts.join("+");
        };
        UtilKeyboardEvent.on = function (target, expressionOrShortcut, handler) {
            var shortcut = this.toShortcut(expressionOrShortcut);
            document.body.addEventListener("keydown", function (e) {
                if (e.altKey === shortcut.alt &&
                    e.ctrlKey === shortcut.ctrl &&
                    e.shiftKey === shortcut.shift &&
                    (e.key === shortcut.key || e.which === shortcut.which)) {
                    if (target.state.isActionable) {
                        if (shortcut.event != null) {
                            target.emit(shortcut.event);
                        }
                        else if (handler != null) {
                            handler(e);
                        }
                    }
                    e.preventDefault();
                }
            });
        };
        UtilKeyboardEvent.moveFocusVertically = function (e, target, picker) {
            if (target.state.isActionable) {
                var isBackward = UtilKeyboardEvent.isArrowUpKey(e);
                var isForward = UtilKeyboardEvent.isArrowDownKey(e);
                if (isBackward || isForward) {
                    return this.moveFocus(isForward, target, picker);
                }
            }
            return false;
        };
        UtilKeyboardEvent.moveFocusHorizontally = function (e, target, picker) {
            if (target.state.isActionable) {
                var isBackward = UtilKeyboardEvent.isArrowLeftKey(e);
                var isForward = UtilKeyboardEvent.isArrowRightKey(e);
                if (isBackward || isForward) {
                    return this.moveFocus(isForward, target, picker);
                }
            }
            return false;
        };
        UtilKeyboardEvent.moveFocus = function (direction, target, picker) {
            var _a;
            var layer = (_a = picker === null || picker === void 0 ? void 0 : picker.picked) !== null && _a !== void 0 ? _a : DApplications.getLayer(target);
            if (layer) {
                var focusController = layer.getFocusController();
                var focused = focusController.get();
                if (focused != null) {
                    var next = focusController.find(focused, false, focused.state.isFocusRoot || direction, direction, target);
                    if (next != null) {
                        focusController.focus(next);
                        return true;
                    }
                }
            }
            return false;
        };
        return UtilKeyboardEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRuntimeReset;
    (function (EShapeRuntimeReset) {
        EShapeRuntimeReset[EShapeRuntimeReset["NONE"] = 0] = "NONE";
        EShapeRuntimeReset[EShapeRuntimeReset["POSITION_X"] = 1] = "POSITION_X";
        EShapeRuntimeReset[EShapeRuntimeReset["POSITION_Y"] = 2] = "POSITION_Y";
        EShapeRuntimeReset[EShapeRuntimeReset["POSITION"] = 3] = "POSITION";
        EShapeRuntimeReset[EShapeRuntimeReset["ROTATION"] = 4] = "ROTATION";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_FILL"] = 8] = "COLOR_FILL";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_STROKE"] = 16] = "COLOR_STROKE";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_FILL_AND_STROKE"] = 24] = "COLOR_FILL_AND_STROKE";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_TEXT"] = 32] = "COLOR_TEXT";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR_TEXT_OUTLINE"] = 64] = "COLOR_TEXT_OUTLINE";
        EShapeRuntimeReset[EShapeRuntimeReset["COLOR"] = 120] = "COLOR";
        EShapeRuntimeReset[EShapeRuntimeReset["VISIBILITY"] = 128] = "VISIBILITY";
        EShapeRuntimeReset[EShapeRuntimeReset["HEIGHT"] = 256] = "HEIGHT";
        EShapeRuntimeReset[EShapeRuntimeReset["WIDTH"] = 512] = "WIDTH";
        EShapeRuntimeReset[EShapeRuntimeReset["SIZE"] = 768] = "SIZE";
        EShapeRuntimeReset[EShapeRuntimeReset["TEXT"] = 1024] = "TEXT";
        EShapeRuntimeReset[EShapeRuntimeReset["CURSOR"] = 2048] = "CURSOR";
    })(EShapeRuntimeReset || (EShapeRuntimeReset = {}));
    var EShapeRuntime = /** @class */ (function () {
        function EShapeRuntime(shape) {
            var transform = shape.transform;
            var position = transform.position;
            this.x = position.x;
            this.y = position.y;
            var size = shape.size;
            this.size = new pixi_js.Point(size.x, size.y);
            this.rotation = transform.rotation;
            this.actions = [];
            this.fill = shape.fill.toObject();
            this.stroke = shape.stroke.toObject();
            this.text = shape.text.toObject();
            this.cursor = shape.cursor;
            this.reset = EShapeRuntimeReset.NONE;
            this.written = EShapeRuntimeReset.NONE;
            this.effect = NaN;
            this.isStateChanged = false;
            this.interactive = false;
        }
        EShapeRuntime.prototype.onClick = function (shape, e) {
            if (!shape.state.inDisabled) {
                shape.state.isClicked = true;
            }
        };
        EShapeRuntime.prototype.onDblClick = function (shape, e, interactionManager) {
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onDblClick(shape, this, e, interactionManager);
            }
            return false;
        };
        EShapeRuntime.prototype.onOver = function (shape, e) {
            shape.state.isHovered = true;
        };
        EShapeRuntime.prototype.onOut = function (shape, e) {
            shape.state.isHovered = false;
        };
        EShapeRuntime.prototype.onDown = function (shape, e) {
            if (!shape.state.isDown) {
                this.onDownThisBefore(shape, e);
                // State
                shape.state.addAll(EShapeState.DOWN, DBaseState.PRESSED);
                // Focus
                var layer = DApplications.getLayer(shape);
                if (layer) {
                    var focusController = layer.getFocusController();
                    focusController.focus(focusController.findParent(shape));
                }
                this.onDownThisAfter(shape, e);
            }
        };
        EShapeRuntime.prototype.onDownThisBefore = function (shape, e) {
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onDownThisBefore(shape, this, e);
            }
        };
        EShapeRuntime.prototype.onDownThisAfter = function (shape, e) {
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onDownThisAfter(shape, this, e);
            }
        };
        EShapeRuntime.prototype.onUp = function (shape, e) {
            if (!shape.state.isUp && shape.state.isPressed) {
                shape.state.set(EShapeState.UP, DBaseState.PRESSED);
                // Click
                this.onClick(shape, e);
            }
        };
        EShapeRuntime.prototype.onMove = function (shape, e) {
            //
        };
        EShapeRuntime.prototype.onKeyDown = function (shape, e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onDown(shape, e);
            }
            return false;
        };
        EShapeRuntime.prototype.onKeyUp = function (shape, e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onUp(shape, e);
            }
            return false;
        };
        EShapeRuntime.prototype.onStateChange = function (shape, newState, oldState) {
            this.isStateChanged = true;
            DApplications.update(shape);
            if (newState.isFocused) {
                if (!oldState.isFocused) {
                    this.onFocus(shape);
                }
            }
            else if (oldState.isFocused) {
                this.onBlur(shape);
            }
        };
        EShapeRuntime.prototype.onFocus = function (shape) {
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onFocus(shape, this);
            }
        };
        EShapeRuntime.prototype.onBlur = function (shape) {
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onBlur(shape, this);
            }
        };
        EShapeRuntime.prototype.update = function (shape, time) {
            var tag = shape.tag;
            var isEffectTimeUp = this.effect <= time;
            if (tag.isChanged || this.isStateChanged || isEffectTimeUp) {
                if (isEffectTimeUp) {
                    this.effect = NaN;
                }
                shape.disallowUploadedUpdate();
                this.onUpdate(shape, time);
                shape.allowUploadedUpdate();
                shape.state.removeAll(EShapeState.CLICKED, EShapeState.DOWN, EShapeState.UP);
                this.isStateChanged = false;
                tag.isChanged = false;
            }
        };
        EShapeRuntime.prototype.onRender = function (shape, time, renderer) {
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRender(shape, this, time, renderer);
            }
            this.update(shape, time);
        };
        EShapeRuntime.prototype.onUpdate = function (shape, time) {
            var actions = this.actions;
            if (0 < actions.length) {
                this.written = EShapeRuntimeReset.NONE;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].execute(shape, this, time);
                }
                this.doReset(shape);
            }
        };
        EShapeRuntime.prototype.doReset = function (shape) {
            var target = ~this.written & this.reset;
            if (target !== EShapeRuntimeReset.NONE) {
                if (target & EShapeRuntimeReset.POSITION_X) {
                    shape.transform.position.x = this.x;
                }
                if (target & EShapeRuntimeReset.POSITION_Y) {
                    shape.transform.position.y = this.y;
                }
                if (target & EShapeRuntimeReset.VISIBILITY) {
                    shape.visible = true;
                }
                if (target & EShapeRuntimeReset.COLOR_FILL) {
                    var fill = this.fill;
                    shape.fill.set(undefined, fill.color, fill.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_STROKE) {
                    var stroke = this.stroke;
                    shape.stroke.set(undefined, stroke.color, stroke.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT) {
                    var text = this.text;
                    shape.text.set(undefined, text.color, text.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                    var outline = this.text.outline;
                    shape.text.outline.set(undefined, outline.color, outline.alpha);
                }
                if (target & EShapeRuntimeReset.HEIGHT) {
                    shape.size.y = this.size.y;
                }
                if (target & EShapeRuntimeReset.WIDTH) {
                    shape.size.x = this.size.x;
                }
                if (target & EShapeRuntimeReset.ROTATION) {
                    shape.transform.rotation = this.rotation;
                }
                if (target & EShapeRuntimeReset.TEXT) {
                    shape.text.value = this.text.value;
                }
                if (target & EShapeRuntimeReset.CURSOR) {
                    shape.cursor = this.cursor;
                }
            }
        };
        return EShapeRuntime;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionBases = /** @class */ (function () {
        function EShapeActionBases() {
        }
        EShapeActionBases.toBaseFill = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_FILL ? shape : runtime).fill;
        };
        EShapeActionBases.toBaseStroke = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_STROKE ? shape : runtime).stroke;
        };
        EShapeActionBases.toBaseText = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT ? shape : runtime).text;
        };
        EShapeActionBases.toBaseTextOutline = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT_OUTLINE ? shape : runtime).text
                .outline;
        };
        return EShapeActionBases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionExpressions = /** @class */ (function () {
        function EShapeActionExpressions() {
        }
        EShapeActionExpressions.from = function (expression, caster, def, defLiteral, nullable, parameter) {
            if (expression.trim().length <= 0) {
                return def;
            }
            try {
                /* eslint-disable prettier/prettier */
                var body = "" +
                    "try{" +
                    "with( shape ) {" +
                    "with( state ) {" +
                    (nullable ?
                        ("var result = (" + expression + ");" +
                            ("return (result != null ? " + caster + "(result) : null);")) :
                        "return " + caster + "(" + expression + ");") +
                    "}" +
                    "}" +
                    "} catch( e ) {" +
                    ("return " + defLiteral + ";") +
                    "}";
                /* eslint-enable prettier/prettier */
                if (parameter == null) {
                    return Function("shape", "time", body);
                }
                else {
                    return Function("shape", "time", parameter, body);
                }
            }
            catch (e) {
                return def;
            }
        };
        EShapeActionExpressions.ofNumberOrNull = function (expression) {
            return this.from(expression, "Number", this.NULL, "null", true);
        };
        EShapeActionExpressions.ofStringOrNull = function (expression) {
            return this.from(expression, "String", this.NULL, "null", true);
        };
        EShapeActionExpressions.ofUnknown = function (expression) {
            return this.from(expression, "", this.NULL, "null", false);
        };
        EShapeActionExpressions.ofNumber = function (expression) {
            return this.from(expression, "Number", this.ZERO, "0", false);
        };
        EShapeActionExpressions.ofNumberOrOne = function (expression) {
            return this.from(expression, "Number", this.ONE, "1", false);
        };
        EShapeActionExpressions.ofNumberOrOneHundred = function (expression) {
            return this.from(expression, "Number", this.ONE_HUNDRED, "100", false);
        };
        EShapeActionExpressions.ofString = function (expression) {
            return this.from(expression, "String", this.EMPTY, '""', false);
        };
        EShapeActionExpressions.ofBoolean = function (expression) {
            return this.from(expression, "Boolean", this.TRUE, "true", false);
        };
        EShapeActionExpressions.ofBooleanOrTrue = function (expression) {
            return this.from(expression, "Boolean", this.TRUE, "true", false);
        };
        EShapeActionExpressions.ofBooleanOrFalse = function (expression) {
            return this.from(expression, "Boolean", this.FALSE, "false", false);
        };
        EShapeActionExpressions.ofElementOrNull = function (expression) {
            return this.from(expression, "", undefined, "null", false, "container");
        };
        EShapeActionExpressions.NULL = function () { return null; };
        EShapeActionExpressions.ZERO = function () { return 0; };
        EShapeActionExpressions.ONE = function () { return 1; };
        EShapeActionExpressions.ONE_HUNDRED = function () { return 100; };
        EShapeActionExpressions.EMPTY = function () { return ""; };
        EShapeActionExpressions.TRUE = function () { return true; };
        EShapeActionExpressions.FALSE = function () { return false; };
        return EShapeActionExpressions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An action runtime.
     * Please note that all the action runtimes are shared across shapes.
     */
    var EShapeActionRuntime = /** @class */ (function () {
        function EShapeActionRuntime(reset) {
            this.reset = reset || EShapeRuntimeReset.NONE;
        }
        EShapeActionRuntime.prototype.execute = function (shape, runtime, time) {
            // OVERRIDE THIS
        };
        EShapeActionRuntime.prototype.onFocus = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntime.prototype.onBlur = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntime.prototype.onDownThisBefore = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntime.prototype.onDownThisAfter = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntime.prototype.onDblClick = function (shape, runtime, e, interactionManager) {
            // DO NOTHING
        };
        EShapeActionRuntime.prototype.onRender = function (shape, runtime, time, renderer) {
            // DO NOTHING
        };
        return EShapeActionRuntime;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeConditional = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeConditional, _super);
        function EShapeActionRuntimeConditional(value, reset) {
            var _this = _super.call(this, reset) || this;
            _this.condition = EShapeActionExpressions.ofBoolean(value.condition);
            return _this;
        }
        return EShapeActionRuntimeConditional;
    }(EShapeActionRuntime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlink = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlink, _super);
        function EShapeActionRuntimeBlink(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.interval = value.interval;
            return _this;
        }
        EShapeActionRuntimeBlink.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var interval = this.interval;
                var dinterval = interval << 1;
                var elapsed = time % dinterval;
                if (elapsed < interval) {
                    this.toOff(shape, runtime);
                    runtime.effect = time + (interval - elapsed);
                }
                else {
                    this.toOn(shape, runtime);
                    runtime.effect = time + (dinterval - elapsed);
                }
            }
        };
        EShapeActionRuntimeBlink.prototype.toOn = function (shape, runtime) {
            //
        };
        EShapeActionRuntimeBlink.prototype.toOff = function (shape, runtime) {
            //
        };
        return EShapeActionRuntimeBlink;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkBrighten = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkBrighten, _super);
        function EShapeActionRuntimeBlinkBrighten(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeBlinkBrighten.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.brighten(fill.color, 0.5), fill.alpha);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.brighten(stroke.color, 0.5), stroke.alpha);
            var text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.brighten(text.color, 0.5), text.alpha);
            var outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.brighten(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkBrighten;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkColorFill = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkColorFill, _super);
        function EShapeActionRuntimeBlinkColorFill(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.COLOR_FILL) || this;
            _this.color = value.color;
            _this.alpha = value.alpha;
            return _this;
        }
        EShapeActionRuntimeBlinkColorFill.prototype.toOn = function (shape, runtime) {
            shape.fill.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkColorFill;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkColorStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkColorStroke, _super);
        function EShapeActionRuntimeBlinkColorStroke(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.COLOR_STROKE) || this;
            _this.color = value.color;
            _this.alpha = value.alpha;
            return _this;
        }
        EShapeActionRuntimeBlinkColorStroke.prototype.toOn = function (shape, runtime) {
            shape.stroke.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkColorStroke;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkDarken = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkDarken, _super);
        function EShapeActionRuntimeBlinkDarken(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeBlinkDarken.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.darken(fill.color, 0.5), fill.alpha);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.darken(stroke.color, 0.5), stroke.alpha);
            var text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.darken(text.color, 0.5), text.alpha);
            var outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.darken(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkDarken;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkOpacity = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkOpacity, _super);
        function EShapeActionRuntimeBlinkOpacity(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL_AND_STROKE) || this;
        }
        EShapeActionRuntimeBlinkOpacity.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, fill.color, fill.alpha * 0.5);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, stroke.color, stroke.alpha * 0.5);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkOpacity;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkVisibility = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkVisibility, _super);
        function EShapeActionRuntimeBlinkVisibility(value) {
            return _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
        }
        EShapeActionRuntimeBlinkVisibility.prototype.toOn = function (shape, runtime) {
            shape.visible = true;
            runtime.written |= this.reset;
        };
        EShapeActionRuntimeBlinkVisibility.prototype.toOff = function (shape, runtime) {
            shape.visible = false;
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkVisibility;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBlinkType;
    (function (EShapeActionValueBlinkType) {
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["VISIBILITY"] = 0] = "VISIBILITY";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["BRIGHTEN"] = 1] = "BRIGHTEN";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["DARKEN"] = 2] = "DARKEN";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["OPACITY"] = 3] = "OPACITY";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["COLOR_FILL"] = 4] = "COLOR_FILL";
        EShapeActionValueBlinkType[EShapeActionValueBlinkType["COLOR_STROKE"] = 5] = "COLOR_STROKE";
    })(EShapeActionValueBlinkType || (EShapeActionValueBlinkType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBase = /** @class */ (function () {
        function EShapeActionValueBase(type, condition) {
            this.type = type;
            this.condition = condition;
        }
        EShapeActionValueBase.prototype.isEquals = function (value) {
            return this.type === value.type && this.condition === value.condition;
        };
        EShapeActionValueBase.prototype.toLabel = function () {
            return DThemes.getInstance().get("EShapeActionValue").toLabel(this);
        };
        return EShapeActionValueBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueSubtyped = /** @class */ (function (_super) {
        __extends(EShapeActionValueSubtyped, _super);
        function EShapeActionValueSubtyped(type, condition, subtype) {
            var _this = _super.call(this, type, condition) || this;
            _this.subtype = subtype;
            return _this;
        }
        EShapeActionValueSubtyped.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueSubtyped &&
                this.subtype === value.subtype);
        };
        return EShapeActionValueSubtyped;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueType;
    (function (EShapeActionValueType) {
        EShapeActionValueType[EShapeActionValueType["SHOW_HIDE"] = 0] = "SHOW_HIDE";
        EShapeActionValueType[EShapeActionValueType["BLINK"] = 1] = "BLINK";
        EShapeActionValueType[EShapeActionValueType["TRANSFORM"] = 2] = "TRANSFORM";
        EShapeActionValueType[EShapeActionValueType["OPEN"] = 3] = "OPEN";
        EShapeActionValueType[EShapeActionValueType["EMIT_EVENT"] = 4] = "EMIT_EVENT";
        EShapeActionValueType[EShapeActionValueType["CHANGE_COLOR_LEGACY"] = 5] = "CHANGE_COLOR_LEGACY";
        EShapeActionValueType[EShapeActionValueType["CHANGE_TEXT"] = 6] = "CHANGE_TEXT";
        EShapeActionValueType[EShapeActionValueType["CHANGE_CURSOR"] = 7] = "CHANGE_CURSOR";
        EShapeActionValueType[EShapeActionValueType["MISC"] = 8] = "MISC";
        EShapeActionValueType[EShapeActionValueType["CHANGE_COLOR"] = 9] = "CHANGE_COLOR";
    })(EShapeActionValueType || (EShapeActionValueType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValues = /** @class */ (function () {
        function EShapeActionValues() {
        }
        EShapeActionValues.toResource = function (index, parsed, resources) {
            if (0 <= index && index < parsed.length) {
                var id = parsed[index];
                if (isNumber(id) && 0 <= id && id < resources.length) {
                    return resources[id];
                }
            }
            return "";
        };
        return EShapeActionValues;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBlink = /** @class */ (function (_super) {
        __extends(EShapeActionValueBlink, _super);
        function EShapeActionValueBlink(subtype, condition, interval, color, alpha) {
            var _this = _super.call(this, EShapeActionValueType.BLINK, condition, subtype) || this;
            _this.interval = interval;
            _this.color = color;
            _this.alpha = alpha;
            return _this;
        }
        EShapeActionValueBlink.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueBlink &&
                this.interval === value.interval &&
                this.color === value.color &&
                this.alpha === value.alpha);
        };
        EShapeActionValueBlink.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueBlinkType.BRIGHTEN:
                    return new EShapeActionRuntimeBlinkBrighten(this);
                case EShapeActionValueBlinkType.COLOR_FILL:
                    return new EShapeActionRuntimeBlinkColorFill(this);
                case EShapeActionValueBlinkType.COLOR_STROKE:
                    return new EShapeActionRuntimeBlinkColorStroke(this);
                case EShapeActionValueBlinkType.DARKEN:
                    return new EShapeActionRuntimeBlinkDarken(this);
                case EShapeActionValueBlinkType.OPACITY:
                    return new EShapeActionRuntimeBlinkOpacity(this);
                case EShapeActionValueBlinkType.VISIBILITY:
                    return new EShapeActionRuntimeBlinkVisibility(this);
            }
        };
        EShapeActionValueBlink.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.interval + "," + this.color + "," + this.alpha + "]");
        };
        EShapeActionValueBlink.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueBlink(serialized[2], condition, serialized[3], serialized[4], serialized[5]);
        };
        return EShapeActionValueBlink;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilAlpha = /** @class */ (function () {
        function UtilAlpha() {
        }
        UtilAlpha.blend = function (alphaA, alphaB, t) {
            var w = Math.max(0, Math.min(1, t));
            return Math.max(0, Math.min(1, alphaA * (1 - w) + alphaB * w));
        };
        return UtilAlpha;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toReset = function (type) {
        return type << 3;
    };
    var EShapeActionRuntimeChangeColorBase = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBase, _super);
        function EShapeActionRuntimeChangeColorBase(value) {
            return _super.call(this, value, toReset(value.subtype)) || this;
        }
        EShapeActionRuntimeChangeColorBase.prototype.set = function (shape, runtime, time, color, alpha, blend) {
            var reset = this.reset;
            if (color != null) {
                if (alpha != null) {
                    if (blend != null) {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            var base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            var base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            var base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                    }
                    else {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            shape.fill.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            shape.stroke.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            shape.text.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            shape.text.outline.set(undefined, color, alpha);
                        }
                    }
                }
                else {
                    if (blend != null) {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            var base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            var base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            var base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                    }
                    else {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            var base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            var base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            var base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, color, base.alpha);
                        }
                    }
                }
                runtime.written |= reset;
            }
            else if (alpha != null) {
                if (blend != null) {
                    if (reset & EShapeRuntimeReset.COLOR_FILL) {
                        var base = EShapeActionBases.toBaseFill(shape, runtime);
                        shape.fill.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                        var base = EShapeActionBases.toBaseStroke(shape, runtime);
                        shape.stroke.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                        var base = EShapeActionBases.toBaseText(shape, runtime);
                        shape.text.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                        var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                        shape.text.outline.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                }
                else {
                    if (reset & EShapeRuntimeReset.COLOR_FILL) {
                        var base = EShapeActionBases.toBaseFill(shape, runtime);
                        shape.fill.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                        var base = EShapeActionBases.toBaseStroke(shape, runtime);
                        shape.stroke.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                        var base = EShapeActionBases.toBaseText(shape, runtime);
                        shape.text.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                        var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                        shape.text.outline.set(undefined, base.color, alpha);
                    }
                }
                runtime.written |= reset;
            }
        };
        return EShapeActionRuntimeChangeColorBase;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTarget;
    (function (EShapeActionValueChangeColorTarget) {
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["COLOR_AND_ALPHA"] = 0] = "COLOR_AND_ALPHA";
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["COLOR"] = 1] = "COLOR";
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["ALPHA"] = 2] = "ALPHA";
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["CODE"] = 3] = "CODE";
        EShapeActionValueChangeColorTarget[EShapeActionValueChangeColorTarget["BRIGHTNESS"] = 4] = "BRIGHTNESS";
    })(EShapeActionValueChangeColorTarget || (EShapeActionValueChangeColorTarget = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColor = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColor, _super);
        function EShapeActionRuntimeChangeColor(value) {
            var _this = _super.call(this, value) || this;
            switch (value.target) {
                case EShapeActionValueChangeColorTarget.COLOR:
                    _this.color = value.color;
                    _this.alpha = null;
                    break;
                case EShapeActionValueChangeColorTarget.ALPHA:
                    _this.color = null;
                    _this.alpha = value.alpha;
                    break;
                default:
                    _this.color = value.color;
                    _this.alpha = value.alpha;
                    break;
            }
            _this.blend = EShapeActionExpressions.ofNumberOrNull(value.blend);
            return _this;
        }
        EShapeActionRuntimeChangeColor.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var color = this.color;
                var alpha = this.alpha;
                var blend = this.blend(shape, time);
                this.set(shape, runtime, time, color, alpha, blend);
            }
        };
        return EShapeActionRuntimeChangeColor;
    }(EShapeActionRuntimeChangeColorBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorType;
    (function (EShapeActionValueChangeColorType) {
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["NONE"] = 0] = "NONE";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["FILL"] = 1] = "FILL";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["STROKE"] = 2] = "STROKE";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["TEXT"] = 4] = "TEXT";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["TEXT_OUTLINE"] = 8] = "TEXT_OUTLINE";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["FILL_AND_STROKE"] = 3] = "FILL_AND_STROKE";
        EShapeActionValueChangeColorType[EShapeActionValueChangeColorType["ALL"] = 15] = "ALL";
    })(EShapeActionValueChangeColorType || (EShapeActionValueChangeColorType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTypeLegacy;
    (function (EShapeActionValueChangeColorTypeLegacy) {
        EShapeActionValueChangeColorTypeLegacy[EShapeActionValueChangeColorTypeLegacy["FILL"] = 0] = "FILL";
        EShapeActionValueChangeColorTypeLegacy[EShapeActionValueChangeColorTypeLegacy["STROKE"] = 1] = "STROKE";
        EShapeActionValueChangeColorTypeLegacy[EShapeActionValueChangeColorTypeLegacy["FILL_AND_STROKE"] = 2] = "FILL_AND_STROKE";
        EShapeActionValueChangeColorTypeLegacy[EShapeActionValueChangeColorTypeLegacy["TEXT"] = 3] = "TEXT";
        EShapeActionValueChangeColorTypeLegacy[EShapeActionValueChangeColorTypeLegacy["TEXT_OUTLINE"] = 4] = "TEXT_OUTLINE";
        EShapeActionValueChangeColorTypeLegacy[EShapeActionValueChangeColorTypeLegacy["ALL"] = 5] = "ALL";
    })(EShapeActionValueChangeColorTypeLegacy || (EShapeActionValueChangeColorTypeLegacy = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTypes = /** @class */ (function () {
        function EShapeActionValueChangeColorTypes() {
        }
        EShapeActionValueChangeColorTypes.from = function (serialized) {
            if (serialized[0] === EShapeActionValueType.CHANGE_COLOR) {
                return serialized[2];
            }
            switch (serialized[2]) {
                case EShapeActionValueChangeColorTypeLegacy.FILL:
                    return EShapeActionValueChangeColorType.FILL;
                case EShapeActionValueChangeColorTypeLegacy.STROKE:
                    return EShapeActionValueChangeColorType.STROKE;
                case EShapeActionValueChangeColorTypeLegacy.FILL_AND_STROKE:
                    return EShapeActionValueChangeColorType.FILL_AND_STROKE;
                case EShapeActionValueChangeColorTypeLegacy.TEXT:
                    return EShapeActionValueChangeColorType.TEXT;
                case EShapeActionValueChangeColorTypeLegacy.TEXT_OUTLINE:
                    return EShapeActionValueChangeColorType.TEXT_OUTLINE;
                case EShapeActionValueChangeColorTypeLegacy.ALL:
                    return EShapeActionValueChangeColorType.ALL;
            }
        };
        EShapeActionValueChangeColorTypes.unpack = function (type) {
            var result = [];
            if (type & EShapeActionValueChangeColorType.FILL) {
                result.push(EShapeActionValueChangeColorType.FILL);
            }
            if (type & EShapeActionValueChangeColorType.STROKE) {
                result.push(EShapeActionValueChangeColorType.STROKE);
            }
            if (type & EShapeActionValueChangeColorType.TEXT) {
                result.push(EShapeActionValueChangeColorType.TEXT);
            }
            if (type & EShapeActionValueChangeColorType.TEXT_OUTLINE) {
                result.push(EShapeActionValueChangeColorType.TEXT_OUTLINE);
            }
            return result;
        };
        EShapeActionValueChangeColorTypes.pack = function (types) {
            var result = EShapeActionValueChangeColorType.NONE;
            for (var i = 0, imax = types.length; i < imax; ++i) {
                result |= types[i];
            }
            return result;
        };
        return EShapeActionValueChangeColorTypes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColor = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColor, _super);
        function EShapeActionValueChangeColor(subtype, condition, target, color, alpha, blend) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.target = target;
            _this.color = color;
            _this.alpha = alpha;
            _this.blend = blend;
            return _this;
        }
        EShapeActionValueChangeColor.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeColor &&
                this.target === value.target &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        };
        EShapeActionValueChangeColor.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeColor(this);
        };
        EShapeActionValueChangeColor.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var blendId = manager.addResource(this.blend);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.target + "," + this.color + "," + this.alpha + "," + blendId + "]");
        };
        EShapeActionValueChangeColor.deserialize = function (serialized, manager) {
            var subtype = EShapeActionValueChangeColorTypes.from(serialized);
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColor(subtype, condition, serialized[3], serialized[4], serialized[5], blend);
        };
        return EShapeActionValueChangeColor;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorBrightness = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightness, _super);
        function EShapeActionRuntimeChangeColorBrightness(value) {
            var _this = _super.call(this, value) || this;
            _this.brightness = EShapeActionExpressions.ofNumberOrNull(value.brightness);
            return _this;
        }
        EShapeActionRuntimeChangeColorBrightness.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var brightness = this.brightness(shape, time);
                this.set(shape, runtime, time, brightness);
            }
        };
        EShapeActionRuntimeChangeColorBrightness.prototype.set = function (shape, runtime, time, brightness) {
            var reset = this.reset;
            if (brightness != null) {
                var toAdjusted = this.toAdjusted;
                if (reset & EShapeRuntimeReset.COLOR_FILL) {
                    var base = EShapeActionBases.toBaseFill(shape, runtime);
                    shape.fill.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                    var base = EShapeActionBases.toBaseStroke(shape, runtime);
                    shape.stroke.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                    var base = EShapeActionBases.toBaseText(shape, runtime);
                    shape.text.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                    var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                    shape.text.outline.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                runtime.written |= reset;
            }
        };
        EShapeActionRuntimeChangeColorBrightness.prototype.toAdjusted = function (color, brightness) {
            if (0 <= brightness) {
                return UtilRgb.brighten(color, +brightness);
            }
            else {
                return UtilRgb.darken(color, -brightness);
            }
        };
        return EShapeActionRuntimeChangeColorBrightness;
    }(EShapeActionRuntimeChangeColorBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorBrightness = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColorBrightness, _super);
        function EShapeActionValueChangeColorBrightness(subtype, condition, brightness) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.brightness = brightness;
            return _this;
        }
        EShapeActionValueChangeColorBrightness.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeColorBrightness &&
                this.brightness === value.brightness);
        };
        EShapeActionValueChangeColorBrightness.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeColorBrightness(this);
        };
        EShapeActionValueChangeColorBrightness.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var target = EShapeActionValueChangeColorTarget.BRIGHTNESS;
            var brightnessId = manager.addResource(this.brightness);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + target + "," + brightnessId + "]");
        };
        EShapeActionValueChangeColorBrightness.deserialize = function (serialized, manager) {
            var subtype = EShapeActionValueChangeColorTypes.from(serialized);
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var brightness = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueChangeColorBrightness(subtype, condition, brightness);
        };
        return EShapeActionValueChangeColorBrightness;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorCode = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCode, _super);
        function EShapeActionRuntimeChangeColorCode(value) {
            var _this = _super.call(this, value) || this;
            _this.color = EShapeActionExpressions.ofNumberOrNull(value.color);
            _this.alpha = EShapeActionExpressions.ofNumberOrNull(value.alpha);
            _this.blend = EShapeActionExpressions.ofNumberOrNull(value.blend);
            return _this;
        }
        EShapeActionRuntimeChangeColorCode.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var color = this.color(shape, time);
                var alpha = this.alpha(shape, time);
                var blend = this.blend(shape, time);
                this.set(shape, runtime, time, color, alpha, blend);
            }
        };
        return EShapeActionRuntimeChangeColorCode;
    }(EShapeActionRuntimeChangeColorBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorCode = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColorCode, _super);
        function EShapeActionValueChangeColorCode(subtype, condition, color, alpha, blend) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.color = color;
            _this.alpha = alpha;
            _this.blend = blend;
            return _this;
        }
        EShapeActionValueChangeColorCode.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeColorCode &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        };
        EShapeActionValueChangeColorCode.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeColorCode(this);
        };
        EShapeActionValueChangeColorCode.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var target = EShapeActionValueChangeColorTarget.CODE;
            var colorId = manager.addResource(this.color);
            var alphaId = manager.addResource(this.alpha);
            var blendId = manager.addResource(this.blend);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + target + "," + colorId + "," + alphaId + "," + blendId + "]");
        };
        EShapeActionValueChangeColorCode.deserialize = function (serialized, manager) {
            var subtype = EShapeActionValueChangeColorTypes.from(serialized);
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var color = EShapeActionValues.toResource(4, serialized, manager.resources);
            var alpha = EShapeActionValues.toResource(5, serialized, manager.resources);
            var blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColorCode(subtype, condition, color, alpha, blend);
        };
        return EShapeActionValueChangeColorCode;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeCursor = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeCursor, _super);
        function EShapeActionRuntimeChangeCursor(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.CURSOR) || this;
            _this.name = EShapeActionExpressions.ofStringOrNull(value.name);
            return _this;
        }
        EShapeActionRuntimeChangeCursor.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var name_1 = this.name(shape, time);
                if (name_1 != null) {
                    shape.cursor = name_1;
                    runtime.written |= this.reset;
                }
            }
        };
        return EShapeActionRuntimeChangeCursor;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeCursor = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeCursor, _super);
        function EShapeActionValueChangeCursor(condition, name) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_CURSOR, condition) || this;
            _this.name = name;
            return _this;
        }
        EShapeActionValueChangeCursor.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeCursor &&
                this.name === value.name);
        };
        EShapeActionValueChangeCursor.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeCursor(this);
        };
        EShapeActionValueChangeCursor.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var nameId = manager.addResource(this.name);
            return manager.addResource("[" + this.type + "," + conditionId + "," + nameId + "]");
        };
        EShapeActionValueChangeCursor.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueChangeCursor(condition, name);
        };
        return EShapeActionValueChangeCursor;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeA = /** @class */ (function () {
        function FormatNodeA() {
        }
        FormatNodeA.prototype.format = function (target, step, date) {
            return date.getHours() < 12 ? "AM" : "PM";
        };
        return FormatNodeA;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodea = /** @class */ (function () {
        function FormatNodea() {
        }
        FormatNodea.prototype.format = function (target, step, date) {
            return date.getHours() < 12 ? "am" : "pm";
        };
        return FormatNodea;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeD = /** @class */ (function () {
        function FormatNodeD() {
        }
        FormatNodeD.prototype.format = function (target, step, date) {
            return String(date.getDate());
        };
        return FormatNodeD;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoded = /** @class */ (function () {
        function FormatNoded() {
        }
        FormatNoded.prototype.format = function (target, step, date) {
            return "" + (target | 0);
        };
        return FormatNoded;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePrecision = /** @class */ (function () {
        function FormatNodePrecision(precision) {
            if (precision != null) {
                this.precision = +precision.substring(1, precision.length);
            }
            else {
                this.precision = undefined;
            }
        }
        return FormatNodePrecision;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodee = /** @class */ (function (_super) {
        __extends(FormatNodee, _super);
        function FormatNodee() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodee.prototype.format = function (target, step, date) {
            return target.toExponential(this.precision);
        };
        return FormatNodee;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodef = /** @class */ (function (_super) {
        __extends(FormatNodef, _super);
        function FormatNodef() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodef.prototype.format = function (target, step, date) {
            return target.toFixed(this.precision);
        };
        return FormatNodef;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodefsi = /** @class */ (function (_super) {
        __extends(FormatNodefsi, _super);
        function FormatNodefsi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodefsi.prototype.format = function (target, step, date) {
            var abs = this.toAbs(target, step, date);
            if (abs < 1e-24) {
                return this.format_(target, 1, "");
            }
            else if (abs < 1e-21) {
                return this.format_(target, 1e24, "y");
            }
            else if (abs < 1e-18) {
                return this.format_(target, 1e21, "z");
            }
            else if (abs < 1e-15) {
                return this.format_(target, 1e18, "a");
            }
            else if (abs < 1e-12) {
                return this.format_(target, 1e15, "f");
            }
            else if (abs < 1e-9) {
                return this.format_(target, 1e12, "p");
            }
            else if (abs < 1e-6) {
                return this.format_(target, 1e9, "n");
            }
            else if (abs < 1e-3) {
                return this.format_(target, 1e6, "");
            }
            else if (abs < 1) {
                return this.format_(target, 1e3, "m");
            }
            else if (abs < 1e3) {
                return this.format_(target, 1, "");
            }
            else if (abs < 1e6) {
                return this.format_(target, 1e-3, "k");
            }
            else if (abs < 1e9) {
                return this.format_(target, 1e-6, "M");
            }
            else if (abs < 1e12) {
                return this.format_(target, 1e-9, "G");
            }
            else if (abs < 1e15) {
                return this.format_(target, 1e-12, "T");
            }
            else if (abs < 1e18) {
                return this.format_(target, 1e-15, "P");
            }
            else if (abs < 1e21) {
                return this.format_(target, 1e-18, "E");
            }
            else if (abs < 1e24) {
                return this.format_(target, 1e-21, "Z");
            }
            else {
                return this.format_(target, 1e-24, "Y");
            }
        };
        FormatNodefsi.prototype.toAbs = function (target, step, date) {
            return Math.abs(target);
        };
        FormatNodefsi.prototype.format_ = function (target, unitInverse, postfix) {
            var value = target * unitInverse;
            return "" + value.toFixed(this.precision) + postfix;
        };
        return FormatNodefsi;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeg = /** @class */ (function (_super) {
        __extends(FormatNodeg, _super);
        function FormatNodeg() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodeg.prototype.format = function (target, step, date) {
            return target.toPrecision(this.precision);
        };
        return FormatNodeg;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeH = /** @class */ (function () {
        function FormatNodeH() {
        }
        FormatNodeH.prototype.format = function (target, step, date) {
            return String(date.getHours());
        };
        return FormatNodeH;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeh = /** @class */ (function () {
        function FormatNodeh() {
        }
        FormatNodeh.prototype.format = function (target, step, date) {
            return String(date.getHours() % 12);
        };
        return FormatNodeh;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeM = /** @class */ (function () {
        function FormatNodeM() {
        }
        FormatNodeM.prototype.format = function (target, step, date) {
            return String(date.getMonth() + 1);
        };
        return FormatNodeM;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodem = /** @class */ (function () {
        function FormatNodem() {
        }
        FormatNodem.prototype.format = function (target, step, date) {
            return String(date.getMinutes());
        };
        return FormatNodem;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodemi = /** @class */ (function () {
        function FormatNodemi() {
        }
        FormatNodemi.prototype.format = function (target, step, date) {
            return String(date.getMilliseconds());
        };
        return FormatNodemi;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeP = /** @class */ (function () {
        function FormatNodeP() {
        }
        FormatNodeP.prototype.format = function (target, step, date) {
            return ((target * 100) | 0) + "%";
        };
        return FormatNodeP;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodep = /** @class */ (function () {
        function FormatNodep() {
        }
        FormatNodep.prototype.format = function (target, step, date) {
            return (target | 0) + "%";
        };
        return FormatNodep;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePadding = /** @class */ (function () {
        function FormatNodePadding(length, character, node) {
            this.length = length;
            this.character = character;
            this.node = node;
        }
        FormatNodePadding.prototype.format = function (target, step, date) {
            return toPadded(this.node.format(target, step, date), this.length, this.character);
        };
        return FormatNodePadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeParenthesis = /** @class */ (function () {
        function FormatNodeParenthesis(node) {
            this.node = node;
        }
        FormatNodeParenthesis.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] === "-") {
                return "(" + result.substring(1, result.length) + ")";
            }
            return result;
        };
        return FormatNodeParenthesis;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePlus = /** @class */ (function () {
        function FormatNodePlus(node) {
            this.node = node;
        }
        FormatNodePlus.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return "+" + result;
            }
            return result;
        };
        return FormatNodePlus;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeRP = /** @class */ (function () {
        function FormatNodeRP() {
        }
        FormatNodeRP.prototype.format = function (target, step, date) {
            return Math.round(target * 100) + "%";
        };
        return FormatNodeRP;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoderp = /** @class */ (function () {
        function FormatNoderp() {
        }
        FormatNoderp.prototype.format = function (target, step, date) {
            return Math.round(target) + "%";
        };
        return FormatNoderp;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodesdt = /** @class */ (function () {
        function FormatNodesdt(Y, M, D, H, m, s, mi) {
            this.Y = Y;
            this.M = M;
            this.D = D;
            this.H = H;
            this.m = m;
            this.s = s;
            this.mi = mi;
        }
        FormatNodesdt.prototype.format = function (target, step, date) {
            if (step < 1000) {
                return this.s.format(target, step, date) + "." + this.mi.format(target, step, date);
            }
            else if (step < 60000) {
                return this.m.format(target, step, date) + ":" + this.s.format(target, step, date);
            }
            else if (step < 3600000) {
                return this.H.format(target, step, date) + ":" + this.m.format(target, step, date);
            }
            else if (step < 86400000) {
                var M = this.M.format(target, step, date);
                var D = this.D.format(target, step, date);
                return M + "/" + D + " " + this.H.format(target, step, date);
            }
            else if (step < 2592000000) {
                return this.M.format(target, step, date) + "/" + this.D.format(target, step, date);
            }
            else {
                return this.Y.format(target, step, date) + "/" + this.M.format(target, step, date);
            }
        };
        return FormatNodesdt;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeSpace = /** @class */ (function () {
        function FormatNodeSpace(node) {
            this.node = node;
        }
        FormatNodeSpace.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return " " + result;
            }
            return result;
        };
        return FormatNodeSpace;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodessi = /** @class */ (function (_super) {
        __extends(FormatNodessi, _super);
        function FormatNodessi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodessi.prototype.toAbs = function (target, step, date) {
            return Math.abs(step);
        };
        return FormatNodessi;
    }(FormatNodefsi));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeString = /** @class */ (function () {
        function FormatNodeString(str) {
            this.str = str;
        }
        FormatNodeString.prototype.format = function (target, step, date) {
            return this.str;
        };
        return FormatNodeString;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeY = /** @class */ (function () {
        function FormatNodeY() {
        }
        FormatNodeY.prototype.format = function (target, step, date) {
            return String(date.getFullYear());
        };
        return FormatNodeY;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodey = /** @class */ (function () {
        function FormatNodey() {
        }
        FormatNodey.prototype.format = function (target, step, date) {
            return String(date.getFullYear() % 100);
        };
        return FormatNodey;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodez = /** @class */ (function () {
        function FormatNodez() {
        }
        FormatNodez.prototype.format = function (target, step, date) {
            var z = date.getTimezoneOffset();
            var tzs = z <= 0 ? "+" : "-";
            var tzh = toPadded(String(Math.floor(Math.abs(z) / 60)), 2, "0");
            var tzm = toPadded(String(Math.floor(Math.abs(z) % 60)), 2, "0");
            return "" + tzs + tzh + ":" + tzm;
        };
        return FormatNodez;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoderd = /** @class */ (function () {
        function FormatNoderd() {
        }
        FormatNoderd.prototype.format = function (target, step, date) {
            return "" + Math.round(target);
        };
        return FormatNoderd;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodes = /** @class */ (function () {
        function FormatNodes() {
        }
        FormatNodes.prototype.format = function (target, step, date) {
            return String(date.getSeconds());
        };
        return FormatNodes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var REGEXP = /%(0|_|-|\+|\()?(\.\d+)?(Y(?:MD?)?|y(?:MD?)?|MD?|D|H(?:ms?)?|h(?:ms?)?|m(?:i|s)?|a|A|s(?:s?i|dt)?|z|%|f(?:si)?|e|g|d|r(?:d|p)|p|P|RP)/g;
    /**
     * A NumberFormatter implementation class.
     */
    var NumberFormatterImpl = /** @class */ (function () {
        function NumberFormatterImpl(format) {
            var previousIndex = 0;
            var isDateRequired = false;
            var nodes = [];
            REGEXP.lastIndex = 0;
            while (true) {
                var matched = REGEXP.exec(format);
                if (matched != null) {
                    var index = matched.index;
                    if (previousIndex < index) {
                        nodes.push(new FormatNodeString(format.substring(previousIndex, index)));
                    }
                    previousIndex = index + matched[0].length;
                    var all = matched[0];
                    var modifier = matched[1];
                    var precision = matched[2];
                    var specifier = matched[3];
                    switch (specifier) {
                        case "Y": // full year
                            isDateRequired = true;
                            nodes.push(new FormatNodeY());
                            break;
                        case "YM":
                            isDateRequired = true;
                            nodes.push(new FormatNodeY(), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()));
                            break;
                        case "YMD":
                            isDateRequired = true;
                            nodes.push(new FormatNodeY(), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeD()));
                            break;
                        case "y": // short year: [0, 99]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodey()));
                            break;
                        case "yM":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodey()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()));
                            break;
                        case "yMD":
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodey()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeD()));
                            break;
                        case "M": // month: [1, 12]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeM()));
                            break;
                        case "MD":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeM()), new FormatNodeString("/"), this.toModifiedNodeDatetime2(modifier, new FormatNodeD()));
                            break;
                        case "D": // day of the month: [1, 31]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeD()));
                            break;
                        case "H": // 24-hour clock: [0, 23]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeH()));
                            break;
                        case "Hm":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeH()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodem()));
                            break;
                        case "Hms":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeH()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodem()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodes()));
                            break;
                        case "h": // 12-hour clock: [1, 12]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeh()));
                            break;
                        case "hm":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeh()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodem()));
                            break;
                        case "hms":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodeh()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodem()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodes()));
                            break;
                        case "m": // minute [0, 59]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodem()));
                            break;
                        case "ms":
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodem()), new FormatNodeString(":"), this.toModifiedNodeDatetime2(modifier, new FormatNodes()));
                            break;
                        case "mi": // milliseconds [0, 999]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime3(modifier, new FormatNodemi()));
                            break;
                        case "a": // am or pm
                            isDateRequired = true;
                            nodes.push(new FormatNodea());
                            break;
                        case "A": // AM or PM
                            isDateRequired = true;
                            nodes.push(new FormatNodeA());
                            break;
                        case "s": // seconds: [0, 61]
                            isDateRequired = true;
                            nodes.push(this.toModifiedNodeDatetime2(modifier, new FormatNodes()));
                            break;
                        case "sdt":
                            isDateRequired = true;
                            nodes.push(new FormatNodesdt(new FormatNodeY(), this.toModifiedNodeDatetime2(modifier, new FormatNodeM()), this.toModifiedNodeDatetime2(modifier, new FormatNodeD()), this.toModifiedNodeDatetime2(modifier, new FormatNodeH()), this.toModifiedNodeDatetime2(modifier, new FormatNodem()), this.toModifiedNodeDatetime2(modifier, new FormatNodes()), this.toModifiedNodeDatetime3(modifier, new FormatNodemi())));
                            break;
                        case "z": // time zone
                            isDateRequired = true;
                            nodes.push(new FormatNodez());
                            break;
                        case "%": // a % literal
                            nodes.push(new FormatNodeString("%"));
                            break;
                        case "f": // fixed point notation
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodef(precision)));
                            break;
                        case "e": // exponent notation
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodee(precision)));
                            break;
                        case "g": // %f or %e
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodeg(precision)));
                            break;
                        case "rd": // rounded decimal notation
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNoderd()));
                            break;
                        case "d": // decimal notation
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNoded()));
                            break;
                        case "P": // percent notation (Multiplied by 100)
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodeP()));
                            break;
                        case "p": // percent notation (Not multiplied by 100)
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodep()));
                            break;
                        case "RP": // percent notation (Multiplied by 100)
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodeRP()));
                            break;
                        case "rp": // percent notation (Not multiplied by 100)
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNoderp()));
                            break;
                        case "fsi": // fixed point notation with a SI prefix
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodefsi(precision)));
                            break;
                        case "ssi": // Step-based fixed point notation with a SI prefix
                            nodes.push(this.toModifiedNodeNumber(modifier, new FormatNodessi(precision)));
                            break;
                        default:
                            nodes.push(new FormatNodeString(all));
                            break;
                    }
                }
                else {
                    if (previousIndex < format.length) {
                        nodes.push(new FormatNodeString(format.substring(previousIndex, format.length)));
                    }
                    break;
                }
            }
            this.isDateRequired = isDateRequired;
            this.nodes = nodes;
            this.date = new Date();
        }
        NumberFormatterImpl.prototype.toModifiedNodeDatetime2 = function (modifier, node) {
            switch (modifier) {
                case "_":
                    return new FormatNodePadding(2, " ", node);
                case "-":
                    return node;
                default:
                    return new FormatNodePadding(2, "0", node);
            }
        };
        NumberFormatterImpl.prototype.toModifiedNodeDatetime3 = function (modifier, node) {
            switch (modifier) {
                case "_":
                    return new FormatNodePadding(3, " ", node);
                case "-":
                    return node;
                default:
                    return new FormatNodePadding(3, "0", node);
            }
        };
        NumberFormatterImpl.prototype.toModifiedNodeNumber = function (modifier, node) {
            switch (modifier) {
                case "_": // space for non-negative numbers
                    return new FormatNodeSpace(node);
                case "+": // plus sign for non-negative numbers
                    return new FormatNodePlus(node);
                case "(": // parenthesis for the negative numbers
                    return new FormatNodeParenthesis(node);
                default:
                    return node;
            }
        };
        NumberFormatterImpl.prototype.format = function (target, step) {
            var nodes = this.nodes;
            var date = this.date;
            if (this.isDateRequired) {
                date.setTime(target);
            }
            var result = "";
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                result += nodes[i].format(target, step, date);
            }
            return result;
        };
        return NumberFormatterImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An number formatter utility class.
     */
    var NumberFormatters = /** @class */ (function () {
        function NumberFormatters() {
        }
        /**
         * Creates a number formatter of the given format.
         * Please refer to {@link NumberFormatter} for format details.
         *
         * @return A created number formatter
         */
        NumberFormatters.create = function (format) {
            return new NumberFormatterImpl(format);
        };
        return NumberFormatters;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeTextNumber = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeTextNumber, _super);
        function EShapeActionRuntimeChangeTextNumber(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.TEXT) || this;
            _this.number = EShapeActionExpressions.ofNumber(value.value);
            _this.formatters = new Map();
            return _this;
        }
        EShapeActionRuntimeChangeTextNumber.prototype.getFormatter = function (shape, runtime) {
            var formatters = this.formatters;
            var text = runtime.text.value;
            var result = formatters.get(text);
            if (result === undefined) {
                result = this.newFormatter(text);
                formatters.set(text, result);
            }
            return result;
        };
        EShapeActionRuntimeChangeTextNumber.prototype.newFormatter = function (format) {
            format = format.trim();
            if (0 < format.length) {
                return NumberFormatters.create(format);
            }
            return null;
        };
        EShapeActionRuntimeChangeTextNumber.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var value = this.number(shape, time);
                var formatter = this.getFormatter(shape, runtime);
                shape.text.value = formatter != null ? formatter.format(value, 0) : String(value);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeTextNumber;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeTextText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeTextText, _super);
        function EShapeActionRuntimeChangeTextText(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.TEXT) || this;
            _this.text = EShapeActionExpressions.ofString(value.value);
            return _this;
        }
        EShapeActionRuntimeChangeTextText.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                shape.text.value = this.text(shape, time);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeTextText;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeTextType;
    (function (EShapeActionValueChangeTextType) {
        EShapeActionValueChangeTextType[EShapeActionValueChangeTextType["TEXT"] = 0] = "TEXT";
        EShapeActionValueChangeTextType[EShapeActionValueChangeTextType["NUMBER"] = 1] = "NUMBER";
    })(EShapeActionValueChangeTextType || (EShapeActionValueChangeTextType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeText = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeText, _super);
        function EShapeActionValueChangeText(subtype, condition, value) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_TEXT, condition, subtype) || this;
            _this.value = value;
            return _this;
        }
        EShapeActionValueChangeText.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeText &&
                this.value === value.value);
        };
        EShapeActionValueChangeText.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueChangeTextType.TEXT:
                    return new EShapeActionRuntimeChangeTextText(this);
                case EShapeActionValueChangeTextType.NUMBER:
                    return new EShapeActionRuntimeChangeTextNumber(this);
            }
        };
        EShapeActionValueChangeText.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var valueId = manager.addResource(this.value);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + valueId + "]");
        };
        EShapeActionValueChangeText.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var value = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueChangeText(serialized[2], condition, value);
        };
        return EShapeActionValueChangeText;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackground = /** @class */ (function () {
        function DBaseBackground(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var background = options === null || options === void 0 ? void 0 : options.background;
            if (background) {
                this._color = background.color;
                this._alpha = background.alpha;
            }
        }
        DBaseBackground.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseBackground.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseBackground.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBackgroundColor(state);
        };
        Object.defineProperty(DBaseBackground.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackground.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBackgroundAlpha(state);
        };
        Object.defineProperty(DBaseBackground.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackground.prototype.onChange = function () {
            var callback = this._callback;
            if (callback != null) {
                callback();
            }
        };
        return DBaseBackground;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A border mask.
     * Borders on masked parts are not rendered.
     */
    var DBorderMask;
    (function (DBorderMask) {
        DBorderMask[DBorderMask["NONE"] = 0] = "NONE";
        DBorderMask[DBorderMask["TOP"] = 1] = "TOP";
        DBorderMask[DBorderMask["RIGHT"] = 2] = "RIGHT";
        DBorderMask[DBorderMask["BOTTOM"] = 4] = "BOTTOM";
        DBorderMask[DBorderMask["LEFT"] = 8] = "LEFT";
        DBorderMask[DBorderMask["TOP_RIGHT"] = 3] = "TOP_RIGHT";
        DBorderMask[DBorderMask["TOP_BOTTOM"] = 5] = "TOP_BOTTOM";
        DBorderMask[DBorderMask["TOP_LEFT"] = 9] = "TOP_LEFT";
        DBorderMask[DBorderMask["RIGHT_BOTTOM"] = 6] = "RIGHT_BOTTOM";
        DBorderMask[DBorderMask["RIGHT_LEFT"] = 10] = "RIGHT_LEFT";
        DBorderMask[DBorderMask["BOTTOM_LEFT"] = 12] = "BOTTOM_LEFT";
        DBorderMask[DBorderMask["NOT_TOP"] = 14] = "NOT_TOP";
        DBorderMask[DBorderMask["NOT_RIGHT"] = 13] = "NOT_RIGHT";
        DBorderMask[DBorderMask["NOT_BOTTOM"] = 11] = "NOT_BOTTOM";
        DBorderMask[DBorderMask["NOT_LEFT"] = 7] = "NOT_LEFT";
        DBorderMask[DBorderMask["ALL"] = 15] = "ALL";
    })(DBorderMask || (DBorderMask = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toEnum = function (target, te) {
        return isString(target) ? te[target] : target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorder = /** @class */ (function () {
        function DBaseBorder(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var border = options === null || options === void 0 ? void 0 : options.border;
            if (border) {
                this._color = border.color;
                this._alpha = border.alpha;
                this._width = border.width;
                this._align = border.align;
                this._mask = toEnum(border.mask, DBorderMask);
            }
        }
        DBaseBorder.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseBorder.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseBorder.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBorderColor(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBorderAlpha(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getWidth = function (state) {
            var width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    var result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getBorderWidth(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getAlign = function (state) {
            var align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    var result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getBorderAlign(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getMask = function (state) {
            var mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    var result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getBorderMask(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.onChange = function () {
            var callback = this._callback;
            if (callback != null) {
                callback();
            }
        };
        return DBaseBorder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCornerMask;
    (function (DCornerMask) {
        DCornerMask[DCornerMask["NONE"] = 0] = "NONE";
        DCornerMask[DCornerMask["TOP_LEFT"] = 1] = "TOP_LEFT";
        DCornerMask[DCornerMask["TOP_RIGHT"] = 2] = "TOP_RIGHT";
        DCornerMask[DCornerMask["BOTTOM_LEFT"] = 4] = "BOTTOM_LEFT";
        DCornerMask[DCornerMask["BOTTOM_RIGHT"] = 8] = "BOTTOM_RIGHT";
        DCornerMask[DCornerMask["TOP"] = 3] = "TOP";
        DCornerMask[DCornerMask["BOTTOM"] = 12] = "BOTTOM";
        DCornerMask[DCornerMask["LEFT"] = 5] = "LEFT";
        DCornerMask[DCornerMask["RIGHT"] = 10] = "RIGHT";
        DCornerMask[DCornerMask["ALL"] = 15] = "ALL";
    })(DCornerMask || (DCornerMask = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseCorner = /** @class */ (function () {
        function DBaseCorner(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var corner = options === null || options === void 0 ? void 0 : options.corner;
            if (corner) {
                if (isNumber(corner)) {
                    this._radius = corner;
                    this._mask = undefined;
                }
                else {
                    this._radius = corner.radius;
                    this._mask = toEnum(corner.mask, DCornerMask);
                }
            }
        }
        DBaseCorner.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseCorner.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseCorner.prototype.getRadius = function () {
            var _a;
            return (_a = this._radius) !== null && _a !== void 0 ? _a : this._theme.getCornerRadius();
        };
        Object.defineProperty(DBaseCorner.prototype, "radius", {
            get: function () {
                return this._radius;
            },
            set: function (radius) {
                if (this._radius !== radius) {
                    this._radius = radius;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseCorner.prototype.getMask = function () {
            var _a;
            return (_a = this._mask) !== null && _a !== void 0 ? _a : this._theme.getCornerMask();
        };
        Object.defineProperty(DBaseCorner.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseCorner.prototype.set = function (radius, mask) {
            var isChanged = false;
            if (this._radius !== radius) {
                this._radius = radius;
                isChanged = true;
            }
            if (this._mask !== mask) {
                this._mask = mask;
                isChanged = true;
            }
            var callback = this._callback;
            if (isChanged && callback != null) {
                callback();
            }
        };
        return DBaseCorner;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * DBase interactivity.
     * Mouse / touch events are triggered only on interactive objects.
     */
    var DBaseInteractive;
    (function (DBaseInteractive) {
        /**
         * Not interactive.
         */
        DBaseInteractive[DBaseInteractive["NONE"] = 0] = "NONE";
        /**
         * Interactive.
         * However children are not interactive.
         */
        DBaseInteractive[DBaseInteractive["SELF"] = 1] = "SELF";
        /**
         * Not interactive.
         * However children are interactive.
         */
        DBaseInteractive[DBaseInteractive["CHILDREN"] = 2] = "CHILDREN";
        /**
         * Interactive.
         * Children are also interactive.
         */
        DBaseInteractive[DBaseInteractive["BOTH"] = 3] = "BOTH";
    })(DBaseInteractive || (DBaseInteractive = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOutline = /** @class */ (function () {
        function DBaseOutline(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var outline = options === null || options === void 0 ? void 0 : options.outline;
            if (outline) {
                this._color = outline.color;
                this._alpha = outline.alpha;
                this._width = outline.width;
                this._offset = outline.offset;
                this._align = outline.align;
                this._mask = toEnum(outline.mask, DBorderMask);
            }
        }
        DBaseOutline.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseOutline.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseOutline.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getOutlineColor(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getOutlineAlpha(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getWidth = function (state) {
            var width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    var result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getOutlineWidth(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getOffset = function (state) {
            var offset = this._offset;
            if (offset !== undefined) {
                if (isFunction(offset)) {
                    var result = offset(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return offset;
                }
            }
            return this._theme.getOutlineOffset(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            set: function (offset) {
                if (this._offset !== offset) {
                    this._offset = offset;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getAlign = function (state) {
            var align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    var result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getOutlineAlign(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getMask = function (state) {
            var mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    var result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getOutlineMask(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        return DBaseOutline;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePadding = /** @class */ (function () {
        function DBasePadding(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var padding = options === null || options === void 0 ? void 0 : options.padding;
            if (padding) {
                if (isNumber(padding)) {
                    this._left = padding;
                    this._top = padding;
                    this._right = padding;
                    this._bottom = padding;
                }
                else {
                    this._left = padding.left;
                    this._top = padding.top;
                    this._right = padding.right;
                    this._bottom = padding.bottom;
                }
            }
        }
        DBasePadding.prototype.getTheme = function () {
            return this._theme;
        };
        DBasePadding.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBasePadding.prototype.getCallback = function () {
            return this._callback;
        };
        DBasePadding.prototype.getLeft = function () {
            var _a;
            return (_a = this._left) !== null && _a !== void 0 ? _a : this._theme.getPaddingLeft();
        };
        Object.defineProperty(DBasePadding.prototype, "left", {
            get: function () {
                return this._left;
            },
            set: function (left) {
                if (this._left !== left) {
                    this._left = left;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.getTop = function () {
            var _a;
            return (_a = this._top) !== null && _a !== void 0 ? _a : this._theme.getPaddingTop();
        };
        Object.defineProperty(DBasePadding.prototype, "top", {
            get: function () {
                return this._top;
            },
            set: function (top) {
                if (this._top !== top) {
                    this._top = top;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.getRight = function () {
            var _a;
            return (_a = this._right) !== null && _a !== void 0 ? _a : this._theme.getPaddingRight();
        };
        Object.defineProperty(DBasePadding.prototype, "right", {
            get: function () {
                return this._right;
            },
            set: function (right) {
                if (this._right !== right) {
                    this._right = right;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.getBottom = function () {
            var _a;
            return (_a = this._bottom) !== null && _a !== void 0 ? _a : this._theme.getPaddingBottom();
        };
        Object.defineProperty(DBasePadding.prototype, "bottom", {
            get: function () {
                return this._bottom;
            },
            set: function (bottom) {
                if (this._bottom !== bottom) {
                    this._bottom = bottom;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.set = function (top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
            if (this._callback != null) {
                this._callback();
            }
        };
        return DBasePadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePoint = /** @class */ (function () {
        function DBasePoint(point, onChange) {
            this._point = point;
            this._onChange = onChange;
        }
        Object.defineProperty(DBasePoint.prototype, "x", {
            get: function () {
                return this._point.x;
            },
            set: function (x) {
                var point = this._point;
                var oldX = point.x;
                if (oldX !== x) {
                    point.x = x;
                    var y = point.y;
                    this._onChange(x, y, oldX, y);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBasePoint.prototype, "y", {
            get: function () {
                return this._point.y;
            },
            set: function (y) {
                var point = this._point;
                var oldY = point.y;
                if (oldY !== y) {
                    point.y = y;
                    var x = point.x;
                    this._onChange(x, y, x, oldY);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePoint.prototype.set = function (x, y) {
            var point = this._point;
            var oldX = point.x;
            var oldY = point.y;
            if (oldX !== x || oldY !== y) {
                point.set(x, y);
                this._onChange(x, y, oldX, oldY);
            }
            return this;
        };
        DBasePoint.prototype.copyFrom = function (target) {
            var x = target.x;
            var y = target.y;
            var point = this._point;
            var oldX = point.x;
            var oldY = point.y;
            if (oldX !== x || oldY !== y) {
                point.copyFrom(target);
                this._onChange(x, y, oldX, oldY);
            }
            return this;
        };
        DBasePoint.prototype.copyTo = function (target) {
            return target.copyFrom(this._point);
        };
        DBasePoint.prototype.copy = function () {
            // eslint-disable-next-line prefer-rest-params
            return this.copyFrom(arguments[0]);
        };
        DBasePoint.prototype.clone = function (onChange) {
            return new DBasePoint(this._point, onChange || this._onChange);
        };
        DBasePoint.prototype.equals = function (p) {
            return this._point.equals(p);
        };
        return DBasePoint;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseBackgroundMeshGeometry, _super);
        function DBaseBackgroundMeshGeometry(texture, width, height, borderSize, cornerMask) {
            var _this = _super.call(this, new Float32Array(56), new Float32Array(56), new Uint16Array(42)) || this;
            _this._width = width;
            _this._height = height;
            _this._texture = texture;
            _this._borderSize = borderSize;
            _this._cornerMask = cornerMask;
            _this._isDirty = true;
            _this._textureId = NaN;
            _this._vertexBuffer = _this.getBuffer("aVertexPosition");
            _this._vertices = _this._vertexBuffer.data;
            _this._uvBuffer = _this.getBuffer("aTextureCoord");
            _this._uvs = _this._uvBuffer.data;
            _this._indexBuffer = _this.getIndex();
            _this._indices = _this._indexBuffer.data;
            return _this;
        }
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "borderSize", {
            get: function () {
                return this._borderSize;
            },
            set: function (borderSize) {
                if (this._borderSize !== borderSize) {
                    this._borderSize = borderSize;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "cornerMask", {
            get: function () {
                return this._cornerMask;
            },
            set: function (cornerMask) {
                if (this._cornerMask !== cornerMask) {
                    this._cornerMask = cornerMask;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (height) {
                if (this._height !== height) {
                    this._height = height;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMeshGeometry.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            set: function (texture) {
                if (this._texture !== texture) {
                    this._texture = texture;
                    this._isDirty = true;
                    this._textureId = NaN;
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackgroundMeshGeometry.prototype.getTextureId = function () {
            return this._texture._updateID;
        };
        DBaseBackgroundMeshGeometry.prototype.fillVertices = function (iv, array, x0, x1, y0, y1) {
            array[iv + 0] = x0;
            array[iv + 1] = y0;
            array[iv + 2] = x1;
            array[iv + 3] = y0;
            array[iv + 4] = x0;
            array[iv + 5] = y1;
            array[iv + 6] = x1;
            array[iv + 7] = y1;
        };
        DBaseBackgroundMeshGeometry.prototype.fillIndices = function (ii, indices, iv) {
            indices[ii + 0] = iv + 0;
            indices[ii + 1] = iv + 1;
            indices[ii + 2] = iv + 2;
            indices[ii + 3] = iv + 1;
            indices[ii + 4] = iv + 3;
            indices[ii + 5] = iv + 2;
        };
        DBaseBackgroundMeshGeometry.prototype.fillUvsCorner = function (iv, uvs, c, u0, u1, u2, u3, v0, v1, v2, v3) {
            if (c) {
                this.fillVertices(iv, uvs, u0, u1, v0, v1);
            }
            else {
                this.fillVertices(iv, uvs, u3, u2, v0, v1);
            }
        };
        DBaseBackgroundMeshGeometry.prototype.fillUvs = function (iv, uvs, u0, u1, v0, v1) {
            this.fillVertices(iv, uvs, u0, u1, v0, v1);
        };
        DBaseBackgroundMeshGeometry.prototype.update = function () {
            var texture = this.texture;
            if (!texture.valid) {
                return;
            }
            var textureId = this.getTextureId();
            if (this._isDirty || this._textureId !== textureId) {
                this._isDirty = false;
                this._textureId = textureId;
                var vertices = this._vertices;
                var uvs = this._uvs;
                var indices = this._indices;
                var width = this._width;
                var height = this._height;
                var borderSize = this._borderSize;
                var x0 = 0;
                var x1 = Math.min(width * 0.5, borderSize);
                var x2 = Math.max(width * 0.5, width - borderSize);
                var x3 = width;
                var y0 = 0;
                var y1 = Math.min(height * 0.5, borderSize);
                var y2 = Math.max(height * 0.5, height - borderSize);
                var y3 = height;
                var textureUvs = texture._uvs;
                var l = textureUvs.x0;
                var r = textureUvs.x1;
                var t = textureUvs.y0;
                var b = textureUvs.y3;
                var w = (r - l) * (borderSize / texture.width);
                var h = (b - t) * (borderSize / texture.height);
                var u0 = l;
                var u1 = l + w;
                var u2 = r - w;
                var u3 = r;
                var v0 = t;
                var v1 = t + h;
                var v2 = b - h;
                var v3 = b;
                var cornerMask = this._cornerMask;
                var ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                var ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                var cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                var cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                var iv = 0;
                var ia = 0;
                var ii = 0;
                // Top left
                this.fillVertices(iv, vertices, x0, x1, y0, y1);
                this.fillUvsCorner(iv, uvs, ctl, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Top middle
                this.fillVertices(iv, vertices, x1, x2, y0, y1);
                this.fillUvs(iv, uvs, u1, u2, v0, v1);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Top right
                this.fillVertices(iv, vertices, x3, x2, y0, y1);
                this.fillUvsCorner(iv, uvs, ctr, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Middle
                this.fillVertices(iv, vertices, x0, x3, y1, y2);
                this.fillUvs(iv, uvs, u0, u3, v1, v2);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom left
                this.fillVertices(iv, vertices, x0, x1, y3, y2);
                this.fillUvsCorner(iv, uvs, cbl, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom middle
                this.fillVertices(iv, vertices, x1, x2, y2, y3);
                this.fillUvs(iv, uvs, u1, u2, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom right
                this.fillVertices(iv, vertices, x3, x2, y3, y2);
                this.fillUvsCorner(iv, uvs, cbr, u3, u2, u1, u0, v3, v2, v1, v0);
                this.fillIndices(ii, indices, ia);
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        };
        return DBaseBackgroundMeshGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundMesh = /** @class */ (function (_super) {
        __extends(DBaseBackgroundMesh, _super);
        function DBaseBackgroundMesh(texture, borderSize, cornerMask) {
            return _super.call(this, new DBaseBackgroundMeshGeometry(texture, 100, 100, borderSize, cornerMask), new pixi_js.MeshMaterial(texture)) || this;
        }
        Object.defineProperty(DBaseBackgroundMesh.prototype, "texture", {
            // @ts-ignore
            get: function () {
                return this.shader.texture;
            },
            set: function (texture) {
                if (this.shader.texture !== texture) {
                    this.shader.texture = texture;
                    this.geometry.texture = texture;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this.geometry.width;
            },
            set: function (width) {
                this.geometry.width = width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this.geometry.height;
            },
            set: function (height) {
                this.geometry.height = height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "borderSize", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (borderSize) {
                this.geometry.borderSize = borderSize;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "cornerMask", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (cornerMask) {
                this.geometry.cornerMask = cornerMask;
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackgroundMesh.prototype._render = function (renderer) {
            this.geometry.update();
            _super.prototype._render.call(this, renderer);
        };
        DBaseBackgroundMesh.prototype.update = function () {
            this.geometry.update();
        };
        return DBaseBackgroundMesh;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundSnippet = /** @class */ (function () {
        function DBaseBackgroundSnippet() {
            this._cornerRadius = 0;
        }
        DBaseBackgroundSnippet.prototype.get = function (base, theme, cornerRadius, cornerHeight, cornerMask) {
            var result = this._mesh;
            if (result == null) {
                result = new DBaseBackgroundMesh(theme.getBackgroundTexture(cornerRadius), cornerHeight, cornerMask);
                result.parent = base;
                this._mesh = result;
                this._cornerRadius = cornerRadius;
            }
            if (this._cornerRadius !== cornerRadius) {
                this._cornerRadius = cornerRadius;
                result.texture = theme.getBackgroundTexture(cornerRadius);
                result.borderSize = cornerHeight;
            }
            return result;
        };
        DBaseBackgroundSnippet.prototype.hide = function () {
            var mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        };
        DBaseBackgroundSnippet.prototype.onReflow = function (base, width, height, theme, state, cornerRadius, cornerHeight, cornerMask) {
            var background = base.background;
            var backgroundColor = background.getColor(state);
            if (backgroundColor != null) {
                var backgroundAlpha = background.getAlpha(state);
                if (0 < backgroundAlpha) {
                    var backgroundMesh = this.get(base, theme, cornerRadius, cornerHeight, cornerMask);
                    backgroundMesh.tint = backgroundColor;
                    backgroundMesh.alpha = backgroundAlpha;
                    backgroundMesh.width = width;
                    backgroundMesh.height = height;
                    backgroundMesh.cornerMask = cornerMask;
                    backgroundMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        };
        DBaseBackgroundSnippet.prototype.render = function (renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        };
        DBaseBackgroundSnippet.prototype.updateTransform = function () {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        };
        return DBaseBackgroundSnippet;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseBorderMeshGeometry, _super);
        function DBaseBorderMeshGeometry(texture, width, height, borderSize, borderMask, cornerMask) {
            var _this = _super.call(this, new Float32Array(64), new Float32Array(64), new Uint16Array(48)) || this;
            _this._width = width;
            _this._height = height;
            _this._texture = texture;
            _this._borderSize = borderSize;
            _this._borderMask = borderMask;
            _this._cornerMask = cornerMask;
            _this._isDirty = true;
            _this._textureId = NaN;
            _this._vertexBuffer = _this.getBuffer("aVertexPosition");
            _this._vertices = _this._vertexBuffer.data;
            _this._uvBuffer = _this.getBuffer("aTextureCoord");
            _this._uvs = _this._uvBuffer.data;
            _this._indexBuffer = _this.getIndex();
            _this._indices = _this._indexBuffer.data;
            return _this;
        }
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "borderMask", {
            get: function () {
                return this._borderMask;
            },
            set: function (borderMask) {
                if (this._borderMask !== borderMask) {
                    this._borderMask = borderMask;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "cornerMask", {
            get: function () {
                return this._cornerMask;
            },
            set: function (cornerMask) {
                if (this._cornerMask !== cornerMask) {
                    this._cornerMask = cornerMask;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "borderSize", {
            get: function () {
                return this._borderSize;
            },
            set: function (borderSize) {
                if (this._borderSize !== borderSize) {
                    this._borderSize = borderSize;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (height) {
                if (this._height !== height) {
                    this._height = height;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            set: function (texture) {
                if (this._texture !== texture) {
                    this._texture = texture;
                    this._isDirty = true;
                    this._textureId = NaN;
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorderMeshGeometry.prototype.fillVertices = function (iv, array, x0, x1, y0, y1) {
            array[iv + 0] = x0;
            array[iv + 1] = y0;
            array[iv + 2] = x1;
            array[iv + 3] = y0;
            array[iv + 4] = x0;
            array[iv + 5] = y1;
            array[iv + 6] = x1;
            array[iv + 7] = y1;
        };
        DBaseBorderMeshGeometry.prototype.fillIndices = function (ii, indices, iv) {
            indices[ii + 0] = iv + 0;
            indices[ii + 1] = iv + 1;
            indices[ii + 2] = iv + 2;
            indices[ii + 3] = iv + 1;
            indices[ii + 4] = iv + 3;
            indices[ii + 5] = iv + 2;
        };
        DBaseBorderMeshGeometry.prototype.fillUvsCorner = function (iv, uvs, b1, b2, c, u0, u1, u2, u3, v0, v1, v2, v3) {
            if (b1 || b2) {
                if (c) {
                    this.fillVertices(iv, uvs, u0, u1, v0, v1);
                }
                else if (b1 && b2) {
                    this.fillVertices(iv, uvs, u3, u2, v0, v1);
                }
                else if (b1) {
                    this.fillVertices(iv, uvs, u1, u2, v0, v1);
                }
                else {
                    this.fillVertices(iv, uvs, u0, u1, v1, v2);
                }
            }
            else {
                this.fillVertices(iv, uvs, u1, u1, v1, v1);
            }
        };
        DBaseBorderMeshGeometry.prototype.fillUvs = function (iv, uvs, b, u0, u1, v0, v1, uz, vz) {
            if (b) {
                this.fillVertices(iv, uvs, u0, u1, v0, v1);
            }
            else {
                this.fillVertices(iv, uvs, uz, uz, vz, vz);
            }
        };
        DBaseBorderMeshGeometry.prototype.update = function () {
            var texture = this._texture;
            if (!texture.valid) {
                return;
            }
            var textureId = texture._updateID;
            if (this._isDirty || this._textureId !== textureId) {
                this._isDirty = false;
                this._textureId = textureId;
                var vertices = this._vertices;
                var uvs = this._uvs;
                var indices = this._indices;
                var width = this._width;
                var height = this._height;
                var borderSize = this._borderSize;
                var x0 = 0;
                var x1 = Math.min(width * 0.5, borderSize);
                var x2 = Math.max(width * 0.5, width - borderSize);
                var x3 = width;
                var y0 = 0;
                var y1 = Math.min(height * 0.5, borderSize);
                var y2 = Math.max(height * 0.5, height - borderSize);
                var y3 = height;
                var textureUvs = texture._uvs;
                var l = textureUvs.x0;
                var r = textureUvs.x1;
                var t = textureUvs.y0;
                var b = textureUvs.y3;
                var w = (r - l) * (borderSize / texture.width);
                var h = (b - t) * (borderSize / texture.height);
                var u0 = l;
                var u1 = l + w;
                var u2 = r - w;
                var u3 = r;
                var v0 = t;
                var v1 = t + h;
                var v2 = b - h;
                var v3 = b;
                var borderMask = this._borderMask;
                var bt = !(borderMask & DBorderMask.TOP);
                var bb = !(borderMask & DBorderMask.BOTTOM);
                var bl = !(borderMask & DBorderMask.LEFT);
                var br = !(borderMask & DBorderMask.RIGHT);
                var cornerMask = this._cornerMask;
                var ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                var ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                var cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                var cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                var iv = 0;
                var ia = 0;
                var ii = 0;
                // Top left
                this.fillVertices(iv, vertices, x0, x1, y0, y1);
                this.fillUvsCorner(iv, uvs, bt, bl, ctl, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Top middle
                this.fillVertices(iv, vertices, x1, x2, y0, y1);
                this.fillUvs(iv, uvs, bt, u1, u2, v0, v1, u1, v1);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Top right
                this.fillVertices(iv, vertices, x3, x2, y0, y1);
                this.fillUvsCorner(iv, uvs, bt, br, ctr, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Middle left
                this.fillVertices(iv, vertices, x0, x1, y1, y2);
                this.fillUvs(iv, uvs, bl, u0, u1, v1, v2, u1, v1);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Middle right
                this.fillVertices(iv, vertices, x2, x3, y1, y2);
                this.fillUvs(iv, uvs, br, u2, u3, v1, v2, u2, v2);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom left
                this.fillVertices(iv, vertices, x0, x1, y3, y2);
                this.fillUvsCorner(iv, uvs, bb, bl, cbl, u0, u1, u2, u3, v0, v1, v2, v3);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom middle
                this.fillVertices(iv, vertices, x1, x2, y2, y3);
                this.fillUvs(iv, uvs, bb, u1, u2, v2, v3, u2, v2);
                this.fillIndices(ii, indices, ia);
                iv += 8;
                ia += 4;
                ii += 6;
                // Bottom right
                this.fillVertices(iv, vertices, x3, x2, y3, y2);
                this.fillUvsCorner(iv, uvs, bb, br, cbr, u3, u2, u1, u0, v3, v2, v1, v0);
                this.fillIndices(ii, indices, ia);
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        };
        return DBaseBorderMeshGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderMesh = /** @class */ (function (_super) {
        __extends(DBaseBorderMesh, _super);
        function DBaseBorderMesh(texture, borderSize, borderMask, cornerMask) {
            return _super.call(this, new DBaseBorderMeshGeometry(texture, 100, 100, borderSize, borderMask, cornerMask), new pixi_js.MeshMaterial(texture)) || this;
        }
        Object.defineProperty(DBaseBorderMesh.prototype, "texture", {
            // @ts-ignore
            get: function () {
                return this.shader.texture;
            },
            set: function (texture) {
                if (this.shader.texture !== texture) {
                    this.shader.texture = texture;
                    this.geometry.texture = texture;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this.geometry.width;
            },
            set: function (width) {
                this.geometry.width = width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this.geometry.height;
            },
            set: function (height) {
                this.geometry.height = height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "borderSize", {
            get: function () {
                return this.geometry.borderSize;
            },
            set: function (borderSize) {
                this.geometry.borderSize = borderSize;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "borderMask", {
            get: function () {
                return this.geometry.borderMask;
            },
            set: function (borderMask) {
                this.geometry.borderMask = borderMask;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "cornerMask", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (cornerMask) {
                this.geometry.cornerMask = cornerMask;
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorderMesh.prototype._render = function (renderer) {
            this.geometry.update();
            _super.prototype._render.call(this, renderer);
        };
        DBaseBorderMesh.prototype.update = function () {
            this.geometry.update();
        };
        return DBaseBorderMesh;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderSnippet = /** @class */ (function () {
        function DBaseBorderSnippet() {
            this._cornerRadius = 0;
            this._borderWidth = 0;
        }
        DBaseBorderSnippet.prototype.get = function (base, theme, cornerRadius, cornerHeight, cornerMask, borderWidth, borderMask) {
            var result = this._mesh;
            if (result == null) {
                result = new DBaseBorderMesh(theme.getBorderTexture(cornerRadius, borderWidth), cornerHeight, borderMask, cornerMask);
                result.parent = base;
                this._mesh = result;
                this._cornerRadius = cornerRadius;
            }
            if (this._cornerRadius !== cornerRadius || this._borderWidth !== borderWidth) {
                this._cornerRadius = cornerRadius;
                this._borderWidth = borderWidth;
                result.texture = theme.getBorderTexture(cornerRadius, borderWidth);
                result.borderSize = cornerHeight;
            }
            return result;
        };
        DBaseBorderSnippet.prototype.hide = function () {
            var mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        };
        DBaseBorderSnippet.prototype.onReflow = function (base, width, height, theme, state, cornerRadius, cornerHeight, cornerMask) {
            var border = base.border;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                if (0 < borderAlpha) {
                    var borderWidth = border.getWidth(state);
                    var borderMask = border.getMask(state);
                    var borderMesh = this.get(base, theme, cornerRadius, cornerHeight, cornerMask, borderWidth, borderMask);
                    var borderAlign = border.getAlign(state);
                    var borderOffset = borderAlign * borderWidth;
                    borderMesh.tint = borderColor;
                    borderMesh.alpha = borderAlpha;
                    borderMesh.x = -borderOffset;
                    borderMesh.y = -borderOffset;
                    borderMesh.width = width + borderOffset * 2;
                    borderMesh.height = height + borderOffset * 2;
                    borderMesh.borderMask = borderMask;
                    borderMesh.cornerMask = cornerMask;
                    borderMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        };
        DBaseBorderSnippet.prototype.render = function (renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        };
        DBaseBorderSnippet.prototype.updateTransform = function () {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        };
        return DBaseBorderSnippet;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOutlineSnippet = /** @class */ (function () {
        function DBaseOutlineSnippet() {
            this._cornerRadius = 0;
            this._outlineWidth = 0;
        }
        DBaseOutlineSnippet.prototype.get = function (base, theme, cornerRadius, cornerHeight, cornerMask, outlineWidth, outlineMask) {
            var result = this._mesh;
            if (result == null) {
                result = new DBaseBorderMesh(theme.getBorderTexture(cornerRadius, outlineWidth), cornerHeight, outlineMask, cornerMask);
                result.parent = base;
                this._mesh = result;
                this._cornerRadius = cornerRadius;
                this._outlineWidth = outlineWidth;
            }
            if (this._cornerRadius !== cornerRadius || this._outlineWidth !== outlineWidth) {
                this._cornerRadius = cornerRadius;
                this._outlineWidth = outlineWidth;
                result.texture = theme.getBorderTexture(cornerRadius, outlineWidth);
                result.borderSize = cornerHeight;
            }
            return result;
        };
        DBaseOutlineSnippet.prototype.hide = function () {
            var mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        };
        DBaseOutlineSnippet.prototype.onReflow = function (base, width, height, theme, state, cornerRadius, cornerHeight, cornerMask) {
            var outline = base.outline;
            var outlineColor = outline.getColor(state);
            if (outlineColor != null) {
                var outlineAlpha = outline.getAlpha(state);
                if (0 < outlineAlpha) {
                    var outlineWidth = outline.getWidth(state);
                    var outlineMask = outline.getMask(state);
                    var outlineMesh = this.get(base, theme, cornerRadius, cornerHeight, cornerMask, outlineWidth, outlineMask);
                    var outlineOffset = outline.getOffset(state);
                    var outlineAlign = outline.getAlign(state);
                    var outlineOffsetAccumulative = outlineOffset + outlineAlign * outlineWidth;
                    outlineMesh.tint = outlineColor;
                    outlineMesh.alpha = outlineAlpha;
                    outlineMesh.x = -outlineOffsetAccumulative;
                    outlineMesh.y = -outlineOffsetAccumulative;
                    outlineMesh.width = width + outlineOffsetAccumulative * 2;
                    outlineMesh.height = height + outlineOffsetAccumulative * 2;
                    outlineMesh.borderMask = outlineMask;
                    outlineMesh.cornerMask = cornerMask;
                    outlineMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        };
        DBaseOutlineSnippet.prototype.render = function (renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        };
        DBaseOutlineSnippet.prototype.updateTransform = function () {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        };
        return DBaseOutlineSnippet;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseReflowableImpl = /** @class */ (function () {
        function DBaseReflowableImpl(base) {
            var background = new DBaseBackgroundSnippet();
            this._background = background;
            base.snippet.add(background, true);
            var border = new DBaseBorderSnippet();
            this._border = border;
            base.snippet.add(border, false);
            var outline = new DBaseOutlineSnippet();
            this._outline = outline;
            base.snippet.add(outline, false);
            base.reflowable.add(this);
        }
        DBaseReflowableImpl.prototype.onReflow = function (base, width, height) {
            var theme = base.theme;
            var state = base.state;
            var corner = base.corner;
            var cornerRadius = corner.getRadius();
            var cornerHeight = cornerRadius + 1;
            var cornerMask = corner.getMask();
            this._background.onReflow(base, width, height, theme, state, cornerRadius, cornerHeight, cornerMask);
            this._border.onReflow(base, width, height, theme, state, cornerRadius, cornerHeight, cornerMask);
            this._outline.onReflow(base, width, height, theme, state, cornerRadius, cornerHeight, cornerMask);
        };
        return DBaseReflowableImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutClearType;
    (function (DLayoutClearType) {
        DLayoutClearType[DLayoutClearType["NONE"] = 0] = "NONE";
        DLayoutClearType[DLayoutClearType["BEFORE"] = 1] = "BEFORE";
        DLayoutClearType[DLayoutClearType["AFTER"] = 2] = "AFTER";
        DLayoutClearType[DLayoutClearType["BOTH"] = 3] = "BOTH";
    })(DLayoutClearType || (DLayoutClearType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var NodeType;
    (function (NodeType) {
        // Parensesis
        NodeType[NodeType["OPEN"] = 0] = "OPEN";
        NodeType[NodeType["CLOSE"] = 1] = "CLOSE";
        NodeType[NodeType["PARENSESIS"] = 2] = "PARENSESIS";
        // Operations
        NodeType[NodeType["ADD_OR_PLUS"] = 3] = "ADD_OR_PLUS";
        NodeType[NodeType["SUB_OR_MINUS"] = 4] = "SUB_OR_MINUS";
        NodeType[NodeType["PLUS"] = 5] = "PLUS";
        NodeType[NodeType["MINUS"] = 6] = "MINUS";
        NodeType[NodeType["ADD"] = 7] = "ADD";
        NodeType[NodeType["SUB"] = 8] = "SUB";
        NodeType[NodeType["MUL"] = 9] = "MUL";
        NodeType[NodeType["DIV"] = 10] = "DIV";
        // Functions
        NodeType[NodeType["MIN"] = 11] = "MIN";
        NodeType[NodeType["MAX"] = 12] = "MAX";
        NodeType[NodeType["COMMA"] = 13] = "COMMA";
        // Literals
        NodeType[NodeType["PARENT"] = 14] = "PARENT";
        NodeType[NodeType["SELF"] = 15] = "SELF";
        NodeType[NodeType["PADDING"] = 16] = "PADDING";
        NodeType[NodeType["CURRENT"] = 17] = "CURRENT";
        NodeType[NodeType["NUMBER"] = 18] = "NUMBER";
    })(NodeType || (NodeType = {}));
    var TOKEN_MAPPING_OPERATOR = {
        "+": 3 /* ADD_OR_PLUS */,
        "-": 4 /* SUB_OR_MINUS */,
        "*": 9 /* MUL */,
        "/": 10 /* DIV */,
        "(": 0 /* OPEN */,
        ")": 1 /* CLOSE */,
        ",": 13 /* COMMA */,
        min: 11 /* MIN */,
        max: 12 /* MAX */
    };
    var TOKEN_MAPPING_LITERAL = {
        "%": 14 /* PARENT */,
        s: 15 /* SELF */,
        p: 16 /* PADDING */,
        c: 17 /* CURRENT */
    };
    /**
     * Parser and evaluator of the scalar expressions like `100% - 50s`.
     *
     * Literals
     *
     * * x%: 0.01 * x * parent value
     * * xs: 0.01 * x * self value
     * * xp: 0.01 * x * padding value
     * * xc: 0.01 * x * current value
     *
     * Operators
     *
     * * `+`
     * * `-`
     * * `*`
     * * `/`
     * * `(` and `)`
     *
     * Functions
     *
     * * min( a, b, ... )
     * * max( a, b, ... )
     *
     * Examples
     *
     * * `90%`: 0.9 * parent value
     * * `50s`: 0.5 * self value
     * * `90% - 50s`: 0.9 * parent value - 0.5 * self value
     * * `90% - (50s + 100) * 2`: 0.9 * parent value - ( 0.5 * self value + 100 ) * 2
     */
    var DScalarExpression = /** @class */ (function () {
        function DScalarExpression(expression) {
            var nodes = this.toToken(expression);
            var i = 0;
            do {
                i = this.toParensesis(nodes, i);
            } while (i < nodes.length);
            this.toUnary(nodes);
            this.toArithmetic(nodes, 9 /* MUL */, 10 /* DIV */);
            this.toArithmetic(nodes, 7 /* ADD */, 8 /* SUB */);
            if (nodes.length === 1) {
                var node = nodes[0];
                if (!isNumber(node)) {
                    this._node = node;
                    return;
                }
            }
            throw new Error("Failed to parse '" + expression + "'");
        }
        DScalarExpression.prototype.toParensesis = function (nodes, ifrom) {
            var ito = nodes.length;
            for (var i = ifrom; i < ito; ++i) {
                var inode = nodes[i];
                if (inode === 0 /* OPEN */) {
                    var istart = i;
                    var nodeType = 2 /* PARENSESIS */;
                    if (0 < i) {
                        var nodeTypePrev = nodes[i - 1];
                        if (nodeTypePrev === 11 /* MIN */ || nodeTypePrev === 12 /* MAX */) {
                            istart -= 1;
                            nodeType = nodeTypePrev;
                        }
                    }
                    for (var j = i + 1; j < ito; ++j) {
                        var jnode = nodes[j];
                        if (jnode === 1 /* CLOSE */) {
                            nodes[istart] = [nodeType, this.toComma(nodes, i + 1, j)];
                            nodes.splice(istart + 1, j - istart);
                            return istart + 1;
                        }
                        else if (jnode === 0 /* OPEN */) {
                            j = this.toParensesis(nodes, j) - 1;
                            ito = nodes.length;
                        }
                    }
                    throw new Error("Malformed parensesis");
                }
            }
            return ito;
        };
        DScalarExpression.prototype.toCommaOf = function (nodes, ifrom, ito) {
            var l = ito - ifrom;
            if (l <= 0) {
                return [18 /* NUMBER */, 0];
            }
            else if (l <= 1) {
                return nodes[ifrom];
            }
            else {
                var operand = [];
                for (var j = ifrom; j < ito; ++j) {
                    operand.push(nodes[j]);
                }
                return [2 /* PARENSESIS */, operand];
            }
        };
        DScalarExpression.prototype.toComma = function (nodes, ifrom, ito) {
            var result = null;
            var iprev = ifrom;
            for (var i = ifrom; i < ito; ++i) {
                var node = nodes[i];
                if (node === 13 /* COMMA */) {
                    result = result || [];
                    result.push(this.toCommaOf(nodes, iprev, i));
                    iprev = i + 1;
                }
            }
            if (iprev < ito) {
                if (result == null) {
                    var operand = [];
                    for (var i = iprev; i < ito; ++i) {
                        operand.push(nodes[i]);
                    }
                    return operand;
                }
                else {
                    result.push(this.toCommaOf(nodes, iprev, ito));
                }
            }
            return result || [];
        };
        DScalarExpression.prototype.toUnaryNode = function (node) {
            if (!isNumber(node)) {
                if (node[0] === 2 /* PARENSESIS */ ||
                    node[0] === 11 /* MIN */ ||
                    node[0] === 12 /* MAX */) {
                    this.toUnary(node[1]);
                }
            }
        };
        DScalarExpression.prototype.toUnary = function (nodes) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (node === 3 /* ADD_OR_PLUS */ || node === 4 /* SUB_OR_MINUS */) {
                    if (i <= 0 || isNumber(nodes[i - 1])) {
                        if (i + 1 < imax && !isNumber(nodes[i + 1])) {
                            var operand = nodes.splice(i + 1, 1)[0];
                            var type = node === 3 /* ADD_OR_PLUS */ ? 5 /* PLUS */ : 6 /* MINUS */;
                            nodes[i] = [type, operand];
                            imax = nodes.length;
                            this.toUnaryNode(operand);
                        }
                        else {
                            throw new Error("Malformed unary operator");
                        }
                    }
                    else {
                        var type = node === 3 /* ADD_OR_PLUS */ ? 7 /* ADD */ : 8 /* SUB */;
                        nodes[i] = type;
                    }
                }
                else {
                    this.toUnaryNode(node);
                    imax = nodes.length;
                }
            }
        };
        DScalarExpression.prototype.toArithmeticNode = function (node, operatorA, operatorB) {
            if (!isNumber(node)) {
                if (node[0] === 2 /* PARENSESIS */ ||
                    node[0] === 11 /* MIN */ ||
                    node[0] === 12 /* MAX */) {
                    this.toArithmetic(node[1], operatorA, operatorB);
                }
                else if (node[0] === 5 /* PLUS */ || node[0] === 6 /* MINUS */) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                }
                else if (node[0] === 7 /* ADD */ ||
                    node[0] === 8 /* SUB */ ||
                    node[0] === 9 /* MUL */ ||
                    node[0] === 10 /* DIV */) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                    this.toArithmeticNode(node[2], operatorA, operatorB);
                }
            }
        };
        DScalarExpression.prototype.toArithmetic = function (nodes, operatorA, operatorB) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (node === operatorA || node === operatorB) {
                    if (0 < i && i + 1 < imax) {
                        var left = nodes[i - 1];
                        var right = nodes[i + 1];
                        if (!isNumber(left) && !isNumber(right)) {
                            nodes.splice(i, 2);
                            nodes[i - 1] = [node, left, right];
                            i -= 1;
                            imax = nodes.length;
                            this.toArithmeticNode(left, operatorA, operatorB);
                            this.toArithmeticNode(right, operatorA, operatorB);
                            continue;
                        }
                    }
                    throw new Error("Malformed operands for the operator " + node);
                }
                else {
                    this.toArithmeticNode(node, operatorA, operatorB);
                    imax = nodes.length;
                }
            }
        };
        DScalarExpression.prototype.toToken = function (expression) {
            var tokens = [];
            while (true) {
                var matched = DScalarExpression.TOKEN_REGEX.exec(expression);
                if (matched != null) {
                    var token = matched[0];
                    var tokenTypeOperator = TOKEN_MAPPING_OPERATOR[token];
                    if (tokenTypeOperator != null) {
                        tokens.push(tokenTypeOperator);
                    }
                    else {
                        var parsedToken = parseFloat(token);
                        if (parsedToken !== parsedToken) {
                            throw new Error("Unexpected token '" + token + "' at " + matched.index + " in '" + expression + "'");
                        }
                        var tokenTypeLiteral = TOKEN_MAPPING_LITERAL[token[token.length - 1]];
                        if (tokenTypeLiteral != null) {
                            tokens.push([tokenTypeLiteral, parsedToken * 0.01]);
                        }
                        else {
                            tokens.push([18 /* NUMBER */, parsedToken]);
                        }
                    }
                }
                else {
                    break;
                }
            }
            return tokens;
        };
        DScalarExpression.prototype.evaluate = function (node, parent, self, padding, current) {
            switch (node[0]) {
                case 2 /* PARENSESIS */:
                    var nodes = node[1];
                    return this.evaluate(nodes[nodes.length - 1], parent, self, padding, current);
                // Unary operators
                case 5 /* PLUS */:
                    return +this.evaluate(node[1], parent, self, padding, current);
                case 6 /* MINUS */:
                    return -this.evaluate(node[1], parent, self, padding, current);
                // Four arithmetic operators
                case 7 /* ADD */:
                    return (this.evaluate(node[1], parent, self, padding, current) +
                        this.evaluate(node[2], parent, self, padding, current));
                case 8 /* SUB */:
                    return (this.evaluate(node[1], parent, self, padding, current) -
                        this.evaluate(node[2], parent, self, padding, current));
                case 9 /* MUL */:
                    return (this.evaluate(node[1], parent, self, padding, current) *
                        this.evaluate(node[2], parent, self, padding, current));
                case 10 /* DIV */:
                    return (this.evaluate(node[1], parent, self, padding, current) /
                        this.evaluate(node[2], parent, self, padding, current));
                // Functions
                case 11 /* MIN */:
                    if (0 < node[1].length) {
                        var args = node[1];
                        var result = this.evaluate(args[0], parent, self, padding, current);
                        for (var i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.min(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                case 12 /* MAX */:
                    if (0 < node[1].length) {
                        var args = node[1];
                        var result = this.evaluate(args[0], parent, self, padding, current);
                        for (var i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.max(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                // Literals
                case 14 /* PARENT */:
                    return node[1] * parent;
                case 15 /* SELF */:
                    return node[1] * self;
                case 16 /* PADDING */:
                    return node[1] * padding;
                case 17 /* CURRENT */:
                    return node[1] * current;
                case 18 /* NUMBER */:
                    return node[1];
            }
            return 0;
        };
        DScalarExpression.prototype.calculate = function (parent, self, padding, current) {
            return this.evaluate(this._node, parent, self, padding, current);
        };
        DScalarExpression.TOKEN_REGEX = /(?:\+|-|\*|\/|\(|\)|min|max|,|(?:\d+(?:\.\d*)?[%psc]?))/g;
        return DScalarExpression;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var POSITION_CENTER = function (p, s) { return (p - s) * 0.5; };
    var POSITION_PADDING = function (p, s, d) { return d; };
    var SIZE_MAXIMIZED = function (p) { return p; };
    var SIZE_PADDING = function (p, s, d) { return p - d; };
    var DScalarFunctions = /** @class */ (function () {
        function DScalarFunctions() {
        }
        DScalarFunctions.position = function (coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "center":
                    case "CENTER":
                        return POSITION_CENTER;
                    case "padding":
                    case "PADDING":
                        return POSITION_PADDING;
                }
                var scalarExpression_1 = new DScalarExpression(coordinate);
                return function (parent, self, padding, current) {
                    return scalarExpression_1.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                var scalar_1 = coordinate;
                return function (parent, self, padding, current) {
                    return scalar_1.calculate(parent, self, padding, current);
                };
            }
        };
        DScalarFunctions.size = function (coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "100%":
                    case "maximized":
                    case "MAXIMIZED":
                        return SIZE_MAXIMIZED;
                    case "padding":
                    case "PADDING":
                        return SIZE_PADDING;
                }
                var scalarExpression_2 = new DScalarExpression(coordinate);
                return function (parent, self, padding, current) {
                    return scalarExpression_2.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                var scalar_2 = coordinate;
                return function (parent, self, padding, current) {
                    return scalar_2.calculate(parent, self, padding, current);
                };
            }
        };
        return DScalarFunctions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilPointerEvent = /** @class */ (function () {
        function UtilPointerEvent() {
        }
        Object.defineProperty(UtilPointerEvent, "touchable", {
            get: function () {
                return "ontouchstart" in document;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "tap", {
            get: function () {
                return "pointertap";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "down", {
            get: function () {
                return "pointerdown";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "enter", {
            get: function () {
                return "pointerenter";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "leave", {
            get: function () {
                return "pointerleave";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "move", {
            get: function () {
                return "pointermove";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "out", {
            get: function () {
                return "pointerout";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "over", {
            get: function () {
                return "pointerover";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "up", {
            get: function () {
                return "pointerup";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "cancel", {
            get: function () {
                return "pointercancel";
            },
            enumerable: false,
            configurable: true
        });
        UtilPointerEvent.toGlobal = function (e, interactionManager, result) {
            if ("touches" in e) {
                var touches = e.changedTouches;
                var touch = touches[touches.length - 1];
                if (touch != null) {
                    interactionManager.mapPositionToPoint(result, touch.clientX, touch.clientY);
                }
                else {
                    interactionManager.mapPositionToPoint(result, 0, 0);
                }
            }
            else {
                interactionManager.mapPositionToPoint(result, e.clientX, e.clientY);
            }
            return result;
        };
        UtilPointerEvent.isValidDistance = function (e, x, y) {
            var global = e.data.global;
            var dx = Math.abs(x - global.x);
            var dy = Math.abs(y - global.y);
            var threshold = this.CLICK_DISTANCE_THRESHOLD;
            return dx < threshold && dy < threshold;
        };
        UtilPointerEvent.onClick = function (target, onClick) {
            var _this = this;
            if (!this.touchable) {
                target.on("click", onClick);
            }
            else {
                var isDowned_1 = false;
                var downX_1 = 0;
                var downY_1 = 0;
                var interactionManagerBound_1 = null;
                var cleanup_1 = function () {
                    isDowned_1 = false;
                    if (interactionManagerBound_1) {
                        interactionManagerBound_1.off(up_1, onUp_1);
                        interactionManagerBound_1 = null;
                    }
                };
                target.on("click", function (e) {
                    if (isDowned_1) {
                        cleanup_1();
                    }
                    onClick(e);
                });
                var up_1 = this.up;
                var onUp_1 = function (e) {
                    if (isDowned_1) {
                        cleanup_1();
                        if (_this.contains(target, e.target)) {
                            if (_this.isValidDistance(e, downX_1, downY_1)) {
                                onClick(e);
                            }
                        }
                    }
                };
                target.on(this.down, function (e) {
                    if (isDowned_1) {
                        var global_1 = e.data.global;
                        downX_1 = global_1.x;
                        downY_1 = global_1.y;
                    }
                    else {
                        isDowned_1 = true;
                        var global_2 = e.data.global;
                        downX_1 = global_2.x;
                        downY_1 = global_2.y;
                        if (interactionManagerBound_1) {
                            interactionManagerBound_1.off(up_1, onUp_1);
                            interactionManagerBound_1 = null;
                        }
                        var layer = DApplications.getLayer(target);
                        if (layer) {
                            interactionManagerBound_1 = layer.renderer.plugins.interaction;
                            interactionManagerBound_1.once(up_1, onUp_1);
                        }
                    }
                });
            }
        };
        UtilPointerEvent.onLongClick = function (target, onClick, onLongClick, isLongClickable) {
            var _this = this;
            if (!this.touchable) {
                target.on("click", onClick);
            }
            else {
                var isDowned_2 = false;
                var downX_2 = 0;
                var downY_2 = 0;
                var timeoutId_1 = null;
                var interactionManagerBound_2 = null;
                var cleanupTimeout_1 = function () {
                    if (timeoutId_1 != null) {
                        clearTimeout(timeoutId_1);
                        timeoutId_1 = null;
                    }
                };
                var cleanup_2 = function () {
                    isDowned_2 = false;
                    if (interactionManagerBound_2) {
                        interactionManagerBound_2.off(up_2, onUp_2);
                        interactionManagerBound_2.off(move_1, onMove_1);
                        interactionManagerBound_2 = null;
                    }
                    cleanupTimeout_1();
                };
                target.on("click", function (e) {
                    if (isDowned_2) {
                        cleanup_2();
                    }
                    onClick(e);
                });
                var up_2 = this.up;
                var move_1 = this.move;
                var onUp_2 = function (e) {
                    if (isDowned_2) {
                        cleanup_2();
                        if (_this.contains(target, e.target)) {
                            if (_this.isValidDistance(e, downX_2, downY_2)) {
                                onClick(e);
                            }
                        }
                    }
                };
                var onMove_1 = function (e) {
                    if (isDowned_2) {
                        if (_this.contains(target, e.target)) {
                            if (!_this.isValidDistance(e, downX_2, downY_2)) {
                                cleanup_2();
                            }
                        }
                    }
                };
                target.on(this.down, function (e) {
                    if (!isDowned_2) {
                        isDowned_2 = true;
                        var global_3 = e.data.global;
                        downX_2 = global_3.x;
                        downY_2 = global_3.y;
                        cleanupTimeout_1();
                        var oe = e.data.originalEvent;
                        if ("touches" in oe && (isLongClickable == null || isLongClickable(e))) {
                            timeoutId_1 = window.setTimeout(function () {
                                if (isDowned_2) {
                                    cleanup_2();
                                    onLongClick(e);
                                }
                            }, _this.LONG_CLICK_THRESHOLD);
                        }
                        if (interactionManagerBound_2) {
                            interactionManagerBound_2.off(up_2, onUp_2);
                            interactionManagerBound_2.off(move_1, onMove_1);
                            interactionManagerBound_2 = null;
                        }
                        var layer = DApplications.getLayer(target);
                        if (layer) {
                            interactionManagerBound_2 = layer.renderer.plugins.interaction;
                            interactionManagerBound_2.once(up_2, onUp_2);
                            interactionManagerBound_2.on(move_1, onMove_1);
                        }
                    }
                });
            }
        };
        UtilPointerEvent.onDblClick = function (target, handler) {
            var _this = this;
            if (!this.touchable) {
                target.addEventListener("dblclick", handler);
            }
            else {
                var isDowned_3 = 0;
                var downX_3 = 0;
                var downY_3 = 0;
                var clickTime_1 = 0;
                target.addEventListener("dblclick", handler);
                target.addEventListener("touchend", function (e) {
                    if (isDowned_3 === 1 || isDowned_3 === 3) {
                        var touches = e.changedTouches;
                        var touch = touches[touches.length - 1];
                        if (touch != null) {
                            var dx = downX_3 - touch.clientX;
                            var dy = downY_3 - touch.clientY;
                            if (Math.abs(dx) + Math.abs(dy) < _this.CLICK_DISTANCE_THRESHOLD) {
                                isDowned_3 += 1;
                                if (isDowned_3 === 4) {
                                    isDowned_3 = 0;
                                    var elapsedTime = e.timeStamp - clickTime_1;
                                    if (elapsedTime < _this.DBLCLICK_INTERVAL_THRESHOLD) {
                                        handler(e);
                                    }
                                    else {
                                        clickTime_1 = e.timeStamp;
                                        isDowned_3 = 2;
                                    }
                                }
                                else {
                                    clickTime_1 = e.timeStamp;
                                }
                                return;
                            }
                        }
                    }
                    isDowned_3 = 0;
                });
                target.addEventListener("touchstart", function (e) {
                    if (isDowned_3 === 0) {
                        var touch = e.touches.item(e.touches.length - 1);
                        if (touch != null) {
                            isDowned_3 = 1;
                            downX_3 = touch.clientX;
                            downY_3 = touch.clientY;
                            return;
                        }
                    }
                    else if (isDowned_3 === 2) {
                        var touch = e.touches.item(e.touches.length - 1);
                        if (touch != null) {
                            isDowned_3 = 3;
                            downX_3 = touch.clientX;
                            downY_3 = touch.clientY;
                            return;
                        }
                    }
                    isDowned_3 = 0;
                });
            }
        };
        UtilPointerEvent.contains = function (target, targetOrChild) {
            var current = targetOrChild;
            while (current != null && current !== target) {
                current = current.parent;
            }
            return current === target;
        };
        UtilPointerEvent.CLICK_DISTANCE_THRESHOLD = 10;
        UtilPointerEvent.DBLCLICK_INTERVAL_THRESHOLD = 333;
        UtilPointerEvent.LONG_CLICK_THRESHOLD = 750;
        return UtilPointerEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseAuto = /** @class */ (function () {
        function DBaseAuto() {
            this._isOn = false;
        }
        Object.defineProperty(DBaseAuto.prototype, "isOff", {
            get: function () {
                return !this._isOn;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseAuto.prototype, "isOn", {
            get: function () {
                return this._isOn;
            },
            enumerable: false,
            configurable: true
        });
        DBaseAuto.prototype.toCoordinate = function (def) {
            return this._isOn ? "auto" : def;
        };
        /**
         * Update the auto settings by the given size.
         *
         * @param size a size
         * @returns True if the given size is "auto".
         */
        DBaseAuto.prototype.from = function (size) {
            if (size === "auto" || size === "AUTO") {
                this._isOn = true;
                return true;
            }
            this._isOn = false;
            return false;
        };
        return DBaseAuto;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseAutoSet = /** @class */ (function () {
        function DBaseAutoSet() {
            this.width = new DBaseAuto();
            this.height = new DBaseAuto();
        }
        return DBaseAutoSet;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseSnippetContainer = /** @class */ (function () {
        function DBaseSnippetContainer(parent) {
            this._parent = parent;
            this._befores = [];
            this._afters = [];
            this._renderable = true;
        }
        Object.defineProperty(DBaseSnippetContainer.prototype, "renderable", {
            get: function () {
                return this._renderable;
            },
            set: function (renderable) {
                this._renderable = renderable;
            },
            enumerable: false,
            configurable: true
        });
        DBaseSnippetContainer.prototype.add = function (snippet, phase) {
            var list = phase ? this._befores : this._afters;
            list.push(snippet);
            if ("parent" in snippet) {
                snippet.parent = this._parent;
            }
        };
        DBaseSnippetContainer.prototype.addAt = function (snippet, phase, index) {
            var list = phase ? this._befores : this._afters;
            if (index === 0) {
                list.unshift(snippet);
            }
            else if (0 < index && index < list.length) {
                list.splice(index, 0, snippet);
            }
            else {
                list.push(snippet);
            }
            if ("parent" in snippet) {
                snippet.parent = this._parent;
            }
        };
        DBaseSnippetContainer.prototype.remove = function (snippet, phase) {
            var list = phase ? this._befores : this._afters;
            var index = list.indexOf(snippet);
            if (0 <= index) {
                list.splice(index, 1);
                if ("parent" in snippet) {
                    snippet.parent = null;
                }
            }
        };
        DBaseSnippetContainer.prototype.render = function (renderer, phase) {
            if (this._renderable) {
                var list = phase ? this._befores : this._afters;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var snippet = list[i];
                    snippet.updateTransform();
                    snippet.render(renderer);
                }
            }
        };
        return DBaseSnippetContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseReflowableContainer = /** @class */ (function () {
        function DBaseReflowableContainer() {
            this._list = [];
        }
        DBaseReflowableContainer.prototype.add = function (reflowable) {
            this._list.push(reflowable);
        };
        DBaseReflowableContainer.prototype.remove = function (reflowable) {
            var list = this._list;
            var index = list.indexOf(reflowable);
            if (0 <= index) {
                list.splice(index, 1);
            }
        };
        DBaseReflowableContainer.prototype.onReflow = function (base, width, height) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].onReflow(base, width, height);
            }
        };
        return DBaseReflowableContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toTheme = function (options) {
        var theme = options === null || options === void 0 ? void 0 : options.theme;
        if (theme) {
            if (isString(theme)) {
                return DThemes.getInstance().get(theme);
            }
            return theme;
        }
    };
    var toShortcuts = function (options) {
        if (options) {
            var shortcut = options.shortcut;
            var shortcuts = options.shortcuts;
            if (shortcuts != null || shortcut != null) {
                var result = [];
                if (shortcut != null) {
                    result.push(UtilKeyboardEvent.toShortcut(shortcut));
                }
                if (shortcuts != null) {
                    for (var i = 0, imax = shortcuts.length; i < imax; ++i) {
                        UtilKeyboardEvent.toShortcut(shortcuts[i]);
                    }
                }
                return result;
            }
        }
        return undefined;
    };
    /**
     * A base class for UI classes.
     * See {@link DBaseEvents} for event details.
     */
    var DBase = /** @class */ (function (_super) {
        __extends(DBase, _super);
        function DBase(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            var _this = _super.call(this) || this;
            // Transform
            var transform = _this.transform;
            _this._position = new DBasePoint(transform.position, function (newX, newY, oldX, oldY) {
                _this.onMove(newX, newY, oldX, oldY);
            });
            _this._scale = new DBasePoint(transform.scale, function (newX, newY, oldX, oldY) {
                _this.onScale(newX, newY, oldX, oldY);
            });
            _this._skew = new DBasePoint(transform.skew, function (newX, newY, oldX, oldY) {
                _this.onSkew(newX, newY, oldX, oldY);
            });
            //
            _this._options = options;
            var scalarSet = (_this._scalarSet = {});
            _this._auto = new DBaseAutoSet();
            _this._isDirty = true;
            _this._hasDirty = false;
            _this._isChildrenDirty = false;
            _this._shadow = null;
            _this.name = (_a = options === null || options === void 0 ? void 0 : options.name) !== null && _a !== void 0 ? _a : "";
            var theme = toTheme(options) || _this.getThemeDefault();
            _this._theme = theme;
            _this._snippet = new DBaseSnippetContainer(_this);
            _this._reflowable = new DBaseReflowableContainer();
            _this._clearType = toEnum((_b = options === null || options === void 0 ? void 0 : options.clear) !== null && _b !== void 0 ? _b : theme.getClearType(), DLayoutClearType);
            _this._padding = new DBasePadding(theme, options, function () {
                _this.layout();
                _this.toChildrenDirty();
                DApplications.update(_this);
            });
            var toDirtyAndUpdate = function () {
                _this.toDirty();
                DApplications.update(_this);
            };
            _this._background = new DBaseBackground(theme, options, toDirtyAndUpdate);
            _this._border = new DBaseBorder(theme, options, toDirtyAndUpdate);
            _this._outline = new DBaseOutline(theme, options, toDirtyAndUpdate);
            _this._corner = new DBaseCorner(theme, options, toDirtyAndUpdate);
            // X
            var position = transform.position;
            var x = (_c = options === null || options === void 0 ? void 0 : options.x) !== null && _c !== void 0 ? _c : theme.getX();
            if (isNumber(x)) {
                position.x = x;
            }
            else {
                position.x = 0;
                scalarSet.x = DScalarFunctions.position(x);
            }
            // Y
            var y = (_d = options === null || options === void 0 ? void 0 : options.y) !== null && _d !== void 0 ? _d : theme.getY();
            if (isNumber(y)) {
                position.y = y;
            }
            else {
                position.y = 0;
                scalarSet.y = DScalarFunctions.position(y);
            }
            // Width
            var width = (_e = options === null || options === void 0 ? void 0 : options.width) !== null && _e !== void 0 ? _e : theme.getWidth();
            if (!_this._auto.width.from(width)) {
                if (isNumber(width)) {
                    _this._width = width;
                }
                else {
                    _this._width = 100;
                    scalarSet.width = DScalarFunctions.size(width);
                }
            }
            else {
                _this._width = 100;
            }
            // Height
            var height = (_f = options === null || options === void 0 ? void 0 : options.height) !== null && _f !== void 0 ? _f : theme.getHeight();
            if (!_this._auto.height.from(height)) {
                if (isNumber(height)) {
                    _this._height = height;
                }
                else {
                    _this._height = 100;
                    scalarSet.height = DScalarFunctions.size(height);
                }
            }
            else {
                _this._height = 100;
            }
            // Visibility
            var visible = options === null || options === void 0 ? void 0 : options.visible;
            if (visible != null) {
                _this.visible = visible;
            }
            // State
            _this._state = new DBaseStateSetImplObservable(function (newState, oldState) {
                _this.onStateChange(newState, oldState);
            });
            // Interactive
            var interactive = toEnum((_g = options === null || options === void 0 ? void 0 : options.interactive) !== null && _g !== void 0 ? _g : theme.getInteractive(), DBaseInteractive);
            _this.interactive = !!(interactive & DBaseInteractive.SELF);
            _this.interactiveChildren = !!(interactive & DBaseInteractive.CHILDREN);
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            // Title
            _this._title = (_h = options === null || options === void 0 ? void 0 : options.title) !== null && _h !== void 0 ? _h : theme.getTitle();
            // Weight
            _this._weight = (_j = options === null || options === void 0 ? void 0 : options.weight) !== null && _j !== void 0 ? _j : theme.getWeight();
            // Reflowable
            _this.initReflowable();
            // Shadow
            _this._onShadowUpdateBound = function () {
                DApplications.update(_this);
            };
            var shadow = options === null || options === void 0 ? void 0 : options.shadow;
            if (shadow === undefined) {
                shadow = theme.getShadow();
            }
            if (shadow) {
                if (isString(shadow)) {
                    switch (shadow) {
                        case "WEAK":
                            _this.shadow = theme.newShadowWeak();
                            break;
                        case "DEFAULT":
                            _this.shadow = theme.newShadow();
                            break;
                    }
                }
                else {
                    _this.shadow = shadow;
                }
            }
            // Event handlers
            _this.on(UtilPointerEvent.over, function (e) {
                _this.onOver(e);
            });
            _this.on(UtilPointerEvent.out, function (e) {
                _this.onOut(e);
            });
            _this.on(UtilPointerEvent.down, function (e) {
                _this.onDown(e);
            });
            _this.on(UtilPointerEvent.up, function (e) {
                _this.onUp(e);
            });
            // Children change detection
            _this.on("added", function () {
                _this.layout();
                if (_this.isDirty() || _this.hasDirty()) {
                    _this.toParentHasDirty();
                }
                if (_this._isChildrenDirty) {
                    _this.toParentChildrenDirty();
                }
                var newParent = _this.parent;
                if (newParent instanceof DBase) {
                    _this.state.parent = newParent.state;
                }
                DApplications.update(_this);
            });
            _this.on("removed", function () {
                _this.blur(true);
                _this.state.parent = null;
                DApplications.update(_this);
            });
            // Shortcut
            var shortcuts = toShortcuts(options);
            _this._shortcuts = shortcuts;
            if (shortcuts != null) {
                var onShortcutBound = function (e) {
                    _this.onShortcut(e);
                };
                for (var i = 0, imax = shortcuts.length; i < imax; ++i) {
                    UtilKeyboardEvent.on(_this, shortcuts[i], onShortcutBound);
                }
            }
            // Other initialization
            _this.init(options);
            // State Override
            var state = options === null || options === void 0 ? void 0 : options.state;
            if (state != null) {
                if (isString(state)) {
                    _this._state.add(state);
                }
                else {
                    _this._state.addAll(state);
                }
            }
            // Parent
            var parent = options === null || options === void 0 ? void 0 : options.parent;
            if (parent != null) {
                parent.addChild(_this);
            }
            // Children
            var children = options === null || options === void 0 ? void 0 : options.children;
            if (children != null) {
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child != null) {
                        _this.addChild(child);
                    }
                }
            }
            // Cursor
            var cursor = options === null || options === void 0 ? void 0 : options.cursor;
            _this._cursor = cursor;
            _this.cursor = _this.toCursor(cursor, _this._state);
            // Done
            _this.emit("init", _this);
            return _this;
        }
        DBase.prototype.toCursor = function (cursor, state) {
            if (cursor) {
                if (isFunction(cursor)) {
                    var result = cursor(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else if (cursor !== undefined) {
                    return cursor;
                }
            }
            return this.theme.getCursor(state);
        };
        Object.defineProperty(DBase.prototype, "snippet", {
            get: function () {
                return this._snippet;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "reflowable", {
            get: function () {
                return this._reflowable;
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.initReflowable = function () {
            new DBaseReflowableImpl(this);
        };
        DBase.prototype.onChildrenChange = function () {
            this.toChildrenDirty();
            _super.prototype.onChildrenChange.call(this);
        };
        DBase.prototype.onShortcut = function (e) {
            // DO NOTHING
        };
        DBase.prototype.init = function (options) {
            // OTHER INITIALIZATIONS BEFORE `parent.addChild( this )`
        };
        Object.defineProperty(DBase.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.onMove = function (newX, newY, oldX, oldY) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentMove(newX, newY, oldX, oldY);
                }
            }
            DApplications.update(this);
            this.emit("move", newX, newY, oldX, oldY, this);
        };
        DBase.prototype.resize = function (width, height) {
            var oldWidth = this._width;
            var oldHeight = this._height;
            var widthResized = oldWidth !== width;
            var heightResized = oldHeight !== height;
            if (widthResized) {
                this._width = width;
            }
            if (heightResized) {
                this._height = height;
            }
            var resized = widthResized || heightResized;
            if (resized) {
                this.onResize(width, height, oldWidth, oldHeight);
            }
            if (widthResized) {
                var scalarSet = this._scalarSet;
                if (scalarSet.x != null) {
                    var position = this.transform.position;
                    var parent_1 = this.getParentOfSize();
                    if (parent_1) {
                        this.x = scalarSet.x(parent_1.width, width, parent_1.padding.getLeft(), position.x);
                    }
                }
            }
            if (heightResized) {
                var scalarSet = this._scalarSet;
                if (scalarSet.y != null) {
                    var position = this.transform.position;
                    var parent_2 = this.getParentOfSize();
                    if (parent_2) {
                        this.y = scalarSet.y(parent_2.height, height, parent_2.padding.getTop(), position.y);
                    }
                }
            }
            return resized;
        };
        DBase.prototype.getClearType = function () {
            return this._clearType;
        };
        DBase.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            this.toDirty();
            this.toChildrenDirty();
            var padding = this._padding;
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(newWidth, newHeight, padding);
                }
            }
            DApplications.update(this);
            this.emit("resize", newWidth, newHeight, oldWidth, oldHeight, this);
        };
        DBase.prototype.onScale = function (newX, newY, oldX, oldY) {
            DApplications.update(this);
            this.emit("scale", newX, newY, oldX, oldY, this);
        };
        DBase.prototype.onSkew = function (newX, newY, oldX, oldY) {
            DApplications.update(this);
            this.emit("skew", newX, newY, oldX, oldY, this);
        };
        Object.defineProperty(DBase.prototype, "type", {
            get: function () {
                return this.getType();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "x", {
            // @ts-ignore
            get: function () {
                return this._position.x;
            },
            set: function (x) {
                this._position.x = x;
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getX = function () {
            var scalarSet = this._scalarSet;
            if (scalarSet.x != null) {
                return scalarSet.x;
            }
            else {
                return this.x;
            }
        };
        DBase.prototype.setX = function (x) {
            if (isNumber(x)) {
                this.x = x;
            }
            else {
                var scalarSet = this._scalarSet;
                var scalar = DScalarFunctions.position(x);
                if (scalarSet.x !== scalar) {
                    scalarSet.x = scalar;
                    this.layout();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "y", {
            // @ts-ignore
            get: function () {
                return this._position.y;
            },
            set: function (y) {
                this._position.y = y;
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getY = function () {
            var scalarSet = this._scalarSet;
            if (scalarSet.y != null) {
                return scalarSet.y;
            }
            else {
                return this.y;
            }
        };
        DBase.prototype.setY = function (y) {
            if (isNumber(y)) {
                this.y = y;
            }
            else {
                var scalarSet = this._scalarSet;
                var scalar = DScalarFunctions.position(y);
                if (scalarSet.y !== scalar) {
                    scalarSet.y = scalar;
                    this.layout();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this._width;
            },
            set: function (width) {
                var oldWidth = this._width;
                if (oldWidth !== width) {
                    this._width = width;
                    var height = this._height;
                    this.onResize(width, height, oldWidth, height);
                    // Layout
                    var scalarSet = this._scalarSet;
                    if (scalarSet.x != null) {
                        var position = this.transform.position;
                        var parent_3 = this.getParentOfSize();
                        if (parent_3) {
                            this.x = scalarSet.x(parent_3.width, width, parent_3.padding.getLeft(), position.x);
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getWidth = function () {
            return this._auto.width.toCoordinate(this._scalarSet.width || this._width);
        };
        DBase.prototype.setWidth = function (width) {
            var auto = this._auto.width;
            var isOn = auto.isOn;
            var isAuto = auto.from(width);
            if (auto.isOn !== isOn) {
                this.toChildrenDirty();
                DApplications.update(this);
            }
            if (!isAuto) {
                if (isNumber(width)) {
                    this.width = width;
                }
                else {
                    var scalarSet = this._scalarSet;
                    var scalar = DScalarFunctions.size(width);
                    if (scalarSet.width !== scalar) {
                        scalarSet.width = scalar;
                        this.layout();
                    }
                }
            }
        };
        Object.defineProperty(DBase.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this._height;
            },
            set: function (height) {
                var oldHeight = this._height;
                if (oldHeight !== height) {
                    this._height = height;
                    var width = this._width;
                    this.onResize(width, height, width, oldHeight);
                    // Layout
                    var scalarSet = this._scalarSet;
                    if (scalarSet.y != null) {
                        var position = this.transform.position;
                        var parent_4 = this.getParentOfSize();
                        if (parent_4) {
                            this.y = scalarSet.y(parent_4.height, height, parent_4.padding.getTop(), position.y);
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getHeight = function () {
            return this._auto.height.toCoordinate(this._scalarSet.height || this._height);
        };
        DBase.prototype.setHeight = function (height) {
            var auto = this._auto.height;
            var isOn = auto.isOn;
            var isAuto = auto.from(height);
            if (auto.isOn !== isOn) {
                this.toChildrenDirty();
                DApplications.update(this);
            }
            if (!isAuto) {
                if (isNumber(height)) {
                    this.height = height;
                }
                else {
                    var scalarSet = this._scalarSet;
                    var scalar = DScalarFunctions.size(height);
                    if (scalarSet.height !== scalar) {
                        scalarSet.height = scalar;
                        this.layout();
                    }
                }
            }
        };
        Object.defineProperty(DBase.prototype, "position", {
            // @ts-ignore
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "scale", {
            // @ts-ignore
            get: function () {
                return this._scale;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "skew", {
            // @ts-ignore
            get: function () {
                return this._skew;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "corner", {
            get: function () {
                return this._corner;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "background", {
            get: function () {
                return this._background;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "border", {
            get: function () {
                return this._border;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "outline", {
            get: function () {
                return this._outline;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "unsafe", {
            get: function () {
                return this.transform;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (title) {
                if (this._title !== title) {
                    this._title = title;
                    if (this.state.isHovered) {
                        this.applyTitle();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.applyTitle = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.view.title = this._title;
            }
        };
        DBase.prototype.show = function () {
            if (!this.visible) {
                this.visible = true;
                this.toParentChildrenDirty();
                DApplications.update(this);
            }
            return this;
        };
        DBase.prototype.isShown = function () {
            return this.visible;
        };
        DBase.prototype.hide = function () {
            if (this.visible) {
                this.visible = false;
                this.toParentChildrenDirty();
                this.blur(true);
                DApplications.update(this);
            }
            return this;
        };
        DBase.prototype.isHidden = function () {
            return !this.visible;
        };
        DBase.prototype.toDirty = function () {
            if (!this._isDirty) {
                this._isDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toHasDirty = function () {
            if (!this._hasDirty) {
                this._hasDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toParentHasDirty = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.toHasDirty();
            }
        };
        DBase.prototype.toChildrenDirty = function () {
            if (!this._isChildrenDirty) {
                this._isChildrenDirty = true;
                this.onChildrenDirty();
                this.toParentChildrenDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toParentChildrenDirty = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.toChildrenDirty();
            }
        };
        DBase.prototype.isChildrenDirty = function () {
            return this._isChildrenDirty;
        };
        DBase.prototype.onChildrenDirty = function () {
            // DO NOTHING
        };
        DBase.prototype.isDirty = function () {
            return this._isDirty;
        };
        DBase.prototype.hasDirty = function () {
            return this._hasDirty;
        };
        DBase.prototype.setFocused = function (isFocused) {
            if (this.state.isFocused !== isFocused) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().set(this, isFocused);
                }
            }
            return this;
        };
        DBase.prototype.focus = function () {
            return this.setFocused(true);
        };
        DBase.prototype.blur = function (recursively) {
            if (recursively) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var focusController = layer.getFocusController();
                    var focused = focusController.get();
                    if (focused instanceof DBase) {
                        var current = focused;
                        while (current) {
                            if (current === this) {
                                focused.setFocused(false);
                                break;
                            }
                            current = current.parent;
                        }
                    }
                }
            }
            else {
                this.setFocused(false);
            }
            return this;
        };
        DBase.prototype.onStateChange = function (newState, oldState) {
            this.toDirty();
            DApplications.update(this);
            this.emit("statechange", newState, oldState, this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.state.onParentChange(newState, oldState);
                }
            }
            if (newState.isFocused) {
                if (!oldState.isFocused) {
                    this.onFocus();
                }
            }
            else if (oldState.isFocused) {
                this.onBlur();
            }
            this.cursor = this.toCursor(this._cursor, newState);
        };
        DBase.prototype.onChildFocus = function (focused) {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocus(focused);
            }
        };
        DBase.prototype.onFocus = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocus(this);
            }
        };
        DBase.prototype.onChildBlur = function (blured) {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildBlur(blured);
            }
        };
        DBase.prototype.onBlur = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildBlur(this);
            }
        };
        Object.defineProperty(DBase.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "theme", {
            get: function () {
                return this._theme;
            },
            set: function (theme) {
                var result = this._theme;
                if (result !== theme) {
                    this._theme = theme;
                    this._padding.setTheme(theme);
                    this._background.setTheme(theme);
                    this._border.setTheme(theme);
                    this._outline.setTheme(theme);
                    this._corner.setTheme(theme);
                    this.toDirty();
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.refit = function () {
            if (this._isChildrenDirty) {
                this._isChildrenDirty = false;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.refit();
                    }
                }
                this.onRefit();
            }
        };
        DBase.prototype.onRefit = function () {
            var auto = this._auto;
            var isWidthAuto = auto.width.isOn;
            var isHeightAuto = auto.height.isOn;
            if (isWidthAuto && isHeightAuto) {
                var width = 0;
                var height = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible) {
                        if (this.hasRefitableWidth(child)) {
                            width = Math.max(width, child.x + child.width);
                        }
                        if (this.hasRefitableHeight(child)) {
                            height = Math.max(height, child.y + child.height);
                        }
                    }
                }
                var padding = this.padding;
                this.resize(width + padding.getRight(), height + padding.getBottom());
            }
            else if (isWidthAuto) {
                var width = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible && this.hasRefitableWidth(child)) {
                        width = Math.max(width, child.x + child.width);
                    }
                }
                this.width = width + this.padding.getRight();
            }
            else if (isHeightAuto) {
                var height = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible && this.hasRefitableHeight(child)) {
                        height = Math.max(height, child.y + child.height);
                    }
                }
                this.height = height + this.padding.getBottom();
            }
        };
        DBase.prototype.isRefitable = function (target) {
            return target instanceof DBase;
        };
        DBase.prototype.hasRefitableHeight = function (target) {
            return (this.isRefitable(target) && !(target instanceof DBase && isFunction(target.getHeight())));
        };
        DBase.prototype.hasRefitableWidth = function (target) {
            return (this.isRefitable(target) && !(target instanceof DBase && isFunction(target.getWidth())));
        };
        DBase.prototype.reflow = function () {
            if (this._isDirty) {
                this.onReflow();
                this._isDirty = false;
            }
            if (this._hasDirty) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                    }
                }
                this._hasDirty = false;
            }
        };
        DBase.prototype.onReflow = function () {
            this._reflowable.onReflow(this, this._width, this._height);
        };
        Object.defineProperty(DBase.prototype, "shadow", {
            get: function () {
                return this._shadow;
            },
            set: function (shadow) {
                var previous = this._shadow;
                if (previous !== shadow) {
                    var reflowable = this._reflowable;
                    var snippet = this._snippet;
                    var onShadowUpdateBound = this._onShadowUpdateBound;
                    if (previous != null) {
                        previous.off("update", onShadowUpdateBound);
                        reflowable.remove(previous);
                        snippet.remove(previous, true);
                    }
                    this._shadow = shadow;
                    if (shadow != null) {
                        shadow.on("update", onShadowUpdateBound);
                        reflowable.add(shadow);
                        snippet.addAt(shadow, true, 0);
                    }
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.layout = function () {
            var parent = this.getParentOfSize();
            if (parent) {
                this.onParentResize(parent.width, parent.height, parent.padding);
            }
        };
        DBase.prototype.getParentOfSize = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                return parent;
            }
            else {
                return DApplications.getLayer(this);
            }
        };
        /**
         * Called when a parent resized.
         *
         * @param parentWidth a parent's local width
         * @param parentHeight a parent's local height
         */
        DBase.prototype.onParentResize = function (parentWidth, parentHeight, parentPadding) {
            var scalarSet = this._scalarSet;
            var position = this.transform.position;
            var x = position.x;
            var y = position.y;
            var width = this._width;
            var height = this._height;
            // Width & height
            var paddingWidth = parentPadding.getLeft() + parentPadding.getRight();
            var paddingHeight = parentPadding.getTop() + parentPadding.getBottom();
            var newWidth = scalarSet.width != null
                ? scalarSet.width(parentWidth, width, paddingWidth, width)
                : width;
            var newHeight = scalarSet.height != null
                ? scalarSet.height(parentHeight, height, paddingHeight, height)
                : height;
            this.resize(newWidth, newHeight);
            // X & Y
            var newX = scalarSet.x != null
                ? scalarSet.x(parentWidth, this._width, parentPadding.getLeft(), x)
                : x;
            var newY = scalarSet.y != null
                ? scalarSet.y(parentHeight, this._height, parentPadding.getTop(), y)
                : y;
            this.position.set(newX, newY);
        };
        /**
         * Called when a parent moved.
         *
         * @param newX a new parent's local x position
         * @param newY a new parent's local y position
         * @param oldX an old parent's local x position
         * @param oldY an old parent's local y position
         */
        DBase.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            // DO NOTHING
        };
        // Wheel
        DBase.prototype.onWheel = function (e, deltas, global) {
            this.emit("wheel", e, deltas, global, this);
            return false;
        };
        // Keydown
        DBase.prototype.onKeyDown = function (e) {
            this.emit("keydown", e, this);
            return false;
        };
        DBase.prototype.onKeyUp = function (e) {
            this.emit("keyup", e, this);
            return false;
        };
        // Down
        DBase.prototype.isEventTarget = function (e) {
            var target = e.target;
            if (target === this) {
                return true;
            }
            else if (target != null && !(target instanceof DBase)) {
                var parent_5 = target.parent;
                while (parent_5 != null && !(parent_5 instanceof DBase)) {
                    parent_5 = parent_5.parent;
                }
                return parent_5 === this;
            }
            return false;
        };
        DBase.prototype.onDown = function (e) {
            if (this.isEventTarget(e)) {
                this.onDownThis(e);
            }
            this.emit("down", e, this);
        };
        DBase.prototype.onDownThis = function (e) {
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                var lastDownPoint = this._lastDownPoint || new pixi_js.Point();
                this._lastDownPoint = lastDownPoint;
                lastDownPoint.copyFrom(e.data.global);
            }
            else {
                this.focusOnClosest();
            }
        };
        DBase.prototype.onUp = function (e) {
            if (this.isEventTarget(e)) {
                this.onUpThis(e);
            }
            this.emit("up", e, this);
        };
        DBase.prototype.onUpThis = function (e) {
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                var lastDownPoint = this._lastDownPoint;
                if (lastDownPoint) {
                    var global_1 = e.data.global;
                    var dx = Math.abs(global_1.x - lastDownPoint.x);
                    var dy = Math.abs(global_1.y - lastDownPoint.y);
                    var threshold = UtilPointerEvent.CLICK_DISTANCE_THRESHOLD;
                    if (dx < threshold && dy < threshold) {
                        this.focusOnClosest();
                    }
                }
            }
        };
        DBase.prototype.focusOnClosest = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var focusController = layer.getFocusController();
                focusController.focus(focusController.findParent(this));
            }
        };
        // Over
        DBase.prototype.onOver = function (e) {
            // Update the hover state
            this.state.isHovered = true;
            // Update the title
            if (e.target === this) {
                this.applyTitle();
            }
            // Event
            this.emit("over", e, this);
        };
        // Out
        DBase.prototype.onOut = function (e) {
            // Update the hover state
            this.state.isHovered = false;
            // Event
            this.emit("out", e, this);
        };
        // Double click
        DBase.prototype.onDblClick = function (e, interactionManager) {
            this.emit("dblclick", e, interactionManager, this);
            return false;
        };
        //
        DBase.prototype.render = function (renderer) {
            if (this.visible && 0 < this.worldAlpha && this.renderable) {
                var snippet = this._snippet;
                snippet.render(renderer, true);
                _super.prototype.render.call(this, renderer);
                snippet.render(renderer, false);
            }
        };
        //
        DBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DBase.prototype.getType = function () {
            return "DBase";
        };
        //
        DBase.prototype._calculateBounds = function () {
            var worldTransform = this.transform.worldTransform;
            var bounds = this._bounds;
            var work = DBase.WORK_CONTAINS_POINT;
            work.set(0, 0);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(this._width, this._height);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            _super.prototype._calculateBounds.call(this);
        };
        DBase.prototype.containsPoint = function (point) {
            return (this.containsGlobalPoint(point) ||
                this.containsLocalPoint(this.worldTransform.applyInverse(point, DBase.WORK_CONTAINS_POINT)));
        };
        DBase.prototype.containsGlobalPoint = function (point) {
            return false;
        };
        DBase.prototype.containsLocalPoint = function (point) {
            var x = point.x;
            var y = point.y;
            var w = this._width;
            var h = this._height;
            return 0 <= x && x <= w && 0 <= y && y <= h;
        };
        /**
         * Returns a clipping rect.
         *
         * @param result a clipping rect
         */
        DBase.prototype.getClippingRect = function (target, result) {
            result.x = 0;
            result.y = 0;
            result.width = this._width;
            result.height = this._height;
        };
        DBase.prototype.destroy = function () {
            // Layout
            var scalarSet = this._scalarSet;
            scalarSet.x = null;
            scalarSet.y = null;
            scalarSet.width = null;
            scalarSet.height = null;
            // Shadow
            var shadow = this._shadow;
            if (shadow) {
                this._shadow = null;
                shadow.destroy();
            }
            // Children
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            //
            _super.prototype.destroy.call(this);
        };
        DBase.WORK_CONTAINS_POINT = new pixi_js.Point();
        return DBase;
    }(pixi_js.Container));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOverflowMask = /** @class */ (function (_super) {
        __extends(DBaseOverflowMask, _super);
        function DBaseOverflowMask(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            return _this;
        }
        DBaseOverflowMask.prototype.render = function (renderer) {
            this.updateTransform();
            _super.prototype.render.call(this, renderer);
        };
        DBaseOverflowMask.prototype.onReflow = function (base, width, height) {
            var x = 0;
            var y = 0;
            var corner = base.corner;
            var cornerRadius = Math.max(0, corner.getRadius() - 0.5);
            var cornerMask = corner.getMask();
            var tl = cornerMask & DCornerMask.TOP_LEFT ? 0 : cornerRadius;
            var tr = cornerMask & DCornerMask.TOP_RIGHT ? 0 : cornerRadius;
            var bl = cornerMask & DCornerMask.BOTTOM_LEFT ? 0 : cornerRadius;
            var br = cornerMask & DCornerMask.BOTTOM_RIGHT ? 0 : cornerRadius;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.lineStyle(0, 0, 0, 0, false);
            if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
                this.drawRect(x, y, width, height);
            }
            else {
                this.moveTo(x + tl, y);
                if (0 < tr) {
                    this.arcTo(x + width, y, x + width, y + height, tr);
                }
                else {
                    this.lineTo(x + width, y);
                }
                if (0 < br) {
                    this.arcTo(x + width, y + height, x, y + height, br);
                }
                else {
                    this.lineTo(x + width, y + height);
                }
                if (0 < bl) {
                    this.arcTo(x, y + height, x, y, bl);
                }
                else {
                    this.lineTo(x, y + height);
                }
                if (0 < tl) {
                    this.arcTo(x, y, x + width, y, tl);
                }
                else {
                    this.lineTo(x, y);
                }
            }
            this.endFill();
        };
        return DBaseOverflowMask;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMouseModifier;
    (function (DMouseModifier) {
        DMouseModifier[DMouseModifier["NONE"] = 0] = "NONE";
        DMouseModifier[DMouseModifier["CTRL"] = 1] = "CTRL";
        DMouseModifier[DMouseModifier["SHIFT"] = 2] = "SHIFT";
        DMouseModifier[DMouseModifier["ALT"] = 4] = "ALT";
        DMouseModifier[DMouseModifier["AND"] = 8] = "AND";
        DMouseModifier[DMouseModifier["OR"] = 16] = "OR";
        DMouseModifier[DMouseModifier["NOT_NONE"] = 23] = "NOT_NONE";
    })(DMouseModifier || (DMouseModifier = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMouseModifiers = /** @class */ (function () {
        function DMouseModifiers() {
        }
        DMouseModifiers.from = function (e) {
            var oe = "data" in e ? e.data.originalEvent : e;
            return ((oe.ctrlKey ? DMouseModifier.CTRL : DMouseModifier.NONE) |
                (oe.altKey ? DMouseModifier.ALT : DMouseModifier.NONE) |
                (oe.shiftKey ? DMouseModifier.SHIFT : DMouseModifier.NONE));
        };
        DMouseModifiers.match = function (e, modifier) {
            if (modifier & DMouseModifier.OR) {
                return !!(DMouseModifiers.from(e) & modifier);
            }
            else {
                return DMouseModifiers.from(e) === modifier;
            }
        };
        return DMouseModifiers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDragMode;
    (function (DDragMode) {
        DDragMode[DDragMode["OFF"] = 0] = "OFF";
        DDragMode[DDragMode["ON"] = 1] = "ON";
        DDragMode[DDragMode["TOUCH"] = 2] = "TOUCH";
    })(DDragMode || (DDragMode = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationTimings = /** @class */ (function () {
        function DAnimationTimings() {
        }
        DAnimationTimings.LINEAR = function (t) {
            return t;
        };
        DAnimationTimings.ELASTIC = function (t) {
            return t * (3 * (1 - t) * (1 - t) + t * (3 * (1 - t) + t));
        };
        DAnimationTimings.QUAD_IN_OUT = function (t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        };
        return DAnimationTimings;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationBase = /** @class */ (function (_super) {
        __extends(DAnimationBase, _super);
        function DAnimationBase(options) {
            var _a, _b, _c;
            var _this = _super.call(this) || this;
            _this._id = null;
            _this._target = (_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : null;
            _this._startTime = 0;
            _this._duration = (_b = options === null || options === void 0 ? void 0 : options.duration) !== null && _b !== void 0 ? _b : 200;
            _this._durationInverse = 1 / Math.max(1, _this._duration);
            _this._reverse = false;
            _this._onTime = options === null || options === void 0 ? void 0 : options.onTime;
            _this._onTimeBaseBound = function () {
                _this.onTimeBase();
            };
            _this._onStart = options === null || options === void 0 ? void 0 : options.onStart;
            _this._onEnd = options === null || options === void 0 ? void 0 : options.onEnd;
            _this._timing = (_c = options === null || options === void 0 ? void 0 : options.timing) !== null && _c !== void 0 ? _c : DAnimationTimings.ELASTIC;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DAnimationBase.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DAnimationBase.prototype, "duration", {
            get: function () {
                return this._duration;
            },
            set: function (duration) {
                this._duration = duration;
                this._durationInverse = 1 / Math.max(1, duration);
            },
            enumerable: false,
            configurable: true
        });
        DAnimationBase.prototype.start = function (reverse) {
            if (reverse === void 0) { reverse = false; }
            this.stop();
            this._startTime = Date.now();
            this._reverse = reverse;
            this._id = window.setTimeout(this._onTimeBaseBound, 0);
            // onStart
            this.onStart(reverse);
            // onTime
            var duration = this._duration;
            var time = this.toTime(reverse ? duration : 0);
            this.onTime(time, reverse, 0);
        };
        DAnimationBase.prototype.onStart = function (isReverse) {
            var onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        };
        DAnimationBase.prototype.onTime = function (time, isReverse, elapsedTime) {
            var onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        };
        DAnimationBase.prototype.onEnd = function (isReverse) {
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        };
        DAnimationBase.prototype.isStarted = function () {
            return this._id != null;
        };
        DAnimationBase.prototype.isReverse = function () {
            return this._reverse;
        };
        DAnimationBase.prototype.onTimeBase = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                var elapsedTime = Date.now() - this._startTime;
                var duration = this._duration;
                var reverse = this._reverse;
                if (elapsedTime < duration) {
                    this._id = window.setTimeout(this._onTimeBaseBound, 0);
                    // OnTime
                    var time = this.toTime(reverse ? duration - elapsedTime : elapsedTime);
                    this.onTime(time, reverse, elapsedTime);
                }
                else {
                    // OnTime
                    var time = this.toTime(reverse ? 0 : duration);
                    this.onTime(time, reverse, elapsedTime);
                    // OnEnd
                    this.onEnd(reverse);
                }
            }
        };
        DAnimationBase.prototype.toTime = function (elapsedTime) {
            return this._timing(elapsedTime * this._durationInverse, this);
        };
        DAnimationBase.prototype.stop = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
            }
        };
        DAnimationBase.prototype.end = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
                // OnTime
                var reverse = this._reverse;
                var elapsedTime = Date.now() - this._startTime;
                var duration = this._duration;
                var time = this.toTime(reverse ? 0 : duration);
                this.onTime(time, reverse, elapsedTime);
                // OnEnd
                this.onEnd(reverse);
            }
        };
        return DAnimationBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilDragEasingHistory = /** @class */ (function () {
        function UtilDragEasingHistory(dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        }
        UtilDragEasingHistory.prototype.set = function (dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        };
        return UtilDragEasingHistory;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilDragEasing = /** @class */ (function () {
        function UtilDragEasing(onMove, options) {
            var _this = this;
            this._histories = [];
            this._historiesSorted = [];
            this._historyBegin = 0;
            this._historyEnd = -1;
            this._dx = 0;
            this._dy = 0;
            this._ds = 0;
            this._dt = 0;
            this._animation = new DAnimationBase({
                onTime: function (t) {
                    _this.onEase(t);
                },
                timing: DAnimationTimings.LINEAR,
                duration: 1000
            });
            var duration = options && options.duration;
            if (duration) {
                if (isNumber(duration)) {
                    this._durationPosition = duration;
                    this._durationScale = duration;
                }
                else {
                    this._durationPosition = duration.position != null ? duration.position : 1;
                    this._durationScale = duration.scale != null ? duration.scale : 1;
                }
            }
            else {
                this._durationPosition = 1;
                this._durationScale = 1;
            }
            this._onMove = onMove;
        }
        UtilDragEasing.prototype.onStart = function () {
            // History
            var histories = this._histories;
            for (var i = histories.length, imax = UtilDragEasing.HISTORY_CAPACITY; i < imax; ++i) {
                histories.push(new UtilDragEasingHistory(0, 0, 1, 0));
            }
            this._historyBegin = 0;
            this._historyEnd = -1;
            // Stop animation
            this._animation.stop();
        };
        UtilDragEasing.prototype.onMove = function (dx, dy, ds, dt) {
            var capacity = UtilDragEasing.HISTORY_CAPACITY;
            var oldHistoryEnd = this._historyEnd;
            var newHistoryEnd = (oldHistoryEnd + 1) % capacity;
            this._historyEnd = newHistoryEnd;
            var oldHistoryBegin = this._historyBegin;
            if (newHistoryEnd < oldHistoryEnd ||
                (0 <= oldHistoryEnd && oldHistoryEnd < oldHistoryBegin)) {
                this._historyBegin = (oldHistoryBegin + 1) % capacity;
            }
            this._histories[newHistoryEnd].set(dx, dy, ds, dt);
        };
        UtilDragEasing.prototype.updateHistoriesSorted = function (dt) {
            var unsorted = this._histories;
            var sorted = this._historiesSorted;
            var begin = this._historyBegin;
            var end = this._historyEnd;
            var length = unsorted.length;
            var threshold = 160;
            if (end < 0) {
                sorted.length = 0;
                return dt;
            }
            else if (end < begin) {
                var total = dt;
                sorted.length = 0;
                for (var i = end; 0 <= i; --i) {
                    var history_1 = unsorted[i];
                    if (total + history_1.dt < threshold) {
                        total += history_1.dt;
                        sorted.push(history_1);
                    }
                    else {
                        return total;
                    }
                }
                for (var i = length - 1; begin <= i; --i) {
                    var history_2 = unsorted[i];
                    if (total + history_2.dt < threshold) {
                        total += history_2.dt;
                        sorted.push(history_2);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
            else {
                var total = dt;
                sorted.length = 0;
                for (var i = end; begin <= i; --i) {
                    var history_3 = unsorted[i];
                    if (total + history_3.dt < threshold) {
                        total += history_3.dt;
                        sorted.push(history_3);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
        };
        UtilDragEasing.prototype.onEnd = function (ldt) {
            var adt = this.updateHistoriesSorted(ldt);
            var sorted = this._historiesSorted;
            var sortedLength = sorted.length;
            if (0 < sortedLength) {
                var dx = 0;
                var dy = 0;
                var ds = 0;
                var dt = 0;
                for (var i = 0; i < sortedLength; ++i) {
                    var history_4 = sorted[i];
                    dx += history_4.dx;
                    dy += history_4.dy;
                    ds += history_4.ds;
                    dt += history_4.dt;
                }
                var w = (1 - ldt / adt) / sortedLength;
                dx *= w;
                dy *= w;
                ds = 1 + (ds - sortedLength) * w;
                dt *= w;
                this._dx = dx;
                this._dy = dy;
                this._ds = ds;
                this._dt = dt;
                // Start animation
                var d0 = this._durationPosition * 40 * Math.sqrt(dx * dx + dy * dy);
                var d1 = this._durationScale * 10000 * Math.abs(ds - 1);
                var animation = this._animation;
                animation.duration = Math.max(d0, d1);
                animation.start();
            }
        };
        UtilDragEasing.prototype.onEase = function (time) {
            var w = 1 - time;
            this._onMove(this._dx * w, this._dy * w, 1 + (this._ds - 1) * w, time);
        };
        UtilDragEasing.prototype.stop = function () {
            this._animation.stop();
        };
        UtilDragEasing.HISTORY_CAPACITY = 5;
        return UtilDragEasing;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toEasingOptions = function (options) {
        return options == null || options === true ? undefined : options;
    };
    var toChecker = function (options) {
        var _a, _b;
        var checker = options.checker;
        var defaultChecker = DMouseModifiers.match;
        return {
            start: (_a = checker === null || checker === void 0 ? void 0 : checker.start) !== null && _a !== void 0 ? _a : defaultChecker,
            move: (_b = checker === null || checker === void 0 ? void 0 : checker.move) !== null && _b !== void 0 ? _b : defaultChecker
        };
    };
    var UtilDrag = /** @class */ (function () {
        function UtilDrag(options) {
            var _this = this;
            var _a;
            var target = options.target;
            this._target = target;
            var on = options.on;
            if (on) {
                this._onStart = on.start;
                this._onMove = on.move;
                this._onEnd = on.end;
            }
            this._modifier = (_a = options === null || options === void 0 ? void 0 : options.modifier) !== null && _a !== void 0 ? _a : DMouseModifier.NONE;
            this._checker = toChecker(options);
            this._interactionManager = null;
            this._center = new pixi_js.Point();
            this._scale = 1;
            this._scalingCenter = new pixi_js.Point();
            this._time = 0;
            var easing = options.easing;
            if (easing == null || easing !== false) {
                var onEasingMoveBound = function (dx, dy, ds, time) {
                    _this.onEasingMove(dx, dy, ds, time);
                };
                this._easing = new UtilDragEasing(onEasingMoveBound, toEasingOptions(easing));
            }
            this._onDownBound = function (e) {
                _this.onDown(e);
            };
            this._onMoveBound = function (e) {
                _this.onMove(e);
            };
            this._onEndBound = function (e) {
                _this.onEnd(e);
            };
            if (options.touch) {
                this._down = "touchstart";
                this._move = "touchmove";
                this._up = "touchend";
            }
            else {
                this._down = UtilPointerEvent.down;
                this._move = UtilPointerEvent.move;
                this._up = UtilPointerEvent.up;
            }
            if (options.bind !== false) {
                target.on(this._down, this._onDownBound);
            }
        }
        UtilDrag.prototype.calcCenterAndScale = function (e, center, interactionManager) {
            var oe = e.data.originalEvent;
            var global = e.data.global;
            if ("touches" in oe) {
                var touches = oe.touches;
                var touchesLength = touches.length;
                if (0 < touchesLength) {
                    // Update the center
                    var first = touches[0];
                    var centerX = first.clientX;
                    var centerY = first.clientY;
                    for (var i = 1, imax = touches.length; i < imax; ++i) {
                        var touch = touches[i];
                        centerX += touch.clientX;
                        centerY += touch.clientY;
                    }
                    centerX /= touchesLength;
                    centerY /= touchesLength;
                    interactionManager.mapPositionToPoint(center, centerX, centerY);
                    if (1 < touchesLength) {
                        // Calculate the maximum distance from the center
                        var squareDistance = 0;
                        for (var i = 1, imax = touches.length; i < imax; ++i) {
                            var touch = touches[i];
                            var dx = touch.clientX - centerX;
                            var dy = touch.clientY - centerY;
                            squareDistance = Math.max(squareDistance, dx * dx + dy * dy);
                        }
                        return Math.sqrt(squareDistance);
                    }
                    else {
                        return 0;
                    }
                }
            }
            center.copyFrom(global);
            return 0;
        };
        UtilDrag.prototype.onDown = function (e) {
            var target = this._target;
            if (this._checker.start(e, this._modifier, target)) {
                var layer = DApplications.getLayer(target);
                if (layer) {
                    e.stopPropagation();
                    if (target.state.isDragging) {
                        var interactionManager = this._interactionManager;
                        if (interactionManager) {
                            var center = this._center;
                            this._scale = this.calcCenterAndScale(e, center, interactionManager);
                        }
                    }
                    else {
                        target.state.isDragging = true;
                        // Interaction manager
                        var interactionManager = layer.renderer.plugins.interaction;
                        this._interactionManager = interactionManager;
                        // Update the center
                        var center = this._center;
                        this._scale = this.calcCenterAndScale(e, center, interactionManager);
                        //
                        this._time = e.data.originalEvent.timeStamp;
                        // Easing util
                        var easing = this._easing;
                        if (easing) {
                            easing.onStart();
                        }
                        // User-defined handler
                        var onStart = this._onStart;
                        if (onStart != null) {
                            onStart();
                        }
                        // Event handler
                        interactionManager.on(this._move, this._onMoveBound);
                        interactionManager.on(this._up, this._onEndBound);
                    }
                }
            }
        };
        UtilDrag.prototype.onMove = function (e) {
            var target = this._target;
            if (target.state.isDragging && this._checker.move(e, this._modifier, target)) {
                var interactionManager = this._interactionManager;
                if (interactionManager) {
                    // Update the center
                    var center = this._center;
                    var centerX = center.x;
                    var centerY = center.y;
                    var newScale = this.calcCenterAndScale(e, center, interactionManager);
                    var oldScale = this._scale;
                    this._scale = newScale;
                    var oldTime = this._time;
                    var newTime = e.data.originalEvent.timeStamp;
                    this._time = newTime;
                    // Calculate the position
                    var dx = center.x - centerX;
                    var dy = center.y - centerY;
                    var dt = newTime - oldTime;
                    var ds = UtilDrag.EPSILON < oldScale ? newScale / oldScale : 1;
                    // Easing util
                    var easing = this._easing;
                    if (easing) {
                        easing.onMove(dx, dy, ds, dt);
                    }
                    // User-defined handler
                    var onMove = this._onMove;
                    if (onMove != null) {
                        if (dx !== 0 || dy !== 0 || ds !== 1) {
                            onMove(dx, dy, center.x, center.y, ds);
                        }
                    }
                }
            }
        };
        UtilDrag.prototype.onEnd = function (e) {
            var target = this._target;
            if (target.state.isDragging) {
                var interactionManager = this._interactionManager;
                if (interactionManager) {
                    // Update the center
                    var center = this._center;
                    this._scalingCenter.copyFrom(center);
                    this._scale = this.calcCenterAndScale(e, center, interactionManager);
                    // Finalize
                    var oe = e.data.originalEvent;
                    if ("touches" in oe ? oe.touches.length <= 0 : true) {
                        target.state.isDragging = false;
                        // Event handler
                        this._interactionManager = null;
                        interactionManager.off(this._move, this._onMoveBound);
                        interactionManager.off(this._up, this._onEndBound);
                        // User-defined handler
                        var onEnd = this._onEnd;
                        if (onEnd != null) {
                            onEnd();
                        }
                        // Easing util
                        var easing = this._easing;
                        if (easing) {
                            easing.onEnd(e.data.originalEvent.timeStamp - this._time);
                        }
                    }
                }
            }
        };
        UtilDrag.prototype.onEasingMove = function (dx, dy, ds, time) {
            var onMove = this._onMove;
            if (onMove != null) {
                if (dx !== 0 || dy !== 0 || ds !== 1) {
                    var scalingCenter = this._scalingCenter;
                    scalingCenter.set(scalingCenter.x + dx, scalingCenter.y + dy);
                    onMove(dx, dy, scalingCenter.x, scalingCenter.y, ds);
                }
            }
        };
        UtilDrag.prototype.stop = function () {
            var easing = this._easing;
            if (easing) {
                easing.stop();
            }
        };
        UtilDrag.EPSILON = 0.00001;
        return UtilDrag;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewDragImpl = /** @class */ (function () {
        function DViewDragImpl(parent, toTarget, stopper, theme, options) {
            var _this = this;
            var _a, _b, _c;
            this._parent = parent;
            this._toTarget = toTarget;
            this._stopper = stopper;
            var mode = toEnum((_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : theme.getDragMode(), DDragMode);
            var modifier = toEnum((_b = options === null || options === void 0 ? void 0 : options.modifier) !== null && _b !== void 0 ? _b : theme.getDragModifier(), DMouseModifier);
            var duration = (_c = options === null || options === void 0 ? void 0 : options.duration) !== null && _c !== void 0 ? _c : {
                position: theme.getDragDurationPosition(),
                scale: theme.getDragDurationScale()
            };
            var bind = mode === DDragMode.TOUCH;
            this._bind = bind;
            if (mode === DDragMode.ON || mode === DDragMode.TOUCH) {
                this._dragUtil = new UtilDrag({
                    target: parent,
                    touch: bind,
                    modifier: modifier,
                    checker: options && options.checker,
                    easing: {
                        duration: duration
                    },
                    bind: bind,
                    on: {
                        start: function () {
                            _this._stopper.stop();
                        },
                        move: function (dx, dy, x, y, ds) {
                            var target = toTarget(parent);
                            if (target != null) {
                                // Scale
                                var oldScale = target.scale.y;
                                var newScale = stopper.toNormalizedScale(oldScale * ds);
                                var scaleRatio = newScale / oldScale;
                                // Position
                                var cx = x - dx;
                                var cy = y - dy;
                                var position = target.position;
                                var newX = (position.x - cx) * scaleRatio + x;
                                var newY = (position.y - cy) * scaleRatio + y;
                                // Update
                                target.scale.set(newScale, newScale);
                                target.position.set(newX, newY);
                            }
                        }
                    }
                });
            }
        }
        DViewDragImpl.prototype.stop = function () {
            var dragUtil = this._dragUtil;
            if (dragUtil != null) {
                dragUtil.stop();
            }
        };
        DViewDragImpl.prototype.onDown = function (e) {
            if (!this._bind) {
                var dragUtil = this._dragUtil;
                if (dragUtil) {
                    dragUtil.onDown(e);
                }
            }
        };
        return DViewDragImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewTransformImpl = /** @class */ (function () {
        function DViewTransformImpl(parent, toTarget, stopper, duration) {
            var _this = this;
            this._parent = parent;
            this._toTarget = toTarget;
            this._newScaleX = 1;
            this._newScaleY = 1;
            this._newX = 0;
            this._newY = 0;
            this._oldScaleX = 1;
            this._oldScaleY = 1;
            this._oldX = 0;
            this._oldY = 0;
            this._animation = new DAnimationBase({
                onTime: function (time) {
                    _this.onTime(time);
                },
                duration: duration
            });
            this._stopper = stopper;
            this._duration = duration;
        }
        DViewTransformImpl.prototype.onTime = function (time) {
            var w0 = 1 - time;
            var w1 = time;
            var scaleX = this._oldScaleX * w0 + this._newScaleX * w1;
            var scaleY = this._oldScaleY * w0 + this._newScaleY * w1;
            var x = this._oldX * w0 + this._newX * w1;
            var y = this._oldY * w0 + this._newY * w1;
            var target = this._toTarget(this._parent);
            if (target != null) {
                target.scale.set(scaleX, scaleY);
                target.position.set(x, y);
            }
        };
        DViewTransformImpl.prototype.start = function (target, x, Y, scaleX, scaleY, duration, stop) {
            if (stop !== false) {
                this._stopper.stop();
            }
            if (duration == null) {
                duration = this._duration;
            }
            if (duration <= 0) {
                target.scale.set(scaleX, scaleY);
                target.position.set(x, Y);
            }
            else {
                var position = target.position;
                var scale = target.scale;
                this._oldX = position.x;
                this._oldY = position.y;
                this._oldScaleX = scale.x;
                this._oldScaleY = scale.y;
                this._newX = x;
                this._newY = Y;
                this._newScaleX = scaleX;
                this._newScaleY = scaleY;
                this._animation.duration = duration;
                this._animation.start();
            }
        };
        DViewTransformImpl.prototype.stop = function () {
            this._animation.stop();
        };
        return DViewTransformImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewImpl = /** @class */ (function () {
        function DViewImpl(parent, toTarget, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
            this._parent = parent;
            this._toTarget = toTarget;
            this._workRect = new pixi_js.Rectangle();
            // Theme
            var theme = this.toTheme(options) || this.getThemeDefault();
            // Zoom
            var zoom = options === null || options === void 0 ? void 0 : options.zoom;
            this._zoomPoint = new pixi_js.Point();
            this._zoomMin = (_a = zoom === null || zoom === void 0 ? void 0 : zoom.min) !== null && _a !== void 0 ? _a : theme.getZoomMin();
            this._zoomMax = (_b = zoom === null || zoom === void 0 ? void 0 : zoom.max) !== null && _b !== void 0 ? _b : theme.getZoomMax();
            this._zoomKeepRatio = (_c = zoom === null || zoom === void 0 ? void 0 : zoom.keepRatio) !== null && _c !== void 0 ? _c : theme.getZoomKeepRatio();
            // Zoom: Wheel
            var wheelZoom = zoom === null || zoom === void 0 ? void 0 : zoom.wheel;
            this._isWheelZoomEnabled = (_d = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.enable) !== null && _d !== void 0 ? _d : theme.isWheelZoomEnabled();
            this._wheelZoomSpeed = (_e = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.speed) !== null && _e !== void 0 ? _e : theme.getWheelZoomSpeed();
            this._wheelZoomModifier = toEnum((_f = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.modifier) !== null && _f !== void 0 ? _f : theme.getWheelZoomModifier(), DMouseModifier);
            this._wheelZoomChecker = (_g = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.checker) !== null && _g !== void 0 ? _g : DMouseModifiers.match;
            // Zoom: Dbl click
            var dblClickZoom = zoom === null || zoom === void 0 ? void 0 : zoom.dblclick;
            this._isDblClickZoomEnabled = (_h = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.enable) !== null && _h !== void 0 ? _h : theme.isDblClickZoomEnabled();
            this._dblClickZoomSpeed = (_j = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.amount) !== null && _j !== void 0 ? _j : theme.getDblClickZoomSpeed();
            this._dblClickZoomModifier = toEnum((_k = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.modifier) !== null && _k !== void 0 ? _k : theme.getDblClickZoomModifier(), DMouseModifier);
            this._dblClickZoomChecker = (_l = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.checker) !== null && _l !== void 0 ? _l : DMouseModifiers.match;
            this._dblclickZoomDuration = (_m = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.duration) !== null && _m !== void 0 ? _m : theme.getDblClickZoomDuration();
            // Translation: Wheel
            var wheelTranslation = (_o = options === null || options === void 0 ? void 0 : options.translation) === null || _o === void 0 ? void 0 : _o.wheel;
            this._isWheelTranslationEnabled =
                (_p = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.enable) !== null && _p !== void 0 ? _p : theme.isWheelTranslationEnabled();
            this._wheelTranslationSpeed = (_q = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.speed) !== null && _q !== void 0 ? _q : theme.getWheelTranslationSpeed();
            this._wheelTranslationModifier = toEnum((_r = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.modifier) !== null && _r !== void 0 ? _r : theme.getWheelTranslationModifier(), DMouseModifier);
            this._wheelTranslationChecker = (_s = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.checker) !== null && _s !== void 0 ? _s : DMouseModifiers.match;
            // Drag
            this._drag = new DViewDragImpl(parent, toTarget, this, theme, options === null || options === void 0 ? void 0 : options.drag);
            // Transform
            this._transform = new DViewTransformImpl(parent, toTarget, this, this._dblclickZoomDuration);
        }
        Object.defineProperty(DViewImpl.prototype, "drag", {
            get: function () {
                return this._drag;
            },
            enumerable: false,
            configurable: true
        });
        DViewImpl.prototype.stop = function () {
            this._drag.stop();
            this._transform.stop();
        };
        DViewImpl.prototype.reset = function (duration, stop) {
            var parent = this._parent;
            var target = this._toTarget(parent);
            if (target) {
                var targetRect = target.getLocalBounds(this._workRect);
                var newTargetX = (parent.width - targetRect.width) * 0.5 - targetRect.x;
                var newTargetY = (parent.height - targetRect.height) * 0.5 - targetRect.y;
                this._transform.start(target, newTargetX, newTargetY, 1, 1, duration, stop);
            }
        };
        DViewImpl.prototype.fit = function (duration, stop) {
            var parent = this._parent;
            var target = this._toTarget(parent);
            if (target) {
                var padding = parent.padding;
                var width = parent.width;
                var height = parent.height;
                var targetRect = target.getLocalBounds(this._workRect);
                var targetX = targetRect.x;
                var targetY = targetRect.y;
                var targetWidth = targetRect.width;
                var targetHeight = targetRect.height;
                var newTargetScaleX = (width - padding.getLeft() - padding.getRight()) / targetWidth;
                var newTargetScaleY = (height - padding.getTop() - padding.getBottom()) / targetHeight;
                if (this._zoomKeepRatio) {
                    var newTargetScale = this.toNormalizedScale(Math.min(newTargetScaleX, newTargetScaleY));
                    newTargetScaleX = newTargetScale;
                    newTargetScaleY = newTargetScale;
                }
                else {
                    newTargetScaleX = this.toNormalizedScale(newTargetScaleX);
                    newTargetScaleY = this.toNormalizedScale(newTargetScaleY);
                }
                var newTargetWidth = targetWidth * newTargetScaleX;
                var newTargetHeight = targetHeight * newTargetScaleY;
                var newTargetX = (width - newTargetWidth) * 0.5 - targetX * newTargetScaleX;
                var newTargetY = (height - newTargetHeight) * 0.5 - targetY * newTargetScaleY;
                this._transform.start(target, newTargetX, newTargetY, newTargetScaleX, newTargetScaleY, duration, stop);
            }
        };
        DViewImpl.prototype.zoomIn = function (duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var factor = this._dblClickZoomSpeed;
                var targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        };
        DViewImpl.prototype.zoomOut = function (duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var factor = 1 / this._dblClickZoomSpeed;
                var targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        };
        DViewImpl.prototype.zoomAt = function (x, y, scaleX, scaleY, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                // Scale
                var oldScaleX = target.scale.x;
                var oldScaleY = target.scale.y;
                var newScaleX = this.toNormalizedScale(scaleX);
                var newScaleY = this.toNormalizedScale(scaleY);
                var scaleRatioX = newScaleX / oldScaleX;
                var scaleRatioY = newScaleY / oldScaleY;
                // Position
                var newX = (target.position.x - x) * scaleRatioX + x;
                var newY = (target.position.y - y) * scaleRatioY + y;
                // Start
                this._transform.start(target, newX, newY, newScaleX, newScaleY, duration, stop);
            }
        };
        DViewImpl.prototype.zoomAtGlobal = function (x, y, scaleX, scaleY, duration, stop) {
            var local = this._zoomPoint;
            local.set(x, y);
            this.toLocal(local, local);
            this.zoomAt(local.x, local.y, scaleX, scaleY, duration, stop);
        };
        DViewImpl.prototype.zoom = function (scaleX, scaleY, duration, stop) {
            var parent = this._parent;
            this.zoomAt(parent.width * 0.5, parent.height * 0.5, scaleX, scaleY, duration, stop);
        };
        Object.defineProperty(DViewImpl.prototype, "scale", {
            get: function () {
                var target = this._toTarget(this._parent);
                if (target) {
                    return target.scale;
                }
                return new pixi_js.Point(1, 1);
            },
            set: function (scale) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var newScaleX = this.toNormalizedScale(scale.x);
                    var newScaleY = this.toNormalizedScale(scale.y);
                    target.scale.set(newScaleX, newScaleY);
                }
            },
            enumerable: false,
            configurable: true
        });
        DViewImpl.prototype.moveTo = function (x, y, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var targetScale = target.scale;
                this._transform.start(target, x, y, targetScale.x, targetScale.y, duration, stop);
            }
        };
        Object.defineProperty(DViewImpl.prototype, "position", {
            get: function () {
                var target = this._toTarget(this._parent);
                if (target) {
                    return target.position;
                }
                return new pixi_js.Point(0, 0);
            },
            set: function (position) {
                var target = this._toTarget(this._parent);
                if (target) {
                    target.position.set(position.x, position.y);
                }
            },
            enumerable: false,
            configurable: true
        });
        DViewImpl.prototype.transform = function (x, y, scaleX, scaleY, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                this._transform.start(target, x, y, scaleX, scaleY, duration, stop);
            }
        };
        DViewImpl.prototype.toLocal = function (global, local, skipUpdate) {
            return this._parent.toLocal(global, undefined, local, skipUpdate);
        };
        DViewImpl.prototype.toGlobal = function (local, global, skipUpdate) {
            return this._parent.toGlobal(local, global, skipUpdate);
        };
        DViewImpl.prototype.toNormalizedScale = function (scale) {
            return Math.min(this._zoomMax, Math.max(this._zoomMin, scale));
        };
        DViewImpl.prototype.onWheel = function (e, deltas, global) {
            if (this._isWheelZoomEnabled &&
                this._wheelZoomChecker(e, this._wheelZoomModifier, this._parent)) {
                if (deltas.deltaY !== 0) {
                    var target = this._toTarget(this._parent);
                    if (target) {
                        var speed = deltas.lowest * this._wheelZoomSpeed;
                        var factor = 1 + deltas.deltaY * speed;
                        var targetScale = target.scale;
                        this.zoomAtGlobal(global.x, global.y, targetScale.x * factor, targetScale.y * factor, 0);
                        return true;
                    }
                }
            }
            if (this._isWheelTranslationEnabled &&
                this._wheelTranslationChecker(e, this._wheelTranslationModifier, this._parent)) {
                var target = this._toTarget(this._parent);
                if (target) {
                    this.stop();
                    var speed = deltas.lowest * this._wheelTranslationSpeed;
                    target.position.set(target.position.x - deltas.deltaX * speed, target.position.y + deltas.deltaY * speed);
                    return true;
                }
            }
            return false;
        };
        DViewImpl.prototype.onDown = function (e) {
            this._drag.onDown(e);
        };
        DViewImpl.prototype.onDblClick = function (e, interactionManager) {
            if (this._isDblClickZoomEnabled &&
                this._dblClickZoomChecker(e, this._dblClickZoomModifier, this._parent)) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var global_1 = this._zoomPoint;
                    UtilPointerEvent.toGlobal(e, interactionManager, global_1);
                    var factor = this._dblClickZoomSpeed;
                    var targetScale = target.scale;
                    this.zoomAtGlobal(global_1.x, global_1.y, targetScale.x * factor, targetScale.y * factor, this._dblclickZoomDuration);
                    return true;
                }
            }
            return false;
        };
        DViewImpl.prototype.toTheme = function (options) {
            if (options && options.theme) {
                var theme = options.theme;
                if (isString(theme)) {
                    return DThemes.getInstance().get(theme);
                }
                else {
                    return theme;
                }
            }
            return null;
        };
        DViewImpl.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DViewImpl.prototype.getType = function () {
            return "DView";
        };
        return DViewImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A canvas container.
     */
    var DCanvasContainer = /** @class */ (function (_super) {
        __extends(DCanvasContainer, _super);
        function DCanvasContainer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCanvasContainer.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            this._canvas = null;
            var theme = this.theme;
            this._view = new DViewImpl(this, function () { return _this._canvas; }, options === null || options === void 0 ? void 0 : options.view);
            // Canvas
            var canvas = options === null || options === void 0 ? void 0 : options.canvas;
            if (canvas) {
                this.canvas = canvas;
            }
            // Overflow mask
            var mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : theme.isOverflowMaskEnabled();
            if (mask) {
                this.mask = this.getOverflowMask();
            }
        };
        DCanvasContainer.prototype.getType = function () {
            return "DCanvasContainer";
        };
        DCanvasContainer.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.updateContentSize(newWidth, newHeight, oldWidth, oldHeight);
        };
        Object.defineProperty(DCanvasContainer.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            set: function (canvas) {
                var previous = this._canvas;
                if (previous != null) {
                    this._canvas = null;
                    this.removeChild(previous);
                    this.emit("unset", previous, this);
                    previous.destroy();
                }
                this._canvas = canvas;
                if (canvas != null) {
                    this.addChild(canvas);
                    this._view.reset(0);
                    this.emit("set", canvas, this);
                }
                else {
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DCanvasContainer.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this._reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        DCanvasContainer.prototype.updateContentSize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var canvas = this._canvas;
            if (canvas != null) {
                var canvasX = canvas.x + (newWidth - oldWidth) * 0.5;
                var canvasY = canvas.y + (newHeight - oldHeight) * 0.5;
                canvas.position.set(canvasX, canvasY);
            }
        };
        Object.defineProperty(DCanvasContainer.prototype, "view", {
            get: function () {
                return this._view;
            },
            enumerable: false,
            configurable: true
        });
        DCanvasContainer.prototype.onWheel = function (e, deltas, global) {
            var vresult = this._view.onWheel(e, deltas, global);
            var sresult = _super.prototype.onWheel.call(this, e, deltas, global);
            return vresult || sresult;
        };
        DCanvasContainer.prototype.onDblClick = function (e, interactionManager) {
            var vresult = this._view.onDblClick(e, interactionManager);
            var sresult = _super.prototype.onDblClick.call(this, e, interactionManager);
            return vresult || sresult;
        };
        DCanvasContainer.prototype.onDown = function (e) {
            this._view.onDown(e);
            _super.prototype.onDown.call(this, e);
        };
        DCanvasContainer.prototype.destroy = function () {
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            _super.prototype.destroy.call(this);
        };
        return DCanvasContainer;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimes = /** @class */ (function () {
        function EShapeActionRuntimes() {
        }
        EShapeActionRuntimes.toContainer = function (shape) {
            var current = shape;
            while (current != null) {
                if (current instanceof DCanvasContainer) {
                    return current;
                }
                current = current.parent;
            }
            return null;
        };
        EShapeActionRuntimes.open = function (shape, target) {
            var container = this.toContainer(shape);
            if (container) {
                container.openByName(target);
            }
        };
        EShapeActionRuntimes.write = function (shape, id, value, time, remote) {
            var container = this.toContainer(shape);
            if (container) {
                if (remote) {
                    container.tag.remote.set(id, value, time);
                }
                else {
                    container.tag.set(id, value, time);
                }
            }
        };
        EShapeActionRuntimes.emit = function (shape, name, value, time) {
            var container = EShapeActionRuntimes.toContainer(shape);
            if (time === undefined) {
                shape.emit(name, shape);
                if (container) {
                    container.shape.emit(name, shape);
                }
            }
            else {
                shape.emit(name, value, time, shape);
                if (container) {
                    container.shape.emit(name, value, time, shape);
                }
            }
        };
        return EShapeActionRuntimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeEmitEvent, _super);
        function EShapeActionRuntimeEmitEvent(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.name = EShapeActionExpressions.ofStringOrNull(value.name);
            return _this;
        }
        EShapeActionRuntimeEmitEvent.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var name_1 = this.name(shape, time);
                if (name_1 != null) {
                    EShapeActionRuntimes.emit(shape, name_1);
                }
            }
        };
        return EShapeActionRuntimeEmitEvent;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionValueEmitEvent, _super);
        function EShapeActionValueEmitEvent(condition, name) {
            var _this = _super.call(this, EShapeActionValueType.EMIT_EVENT, condition) || this;
            _this.name = name;
            return _this;
        }
        EShapeActionValueEmitEvent.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueEmitEvent &&
                this.name === value.name);
        };
        EShapeActionValueEmitEvent.prototype.toRuntime = function () {
            return new EShapeActionRuntimeEmitEvent(this);
        };
        EShapeActionValueEmitEvent.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var nameId = manager.addResource(this.name);
            return manager.addResource("[" + this.type + "," + conditionId + "," + nameId + "]");
        };
        EShapeActionValueEmitEvent.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueEmitEvent(condition, name);
        };
        return EShapeActionValueEmitEvent;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscEmitEvent, _super);
        function EShapeActionRuntimeMiscEmitEvent(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            return _this;
        }
        EShapeActionRuntimeMiscEmitEvent.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var target = this.target(shape, time);
                if (target != null) {
                    EShapeActionRuntimes.emit(shape, target);
                }
            }
        };
        return EShapeActionRuntimeMiscEmitEvent;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DHtmlElementState = {
        NO_POINTER_EVENTS: "NO_POINTER_EVENTS"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DHtmlElement} option when to show a HTML element
     */
    var UtilHtmlElementWhen;
    (function (UtilHtmlElementWhen) {
        /**
         * Shows a HTML element when clicked.
         */
        UtilHtmlElementWhen[UtilHtmlElementWhen["CLICKED"] = 0] = "CLICKED";
        /**
         * Shows a HTML element when double clicked.
         */
        UtilHtmlElementWhen[UtilHtmlElementWhen["DOUBLE_CLICKED"] = 1] = "DOUBLE_CLICKED";
        /**
         * Shows a HTML element when focused.
         * And also shows when clicked if focused.
         */
        UtilHtmlElementWhen[UtilHtmlElementWhen["FOCUSED"] = 2] = "FOCUSED";
        /**
         * Always shows a HTML element.
         */
        UtilHtmlElementWhen[UtilHtmlElementWhen["ALWAYS"] = 3] = "ALWAYS";
    })(UtilHtmlElementWhen || (UtilHtmlElementWhen = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHtmlElement = /** @class */ (function () {
        function UtilHtmlElement(target, operation, theme, options) {
            var _this = this;
            this._target = target;
            this._operation = operation;
            var data = this.toData(theme, options);
            this._data = data;
            this._isElementShown = false;
            this._onElementFocusBound = function (e) {
                _this.onElementFocus(e);
            };
            this._onBeforeFocusBound = function (e) {
                _this.onBeforeFocus(e);
            };
            this._onAfterFocusBound = function (e) {
                _this.onAfterFocus(e);
            };
            this._isStarted = false;
            this._wasStarted = false;
            this._doSelectBound = function () {
                _this.doSelect();
            };
            this._isStartRequested = this._data.when === UtilHtmlElementWhen.ALWAYS;
            this._onPostRenderBound = function () {
                _this.updateElement(_this._rendererBound);
            };
        }
        UtilHtmlElement.prototype.toData = function (theme, options) {
            var _a, _b;
            return {
                element: this.toElementData(theme, options === null || options === void 0 ? void 0 : options.element),
                clipper: this.toClipperData(theme, options === null || options === void 0 ? void 0 : options.clipper),
                before: this.toBeforeData(theme, options === null || options === void 0 ? void 0 : options.before),
                after: this.toAfterData(theme, options === null || options === void 0 ? void 0 : options.after),
                when: toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : theme.getWhen(), UtilHtmlElementWhen),
                select: (_b = options === null || options === void 0 ? void 0 : options.select) !== null && _b !== void 0 ? _b : theme.getSelect()
            };
        };
        UtilHtmlElement.prototype.toElementData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getElementCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newElementStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newElementStyler = function (theme) {
            return function (target, state, padding, elementRect, elementMatrix, clipperRect) {
                return theme.setElementStyle(target, state, padding, elementRect, elementMatrix, clipperRect);
            };
        };
        UtilHtmlElement.prototype.toClipperData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getClipperCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newClipperStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newClipperStyler = function (theme) {
            return function (target, state, padding, elementRect, elementMatrix, clipperRect) {
                return theme.setClipperStyle(target, state, padding, elementRect, elementMatrix, clipperRect);
            };
        };
        UtilHtmlElement.prototype.toBeforeData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getBeforeCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newBeforeStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newBeforeStyler = function (theme) {
            return function (target) {
                theme.setBeforeStyle(target);
            };
        };
        UtilHtmlElement.prototype.toAfterData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getAfterCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newAfterStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newAfterStyler = function (theme) {
            return function (target) {
                theme.setAfterStyle(target);
            };
        };
        Object.defineProperty(UtilHtmlElement.prototype, "element", {
            get: function () {
                var _a;
                return (_a = this._element) !== null && _a !== void 0 ? _a : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilHtmlElement.prototype, "when", {
            get: function () {
                return this._data.when;
            },
            enumerable: false,
            configurable: true
        });
        UtilHtmlElement.prototype.onDownThisBefore = function (e) {
            this._wasStarted = this._isStarted;
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                    this.start();
                    break;
                case UtilHtmlElementWhen.FOCUSED:
                    if (this._target.state.isFocused) {
                        this.start();
                    }
                    break;
            }
        };
        UtilHtmlElement.prototype.onDownThisAfter = function (e) {
            if (!this._wasStarted && this._isStarted) {
                if ("data" in e) {
                    e.data.originalEvent.preventDefault();
                }
                else {
                    e.preventDefault();
                }
            }
        };
        UtilHtmlElement.prototype.onDblClick = function (e, interactionManager) {
            switch (this.when) {
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                    this.start();
                    break;
            }
        };
        UtilHtmlElement.prototype.onFocus = function () {
            var _a;
            switch (this.when) {
                case UtilHtmlElementWhen.FOCUSED:
                    this.start();
                    break;
                default:
                    (_a = this._element) === null || _a === void 0 ? void 0 : _a.focus();
                    break;
            }
        };
        UtilHtmlElement.prototype.onBlur = function () {
            var _a;
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                case UtilHtmlElementWhen.FOCUSED:
                    this.onEndByBlur();
                    this.cancel();
                    break;
                default:
                    (_a = this._element) === null || _a === void 0 ? void 0 : _a.blur();
                    break;
            }
        };
        UtilHtmlElement.prototype.isStartable = function () {
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                case UtilHtmlElementWhen.FOCUSED:
                    return this._target.state.isActionable;
                default:
                    return true;
            }
        };
        UtilHtmlElement.prototype.start = function () {
            if (!this._isStarted && this.isStartable()) {
                this._isStarted = true;
                if (this._target.worldVisible) {
                    this.doStart();
                }
                else {
                    this._isStartRequested = true;
                }
                DApplications.update(this._target);
            }
        };
        UtilHtmlElement.prototype.isShown = function () {
            return this._isElementShown;
        };
        UtilHtmlElement.prototype.onRender = function (renderer) {
            if (this._isStartRequested ||
                (!this._isElementShown && this.when === UtilHtmlElementWhen.ALWAYS)) {
                this._isStartRequested = false;
                this.doStart(renderer);
            }
            if (this._isStarted) {
                this._isStarted = false;
            }
        };
        UtilHtmlElement.prototype.getElementRect = function (resolution) {
            var point = this._point || new pixi_js.Point(0, 0);
            this._point = point;
            var result = this._elementRectResult || new pixi_js.Rectangle();
            this._elementRectResult = result;
            return this._operation.getElementRect(resolution, point, result);
        };
        UtilHtmlElement.prototype.getElementMatrix = function () {
            return this._operation.getElementMatrix();
        };
        UtilHtmlElement.prototype.getClipperRect = function (resolution) {
            var point = this._point || new pixi_js.Point(0, 0);
            this._point = point;
            var result = this._clipperRectResult || new pixi_js.Rectangle();
            this._clipperRectResult = result;
            return this._operation.getClipperRect(resolution, point, result);
        };
        UtilHtmlElement.prototype.doStart = function (renderer) {
            var _a, _b;
            if (!this._isElementShown) {
                this._isElementShown = true;
                var rendererBound = this._rendererBound;
                if (rendererBound != null) {
                    this._rendererBound = undefined;
                    rendererBound.off("postrender", this._onPostRenderBound);
                }
                var target = this._target;
                if (renderer == null) {
                    renderer = (_a = DApplications.getLayer(target)) === null || _a === void 0 ? void 0 : _a.renderer;
                }
                if (renderer) {
                    this._rendererBound = renderer;
                    renderer.on("postrender", this._onPostRenderBound);
                }
                this.onStart();
                var clipper = this.getClipper();
                if (clipper) {
                    var before = this.getBefore(clipper);
                    var element = this.getElement(clipper);
                    var after = this.getAfter(clipper);
                    if (element) {
                        var resolution = (_b = renderer === null || renderer === void 0 ? void 0 : renderer.resolution) !== null && _b !== void 0 ? _b : DApplications.getResolution(target);
                        var elementRect = this.getElementRect(resolution);
                        var elementMatrix = this.getElementMatrix();
                        var clipperRect = this.toClipperRectAdjusted(elementRect, elementMatrix, this.getClipperRect(resolution));
                        var state = target.state;
                        var padding = this._operation.getPadding();
                        var options = this._data;
                        options.clipper.styler(clipper, state, padding, elementRect, elementMatrix, clipperRect);
                        options.element.styler(element, state, padding, elementRect, elementMatrix, clipperRect);
                        if (before) {
                            options.before.styler(before);
                        }
                        if (after) {
                            options.after.styler(after);
                        }
                        this.onElementAttached(element, before, after);
                        // Show HTML elements
                        clipper.style.display = "";
                        if (state.isFocused) {
                            element.focus();
                        }
                        clipper.scrollTop = 0;
                        clipper.scrollLeft = 0;
                        // Select the element if required.
                        if (this._data.select) {
                            setTimeout(this._doSelectBound, 0);
                        }
                    }
                }
            }
        };
        UtilHtmlElement.prototype.onStart = function () {
            this._operation.onStart();
        };
        UtilHtmlElement.prototype.doSelect = function () {
            var element = this._element;
            if (element) {
                if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                    // The following does not work on mobile devices.
                    // I think selecting texts on a tap is annoying.
                    // Therefore, I leave this untouched.
                    element.select();
                }
            }
        };
        UtilHtmlElement.prototype.cancel = function () {
            if (this._isElementShown) {
                this._isElementShown = false;
                var rendererBound = this._rendererBound;
                if (rendererBound != null) {
                    this._rendererBound = undefined;
                    rendererBound.off("postrender", this._onPostRenderBound);
                }
                this.onCancel();
                var target = this._target;
                var layer = DApplications.getLayer(target);
                if (layer) {
                    var view = layer.view;
                    switch (this.when) {
                        case UtilHtmlElementWhen.CLICKED:
                        case UtilHtmlElementWhen.DOUBLE_CLICKED:
                        case UtilHtmlElementWhen.FOCUSED:
                            if (document.activeElement === this._element) {
                                view.focus();
                            }
                            break;
                    }
                    var state = target.state;
                    var interactionManager = layer.renderer.plugins.interaction;
                    if (this._operation.containsPoint(interactionManager.mouse.global) &&
                        !state.isHovered) {
                        state.isHovered = true;
                        view.style.cursor = target.cursor;
                    }
                    layer.update();
                }
                var element = this._element;
                if (element != null) {
                    this.onElementDetached(element, this._before, this._after);
                }
                var clipper = this._clipper;
                if (clipper != null) {
                    clipper.style.display = "none";
                }
            }
        };
        UtilHtmlElement.prototype.onCancel = function () {
            this._operation.onCancel();
        };
        UtilHtmlElement.prototype.onElementAttached = function (element, before, after) {
            before === null || before === void 0 ? void 0 : before.addEventListener("focus", this._onBeforeFocusBound);
            after === null || after === void 0 ? void 0 : after.addEventListener("focus", this._onAfterFocusBound);
            element.addEventListener("focus", this._onElementFocusBound, true);
        };
        UtilHtmlElement.prototype.onElementDetached = function (element, before, after) {
            before === null || before === void 0 ? void 0 : before.removeEventListener("focus", this._onBeforeFocusBound);
            after === null || after === void 0 ? void 0 : after.removeEventListener("focus", this._onAfterFocusBound);
            element.removeEventListener("focus", this._onElementFocusBound, true);
        };
        UtilHtmlElement.prototype.getClipper = function () {
            var result = this._clipper;
            if (result == null) {
                var layer = DApplications.getLayer(this._target);
                result = layer ? this._data.clipper.creator(layer.getElementContainer()) : null;
                this._clipper = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getElement = function (clipper) {
            var result = this._element;
            if (result == null) {
                result = this._data.element.creator(clipper);
                this._element = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getBefore = function (clipper) {
            var result = this._before;
            if (result == null) {
                result = this._data.before.creator(clipper);
                this._before = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getAfter = function (clipper) {
            var result = this._after;
            if (result == null) {
                result = this._data.after.creator(clipper);
                this._after = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.onBeforeFocus = function (e) {
            var target = this._target;
            var layer = DApplications.getLayer(target);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.find(target, false, false, false);
                layer.view.focus();
                focusController.focus(focusable);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        };
        UtilHtmlElement.prototype.onAfterFocus = function (e) {
            var target = this._target;
            var layer = DApplications.getLayer(target);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.find(target, false, false, true);
                layer.view.focus();
                focusController.focus(focusable);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        };
        UtilHtmlElement.prototype.onElementFocus = function (e) {
            if (this.when === UtilHtmlElementWhen.ALWAYS) {
                var target = this._target;
                if (!target.state.isFocused) {
                    target.focus();
                }
            }
        };
        UtilHtmlElement.prototype.onEndByBlur = function () {
            this.onEnd();
        };
        UtilHtmlElement.prototype.onEnd = function () {
            this._operation.onEnd();
        };
        UtilHtmlElement.prototype.end = function () {
            this.onEnd();
            this.cancel();
        };
        UtilHtmlElement.prototype.select = function () {
            if (this._isElementShown && this._data.select) {
                this.doSelect();
            }
            return this;
        };
        UtilHtmlElement.prototype.toClipperRectAdjusted = function (elementRect, elementMatrix, clipperRect) {
            if (clipperRect && elementRect && elementMatrix == null) {
                var ex0 = elementRect.x;
                var ey0 = elementRect.y;
                var ex1 = ex0 + elementRect.width;
                var ey1 = ey0 + elementRect.height;
                var cx0 = clipperRect.x;
                var cy0 = clipperRect.y;
                var cx1 = cx0 + clipperRect.width;
                var cy1 = cy0 + clipperRect.height;
                var ncx0 = Math.min(Math.max(cx0, ex0), cx1);
                var ncx1 = Math.min(Math.max(cx0, ex1), cx1);
                var ncy0 = Math.min(Math.max(cy0, ey0), cy1);
                var ncy1 = Math.min(Math.max(cy0, ey1), cy1);
                clipperRect.x = ncx0;
                clipperRect.y = ncy0;
                clipperRect.width = ncx1 - ncx0;
                clipperRect.height = ncy1 - ncy0;
            }
            return clipperRect;
        };
        UtilHtmlElement.prototype.updateElement = function (renderer) {
            if (this._isElementShown) {
                var target = this._target;
                if (target.worldVisible) {
                    var element = this._element;
                    var clipper = this._clipper;
                    if (element && clipper) {
                        var resolution = renderer.resolution;
                        var elementRect = this.getElementRect(resolution);
                        var elementMatrix = this.getElementMatrix();
                        var clipperRect = this.toClipperRectAdjusted(elementRect, elementMatrix, this.getClipperRect(resolution));
                        var state = target.state;
                        var padding = this._operation.getPadding();
                        var options = this._data;
                        options.clipper.styler(clipper, state, padding, elementRect, elementMatrix, clipperRect);
                        options.element.styler(element, state, padding, elementRect, elementMatrix, clipperRect);
                    }
                }
                else {
                    switch (this.when) {
                        case UtilHtmlElementWhen.ALWAYS:
                            var clipper = this._clipper;
                            if (clipper) {
                                clipper.style.display = "none";
                            }
                            break;
                        default:
                            this.cancel();
                            break;
                    }
                }
            }
        };
        UtilHtmlElement.getClipperRect = function (parent, target, resolution, point, result) {
            var isFirst = true;
            var x0 = 0;
            var y0 = 0;
            var x1 = 0;
            var y1 = 0;
            var current = parent;
            while (current instanceof DBase) {
                current.getClippingRect(target, result);
                point.set(result.x, result.y);
                current.toGlobal(point, point, false);
                var cx0 = ((point.x * resolution) | 0) / resolution;
                var cy0 = ((point.y * resolution) | 0) / resolution;
                point.set(result.x + result.width, result.y + result.height);
                current.toGlobal(point, point, true);
                var cx1 = point.x;
                var cy1 = point.y;
                var dx0 = Math.min(cx0, cx1);
                var dy0 = Math.min(cy0, cy1);
                var dx1 = Math.max(cx0, cx1);
                var dy1 = Math.max(cy0, cy1);
                if (isFirst) {
                    isFirst = false;
                    x0 = dx0;
                    y0 = dy0;
                    x1 = dx1;
                    y1 = dy1;
                }
                else {
                    x0 = Math.min(Math.max(x0, dx0), dx1);
                    y0 = Math.min(Math.max(y0, dy0), dy1);
                    x1 = Math.min(Math.max(x1, dx0), dx1);
                    y1 = Math.min(Math.max(y1, dy0), dy1);
                }
                current = current.parent;
            }
            if (isFirst) {
                return null;
            }
            result.x = x0;
            result.y = y0;
            result.width = x1 - x0;
            result.height = y1 - y0;
            return result;
        };
        return UtilHtmlElement;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscHtmlElementBase = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscHtmlElementBase, _super);
        function EShapeActionRuntimeMiscHtmlElementBase(value) {
            var _this = _super.call(this) || this;
            _this.condition = EShapeActionExpressions.ofString(value.condition);
            _this.utils = new Map();
            return _this;
        }
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getUtil = function (shape, runtime) {
            var utils = this.utils;
            var result = utils.get(shape);
            if (result == null) {
                result = this.newUtil(shape, runtime);
                utils.set(shape, result);
            }
            return result;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.newUtil = function (shape, runtime) {
            return new UtilHtmlElement(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DHtmlElement"), this.newUtilOptions(shape, runtime));
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.newOperation = function (shape, runtime) {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(shape, runtime, resolution, work, result);
                },
                getElementMatrix: function () {
                    return _this.getElementMatrix(shape, runtime);
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperToRect(shape, runtime, resolution, work, result);
                },
                getPadding: function () {
                    return _this.getPadding(shape, runtime);
                },
                containsPoint: function (point) {
                    return _this.containsPoint(shape, runtime, point);
                },
                onStart: function () {
                    // DO NOTHING
                },
                onCancel: function () {
                    // DO NOTHING
                },
                onEnd: function () {
                    // DO NOTHING
                }
            };
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.newUtilOptions = function (shape, runtime) {
            return {
                element: {
                    creator: this.newElementCreator(shape, runtime)
                },
                when: this.toWhen(shape, runtime)
            };
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.toWhen = function (shape, runtime) {
            var value = this.condition(shape, Date.now());
            if (value != null && value in UtilHtmlElementWhen) {
                return UtilHtmlElementWhen[value];
            }
            return undefined;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.containsPoint = function (shape, runtime, point) {
            if (shape.visible) {
                var local = EShapeActionRuntimeMiscHtmlElementBase.WORK || new pixi_js.Point();
                EShapeActionRuntimeMiscHtmlElementBase.WORK = local;
                shape.toLocal(point, undefined, local);
                return shape.contains(local) != null;
            }
            return false;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getPadding = function (shape, runtime) {
            return null;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getElementRect = function (shape, runtime, resolution, point, result) {
            var pivot = shape.transform.pivot;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            result.x = -0.5 * sizeX + pivot.x;
            result.y = -0.5 * sizeY + pivot.y;
            result.width = sizeX;
            result.height = sizeY;
            return result;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getElementMatrix = function (shape, runtime) {
            shape.updateTransform();
            return shape.transform.worldTransform;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getClipperToRect = function (shape, runtime, resolution, point, result) {
            var container = EShapeActionRuntimes.toContainer(shape);
            return UtilHtmlElement.getClipperRect(container, shape, resolution, point, result);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onRender = function (shape, runtime, time, renderer) {
            this.getUtil(shape, runtime).onRender(renderer);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onFocus = function (shape, runtime) {
            this.getUtil(shape, runtime).onFocus();
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onBlur = function (shape, runtime) {
            this.getUtil(shape, runtime).onBlur();
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onDownThisBefore = function (shape, runtime, e) {
            this.getUtil(shape, runtime).onDownThisBefore(e);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onDownThisAfter = function (shape, runtime, e) {
            this.getUtil(shape, runtime).onDownThisAfter(e);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onDblClick = function (shape, runtime, e, interactionManager) {
            this.getUtil(shape, runtime).onDblClick(e, interactionManager);
        };
        return EShapeActionRuntimeMiscHtmlElementBase;
    }(EShapeActionRuntime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscType;
    (function (EShapeActionValueMiscType) {
        EShapeActionValueMiscType[EShapeActionValueMiscType["INPUT_TEXT"] = 0] = "INPUT_TEXT";
        EShapeActionValueMiscType[EShapeActionValueMiscType["INPUT_INTEGER"] = 1] = "INPUT_INTEGER";
        EShapeActionValueMiscType[EShapeActionValueMiscType["INPUT_REAL"] = 2] = "INPUT_REAL";
        EShapeActionValueMiscType[EShapeActionValueMiscType["EMIT_EVENT"] = 3] = "EMIT_EVENT";
        EShapeActionValueMiscType[EShapeActionValueMiscType["WRITE_BOTH"] = 4] = "WRITE_BOTH";
        EShapeActionValueMiscType[EShapeActionValueMiscType["WRITE_LOCAL"] = 5] = "WRITE_LOCAL";
        EShapeActionValueMiscType[EShapeActionValueMiscType["WRITE_REMOTE"] = 6] = "WRITE_REMOTE";
        EShapeActionValueMiscType[EShapeActionValueMiscType["HTML_ELEMENT"] = 7] = "HTML_ELEMENT";
        EShapeActionValueMiscType[EShapeActionValueMiscType["HTML_ELEMENT_WITHOUT_POINTER_EVENTS"] = 8] = "HTML_ELEMENT_WITHOUT_POINTER_EVENTS";
    })(EShapeActionValueMiscType || (EShapeActionValueMiscType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscHtmlElement = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscHtmlElement, _super);
        function EShapeActionRuntimeMiscHtmlElement(value) {
            var _this = _super.call(this, value) || this;
            _this.elementCreator = EShapeActionExpressions.ofElementOrNull(value.value);
            _this.noPointerEvent =
                value.subtype === EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS;
            return _this;
        }
        EShapeActionRuntimeMiscHtmlElement.prototype.newUtil = function (shape, runtime) {
            if (this.noPointerEvent) {
                shape.state.add(DHtmlElementState.NO_POINTER_EVENTS);
            }
            return _super.prototype.newUtil.call(this, shape, runtime);
        };
        EShapeActionRuntimeMiscHtmlElement.prototype.newElementCreator = function (shape, runtime) {
            var elementCreator = this.elementCreator;
            if (elementCreator) {
                return function (container) {
                    return elementCreator(shape, Date.now(), container);
                };
            }
            return undefined;
        };
        return EShapeActionRuntimeMiscHtmlElement;
    }(EShapeActionRuntimeMiscHtmlElementBase));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInput = /** @class */ (function (_super) {
        __extends(UtilInput, _super);
        function UtilInput(target, operation, theme, options) {
            var _a, _b, _c, _d, _e, _f, _g;
            var _this = _super.call(this, target, operation, theme, options) || this;
            _this._operation = operation;
            _this._onInputKeyDownBound = function (e) {
                _this.onInputKeyDown(e);
            };
            _this._onInputChangeBound = function () {
                _this.onInputChange();
            };
            _this._onInputInputBound = function (e) {
                _this.onInputInput(e);
            };
            _this._description = (_a = options === null || options === void 0 ? void 0 : options.description) !== null && _a !== void 0 ? _a : "";
            var editing = options === null || options === void 0 ? void 0 : options.editing;
            _this._editingFormatter =
                (_e = (_b = editing === null || editing === void 0 ? void 0 : editing.formatter) !== null && _b !== void 0 ? _b : (_d = (_c = options) === null || _c === void 0 ? void 0 : _c.text) === null || _d === void 0 ? void 0 : _d.formatter) !== null && _e !== void 0 ? _e : theme.getEditingFormatter();
            _this._editingUnformatter = (_f = editing === null || editing === void 0 ? void 0 : editing.unformatter) !== null && _f !== void 0 ? _f : theme.getEditingUnformatter();
            _this._editingValidator = (_g = editing === null || editing === void 0 ? void 0 : editing.validator) !== null && _g !== void 0 ? _g : theme.getEditingValidator();
            return _this;
        }
        UtilInput.prototype.onEnd = function () {
            _super.prototype.onEnd.call(this);
            this.onInputChange();
        };
        UtilInput.prototype.onElementAttached = function (element, before, after) {
            element.type = this.getInputType();
            element.value = this.fromValue(this._operation.getValue());
            element.addEventListener("keydown", this._onInputKeyDownBound);
            element.addEventListener("change", this._onInputChangeBound);
            element.addEventListener("input", this._onInputInputBound);
            _super.prototype.onElementAttached.call(this, element, before, after);
        };
        UtilInput.prototype.onElementDetached = function (element, before, after) {
            _super.prototype.onElementDetached.call(this, element, before, after);
            element.removeEventListener("keydown", this._onInputKeyDownBound);
            element.removeEventListener("change", this._onInputChangeBound);
            element.removeEventListener("input", this._onInputInputBound);
        };
        UtilInput.prototype.onInputKeyDown = function (e) {
            if (UtilKeyboardEvent.isOkKey(e)) {
                this.end();
                this._operation.onEnter();
            }
            else if (UtilKeyboardEvent.isCancelKey(e)) {
                this.cancel();
            }
        };
        UtilInput.prototype.onInputChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element != null) {
                    var operation = this._operation;
                    var newValue = this.toValue(element.value);
                    var oldValue = operation.getValue();
                    if (oldValue !== newValue) {
                        operation.onValueChange(newValue, oldValue);
                    }
                }
            }
        };
        UtilInput.prototype.toValue = function (valueAsString) {
            return this._editingUnformatter(valueAsString, this);
        };
        UtilInput.prototype.fromValue = function (value) {
            if (value !== undefined) {
                return this._editingFormatter(value, this);
            }
            return "";
        };
        UtilInput.prototype.onInputInput = function (e) {
            var target = e.target;
            if (target instanceof HTMLInputElement) {
                this._operation.onValueInput(this.toValue(target.value));
            }
        };
        UtilInput.prototype.validate = function () {
            var value = this._operation.getValue();
            if (value !== undefined) {
                var result = this._editingValidator(value, this);
                if (this._editingValidationResult !== result) {
                    this._editingValidationResult = result;
                    var state = this._target.state;
                    state.isInvalid = result != null;
                    if (state.isHovered) {
                        this._operation.applyTitle();
                    }
                }
                return result;
            }
            return null;
        };
        UtilInput.prototype.applyTitle = function () {
            var editingValidationResult = this._editingValidationResult;
            if (isString(editingValidationResult)) {
                var layer = DApplications.getLayer(this._target);
                if (layer) {
                    layer.view.title = editingValidationResult;
                }
                return true;
            }
            return false;
        };
        return UtilInput;
    }(UtilHtmlElement));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputNumber = /** @class */ (function (_super) {
        __extends(UtilInputNumber, _super);
        function UtilInputNumber(target, operation, theme, options) {
            var _a, _b, _c;
            var _this = _super.call(this, target, operation, theme, options) || this;
            _this._step = (_a = options === null || options === void 0 ? void 0 : options.step) !== null && _a !== void 0 ? _a : theme.getStep();
            _this._min = (_b = options === null || options === void 0 ? void 0 : options.min) !== null && _b !== void 0 ? _b : theme.getMin();
            _this._max = (_c = options === null || options === void 0 ? void 0 : options.max) !== null && _c !== void 0 ? _c : theme.getMax();
            return _this;
        }
        Object.defineProperty(UtilInputNumber.prototype, "step", {
            get: function () {
                return this._step;
            },
            set: function (step) {
                if (this._step !== step) {
                    this._step = step;
                    this.onStepChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilInputNumber.prototype, "min", {
            get: function () {
                return this._min;
            },
            set: function (min) {
                if (this._min !== min) {
                    this._min = min;
                    this.onMinChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilInputNumber.prototype, "max", {
            get: function () {
                return this._max;
            },
            set: function (max) {
                if (this._max !== max) {
                    this._max = max;
                    this.onMaxChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        UtilInputNumber.prototype.toValue = function (valueAsString) {
            var result = _super.prototype.toValue.call(this, valueAsString);
            if (result === result /* NaN Check */) {
                var min = this._min;
                if (min != null && result < min) {
                    return min;
                }
                var max = this._max;
                if (max != null && max < result) {
                    return max;
                }
                return result;
            }
            return 0;
        };
        UtilInputNumber.prototype.fromValue = function (value) {
            if (value !== undefined) {
                return this._editingFormatter(value, this);
            }
            return "0";
        };
        UtilInputNumber.prototype.onStepChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element) {
                    this.updateStep(element);
                }
            }
        };
        UtilInputNumber.prototype.onMinChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element) {
                    this.updateMin(element);
                }
            }
        };
        UtilInputNumber.prototype.onMaxChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element) {
                    this.updateMax(element);
                }
            }
        };
        UtilInputNumber.prototype.updateStep = function (input) {
            var step = this.step;
            if (step != null) {
                input.step = "" + step;
            }
            else {
                input.step = "any";
            }
        };
        UtilInputNumber.prototype.updateMin = function (input) {
            var min = this.min;
            if (min != null) {
                input.min = "" + min;
            }
            else {
                input.removeAttribute("min");
            }
        };
        UtilInputNumber.prototype.updateMax = function (input) {
            var max = this.max;
            if (max != null) {
                input.max = "" + max;
            }
            else {
                input.removeAttribute("max");
            }
        };
        UtilInputNumber.prototype.onElementAttached = function (element, before, after) {
            _super.prototype.onElementAttached.call(this, element, before, after);
            this.updateStep(element);
            this.updateMin(element);
            this.updateMax(element);
        };
        UtilInputNumber.prototype.getInputType = function () {
            return "number";
        };
        return UtilInputNumber;
    }(UtilInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOnInputAction;
    (function (EShapeActionValueOnInputAction) {
        EShapeActionValueOnInputAction[EShapeActionValueOnInputAction["EMIT_EVENT"] = 0] = "EMIT_EVENT";
        EShapeActionValueOnInputAction[EShapeActionValueOnInputAction["WRITE_BOTH"] = 1] = "WRITE_BOTH";
        EShapeActionValueOnInputAction[EShapeActionValueOnInputAction["WRITE_LOCAL"] = 2] = "WRITE_LOCAL";
        EShapeActionValueOnInputAction[EShapeActionValueOnInputAction["WRITE_REMOTE"] = 3] = "WRITE_REMOTE";
    })(EShapeActionValueOnInputAction || (EShapeActionValueOnInputAction = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOnInputActions = /** @class */ (function () {
        function EShapeActionValueOnInputActions() {
        }
        EShapeActionValueOnInputActions.execute = function (shape, action, target, value, time) {
            switch (action) {
                case EShapeActionValueOnInputAction.EMIT_EVENT:
                    shape.emit(target, shape, value);
                    EShapeActionRuntimes.emit(shape, target, value, time);
                    break;
                case EShapeActionValueOnInputAction.WRITE_LOCAL:
                    EShapeActionRuntimes.write(shape, target, value, time, false);
                    break;
                case EShapeActionValueOnInputAction.WRITE_REMOTE:
                    EShapeActionRuntimes.write(shape, target, value, time, true);
                    break;
                case EShapeActionValueOnInputAction.WRITE_BOTH:
                    EShapeActionRuntimes.write(shape, target, value, time, false);
                    EShapeActionRuntimes.write(shape, target, value, time, true);
                    break;
            }
        };
        return EShapeActionValueOnInputActions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInput = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInput, _super);
        function EShapeActionRuntimeMiscInput(value) {
            var _this = _super.call(this, value) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.onInputAction = value.onInputAction;
            return _this;
        }
        EShapeActionRuntimeMiscInput.prototype.newOperation = function (shape, runtime) {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(shape, runtime, resolution, work, result);
                },
                getElementMatrix: function () {
                    return _this.getElementMatrix(shape, runtime);
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperToRect(shape, runtime, resolution, work, result);
                },
                getPadding: function () {
                    return _this.getPadding(shape, runtime);
                },
                containsPoint: function (point) {
                    return _this.containsPoint(shape, runtime, point);
                },
                onStart: function () {
                    shape.text.enable = false;
                },
                onCancel: function () {
                    shape.text.enable = true;
                },
                onEnd: function () {
                    // DO NOTHING
                },
                getValue: function () {
                    return _this.getUtil(shape, runtime).toValue(shape.text.value);
                },
                onValueInput: function (newValue) {
                    // DO NOTHING
                },
                onValueChange: function (newValue, oldValue) {
                    _this.onValueChange(shape, runtime, newValue, oldValue);
                },
                onEnter: function () {
                    // DO NOTHING
                },
                applyTitle: function () {
                    // DO NOTHING
                }
            };
        };
        EShapeActionRuntimeMiscInput.prototype.newElementCreator = function (shape, runtime) {
            return undefined;
        };
        EShapeActionRuntimeMiscInput.prototype.getPadding = function (shape, runtime) {
            return shape.text.padding;
        };
        EShapeActionRuntimeMiscInput.prototype.onValueChange = function (shape, runtime, newValue, oldValue) {
            shape.text.value = this.getUtil(shape, runtime).fromValue(newValue);
            var now = Date.now();
            var target = this.target(shape, now);
            if (target != null) {
                EShapeActionValueOnInputActions.execute(shape, this.onInputAction, target, newValue, now);
            }
        };
        return EShapeActionRuntimeMiscInput;
    }(EShapeActionRuntimeMiscHtmlElementBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputInteger = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputInteger, _super);
        function EShapeActionRuntimeMiscInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscInputInteger.prototype.newUtil = function (shape, runtime) {
            return new UtilInputNumber(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputInteger"), this.newUtilOptions(shape, runtime));
        };
        return EShapeActionRuntimeMiscInputInteger;
    }(EShapeActionRuntimeMiscInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputReal = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputReal, _super);
        function EShapeActionRuntimeMiscInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscInputReal.prototype.newUtil = function (shape, runtime) {
            return new UtilInputNumber(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputReal"), this.newUtilOptions(shape, runtime));
        };
        return EShapeActionRuntimeMiscInputReal;
    }(EShapeActionRuntimeMiscInput));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputText = /** @class */ (function (_super) {
        __extends(UtilInputText, _super);
        function UtilInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UtilInputText.prototype.getInputType = function () {
            return "text";
        };
        return UtilInputText;
    }(UtilInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputText, _super);
        function EShapeActionRuntimeMiscInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscInputText.prototype.newUtil = function (shape, runtime) {
            return new UtilInputText(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputText"), this.newUtilOptions(shape, runtime));
        };
        return EShapeActionRuntimeMiscInputText;
    }(EShapeActionRuntimeMiscInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWrite = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWrite, _super);
        function EShapeActionRuntimeMiscWrite(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.value = EShapeActionExpressions.ofUnknown(value.value);
            return _this;
        }
        EShapeActionRuntimeMiscWrite.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var target = this.target(shape, time);
                if (target != null) {
                    this.write(shape, target, this.value(shape, time), time);
                }
            }
        };
        return EShapeActionRuntimeMiscWrite;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWriteBoth = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWriteBoth, _super);
        function EShapeActionRuntimeMiscWriteBoth() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscWriteBoth.prototype.write = function (shape, target, value, time) {
            EShapeActionRuntimes.write(shape, target, value, time, false);
            EShapeActionRuntimes.write(shape, target, value, time, true);
        };
        return EShapeActionRuntimeMiscWriteBoth;
    }(EShapeActionRuntimeMiscWrite));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWriteLocal = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWriteLocal, _super);
        function EShapeActionRuntimeMiscWriteLocal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscWriteLocal.prototype.write = function (shape, target, value, time) {
            EShapeActionRuntimes.write(shape, target, value, time, false);
        };
        return EShapeActionRuntimeMiscWriteLocal;
    }(EShapeActionRuntimeMiscWrite));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWriteRemote = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWriteRemote, _super);
        function EShapeActionRuntimeMiscWriteRemote() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscWriteRemote.prototype.write = function (shape, target, value, time) {
            EShapeActionRuntimes.write(shape, target, value, time, true);
        };
        return EShapeActionRuntimeMiscWriteRemote;
    }(EShapeActionRuntimeMiscWrite));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMisc = /** @class */ (function (_super) {
        __extends(EShapeActionValueMisc, _super);
        function EShapeActionValueMisc(subtype, condition, target, onInputAction, value) {
            var _this = _super.call(this, EShapeActionValueType.MISC, condition, subtype) || this;
            _this.target = target;
            _this.onInputAction = onInputAction;
            _this.value = value;
            return _this;
        }
        EShapeActionValueMisc.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueMiscType.INPUT_TEXT:
                    return new EShapeActionRuntimeMiscInputText(this);
                case EShapeActionValueMiscType.INPUT_INTEGER:
                    return new EShapeActionRuntimeMiscInputInteger(this);
                case EShapeActionValueMiscType.INPUT_REAL:
                    return new EShapeActionRuntimeMiscInputReal(this);
                case EShapeActionValueMiscType.EMIT_EVENT:
                    return new EShapeActionRuntimeMiscEmitEvent(this);
                case EShapeActionValueMiscType.WRITE_BOTH:
                    return new EShapeActionRuntimeMiscWriteBoth(this);
                case EShapeActionValueMiscType.WRITE_LOCAL:
                    return new EShapeActionRuntimeMiscWriteLocal(this);
                case EShapeActionValueMiscType.WRITE_REMOTE:
                    return new EShapeActionRuntimeMiscWriteRemote(this);
                case EShapeActionValueMiscType.HTML_ELEMENT:
                case EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                    return new EShapeActionRuntimeMiscHtmlElement(this);
            }
        };
        EShapeActionValueMisc.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var valueId = manager.addResource(this.value);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + targetId + "," + this.onInputAction + "," + valueId + "]");
        };
        EShapeActionValueMisc.deserialize = function (serialized, manager) {
            var resources = manager.resources;
            var condition = EShapeActionValues.toResource(1, serialized, resources);
            var target = EShapeActionValues.toResource(3, serialized, resources);
            var value = EShapeActionValues.toResource(5, serialized, resources);
            return new EShapeActionValueMisc(serialized[2], condition, target, serialized[4], value);
        };
        return EShapeActionValueMisc;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DButtonBase} option when to activate a button.
     */
    var DButtonBaseWhen;
    (function (DButtonBaseWhen) {
        /** Activates when clicked */
        DButtonBaseWhen[DButtonBaseWhen["CLICKED"] = 0] = "CLICKED";
        /** Activates when double clicked */
        DButtonBaseWhen[DButtonBaseWhen["DOUBLE_CLICKED"] = 1] = "DOUBLE_CLICKED";
    })(DButtonBaseWhen || (DButtonBaseWhen = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignHorizontal;
    (function (DAlignHorizontal) {
        DAlignHorizontal[DAlignHorizontal["LEFT"] = 0] = "LEFT";
        DAlignHorizontal[DAlignHorizontal["CENTER"] = 1] = "CENTER";
        DAlignHorizontal[DAlignHorizontal["RIGHT"] = 2] = "RIGHT";
    })(DAlignHorizontal || (DAlignHorizontal = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignVertical;
    (function (DAlignVertical) {
        DAlignVertical[DAlignVertical["TOP"] = 0] = "TOP";
        DAlignVertical[DAlignVertical["MIDDLE"] = 1] = "MIDDLE";
        DAlignVertical[DAlignVertical["BOTTOM"] = 2] = "BOTTOM";
    })(DAlignVertical || (DAlignVertical = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignWith;
    (function (DAlignWith) {
        DAlignWith[DAlignWith["TEXT"] = 0] = "TEXT";
        DAlignWith[DAlignWith["PADDING"] = 1] = "PADDING";
        DAlignWith[DAlignWith["BORDER"] = 2] = "BORDER";
    })(DAlignWith || (DAlignWith = {}));

    var DDynamicTextMeasureResultCharacter = /** @class */ (function () {
        function DDynamicTextMeasureResultCharacter(x, y, character) {
            this.x = x;
            this.y = y;
            this.character = character;
        }
        DDynamicTextMeasureResultCharacter.prototype.set = function (x, y, character) {
            this.x = x;
            this.y = y;
            this.character = character;
        };
        return DDynamicTextMeasureResultCharacter;
    }());

    var DDynamicTextMeasureResult = /** @class */ (function () {
        function DDynamicTextMeasureResult() {
            this.count = 0;
            this.width = 0;
            this.height = 0;
            this.characters = [];
            this.clipped = false;
            this.x = 0;
            this.y = 0;
        }
        DDynamicTextMeasureResult.prototype.start = function () {
            this.count = 0;
            this.width = 0;
            this.height = 0;
            this.clipped = false;
            this.x = 0;
            this.y = 0;
        };
        DDynamicTextMeasureResult.prototype.push = function (character) {
            var x = this.x;
            this.x += character.advance;
            var y = this.y;
            var count = this.count;
            var characters = this.characters;
            if (count < characters.length) {
                characters[count].set(x, y, character);
            }
            else {
                characters.push(new DDynamicTextMeasureResultCharacter(x, y, character));
            }
            this.count += 1;
        };
        DDynamicTextMeasureResult.prototype.newLine = function (lineHeight) {
            this.width = Math.max(this.width, this.x);
            this.x = 0;
            this.y += lineHeight;
        };
        DDynamicTextMeasureResult.prototype.pop = function () {
            if (0 < this.x) {
                var count = this.count;
                var characters = this.characters;
                if (0 < count) {
                    var character = characters[count - 1];
                    this.x -= character.character.advance;
                    this.count -= 1;
                    return true;
                }
            }
            return false;
        };
        DDynamicTextMeasureResult.prototype.end = function (lineHeight) {
            this.newLine(lineHeight);
            this.height = this.y;
        };
        return DDynamicTextMeasureResult;
    }());

    var DDynamicTextMeasure = /** @class */ (function () {
        function DDynamicTextMeasure() {
        }
        DDynamicTextMeasure.measure = function (text, atlas, clippingWidth) {
            var result = DDynamicTextMeasure.RESULT || new DDynamicTextMeasureResult();
            DDynamicTextMeasure.RESULT = result;
            result.start();
            if (atlas != null) {
                var iterator = UtilCharacterIterator.from(text);
                var lineHeight = atlas.font.height;
                var newLine = "\n";
                while (iterator.hasNext()) {
                    var character = iterator.next();
                    if (character === newLine) {
                        result.newLine(lineHeight);
                    }
                    else {
                        var a = atlas.get(character);
                        if (a != null) {
                            if (clippingWidth != null && clippingWidth < result.x + a.advance) {
                                result.clipped = true;
                                var dots = atlas.get("...");
                                if (dots != null) {
                                    while (clippingWidth - dots.advance < result.x) {
                                        if (!result.pop()) {
                                            break;
                                        }
                                    }
                                    if (result.x <= clippingWidth - dots.advance) {
                                        result.push(dots);
                                    }
                                }
                                while (iterator.hasNext()) {
                                    if (iterator.next() === newLine) {
                                        result.newLine(lineHeight);
                                        break;
                                    }
                                }
                            }
                            else {
                                result.push(a);
                            }
                        }
                    }
                }
                result.end(lineHeight);
            }
            return result;
        };
        DDynamicTextMeasure.RESULT = null;
        return DDynamicTextMeasure;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextGeometry = /** @class */ (function (_super) {
        __extends(DDynamicTextGeometry, _super);
        function DDynamicTextGeometry() {
            var _this = _super.call(this, new Float32Array(64), new Float32Array(64), new Uint16Array(48)) || this;
            _this.width = 0;
            _this.height = 0;
            _this.clipped = false;
            return _this;
        }
        DDynamicTextGeometry.prototype.update = function (text, atlas, clippingWidth) {
            var vertexBuffer = this.getBuffer("aVertexPosition");
            var uvBuffer = this.getBuffer("aTextureCoord");
            var indexBuffer = this.getIndex();
            var result = DDynamicTextMeasure.measure(text, atlas, clippingWidth);
            var requiredTextSize = Math.ceil(result.count / 8) << 3;
            var requiredVertexSize = requiredTextSize << 3;
            if (vertexBuffer.data.length < requiredVertexSize) {
                vertexBuffer.data = new Float32Array(requiredVertexSize);
                uvBuffer.data = new Float32Array(requiredVertexSize);
            }
            var requiredIndexSize = requiredTextSize * 6;
            if (indexBuffer.data.length < requiredIndexSize) {
                indexBuffer.data = new Uint16Array(requiredIndexSize);
            }
            var vertices = vertexBuffer.data;
            var uvs = uvBuffer.data;
            var indices = indexBuffer.data;
            if (atlas != null) {
                var count = result.count;
                var characters = result.characters;
                for (var i = 0; i < count; ++i) {
                    var character = characters[i];
                    var cx = character.x;
                    var cy = character.y;
                    var cc = character.character;
                    var w = atlas.width;
                    var h = atlas.height;
                    this.writeCharacter(vertices, uvs, indices, i, cx, cy, cc, w, h);
                }
                for (var i = count, imax = vertices.length >> 3; i < imax; ++i) {
                    this.writeCharacterEmpty(vertices, uvs, indices, i);
                }
                this.width = result.width;
                this.height = result.height;
                this.clipped = result.clipped;
            }
            else {
                for (var i = 0, imax = vertices.length >> 3; i < imax; ++i) {
                    this.writeCharacterEmpty(vertices, uvs, indices, i);
                }
                this.width = 0;
                this.height = 0;
                this.clipped = false;
            }
            vertexBuffer.update();
            uvBuffer.update();
            indexBuffer.update();
        };
        DDynamicTextGeometry.prototype.writeCharacter = function (vertices, uvs, indices, index, x, y, character, width, height) {
            var cx = character.x;
            var cy = character.y;
            var cw = character.width;
            var ch = character.height;
            var cox = character.origin.x;
            var x0 = x + (cx - cox);
            var y0 = y;
            var x1 = x0 + cw;
            var y1 = y0 + ch;
            var iv = index << 3;
            vertices[iv + 0] = x0;
            vertices[iv + 1] = y0;
            vertices[iv + 2] = x1;
            vertices[iv + 3] = y0;
            vertices[iv + 4] = x1;
            vertices[iv + 5] = y1;
            vertices[iv + 6] = x0;
            vertices[iv + 7] = y1;
            var u0 = cx / width;
            var v0 = cy / height;
            var u1 = (cx + cw) / width;
            var v1 = (cy + ch) / height;
            uvs[iv + 0] = u0;
            uvs[iv + 1] = v0;
            uvs[iv + 2] = u1;
            uvs[iv + 3] = v0;
            uvs[iv + 4] = u1;
            uvs[iv + 5] = v1;
            uvs[iv + 6] = u0;
            uvs[iv + 7] = v1;
            var ii = index * 6;
            var vo = index << 2;
            indices[ii + 0] = vo + 0;
            indices[ii + 1] = vo + 1;
            indices[ii + 2] = vo + 3;
            indices[ii + 3] = vo + 1;
            indices[ii + 4] = vo + 2;
            indices[ii + 5] = vo + 3;
        };
        DDynamicTextGeometry.prototype.writeCharacterEmpty = function (vertices, uvs, indices, index) {
            var iv = index << 3;
            vertices[iv + 0] = 0;
            vertices[iv + 1] = 0;
            vertices[iv + 2] = 0;
            vertices[iv + 3] = 0;
            vertices[iv + 4] = 0;
            vertices[iv + 5] = 0;
            vertices[iv + 6] = 0;
            vertices[iv + 7] = 0;
            uvs[iv + 0] = 0;
            uvs[iv + 1] = 0;
            uvs[iv + 2] = 0;
            uvs[iv + 3] = 0;
            uvs[iv + 4] = 0;
            uvs[iv + 5] = 0;
            uvs[iv + 6] = 0;
            uvs[iv + 7] = 0;
            var ii = index * 6;
            var vo = index << 2;
            indices[ii + 0] = vo + 0;
            indices[ii + 1] = vo + 1;
            indices[ii + 2] = vo + 3;
            indices[ii + 3] = vo + 1;
            indices[ii + 4] = vo + 2;
            indices[ii + 5] = vo + 3;
        };
        return DDynamicTextGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextStyle = /** @class */ (function () {
        function DDynamicTextStyle(options, onChange) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            this._id = 0;
            this._idApproved = -1;
            var defaultOptions = this.getDefaultOptions();
            if (options) {
                this._align = (_a = options.align) !== null && _a !== void 0 ? _a : defaultOptions.align;
                this._fontFamily = (_b = options.fontFamily) !== null && _b !== void 0 ? _b : defaultOptions.fontFamily;
                this._fontSize = (_c = options.fontSize) !== null && _c !== void 0 ? _c : defaultOptions.fontSize;
                this._fontStyle = (_d = options.fontStyle) !== null && _d !== void 0 ? _d : defaultOptions.fontStyle;
                this._fontVariant = (_e = options.fontVariant) !== null && _e !== void 0 ? _e : defaultOptions.fontVariant;
                this._fontWeight = (_f = options.fontWeight) !== null && _f !== void 0 ? _f : defaultOptions.fontWeight;
                this._fill = (_g = options.fill) !== null && _g !== void 0 ? _g : defaultOptions.fill;
                this._clipping = (_h = options.clipping) !== null && _h !== void 0 ? _h : defaultOptions.clipping;
            }
            else {
                this._align = defaultOptions.align;
                this._fontFamily = defaultOptions.fontFamily;
                this._fontSize = defaultOptions.fontSize;
                this._fontStyle = defaultOptions.fontStyle;
                this._fontVariant = defaultOptions.fontVariant;
                this._fontWeight = defaultOptions.fontWeight;
                this._fill = defaultOptions.fill;
                this._clipping = defaultOptions.clipping;
            }
            this._fontIdId = -1;
            this._fontId = "";
            this._fontIdApproved = "";
            this._fillApproved = 0x000000;
            this._onChange = onChange;
        }
        DDynamicTextStyle.prototype.getDefaultOptions = function () {
            var result = DDynamicTextStyle.DEFAULT_OPTIONS;
            if (result == null) {
                var theme = DThemes.getInstance().get("DBase");
                result = {
                    align: "left",
                    fontFamily: theme.getFontFamilly(),
                    fontSize: theme.getFontSize(),
                    fontStyle: "normal",
                    fontVariant: "normal",
                    fontWeight: "normal",
                    fill: theme.getColor(new DBaseStateSetImpl()),
                    clipping: true
                };
                DDynamicTextStyle.DEFAULT_OPTIONS = result;
            }
            return result;
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "idApproved", {
            get: function () {
                return this._idApproved;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontId", {
            get: function () {
                this.update();
                return this._fontId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontIdApproved", {
            get: function () {
                return this._fontIdApproved;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            set: function (fill) {
                if (this._fill !== fill) {
                    this._fill = fill;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.onChange = function () {
            this._id += 1;
            this._onChange();
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "fillApproved", {
            get: function () {
                return this._fillApproved;
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.approve = function () {
            this.update();
            this._idApproved = this._id;
            this._fontIdApproved = this._fontId;
            this._fillApproved = this._fill;
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "fontFamily", {
            get: function () {
                return this._fontFamily;
            },
            set: function (fontFamily) {
                if (this._fontFamily !== fontFamily) {
                    this._fontFamily = fontFamily;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontSize", {
            get: function () {
                return this._fontSize;
            },
            set: function (fontSize) {
                if (this._fontSize !== fontSize) {
                    this._fontSize = fontSize;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontStyle", {
            get: function () {
                return this._fontStyle;
            },
            set: function (fontStyle) {
                if (this._fontStyle !== fontStyle) {
                    this._fontStyle = fontStyle;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontVariant", {
            get: function () {
                return this._fontVariant;
            },
            set: function (fontVariant) {
                if (this._fontVariant !== fontVariant) {
                    this._fontVariant = fontVariant;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontWeight", {
            get: function () {
                return this._fontWeight;
            },
            set: function (fontWeight) {
                if (this._fontWeight !== fontWeight) {
                    this._fontWeight = fontWeight;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.update = function () {
            if (this._fontIdId !== this._id) {
                this._fontIdId = this._id;
                this._fontId = this.newFontId();
            }
        };
        DDynamicTextStyle.prototype.newFontId = function () {
            return this._fontStyle + " " + this._fontVariant + " " + this._fontWeight + " " + this._fontSize + "px " + this._fontFamily;
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "clipping", {
            get: function () {
                return this._clipping;
            },
            set: function (clipping) {
                if (this._clipping !== clipping) {
                    this._clipping = clipping;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        return DDynamicTextStyle;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicText = /** @class */ (function (_super) {
        __extends(DDynamicText, _super);
        function DDynamicText(text, options) {
            var _this = _super.call(this, new DDynamicTextGeometry(), new pixi_js.MeshMaterial(pixi_js.Texture.EMPTY)) || this;
            _this._style = new DDynamicTextStyle(options, function () {
                _this._isDirty = true;
                _this._isGeometryDirty = true;
                _this._atlas = null;
                _this.update_();
            });
            _this._text = text;
            _this._textApproved = "";
            _this._isDirty = true;
            _this._isGeometryDirty = true;
            _this._atlas = null;
            _this._atlasRevisionUpdated = 0;
            _this._width = 0;
            _this._height = 0;
            _this._clippingWidthDelta = 0;
            _this.update_();
            return _this;
        }
        DDynamicText.prototype.update_ = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var style = this._style;
                if (this._isDirty) {
                    this._isDirty = false;
                    var text = this._text;
                    var textApproved = this._textApproved;
                    this._textApproved = text;
                    var fontId = style.fontId;
                    var fontIdApproved = style.fontIdApproved;
                    var fontSize = style.fontSize;
                    var fill = style.fill;
                    var fillApproved = style.fillApproved;
                    style.approve();
                    var atlases = layer.getDynamicFontAtlases();
                    if (text !== textApproved || fontId !== fontIdApproved || fill !== fillApproved) {
                        atlases.add(fontId, fontSize, fill, text);
                        atlases.remove(fontIdApproved, fillApproved, textApproved);
                    }
                }
            }
        };
        Object.defineProperty(DDynamicText.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                if (this._text !== text) {
                    this._text = text;
                    this._isDirty = true;
                    this._isGeometryDirty = true;
                    this.update_();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "width", {
            // @ts-ignore
            get: function () {
                this.update();
                return Math.abs(this.scale.x) * this.geometry.width;
            },
            set: function (width) {
                this.update();
                var geometryWidth = this.geometry.width;
                if (+1e-4 < geometryWidth) {
                    var newScale = width / geometryWidth;
                    this.scale.x = 0 <= this.scale.x ? +newScale : -newScale;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "height", {
            // @ts-ignore
            get: function () {
                this.update();
                return Math.abs(this.scale.y) * this.geometry.height;
            },
            set: function (height) {
                this.update();
                var geometryHeight = this.geometry.height;
                if (+1e-4 < geometryHeight) {
                    var newScale = height / geometryHeight;
                    this.scale.y = 0 <= this.scale.y ? +newScale : -newScale;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "clipped", {
            get: function () {
                return this.geometry.clipped;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "style", {
            get: function () {
                return this._style;
            },
            enumerable: false,
            configurable: true
        });
        DDynamicText.prototype.update = function () {
            this.update_();
            var atlas = this._atlas;
            if (atlas == null) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var style = this._style;
                    atlas = layer.getDynamicFontAtlases().get(style.fontId, style.fill);
                    if (atlas != null) {
                        this._atlasRevisionUpdated = atlas.getRevisionUpdate();
                        this._atlas = atlas;
                        this.texture = atlas.texture;
                        this._isGeometryDirty = true;
                    }
                }
            }
            else {
                var revisionUpdate = atlas.getRevisionUpdate();
                if (revisionUpdate !== this._atlasRevisionUpdated) {
                    this._atlasRevisionUpdated = revisionUpdate;
                    this._isGeometryDirty = true;
                }
            }
            var clippingWidth = this._clippingWidth;
            var newClippingWidth = this.getClippingWidth();
            if (clippingWidth !== newClippingWidth) {
                this._clippingWidth = newClippingWidth;
                this._isGeometryDirty = true;
            }
            if (this._isGeometryDirty) {
                this._isGeometryDirty = false;
                this.geometry.update(this._text, atlas, newClippingWidth);
            }
        };
        DDynamicText.prototype.getClippingWidth = function () {
            if (this._style.clipping) {
                var parent_1 = this.parent;
                if (parent_1 instanceof DBase) {
                    return (parent_1.width -
                        parent_1.padding.getLeft() -
                        parent_1.padding.getRight() -
                        this._clippingWidthDelta);
                }
            }
            return undefined;
        };
        DDynamicText.prototype.setClippingWidthDelta = function (width) {
            this._clippingWidthDelta = width;
        };
        DDynamicText.prototype._calculateBounds = function () {
            this.update();
            _super.prototype._calculateBounds.call(this);
        };
        DDynamicText.prototype._render = function (renderer) {
            this.update();
            _super.prototype._render.call(this, renderer);
        };
        return DDynamicText;
    }(pixi_js.Mesh));

    var DImageBaseThemeWrapperSecondary = /** @class */ (function () {
        function DImageBaseThemeWrapperSecondary(theme) {
            this._theme = theme;
        }
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignHorizontal = function () {
            return this._theme.getSecondaryImageAlignHorizontal();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignVertical = function () {
            return this._theme.getSecondaryImageAlignVertical();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignWith = function () {
            return this._theme.getSecondaryImageAlignWith();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageMarginHorizontal = function () {
            return this._theme.getSecondaryImageMarginHorizontal();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageMarginVertial = function () {
            return this._theme.getSecondaryImageMarginVertial();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageTintColor = function (state) {
            return this._theme.getSecondaryImageTintColor(state);
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageTintAlpha = function (state) {
            return this._theme.getSecondaryImageTintAlpha(state);
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageSource = function (state) {
            return this._theme.getSecondaryImageSource(state);
        };
        return DImageBaseThemeWrapperSecondary;
    }());

    var DImageBaseThemeWrapperTertiary = /** @class */ (function () {
        function DImageBaseThemeWrapperTertiary(theme) {
            this._theme = theme;
        }
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignHorizontal = function () {
            return this._theme.getTertiaryImageAlignHorizontal();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignVertical = function () {
            return this._theme.getTertiaryImageAlignVertical();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignWith = function () {
            return this._theme.getTertiaryImageAlignWith();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageMarginHorizontal = function () {
            return this._theme.getTertiaryImageMarginHorizontal();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageMarginVertial = function () {
            return this._theme.getTertiaryImageMarginVertial();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageTintColor = function (state) {
            return this._theme.getTertiaryImageTintColor(state);
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageTintAlpha = function (state) {
            return this._theme.getTertiaryImageTintAlpha(state);
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageSource = function (state) {
            return this._theme.getTertiaryImageSource(state);
        };
        return DImageBaseThemeWrapperTertiary;
    }());

    var toImageAlign = function (theme, options) {
        var _a, _b, _c;
        var align = options === null || options === void 0 ? void 0 : options.align;
        return {
            with: toEnum((_a = align === null || align === void 0 ? void 0 : align.with) !== null && _a !== void 0 ? _a : theme.getImageAlignWith(), DAlignWith),
            vertical: toEnum((_b = align === null || align === void 0 ? void 0 : align.vertical) !== null && _b !== void 0 ? _b : theme.getImageAlignVertical(), DAlignVertical),
            horizontal: toEnum((_c = align === null || align === void 0 ? void 0 : align.horizontal) !== null && _c !== void 0 ? _c : theme.getImageAlignHorizontal(), DAlignHorizontal)
        };
    };
    var toImageMargin = function (theme, options) {
        var _a, _b;
        var margin = options === null || options === void 0 ? void 0 : options.margin;
        return {
            vertical: (_a = margin === null || margin === void 0 ? void 0 : margin.vertical) !== null && _a !== void 0 ? _a : theme.getImageMarginVertial(),
            horizontal: (_b = margin === null || margin === void 0 ? void 0 : margin.horizontal) !== null && _b !== void 0 ? _b : theme.getImageMarginHorizontal()
        };
    };
    var DImagePiece = /** @class */ (function () {
        function DImagePiece(parent, theme, textAlign, options) {
            var _this = this;
            this._parent = parent;
            this._theme = theme;
            this._textAlign = textAlign;
            this._image = null;
            this._align = toImageAlign(theme, options);
            this._margin = toImageMargin(theme, options);
            this._tint = options === null || options === void 0 ? void 0 : options.tint;
            this._bound = new pixi_js.Rectangle();
            this._source = options === null || options === void 0 ? void 0 : options.source;
            this._computed = null;
            this._onUpdateBound = function () {
                _this.onUpdate();
            };
        }
        Object.defineProperty(DImagePiece.prototype, "image", {
            get: function () {
                return this._image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "align", {
            get: function () {
                return this._align;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "bound", {
            get: function () {
                return this._bound;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "source", {
            get: function () {
                return this._source;
            },
            set: function (source) {
                if (this._source !== source) {
                    this._source = source;
                    this.onUpdate();
                }
            },
            enumerable: false,
            configurable: true
        });
        DImagePiece.prototype.computeSource = function () {
            var source = this._source;
            if (source !== undefined) {
                if (isFunction(source)) {
                    var result = source(this._parent.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return source;
                }
            }
            return this._theme.getImageSource(this._parent.state);
        };
        DImagePiece.prototype.onStateChange = function (newState, oldState) {
            this.updateTint();
        };
        DImagePiece.prototype.updateBound = function () {
            var bound = this._bound;
            var image = this._image;
            if (image != null) {
                image.updateTransform();
                image.getLocalBounds(bound);
                var bl = bound.left;
                var bt = bound.top;
                var br = bound.right;
                var bb = bound.bottom;
                var localTransform = image.localTransform;
                var a = localTransform.a;
                var b = localTransform.b;
                var c = localTransform.c;
                var d = localTransform.d;
                var x0 = a * bl + c * bt;
                var y0 = b * bl + d * bt;
                var x1 = a * br + c * bt;
                var y1 = b * br + d * bt;
                var x2 = a * br + c * bb;
                var y2 = b * br + d * bb;
                var x3 = a * bl + c * bb;
                var y3 = b * bl + d * bb;
                var xmin = Math.min(x0, x1, x2, x3);
                var xmax = Math.max(x0, x1, x2, x3);
                var ymin = Math.min(y0, y1, y2, y3);
                var ymax = Math.max(y0, y1, y2, y3);
                bound.x = xmin + localTransform.tx;
                bound.y = ymin + localTransform.ty;
                bound.width = xmax - xmin;
                bound.height = ymax - ymin;
            }
            else {
                bound.x = 0;
                bound.y = 0;
                bound.width = 0;
                bound.height = 0;
            }
        };
        DImagePiece.prototype.isTintAware = function (target) {
            return target != null && "tint" in target;
        };
        DImagePiece.prototype.toTintColor = function (theme, state) {
            var tint = this._tint;
            if (tint) {
                var color = tint.color;
                if (color !== undefined) {
                    if (isFunction(color)) {
                        var result = color(state);
                        if (result !== undefined) {
                            return result;
                        }
                    }
                    else {
                        return color;
                    }
                }
            }
            return theme.getImageTintColor(state);
        };
        DImagePiece.prototype.toTintAlpha = function (theme, state) {
            var tint = this._tint;
            if (tint) {
                var alpha = tint.alpha;
                if (alpha !== undefined) {
                    if (isFunction(alpha)) {
                        var result = alpha(state);
                        if (result !== undefined) {
                            return result;
                        }
                    }
                    else {
                        return alpha;
                    }
                }
            }
            return theme.getImageTintAlpha(state);
        };
        /**
         * Updates the tint.
         *
         * @returns True if the tint is changed.
         */
        DImagePiece.prototype.updateTint = function () {
            var image = this._image;
            if (image) {
                if (this.isTintAware(image)) {
                    var theme = this._theme;
                    var state = this._parent.state;
                    var color = this.toTintColor(theme, state);
                    if (color != null) {
                        var result = false;
                        if (image.tint !== color) {
                            image.tint = color;
                            result = true;
                        }
                        var alpha = this.toTintAlpha(theme, state);
                        if (image.alpha !== alpha) {
                            image.alpha = alpha;
                            result = true;
                        }
                        return result;
                    }
                }
            }
            return false;
        };
        /**
         * Updates the computed source.
         *
         * @returns True if the computed source is changed
         */
        DImagePiece.prototype.updateSource = function () {
            var newComputed = this.computeSource();
            var oldComputed = this._computed;
            if (newComputed !== oldComputed) {
                this._computed = newComputed;
                var parent_1 = this._parent;
                var oldImage = this._image;
                var onUpdateBound = this._onUpdateBound;
                if (newComputed instanceof pixi_js.Texture) {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", onUpdateBound);
                        if (oldImage instanceof pixi_js.Sprite) {
                            oldImage.texture = newComputed;
                            newComputed.on("update", onUpdateBound);
                        }
                    }
                    else {
                        if (oldImage != null) {
                            parent_1.removeChild(oldImage);
                        }
                        var newImage = new pixi_js.Sprite(newComputed);
                        var overflowMask = parent_1.getOverflowMask();
                        if (overflowMask) {
                            newImage.mask = overflowMask;
                        }
                        newComputed.on("update", onUpdateBound);
                        parent_1.addChild(newImage);
                        this._image = newImage;
                    }
                }
                else {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", onUpdateBound);
                        if (oldImage != null) {
                            parent_1.removeChild(oldImage);
                            oldImage.destroy();
                        }
                    }
                    else if (oldImage != null) {
                        parent_1.removeChild(oldImage);
                    }
                    if (newComputed != null) {
                        var overflowMask = parent_1.getOverflowMask();
                        if (overflowMask) {
                            newComputed.mask = overflowMask;
                        }
                        parent_1.addChild(newComputed);
                    }
                    this._image = newComputed;
                }
                return true;
            }
            return false;
        };
        DImagePiece.prototype.isRefitable = function (target) {
            return target != null && target === this._image;
        };
        DImagePiece.prototype.destroy = function () {
            var image = this._image;
            if (image) {
                this._image = null;
                var computed = this._computed;
                if (computed instanceof pixi_js.Texture) {
                    computed.off("update", this._onUpdateBound, this);
                    image.destroy();
                }
            }
        };
        DImagePiece.prototype.onUpdate = function () {
            this._parent.toDirty();
            DApplications.update(this._parent);
        };
        return DImagePiece;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOverflowMaskSimple = /** @class */ (function (_super) {
        __extends(DBaseOverflowMaskSimple, _super);
        function DBaseOverflowMaskSimple(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            return _this;
        }
        DBaseOverflowMaskSimple.prototype.render = function (renderer) {
            this.updateTransform();
            _super.prototype.render.call(this, renderer);
        };
        DBaseOverflowMaskSimple.prototype.onReflow = function (base, width, height) {
            this.clear();
            this.beginFill(0xffffff, 1);
            this.drawRect(0, 0, width, height);
            this.endFill();
        };
        return DBaseOverflowMaskSimple;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toTextStyle = function (theme, options, state) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var style = (_a = options === null || options === void 0 ? void 0 : options.text) === null || _a === void 0 ? void 0 : _a.style;
        if (style != null) {
            var fill = (_b = style.fill) !== null && _b !== void 0 ? _b : theme.getColor(state);
            var fontSize = (_c = style.fontSize) !== null && _c !== void 0 ? _c : theme.getFontSize();
            var fontFamily = (_d = style.fontFamily) !== null && _d !== void 0 ? _d : theme.getFontFamilly();
            var fontWeight = (_e = style.fontWeight) !== null && _e !== void 0 ? _e : theme.getFontWeight();
            var fontStyle = (_f = style.fontStyle) !== null && _f !== void 0 ? _f : theme.getFontStyle();
            var fontVariant = (_g = style.fontVariant) !== null && _g !== void 0 ? _g : theme.getFontVariant();
            var clipping = (_h = style.clipping) !== null && _h !== void 0 ? _h : theme.getTextStyleClipping();
            return {
                fill: fill,
                fontSize: fontSize,
                fontFamily: fontFamily,
                fontWeight: fontWeight,
                fontStyle: fontStyle,
                fontVariant: fontVariant,
                clipping: clipping
            };
        }
        return {
            fill: theme.getColor(state),
            fontSize: theme.getFontSize(),
            fontFamily: theme.getFontFamilly(),
            fontWeight: theme.getFontWeight(),
            fontStyle: theme.getFontStyle(),
            fontVariant: theme.getFontVariant(),
            clipping: theme.getTextStyleClipping()
        };
    };
    var toTextAlign = function (theme, options) {
        var _a, _b, _c;
        var align = (_a = options === null || options === void 0 ? void 0 : options.text) === null || _a === void 0 ? void 0 : _a.align;
        return {
            vertical: toEnum((_b = align === null || align === void 0 ? void 0 : align.vertical) !== null && _b !== void 0 ? _b : theme.getTextAlignVertical(), DAlignVertical),
            horizontal: toEnum((_c = align === null || align === void 0 ? void 0 : align.horizontal) !== null && _c !== void 0 ? _c : theme.getTextAlignHorizontal(), DAlignHorizontal)
        };
    };
    /**
     * A base class for UI classes with a text support.
     * See {@link DTextBaseEvents} for event defaults.
     */
    var DTextBase = /** @class */ (function (_super) {
        __extends(DTextBase, _super);
        function DTextBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTextBase.prototype.init = function (options) {
            var _a, _b, _c, _d, _e;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._textValue = (_b = (_a = options === null || options === void 0 ? void 0 : options.text) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : theme.newTextValue();
            this._textValueComputed = this.computeTextValue();
            var text = options === null || options === void 0 ? void 0 : options.text;
            this._textColor = text === null || text === void 0 ? void 0 : text.color;
            this._textAlpha = text === null || text === void 0 ? void 0 : text.alpha;
            this._textStyle = toTextStyle(theme, options, this.state);
            this._textAlign = toTextAlign(theme, options);
            this._textFormatter = (_c = text === null || text === void 0 ? void 0 : text.formatter) !== null && _c !== void 0 ? _c : theme.getTextFormatter();
            this._isTextDynamic = (_d = text === null || text === void 0 ? void 0 : text.dynamic) !== null && _d !== void 0 ? _d : theme.isTextDynamic();
            this._isTextVisible = true;
            this._isOverflowMaskEnabled = (_e = options === null || options === void 0 ? void 0 : options.mask) !== null && _e !== void 0 ? _e : theme.isOverflowMaskEnabled();
            this.onTextChange();
            this.createOrUpdateText();
        };
        Object.defineProperty(DTextBase.prototype, "text", {
            get: function () {
                return this._textValue;
            },
            set: function (text) {
                if (this._textValue !== text) {
                    this._textValue = text;
                    this.updateTextValue();
                }
            },
            enumerable: false,
            configurable: true
        });
        DTextBase.prototype.onTextChange = function () {
            // DO NOTHING
        };
        DTextBase.prototype.computeTextValue = function () {
            var textValue = this._textValue;
            if (textValue !== undefined) {
                if (isFunction(textValue)) {
                    var result = textValue(this.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return textValue;
                }
            }
            return this.theme.getTextValue(this.state);
        };
        DTextBase.prototype.createOrUpdateText = function () {
            var textValueComputed = this._textValueComputed;
            if (textValueComputed !== undefined) {
                var formatted = this._textFormatter(textValueComputed, this);
                var text = this._text;
                if (text == null) {
                    if (0 < formatted.length) {
                        var newText = this.createText(formatted);
                        newText.visible = this._isTextVisible;
                        this._text = newText;
                        this.addChild(newText);
                        this.updateTextPosition(newText);
                        var overflowMask = this.getOverflowMask();
                        if (overflowMask) {
                            newText.mask = overflowMask;
                        }
                        this.toDirty();
                        DApplications.update(this);
                    }
                }
                else {
                    text.text = formatted;
                    this.toDirty();
                    DApplications.update(this);
                }
            }
        };
        DTextBase.prototype.createText = function (formatted) {
            if (this._isTextDynamic) {
                return new DDynamicText(formatted, this._textStyle);
            }
            else {
                var result = new pixi_js.Text(formatted, this._textStyle);
                result.texture.baseTexture.scaleMode = pixi_js.SCALE_MODES.NEAREST;
                result.resolution = DApplications.getResolution(this);
                return result;
            }
        };
        DTextBase.prototype.getOverflowMask = function () {
            if (this._isOverflowMaskEnabled) {
                if (this._overflowMask == null) {
                    this._overflowMask = new DBaseOverflowMaskSimple(this);
                    this._reflowable.add(this._overflowMask);
                    this.toDirty();
                }
                return this._overflowMask;
            }
            return null;
        };
        DTextBase.prototype.updateTextPosition = function (text) {
            var align = this._textAlign;
            var padding = this._padding;
            var toRounded = this.toRounded;
            switch (align.horizontal) {
                case DAlignHorizontal.LEFT:
                    text.x = toRounded(padding.getLeft());
                    break;
                case DAlignHorizontal.CENTER:
                    text.x = toRounded((this.width - text.width) * 0.5);
                    break;
                case DAlignHorizontal.RIGHT:
                    text.x = toRounded(this.width - text.width - padding.getRight());
                    break;
            }
            switch (align.vertical) {
                case DAlignVertical.TOP:
                    text.y = toRounded(padding.getTop());
                    break;
                case DAlignVertical.MIDDLE:
                    text.y = toRounded((this.height - text.height) * 0.5);
                    break;
                case DAlignVertical.BOTTOM:
                    text.y = toRounded(this.height - text.height - padding.getBottom());
                    break;
            }
        };
        DTextBase.prototype.toRounded = function (value) {
            return Math.round(value);
        };
        DTextBase.prototype.getTextColor = function (theme, state) {
            var color = this._textColor;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return theme.getColor(state);
        };
        DTextBase.prototype.getTextAlpha = function (theme, state) {
            var alpha = this._textAlpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return theme.getAlpha(state);
        };
        DTextBase.prototype.updateTextColor = function (text) {
            var theme = this.theme;
            var state = this.state;
            text.style.fill = this.getTextColor(theme, state);
            text.alpha = this.getTextAlpha(theme, state);
        };
        DTextBase.prototype.updateTextValue = function () {
            var newTextValueComputed = this.computeTextValue();
            if (this._textValueComputed !== newTextValueComputed) {
                this._textValueComputed = newTextValueComputed;
                this.onTextChange();
                this.createOrUpdateText();
            }
        };
        DTextBase.prototype.updateText = function () {
            var text = this._text;
            if (text) {
                this.updateTextValue();
                this.updateTextPosition(text);
                this.updateTextColor(text);
            }
        };
        DTextBase.prototype.showText = function () {
            var text = this._text;
            if (text) {
                text.visible = true;
            }
            this._isTextVisible = true;
        };
        DTextBase.prototype.hideText = function () {
            var text = this._text;
            if (text) {
                text.visible = false;
            }
            this._isTextVisible = false;
        };
        DTextBase.prototype.onReflow = function () {
            _super.prototype.onReflow.call(this);
            this.updateText();
        };
        DTextBase.prototype.isRefitable = function (target) {
            return _super.prototype.isRefitable.call(this, target) || (target != null && target === this._text);
        };
        DTextBase.prototype.applyTitle = function () {
            var text = this._text;
            if (this._title.length <= 0 && text && "clipped" in text && text.clipped) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.view.title = text.text;
                }
            }
            else {
                _super.prototype.applyTitle.call(this);
            }
        };
        DTextBase.prototype.getType = function () {
            return "DTextBase";
        };
        DTextBase.prototype.destroy = function () {
            // Text
            var text = this._text;
            if (text) {
                this._text = null;
                text.destroy();
            }
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DTextBase;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hasSecondaryImageSource = function (theme) {
        return !!theme.getSecondaryImageSource;
    };
    var hasTertiaryImageSource = function (theme) {
        return !!theme.getTertiaryImageSource;
    };
    /**
     * A base class for UI classes with an image support.
     * See {@link DImageBaseEvents} for event details.
     */
    var DImageBase = /** @class */ (function (_super) {
        __extends(DImageBase, _super);
        function DImageBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImageBase.prototype.init = function (options) {
            this._images = this.newImages(this.theme, options);
            _super.prototype.init.call(this, options);
        };
        DImageBase.prototype.newImages = function (theme, options) {
            var images = [];
            images.push(this.newImage(theme, this.toImageOptions(theme, options === null || options === void 0 ? void 0 : options.image)));
            if (hasSecondaryImageSource(theme)) {
                images.push(this.newImage(new DImageBaseThemeWrapperSecondary(theme)));
            }
            if (hasTertiaryImageSource(theme)) {
                images.push(this.newImage(new DImageBaseThemeWrapperTertiary(theme)));
            }
            return images;
        };
        DImageBase.prototype.toImageOptions = function (theme, options) {
            return options;
        };
        DImageBase.prototype.newImage = function (theme, options) {
            return new DImagePiece(this, theme, this._textAlign, options);
        };
        Object.defineProperty(DImageBase.prototype, "image", {
            get: function () {
                return this._images[0].source;
            },
            set: function (imageSource) {
                this._images[0].source = imageSource;
            },
            enumerable: false,
            configurable: true
        });
        DImageBase.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            var images = this._images;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                images[i].onStateChange(newState, oldState);
            }
        };
        DImageBase.prototype.updateText = function () {
            this.updateTextValue();
            this.updateTextAndImage();
        };
        DImageBase.prototype.updateTextAndImage = function () {
            var text = this._text;
            var images = this._images;
            var padding = this._padding;
            var toRounded = this.toRounded;
            var width = this.width;
            var height = this.height;
            var pl = padding.getLeft();
            var pr = padding.getRight();
            var pt = padding.getTop();
            var pb = padding.getBottom();
            var noText = text == null;
            var textLeftFirst = noText;
            var textTopFirst = noText;
            var textRightLastMargin = 0;
            var textBottomLastMargin = 0;
            var textLeft = 0;
            var textRight = 0;
            var textTop = 0;
            var textBottom = 0;
            var paddingLeft = pl;
            var paddingRight = width - pr;
            var paddingTop = pt;
            var paddingBottom = height - pb;
            var borderLeft = 0;
            var borderRight = width;
            var borderTop = 0;
            var borderBottom = height;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                var image = images[i];
                image.updateSource();
                image.updateTint();
                image.updateBound();
                var imageImage = image.image;
                if (imageImage) {
                    var imageBound = image.bound;
                    var imageBoundWidth = imageBound.width;
                    var imageBoundHeight = imageBound.height;
                    var imageMargin = image.margin;
                    var imageMarginHorizontal = imageMargin.horizontal;
                    var imageMarginVertical = imageMargin.vertical;
                    // Text
                    if (image.align.with === DAlignWith.TEXT) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.LEFT:
                                imageImage.x = textLeft;
                                textLeft += imageBoundWidth;
                                if (textLeftFirst) {
                                    textLeftFirst = false;
                                }
                                else {
                                    textLeft += imageMarginHorizontal;
                                }
                                break;
                            case DAlignHorizontal.CENTER:
                                // DO NOTHING
                                break;
                            case DAlignHorizontal.RIGHT:
                                textRight -= imageBoundWidth;
                                imageImage.x = textRight;
                                textRight -= imageMarginHorizontal;
                                textRightLastMargin = imageMarginHorizontal;
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.TOP:
                                imageImage.y = textTop;
                                textTop += imageBoundHeight;
                                if (textTopFirst) {
                                    textTopFirst = false;
                                }
                                else {
                                    textTop += imageMarginVertical;
                                }
                                break;
                            case DAlignVertical.MIDDLE:
                                // DO NOTHING
                                break;
                            case DAlignVertical.BOTTOM:
                                textBottom -= imageBoundHeight;
                                imageImage.y = textBottom;
                                textBottom -= imageMarginVertical;
                                textBottomLastMargin = imageMarginVertical;
                                break;
                        }
                    }
                    // Padding
                    if (image.align.with === DAlignWith.PADDING) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.LEFT:
                                paddingLeft += imageMarginHorizontal;
                                imageImage.x = toRounded(paddingLeft);
                                paddingLeft += imageBoundWidth;
                                break;
                            case DAlignHorizontal.CENTER:
                                // DO NOTHING
                                break;
                            case DAlignHorizontal.RIGHT:
                                paddingRight -= imageBoundWidth + imageMarginHorizontal;
                                imageImage.x = toRounded(paddingRight);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.TOP:
                                paddingTop += imageMarginVertical;
                                imageImage.y = toRounded(paddingTop);
                                paddingTop += imageBoundHeight;
                                break;
                            case DAlignVertical.MIDDLE:
                                // DO NOTHING
                                break;
                            case DAlignVertical.BOTTOM:
                                paddingBottom -= imageBoundHeight + imageMarginVertical;
                                imageImage.y = toRounded(paddingBottom);
                                break;
                        }
                    }
                    // Border
                    if (image.align.with === DAlignWith.BORDER) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.LEFT:
                                borderLeft += imageMarginHorizontal;
                                imageImage.x = toRounded(borderLeft);
                                borderLeft += imageBoundWidth;
                                break;
                            case DAlignHorizontal.CENTER:
                                // DO NOTHING
                                break;
                            case DAlignHorizontal.RIGHT:
                                borderRight -= imageBoundWidth + imageMarginHorizontal;
                                imageImage.x = toRounded(borderRight);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.TOP:
                                borderTop += imageMarginVertical;
                                imageImage.y = toRounded(borderTop);
                                borderTop += imageBoundHeight;
                                break;
                            case DAlignVertical.MIDDLE:
                                // DO NOTHING
                                break;
                            case DAlignVertical.BOTTOM:
                                borderBottom -= imageBoundHeight + imageMarginVertical;
                                imageImage.y = toRounded(borderBottom);
                                break;
                        }
                    }
                }
            }
            if (noText) {
                textRight += textRightLastMargin;
                textBottom += textBottomLastMargin;
            }
            // Text
            var textLeftAdjust = 0;
            var textCenterAdjust = 0;
            var textRightAdjust = 0;
            var textTopAdjust = 0;
            var textMiddleAdjust = 0;
            var textBottomAdjust = 0;
            if (text != null) {
                this.updateTextColor(text);
                if (text instanceof DDynamicText) {
                    text.setClippingWidthDelta(textLeft - textRight);
                }
                var textAlign = this._textAlign;
                var textWidth = text.width;
                var textHeight = text.height;
                switch (textAlign.horizontal) {
                    case DAlignHorizontal.LEFT:
                        textLeftAdjust = pl;
                        textRightAdjust = textLeftAdjust + textLeft + textWidth - textRight;
                        break;
                    case DAlignHorizontal.CENTER:
                        textLeftAdjust = (width - textLeft + textRight - textWidth) * 0.5;
                        textRightAdjust = textLeftAdjust + textLeft + textWidth - textRight;
                        break;
                    case DAlignHorizontal.RIGHT:
                        textRightAdjust = width - pr;
                        textLeftAdjust = textRightAdjust + textRight - textWidth - textLeft;
                        break;
                }
                text.x = toRounded(textLeftAdjust + textLeft);
                textCenterAdjust = textLeftAdjust + textLeft + textWidth * 0.5;
                switch (textAlign.vertical) {
                    case DAlignVertical.TOP:
                        textTopAdjust = pt;
                        textBottomAdjust = textTopAdjust + textTop + textHeight - textBottom;
                        break;
                    case DAlignVertical.MIDDLE:
                        textTopAdjust = (height - textTop + textBottom - textHeight) * 0.5;
                        textBottomAdjust = textTopAdjust + textTop + textHeight - textBottom;
                        break;
                    case DAlignVertical.BOTTOM:
                        textBottomAdjust = height - pb;
                        textTopAdjust = textBottomAdjust + textBottom - textHeight - textTop;
                        break;
                }
                text.y = toRounded(textTopAdjust + textTop);
                textMiddleAdjust = textTopAdjust + textTop + textHeight * 0.5;
            }
            else {
                textLeftAdjust = (width - textLeft + textRight) * 0.5;
                textRightAdjust = textLeftAdjust + textLeft - textRight;
                textCenterAdjust = textLeftAdjust + textLeft;
                textTopAdjust = (height - textTop + textBottom) * 0.5;
                textBottomAdjust = textTopAdjust + textTop - textBottom;
                textMiddleAdjust = textTopAdjust + textTop;
            }
            var paddingCenterAdjust = width * 0.5;
            var paddingMiddleAdjust = height * 0.5;
            var borderCenterAdjust = width * 0.5;
            var borderMiddleAdjust = height * 0.5;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                var image = images[i];
                var imageImage = image.image;
                if (imageImage) {
                    var imageBound = image.bound;
                    var imageBoundWidth = imageBound.width;
                    var imageBoundHeight = imageBound.height;
                    // Text
                    if (image.align.with === DAlignWith.TEXT) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.LEFT:
                                imageImage.x = toRounded(imageImage.x + textLeftAdjust);
                                break;
                            case DAlignHorizontal.CENTER:
                                imageImage.x = toRounded(textCenterAdjust - imageBoundWidth * 0.5);
                                break;
                            case DAlignHorizontal.RIGHT:
                                imageImage.x = toRounded(imageImage.x + textRightAdjust);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.TOP:
                                imageImage.y = toRounded(imageImage.y + textTopAdjust);
                                break;
                            case DAlignVertical.MIDDLE:
                                imageImage.y = toRounded(textMiddleAdjust - imageBoundHeight * 0.5);
                                break;
                            case DAlignVertical.BOTTOM:
                                imageImage.y = toRounded(imageImage.y + textBottomAdjust);
                                break;
                        }
                    }
                    // Padding
                    if (image.align.with === DAlignWith.PADDING) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.CENTER:
                                imageImage.x = toRounded(paddingCenterAdjust - imageBoundWidth * 0.5);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.MIDDLE:
                                imageImage.y = toRounded(paddingMiddleAdjust - imageBoundHeight * 0.5);
                                break;
                        }
                    }
                    // Border
                    if (image.align.with === DAlignWith.BORDER) {
                        switch (image.align.horizontal) {
                            case DAlignHorizontal.CENTER:
                                imageImage.x = toRounded(borderCenterAdjust - imageBoundWidth * 0.5);
                                break;
                        }
                        switch (image.align.vertical) {
                            case DAlignVertical.MIDDLE:
                                imageImage.y = toRounded(borderMiddleAdjust - imageBoundHeight * 0.5);
                                break;
                        }
                    }
                }
            }
        };
        DImageBase.prototype.isRefitable = function (target) {
            if (_super.prototype.isRefitable.call(this, target)) {
                return true;
            }
            var images = this._images;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                if (images[i].isRefitable(target)) {
                    return true;
                }
            }
            return false;
        };
        DImageBase.prototype.getType = function () {
            return "DImageBase";
        };
        DImageBase.prototype.destroy = function () {
            var images = this._images;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                images[i].destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DImageBase;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class for button classes.
     * See {@link DButtonBaseEvents} for event details.
     */
    var DButtonBase = /** @class */ (function (_super) {
        __extends(DButtonBase, _super);
        function DButtonBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonBase.prototype.init = function (options) {
            var _a, _b;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._isToggle = (_a = options === null || options === void 0 ? void 0 : options.toggle) !== null && _a !== void 0 ? _a : theme.isToggle();
            var when = toEnum((_b = options === null || options === void 0 ? void 0 : options.when) !== null && _b !== void 0 ? _b : theme.getWhen(), DButtonBaseWhen);
            this._when = when;
            // Event handlers
            this.initOnClick(when, theme, options);
            this.initOnPress(when, theme, options);
            // Group
            var group = options === null || options === void 0 ? void 0 : options.group;
            if (group) {
                group.add(this);
            }
        };
        DButtonBase.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.onClick(e);
        };
        DButtonBase.prototype.isToggle = function () {
            return this._isToggle;
        };
        DButtonBase.prototype.initOnClick = function (when, theme, options) {
            var _this = this;
            UtilPointerEvent.onClick(this, function (e) {
                if (when === DButtonBaseWhen.CLICKED) {
                    _this.onClick(e);
                }
            });
        };
        DButtonBase.prototype.initOnPress = function (when, theme, options) {
            var _this = this;
            var interactionManager = null;
            var onUp = function () {
                _this.state.isPressed = false;
                if (interactionManager != null) {
                    interactionManager.off(UtilPointerEvent.up, onUp);
                    interactionManager = null;
                }
            };
            this.on(UtilPointerEvent.down, function () {
                _this.state.isPressed = true;
                var layer = DApplications.getLayer(_this);
                if (layer) {
                    interactionManager = layer.renderer.plugins.interaction;
                    interactionManager.on(UtilPointerEvent.up, onUp);
                }
            });
        };
        DButtonBase.prototype.getType = function () {
            return "DButton";
        };
        DButtonBase.prototype.onClick = function (e) {
            if (this.state.isActionable) {
                if (this.isToggle()) {
                    this.onToggleStart(e);
                    this.onToggleEnd(e);
                }
                else {
                    this.onActivate(e);
                }
            }
        };
        DButtonBase.prototype.onDblClick = function (e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED) {
                this.onClick(e);
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DButtonBase.prototype.onActivate = function (e) {
            this.emit("active", this);
        };
        DButtonBase.prototype.onInactivate = function (e) {
            this.emit("inactive", this);
        };
        DButtonBase.prototype.toggle = function () {
            if (this.state.isActionable) {
                if (this.isToggle()) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
            }
        };
        DButtonBase.prototype.onToggleStart = function (e) {
            this.state.isActive = !this.state.isActive;
        };
        DButtonBase.prototype.onToggleEnd = function (e) {
            if (this.state.isActive) {
                this.onActivate(e);
            }
            else {
                this.onInactivate(e);
            }
        };
        DButtonBase.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                if (this.isToggle()) {
                    this.onToggleStart(e);
                }
                else {
                    this.state.isPressed = true;
                }
            }
        };
        DButtonBase.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.isToggle()) {
                    this.onToggleEnd(e);
                }
                else {
                    if (this.state.isPressed) {
                        this.onActivate(e);
                    }
                    this.state.isPressed = false;
                }
            }
        };
        DButtonBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DButtonBase.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DButtonBase.prototype.destroy = function () {
            var _a, _b;
            (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.group) === null || _b === void 0 ? void 0 : _b.remove(this);
            _super.prototype.destroy.call(this);
        };
        return DButtonBase;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A button class.
     */
    var DButton = /** @class */ (function (_super) {
        __extends(DButton, _super);
        function DButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButton.prototype.getType = function () {
            return "DButton";
        };
        return DButton;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonPrimary = /** @class */ (function (_super) {
        __extends(DButtonPrimary, _super);
        function DButtonPrimary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonPrimary.prototype.getType = function () {
            return "DButtonPrimary";
        };
        return DButtonPrimary;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationFadeIn = /** @class */ (function (_super) {
        __extends(DAnimationFadeIn, _super);
        function DAnimationFadeIn(options) {
            var _a, _b;
            var _this = _super.call(this, options) || this;
            _this._storedX = 0;
            _this._storedY = 0;
            _this._storedAlpha = 0;
            _this._storedTime = 0;
            _this._storedTarget = null;
            _this._layer = null;
            // Shifts
            var shift = options === null || options === void 0 ? void 0 : options.shift;
            _this._shiftX = (_a = shift === null || shift === void 0 ? void 0 : shift.x) !== null && _a !== void 0 ? _a : 0;
            _this._shiftY = (_b = shift === null || shift === void 0 ? void 0 : shift.y) !== null && _b !== void 0 ? _b : 15;
            _this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            _this._onPostrenderBound = function () {
                _this.onPostrender();
            };
            return _this;
        }
        DAnimationFadeIn.prototype.stop = function () {
            this._storedTime = 0;
            this.removeEventListeners();
            _super.prototype.stop.call(this);
        };
        DAnimationFadeIn.prototype.addEventListeners = function (target) {
            var layer = DApplications.getLayer(target);
            if (layer) {
                this._layer = layer;
                var renderer = layer.renderer;
                renderer.on("prerender", this._onPrerenderBound);
                renderer.on("postrender", this._onPostrenderBound);
            }
        };
        DAnimationFadeIn.prototype.removeEventListeners = function () {
            var layer = this._layer;
            if (layer) {
                this._layer = null;
                var renderer = layer.renderer;
                renderer.off("prerender", this._onPrerenderBound);
                renderer.off("postrender", this._onPostrenderBound);
            }
        };
        DAnimationFadeIn.prototype.onStart = function (isReverse) {
            var target = (this._storedTarget = this._target);
            if (target != null) {
                this._storedTime = 0;
                this.removeEventListeners();
                this.addEventListeners(target);
                if (!isReverse) {
                    target.visible = true;
                }
                _super.prototype.onStart.call(this, isReverse);
            }
        };
        DAnimationFadeIn.prototype.onTime = function (time, isReverse, elapsedTime) {
            var target = this._storedTarget;
            if (target != null) {
                var layer = this._layer;
                if (layer) {
                    this._storedTime = time;
                    _super.prototype.onTime.call(this, time, isReverse, elapsedTime);
                    layer.update();
                }
                else {
                    this._storedTime = time;
                    _super.prototype.onTime.call(this, time, isReverse, elapsedTime);
                }
            }
        };
        DAnimationFadeIn.prototype.onEnd = function (isReverse) {
            var target = this._storedTarget;
            if (target != null) {
                this.removeEventListeners();
                if (isReverse) {
                    target.visible = false;
                }
                _super.prototype.onEnd.call(this, isReverse);
            }
        };
        DAnimationFadeIn.prototype.onPrerender = function () {
            var target = this._storedTarget;
            if (target != null) {
                var storedTime = this._storedTime;
                // Position
                var position = target.unsafe.position;
                this._storedX = position.x;
                this._storedY = position.y;
                position.set(position.x - this._shiftX * (1 - storedTime), position.y - this._shiftY * (1 - storedTime));
                // Alpha
                this._storedAlpha = target.alpha;
                target.alpha = storedTime;
            }
        };
        DAnimationFadeIn.prototype.onPostrender = function () {
            var target = this._storedTarget;
            if (target != null) {
                // Position
                var position = target.unsafe.position;
                position.set(this._storedX, this._storedY);
                // Alpha
                target.alpha = this._storedAlpha;
            }
        };
        return DAnimationFadeIn;
    }(DAnimationBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilAttachAlign;
    (function (UtilAttachAlign) {
        UtilAttachAlign[UtilAttachAlign["TOP"] = 0] = "TOP";
        UtilAttachAlign[UtilAttachAlign["TOP_LEFT"] = 1] = "TOP_LEFT";
        UtilAttachAlign[UtilAttachAlign["TOP_CENTER"] = 2] = "TOP_CENTER";
        UtilAttachAlign[UtilAttachAlign["TOP_RIGHT"] = 3] = "TOP_RIGHT";
        UtilAttachAlign[UtilAttachAlign["LEFT"] = 4] = "LEFT";
        UtilAttachAlign[UtilAttachAlign["LEFT_TOP"] = 5] = "LEFT_TOP";
        UtilAttachAlign[UtilAttachAlign["LEFT_MIDDLE"] = 6] = "LEFT_MIDDLE";
        UtilAttachAlign[UtilAttachAlign["LEFT_BOTTOM"] = 7] = "LEFT_BOTTOM";
        UtilAttachAlign[UtilAttachAlign["RIGHT"] = 8] = "RIGHT";
        UtilAttachAlign[UtilAttachAlign["RIGHT_TOP"] = 9] = "RIGHT_TOP";
        UtilAttachAlign[UtilAttachAlign["RIGHT_MIDDLE"] = 10] = "RIGHT_MIDDLE";
        UtilAttachAlign[UtilAttachAlign["RIGHT_BOTTOM"] = 11] = "RIGHT_BOTTOM";
        UtilAttachAlign[UtilAttachAlign["BOTTOM"] = 12] = "BOTTOM";
        UtilAttachAlign[UtilAttachAlign["BOTTOM_LEFT"] = 13] = "BOTTOM_LEFT";
        UtilAttachAlign[UtilAttachAlign["BOTTOM_CENTER"] = 14] = "BOTTOM_CENTER";
        UtilAttachAlign[UtilAttachAlign["BOTTOM_RIGHT"] = 15] = "BOTTOM_RIGHT";
        UtilAttachAlign[UtilAttachAlign["OVER"] = 16] = "OVER";
    })(UtilAttachAlign || (UtilAttachAlign = {}));
    var UtilAttach = /** @class */ (function () {
        function UtilAttach() {
        }
        UtilAttach.attach = function (target, bounds, offsetX, offsetY, clippingWidth, clippingHeight, align) {
            var width = target.width;
            var height = target.height;
            var x = 0;
            switch (align) {
                case UtilAttachAlign.LEFT:
                case UtilAttachAlign.LEFT_TOP:
                case UtilAttachAlign.LEFT_MIDDLE:
                case UtilAttachAlign.LEFT_BOTTOM:
                    x = bounds.left - width - offsetX;
                    if (x < offsetX) {
                        x = bounds.right + offsetX;
                        if (clippingWidth - offsetX < x + width) {
                            x = offsetX;
                        }
                    }
                    break;
                case UtilAttachAlign.RIGHT:
                case UtilAttachAlign.RIGHT_TOP:
                case UtilAttachAlign.RIGHT_MIDDLE:
                case UtilAttachAlign.RIGHT_BOTTOM:
                    x = bounds.right + offsetX;
                    if (clippingWidth - offsetX < x + width) {
                        x = bounds.left - width - offsetX;
                        if (x < offsetX) {
                            x = clippingWidth - width - offsetX;
                        }
                    }
                    break;
                case UtilAttachAlign.TOP:
                case UtilAttachAlign.TOP_LEFT:
                case UtilAttachAlign.BOTTOM:
                case UtilAttachAlign.BOTTOM_LEFT:
                    x = this.adjust(bounds.left, width, offsetX, clippingWidth);
                    break;
                case UtilAttachAlign.TOP_RIGHT:
                case UtilAttachAlign.BOTTOM_RIGHT:
                    x = this.adjust(bounds.right - width, width, offsetX, clippingWidth);
                    break;
                case UtilAttachAlign.TOP_CENTER:
                case UtilAttachAlign.BOTTOM_CENTER:
                case UtilAttachAlign.OVER:
                    x = this.adjust((bounds.left + bounds.right - width) * 0.5, width, offsetX, clippingWidth);
                    break;
            }
            var y = 0;
            switch (align) {
                case UtilAttachAlign.LEFT:
                case UtilAttachAlign.LEFT_TOP:
                case UtilAttachAlign.RIGHT:
                case UtilAttachAlign.RIGHT_TOP:
                    y = this.adjust(bounds.top, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.LEFT_MIDDLE:
                case UtilAttachAlign.RIGHT_MIDDLE:
                case UtilAttachAlign.OVER:
                    y = this.adjust((bounds.top + bounds.bottom - height) * 0.5, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.LEFT_BOTTOM:
                case UtilAttachAlign.RIGHT_BOTTOM:
                    y = this.adjust(bounds.bottom, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.TOP:
                case UtilAttachAlign.TOP_LEFT:
                case UtilAttachAlign.TOP_RIGHT:
                case UtilAttachAlign.TOP_CENTER:
                    y = bounds.top - height - offsetY;
                    if (y < offsetY) {
                        y = bounds.bottom + offsetY;
                        if (clippingHeight < y + height) {
                            y = offsetY;
                        }
                    }
                    break;
                case UtilAttachAlign.BOTTOM:
                case UtilAttachAlign.BOTTOM_LEFT:
                case UtilAttachAlign.BOTTOM_RIGHT:
                case UtilAttachAlign.BOTTOM_CENTER:
                    y = bounds.bottom + offsetY;
                    if (clippingHeight - offsetY < y + height) {
                        y = bounds.top - height - offsetY;
                        if (y < offsetY) {
                            y = clippingHeight - height - offsetY;
                        }
                    }
                    break;
            }
            target.position.set(x, y);
        };
        UtilAttach.adjust = function (position, size, offset, clippingSize) {
            if (position < offset) {
                if (clippingSize - offset < position + size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return offset;
                }
            }
            else if (clippingSize - offset < position + size) {
                if (clippingSize < size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return clippingSize - size - offset;
                }
            }
            return position;
        };
        return UtilAttach;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogCloseOn;
    (function (DDialogCloseOn) {
        DDialogCloseOn[DDialogCloseOn["NONE"] = 0] = "NONE";
        DDialogCloseOn[DDialogCloseOn["ESC"] = 1] = "ESC";
        DDialogCloseOn[DDialogCloseOn["CLICK_OUTSIDE"] = 2] = "CLICK_OUTSIDE";
    })(DDialogCloseOn || (DDialogCloseOn = {}));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DDialog} mode options.
     */
    var DDialogMode;
    (function (DDialogMode) {
        DDialogMode[DDialogMode["MODAL"] = 0] = "MODAL";
        DDialogMode[DDialogMode["MODELESS"] = 1] = "MODELESS";
        DDialogMode[DDialogMode["MENU"] = 2] = "MENU";
    })(DDialogMode || (DDialogMode = {}));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogState = {
        MODAL: "MODAL",
        MODELESS: "MODELESS",
        MENU: "MENU"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilClickOutside = /** @class */ (function () {
        function UtilClickOutside() {
        }
        UtilClickOutside.apply = function (target, onClick) {
            var _this = this;
            target.on(UtilPointerEvent.down, function (e) {
                if (e.target === target) {
                    var point = _this.point;
                    point.copyFrom(e.data.global);
                    target.toLocal(point, undefined, point, true);
                    var x = point.x;
                    var y = point.y;
                    if (x < 0 || y < 0 || target.width < x || target.height < y) {
                        onClick(e);
                    }
                }
            });
        };
        UtilClickOutside.point = new pixi_js.Point();
        return UtilClickOutside;
    }());

    var UtilOverlay = /** @class */ (function () {
        function UtilOverlay(options) {
            this._layer = null;
            this._application = (options === null || options === void 0 ? void 0 : options.parent) == null ? DApplications.last() : null;
        }
        Object.defineProperty(UtilOverlay.prototype, "picked", {
            get: function () {
                return this._layer;
            },
            enumerable: false,
            configurable: true
        });
        UtilOverlay.prototype.pick = function (target) {
            var layer = this._layer;
            if (layer == null) {
                layer = DApplications.getLayerOverlay(target);
                if (!layer) {
                    var application = this._application;
                    if (application) {
                        layer = application.getLayerOverlay();
                    }
                    else {
                        layer = DApplications.last().getLayerOverlay();
                    }
                }
                this._layer = layer;
            }
            return layer;
        };
        return UtilOverlay;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog class.
     *
     * If multiple application instances are there, better to set the constructor
     * option `parent` to an `application.stage` so that the dialog picks a right
     * application. By default, the dialog assumes the last created application is
     * the one it belongs to at the time when it is created.
     */
    var DDialog = /** @class */ (function (_super) {
        __extends(DDialog, _super);
        function DDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialog.prototype.init = function (options) {
            var _this = this;
            var _a, _b, _c, _d;
            _super.prototype.init.call(this, options);
            this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            // Modeless
            var theme = this.theme;
            var mode = toEnum((_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : theme.getMode(), DDialogMode);
            this._mode = mode;
            // Sticky
            this._sticky = (_b = options === null || options === void 0 ? void 0 : options.sticky) !== null && _b !== void 0 ? _b : theme.isSticky();
            // Close On
            var closeOn = (_c = options === null || options === void 0 ? void 0 : options.closeOn) !== null && _c !== void 0 ? _c : theme.closeOn();
            this._closeOn = closeOn;
            // Align
            this._align = toEnum((_d = options === null || options === void 0 ? void 0 : options.align) !== null && _d !== void 0 ? _d : UtilAttachAlign.BOTTOM, UtilAttachAlign);
            // Overlay
            this._overlay = new UtilOverlay();
            // Others
            switch (mode) {
                case DDialogMode.MODAL:
                case DDialogMode.MENU:
                    this.visible = false;
                    var state = this.state;
                    state.lock();
                    state.isFocusRoot = true;
                    state.add(mode === DDialogMode.MODAL ? DDialogState.MODAL : DDialogState.MENU);
                    state.unlock();
                    if (closeOn & DDialogCloseOn.CLICK_OUTSIDE) {
                        UtilClickOutside.apply(this, function () {
                            _this.onCloseOn();
                        });
                    }
                    break;
                case DDialogMode.MODELESS:
                    this.state.add(DDialogState.MODELESS);
                    break;
            }
        };
        DDialog.prototype.getAnimation = function () {
            var _this = this;
            var _a, _b, _c, _d;
            var result = this._animation;
            if (result === undefined) {
                switch (this._mode) {
                    case DDialogMode.MODAL:
                        result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.animation) !== null && _b !== void 0 ? _b : new DAnimationFadeIn();
                        break;
                    case DDialogMode.MODELESS:
                        result = null;
                        break;
                    case DDialogMode.MENU:
                        result = (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.animation) !== null && _d !== void 0 ? _d : null;
                        break;
                }
                if (result) {
                    result.target = this;
                    result.on("end", function (isReverse) {
                        _this.onAnimationEnd(isReverse);
                    });
                }
                this._animation = result;
            }
            return result;
        };
        DDialog.prototype.onAnimationEnd = function (isReverse) {
            if (isReverse) {
                var parent_1 = this.parent;
                if (parent_1) {
                    parent_1.removeChild(this);
                }
            }
            else {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var focusController = layer.getFocusController();
                    this._focusable = focusController.get();
                    var firstFocusable = focusController.find(this, false, true, true);
                    focusController.focus(firstFocusable || this);
                }
            }
        };
        DDialog.prototype.open = function (owner) {
            var _this = this;
            var result = this._promise;
            if (result == null) {
                result = new Promise(function (resolve, reject) {
                    _this._resolve = resolve;
                    _this._reject = reject;
                });
                this._promise = result;
                this._owner = owner;
                switch (this._mode) {
                    case DDialogMode.MODAL:
                        {
                            var layer = this._overlay.pick(this);
                            layer.stage.addChild(this);
                        }
                        break;
                    case DDialogMode.MODELESS:
                        break;
                    case DDialogMode.MENU:
                        {
                            var layer = this._overlay.pick(this);
                            layer.stage.addChild(this);
                            // Position & size
                            var renderer = layer.renderer;
                            var onPrerenderBound = this._onPrerenderBound;
                            if (this._sticky) {
                                renderer.on("prerender", onPrerenderBound);
                            }
                            else {
                                renderer.once("prerender", onPrerenderBound);
                            }
                        }
                        break;
                }
                this.onOpen();
            }
            return result;
        };
        DDialog.prototype.onPrerender = function () {
            var owner = this._owner;
            if (owner) {
                var bounds = owner.getBounds();
                if (bounds) {
                    var layer = this._overlay.picked;
                    if (layer) {
                        var theme = this.theme;
                        UtilAttach.attach(this, bounds, theme.getOffsetX(), theme.getOffsetY(), layer.width, layer.height, this._align);
                    }
                }
            }
        };
        DDialog.prototype.onOpen = function () {
            this.emit("open", this);
            // Animation
            var animation = this.getAnimation();
            if (animation) {
                animation.start();
            }
            else if (this._mode === DDialogMode.MENU) {
                this.visible = true;
                this.onAnimationEnd(false);
            }
        };
        DDialog.prototype.isOpened = function () {
            return this._promise != null;
        };
        DDialog.prototype.close = function () {
            this.doReject();
        };
        DDialog.prototype.doResolve = function (value) {
            var resolve = this._resolve;
            if (resolve) {
                this._promise = undefined;
                this._resolve = undefined;
                this._reject = undefined;
                this.onClose();
                resolve(value);
            }
        };
        DDialog.prototype.doReject = function (reason) {
            var reject = this._reject;
            if (reject) {
                this._promise = undefined;
                this._resolve = undefined;
                this._reject = undefined;
                this.onClose();
                reject(reason);
            }
        };
        DDialog.prototype.onClose = function () {
            // Focus
            var layer = this._overlay.picked;
            var focusable = this._focusable;
            if (focusable != null) {
                this._focusable = null;
                if (layer) {
                    layer.getFocusController().focus(focusable);
                }
                else {
                    this.blur(true);
                }
            }
            else {
                this.blur(true);
            }
            // Remove the prerender event handler
            switch (this._mode) {
                case DDialogMode.MODAL:
                    break;
                case DDialogMode.MODELESS:
                    break;
                case DDialogMode.MENU:
                    if (layer) {
                        layer.renderer.off("prerender", this._onPrerenderBound);
                    }
                    break;
            }
            // Forget the owner
            this._owner = null;
            // Animation
            var animation = this.getAnimation();
            if (animation) {
                animation.start(true);
            }
            else if (this._mode === DDialogMode.MENU) {
                this.visible = false;
                this.onAnimationEnd(true);
            }
            this.emit("close", this);
        };
        DDialog.prototype.onKeyDown = function (e) {
            switch (this._mode) {
                case DDialogMode.MODAL:
                case DDialogMode.MENU:
                    if (this._closeOn & DDialogCloseOn.ESC) {
                        if (UtilKeyboardEvent.isCancelKey(e)) {
                            this.onCloseOn();
                        }
                    }
                    break;
                case DDialogMode.MODELESS:
                    break;
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDialog.prototype.onCloseOn = function () {
            this.close();
        };
        DDialog.prototype.containsGlobalPoint = function (point) {
            switch (this._mode) {
                case DDialogMode.MODAL:
                case DDialogMode.MENU:
                    return true;
                case DDialogMode.MODELESS:
                    return _super.prototype.containsGlobalPoint.call(this, point);
            }
        };
        DDialog.prototype.getType = function () {
            return "DDialog";
        };
        return DDialog;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutDirection;
    (function (DLayoutDirection) {
        DLayoutDirection[DLayoutDirection["VERTICAL"] = 0] = "VERTICAL";
        DLayoutDirection[DLayoutDirection["HORIZONTAL"] = 1] = "HORIZONTAL";
    })(DLayoutDirection || (DLayoutDirection = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutSpace = /** @class */ (function (_super) {
        __extends(DLayoutSpace, _super);
        function DLayoutSpace(options) {
            var _this = _super.call(this, options) || this;
            _this.visible = false;
            _this.state.isFocusable = false;
            return _this;
        }
        DLayoutSpace.prototype.getType = function () {
            return "DLayoutSpace";
        };
        return DLayoutSpace;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isVisible = function (child) {
        return child instanceof DBase && (child.visible || child instanceof DLayoutSpace);
    };
    var toMultiplicity = function (theme, options) {
        if (options) {
            var row = options.row;
            if (row != null) {
                return row;
            }
            var column = options.column;
            if (column != null) {
                return column;
            }
        }
        return theme.getMultiplicity();
    };
    var toMargin = function (theme, options) {
        var _a, _b;
        var margin = options === null || options === void 0 ? void 0 : options.margin;
        if (margin != null) {
            if (isNumber(margin)) {
                return {
                    horizontal: margin,
                    vertical: margin
                };
            }
            else {
                var themeMargin = theme.getMargin();
                return {
                    horizontal: (_a = margin.horizontal) !== null && _a !== void 0 ? _a : themeMargin,
                    vertical: (_b = margin.vertical) !== null && _b !== void 0 ? _b : themeMargin
                };
            }
        }
        else {
            var themeMargin = theme.getMargin();
            return {
                horizontal: themeMargin,
                vertical: themeMargin
            };
        }
    };
    var toDirection = function (theme, options) {
        var direction = options === null || options === void 0 ? void 0 : options.direction;
        if (direction != null) {
            if (isString(direction)) {
                return DLayoutDirection[direction];
            }
            else {
                return direction;
            }
        }
        return theme.getDirection();
    };
    var toCornerAdjust = function (theme, options) {
        var corner = options === null || options === void 0 ? void 0 : options.corner;
        if (corner != null && !isNumber(corner)) {
            var adjust = corner.adjust;
            if (adjust != null) {
                return adjust;
            }
        }
        return theme.getCornerAdjust();
    };
    var toReverse = function (theme, options) {
        var _a;
        return (_a = options === null || options === void 0 ? void 0 : options.reverse) !== null && _a !== void 0 ? _a : theme.getReverse();
    };
    var DLayout = /** @class */ (function (_super) {
        __extends(DLayout, _super);
        function DLayout(options) {
            return _super.call(this, options) || this;
        }
        DLayout.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
            var theme = this.theme;
            this._margin = toMargin(theme, options);
            this._direction = toDirection(theme, options);
            this._cornerAdjust = toCornerAdjust(theme, options);
            this._multiplicity = toMultiplicity(theme, options);
            this._reverse = toReverse(theme, options);
        };
        Object.defineProperty(DLayout.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLayout.prototype, "multiplicity", {
            get: function () {
                return this._multiplicity;
            },
            enumerable: false,
            configurable: true
        });
        DLayout.prototype.getWeightTotal = function () {
            var children = this.children;
            var result = 0;
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            for (var i = 0, imax = children.length; i < imax;) {
                var weight = -1;
                var j = 0;
                for (; j < multiplicity && i + j < imax; ++j) {
                    var child = children[reverse ? imax - 1 - (i + j) : i + j];
                    if (isVisible(child)) {
                        var clearType = child.getClearType();
                        if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                            break;
                        }
                        else {
                            weight = Math.max(weight, child.weight);
                            if (clearType && DLayoutClearType.AFTER) {
                                j += 1;
                                break;
                            }
                        }
                    }
                    else {
                        i += 1;
                        j -= 1;
                    }
                }
                i += j;
                if (0 <= weight) {
                    result += weight;
                }
            }
            return result;
        };
        DLayout.prototype.getSpaceLeft = function (baseSize, margin) {
            var children = this.children;
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            if (this._direction === DLayoutDirection.VERTICAL) {
                var result = baseSize;
                var marginNext = 0;
                for (var i = 0, imax = children.length; i < imax;) {
                    var height = 0;
                    var weight = -1;
                    var j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        var child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            var clearType = child.getClearType();
                            if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    height = Math.max(height, child.height + marginNext);
                                }
                                else {
                                    height = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= height;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
            else {
                var result = baseSize;
                var marginNext = 0;
                for (var i = 0, imax = children.length; i < imax;) {
                    var width = 0;
                    var weight = -1;
                    var j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        var child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            var clearType = child.getClearType();
                            if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    width = Math.max(width, child.width + marginNext);
                                }
                                else {
                                    width = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= width;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
        };
        DLayout.prototype.calcSpaceLeft = function (isOn, size, padding, margin) {
            return isOn ? 0 : this.getSpaceLeft(size - padding, margin);
        };
        DLayout.prototype.onRefit = function () {
            var children = this.children;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            var paddingRight = padding.getRight();
            var margin = this._margin;
            var marginVertical = margin.vertical;
            var marginHorizontal = margin.horizontal;
            var weightTotal = this.getWeightTotal();
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            var auto = this._auto;
            var cornerAdjustWork = null;
            if (this._cornerAdjust) {
                var requiredSize = 4 + (children.length << 1);
                if (DLayout.CORNER_ADJUST_WORK == null ||
                    DLayout.CORNER_ADJUST_WORK.length < requiredSize) {
                    DLayout.CORNER_ADJUST_WORK = new Float32Array(requiredSize);
                }
                cornerAdjustWork = DLayout.CORNER_ADJUST_WORK;
                cornerAdjustWork[0] = -2;
                cornerAdjustWork[1] = -2;
                cornerAdjustWork[requiredSize - 2] = -3;
                cornerAdjustWork[requiredSize - 1] = -3;
            }
            if (this._direction === DLayoutDirection.VERTICAL) {
                var irow = 0;
                var y = paddingTop - marginVertical;
                if (0 < weightTotal) {
                    var weightTotalInverse = 1 / weightTotal;
                    var spaceLeft = this.calcSpaceLeft(auto.height.isOn, this.height, paddingTop + paddingBottom, marginVertical);
                    for (var i = 0, imax = children.length; i < imax;) {
                        var x = paddingLeft - marginHorizontal;
                        var height = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                var icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                var ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
                else {
                    for (var i = 0, imax = children.length; i < imax;) {
                        var x = paddingLeft - marginHorizontal;
                        var height = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = 0;
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                var icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                var ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
            }
            else {
                var icolumn = 0;
                var x = paddingLeft - marginHorizontal;
                if (0 < weightTotal) {
                    var weightTotalInverse = 1 / weightTotal;
                    var spaceLeft = this.calcSpaceLeft(auto.width.isOn, this.width, paddingLeft + paddingRight, marginHorizontal);
                    for (var i = 0, imax = children.length; i < imax;) {
                        var y = paddingTop - marginVertical;
                        var width = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                var irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                var nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
                else {
                    for (var i = 0, imax = children.length; i < imax;) {
                        var y = paddingTop - marginVertical;
                        var width = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = 0;
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                var irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                var nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
            }
            _super.prototype.onRefit.call(this);
        };
        DLayout.prototype.hasClearTypeBefore = function (children, index) {
            return this.hasClearType(children, index, DLayoutClearType.BEFORE);
        };
        DLayout.prototype.hasClearTypeAfter = function (children, index) {
            return this.hasClearType(children, index, DLayoutClearType.AFTER);
        };
        DLayout.prototype.hasClearType = function (children, index, clearType) {
            if (2 <= index) {
                var i = (index - 2) >> 1;
                if (0 <= i && i < children.length) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        return !!(child.getClearType() & clearType);
                    }
                }
            }
            return false;
        };
        DLayout.prototype.findColumnIndexPrevious = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i] !== icolumn) {
                    return i;
                }
            }
            return 0;
        };
        DLayout.prototype.findColumnIndexNext = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    for (var j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j] !== icolumn2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        };
        DLayout.prototype.countRow = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    return cornerAdjustWork[i - 2 + 1] + 1;
                }
            }
            return 0;
        };
        DLayout.prototype.findRowIndexPrevious = function (istart, irow, cornerAdjustWork) {
            for (var i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i + 1] !== irow) {
                    return i;
                }
            }
            return 0;
        };
        DLayout.prototype.findRowIndexNext = function (istart, irow, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    for (var j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j + 1] !== irow2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        };
        DLayout.prototype.countColumn = function (istart, irow, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    return cornerAdjustWork[i - 2 + 0] + 1;
                }
            }
            return 0;
        };
        DLayout.prototype.toCornerMaskColumn = function (i0, i1, i2, n) {
            var result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & ~result;
        };
        DLayout.prototype.toCornerMaskRow = function (i0, i1, i2, n) {
            var result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & ~result;
        };
        DLayout.prototype.addSpace = function (options) {
            return this.addChild(new DLayoutSpace(options));
        };
        DLayout.prototype.getType = function () {
            return "DLayout";
        };
        DLayout.CORNER_ADJUST_WORK = null;
        return DLayout;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutHorizontal = /** @class */ (function (_super) {
        __extends(DLayoutHorizontal, _super);
        function DLayoutHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayoutHorizontal.prototype.getType = function () {
            return "DLayoutHorizontal";
        };
        return DLayoutHorizontal;
    }(DLayout));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutVertical = /** @class */ (function (_super) {
        __extends(DLayoutVertical, _super);
        function DLayoutVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayoutVertical.prototype.getType = function () {
            return "DLayoutVertical";
        };
        return DLayoutVertical;
    }(DLayout));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog with "ok" and "cancel" buttons.
     */
    var DDialogCommand = /** @class */ (function (_super) {
        __extends(DDialogCommand, _super);
        function DDialogCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogCommand.prototype.init = function (options) {
            var _this = this;
            var _a, _b;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            var layout = this.newLayout(theme, options);
            this.onInit(layout, options);
            // Buttons
            var ok = (_a = options === null || options === void 0 ? void 0 : options.ok) !== null && _a !== void 0 ? _a : theme.getOk();
            var cancel = (_b = options === null || options === void 0 ? void 0 : options.cancel) !== null && _b !== void 0 ? _b : theme.getCancel();
            if (ok != null || cancel != null) {
                var buttonLayout = new DLayoutHorizontal({
                    parent: layout,
                    width: "padding",
                    height: "auto",
                    padding: {
                        top: Math.max(0, this.padding.getTop() - layout.margin.vertical)
                    }
                });
                this._buttonLayout = buttonLayout;
                new DLayoutSpace({
                    parent: buttonLayout,
                    weight: 1
                });
                if (ok != null && cancel != null) {
                    this._buttonCancel = new DButtonPrimary({
                        parent: buttonLayout,
                        text: {
                            value: cancel
                        },
                        on: {
                            active: function () {
                                _this.cancel();
                            }
                        }
                    });
                    this._buttonOk = new DButton({
                        parent: buttonLayout,
                        text: {
                            value: ok
                        },
                        on: {
                            active: function () {
                                _this.ok();
                            }
                        }
                    });
                }
                else if (ok != null) {
                    this._buttonOk = new DButtonPrimary({
                        parent: buttonLayout,
                        text: {
                            value: ok
                        },
                        on: {
                            active: function () {
                                _this.ok();
                            }
                        }
                    });
                }
                else if (cancel != null) {
                    this._buttonCancel = new DButtonPrimary({
                        parent: buttonLayout,
                        text: {
                            value: cancel
                        },
                        on: {
                            active: function () {
                                _this.cancel();
                            }
                        }
                    });
                }
                new DLayoutSpace({
                    parent: buttonLayout,
                    weight: 1
                });
            }
        };
        DDialogCommand.prototype.newLayout = function (theme, options) {
            return new DLayoutVertical(this.toLayoutOptions(theme, options === null || options === void 0 ? void 0 : options.layout));
        };
        DDialogCommand.prototype.toLayoutOptions = function (theme, options) {
            var _a, _b, _c, _d, _e;
            options !== null && options !== void 0 ? options : (options = {});
            options.parent = this;
            (_a = options.x) !== null && _a !== void 0 ? _a : (options.x = theme.getLayoutX());
            (_b = options.y) !== null && _b !== void 0 ? _b : (options.y = theme.getLayoutY());
            (_c = options.width) !== null && _c !== void 0 ? _c : (options.width = theme.getLayoutWidth());
            (_d = options.height) !== null && _d !== void 0 ? _d : (options.height = theme.getLayoutHeight());
            (_e = options.margin) !== null && _e !== void 0 ? _e : (options.margin = theme.getLayoutMargin());
            return options;
        };
        DDialogCommand.prototype.onInit = function (layout, options) {
            // OVERRIDE THIS
        };
        DDialogCommand.prototype.ok = function () {
            this.onOk(this.getResolvedValue());
        };
        DDialogCommand.prototype.onOk = function (value) {
            if (this._mode !== DDialogMode.MODELESS) {
                this.doResolve(value);
            }
            this.emit("ok", value, this);
        };
        DDialogCommand.prototype.cancel = function () {
            this.onCancel(this.getRejectReason());
        };
        DDialogCommand.prototype.onCancel = function (reason) {
            if (this._mode !== DDialogMode.MODELESS) {
                this.doReject(reason);
            }
            this.emit("cancel", reason, this);
        };
        DDialogCommand.prototype.getRejectReason = function () {
            return undefined;
        };
        DDialogCommand.prototype.getType = function () {
            return "DDialogCommand";
        };
        return DDialogCommand;
    }(DDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DText = /** @class */ (function (_super) {
        __extends(DText, _super);
        function DText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DText.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
        };
        DText.prototype.getType = function () {
            return "DText";
        };
        return DText;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInput = /** @class */ (function (_super) {
        __extends(DDialogInput, _super);
        function DDialogInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInput.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            var theme = this.theme;
            var margin = this.toMargin(theme, options);
            var marginHorizontal = margin.horizontal;
            var marginVertical = margin.vertical;
            var labelOptions = this.toLabelOptions(theme, options);
            if (labelOptions) {
                this._label = new DText(labelOptions);
                new DLayoutHorizontal({
                    parent: layout,
                    width: "padding",
                    height: "auto",
                    margin: 0,
                    children: [new DLayoutSpace({ width: marginHorizontal }), this._label]
                });
            }
            new DLayoutHorizontal({
                parent: layout,
                width: "padding",
                height: "auto",
                margin: 0,
                padding: labelOptions ? { top: marginVertical } : undefined,
                children: [
                    new DLayoutSpace({ width: marginHorizontal }),
                    this.input,
                    new DLayoutSpace({ width: marginHorizontal })
                ]
            });
        };
        DDialogInput.prototype.toMargin = function (theme, options) {
            var margin = options === null || options === void 0 ? void 0 : options.margin;
            if (margin != null) {
                if (isNumber(margin)) {
                    return {
                        horizontal: margin,
                        vertical: margin
                    };
                }
                else {
                    var horizontal = margin.horizontal;
                    var vertical = margin.vertical;
                    return {
                        horizontal: horizontal !== null && horizontal !== void 0 ? horizontal : theme.getMarginHorizontal(),
                        vertical: vertical !== null && vertical !== void 0 ? vertical : theme.getMarginVertical()
                    };
                }
            }
            return {
                horizontal: theme.getMarginHorizontal(),
                vertical: theme.getMarginVertical()
            };
        };
        DDialogInput.prototype.toLabelOptions = function (theme, options) {
            var label = options === null || options === void 0 ? void 0 : options.label;
            if (label == null) {
                return null;
            }
            if (isString(label)) {
                return {
                    weight: 1,
                    text: {
                        value: label
                    }
                };
            }
            else {
                // Text
                var text = label.text || {};
                label.text = text;
                if (text.value === undefined) {
                    text.value = theme.getLabel();
                }
                // Margin
                if (label.width === undefined && label.weight === undefined) {
                    label.weight = 1;
                }
                return label;
            }
        };
        Object.defineProperty(DDialogInput.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogInput.prototype, "input", {
            get: function () {
                var result = this._input;
                if (result == null) {
                    var options = this._options;
                    result = this.newInput(options === null || options === void 0 ? void 0 : options.input);
                    this._input = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogInput.prototype, "value", {
            get: function () {
                return this.input.value;
            },
            set: function (value) {
                this.input.value = value;
            },
            enumerable: false,
            configurable: true
        });
        DDialogInput.prototype.getResolvedValue = function () {
            return this.input.value;
        };
        DDialogInput.prototype.getType = function () {
            return "DDialogInput";
        };
        return DDialogInput;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonGroup = /** @class */ (function (_super) {
        __extends(DButtonGroup, _super);
        function DButtonGroup(options) {
            var _this = _super.call(this) || this;
            _this._buttons = [];
            _this._active = null;
            _this._onActiveBound = function (button) {
                _this.active = button;
            };
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            // Done
            _this.emit("init", _this);
            return _this;
        }
        DButtonGroup.prototype.add = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            if (index < 0) {
                this._buttons.push(button);
                var isEnabled = this._isEnabled;
                if (isEnabled != null) {
                    button.state.isEnabled = isEnabled;
                }
                button.on("active", this._onActiveBound);
                if (button.state.isActive) {
                    this.active = button;
                }
            }
        };
        Object.defineProperty(DButtonGroup.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (newActive) {
                if ((newActive == null || newActive.isToggle()) && this._active !== newActive) {
                    var oldActive = this._active;
                    this._active = null;
                    var buttons = this._buttons;
                    for (var i = 0, imax = buttons.length; i < imax; ++i) {
                        var button = buttons[i];
                        if (button !== newActive && button.isToggle() && button.state.isActive) {
                            button.toggle();
                        }
                    }
                    this.emit("active", newActive, oldActive, this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonGroup.prototype.remove = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            if (0 <= index) {
                buttons.splice(index, 1);
                button.off("active", this._onActiveBound);
                if (this._active === button) {
                    this.active = null;
                }
            }
        };
        DButtonGroup.prototype.contains = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            return 0 <= index;
        };
        DButtonGroup.prototype.clear = function () {
            this._buttons.length = 0;
            this.active = null;
        };
        DButtonGroup.prototype.size = function () {
            return this._buttons.length;
        };
        DButtonGroup.prototype.each = function (iteratee) {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                var button = buttons[i];
                if (iteratee(button) === false) {
                    break;
                }
            }
        };
        DButtonGroup.prototype.disable = function () {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].state.isDisabled = true;
            }
            this._isEnabled = false;
        };
        DButtonGroup.prototype.enable = function () {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].state.isDisabled = false;
            }
            this._isEnabled = true;
        };
        DButtonGroup.prototype.destroy = function () {
            this.clear();
        };
        return DButtonGroup;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputBooleanButtonOff = /** @class */ (function (_super) {
        __extends(DInputBooleanButtonOff, _super);
        function DInputBooleanButtonOff() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputBooleanButtonOff.prototype.getType = function () {
            return "DInputBooleanButtonOff";
        };
        return DInputBooleanButtonOff;
    }(DButton));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputBooleanButtonOn = /** @class */ (function (_super) {
        __extends(DInputBooleanButtonOn, _super);
        function DInputBooleanButtonOn() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputBooleanButtonOn.prototype.getType = function () {
            return "DInputBooleanButtonOn";
        };
        return DInputBooleanButtonOn;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputBoolean = /** @class */ (function (_super) {
        __extends(DInputBoolean, _super);
        function DInputBoolean(options) {
            var _this = _super.call(this, options) || this;
            _this.addChild(_this.getButtonOff());
            _this.addChild(_this.getButtonOn());
            var value = options === null || options === void 0 ? void 0 : options.value;
            if (value != null) {
                _this.value = value;
            }
            _this.getButtonGroup().on("active", function () {
                var newValue = _this.value;
                _this.emit("change", newValue, !newValue, _this);
            });
            return _this;
        }
        DInputBoolean.prototype.getButtonGroup = function () {
            var result = this._buttonGroup;
            if (result == null) {
                result = this.newButtonGroup();
                this._buttonGroup = result;
            }
            return result;
        };
        DInputBoolean.prototype.newButtonGroup = function () {
            return new DButtonGroup();
        };
        DInputBoolean.prototype.getButtonOn = function () {
            var result = this._buttonOn;
            if (result == null) {
                result = this.newButtonOn();
                this._buttonOn = result;
            }
            return result;
        };
        DInputBoolean.prototype.newButtonOn = function () {
            return new DInputBooleanButtonOn({
                weight: 1,
                group: this.getButtonGroup()
            });
        };
        DInputBoolean.prototype.getButtonOff = function () {
            var result = this._buttonOff;
            if (result == null) {
                result = this.newButtonOff();
                this._buttonOff = result;
            }
            return result;
        };
        DInputBoolean.prototype.newButtonOff = function () {
            return new DInputBooleanButtonOff({
                weight: 1,
                group: this.getButtonGroup(),
                state: DBaseState.ACTIVE
            });
        };
        Object.defineProperty(DInputBoolean.prototype, "value", {
            get: function () {
                return this.getButtonOn().state.isActive;
            },
            set: function (value) {
                if (this.value !== value) {
                    if (value) {
                        this.getButtonOn().onClick();
                    }
                    else {
                        this.getButtonOff().onClick();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DInputBoolean.prototype.getType = function () {
            return "DInputBoolean";
        };
        return DInputBoolean;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputBoolean = /** @class */ (function (_super) {
        __extends(DDialogInputBoolean, _super);
        function DDialogInputBoolean() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputBoolean.prototype.newInput = function (options) {
            return new DInputBoolean(this.toInputOptions(options));
        };
        DDialogInputBoolean.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputBoolean.prototype.getType = function () {
            return "DDialogInputBoolean";
        };
        return DDialogInputBoolean;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpen = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpen, _super);
        function EShapeActionRuntimeOpen(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            return _this;
        }
        return EShapeActionRuntimeOpen;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialog = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialog, _super);
        function EShapeActionRuntimeOpenDialog(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.onInputAction = value.onInputAction;
            _this.isOpened = false;
            return _this;
        }
        EShapeActionRuntimeOpenDialog.prototype.execute = function (shape, runtime, time) {
            var _this = this;
            if (!this.isOpened) {
                if (this.condition(shape, time)) {
                    var target_1 = this.target(shape, time);
                    if (target_1 != null) {
                        var initial_1 = this.initial(shape, time);
                        this.isOpened = true;
                        setTimeout(function () {
                            _this.open(target_1, initial_1).then(function (value) {
                                _this.isOpened = false;
                                EShapeActionValueOnInputActions.execute(shape, _this.onInputAction, target_1, value, time);
                            }, function () {
                                _this.isOpened = false;
                            });
                        }, 0);
                    }
                }
            }
        };
        return EShapeActionRuntimeOpenDialog;
    }(EShapeActionRuntimeOpen));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogBoolean = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogBoolean, _super);
        function EShapeActionRuntimeOpenDialogBoolean(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofBooleanOrFalse(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogBoolean.prototype.open = function (target, initial) {
            var dialog = EShapeActionRuntimeOpenDialogBoolean.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputBoolean({
                    label: target
                });
                EShapeActionRuntimeOpenDialogBoolean.DIALOG = dialog;
            }
            else {
                var label = dialog.label;
                if (label) {
                    label.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open();
        };
        return EShapeActionRuntimeOpenDialogBoolean;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DHtmlElement = /** @class */ (function (_super) {
        __extends(DHtmlElement, _super);
        function DHtmlElement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DHtmlElement.prototype.getUtil = function () {
            var result = this._util;
            if (result == null) {
                result = this.newUtil();
                this._util = result;
            }
            return result;
        };
        DHtmlElement.prototype.newUtil = function () {
            return new UtilHtmlElement(this, this.newOperation(), this.theme, this._options);
        };
        DHtmlElement.prototype.newOperation = function () {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(resolution, work, result);
                },
                getElementMatrix: function () {
                    return null;
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperRect(resolution, work, result);
                },
                getPadding: function () {
                    return _this.padding;
                },
                containsPoint: function (point) {
                    return _this.containsPoint(point);
                },
                onStart: function () {
                    // DO NOTHING
                },
                onCancel: function () {
                    // DO NOTHING
                },
                onEnd: function () {
                    // DO NOTHING
                }
            };
        };
        Object.defineProperty(DHtmlElement.prototype, "element", {
            get: function () {
                return this.getUtil().element;
            },
            enumerable: false,
            configurable: true
        });
        DHtmlElement.prototype.onDownThis = function (e) {
            var util = this.getUtil();
            util.onDownThisBefore(e);
            _super.prototype.onDownThis.call(this, e);
            util.onDownThisAfter(e);
        };
        DHtmlElement.prototype.onDblClick = function (e, interactionManager) {
            this.getUtil().onDblClick(e, interactionManager);
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DHtmlElement.prototype.onFocus = function () {
            _super.prototype.onFocus.call(this);
            this.getUtil().onFocus();
        };
        DHtmlElement.prototype.onBlur = function () {
            _super.prototype.onBlur.call(this);
            this.getUtil().onBlur();
        };
        DHtmlElement.prototype.start = function () {
            this.getUtil().start();
        };
        DHtmlElement.prototype.render = function (renderer) {
            this.getUtil().onRender(renderer);
            _super.prototype.render.call(this, renderer);
        };
        /**
         * Please note that this method does not update transforms.
         *
         * @param resolution
         */
        DHtmlElement.prototype.getElementRect = function (resolution, point, result) {
            point.set(0, 0);
            this.toGlobal(point, point, false);
            result.x = point.x;
            result.y = point.y;
            point.set(this.width, this.height);
            this.toGlobal(point, point, true);
            result.width = point.x - result.x;
            result.height = point.y - result.y;
            // Rounds pixels as Pixi.js does
            result.x = ((result.x * resolution) | 0) / resolution;
            result.y = ((result.y * resolution) | 0) / resolution;
            return result;
        };
        DHtmlElement.prototype.getClipperRect = function (resolution, point, result) {
            return UtilHtmlElement.getClipperRect(this.parent, this, resolution, point, result);
        };
        DHtmlElement.prototype.cancel = function () {
            this.getUtil().cancel();
        };
        DHtmlElement.prototype.end = function () {
            this.getUtil().end();
        };
        DHtmlElement.prototype.select = function () {
            this.getUtil().select();
            return this;
        };
        DHtmlElement.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        };
        DHtmlElement.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.start();
                }
                this.state.isPressed = false;
            }
        };
        DHtmlElement.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DHtmlElement.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DHtmlElement.prototype.getType = function () {
            return "DHtmlElement";
        };
        return DHtmlElement;
    }(DImageBase));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInput = /** @class */ (function (_super) {
        __extends(DInput, _super);
        function DInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInput.prototype.newOperation = function () {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(resolution, work, result);
                },
                getElementMatrix: function () {
                    return null;
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperRect(resolution, work, result);
                },
                getPadding: function () {
                    return _this.padding;
                },
                containsPoint: function (point) {
                    return _this.containsPoint(point);
                },
                onStart: function () {
                    _this.hideText();
                },
                onCancel: function () {
                    _this.showText();
                },
                onEnd: function () {
                    // DO NOTHING
                },
                getValue: function () {
                    return _this._textValueComputed;
                },
                onValueInput: function (newValue) {
                    _this.onValueInput(newValue);
                },
                onValueChange: function (newValue, oldValue) {
                    _this.text = newValue;
                    _this.onValueChange(newValue, oldValue);
                },
                onEnter: function () {
                    _this.onEnter();
                },
                applyTitle: function () {
                    _this.applyTitle();
                }
            };
        };
        Object.defineProperty(DInput.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DInput.prototype.onTextChange = function () {
            _super.prototype.onTextChange.call(this);
            this.validate();
        };
        DInput.prototype.onValueChange = function (newValue, oldValue) {
            this.emit("change", newValue, oldValue, this);
        };
        DInput.prototype.onValueInput = function (newValue) {
            this.emit("input", newValue, this);
        };
        DInput.prototype.onEnter = function () {
            this.emit("enter", this);
        };
        DInput.prototype.validate = function () {
            return this.getUtil().validate();
        };
        DInput.prototype.applyTitle = function () {
            if (!this.getUtil().applyTitle()) {
                _super.prototype.applyTitle.call(this);
            }
        };
        DInput.prototype.getType = function () {
            return "DInput";
        };
        return DInput;
    }(DHtmlElement));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputNumber = /** @class */ (function (_super) {
        __extends(DInputNumber, _super);
        function DInputNumber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputNumber.prototype.newUtil = function () {
            return new UtilInputNumber(this, this.newOperation(), this.theme, this._options);
        };
        Object.defineProperty(DInputNumber.prototype, "step", {
            get: function () {
                return this.getUtil().step;
            },
            set: function (step) {
                this.getUtil().step = step;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DInputNumber.prototype, "min", {
            get: function () {
                return this.getUtil().min;
            },
            set: function (min) {
                this.getUtil().min = min;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DInputNumber.prototype, "max", {
            get: function () {
                return this.getUtil().max;
            },
            set: function (max) {
                this.getUtil().max = max;
            },
            enumerable: false,
            configurable: true
        });
        return DInputNumber;
    }(DInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputInteger = /** @class */ (function (_super) {
        __extends(DInputInteger, _super);
        function DInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputInteger.prototype.getType = function () {
            return "DInputInteger";
        };
        return DInputInteger;
    }(DInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputInteger = /** @class */ (function (_super) {
        __extends(DDialogInputInteger, _super);
        function DDialogInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputInteger.prototype.newInput = function (options) {
            var _this = this;
            var result = new DInputInteger(this.toInputOptions(options));
            result.on("enter", function () {
                _this.ok();
            });
            return result;
        };
        DDialogInputInteger.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputInteger.prototype.getType = function () {
            return "DDialogInputInteger";
        };
        return DDialogInputInteger;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogInteger = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogInteger, _super);
        function EShapeActionRuntimeOpenDialogInteger(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofNumber(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogInteger.prototype.open = function (target, initial) {
            var dialog = EShapeActionRuntimeOpenDialogInteger.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputInteger({
                    label: target
                });
                EShapeActionRuntimeOpenDialogInteger.DIALOG = dialog;
            }
            else {
                var label = dialog.label;
                if (label) {
                    label.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open();
        };
        return EShapeActionRuntimeOpenDialogInteger;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputReal = /** @class */ (function (_super) {
        __extends(DInputReal, _super);
        function DInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputReal.prototype.getType = function () {
            return "DInputReal";
        };
        return DInputReal;
    }(DInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputReal = /** @class */ (function (_super) {
        __extends(DDialogInputReal, _super);
        function DDialogInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputReal.prototype.newInput = function (options) {
            var _this = this;
            var result = new DInputReal(this.toInputOptions(options));
            result.on("enter", function () {
                _this.ok();
            });
            return result;
        };
        DDialogInputReal.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputReal.prototype.getType = function () {
            return "DDialogInputReal";
        };
        return DDialogInputReal;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogReal = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogReal, _super);
        function EShapeActionRuntimeOpenDialogReal(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofNumber(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogReal.prototype.open = function (target, initial) {
            var dialog = EShapeActionRuntimeOpenDialogReal.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputReal({
                    label: target
                });
                EShapeActionRuntimeOpenDialogReal.DIALOG = dialog;
            }
            else {
                var label = dialog.label;
                if (label) {
                    label.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open();
        };
        return EShapeActionRuntimeOpenDialogReal;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputText = /** @class */ (function (_super) {
        __extends(DInputText, _super);
        function DInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputText.prototype.newUtil = function () {
            return new UtilInputText(this, this.newOperation(), this.theme, this._options);
        };
        DInputText.prototype.getType = function () {
            return "DInputText";
        };
        return DInputText;
    }(DInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputText = /** @class */ (function (_super) {
        __extends(DDialogInputText, _super);
        function DDialogInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputText.prototype.newInput = function (options) {
            var _this = this;
            var result = new DInputText(this.toInputOptions(options));
            result.on("enter", function () {
                _this.ok();
            });
            return result;
        };
        DDialogInputText.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputText.prototype.getType = function () {
            return "DDialogInputText";
        };
        return DDialogInputText;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogText, _super);
        function EShapeActionRuntimeOpenDialogText(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofString(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogText.prototype.open = function (target, initial) {
            var dialog = EShapeActionRuntimeOpenDialogText.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputText({
                    label: target
                });
                EShapeActionRuntimeOpenDialogText.DIALOG = dialog;
            }
            else {
                var label = dialog.label;
                if (label) {
                    label.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open();
        };
        return EShapeActionRuntimeOpenDialogText;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDiagram = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDiagram, _super);
        function EShapeActionRuntimeOpenDiagram(value) {
            return _super.call(this, value, EShapeRuntimeReset.NONE) || this;
        }
        EShapeActionRuntimeOpenDiagram.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var target = this.target(shape, time);
                if (target != null) {
                    EShapeActionRuntimes.open(shape, target);
                }
            }
        };
        return EShapeActionRuntimeOpenDiagram;
    }(EShapeActionRuntimeOpen));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenPage = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenPage, _super);
        function EShapeActionRuntimeOpenPage(value) {
            return _super.call(this, value, EShapeRuntimeReset.NONE) || this;
        }
        EShapeActionRuntimeOpenPage.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var target = this.target(shape, time);
                if (target != null) {
                    window.open(target);
                }
            }
        };
        return EShapeActionRuntimeOpenPage;
    }(EShapeActionRuntimeOpen));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenPageInplace = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenPageInplace, _super);
        function EShapeActionRuntimeOpenPageInplace(value) {
            return _super.call(this, value, EShapeRuntimeReset.NONE) || this;
        }
        EShapeActionRuntimeOpenPageInplace.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var target = this.target(shape, time);
                if (target != null) {
                    window.location.href = target;
                }
            }
        };
        return EShapeActionRuntimeOpenPageInplace;
    }(EShapeActionRuntimeOpen));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenType;
    (function (EShapeActionValueOpenType) {
        EShapeActionValueOpenType[EShapeActionValueOpenType["DIAGRAM"] = 0] = "DIAGRAM";
        EShapeActionValueOpenType[EShapeActionValueOpenType["PAGE"] = 1] = "PAGE";
        EShapeActionValueOpenType[EShapeActionValueOpenType["PAGE_INPLACE"] = 2] = "PAGE_INPLACE";
        EShapeActionValueOpenType[EShapeActionValueOpenType["DIALOG_TEXT"] = 3] = "DIALOG_TEXT";
        EShapeActionValueOpenType[EShapeActionValueOpenType["DIALOG_INTEGER"] = 4] = "DIALOG_INTEGER";
        EShapeActionValueOpenType[EShapeActionValueOpenType["DIALOG_REAL"] = 5] = "DIALOG_REAL";
        EShapeActionValueOpenType[EShapeActionValueOpenType["DIALOG_BOOLEAN"] = 6] = "DIALOG_BOOLEAN";
        EShapeActionValueOpenType[EShapeActionValueOpenType["DIALOG_DATE"] = 7] = "DIALOG_DATE";
        EShapeActionValueOpenType[EShapeActionValueOpenType["DIALOG_TIME"] = 8] = "DIALOG_TIME";
        EShapeActionValueOpenType[EShapeActionValueOpenType["DIALOG_DATETIME"] = 9] = "DIALOG_DATETIME";
    })(EShapeActionValueOpenType || (EShapeActionValueOpenType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonAmbient = /** @class */ (function (_super) {
        __extends(DButtonAmbient, _super);
        function DButtonAmbient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonAmbient.prototype.getType = function () {
            return "DButtonAmbient";
        };
        return DButtonAmbient;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonBack = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonBack, _super);
        function DPickerDatetimeButtonBack() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonBack.prototype.getType = function () {
            return "DPickerDatetimeButtonBack";
        };
        return DPickerDatetimeButtonBack;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonDate = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonDate, _super);
        function DPickerDatetimeButtonDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonDate.prototype.getType = function () {
            return "DPickerDatetimeButtonDate";
        };
        return DPickerDatetimeButtonDate;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonNext = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonNext, _super);
        function DPickerDatetimeButtonNext() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonNext.prototype.getType = function () {
            return "DPickerDatetimeButtonNext";
        };
        return DPickerDatetimeButtonNext;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeLabel = /** @class */ (function (_super) {
        __extends(DPickerDatetimeLabel, _super);
        function DPickerDatetimeLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeLabel.prototype.getType = function () {
            return "DPickerDatetimeLabel";
        };
        return DPickerDatetimeLabel;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeLabelDate = /** @class */ (function (_super) {
        __extends(DPickerDatetimeLabelDate, _super);
        function DPickerDatetimeLabelDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeLabelDate.prototype.getType = function () {
            return "DPickerDatetimeLabelDate";
        };
        return DPickerDatetimeLabelDate;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeSpace = /** @class */ (function (_super) {
        __extends(DPickerDatetimeSpace, _super);
        function DPickerDatetimeSpace(options) {
            var _this = _super.call(this, options) || this;
            _this.state.isFocusable = false;
            _this.renderable = false;
            return _this;
        }
        DPickerDatetimeSpace.prototype.getType = function () {
            return "DPickerDatetimeSpace";
        };
        return DPickerDatetimeSpace;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeMask;
    (function (DPickerDatetimeMask) {
        DPickerDatetimeMask[DPickerDatetimeMask["NONE"] = 0] = "NONE";
        DPickerDatetimeMask[DPickerDatetimeMask["DATE"] = 1] = "DATE";
        DPickerDatetimeMask[DPickerDatetimeMask["HOURS"] = 2] = "HOURS";
        DPickerDatetimeMask[DPickerDatetimeMask["MINUTES"] = 4] = "MINUTES";
        DPickerDatetimeMask[DPickerDatetimeMask["SECONDS"] = 8] = "SECONDS";
        DPickerDatetimeMask[DPickerDatetimeMask["TIME"] = 14] = "TIME";
        DPickerDatetimeMask[DPickerDatetimeMask["ALL"] = 15] = "ALL";
    })(DPickerDatetimeMask || (DPickerDatetimeMask = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeMasks = /** @class */ (function () {
        function DPickerDatetimeMasks() {
        }
        DPickerDatetimeMasks.from = function (themeOrThemeName, options) {
            var mask = options === null || options === void 0 ? void 0 : options.mask;
            if (mask == null) {
                if (isString(themeOrThemeName)) {
                    var theme = DThemes.getInstance().get(themeOrThemeName);
                    if (theme != null) {
                        return theme.getMask();
                    }
                }
                else if (themeOrThemeName != null) {
                    return themeOrThemeName.getMask();
                }
                return DPickerDatetimeMask.NONE;
            }
            else if (isString(mask)) {
                return DPickerDatetimeMask[mask];
            }
            else if (isNumber(mask)) {
                return mask;
            }
            var result = DPickerDatetimeMask.NONE;
            for (var i = 0, imax = mask.length; i < imax; ++i) {
                result |= DPickerDatetimeMask[mask[i]];
            }
            return result;
        };
        return DPickerDatetimeMasks;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBound = /** @class */ (function () {
        function DPickerTimeBound(options, onChange) {
            var _a, _b;
            this._date = (_a = options === null || options === void 0 ? void 0 : options.date) !== null && _a !== void 0 ? _a : null;
            this._inclusive = (_b = options === null || options === void 0 ? void 0 : options.inclusive) !== null && _b !== void 0 ? _b : false;
            this._onChange = onChange;
        }
        Object.defineProperty(DPickerTimeBound.prototype, "date", {
            get: function () {
                return this._date;
            },
            set: function (date) {
                if (this._date !== date) {
                    this._date = date;
                    this._onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerTimeBound.prototype, "inclusive", {
            get: function () {
                return this._inclusive;
            },
            set: function (inclusive) {
                if (this._inclusive !== inclusive) {
                    this._inclusive = inclusive;
                    this._onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        return DPickerTimeBound;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundHours = /** @class */ (function () {
        function DPickerTimeBoundHours(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundHours.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.hour.min;
                    }
                }
                var lowerDateHours = lowerDate.getHours();
                if (lower.inclusive) {
                    return lowerDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (lowerDate.getMinutes() < constant.minute.max) {
                            return lowerDateHours;
                        }
                    }
                    return lowerDateHours + 1;
                }
            }
            return constant.hour.min;
        };
        DPickerTimeBoundHours.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.hour.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.hour.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.hour.max;
                    }
                }
                var upperDateHours = upperDate.getHours();
                if (upper.inclusive) {
                    return upperDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (constant.minute.min < upperDate.getMinutes()) {
                            return upperDateHours;
                        }
                    }
                    return upperDateHours - 1;
                }
            }
            return constant.hour.max;
        };
        return DPickerTimeBoundHours;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundMinutes = /** @class */ (function () {
        function DPickerTimeBoundMinutes(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundMinutes.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.minute.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.minute.min;
                    }
                }
                var lowerDateMinutes = lowerDate.getMinutes();
                if (lower.inclusive) {
                    return lowerDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateMinutes;
                        }
                    }
                    return lowerDateMinutes + 1;
                }
            }
            return constant.minute.min;
        };
        DPickerTimeBoundMinutes.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.minute.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.minute.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.minute.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.minute.max;
                    }
                }
                var upperDateMinutes = upperDate.getMinutes();
                if (upper.inclusive) {
                    return upperDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateMinutes;
                        }
                    }
                    return upperDateMinutes - 1;
                }
            }
            return constant.minute.max;
        };
        return DPickerTimeBoundMinutes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundSeconds = /** @class */ (function () {
        function DPickerTimeBoundSeconds(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundSeconds.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (lowerDate.getMinutes() < date.getMinutes()) {
                        return constant.second.min;
                    }
                }
                return lowerDate.getSeconds() + (lower.inclusive ? 0 : 1);
            }
            return constant.second.min;
        };
        DPickerTimeBoundSeconds.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.second.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.second.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (date.getMinutes() < upperDate.getMinutes()) {
                        return constant.second.max;
                    }
                }
                return upperDate.getSeconds() - (upper.inclusive ? 0 : 1);
            }
            return constant.second.max;
        };
        return DPickerTimeBoundSeconds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBounds = /** @class */ (function () {
        function DPickerTimeBounds(options, onChange) {
            this.constant = this.newConstant();
            this.lower = new DPickerTimeBound(options && options.lower, onChange);
            this.upper = new DPickerTimeBound(options && options.upper, onChange);
            this.mask = DPickerDatetimeMask.ALL;
            this.hours = new DPickerTimeBoundHours(this);
            this.minutes = new DPickerTimeBoundMinutes(this);
            this.seconds = new DPickerTimeBoundSeconds(this);
        }
        DPickerTimeBounds.prototype.newConstant = function () {
            return {
                second: {
                    min: 0,
                    max: 59
                },
                minute: {
                    min: 0,
                    max: 59
                },
                hour: {
                    min: 0,
                    max: 23
                }
            };
        };
        DPickerTimeBounds.prototype.adjust = function (date) {
            var result = this.test(date);
            if (result < 0) {
                var lower = this.lower;
                var lowerDate = lower.date;
                if (lowerDate) {
                    date.setTime(lowerDate.getTime());
                    if (!lower.inclusive) {
                        var mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(lowerDate.getSeconds() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(lowerDate.getMinutes() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(lowerDate.getHours() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(lowerDate.getDate() + 1);
                        }
                    }
                    return true;
                }
            }
            else if (0 < result) {
                var upper = this.upper;
                var upperDate = upper.date;
                if (upperDate) {
                    date.setTime(upperDate.getTime());
                    if (!upper.inclusive) {
                        var mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(upperDate.getSeconds() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(upperDate.getMinutes() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(upperDate.getHours() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(upperDate.getDate() - 1);
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        DPickerTimeBounds.prototype.compare = function (a, b) {
            var mask = this.mask;
            if (mask & DPickerDatetimeMask.DATE) {
                var ay = a.getFullYear();
                var by = b.getFullYear();
                if (ay !== by) {
                    return ay < by ? -1 : +1;
                }
                var am = a.getMonth();
                var bm = b.getMonth();
                if (am !== bm) {
                    return am < bm ? -1 : +1;
                }
                var ad = a.getDate();
                var bd = b.getDate();
                if (ad !== bd) {
                    return ad < bd ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.HOURS) {
                var ah = a.getHours();
                var bh = b.getHours();
                if (ah !== bh) {
                    return ah < bh ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                var am = a.getMinutes();
                var bm = b.getMinutes();
                if (am !== bm) {
                    return am < bm ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                var ad = a.getSeconds();
                var bd = b.getSeconds();
                if (ad !== bd) {
                    return ad < bd ? -1 : +1;
                }
            }
            return 0;
        };
        DPickerTimeBounds.prototype.test = function (date) {
            // Lower bound
            var lower = this.lower;
            var lowerDate = lower.date;
            if (lowerDate != null) {
                var result = this.compare(lowerDate, date);
                if (lower.inclusive) {
                    return result <= 0 ? 0 : -1;
                }
                else {
                    return result < 0 ? 0 : -1;
                }
            }
            // Upper bound
            var upper = this.upper;
            var upperDate = upper.date;
            if (upperDate != null) {
                var result = this.compare(date, upperDate);
                if (upper.inclusive) {
                    return result <= 0 ? 0 : +1;
                }
                else {
                    return result < 0 ? 0 : +1;
                }
            }
            return 0;
        };
        DPickerTimeBounds.prototype.contains = function (date) {
            return this.test(date) === 0;
        };
        return DPickerTimeBounds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toBoundOptions = function (options, defaultDate, defaultInclusive) {
        if (options) {
            var date = options.date;
            var inclusive = options.inclusive;
            return {
                date: date !== undefined ? date : defaultDate,
                inclusive: inclusive !== undefined ? inclusive : defaultInclusive
            };
        }
        return {
            date: defaultDate,
            inclusive: defaultInclusive
        };
    };
    var toBoundsOptions = function (theme, options) {
        if (options) {
            return {
                lower: toBoundOptions(options.lower, theme.getLowerBound(), theme.isLowerBoundInclusive()),
                upper: toBoundOptions(options.upper, theme.getUpperBound(), theme.isUpperBoundInclusive())
            };
        }
        return {
            lower: {
                date: theme.getLowerBound(),
                inclusive: theme.isLowerBoundInclusive()
            },
            upper: {
                date: theme.getUpperBound(),
                inclusive: theme.isUpperBoundInclusive()
            }
        };
    };
    var DPickerTime = /** @class */ (function (_super) {
        __extends(DPickerTime, _super);
        function DPickerTime(options) {
            var _this = _super.call(this, options) || this;
            _this.onNewChange();
            return _this;
        }
        DPickerTime.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
            var theme = this.theme;
            this._dateCurrent = new Date();
            var dateCurrentTime = this._dateCurrent.getTime();
            this._dateNew = new Date(dateCurrentTime);
            this._dateBounds = new DPickerTimeBounds(toBoundsOptions(theme, options === null || options === void 0 ? void 0 : options.bounds), function () {
                _this.onNewChange();
            });
            var margin = (_a = options === null || options === void 0 ? void 0 : options.margin) !== null && _a !== void 0 ? _a : theme.getMargin();
            new DLayoutVertical({
                parent: this,
                x: "padding",
                y: "padding",
                width: "auto",
                height: "auto",
                margin: margin,
                children: this.newChildren(theme, options, margin)
            });
        };
        Object.defineProperty(DPickerTime.prototype, "current", {
            get: function () {
                return this._dateCurrent;
            },
            set: function (dateCurrent) {
                if (this._dateCurrent.getTime() !== dateCurrent.getTime()) {
                    this._dateCurrent = dateCurrent;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerTime.prototype, "new", {
            get: function () {
                return this._dateNew;
            },
            set: function (dateNew) {
                if (this._dateNew.getTime() !== dateNew.getTime()) {
                    this._dateNew = dateNew;
                    this.onNewChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerTime.prototype, "bounds", {
            get: function () {
                return this._dateBounds;
            },
            enumerable: false,
            configurable: true
        });
        DPickerTime.prototype.hasHours = function () {
            return this._inputHours != null;
        };
        DPickerTime.prototype.hasMinutes = function () {
            return this._inputMinutes != null;
        };
        DPickerTime.prototype.hasSeconds = function () {
            return this._inputSeconds != null;
        };
        DPickerTime.prototype.reset = function () {
            var currentTime = this._dateCurrent.getTime();
            this._dateNew.setTime(currentTime);
            this.onReset();
        };
        DPickerTime.prototype.onReset = function () {
            this.onNewChange();
        };
        DPickerTime.prototype.onNewChange = function () {
            var dateNew = this._dateNew;
            var dateBounds = this._dateBounds;
            dateBounds.adjust(this._dateNew);
            var inputHours = this._inputHours;
            if (inputHours) {
                var hours = dateBounds.hours;
                inputHours.value = dateNew.getHours();
                inputHours.min = hours.min(dateNew);
                inputHours.max = hours.max(dateNew);
            }
            var inputMinutes = this._inputMinutes;
            if (inputMinutes) {
                var minutes = dateBounds.minutes;
                inputMinutes.value = dateNew.getMinutes();
                inputMinutes.min = minutes.min(dateNew);
                inputMinutes.max = minutes.max(dateNew);
            }
            var inputSeconds = this._inputSeconds;
            if (inputSeconds) {
                var seconds = dateBounds.seconds;
                inputSeconds.value = dateNew.getSeconds();
                inputSeconds.min = seconds.min(dateNew);
                inputSeconds.max = seconds.max(dateNew);
            }
        };
        DPickerTime.prototype.newChildren = function (theme, options, margin) {
            var mask = DPickerDatetimeMasks.from(theme, options);
            this._dateBounds.mask = mask;
            this._inputHours =
                mask & DPickerDatetimeMask.HOURS ? this.newInputHours(theme, options) : null;
            this._inputMinutes =
                mask & DPickerDatetimeMask.MINUTES ? this.newInputMinutes(theme, options) : null;
            this._inputSeconds =
                mask & DPickerDatetimeMask.SECONDS ? this.newInputSeconds(theme, options) : null;
            return [
                this.newTimeLayout(this._inputHours, this._inputMinutes, this._inputSeconds, margin)
            ];
        };
        DPickerTime.prototype.newTimeLayout = function (hours, minutes, seconds, margin) {
            var children = this.newTimeLayoutChildren(hours, minutes, seconds);
            if (0 < children.length) {
                return new DLayoutHorizontal({
                    width: this.getTimeLayoutWidth(),
                    height: this.getTimeLayoutHeight(),
                    margin: margin,
                    children: children
                });
            }
            return null;
        };
        DPickerTime.prototype.getTimeLayoutWidth = function () {
            return "auto";
        };
        DPickerTime.prototype.getTimeLayoutHeight = function () {
            return "auto";
        };
        DPickerTime.prototype.newTimeLayoutChildren = function (hours, minutes, seconds) {
            var result = [];
            if (hours != null) {
                result.push(hours);
            }
            if (minutes != null) {
                if (0 < result.length) {
                    result.push(this.newMinuteSeparator());
                }
                result.push(minutes);
            }
            if (seconds != null) {
                if (0 < result.length) {
                    result.push(this.newSecondSeparator());
                }
                result.push(seconds);
            }
            return result;
        };
        DPickerTime.prototype.newMinuteSeparator = function () {
            return new DText({
                width: "auto",
                text: {
                    value: this.getMinuteSeparator()
                }
            });
        };
        DPickerTime.prototype.getMinuteSeparator = function () {
            return ":";
        };
        DPickerTime.prototype.newSecondSeparator = function () {
            return new DText({
                width: "auto",
                text: {
                    value: this.getSecondSeparator()
                }
            });
        };
        DPickerTime.prototype.getSecondSeparator = function () {
            return ":";
        };
        DPickerTime.prototype.adjustInputOptions = function (theme, options, max) {
            if (options.step == null) {
                options.step = 1;
            }
            if (options.min == null) {
                options.min = 0;
            }
            if (options.max == null) {
                options.max = max;
            }
            return options;
        };
        DPickerTime.prototype.newInputHours = function (theme, options) {
            var _this = this;
            var _a;
            var inputOptions = (_a = options === null || options === void 0 ? void 0 : options.hours) !== null && _a !== void 0 ? _a : theme.getHoursOptions();
            var max = this._dateBounds.constant.hour.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onHoursChange(value);
            });
            return input;
        };
        DPickerTime.prototype.onHoursChange = function (value) {
            var dateNew = this._dateNew;
            dateNew.setHours(value);
            this.onNewChange();
        };
        DPickerTime.prototype.newInputMinutes = function (theme, options) {
            var _this = this;
            var inputOptions = (options === null || options === void 0 ? void 0 : options.minutes) || theme.getMinutesOptions();
            var max = this._dateBounds.constant.minute.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onMinutesChange(value);
            });
            return input;
        };
        DPickerTime.prototype.onMinutesChange = function (value) {
            var dateNew = this._dateNew;
            dateNew.setMinutes(value);
            this.onNewChange();
        };
        DPickerTime.prototype.newInputSeconds = function (theme, options) {
            var _this = this;
            var inputOptions = (options === null || options === void 0 ? void 0 : options.seconds) || theme.getSecondsOptions();
            var max = this._dateBounds.constant.second.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onSecondsChange(value);
            });
            return input;
        };
        DPickerTime.prototype.onSecondsChange = function (value) {
            this._dateNew.setSeconds(value);
        };
        DPickerTime.prototype.getType = function () {
            return "DPickerTime";
        };
        return DPickerTime;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetime = /** @class */ (function (_super) {
        __extends(DPickerDatetime, _super);
        function DPickerDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetime.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._datePage = new Date(this._dateCurrent.getTime());
        };
        DPickerDatetime.prototype.newChildren = function (theme, options, margin) {
            var _a, _b;
            this._dateButtons = this.newDateButtons(theme, options);
            this._dateDecorator = (_b = (_a = options === null || options === void 0 ? void 0 : options.date) === null || _a === void 0 ? void 0 : _a.decorator) !== null && _b !== void 0 ? _b : theme.getDateDecorator();
            this._label = this.newLabel(theme, options);
            var result = _super.prototype.newChildren.call(this, theme, options, margin);
            result.unshift(new DLayoutHorizontal({
                width: "100%",
                height: "auto",
                children: [
                    this.newBackButton(theme, options),
                    this._label,
                    this.newNextButton(theme, options)
                ]
            }), new DLayoutHorizontal({
                width: "auto",
                height: "auto",
                margin: margin,
                children: this.newDateLabels(theme, options)
            }), new DLayoutVertical({
                width: "auto",
                height: "auto",
                margin: margin,
                column: 7,
                children: this._dateButtons
            }));
            return result;
        };
        Object.defineProperty(DPickerDatetime.prototype, "page", {
            get: function () {
                return this._datePage;
            },
            set: function (datePage) {
                if (this._datePage.getTime() !== datePage.getTime()) {
                    this._datePage = datePage;
                    this.onPageChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DPickerDatetime.prototype.onReset = function () {
            this._datePage.setTime(this._dateCurrent.getTime());
            _super.prototype.onReset.call(this);
        };
        DPickerDatetime.prototype.next = function () {
            var work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() + 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChange();
        };
        DPickerDatetime.prototype.back = function () {
            var work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() - 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChange();
        };
        DPickerDatetime.prototype.onNewChange = function () {
            this._dateBounds.adjust(this._datePage);
            _super.prototype.onNewChange.call(this);
            this.onPageChange();
        };
        DPickerDatetime.prototype.onPageChange = function () {
            var buttons = this._dateButtons;
            var bounds = this._dateBounds;
            var datePage = this._datePage;
            var dateNew = this._dateNew;
            var tmp = new Date(datePage.getTime());
            tmp.setDate(1);
            tmp.setHours(0, 0, 0, 0);
            // Spaces
            var theme = this.theme;
            var spaceCount = (tmp.getDay() - theme.getDayStart() + 7) % 7;
            for (var i = 0; i < spaceCount; ++i) {
                buttons[i].show();
            }
            for (var i = spaceCount; i < 7; ++i) {
                buttons[i].hide();
            }
            // Date buttons
            var dateDecorator = this._dateDecorator;
            tmp.setFullYear(tmp.getFullYear(), tmp.getMonth() + 1, 0);
            var dateCount = tmp.getDate();
            var dateNewDate = dateNew.getFullYear() === tmp.getFullYear() && dateNew.getMonth() === tmp.getMonth()
                ? dateNew.getDate()
                : 0;
            for (var i = 0; i < dateCount; ++i) {
                tmp.setDate(i + 1);
                var button = buttons[i + 7];
                button.state.isActive = dateNewDate === i + 1;
                button.state.isDisabled = !bounds.contains(tmp);
                button.show();
                dateDecorator(tmp, button);
            }
            for (var i = dateCount; i < 31; ++i) {
                var button = buttons[i + 7];
                button.state.isActive = false;
                button.hide();
            }
            // Label
            tmp.setTime(datePage.getTime());
            this._label.text = tmp;
        };
        DPickerDatetime.prototype.adjustInputOptions = function (theme, options, max) {
            if (options.weight == null) {
                options.weight = 1;
            }
            return _super.prototype.adjustInputOptions.call(this, theme, options, max);
        };
        DPickerDatetime.prototype.getTimeLayoutWidth = function () {
            return "100%";
        };
        DPickerDatetime.prototype.toLabelOptions = function (theme, options) {
            var result = (options && options.label) || {};
            if (result.weight === undefined) {
                result.weight = 1;
            }
            if (result.padding === undefined) {
                result.padding = 0;
            }
            var labelText = (result.text = result.text || {});
            var labelTextAlign = (labelText.align = labelText.align || {});
            if (labelTextAlign.horizontal === undefined) {
                labelTextAlign.horizontal = "CENTER";
            }
            if (labelText.formatter === undefined) {
                labelText.formatter = theme.getLabelFormatter();
            }
            return result;
        };
        DPickerDatetime.prototype.newLabel = function (theme, options) {
            return new DPickerDatetimeLabel(this.toLabelOptions(theme, options));
        };
        DPickerDatetime.prototype.newBackButton = function (theme, options) {
            var _this = this;
            var buttonOptions = options === null || options === void 0 ? void 0 : options.back;
            if (buttonOptions === undefined) {
                buttonOptions = theme.getBackButtonOptions();
            }
            if (buttonOptions != null) {
                var button = new DPickerDatetimeButtonBack(buttonOptions);
                button.on("active", function () {
                    _this.back();
                });
                return button;
            }
            return null;
        };
        DPickerDatetime.prototype.newNextButton = function (theme, options) {
            var _this = this;
            var buttonOptions = options === null || options === void 0 ? void 0 : options.next;
            if (buttonOptions === undefined) {
                buttonOptions = theme.getNextButtonOptions();
            }
            if (buttonOptions != null) {
                var button = new DPickerDatetimeButtonNext(buttonOptions);
                button.on("active", function () {
                    _this.next();
                });
                return button;
            }
            return null;
        };
        DPickerDatetime.prototype.newDateLabels = function (theme, options) {
            var dateLabels = theme.getDayLabels();
            var dayStart = theme.getDayStart();
            var result = [];
            for (var i = 0; i < 7; ++i) {
                var label = dateLabels[(dayStart + i) % 7];
                result.push(this.newDateLabel(theme, options, label));
            }
            return result;
        };
        DPickerDatetime.prototype.newDateLabel = function (theme, options, label) {
            return new DPickerDatetimeLabelDate({
                text: {
                    value: label
                }
            });
        };
        DPickerDatetime.prototype.newDateButtons = function (theme, options) {
            var result = [];
            for (var i = 0; i < 7; ++i) {
                result.push(this.newSpace(theme, options));
            }
            for (var i = 1; i <= 31; ++i) {
                result.push(this.newDateButton(theme, options, i));
            }
            return result;
        };
        DPickerDatetime.prototype.newSpace = function (theme, options) {
            return new DPickerDatetimeSpace();
        };
        DPickerDatetime.prototype.newDateButton = function (theme, options, date) {
            var _this = this;
            return new DPickerDatetimeButtonDate({
                text: {
                    value: String(date)
                },
                on: {
                    active: function () {
                        _this.onDateButtonClicked(date);
                    }
                }
            });
        };
        DPickerDatetime.prototype.onDateButtonClicked = function (date) {
            var dateNew = this._dateNew;
            if (dateNew.getDate() !== date) {
                var datePage = this._datePage;
                dateNew.setFullYear(datePage.getFullYear());
                dateNew.setMonth(datePage.getMonth());
                dateNew.setDate(date);
                this.onNewChange();
            }
        };
        DPickerDatetime.prototype.getType = function () {
            return "DPickerDatetime";
        };
        return DPickerDatetime;
    }(DPickerTime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDatetime = /** @class */ (function (_super) {
        __extends(DDialogDatetime, _super);
        function DDialogDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogDatetime.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            layout.addChild(this.picker);
        };
        Object.defineProperty(DDialogDatetime.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            set: function (dateCurrent) {
                this.picker.current = dateCurrent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            set: function (value) {
                this.picker.new = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "page", {
            get: function () {
                return this.picker.new;
            },
            set: function (page) {
                this.picker.page = page;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerDatetime((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogDatetime.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogDatetime.prototype.getType = function () {
            return "DDialogDatetime";
        };
        return DDialogDatetime;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogDatetime = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogDatetime, _super);
        function EShapeActionRuntimeOpenDialogDatetime(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofUnknown(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogDatetime.prototype.open = function (target, initial) {
            var dialog = EShapeActionRuntimeOpenDialogDatetime.DIALOG;
            if (dialog == null) {
                dialog = new DDialogDatetime();
                EShapeActionRuntimeOpenDialogDatetime.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open().then(function (value) {
                return value.toISOString();
            });
        };
        EShapeActionRuntimeOpenDialogDatetime.prototype.toDate = function (value) {
            if (isString(value) || isNumber(value)) {
                return new Date(value);
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        };
        return EShapeActionRuntimeOpenDialogDatetime;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogTime = /** @class */ (function (_super) {
        __extends(DDialogTime, _super);
        function DDialogTime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogTime.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            layout.addChild(this.picker);
        };
        Object.defineProperty(DDialogTime.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            set: function (dateCurrent) {
                this.picker.current = dateCurrent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogTime.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            set: function (dateNew) {
                this.picker.new = dateNew;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogTime.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerTime((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogTime.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogTime.prototype.getType = function () {
            return "DDialogTime";
        };
        return DDialogTime;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isNaN = function (target) {
        return target !== target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogTime = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogTime, _super);
        function EShapeActionRuntimeOpenDialogTime(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofUnknown(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogTime.prototype.open = function (target, initial) {
            var _this = this;
            var dialog = EShapeActionRuntimeOpenDialogTime.DIALOG;
            if (dialog == null) {
                dialog = new DDialogTime();
                EShapeActionRuntimeOpenDialogTime.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open().then(function (value) {
                return _this.getFormatter().format(value.getTime(), 0);
            });
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toDate = function (value) {
            if (isNumber(value)) {
                return new Date(value);
            }
            else if (isString(value)) {
                var result = new Date();
                var pattern = this.getPattern();
                var matched = pattern.exec(value);
                if (matched != null) {
                    var hours = this.toHours(matched[1]);
                    if (hours != null) {
                        result.setHours(hours);
                    }
                    var minutes = this.toMinutes(matched[2]);
                    if (minutes != null) {
                        result.setMinutes(minutes);
                    }
                    var seconds = this.toSeconds(matched[3]);
                    if (seconds != null) {
                        result.setSeconds(seconds);
                    }
                    var milliseconds = this.toMilliseconds(matched[4]);
                    if (milliseconds != null) {
                        result.setMilliseconds(milliseconds);
                    }
                }
                return result;
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toHours = function (value) {
            return this.toNumber(value, 0, 23);
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toMinutes = function (value) {
            return this.toNumber(value, 0, 59);
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toSeconds = function (value) {
            return this.toNumber(value, 0, 59);
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toMilliseconds = function (value) {
            var result = this.toNumber(value, 0, 999);
            if (result != null) {
                var length_1 = value.length;
                if (length_1 === 1) {
                    return result * 100;
                }
                else if (length_1 === 2) {
                    return result * 10;
                }
                else {
                    return result;
                }
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toNumber = function (value, min, max) {
            if (value != null) {
                var num = +value;
                if (!isNaN(num)) {
                    return Math.min(max, Math.max(min, num));
                }
            }
            return null;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.getPattern = function () {
            var result = EShapeActionRuntimeOpenDialogTime.PATTERN;
            if (result == null) {
                result = this.newPattern();
                EShapeActionRuntimeOpenDialogTime.PATTERN = result;
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.newPattern = function () {
            return /^\s*(?:(\d+)(?::(\d+)(?::(\d+))?)?)?(?:\.(\d+))?\s*$/;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.getFormatter = function () {
            var result = EShapeActionRuntimeOpenDialogTime.FORMATTER;
            if (result == null) {
                result = this.newFormatter();
                EShapeActionRuntimeOpenDialogTime.FORMATTER = result;
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.newFormatter = function () {
            return NumberFormatters.create("%Hm");
        };
        return EShapeActionRuntimeOpenDialogTime;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDate = /** @class */ (function (_super) {
        __extends(DPickerDate, _super);
        function DPickerDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDate.prototype.getType = function () {
            return "DPickerDate";
        };
        return DPickerDate;
    }(DPickerDatetime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDate = /** @class */ (function (_super) {
        __extends(DDialogDate, _super);
        function DDialogDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogDate.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            layout.addChild(this.picker);
        };
        Object.defineProperty(DDialogDate.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            set: function (dateCurrent) {
                this.picker.current = dateCurrent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            set: function (value) {
                this.picker.new = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "page", {
            get: function () {
                return this.picker.new;
            },
            set: function (page) {
                this.picker.page = page;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerDate((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogDate.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogDate.prototype.getType = function () {
            return "DDialogDate";
        };
        return DDialogDate;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogDate = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogDate, _super);
        function EShapeActionRuntimeOpenDialogDate(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofUnknown(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogDate.prototype.open = function (target, initial) {
            var _this = this;
            var dialog = EShapeActionRuntimeOpenDialogDate.DIALOG;
            if (dialog == null) {
                dialog = new DDialogDate();
                EShapeActionRuntimeOpenDialogDate.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open().then(function (value) {
                return _this.getFormatter().format(value.getTime(), 0);
            });
        };
        EShapeActionRuntimeOpenDialogDate.prototype.toDate = function (value) {
            if (isString(value) || isNumber(value)) {
                return new Date(value);
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        };
        EShapeActionRuntimeOpenDialogDate.prototype.getFormatter = function () {
            var result = EShapeActionRuntimeOpenDialogDate.FORMATTER;
            if (result == null) {
                result = this.newFormatter();
                EShapeActionRuntimeOpenDialogDate.FORMATTER = result;
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogDate.prototype.newFormatter = function () {
            return NumberFormatters.create("%Y-%M-%D");
        };
        return EShapeActionRuntimeOpenDialogDate;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpen = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpen, _super);
        function EShapeActionValueOpen(subtype, condition, target, onInputAction, initial) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, subtype) || this;
            _this.target = target;
            _this.onInputAction = onInputAction;
            _this.initial = initial;
            return _this;
        }
        EShapeActionValueOpen.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpen &&
                this.target === value.target);
        };
        EShapeActionValueOpen.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueOpenType.DIAGRAM:
                    return new EShapeActionRuntimeOpenDiagram(this);
                case EShapeActionValueOpenType.PAGE:
                    return new EShapeActionRuntimeOpenPage(this);
                case EShapeActionValueOpenType.PAGE_INPLACE:
                    return new EShapeActionRuntimeOpenPageInplace(this);
                case EShapeActionValueOpenType.DIALOG_TEXT:
                    return new EShapeActionRuntimeOpenDialogText(this);
                case EShapeActionValueOpenType.DIALOG_INTEGER:
                    return new EShapeActionRuntimeOpenDialogInteger(this);
                case EShapeActionValueOpenType.DIALOG_REAL:
                    return new EShapeActionRuntimeOpenDialogReal(this);
                case EShapeActionValueOpenType.DIALOG_BOOLEAN:
                    return new EShapeActionRuntimeOpenDialogBoolean(this);
                case EShapeActionValueOpenType.DIALOG_DATE:
                    return new EShapeActionRuntimeOpenDialogDate(this);
                case EShapeActionValueOpenType.DIALOG_TIME:
                    return new EShapeActionRuntimeOpenDialogTime(this);
                case EShapeActionValueOpenType.DIALOG_DATETIME:
                    return new EShapeActionRuntimeOpenDialogDatetime(this);
            }
        };
        EShapeActionValueOpen.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var initialId = manager.addResource(this.initial);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + targetId + "," + this.onInputAction + "," + initialId + "]");
        };
        EShapeActionValueOpen.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var target = EShapeActionValues.toResource(3, serialized, manager.resources);
            var initial = EShapeActionValues.toResource(5, serialized, manager.resources);
            return new EShapeActionValueOpen(serialized[2], condition, target, serialized[4], initial);
        };
        return EShapeActionValueOpen;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHideType;
    (function (EShapeActionValueShowHideType) {
        EShapeActionValueShowHideType[EShapeActionValueShowHideType["SHOW"] = 0] = "SHOW";
        EShapeActionValueShowHideType[EShapeActionValueShowHideType["HIDE"] = 1] = "HIDE";
    })(EShapeActionValueShowHideType || (EShapeActionValueShowHideType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeShowHide = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeShowHide, _super);
        function EShapeActionRuntimeShowHide(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
            _this.visibility = value.subtype === EShapeActionValueShowHideType.SHOW;
            return _this;
        }
        EShapeActionRuntimeShowHide.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                shape.visible = this.visibility;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeShowHide;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHide = /** @class */ (function (_super) {
        __extends(EShapeActionValueShowHide, _super);
        function EShapeActionValueShowHide(subtype, condition) {
            return _super.call(this, EShapeActionValueType.SHOW_HIDE, condition, subtype) || this;
        }
        EShapeActionValueShowHide.prototype.toRuntime = function () {
            return new EShapeActionRuntimeShowHide(this);
        };
        EShapeActionValueShowHide.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "]");
        };
        EShapeActionValueShowHide.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueShowHide(serialized[2], condition);
        };
        return EShapeActionValueShowHide;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMove = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMove, _super);
        function EShapeActionRuntimeTransformMove(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.amount = EShapeActionExpressions.ofNumber(value.amount);
            return _this;
        }
        return EShapeActionRuntimeTransformMove;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveAbsoluteX = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveAbsoluteX, _super);
        function EShapeActionRuntimeTransformMoveAbsoluteX(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_X) || this;
        }
        EShapeActionRuntimeTransformMoveAbsoluteX.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                shape.transform.position.x = amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveAbsoluteX;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveAbsoluteY = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveAbsoluteY, _super);
        function EShapeActionRuntimeTransformMoveAbsoluteY(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_Y) || this;
        }
        EShapeActionRuntimeTransformMoveAbsoluteY.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                shape.transform.position.y = amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveAbsoluteY;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveForwardOrBackward = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveForwardOrBackward, _super);
        function EShapeActionRuntimeTransformMoveForwardOrBackward(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformMoveForwardOrBackward.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var transform = shape.transform;
                var position = transform.position;
                var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                var oldPositionX = writtenPositionX ? position.x : runtime.x;
                var oldPositionY = writtenPositionY ? position.y : runtime.y;
                shape.updateTransform();
                var localTransform = transform.localTransform;
                position.set(oldPositionX - localTransform.c * amount, oldPositionY - localTransform.d * amount);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveForwardOrBackward;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveLeftOrRight = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveLeftOrRight, _super);
        function EShapeActionRuntimeTransformMoveLeftOrRight(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformMoveLeftOrRight.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var transform = shape.transform;
                var position = transform.position;
                var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                var oldPositionX = writtenPositionX ? position.x : runtime.x;
                var oldPositionY = writtenPositionY ? position.y : runtime.y;
                shape.updateTransform();
                var localTransform = transform.localTransform;
                position.set(oldPositionX + localTransform.a * amount, oldPositionY + localTransform.b * amount);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveLeftOrRight;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveRelativeX = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveRelativeX, _super);
        function EShapeActionRuntimeTransformMoveRelativeX(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_X) || this;
        }
        EShapeActionRuntimeTransformMoveRelativeX.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                var position = shape.transform.position;
                var oldPositionX = writtenPositionX ? position.x : runtime.x;
                position.x = oldPositionX + amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveRelativeX;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveRelativeY = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveRelativeY, _super);
        function EShapeActionRuntimeTransformMoveRelativeY(action) {
            return _super.call(this, action, EShapeRuntimeReset.POSITION_Y) || this;
        }
        EShapeActionRuntimeTransformMoveRelativeY.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                var position = shape.transform.position;
                var oldPositionY = writtenPositionY ? position.y : runtime.y;
                position.y = oldPositionY + amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveRelativeY;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpetyped = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpetyped, _super);
        function EShapeActionValueOpetyped(type, condition, subtype, opetype) {
            var _this = _super.call(this, type, condition, subtype) || this;
            _this.opetype = opetype;
            return _this;
        }
        EShapeActionValueOpetyped.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpetyped &&
                this.opetype === value.opetype);
        };
        return EShapeActionValueOpetyped;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformMoveType;
    (function (EShapeActionValueTransformMoveType) {
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["RELATIVE_X"] = 0] = "RELATIVE_X";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["RELATIVE_Y"] = 1] = "RELATIVE_Y";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["ABSOLUTE_X"] = 2] = "ABSOLUTE_X";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["ABSOLUTE_Y"] = 3] = "ABSOLUTE_Y";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["FORWARD_OR_BACKWARD"] = 4] = "FORWARD_OR_BACKWARD";
        EShapeActionValueTransformMoveType[EShapeActionValueTransformMoveType["LEFT_OR_RIGHT"] = 5] = "LEFT_OR_RIGHT";
    })(EShapeActionValueTransformMoveType || (EShapeActionValueTransformMoveType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformType;
    (function (EShapeActionValueTransformType) {
        EShapeActionValueTransformType[EShapeActionValueTransformType["RESIZE"] = 0] = "RESIZE";
        EShapeActionValueTransformType[EShapeActionValueTransformType["MOVE"] = 1] = "MOVE";
        EShapeActionValueTransformType[EShapeActionValueTransformType["ROTATE"] = 2] = "ROTATE";
    })(EShapeActionValueTransformType || (EShapeActionValueTransformType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformMove = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformMove, _super);
        function EShapeActionValueTransformMove(opetype, condition, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.MOVE, opetype) || this;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformMove.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueTransformMove &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformMove.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformMoveType.ABSOLUTE_X:
                    return new EShapeActionRuntimeTransformMoveAbsoluteX(this);
                case EShapeActionValueTransformMoveType.ABSOLUTE_Y:
                    return new EShapeActionRuntimeTransformMoveAbsoluteY(this);
                case EShapeActionValueTransformMoveType.FORWARD_OR_BACKWARD:
                    return new EShapeActionRuntimeTransformMoveForwardOrBackward(this);
                case EShapeActionValueTransformMoveType.LEFT_OR_RIGHT:
                    return new EShapeActionRuntimeTransformMoveLeftOrRight(this);
                case EShapeActionValueTransformMoveType.RELATIVE_X:
                    return new EShapeActionRuntimeTransformMoveRelativeX(this);
                case EShapeActionValueTransformMoveType.RELATIVE_Y:
                    return new EShapeActionRuntimeTransformMoveRelativeY(this);
            }
        };
        EShapeActionValueTransformMove.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var amountId = manager.addResource(this.amount);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.opetype + "," + amountId + "]");
        };
        EShapeActionValueTransformMove.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueTransformMove(serialized[3], condition, amount);
        };
        return EShapeActionValueTransformMove;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeSizes = /** @class */ (function () {
        function EShapeSizes() {
        }
        EShapeSizes.toRounded = function (value) {
            return Math.round(value * 100) / 100;
        };
        EShapeSizes.toNormalized = function (size) {
            var THRESHOLD = 0.001;
            if (Math.abs(size) < THRESHOLD) {
                return size < 0 ? -THRESHOLD : +THRESHOLD;
            }
            return EShapeSizes.toRounded(size);
        };
        EShapeSizes.resize = function (shape, from, to, centerMode, isPerfect) {
            shape.disallowUploadedUpdate();
            var position = shape.transform.position;
            if (centerMode) {
                var dx = Math.abs(to.x - from.x);
                var dy = Math.abs(to.y - from.y);
                if (isPerfect) {
                    var hsize = Math.max(dx, dy);
                    var size = hsize + hsize;
                    shape.size.set(EShapeSizes.toNormalized(size), EShapeSizes.toNormalized(size));
                    position.set(EShapeSizes.toRounded(from.x), EShapeSizes.toRounded(from.y));
                }
                else {
                    shape.size.set(EShapeSizes.toNormalized(dx + dx), EShapeSizes.toNormalized(dy + dy));
                    position.set(EShapeSizes.toRounded(from.x), EShapeSizes.toRounded(from.y));
                }
            }
            else {
                if (isPerfect) {
                    var dx = to.x - from.x;
                    var dy = to.y - from.y;
                    var size = Math.max(Math.abs(dx), Math.abs(dy));
                    var x2 = from.x + (dx < 0 ? -size : +size);
                    var y2 = from.y + (dy < 0 ? -size : +size);
                    var hsize = size * 0.5;
                    var x = Math.min(from.x, x2) + hsize;
                    var y = Math.min(from.y, y2) + hsize;
                    shape.size.set(EShapeSizes.toNormalized(size), EShapeSizes.toNormalized(size));
                    position.set(EShapeSizes.toRounded(x), EShapeSizes.toRounded(y));
                }
                else {
                    var x0 = Math.min(from.x, to.x);
                    var y0 = Math.min(from.y, to.y);
                    var x1 = Math.max(from.x, to.x);
                    var y1 = Math.max(from.y, to.y);
                    var width = x1 - x0;
                    var height = y1 - y0;
                    var px = width * 0.5;
                    var py = height * 0.5;
                    shape.size.set(EShapeSizes.toNormalized(width), EShapeSizes.toNormalized(height));
                    position.set(EShapeSizes.toRounded(x0 + px), EShapeSizes.toRounded(y0 + py));
                }
            }
            shape.allowUploadedUpdate();
        };
        return EShapeSizes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformResizeType;
    (function (EShapeActionValueTransformResizeType) {
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["RELATIVE_SIZE"] = 0] = "RELATIVE_SIZE";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["RELATIVE_HEIGHT"] = 1] = "RELATIVE_HEIGHT";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["RELATIVE_WIDTH"] = 2] = "RELATIVE_WIDTH";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["ABSOLUTE_SIZE"] = 3] = "ABSOLUTE_SIZE";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["ABSOLUTE_HEIGHT"] = 4] = "ABSOLUTE_HEIGHT";
        EShapeActionValueTransformResizeType[EShapeActionValueTransformResizeType["ABSOLUTE_WIDTH"] = 5] = "ABSOLUTE_WIDTH";
    })(EShapeActionValueTransformResizeType || (EShapeActionValueTransformResizeType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResize = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResize, _super);
        function EShapeActionRuntimeTransformResize(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            switch (value.opetype) {
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    _this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    _this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    _this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    _this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    _this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    _this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                default:
                    _this.size = EShapeActionExpressions.ONE;
            }
            return _this;
        }
        EShapeActionRuntimeTransformResize.prototype.adjustPosition = function (shape, runtime, dsx, dsy, originX, originY) {
            var dx = (-0.5 + originX) * dsx;
            var dy = (-0.5 + originY) * dsy;
            shape.updateTransform();
            var transform = shape.transform;
            var position = transform.position;
            var localTransform = transform.localTransform;
            var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
            var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
            var oldPositionX = writtenPositionX ? position.x : runtime.x;
            var oldPositionY = writtenPositionY ? position.y : runtime.y;
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * localTransform.a + dy * localTransform.c, oldPositionY + dx * localTransform.b + dy * localTransform.d);
        };
        return EShapeActionRuntimeTransformResize;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeHeightAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeHeightAbsolute, _super);
        function EShapeActionRuntimeTransformResizeHeightAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.HEIGHT) || this;
            _this.origin = value.originY;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeHeightAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var sizeAbsolute = this.size(shape, time);
                var size = shape.size;
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeY = writtenHeight ? size.y : runtime.size.y;
                size.y = EShapeSizes.toNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        };
        return EShapeActionRuntimeTransformResizeHeightAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeHeightRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeHeightRelative, _super);
        function EShapeActionRuntimeTransformResizeHeightRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.HEIGHT) || this;
            _this.origin = value.originY;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeHeightRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var sizeRelative = this.size(shape, time);
                var size = shape.size;
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeY = writtenHeight ? size.y : runtime.size.y;
                size.y = EShapeSizes.toNormalized(oldSizeY * sizeRelative);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        };
        return EShapeActionRuntimeTransformResizeHeightRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeSizeAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeSizeAbsolute, _super);
        function EShapeActionRuntimeTransformResizeSizeAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.SIZE) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeSizeAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var sizeAbsolute = EShapeSizes.toNormalized(this.size(shape, time));
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeX = writtenWidth ? size.x : runtime.size.x;
                var oldSizeY = writtenHeight ? size.y : runtime.size.y;
                size.set(sizeAbsolute, sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformResizeSizeAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeSizeRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeSizeRelative, _super);
        function EShapeActionRuntimeTransformResizeSizeRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.SIZE) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeSizeRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var sizeRelative = this.size(shape, time);
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeX = writtenWidth ? size.x : runtime.size.x;
                var oldSizeY = writtenHeight ? size.y : runtime.size.y;
                size.set(EShapeSizes.toNormalized(oldSizeX * sizeRelative), EShapeSizes.toNormalized(oldSizeY * sizeRelative));
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformResizeSizeRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeWidthAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeWidthAbsolute, _super);
        function EShapeActionRuntimeTransformResizeWidthAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.WIDTH) || this;
            _this.origin = value.originX;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeWidthAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var sizeAbsolute = this.size(shape, time);
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var oldSizeX = writtenWidth ? size.x : runtime.size.x;
                size.x = EShapeSizes.toNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        };
        return EShapeActionRuntimeTransformResizeWidthAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeWidthRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeWidthRelative, _super);
        function EShapeActionRuntimeTransformResizeWidthRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.WIDTH) || this;
            _this.origin = value.originX;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformResizeWidthRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var sizeRelative = this.size(shape, time);
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var oldSizeX = writtenWidth ? size.x : runtime.size.x;
                size.x = EShapeSizes.toNormalized(oldSizeX * sizeRelative);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        };
        return EShapeActionRuntimeTransformResizeWidthRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformResize = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformResize, _super);
        function EShapeActionValueTransformResize(opetype, condition, originX, originY, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.RESIZE, opetype) || this;
            _this.originX = originX;
            _this.originY = originY;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformResize.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueTransformResize &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformResize.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeAbsolute(this);
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeRelative(this);
            }
        };
        EShapeActionValueTransformResize.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var amountId = manager.addResource(this.amount);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.opetype + "," + this.originX + "," + this.originY + "," + amountId + "]");
        };
        EShapeActionValueTransformResize.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformResize(serialized[3], condition, serialized[4], serialized[5], amount);
        };
        return EShapeActionValueTransformResize;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotate = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotate, _super);
        function EShapeActionRuntimeTransformRotate(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            _this.amount = EShapeActionExpressions.ofNumber("(" + value.amount + ") * (Math.PI / 180)");
            return _this;
        }
        EShapeActionRuntimeTransformRotate.prototype.adjustPosition = function (shape, runtime, oldRotation, newRotation, originX, originY) {
            var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
            var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
            var dx = (-0.5 + originX) * (writtenWidth ? shape.size.x : runtime.size.x);
            var dy = (-0.5 + originY) * (writtenHeight ? shape.size.y : runtime.size.y);
            var s = Math.sin(oldRotation) - Math.sin(newRotation);
            var c = Math.cos(oldRotation) - Math.cos(newRotation);
            var position = shape.transform.position;
            var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
            var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
            var oldPositionX = writtenPositionX ? position.x : runtime.x;
            var oldPositionY = writtenPositionY ? position.y : runtime.y;
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * c - dy * s, oldPositionY + dx * s + dy * c);
        };
        return EShapeActionRuntimeTransformRotate;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotateAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotateAbsolute, _super);
        function EShapeActionRuntimeTransformRotateAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.ROTATION) || this;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformRotateAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var transform = shape.transform;
                var writtenRotation = !!(runtime.written & EShapeRuntimeReset.ROTATION);
                var oldRotation = writtenRotation ? transform.rotation : runtime.rotation;
                transform.rotation = amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, amount, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformRotateAbsolute;
    }(EShapeActionRuntimeTransformRotate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotateRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotateRelative, _super);
        function EShapeActionRuntimeTransformRotateRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.ROTATION) || this;
            _this.reset |= EShapeRuntimeReset.POSITION;
            return _this;
        }
        EShapeActionRuntimeTransformRotateRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time)) {
                var amount = this.amount(shape, time);
                var transform = shape.transform;
                var writtenRotation = !!(runtime.written & EShapeRuntimeReset.ROTATION);
                var oldRotation = writtenRotation ? transform.rotation : runtime.rotation;
                transform.rotation = oldRotation + amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, transform.rotation, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformRotateRelative;
    }(EShapeActionRuntimeTransformRotate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformRotateType;
    (function (EShapeActionValueTransformRotateType) {
        EShapeActionValueTransformRotateType[EShapeActionValueTransformRotateType["RELATIVE"] = 0] = "RELATIVE";
        EShapeActionValueTransformRotateType[EShapeActionValueTransformRotateType["ABSOLUTE"] = 1] = "ABSOLUTE";
    })(EShapeActionValueTransformRotateType || (EShapeActionValueTransformRotateType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformRotate = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformRotate, _super);
        function EShapeActionValueTransformRotate(opetype, condition, originX, originY, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.ROTATE, opetype) || this;
            _this.originX = originX;
            _this.originY = originY;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformRotate.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueTransformRotate &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformRotate.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformRotateType.ABSOLUTE:
                    return new EShapeActionRuntimeTransformRotateAbsolute(this);
                case EShapeActionValueTransformRotateType.RELATIVE:
                    return new EShapeActionRuntimeTransformRotateRelative(this);
            }
        };
        EShapeActionValueTransformRotate.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var amountId = manager.addResource(this.amount);
            return manager.addResource("[" + this.type + "," + conditionId + "," + this.subtype + "," + this.opetype + "," + this.originX + "," + this.originY + "," + amountId + "]");
        };
        EShapeActionValueTransformRotate.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformRotate(serialized[3], condition, serialized[4], serialized[5], amount);
        };
        return EShapeActionValueTransformRotate;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueDeserializer = /** @class */ (function () {
        function EShapeActionValueDeserializer() {
        }
        EShapeActionValueDeserializer.toSerialized = function (resource) {
            try {
                var parsed = JSON.parse(resource);
                if (isArray(parsed)) {
                    for (var i = 0, imax = parsed.length; i < imax; ++i) {
                        if (!isNumber(parsed[i])) {
                            return null;
                        }
                    }
                    if (2 <= parsed.length) {
                        return parsed;
                    }
                }
                return null;
            }
            catch (e) {
                return null;
            }
        };
        EShapeActionValueDeserializer.deserialize = function (id, manager) {
            var action = manager.getAction(id);
            if (action != null) {
                return action;
            }
            var resources = manager.resources;
            var resource = resources[id];
            if (resource != null) {
                var serialized = this.toSerialized(resource);
                if (serialized != null) {
                    switch (serialized[0]) {
                        case EShapeActionValueType.SHOW_HIDE:
                            return EShapeActionValueShowHide.deserialize(serialized, manager);
                        case EShapeActionValueType.BLINK:
                            return EShapeActionValueBlink.deserialize(serialized, manager);
                        case EShapeActionValueType.CHANGE_COLOR:
                        case EShapeActionValueType.CHANGE_COLOR_LEGACY:
                            switch (serialized[3]) {
                                case EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA:
                                case EShapeActionValueChangeColorTarget.COLOR:
                                case EShapeActionValueChangeColorTarget.ALPHA:
                                    return EShapeActionValueChangeColor.deserialize(serialized, manager);
                                case EShapeActionValueChangeColorTarget.CODE:
                                    return EShapeActionValueChangeColorCode.deserialize(serialized, manager);
                                case EShapeActionValueChangeColorTarget.BRIGHTNESS:
                                    return EShapeActionValueChangeColorBrightness.deserialize(serialized, manager);
                            }
                            break;
                        case EShapeActionValueType.CHANGE_TEXT:
                            return EShapeActionValueChangeText.deserialize(serialized, manager);
                        case EShapeActionValueType.CHANGE_CURSOR:
                            return EShapeActionValueChangeCursor.deserialize(serialized, manager);
                        case EShapeActionValueType.EMIT_EVENT:
                            return EShapeActionValueEmitEvent.deserialize(serialized, manager);
                        case EShapeActionValueType.OPEN:
                            return EShapeActionValueOpen.deserialize(serialized, manager);
                        case EShapeActionValueType.TRANSFORM:
                            switch (serialized[2]) {
                                case EShapeActionValueTransformType.MOVE:
                                    return EShapeActionValueTransformMove.deserialize(serialized, manager);
                                case EShapeActionValueTransformType.RESIZE:
                                    return EShapeActionValueTransformResize.deserialize(serialized, manager);
                                case EShapeActionValueTransformType.ROTATE:
                                    return EShapeActionValueTransformRotate.deserialize(serialized, manager);
                            }
                            break;
                        case EShapeActionValueType.MISC:
                            return EShapeActionValueMisc.deserialize(serialized, manager);
                    }
                }
            }
            return new EShapeActionValueShowHide(EShapeActionValueShowHideType.SHOW, "");
        };
        return EShapeActionValueDeserializer;
    }());

    var EShapeImageElements = /** @class */ (function () {
        function EShapeImageElements() {
        }
        EShapeImageElements.toImageElement = function (dataUrl) {
            var imageElements = EShapeImageElements.imageElements;
            var cachedImageElement = imageElements[dataUrl];
            if (cachedImageElement != null) {
                if (cachedImageElement instanceof HTMLImageElement) {
                    return Promise.resolve(cachedImageElement);
                }
                else {
                    return cachedImageElement;
                }
            }
            else {
                var result = new Promise(function (resolve, reject) {
                    var imageElement = document.createElement("img");
                    imageElement.onload = function () {
                        imageElements[dataUrl] = imageElement;
                        resolve(imageElement);
                    };
                    imageElement.onabort = imageElement.onerror = function () {
                        reject();
                    };
                    imageElement.src = dataUrl;
                });
                imageElements[dataUrl] = result;
                return result;
            }
        };
        EShapeImageElements.imageElements = {};
        return EShapeImageElements;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDeserializer = /** @class */ (function () {
        function EShapeDeserializer() {
        }
        EShapeDeserializer.toShape = function (item, manager) {
            var shapeDeserializer = EShapeDeserializers[item[0]];
            if (shapeDeserializer != null) {
                return shapeDeserializer(item, manager);
            }
            return null;
        };
        EShapeDeserializer.deserialize = function (item, manager, result) {
            result.id = manager.resources[item[1]] || "";
            var transform = result.transform;
            transform.position.set(item[2], item[3]);
            transform.rotation = item[6];
            transform.skew.set(item[7], item[7]);
            transform.pivot.set(item[21], item[22]);
            result.size.set(EShapeSizes.toNormalized(item[4]), EShapeSizes.toNormalized(item[5]));
            result.fill.deserialize(item[8], manager);
            result.stroke.deserialize(item[9], manager);
            result.cursor = manager.resources[item[10]] || "";
            result.text.deserialize(item[11], manager);
            result.tag.deserialize(item[12], manager);
            result.radius = item[13];
            result.corner = item[14];
            result.interactive = !!(item[23] & 1);
            result.state.isFocusable = !(item[23] & 2);
            result.shortcut = 0 <= item[24] ? manager.resources[item[24]] : undefined;
            result.title = 0 <= item[25] ? manager.resources[item[25]] : undefined;
            result.uuid = item[26] != null ? item[26] : 0;
            // Children
            var childrenPromise = null;
            var childrenSerialized = item[20];
            if (0 < childrenSerialized.length) {
                var childrenOrPromises = [];
                for (var i = 0, imax = childrenSerialized.length; i < imax; ++i) {
                    var childSerialized = childrenSerialized[i];
                    var childOrPromise = EShapeDeserializer.toShape(childSerialized, manager);
                    if (childOrPromise != null) {
                        childrenOrPromises.push(childOrPromise);
                    }
                }
                childrenPromise = Promise.all(childrenOrPromises).then(function (children) {
                    result.children = children;
                    for (var i = 0, imax = children.length; i < imax; ++i) {
                        children[i].parent = result;
                    }
                    result.onChildTransformChange();
                    result.toDirty();
                    return result;
                });
            }
            // Action
            var serializedActions = item[17];
            for (var i = 0, imax = serializedActions.length; i < imax; ++i) {
                result.action.add(EShapeActionValueDeserializer.deserialize(serializedActions[i], manager));
            }
            // Gradient
            var gradientId = item[19];
            if (0 <= gradientId && gradientId < manager.resources.length) {
                var gradient = manager.resources[gradientId];
                if (isString(gradient)) {
                    result.gradient = EShapeGradients.deserializeGradient(gradient);
                }
            }
            // Image
            var imagePromise = null;
            var imageId = item[18];
            if (0 <= imageId && imageId < manager.resources.length) {
                var imageSrc = manager.resources[imageId];
                if (isString(imageSrc)) {
                    imagePromise = EShapeImageElements.toImageElement(imageSrc).then(function (imageElement) {
                        result.image = imageElement;
                        return result;
                    });
                }
            }
            //
            if (childrenPromise != null) {
                if (imagePromise != null) {
                    return Promise.all([childrenPromise, imagePromise]).then(function () {
                        return result;
                    });
                }
                else {
                    return childrenPromise;
                }
            }
            else {
                if (imagePromise != null) {
                    return imagePromise;
                }
                else {
                    return result;
                }
            }
        };
        EShapeDeserializer.deserializeAll = function (serializeds, manager) {
            var shapes = [];
            for (var i = 0, imax = serializeds.length; i < imax; ++i) {
                var serialized = serializeds[i];
                var shape = EShapeDeserializer.toShape(serialized, manager);
                if (shape == null) {
                    if (0 < shapes.length) {
                        Promise.all(shapes).then(function (resolved) {
                            for (var j = 0, jmax = resolved.length; j < jmax; ++j) {
                                resolved[j].destroy();
                            }
                        });
                    }
                    return null;
                }
                shapes.push(shape);
            }
            if (0 < shapes.length) {
                return Promise.all(shapes);
            }
            return null;
        };
        return EShapeDeserializer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeBar = function (item, manager) {
        var shape = new EShapeBar(EShapeBarPosition.RIGHT);
        var result = EShapeDeserializer.deserialize(item, manager, shape);
        shape.points.deserialize(item[15], manager);
        var style = shape.points.style;
        var mask = EShapePointsStyle.NON_SCALING_MASK |
            EShapePointsStyle.DOTTED_MASK |
            EShapePointsStyle.DASHED_MASK;
        var deprecated = style & mask;
        if (deprecated) {
            shape.points.style &= ~mask;
            shape.stroke.style |= deprecated;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeBar = function () {
        EShapeUploadeds[EShapeType.BAR] = createBarUploaded;
        EShapeDeserializers[EShapeType.BAR] = deserializeBar;
    };

    var CIRCLE_VERTEX_COUNT = 9;
    var CIRCLE_INDEX_COUNT = 8;
    var CIRCLE_WORLD_SIZE = [0, 0];
    var CIRCLE_WORK_POINT = new pixi_js.Point();
    var buildCircleClipping = function (clippings, voffset) {
        var ic = voffset * 3 - 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
    };
    var buildCircleIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 7;
    };
    var buildCircleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        //  0       1       2
        // |-------|-------|
        // |3      |4      |5
        // |-------|-------|
        // |6      |7      |8
        // |-------|-------|
        //
        var work = CIRCLE_WORK_POINT;
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        work.set(-sx + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(0 + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        var dx = x1 - x0;
        var dy = y1 - y0;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var x4 = work.x;
        var y4 = work.y;
        var x7 = x4 + (x4 - x1);
        var y7 = y4 + (y4 - y1);
        var x3 = x4 - dx;
        var y3 = y4 - dy;
        // Vertices
        var iv = voffset * 2 - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1 + dx;
        vertices[++iv] = y1 + dy;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x4 + dx;
        vertices[++iv] = y4 + dy;
        vertices[++iv] = x7 - dx;
        vertices[++iv] = y7 - dy;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x7 + dx;
        vertices[++iv] = y7 + dy;
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x3, y3);
    };
    var buildCircleStep = function (steps, clippings, voffset, strokeWidth, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var is = voffset * 6 - 1;
        var ic = voffset * 3;
        for (var i = 0; i < CIRCLE_VERTEX_COUNT; i += 1, ic += 3) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = worldSize[0];
            steps[++is] = worldSize[1];
            steps[++is] = 1 + clippings[ic];
            steps[++is] = 1 + clippings[ic + 1];
        }
    };
    var buildCircleUv = function (uvs, voffset, textureUvs) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        // UVs
        var iuv = voffset * 2 - 1;
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = 0.5 * (x0 + x1);
        uvs[++iuv] = 0.5 * (y0 + y1);
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = 0.5 * (x0 + x3);
        uvs[++iuv] = 0.5 * (y0 + y3);
        uvs[++iuv] = 0.5 * (x0 + x2);
        uvs[++iuv] = 0.5 * (y0 + y2);
        uvs[++iuv] = 0.5 * (x1 + x2);
        uvs[++iuv] = 0.5 * (y1 + y2);
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = 0.5 * (x3 + x2);
        uvs[++iuv] = 0.5 * (y3 + y2);
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCircleUploaded = /** @class */ (function (_super) {
        __extends(EShapeCircleUploaded, _super);
        function EShapeCircleUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeCircleUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clippings & indices
            var buffer = this.buffer;
            buffer.updateClippings();
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            buildCircleClipping(buffer.clippings, voffset);
            buildCircleIndex(buffer.indices, voffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeCircleUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateCircleVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateCircleUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeCircleUploaded.prototype.updateCircleVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                // Invalidate the text layout to update the text layout.
                this.textSpacingHorizontal = NaN;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                buildCircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, CIRCLE_WORLD_SIZE);
                buildCircleStep(buffer.steps, buffer.clippings, this.vertexOffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
            }
        };
        EShapeCircleUploaded.prototype.updateCircleUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var textureUvs = this.toTextureUvs(texture);
                buildCircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        };
        return EShapeCircleUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createCircle = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = CIRCLE_VERTEX_COUNT + tvcount;
        var icount = CIRCLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeCircleUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCircle = /** @class */ (function (_super) {
        __extends(EShapeCircle, _super);
        function EShapeCircle(type) {
            if (type === void 0) { type = EShapeType.CIRCLE; }
            return _super.call(this, type) || this;
        }
        EShapeCircle.prototype.clone = function () {
            return new EShapeCircle().copy(this);
        };
        EShapeCircle.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var fill = this.fill;
                if (fill.enable) {
                    var x2 = x * x;
                    var y2 = y * y;
                    var ax2 = ax * ax;
                    var ay2 = ay * ay;
                    if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                        return true;
                    }
                }
                else {
                    if (0 < sw) {
                        var s = sw * ss;
                        var x2 = x * x;
                        var y2 = y * y;
                        var wx = Math.max(0.0, ax - s);
                        var wy = Math.max(0.0, ay - s);
                        var wx2 = wx * wx;
                        var wy2 = wy * wy;
                        if (wx2 * wy2 <= x2 * wy2 + y2 * wx2) {
                            var ax2 = ax * ax;
                            var ay2 = ay * ay;
                            if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeCircle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeCircle = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeCircle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeCircle = function () {
        EShapeUploadeds[EShapeType.CIRCLE] = createCircle;
        EShapeDeserializers[EShapeType.CIRCLE] = deserializeCircle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /* eslint-disable prettier/prettier */
    var EShapeCapability;
    (function (EShapeCapability) {
        EShapeCapability[EShapeCapability["NONE"] = 0] = "NONE";
        EShapeCapability[EShapeCapability["ID"] = 1] = "ID";
        EShapeCapability[EShapeCapability["POSITION"] = 2] = "POSITION";
        EShapeCapability[EShapeCapability["WIDTH"] = 4] = "WIDTH";
        EShapeCapability[EShapeCapability["HEIGHT"] = 8] = "HEIGHT";
        EShapeCapability[EShapeCapability["ROTATION"] = 16] = "ROTATION";
        EShapeCapability[EShapeCapability["SKEW"] = 32] = "SKEW";
        EShapeCapability[EShapeCapability["ALIGN"] = 64] = "ALIGN";
        EShapeCapability[EShapeCapability["REPLACING"] = 128] = "REPLACING";
        EShapeCapability[EShapeCapability["GROUPING"] = 256] = "GROUPING";
        EShapeCapability[EShapeCapability["FILL"] = 512] = "FILL";
        EShapeCapability[EShapeCapability["STROKE"] = 1024] = "STROKE";
        EShapeCapability[EShapeCapability["STROKE_SIDE"] = 2048] = "STROKE_SIDE";
        EShapeCapability[EShapeCapability["BORDER_RADIUS"] = 4096] = "BORDER_RADIUS";
        EShapeCapability[EShapeCapability["TEXT"] = 8192] = "TEXT";
        EShapeCapability[EShapeCapability["TEXTURE"] = 16384] = "TEXTURE";
        EShapeCapability[EShapeCapability["TAG"] = 32768] = "TAG";
        EShapeCapability[EShapeCapability["ACTION"] = 65536] = "ACTION";
        EShapeCapability[EShapeCapability["CURSOR"] = 131072] = "CURSOR";
        EShapeCapability[EShapeCapability["ORDER_IN_LAYER"] = 262144] = "ORDER_IN_LAYER";
        EShapeCapability[EShapeCapability["CHILDREN"] = 524288] = "CHILDREN";
        EShapeCapability[EShapeCapability["COORDINATE"] = 127] = "COORDINATE";
        EShapeCapability[EShapeCapability["SHAPE"] = 1920] = "SHAPE";
        EShapeCapability[EShapeCapability["LAYER"] = 262144] = "LAYER";
        EShapeCapability[EShapeCapability["PRIMITIVE"] = 1042431] = "PRIMITIVE";
        EShapeCapability[EShapeCapability["EMBEDDED"] = 369151] = "EMBEDDED";
        EShapeCapability[EShapeCapability["ALL"] = 1048575] = "ALL";
    })(EShapeCapability || (EShapeCapability = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCapabilities = /** @class */ (function () {
        function EShapeCapabilities() {
        }
        EShapeCapabilities.get = function (type) {
            var capability = this.mappings[type];
            if (capability != null) {
                return capability;
            }
            return EShapeCapability.PRIMITIVE;
        };
        EShapeCapabilities.contains = function (shape, target) {
            if (shape != null) {
                var capability = this.get(shape.type);
                if (capability & target) {
                    return true;
                }
                if (capability & EShapeCapability.CHILDREN) {
                    var children = shape.children;
                    for (var i = 0, imax = children.length; i < imax; ++i) {
                        if (this.contains(children[i], target)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        EShapeCapabilities.set = function (type, capability) {
            this.mappings[type] = capability;
        };
        EShapeCapabilities.mappings = {};
        return EShapeCapabilities;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupUploaded = /** @class */ (function (_super) {
        __extends(EShapeGroupUploaded, _super);
        function EShapeGroupUploaded(buffer, voffset, ioffset) {
            return _super.call(this, buffer, voffset, ioffset, 0, 0, 1) || this;
        }
        EShapeGroupUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            this.texture = shape.texture || pixi_js.Texture.WHITE;
            return this;
        };
        EShapeGroupUploaded.prototype.update = function (shape) {
            // DO NOTHING
        };
        return EShapeGroupUploaded;
    }(EShapeUploadedBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createGroupUploaded = function (buffer, shape, voffset, ioffset) {
        return new EShapeGroupUploaded(buffer, voffset, ioffset).init(shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerDeserialization = /** @class */ (function () {
        function EShapeResourceManagerDeserialization(serialized, pieces, pieceData, isEditMode) {
            this.resources = serialized.resources;
            this.tags = serialized.tags || serialized.resources;
            this.pieces = pieces;
            this.pieceData = pieceData;
            this.isEditMode = isEditMode;
            this._actions = new Map();
            this._fills = new Map();
            this._strokes = new Map();
            this._tags = new Map();
            this._tagValues = new Map();
            this._ranges = new Map();
            this._aligns = new Map();
            this._margins = new Map();
            this._texts = new Map();
            this._textOutlines = new Map();
            this._extensions = new Map();
        }
        EShapeResourceManagerDeserialization.prototype.getAction = function (id) {
            return this._actions.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setAction = function (id, action) {
            this._actions.set(id, action);
        };
        EShapeResourceManagerDeserialization.prototype.getFill = function (id) {
            return this._fills.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setFill = function (id, fill) {
            this._fills.set(id, fill);
        };
        EShapeResourceManagerDeserialization.prototype.getStroke = function (id) {
            return this._strokes.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setStroke = function (id, stroke) {
            this._strokes.set(id, stroke);
        };
        EShapeResourceManagerDeserialization.prototype.getTag = function (id) {
            return this._tags.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setTag = function (id, tag) {
            this._tags.set(id, tag);
        };
        EShapeResourceManagerDeserialization.prototype.getTagValue = function (id) {
            return this._tagValues.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setTagValue = function (id, tagValue) {
            this._tagValues.set(id, tagValue);
        };
        EShapeResourceManagerDeserialization.prototype.getRange = function (id) {
            return this._ranges.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setRange = function (id, range) {
            this._ranges.set(id, range);
        };
        EShapeResourceManagerDeserialization.prototype.getAlign = function (id) {
            return this._aligns.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setAlign = function (id, align) {
            this._aligns.set(id, align);
        };
        EShapeResourceManagerDeserialization.prototype.getMargin = function (id) {
            return this._margins.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setMargin = function (id, margin) {
            this._margins.set(id, margin);
        };
        EShapeResourceManagerDeserialization.prototype.getText = function (id) {
            return this._texts.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setText = function (id, text) {
            this._texts.set(id, text);
        };
        EShapeResourceManagerDeserialization.prototype.getTextOutline = function (id) {
            return this._textOutlines.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setTextOutline = function (id, textOutline) {
            this._textOutlines.set(id, textOutline);
        };
        EShapeResourceManagerDeserialization.prototype.getExtension = function (id) {
            return this._extensions.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setExtension = function (id, extension) {
            this._extensions.set(id, extension);
        };
        return EShapeResourceManagerDeserialization;
    }());

    var EShapeEmbeddedDatum = /** @class */ (function () {
        function EShapeEmbeddedDatum(name, width, height, layer) {
            this.name = name;
            this.width = width;
            this.height = height;
            this.layer = layer;
        }
        return EShapeEmbeddedDatum;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupFillViewer = /** @class */ (function () {
        function EShapeGroupFillViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupFillViewer.prototype, "enable", {
            get: function () {
                return true;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupFillViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupFillViewer.prototype.set = function (enable, color, alpha) {
            // DO NOTHING
        };
        EShapeGroupFillViewer.prototype.clone = function () {
            return new EShapeGroupFillViewer();
        };
        EShapeGroupFillViewer.prototype.toObject = function () {
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        };
        EShapeGroupFillViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupFillViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupFillViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEditor = /** @class */ (function () {
        function EShapeEditor() {
            this.localTransform = new pixi_js.Matrix();
            this.internalTransform = new pixi_js.Matrix();
            this.internalTransformParentInverse = new pixi_js.Matrix();
            this.rotation = 0;
            this.size = new pixi_js.Point();
        }
        return EShapeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTransforms = /** @class */ (function () {
        function EShapeTransforms() {
        }
        EShapeTransforms.prepare = function (shape) {
            var editor = shape.editor || new EShapeEditor();
            shape.editor = editor;
            // Ttransform
            shape.updateTransform();
            var parent = shape.parent;
            if (parent instanceof EShapeBase) {
                parent.transform.internalTransform
                    .copyTo(editor.internalTransformParentInverse)
                    .invert();
            }
            else {
                editor.internalTransformParentInverse.identity();
            }
            shape.transform.internalTransform.copyTo(editor.internalTransform);
            // Rotation
            editor.rotation = shape.transform.rotation;
            // Size
            editor.size.copyFrom(shape.size);
            //
            shape.disallowOnTransformChange();
        };
        EShapeTransforms.finalize = function (shape) {
            shape.allowOnTransformChange(true);
        };
        EShapeTransforms.apply = function (shape, transform, keepSize) {
            var editor = shape.editor;
            if (editor != null) {
                var newLocalTransform = editor.localTransform;
                editor.internalTransformParentInverse
                    .copyTo(newLocalTransform)
                    .append(transform)
                    .append(editor.internalTransform);
                if (keepSize) {
                    this.applyLocal(shape, newLocalTransform);
                }
                else {
                    var size = editor.size;
                    this.applyLocal(shape, newLocalTransform, size.x, size.y);
                }
            }
        };
        EShapeTransforms.applyLocal = function (shape, localTransform, bx, by) {
            shape.disallowUploadedUpdate();
            // Reconstruct the position, the rotation and the size
            var a = localTransform.a;
            var b = localTransform.b;
            var c = localTransform.c;
            var d = localTransform.d;
            var tx = localTransform.tx;
            var ty = localTransform.ty;
            // Rotation
            var transform = shape.transform;
            var rx = Math.atan2(-c, d); // rotation - skewX
            var ry = Math.atan2(+b, a); // rotation + skewY
            transform.rotation = (rx + ry) * 0.5; // Here, assumes `skewX` === `skewY`
            // Skew
            var skew = (ry - rx) * 0.5;
            transform.skew.set(skew, skew);
            // Position: Assumes the pivot is invariant.
            // tx = position.x - (a * px + c * py)
            // ty = position.y - (b * px + d * py)
            //
            // Thus,
            // position.x = tx + (a * px + c * py)
            // position.y = ty + (b * px + d * py)
            var pivot = transform.pivot;
            var px = pivot.x;
            var py = pivot.y;
            transform.position.set(tx + (a * px + c * py), ty + (b * px + d * py));
            // Scale
            if (bx != null && by != null) {
                var sx = Math.sqrt(a * a + b * b);
                var sy = Math.sqrt(c * c + d * d);
                shape.size.set(EShapeSizes.toNormalized(bx * sx), EShapeSizes.toNormalized(by * sy));
            }
            //
            shape.allowUploadedUpdate();
        };
        return EShapeTransforms;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeLayout = /** @class */ (function () {
        function EShapeGroupSizeLayout(shape, bx, by) {
            this.shape = shape;
            // Base group size
            this.base = new pixi_js.Point(bx, by);
            // Base shape size
            var size = shape.size;
            this.shapeBase = new pixi_js.Point(size.x, size.y);
            // Transform
            this.transform = new pixi_js.Matrix();
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
        }
        EShapeGroupSizeLayout.prototype.isCompatible = function (shape) {
            return this.shape === shape;
        };
        EShapeGroupSizeLayout.prototype.reset = function (shape, baseX, baseY) {
            this.base.set(baseX, baseY);
            // Base shape size
            var size = shape.size;
            this.shapeBase.copyFrom(size);
            // Transform
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
        };
        EShapeGroupSizeLayout.prototype.update = function (shape, baseX, baseY, pivotX, pivotY) {
            var sx = baseX / this.base.x;
            var sy = baseY / this.base.y;
            var childBase = this.shapeBase;
            var transform = EShapeGroupSizeLayout.WORK_TRANSFORM;
            transform
                .identity()
                .append(this.transform)
                .translate(-pivotX, -pivotY)
                .scale(sx, sy)
                .translate(+pivotX, +pivotY);
            shape.disallowOnTransformChange();
            EShapeTransforms.applyLocal(shape, transform, childBase.x, childBase.y);
            shape.allowOnTransformChange(false);
        };
        EShapeGroupSizeLayout.WORK_TRANSFORM = new pixi_js.Matrix();
        return EShapeGroupSizeLayout;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeEditor = /** @class */ (function () {
        function EShapeGroupSizeEditor(parent, x, y, isFittable) {
            this._workPoint = new pixi_js.Point();
            this._workRectForCalcRect = new pixi_js.Rectangle();
            this._workRectForFit = new pixi_js.Rectangle();
            this._parent = parent;
            this._layouts = [];
            this._size = new pixi_js.Point(x, y);
            this._isFittable = isFittable;
        }
        EShapeGroupSizeEditor.prototype.init = function () {
            // DO NOTHING
        };
        Object.defineProperty(EShapeGroupSizeEditor.prototype, "x", {
            get: function () {
                return this._size.x;
            },
            set: function (x) {
                var size = this._size;
                if (size.x !== x) {
                    var ox = size.x;
                    size.x = x;
                    this.onChange(ox, size.y);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeEditor.prototype, "y", {
            get: function () {
                return this._size.y;
            },
            set: function (y) {
                var size = this._size;
                if (size.y !== y) {
                    var oy = size.y;
                    size.y = y;
                    this.onChange(size.x, oy);
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupSizeEditor.prototype.set = function (x, y) {
            var isChanged = false;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.clone = function () {
            var size = this._size;
            return new EShapeGroupSizeEditor(this._parent, size.x, size.y, this._isFittable);
        };
        EShapeGroupSizeEditor.prototype.copy = function () {
            // DO NOTHING
        };
        EShapeGroupSizeEditor.prototype.copyFrom = function (point) {
            var x = point.x;
            var y = point.y;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.copyTo = function (point) {
            return this._size.copyTo(point);
        };
        EShapeGroupSizeEditor.prototype.equals = function (point) {
            return this._size.equals(point);
        };
        EShapeGroupSizeEditor.prototype.fit = function () {
            if (this._isFittable) {
                this.doFit();
            }
        };
        EShapeGroupSizeEditor.prototype.doFit = function () {
            var parent = this._parent;
            parent.disallowOnTransformChange();
            // Calculate the rect
            var rect = this.calcRect(this._workRectForFit);
            // Set size
            var size = this._size;
            size.set(rect.width, rect.height);
            // Position & Pivot
            // rx := rect.x
            // ry := rect.y
            //
            // | a c tx | | 1 0 +rx | | 1 0 -rx |   | a c tx + (a * rx + c * ry) | | 1 0 -rx |
            // | b d ty | | 0 1 +ry | | 0 1 -ry | = | b d ty + (b * rx + d * ry) | | 0 1 -ry |
            // | 0 0 1  | | 0 0  1  | | 0 0  1  |   | 0 0 1                      | | 0 0  1  |
            //
            // tx -> tx + (a * rx + c * ry) = poxition.x - (a * pivot.x + c * pivot.y)
            // ty -> ty + (b * rx + d * ry) = poxition.y - (b * pivot.x + d * pivot.y)
            // position.x -> position.x + (a * rx + c * ry) - (a * pivot.x + c * pivot.y)
            // position.y -> position.y + (b * rx + d * ry) - (b * pivot.x + d * pivot.y)
            // pivot.x -> 0
            // pivot.y -> 0
            //
            // a -> a', b -> b', c -> c', tx -> tx', ty -> ty'
            //
            // | a' c' tx' | | 1 0 -rx |   | a' c' tx' - (a' * rx + c' * ry) |
            // | b' d' ty' | | 0 1 -ry | = | b' d' ty' - (b' * rx + d' * ry) |
            // | 0  0  1   | | 0 0  1  |   | 0  0  1                         |
            //
            // tx' -> tx' - (a' * rx + c' * ry) = poxition.x - (a' * pivot.x + c' * pivot.y)
            // ty' -> ty' - (b' * rx + d' * ry) = poxition.y - (b' * pivot.x + d' * pivot.y)
            // pivot.x -> pivot.x + rx
            // pivot.y -> pivot.y + ry
            parent.updateTransform();
            var transform = parent.transform;
            var x = rect.x + rect.width * 0.5;
            var y = rect.y + rect.height * 0.5;
            var position = transform.position;
            var localTransform = transform.localTransform;
            var a = localTransform.a;
            var b = localTransform.b;
            var c = localTransform.c;
            var d = localTransform.d;
            var pivot = transform.pivot;
            position.set(position.x + (a * x + c * y) - (a * pivot.x + c * pivot.y), position.y + (b * x + d * y) - (b * pivot.x + d * pivot.y));
            pivot.set(x, y);
            // Reset the data
            this.reset(parent.children, this._layouts, size);
            //
            parent.allowOnTransformChange(true);
        };
        EShapeGroupSizeEditor.prototype.reset = function (children, layouts, size) {
            for (var i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                var child = children[i];
                var layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.reset(child, size.x, size.y);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            if (children.length < layouts.length) {
                layouts.length = children.length;
            }
        };
        EShapeGroupSizeEditor.prototype.calcRect = function (result) {
            var parent = this._parent;
            var children = parent.children;
            if (children.length <= 0) {
                result.x = 0;
                result.y = 0;
                result.width = 0;
                result.height = 0;
            }
            else {
                var workPoint = this._workPoint;
                var workRect = this._workRectForCalcRect;
                children[0].getBoundsLocal(workPoint, false, result);
                for (var i = 1, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    child.getBoundsLocal(workPoint, false, workRect);
                    result.enlarge(workRect);
                }
            }
            return result;
        };
        EShapeGroupSizeEditor.prototype.onChange = function (ox, oy) {
            var parent = this._parent;
            var size = this._size;
            var pivot = parent.transform.pivot;
            this.onChange_(parent.children, this._layouts, size.x, size.y, pivot.x, pivot.y, ox, oy);
            parent.onSizeChange();
        };
        EShapeGroupSizeEditor.prototype.onChange_ = function (children, layouts, sx, sy, px, py, ox, oy) {
            for (var i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                var child = children[i];
                var layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.update(child, sx, sy, px, py);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            for (var i = layouts.length, imax = children.length; i < imax; ++i) {
                var child = children[i];
                var layout = this.newLayout(child, ox, oy);
                layout.update(child, sx, sy, px, py);
                layouts.push(layout);
            }
            if (layouts.length !== children.length) {
                layouts.length = children.length;
            }
        };
        EShapeGroupSizeEditor.prototype.newLayout = function (shape, ox, oy) {
            return shape.layout || new EShapeGroupSizeLayout(shape, ox, oy);
        };
        return EShapeGroupSizeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeViewer = /** @class */ (function () {
        function EShapeGroupSizeViewer(parent, x, y, bx, by) {
            this._parent = parent;
            this._x = x;
            this._y = y;
            this._base = new pixi_js.Point(bx, by);
        }
        Object.defineProperty(EShapeGroupSizeViewer.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                if (this._x !== x) {
                    this._x = x;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeViewer.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                if (this._y !== y) {
                    this._y = y;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeViewer.prototype, "base", {
            get: function () {
                return this._base;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupSizeViewer.prototype.init = function () {
            this._base.copyFrom(this);
            this.onChange();
        };
        EShapeGroupSizeViewer.prototype.clone = function () {
            var base = this._base;
            return new EShapeGroupSizeViewer(this._parent, this._x, this._y, base.x, base.y);
        };
        EShapeGroupSizeViewer.prototype.set = function (x, y) {
            var isChanged = false;
            if (x != null && this._x !== x) {
                this._x = x;
                isChanged = true;
            }
            if (y != null && this._y !== y) {
                this._y = y;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        };
        EShapeGroupSizeViewer.prototype.copyFrom = function (p) {
            if (p instanceof EShapeGroupSizeViewer) {
                this._base.copyFrom(p.base);
            }
            if (this._x !== p.x || this._y !== p.y) {
                this._x = p.x;
                this._y = p.y;
                this.onChange();
            }
            return this;
        };
        EShapeGroupSizeViewer.prototype.copyTo = function (p) {
            if (p instanceof EShapeGroupSizeViewer) {
                this._base.copyTo(p.base);
            }
            p.set(this._x, this._y);
            return p;
        };
        EShapeGroupSizeViewer.prototype.equals = function (p) {
            return p.x === this._x && p.y === this._y;
        };
        EShapeGroupSizeViewer.prototype.fit = function () {
            // DO NOTHING
        };
        EShapeGroupSizeViewer.prototype.onChange = function () {
            var base = this._base;
            this._parent.transform.scale.set(this._x / base.x, this._y / base.y);
        };
        return EShapeGroupSizeViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStrokeSide;
    (function (EShapeStrokeSide) {
        EShapeStrokeSide[EShapeStrokeSide["NONE"] = 0] = "NONE";
        EShapeStrokeSide[EShapeStrokeSide["TOP"] = 1] = "TOP";
        EShapeStrokeSide[EShapeStrokeSide["RIGHT"] = 2] = "RIGHT";
        EShapeStrokeSide[EShapeStrokeSide["BOTTOM"] = 4] = "BOTTOM";
        EShapeStrokeSide[EShapeStrokeSide["LEFT"] = 8] = "LEFT";
        EShapeStrokeSide[EShapeStrokeSide["TOP_OR_LEFT"] = 9] = "TOP_OR_LEFT";
        EShapeStrokeSide[EShapeStrokeSide["TOP_OR_RIGHT"] = 3] = "TOP_OR_RIGHT";
        EShapeStrokeSide[EShapeStrokeSide["BOTTOM_OR_LEFT"] = 12] = "BOTTOM_OR_LEFT";
        EShapeStrokeSide[EShapeStrokeSide["BOTTOM_OR_RIGHT"] = 6] = "BOTTOM_OR_RIGHT";
        EShapeStrokeSide[EShapeStrokeSide["ALL"] = 15] = "ALL";
    })(EShapeStrokeSide || (EShapeStrokeSide = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupStrokeViewer = /** @class */ (function () {
        function EShapeGroupStrokeViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "enable", {
            get: function () {
                return false;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "width", {
            get: function () {
                return 1.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "align", {
            get: function () {
                return 0.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "side", {
            get: function () {
                return EShapeStrokeSide.NONE;
            },
            set: function (side) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "style", {
            get: function () {
                return EShapeStrokeStyle.NONE;
            },
            set: function (style) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupStrokeViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupStrokeViewer.prototype.set = function (enable, color, alpha, width, align, side, style) {
            // DO NOTHING
        };
        EShapeGroupStrokeViewer.prototype.clone = function () {
            return new EShapeGroupStrokeViewer();
        };
        EShapeGroupStrokeViewer.prototype.toObject = function () {
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE,
                style: EShapeStrokeStyle.NONE
            };
        };
        EShapeGroupStrokeViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupStrokeViewer.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupStrokeViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextAlignViewer = /** @class */ (function () {
        function EShapeGroupTextAlignViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextAlignViewer.prototype, "horizontal", {
            get: function () {
                return EShapeTextAlignHorizontal.CENTER;
            },
            set: function (horizontal) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextAlignViewer.prototype, "vertical", {
            get: function () {
                return EShapeTextAlignVertical.MIDDLE;
            },
            set: function (vertical) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextAlignViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextAlignViewer.prototype.set = function (horizontal, vertical) {
            // DO NOTHING
        };
        EShapeGroupTextAlignViewer.prototype.toObject = function () {
            return {
                horizontal: EShapeTextAlignHorizontal.CENTER,
                vertical: EShapeTextAlignVertical.MIDDLE
            };
        };
        EShapeGroupTextAlignViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextAlignViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextAlignViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextOffsetViewer = /** @class */ (function () {
        function EShapeGroupTextOffsetViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextOffsetViewer.prototype, "horizontal", {
            get: function () {
                return 0;
            },
            set: function (horizontal) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOffsetViewer.prototype, "vertical", {
            get: function () {
                return 0;
            },
            set: function (vertical) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextOffsetViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextOffsetViewer.prototype.set = function (horizontal, vertical) {
            // DO NOTHING
        };
        EShapeGroupTextOffsetViewer.prototype.toObject = function () {
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextOffsetViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextOffsetViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextOffsetViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextOutlineViewer = /** @class */ (function () {
        function EShapeGroupTextOutlineViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextOutlineViewer.prototype, "enable", {
            get: function () {
                return false;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineViewer.prototype, "width", {
            get: function () {
                return 1.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextOutlineViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextOutlineViewer.prototype.set = function (enable, color, alpha, width) {
            // DO NOTHING
        };
        EShapeGroupTextOutlineViewer.prototype.clone = function () {
            return new EShapeGroupTextOutlineViewer();
        };
        EShapeGroupTextOutlineViewer.prototype.toObject = function () {
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0
            };
        };
        EShapeGroupTextOutlineViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextOutlineViewer.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupTextOutlineViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextPaddingViewer = /** @class */ (function () {
        function EShapeGroupTextPaddingViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextPaddingViewer.prototype, "horizontal", {
            get: function () {
                return 0;
            },
            set: function (horizontal) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextPaddingViewer.prototype, "vertical", {
            get: function () {
                return 0;
            },
            set: function (vertical) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextPaddingViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextPaddingViewer.prototype.set = function (horizontal, vertical) {
            // DO NOTHING
        };
        EShapeGroupTextPaddingViewer.prototype.toObject = function () {
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextPaddingViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextPaddingViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextPaddingViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextSpacingViewer = /** @class */ (function () {
        function EShapeGroupTextSpacingViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupTextSpacingViewer.prototype, "horizontal", {
            get: function () {
                return 0;
            },
            set: function (horizontal) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextSpacingViewer.prototype, "vertical", {
            get: function () {
                return 0;
            },
            set: function (vertical) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextSpacingViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupTextSpacingViewer.prototype.set = function (horizontal, vertical) {
            // DO NOTHING
        };
        EShapeGroupTextSpacingViewer.prototype.toObject = function () {
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextSpacingViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextSpacingViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextSpacingViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextViewer = /** @class */ (function () {
        function EShapeGroupTextViewer() {
            this.align = new EShapeGroupTextAlignViewer();
            this.offset = new EShapeGroupTextOffsetViewer();
            this.outline = new EShapeGroupTextOutlineViewer();
            this.spacing = new EShapeGroupTextSpacingViewer();
            this.padding = new EShapeGroupTextPaddingViewer();
        }
        Object.defineProperty(EShapeGroupTextViewer.prototype, "enable", {
            get: function () {
                return true;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "value", {
            get: function () {
                return "";
            },
            set: function (value) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "color", {
            get: function () {
                return 0x000000;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "family", {
            get: function () {
                return "auto";
            },
            set: function (family) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "size", {
            get: function () {
                return 24;
            },
            set: function (size) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "weight", {
            get: function () {
                return EShapeTextWeight.NORMAL;
            },
            set: function (weight) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "style", {
            get: function () {
                return EShapeTextStyle.NORMAL;
            },
            set: function (style) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "direction", {
            get: function () {
                return EShapeTextDirection.LEFT_TO_RIGHT;
            },
            set: function (direction) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextViewer.prototype, "clipping", {
            get: function () {
                return false;
            },
            set: function (clipping) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextViewer.prototype.copy = function (target) {
            return this;
        };
        EShapeGroupTextViewer.prototype.set = function (value, color, alpha, family, size, weight, style, direction, clipping) {
            return this;
        };
        EShapeGroupTextViewer.prototype.toObject = function () {
            return {
                value: "",
                color: 0x000000,
                alpha: 1.0,
                family: "auto",
                size: 24,
                weight: EShapeTextWeight.NORMAL,
                align: this.align.toObject(),
                offset: this.offset.toObject(),
                style: EShapeTextStyle.NORMAL,
                outline: this.outline.toObject(),
                spacing: this.spacing.toObject(),
                direction: EShapeTextDirection.LEFT_TO_RIGHT,
                padding: this.padding.toObject(),
                clipping: false
            };
        };
        EShapeGroupTextViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextViewer.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupTextViewer;
    }());

    var EShapeGroupViewer = /** @class */ (function (_super) {
        __extends(EShapeGroupViewer, _super);
        function EShapeGroupViewer(isEditMode, type) {
            var _this = _super.call(this, type) || this;
            _this._isEditMode = isEditMode;
            _this.tag = _this.newTag();
            _this.size = _this.newGroupSize(isEditMode);
            _this.fill = _this.newGroupFill();
            _this.stroke = _this.newGroupStroke();
            _this.text = _this.newGroupText();
            return _this;
        }
        Object.defineProperty(EShapeGroupViewer.prototype, "isEditMode", {
            get: function () {
                return this._isEditMode;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupViewer.prototype.newGroupSize = function (isEditMode) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            if (isEditMode) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        };
        EShapeGroupViewer.prototype.isGroupSizeFittable = function () {
            return true;
        };
        EShapeGroupViewer.prototype.newTag = function () {
            return new EShapeTagImpl();
        };
        EShapeGroupViewer.prototype.newGroupFill = function () {
            return new EShapeGroupFillViewer();
        };
        EShapeGroupViewer.prototype.newGroupStroke = function () {
            return new EShapeGroupStrokeViewer();
        };
        EShapeGroupViewer.prototype.newGroupText = function () {
            return new EShapeGroupTextViewer();
        };
        EShapeGroupViewer.prototype.getBoundsSize = function () {
            var size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                return size.base;
            }
            else {
                return size;
            }
        };
        EShapeGroupViewer.prototype.onChildTransformChange = function () {
            _super.prototype.onChildTransformChange.call(this);
            this.size.fit();
        };
        Object.defineProperty(EShapeGroupViewer.prototype, "corner", {
            get: function () {
                return EShapeCorner.NONE;
            },
            set: function (corner) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "cursor", {
            get: function () {
                return "";
            },
            set: function (cursor) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "gradient", {
            get: function () {
                return undefined;
            },
            set: function (gradient) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "radius", {
            get: function () {
                return 0;
            },
            set: function (radius) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "image", {
            get: function () {
                return undefined;
            },
            set: function (image) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "points", {
            get: function () {
                return undefined;
            },
            set: function (points) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupViewer.prototype.containsAbs = function (x, y, ax, ay) {
            return false;
        };
        return EShapeGroupViewer;
    }(EShapeBase));

    var EShapeEmbeddedLayer = /** @class */ (function (_super) {
        __extends(EShapeEmbeddedLayer, _super);
        function EShapeEmbeddedLayer(name, isEditMode, type) {
            if (type === void 0) { type = EShapeType.LAYER; }
            var _this = _super.call(this, isEditMode, type) || this;
            _this._name = name;
            return _this;
        }
        EShapeEmbeddedLayer.prototype.isGroupSizeFittable = function () {
            return false;
        };
        EShapeEmbeddedLayer.prototype.clone = function () {
            var result = this.newClone().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            result.size.init();
            return result;
        };
        EShapeEmbeddedLayer.prototype.newClone = function () {
            var constructor = this.constructor;
            return new constructor(this._name, this._isEditMode, this.type);
        };
        EShapeEmbeddedLayer.prototype.serializeChildren = function (manager) {
            return [];
        };
        EShapeEmbeddedLayer.prototype.serializeImage = function (manager) {
            return -1;
        };
        EShapeEmbeddedLayer.prototype.serializeGradient = function (manager) {
            return -1;
        };
        return EShapeEmbeddedLayer;
    }(EShapeGroupViewer));

    var EShapeEmbeddedLayerContainer = /** @class */ (function () {
        function EShapeEmbeddedLayerContainer(width, height, isEditMode) {
            this.children = [];
            this._x = -width * 0.5;
            this._y = -height * 0.5;
            this._width = width;
            this._height = height;
            this._isEditMode = isEditMode;
        }
        EShapeEmbeddedLayerContainer.prototype.create = function (name) {
            var result = new EShapeEmbeddedLayer(name, this._isEditMode);
            result.transform.position.set(this._x, this._y);
            result.size.set(this._width, this._height).init();
            this.children.push(result);
            return result;
        };
        return EShapeEmbeddedLayerContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagrams = /** @class */ (function () {
        function DDiagrams() {
        }
        DDiagrams.toSimple = function (serialized) {
            var tags = serialized.tags;
            var pieces = serialized.pieces;
            return {
                version: serialized.version,
                id: serialized.id,
                name: serialized.name,
                tags: tags != null ? JSON.stringify(tags) : undefined,
                pieces: pieces != null ? JSON.stringify(pieces) : undefined,
                thumbnail: serialized.thumbnail,
                data: JSON.stringify({
                    width: serialized.width,
                    height: serialized.height,
                    background: serialized.background,
                    tile: serialized.tile,
                    resources: serialized.resources,
                    layers: serialized.layers,
                    items: serialized.items,
                    snap: serialized.snap
                })
            };
        };
        DDiagrams.toSerialized = function (target) {
            if ("data" in target) {
                var result = JSON.parse(target.data);
                result.version = target.version;
                result.id = target.id;
                result.name = target.name;
                var tags = target.tags;
                if (tags != null) {
                    result.tags = JSON.parse(tags);
                }
                var pieces = target.pieces;
                if (pieces != null) {
                    result.pieces = JSON.parse(pieces);
                }
                result.thumbnail = target.thumbnail;
                return result;
            }
            return target;
        };
        DDiagrams.newLayer = function (serialized, container, manager) {
            // Layers
            var serializedLayers = serialized.layers;
            for (var i = 0, imax = serializedLayers.length; i < imax; ++i) {
                container.create(serializedLayers[i][0] || "");
            }
            // Items
            var serializedItems = serialized.items;
            var shapePromises = EShapeDeserializer.deserializeAll(serializedItems, manager);
            if (shapePromises != null) {
                return shapePromises.then(function (shapes) {
                    var layers = container.children;
                    for (var i = 0, imax = shapes.length; i < imax; ++i) {
                        var serializedItem = serializedItems[i];
                        var shape = shapes[i];
                        var layer = layers[serializedItem[16]];
                        if (layer != null) {
                            shape.attach(layer);
                        }
                    }
                    return shapes;
                });
            }
            else {
                return Promise.resolve([]);
            }
        };
        DDiagrams.toPieceData = function (controller, pieces, isEditMode, mappings) {
            var _this = this;
            if (pieces && 0 < pieces.length && controller) {
                var newMappings_1 = mappings || new Map();
                return new Promise(function (resolve) {
                    var size = pieces.length;
                    var finished = size;
                    var onFinished = function () {
                        finished -= 1;
                        if (finished <= 0) {
                            resolve(newMappings_1);
                        }
                    };
                    var load = function (piece) {
                        if (newMappings_1.has(piece)) {
                            onFinished();
                        }
                        else {
                            controller.piece.getByName(piece).then(function (found) {
                                _this.toPieceDataSub(controller, piece, found, isEditMode, newMappings_1).then(onFinished, onFinished);
                            }, onFinished);
                        }
                    };
                    for (var i = 0; i < size; ++i) {
                        load(pieces[i]);
                    }
                });
            }
        };
        DDiagrams.toPieceDataSub = function (controller, name, serializedOrSimple, isEditMode, mappings) {
            var _this = this;
            var serialized = this.toSerialized(serializedOrSimple);
            var width = serialized.width;
            var height = serialized.height;
            var container = new EShapeEmbeddedLayerContainer(width, height, isEditMode);
            mappings.set(name, new EShapeEmbeddedDatum(name, width, height, container));
            var pieces = serialized.pieces;
            var pieceDataOrPromise = this.toPieceData(controller, pieces, isEditMode, mappings);
            if (pieceDataOrPromise == null) {
                return this.newLayer(serialized, container, new EShapeResourceManagerDeserialization(serialized, undefined, undefined, isEditMode));
            }
            else {
                return pieceDataOrPromise.then(function (pieceData) {
                    return _this.newLayer(serialized, container, new EShapeResourceManagerDeserialization(serialized, pieces, pieceData, isEditMode));
                });
            }
        };
        return DDiagrams;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextAlignEditor = /** @class */ (function () {
        function EShapeGroupTextAlignEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextAlignEditor.prototype, "horizontal", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.align.horizontal;
                }
                return EShapeTextAlignHorizontal.CENTER;
            },
            set: function (horizontal) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.align.horizontal = horizontal;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextAlignEditor.prototype, "vertical", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.align.vertical;
                }
                return EShapeTextAlignVertical.MIDDLE;
            },
            set: function (vertical) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.align.vertical = vertical;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextAlignEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.align.copy(target);
            }
        };
        EShapeGroupTextAlignEditor.prototype.set = function (horizontal, vertical) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.align.set(horizontal, vertical);
            }
        };
        EShapeGroupTextAlignEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.align.toObject();
            }
            return {
                horizontal: EShapeTextAlignHorizontal.CENTER,
                vertical: EShapeTextAlignVertical.MIDDLE
            };
        };
        EShapeGroupTextAlignEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextAlignEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextAlignEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextOffsetEditor = /** @class */ (function () {
        function EShapeGroupTextOffsetEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextOffsetEditor.prototype, "horizontal", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.offset.horizontal;
                }
                return 0;
            },
            set: function (horizontal) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.offset.horizontal = horizontal;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOffsetEditor.prototype, "vertical", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.offset.vertical;
                }
                return 0;
            },
            set: function (vertical) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.offset.vertical = vertical;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextOffsetEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.offset.copy(target);
            }
        };
        EShapeGroupTextOffsetEditor.prototype.set = function (horizontal, vertical) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.offset.set(horizontal, vertical);
            }
        };
        EShapeGroupTextOffsetEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.offset.toObject();
            }
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextOffsetEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextOffsetEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextOffsetEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextOutlineEditor = /** @class */ (function () {
        function EShapeGroupTextOutlineEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextOutlineEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.outline.enable;
                }
                return false;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.outline.enable = enable;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.outline.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.outline.color = color;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.outline.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.outline.alpha = alpha;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextOutlineEditor.prototype, "width", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.outline.width;
                }
                return 1.0;
            },
            set: function (width) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.outline.width = width;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextOutlineEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.outline.copy(target);
            }
        };
        EShapeGroupTextOutlineEditor.prototype.set = function (enable, color, alpha, width) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.outline.set(enable, color, alpha, width);
            }
        };
        EShapeGroupTextOutlineEditor.prototype.clone = function () {
            return new EShapeGroupTextOutlineEditor(this._parent);
        };
        EShapeGroupTextOutlineEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.outline.toObject();
            }
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0
            };
        };
        EShapeGroupTextOutlineEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextOutlineEditor.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupTextOutlineEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextPaddingEditor = /** @class */ (function () {
        function EShapeGroupTextPaddingEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextPaddingEditor.prototype, "horizontal", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.padding.horizontal;
                }
                return 0;
            },
            set: function (horizontal) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.padding.horizontal = horizontal;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextPaddingEditor.prototype, "vertical", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.padding.vertical;
                }
                return 0;
            },
            set: function (vertical) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.padding.vertical = vertical;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextPaddingEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.padding.copy(target);
            }
        };
        EShapeGroupTextPaddingEditor.prototype.set = function (horizontal, vertical) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.padding.set(horizontal, vertical);
            }
        };
        EShapeGroupTextPaddingEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.padding.toObject();
            }
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextPaddingEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextPaddingEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextPaddingEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextSpacingEditor = /** @class */ (function () {
        function EShapeGroupTextSpacingEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupTextSpacingEditor.prototype, "horizontal", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.spacing.horizontal;
                }
                return 0;
            },
            set: function (horizontal) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.spacing.horizontal = horizontal;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextSpacingEditor.prototype, "vertical", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.spacing.vertical;
                }
                return 0;
            },
            set: function (vertical) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.spacing.vertical = vertical;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextSpacingEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.spacing.copy(target);
            }
        };
        EShapeGroupTextSpacingEditor.prototype.set = function (horizontal, vertical) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.spacing.set(horizontal, vertical);
            }
        };
        EShapeGroupTextSpacingEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.spacing.toObject();
            }
            return {
                horizontal: 0,
                vertical: 0
            };
        };
        EShapeGroupTextSpacingEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextSpacingEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextSpacingEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupTextEditor = /** @class */ (function () {
        function EShapeGroupTextEditor(parent) {
            this._parent = parent;
            this.align = new EShapeGroupTextAlignEditor(parent);
            this.offset = new EShapeGroupTextOffsetEditor(parent);
            this.outline = new EShapeGroupTextOutlineEditor(parent);
            this.spacing = new EShapeGroupTextSpacingEditor(parent);
            this.padding = new EShapeGroupTextPaddingEditor(parent);
        }
        Object.defineProperty(EShapeGroupTextEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.enable;
                }
                return true;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.enable = enable;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "value", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.value;
                }
                return "";
            },
            set: function (value) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.value = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.color;
                }
                return 0x000000;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.color = color;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.alpha = alpha;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "family", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.family;
                }
                return "auto";
            },
            set: function (family) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.family = family;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "size", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.size;
                }
                return 24;
            },
            set: function (size) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.size = size;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "weight", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.weight;
                }
                return EShapeTextWeight.NORMAL;
            },
            set: function (weight) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.weight = weight;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "style", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.style;
                }
                return EShapeTextStyle.NORMAL;
            },
            set: function (style) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.style = style;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "direction", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.direction;
                }
                return 0;
            },
            set: function (direction) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.direction = direction;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupTextEditor.prototype, "clipping", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].text.clipping;
                }
                return false;
            },
            set: function (clipping) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].text.clipping = clipping;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupTextEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.copy(target);
            }
            return this;
        };
        EShapeGroupTextEditor.prototype.set = function (value, color, alpha, family, size, weight, style, direction) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].text.set(value, color, alpha, family, size, weight, style, direction);
            }
            return this;
        };
        EShapeGroupTextEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].text.toObject();
            }
            return {
                value: "",
                color: 0x000000,
                alpha: 1.0,
                family: "auto",
                size: 24,
                weight: EShapeTextWeight.NORMAL,
                align: this.align.toObject(),
                offset: this.offset.toObject(),
                style: EShapeTextStyle.NORMAL,
                outline: this.outline.toObject(),
                spacing: this.spacing.toObject(),
                direction: EShapeTextDirection.LEFT_TO_RIGHT,
                padding: this.padding.toObject(),
                clipping: false
            };
        };
        EShapeGroupTextEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupTextEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupTextEditor;
    }());

    var EShapeEmbedded = /** @class */ (function (_super) {
        __extends(EShapeEmbedded, _super);
        function EShapeEmbedded(name, isEditMode, type) {
            if (type === void 0) { type = EShapeType.EMBEDDED; }
            var _this = _super.call(this, isEditMode, type) || this;
            _this._name = name;
            return _this;
        }
        Object.defineProperty(EShapeEmbedded.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: false,
            configurable: true
        });
        EShapeEmbedded.prototype.newGroupText = function () {
            return new EShapeGroupTextEditor(this);
        };
        EShapeEmbedded.prototype.isGroupSizeFittable = function () {
            return false;
        };
        EShapeEmbedded.prototype.clone = function () {
            var result = this.newClone().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            return result;
        };
        EShapeEmbedded.prototype.newClone = function () {
            var constructor = this.constructor;
            return new constructor(this._name, this._isEditMode, this.type);
        };
        EShapeEmbedded.prototype.serializeChildren = function (manager) {
            return [];
        };
        EShapeEmbedded.prototype.serializeImage = function (manager) {
            return -1;
        };
        EShapeEmbedded.prototype.serializeGradient = function (manager) {
            return -1;
        };
        EShapeEmbedded.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = manager.addPiece(this._name);
            return result;
        };
        EShapeEmbedded.prototype.addUuid = function (manager) {
            this.uuid = manager.addUuid(this.uuid);
        };
        EShapeEmbedded.prototype.updateUuid = function (manager) {
            this.uuid = manager.updateUuid(this.uuid);
        };
        return EShapeEmbedded;
    }(EShapeGroupViewer));

    var EShapeEmbeddeds = /** @class */ (function () {
        function EShapeEmbeddeds() {
        }
        EShapeEmbeddeds.from = function (serializedOrSimple, controller, isEditMode) {
            var _this = this;
            var serialized = DDiagrams.toSerialized(serializedOrSimple);
            var pieces = serialized.pieces;
            var pieceDataOrPromise = DDiagrams.toPieceData(controller, pieces, isEditMode);
            if (pieceDataOrPromise == null) {
                return this.from_(serialized, isEditMode);
            }
            else {
                return pieceDataOrPromise.then(function (pieceData) {
                    return _this.from_(serialized, isEditMode, pieces, pieceData);
                });
            }
        };
        EShapeEmbeddeds.from_ = function (serialized, isEditMode, pieces, pieceData) {
            var _this = this;
            var width = serialized.width;
            var height = serialized.height;
            var container = new EShapeEmbeddedLayerContainer(width, height, isEditMode);
            var manager = new EShapeResourceManagerDeserialization(serialized, pieces, pieceData, isEditMode);
            return DDiagrams.newLayer(serialized, container, manager).then(function () {
                return _this.create(serialized.name, width, height, container, manager);
            });
        };
        EShapeEmbeddeds.deserialize = function (name, width, height, layer, manager, item) {
            var shape = new EShapeEmbedded(name, manager.isEditMode);
            var result = EShapeDeserializer.deserialize(item, manager, shape);
            var shapeSize = shape.size;
            var sizeX = shapeSize.x;
            var sizeY = shapeSize.y;
            shape.size.set(width, height);
            this.init(shape, layer);
            shape.size.set(sizeX, sizeY);
            return result;
        };
        EShapeEmbeddeds.create = function (name, width, height, layer, manager) {
            var shape = new EShapeEmbedded(name, manager.isEditMode);
            shape.size.set(width, height);
            this.init(shape, layer);
            return shape;
        };
        EShapeEmbeddeds.init = function (shape, layer) {
            var layers = layer.children;
            var children = shape.children;
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                var clone = layers[i].clone();
                clone.parent = shape;
                children.push(clone);
            }
            shape.onChildTransformChange();
            shape.toDirty();
            shape.size.init();
        };
        return EShapeEmbeddeds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeEmbedded = function (item, manager) {
        var pieces = manager.pieces;
        var pieceId = item[15];
        if (pieces && 0 <= pieceId && pieceId < pieces.length) {
            var pieceData = manager.pieceData;
            if (pieceData) {
                var piece = pieces[pieceId];
                var pieceDatum = pieceData.get(piece);
                if (pieceDatum) {
                    return EShapeEmbeddeds.deserialize(piece, pieceDatum.width, pieceDatum.height, pieceDatum.layer, manager, item);
                }
            }
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeEmbedded = function () {
        EShapeUploadeds[EShapeType.EMBEDDED] = createGroupUploaded;
        EShapeDeserializers[EShapeType.EMBEDDED] = deserializeEmbedded;
        EShapeCapabilities.set(EShapeType.EMBEDDED, EShapeCapability.EMBEDDED);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupFillEditor = /** @class */ (function () {
        function EShapeGroupFillEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupFillEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.enable;
                }
                return true;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.enable = enable;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.color = color;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.alpha = alpha;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupFillEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.copy(target);
            }
        };
        EShapeGroupFillEditor.prototype.set = function (enable, color, alpha) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.set(enable, color, alpha);
            }
        };
        EShapeGroupFillEditor.prototype.clone = function () {
            return new EShapeGroupFillEditor(this._parent);
        };
        EShapeGroupFillEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].fill.toObject();
            }
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        };
        EShapeGroupFillEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupFillEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupFillEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupPoints = /** @class */ (function () {
        function EShapeGroupPoints(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupPoints.prototype, "length", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.length;
                    }
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "id", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.id;
                    }
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "values", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.values;
                    }
                }
                return [];
            },
            set: function (values) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.values = values;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "segments", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.segments;
                    }
                }
                return [];
            },
            set: function (segments) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.segments = segments;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "style", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.style;
                    }
                }
                return EShapePointsStyle.NONE;
            },
            set: function (style) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.style = style;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "formatter", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.formatter;
                    }
                }
                return null;
            },
            set: function (formatter) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.formatter = formatter;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "formatted", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.formatted;
                    }
                }
                return this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupPoints.prototype.copy = function (source) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    points.copy(source);
                }
            }
            return this;
        };
        EShapeGroupPoints.prototype.set = function (values, segments, style) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    points.set(values, segments, style);
                }
            }
            return this;
        };
        EShapeGroupPoints.prototype.clone = function (parent) {
            return new EShapeGroupPoints(parent);
        };
        EShapeGroupPoints.prototype.toPoints = function (transform) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.toPoints(transform);
                }
            }
            return [];
        };
        EShapeGroupPoints.prototype.serialize = function (manager) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.serialize(manager);
                }
            }
            return -1;
        };
        return EShapeGroupPoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupStrokeEditor = /** @class */ (function () {
        function EShapeGroupStrokeEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.enable;
                }
                return false;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.enable = enable;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.color = color;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.alpha = alpha;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "width", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.width;
                }
                return 1.0;
            },
            set: function (width) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.width = width;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "align", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.align;
                }
                return 1.0;
            },
            set: function (align) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.align = align;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "side", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.side;
                }
                return 1.0;
            },
            set: function (side) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.side = side;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "style", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.style;
                }
                return EShapeStrokeStyle.NONE;
            },
            set: function (style) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.style = style;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupStrokeEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.copy(target);
            }
        };
        EShapeGroupStrokeEditor.prototype.set = function (enable, color, alpha, width, side) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.set(enable, color, alpha, width, side);
            }
        };
        EShapeGroupStrokeEditor.prototype.clone = function () {
            return new EShapeGroupStrokeEditor(this._parent);
        };
        EShapeGroupStrokeEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.toObject();
            }
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE,
                style: EShapeStrokeStyle.NONE
            };
        };
        EShapeGroupStrokeEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupStrokeEditor.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupStrokeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroup = /** @class */ (function (_super) {
        __extends(EShapeGroup, _super);
        function EShapeGroup(isEditMode, type) {
            if (type === void 0) { type = EShapeType.GROUP; }
            var _this = _super.call(this, type) || this;
            _this._isEditMode = isEditMode;
            _this.tag = new EShapeTagImpl();
            _this.size = _this.newGroupSize(isEditMode);
            _this.fill = _this.newGroupFill();
            _this.stroke = _this.newGroupStroke();
            _this.text = _this.newGroupText();
            _this._points = _this.newGroupPoints();
            return _this;
        }
        Object.defineProperty(EShapeGroup.prototype, "isEditMode", {
            get: function () {
                return this._isEditMode;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroup.prototype.newGroupSize = function (isEditMode) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            if (isEditMode) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        };
        EShapeGroup.prototype.isGroupSizeFittable = function () {
            return true;
        };
        EShapeGroup.prototype.newGroupFill = function () {
            return new EShapeGroupFillEditor(this);
        };
        EShapeGroup.prototype.newGroupStroke = function () {
            return new EShapeGroupStrokeEditor(this);
        };
        EShapeGroup.prototype.newGroupText = function () {
            return new EShapeGroupTextEditor(this);
        };
        EShapeGroup.prototype.newGroupPoints = function () {
            return new EShapeGroupPoints(this);
        };
        EShapeGroup.prototype.getBoundsSize = function () {
            var size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                return size.base;
            }
            else {
                return size;
            }
        };
        EShapeGroup.prototype.onChildTransformChange = function () {
            _super.prototype.onChildTransformChange.call(this);
            this.size.fit();
        };
        Object.defineProperty(EShapeGroup.prototype, "corner", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].corner;
                }
                return EShapeCorner.ALL;
            },
            set: function (corner) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].corner = corner;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "cursor", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].cursor;
                }
                return "";
            },
            set: function (cursor) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].cursor = cursor;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "gradient", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var gradient = children[i].gradient;
                    if (gradient != null) {
                        return gradient;
                    }
                }
                return undefined;
            },
            set: function (gradient) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].gradient = gradient;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "radius", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].radius;
                }
                return 0.5;
            },
            set: function (radius) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].radius = radius;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "image", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var image = children[i].image;
                    if (image != null) {
                        return image;
                    }
                }
                return undefined;
            },
            set: function (image) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].image = image;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "points", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var points = children[i].points;
                    if (points != null) {
                        return this._points;
                    }
                }
                return undefined;
            },
            set: function (points) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroup.prototype.clone = function () {
            var result = this.newClone().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            return result;
        };
        EShapeGroup.prototype.newClone = function () {
            var constructor = this.constructor;
            return new constructor(this._isEditMode, this.type);
        };
        EShapeGroup.prototype.containsAbs = function (x, y, ax, ay) {
            return false;
        };
        return EShapeGroup;
    }(EShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeGroup = function (item, manager) {
        var shape = new EShapeGroup(manager.isEditMode);
        var result = EShapeDeserializer.deserialize(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeGroup = function () {
        EShapeUploadeds[EShapeType.GROUP] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP] = deserializeGroup;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeShadowed = /** @class */ (function () {
        function EShapeGroupSizeShadowed(parent, x, y) {
            this._parent = parent;
            this._size = new pixi_js.Point(x, y);
        }
        EShapeGroupSizeShadowed.prototype.init = function () {
            // DO NOTHING
        };
        Object.defineProperty(EShapeGroupSizeShadowed.prototype, "x", {
            get: function () {
                return this._size.x;
            },
            set: function (x) {
                var size = this._size;
                if (size.x !== x) {
                    var ox = size.x;
                    size.x = x;
                    this.onChange(ox, size.y);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeShadowed.prototype, "y", {
            get: function () {
                return this._size.y;
            },
            set: function (y) {
                var size = this._size;
                if (size.y !== y) {
                    var oy = size.y;
                    size.y = y;
                    this.onChange(size.x, oy);
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupSizeShadowed.prototype.set = function (x, y) {
            var isChanged = false;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeShadowed.prototype.clone = function () {
            var size = this._size;
            return new EShapeGroupSizeShadowed(this._parent, size.x, size.y);
        };
        EShapeGroupSizeShadowed.prototype.copy = function () {
            // DO NOTHING
        };
        EShapeGroupSizeShadowed.prototype.copyFrom = function (point) {
            var x = point.x;
            var y = point.y;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeShadowed.prototype.copyTo = function (point) {
            return this._size.copyTo(point);
        };
        EShapeGroupSizeShadowed.prototype.equals = function (point) {
            return this._size.equals(point);
        };
        EShapeGroupSizeShadowed.prototype.fit = function () {
            // DO NOTHING
        };
        EShapeGroupSizeShadowed.prototype.onChange = function (ox, oy) {
            this._parent.onSizeChange();
        };
        return EShapeGroupSizeShadowed;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupShadowed = /** @class */ (function (_super) {
        __extends(EShapeGroupShadowed, _super);
        function EShapeGroupShadowed(isEditMode, type) {
            if (type === void 0) { type = EShapeType.GROUP_SHADOWED; }
            return _super.call(this, isEditMode, type) || this;
        }
        EShapeGroupShadowed.prototype.newGroupSize = function (isEditMode) {
            if (isEditMode) {
                return new EShapeGroupSizeShadowed(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            }
            else {
                return _super.prototype.newGroupSize.call(this, isEditMode);
            }
        };
        return EShapeGroupShadowed;
    }(EShapeGroup));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeGroupShadowed = function (item, manager) {
        var shape = new EShapeGroupShadowed(manager.isEditMode);
        var result = EShapeDeserializer.deserialize(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeGroupShadowed = function () {
        EShapeUploadeds[EShapeType.GROUP_SHADOWED] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP_SHADOWED] = deserializeGroupShadowed;
    };

    var RECTANGLE_VERTEX_COUNT = 24;
    var RECTANGLE_INDEX_COUNT = 16;
    var RECTANGLE_WORLD_SIZE = [0, 0, 0, 0];
    var RECTANGLE_WORK_POINT = new pixi_js.Point();
    var buildRectangleClipping = function (clippings, voffset, worldSize) {
        var brxi = 1 - worldSize[0];
        var bryi = 1 - worldSize[1];
        var ic = voffset * 3 - 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = bryi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = bryi;
        clippings[++ic] = 0;
        // --------------------------------
        clippings[++ic] = 0;
        clippings[++ic] = bryi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = bryi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        // --------------------------------
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = brxi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = brxi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        // --------------------------------
        clippings[++ic] = brxi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = brxi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
    };
    var buildRectangleIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
        // --------------------------------
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 11;
        // --------------------------------
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 15;
        // --------------------------------
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 23;
    };
    var buildRectangleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // b0              b1
        // |-------|-------|
        // |       |       |
        // |-------|-------|
        // |       |       |
        // |-------|-------|
        // b3              b2
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var work = RECTANGLE_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var b0x = work.x;
        var b0y = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        var b1x = work.x;
        var b1y = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        var b2x = work.x;
        var b2y = work.y;
        var b3x = b0x + (b2x - b1x);
        var b3y = b0y + (b2y - b1y);
        var ax = toLength(b0x, b0y, b1x, b1y) * 0.5;
        var ay = toLength(b1x, b1y, b2x, b2y) * 0.5;
        var brx = 1;
        var bry = 1;
        if (ax <= ay) {
            bry = ax / ay;
        }
        else {
            brx = ay / ax;
        }
        worldSize[0] = brx;
        worldSize[1] = bry;
        worldSize[2] = ax;
        worldSize[3] = ay;
        // 0      1  2      3
        // |------|--|------|
        // |      |  |      |
        // |------4--5------|
        // |      |  |      |
        // |------6--7------|
        // |      |  |      |
        // |------|--|------|
        // 8      9  10     11
        var d01x = brx * (b1x - b0x) * 0.5;
        var d01y = brx * (b1y - b0y) * 0.5;
        var d03x = bry * (b3x - b0x) * 0.5;
        var d03y = bry * (b3y - b0y) * 0.5;
        var iv = (voffset << 1) - 1;
        vertices[++iv] = b0x;
        vertices[++iv] = b0y;
        vertices[++iv] = b0x + d01x;
        vertices[++iv] = b0y + d01y;
        vertices[++iv] = b1x - d01x;
        vertices[++iv] = b1y - d01y;
        vertices[++iv] = b1x;
        vertices[++iv] = b1y;
        vertices[++iv] = b0x + d01x + d03x;
        vertices[++iv] = b0y + d01y + d03y;
        vertices[++iv] = b1x - d01x + d03x;
        vertices[++iv] = b1y - d01y + d03y;
        vertices[++iv] = b3x + d01x - d03x;
        vertices[++iv] = b3y + d01y - d03y;
        vertices[++iv] = b2x - d01x - d03x;
        vertices[++iv] = b2y - d01y - d03y;
        vertices[++iv] = b3x;
        vertices[++iv] = b3y;
        vertices[++iv] = b3x + d01x;
        vertices[++iv] = b3y + d01y;
        vertices[++iv] = b2x - d01x;
        vertices[++iv] = b2y - d01y;
        vertices[++iv] = b2x;
        vertices[++iv] = b2y;
        // 12               20
        // |------|--|------|
        // |      |  |      |
        // 13----16--18-----21
        // |      |  |      |
        // 14----17--19-----22
        // |      |  |      |
        // |------|--|------|
        // 15               23
        vertices[++iv] = b0x;
        vertices[++iv] = b0y;
        vertices[++iv] = b0x + d03x;
        vertices[++iv] = b0y + d03y;
        vertices[++iv] = b3x - d03x;
        vertices[++iv] = b3y - d03y;
        vertices[++iv] = b3x;
        vertices[++iv] = b3y;
        vertices[++iv] = b0x + d03x + d01x;
        vertices[++iv] = b0y + d03y + d01y;
        vertices[++iv] = b3x - d03x + d01x;
        vertices[++iv] = b3y - d03y + d01y;
        vertices[++iv] = b1x + d03x - d01x;
        vertices[++iv] = b1y + d03y - d01y;
        vertices[++iv] = b2x - d03x - d01x;
        vertices[++iv] = b2y - d03y - d01y;
        vertices[++iv] = b1x;
        vertices[++iv] = b1y;
        vertices[++iv] = b1x + d03x;
        vertices[++iv] = b1y + d03y;
        vertices[++iv] = b2x - d03x;
        vertices[++iv] = b2y - d03y;
        vertices[++iv] = b2x;
        vertices[++iv] = b2y;
    };
    var buildRectangleStep = function (voffset, steps, strokeWidth, strokeSide, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var brx = worldSize[0];
        var bry = worldSize[1];
        var brxi = Math.max(0, 1 - brx);
        var bryi = Math.max(0, 1 - bry);
        var sx = worldSize[2];
        var sy = worldSize[3];
        var wt;
        var bt;
        if (strokeSide & EShapeStrokeSide.TOP) {
            wt = +2;
            bt = +1 + bryi;
        }
        else {
            wt = -2;
            bt = -1 - bryi;
        }
        var wr;
        var br;
        if (strokeSide & EShapeStrokeSide.RIGHT) {
            wr = +2;
            br = +1 + brxi;
        }
        else {
            wr = -2;
            br = -1 - brxi;
        }
        var wb;
        var bb;
        if (strokeSide & EShapeStrokeSide.BOTTOM) {
            wb = +2;
            bb = +1 + bryi;
        }
        else {
            wb = -2;
            bb = -1 - bryi;
        }
        var wl;
        var bl;
        if (strokeSide & EShapeStrokeSide.LEFT) {
            wl = +2;
            bl = +1 + brxi;
        }
        else {
            wl = -2;
            bl = -1 - brxi;
        }
        // 0 1 2 3
        var is = (voffset - 1) * 6 - 1;
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, wt);
        // 4 5
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, bt);
        // 6 7
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, bb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, bb);
        // 8 9 10 11
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, wb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, wb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, wb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, wb);
        // ------------------------------
        // 12 13 14 15
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, bb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, wb);
        // 16 17
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, bb);
        // 18 19
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, bb);
        // 20 21 22 23
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, bb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, wb);
    };
    var fillRectangleStep = function (steps, is, v0, v1, v2, v3, v4, v5) {
        steps[++is] = v0;
        steps[++is] = v1;
        steps[++is] = v2;
        steps[++is] = v3;
        steps[++is] = v4;
        steps[++is] = v5;
    };
    var buildRectangleUv = function (uvs, voffset, textureUvs, worldSize) {
        var x0 = textureUvs.x0;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var x1 = textureUvs.x1;
        var y2 = textureUvs.y2;
        var x2 = textureUvs.x2;
        var y3 = textureUvs.y3;
        var x3 = textureUvs.x3;
        var brx = worldSize[0];
        var bry = worldSize[1];
        var d01x = brx * (x1 - x0) * 0.5;
        var d01y = brx * (y1 - y0) * 0.5;
        var d03x = bry * (x3 - x0) * 0.5;
        var d03y = bry * (y3 - y0) * 0.5;
        // UVs
        var iuv = (voffset << 1) - 1;
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = x0 + d01x;
        uvs[++iuv] = y0 + d01y;
        uvs[++iuv] = x1 - d01x;
        uvs[++iuv] = y1 - d01y;
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = x0 + d01x + d03x;
        uvs[++iuv] = y0 + d01y + d03y;
        uvs[++iuv] = x1 - d01x + d03x;
        uvs[++iuv] = y1 - d01y + d03y;
        uvs[++iuv] = x3 + d01x - d03x;
        uvs[++iuv] = y3 + d01y - d03y;
        uvs[++iuv] = x2 - d01x - d03x;
        uvs[++iuv] = y2 - d01y - d03y;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x3 + d01x;
        uvs[++iuv] = y3 + d01y;
        uvs[++iuv] = x2 - d01x;
        uvs[++iuv] = y2 - d01y;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        // ------------------------------
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = x0 + d03x;
        uvs[++iuv] = y0 + d03y;
        uvs[++iuv] = x3 - d03x;
        uvs[++iuv] = y3 - d03y;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x0 + d03x + d01x;
        uvs[++iuv] = y0 + d03y + d01y;
        uvs[++iuv] = x3 - d03x + d01x;
        uvs[++iuv] = y3 - d03y + d01y;
        uvs[++iuv] = x1 + d03x - d01x;
        uvs[++iuv] = y1 + d03y - d01y;
        uvs[++iuv] = x2 - d03x - d01x;
        uvs[++iuv] = y2 - d03y - d01y;
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = x1 + d03x;
        uvs[++iuv] = y1 + d03y;
        uvs[++iuv] = x2 - d03x;
        uvs[++iuv] = y2 - d03y;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangleUploaded = /** @class */ (function (_super) {
        __extends(EShapeRectangleUploaded, _super);
        function EShapeRectangleUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeRectangleUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeRectangleUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeRectangleUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isVertexChanged || isTransformChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // Clippings
                if (isVertexChanged) {
                    buffer.updateClippings();
                    buildRectangleClipping(buffer.clippings, voffset, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, this.toTextureUvs(texture), RECTANGLE_WORLD_SIZE);
                }
            }
        };
        return EShapeRectangleUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectangleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = RECTANGLE_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeRectangleUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangle = /** @class */ (function (_super) {
        __extends(EShapeRectangle, _super);
        function EShapeRectangle(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE; }
            return _super.call(this, type) || this;
        }
        EShapeRectangle.prototype.clone = function () {
            return new EShapeRectangle().copy(this);
        };
        EShapeRectangle.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var fill = this.fill;
                if (fill.enable) {
                    return true;
                }
                else {
                    var strokeSide = this.stroke.side;
                    if (0 < sw && strokeSide !== EShapeStrokeSide.NONE) {
                        var s = sw * ss;
                        var wx = Math.max(0.0, ax - s);
                        var wy = Math.max(0.0, ay - s);
                        if (!this.containsAbsBBox(x, y, wx, wy)) {
                            if (strokeSide === EShapeStrokeSide.ALL) {
                                return true;
                            }
                            else {
                                if (x <= -wx) {
                                    if (y <= -wy) {
                                        return !!(strokeSide & EShapeStrokeSide.TOP_OR_LEFT);
                                    }
                                    else if (+wy <= y) {
                                        return !!(strokeSide & EShapeStrokeSide.BOTTOM_OR_LEFT);
                                    }
                                    else {
                                        return !!(strokeSide & EShapeStrokeSide.LEFT);
                                    }
                                }
                                else if (+wx <= x) {
                                    if (y <= -wy) {
                                        return !!(strokeSide & EShapeStrokeSide.TOP_OR_RIGHT);
                                    }
                                    else if (+wy <= y) {
                                        return !!(strokeSide & EShapeStrokeSide.BOTTOM_OR_RIGHT);
                                    }
                                    else {
                                        return !!(strokeSide & EShapeStrokeSide.RIGHT);
                                    }
                                }
                                else {
                                    if (y <= -wy) {
                                        return !!(strokeSide & EShapeStrokeSide.TOP);
                                    }
                                    else if (+wy <= y) {
                                        return !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                    }
                                    else {
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeRectangle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImage = /** @class */ (function (_super) {
        __extends(EShapeImage, _super);
        function EShapeImage(image, type) {
            if (type === void 0) { type = EShapeType.IMAGE; }
            var _this = _super.call(this, type) || this;
            if (image != null) {
                _this.image = image;
                _this.size.set(image.width, image.height);
            }
            _this.fill.alpha = 1.0;
            return _this;
        }
        EShapeImage.prototype.clone = function () {
            return new EShapeImage(this.image).copy(this);
        };
        return EShapeImage;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeImage = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeImage());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeImage = function () {
        EShapeUploadeds[EShapeType.IMAGE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.IMAGE] = deserializeImage;
    };

    var IMAGE_SDF_VERTEX_COUNT = 9;
    var IMAGE_SDF_INDEX_COUNT = 8;
    var IMAGE_SDF_WORLD_SIZE = [0, 0];
    var IMAGE_SDF_WORK_POINT = new pixi_js.Point();
    var buildImageSdfClipping = function (clippings, voffset) {
        var ic = voffset * 3 - 1;
        var icmax = (voffset + IMAGE_SDF_VERTEX_COUNT) * 3 - 1;
        for (; ic < icmax;) {
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 2;
        }
    };
    var buildImageSdfIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 7;
    };
    var buildImageSdfStep = function (steps, voffset, strokeAlign, strokeWidth, strokeStyle, textureWidth, textureHeight, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var scaleX = textureWidth / worldSize[0];
        var scaleY = textureHeight / worldSize[1];
        var scaleZ = (scaleX + scaleY) * 0.5;
        var strokeWidthMax = 12;
        var position = -1 + strokeAlign;
        var is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleZ;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleY;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleZ;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleX;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleZ;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleX;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleZ;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleY;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleY;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
    };
    var buildImageSdfVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        // 0       1       2
        // |-------|-------|
        // |       |       |
        // 3-------4-------5
        // |       |       |
        // |-------|-------|
        // 6       7       8
        //
        var work = IMAGE_SDF_WORK_POINT;
        var sx = sizeX * 0.5;
        var sy = sizeY * 0.5;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        var x2 = work.x;
        var y2 = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        var x8 = work.x;
        var y8 = work.y;
        var x6 = x0 + (x8 - x2);
        var y6 = y0 + (y8 - y2);
        // Vertices
        var iv = (voffset << 1) - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = (x0 + x2) * 0.5;
        vertices[++iv] = (y0 + y2) * 0.5;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = (x0 + x6) * 0.5;
        vertices[++iv] = (y0 + y6) * 0.5;
        vertices[++iv] = (x0 + x8) * 0.5;
        vertices[++iv] = (y0 + y8) * 0.5;
        vertices[++iv] = (x2 + x8) * 0.5;
        vertices[++iv] = (y2 + y8) * 0.5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = (x6 + x8) * 0.5;
        vertices[++iv] = (y6 + y8) * 0.5;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        worldSize[0] = toLength(x0, y0, x2, y2) * 0.5;
        worldSize[1] = toLength(x0, y0, x6, y6) * 0.5;
    };
    var buildImageSdfUv = function (uvs, voffset, textureUv) {
        var x0 = textureUv.x0;
        var y0 = textureUv.y0;
        var x1 = textureUv.x1;
        var y1 = textureUv.y1;
        var x2 = textureUv.x2;
        var y2 = textureUv.y2;
        var x3 = textureUv.x3;
        var y3 = textureUv.y3;
        var iv = (voffset << 1) - 1;
        uvs[++iv] = x0;
        uvs[++iv] = y0;
        uvs[++iv] = (x1 + x0) * 0.5;
        uvs[++iv] = (y1 + y0) * 0.5;
        uvs[++iv] = x1;
        uvs[++iv] = y1;
        uvs[++iv] = (x0 + x3) * 0.5;
        uvs[++iv] = (y0 + y3) * 0.5;
        uvs[++iv] = (x0 + x2) * 0.5;
        uvs[++iv] = (y0 + y2) * 0.5;
        uvs[++iv] = (x1 + x2) * 0.5;
        uvs[++iv] = (y1 + y2) * 0.5;
        uvs[++iv] = x3;
        uvs[++iv] = y3;
        uvs[++iv] = (x3 + x2) * 0.5;
        uvs[++iv] = (y3 + y2) * 0.5;
        uvs[++iv] = x2;
        uvs[++iv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImageSdfUploaded = /** @class */ (function (_super) {
        __extends(EShapeImageSdfUploaded, _super);
        function EShapeImageSdfUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) {
            var _this = _super.call(this, buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) || this;
            _this.textureWidth = -1;
            _this.textureHeight = -1;
            return _this;
        }
        EShapeImageSdfUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clippings & indices
            var buffer = this.buffer;
            var voffset = this.vertexOffset;
            buffer.updateClippings();
            buffer.updateIndices();
            buildImageSdfClipping(buffer.clippings, voffset);
            buildImageSdfIndex(buffer.indices, voffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeImageSdfUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeImageSdfUploaded.prototype.updateVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = this.toTexture(shape);
            var textureWidth = texture.width * texture.resolution;
            var textureHeight = texture.height * texture.resolution;
            var isTextureSizeChanged = this.textureWidth !== textureWidth || this.textureHeight !== textureHeight;
            if (isSizeChanged || isTransformChanged || isStrokeChanged || isTextureSizeChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.textureWidth = textureWidth;
                this.textureHeight = textureHeight;
                // Invalidate the text layout to update the text layout.
                this.textSpacingHorizontal = NaN;
                // Vertices
                buffer.updateVertices();
                buildImageSdfVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, shape.transform.internalTransform, IMAGE_SDF_WORLD_SIZE);
                // Steps
                buffer.updateSteps();
                buildImageSdfStep(buffer.steps, this.vertexOffset, strokeAlign, strokeWidth, strokeStyle, textureWidth, textureHeight, IMAGE_SDF_WORLD_SIZE);
            }
        };
        EShapeImageSdfUploaded.prototype.updateUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildImageSdfUv(buffer.uvs, this.vertexOffset, this.toTextureUvs(texture));
            }
        };
        return EShapeImageSdfUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImageSdfUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = IMAGE_SDF_VERTEX_COUNT + tvcount;
        var icount = IMAGE_SDF_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeImageSdfUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImageSdf = /** @class */ (function (_super) {
        __extends(EShapeImageSdf, _super);
        function EShapeImageSdf(image, type) {
            if (type === void 0) { type = EShapeType.IMAGE_SDF; }
            return _super.call(this, image, type) || this;
        }
        EShapeImageSdf.prototype.clone = function () {
            return new EShapeImageSdf(this.image).copy(this);
        };
        return EShapeImageSdf;
    }(EShapeImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeImageSdf = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeImageSdf());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeImageSdf = function () {
        EShapeUploadeds[EShapeType.IMAGE_SDF] = createImageSdfUploaded;
        EShapeDeserializers[EShapeType.IMAGE_SDF] = deserializeImageSdf;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLabelUploaded = /** @class */ (function (_super) {
        __extends(EShapeLabelUploaded, _super);
        function EShapeLabelUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLabelUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLabelUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateLabelVertex(buffer, shape);
            this.updateLabelUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeLabelUploaded.prototype.updateLabelVertex = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            if (isSizeChanged || isTransformChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                // Invalidate the text layout to update the text layout.
                this.textSpacingHorizontal = NaN;
            }
        };
        EShapeLabelUploaded.prototype.updateLabelUv = function (buffer, shape) {
            this.texture = this.toTexture(shape);
        };
        return EShapeLabelUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLabelUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = tvcount;
        var icount = ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeLabelUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLabel = /** @class */ (function (_super) {
        __extends(EShapeLabel, _super);
        function EShapeLabel(type) {
            if (type === void 0) { type = EShapeType.LABEL; }
            return _super.call(this, type) || this;
        }
        EShapeLabel.prototype.clone = function () {
            return new EShapeLabel().copy(this);
        };
        return EShapeLabel;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLabel = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLabel());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLabel = function () {
        EShapeUploadeds[EShapeType.LABEL] = createLabelUploaded;
        EShapeDeserializers[EShapeType.LABEL] = deserializeLabel;
    };

    var LINE_FMIN = 0.00001;
    var LINE_WORK_POINT = new pixi_js.Point();
    var toPointsCount = function (points) {
        if (points) {
            return points.formatted.length;
        }
        return 0;
    };
    var toLinePointCount = function (points) {
        return Math.ceil(toPointsCount(points) / 12) * 12;
    };
    var toLineVertexCount = function (pointCount, isClosed) {
        if (isClosed) {
            return pointCount * 4 + 2;
        }
        else {
            return pointCount * 4;
        }
    };
    var toLineIndexCount = function (pointCount, isClosed) {
        return toLineVertexCount(pointCount, isClosed) - 2;
    };
    var buildLineClipping = function (clippings, voffset, vcount, pointCount) {
        var ic = voffset * 3 - 1;
        var icmax = (voffset + vcount) * 3 - 1;
        for (var i = 0; i < pointCount; ++i) {
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 3;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 5;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 4;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 6;
        }
        for (; ic < icmax;) {
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 3;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 5;
        }
    };
    var buildLineIndex = function (indices, voffset, ioffset, icount) {
        var ii = ioffset * 3 - 1;
        var iimax = (ioffset + icount) * 3 - 1;
        var io = voffset;
        for (; ii < iimax;) {
            indices[++ii] = io + 0;
            indices[++ii] = io + 2;
            indices[++ii] = io + 1;
            indices[++ii] = io + 1;
            indices[++ii] = io + 2;
            indices[++ii] = io + 3;
            io += 2;
        }
    };
    var buildLineUv = function (uvs, colorFills, voffset, vcount, textureUvs, length) {
        var lengthInverse = 1 / Math.max(LINE_FMIN, length);
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var dx01 = x1 - x0;
        var dy01 = y1 - y0;
        var dx32 = x2 - x3;
        var dy32 = y2 - y3;
        var iuv = (voffset << 1) - 1;
        var iuvmax = ((voffset + vcount) << 1) - 1;
        var icf = (voffset << 2) - 8;
        for (; iuv < iuvmax;) {
            var r = colorFills[(icf += 8)] * lengthInverse;
            uvs[++iuv] = x0 + r * dx01;
            uvs[++iuv] = y0 + r * dy01;
            uvs[++iuv] = x3 + r * dx32;
            uvs[++iuv] = y3 + r * dy32;
        }
    };
    var TRANSFORMED_POINT_VALUES;
    var buildLineVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, pointCount, pointsClosed, pointValues, pointSegments, strokeWidth, strokeStyle, internalTransform) {
        var transformedPointValues = TRANSFORMED_POINT_VALUES;
        if (transformedPointValues == null) {
            transformedPointValues = [];
            TRANSFORMED_POINT_VALUES = transformedPointValues;
        }
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var tx = internalTransform.tx;
        var ty = internalTransform.ty;
        for (var i = 0; i < pointCount; ++i) {
            var iv = i << 1;
            var x = pointValues[iv];
            var y = pointValues[iv + 1];
            transformedPointValues[iv] = a * x + c * y + tx;
            transformedPointValues[iv + 1] = b * x + d * y + ty;
        }
        return buildTransformedLineVertexStepAndColorFill(vertices, steps, colorFills, voffset, vcount, pointCount, pointsClosed, transformedPointValues, pointSegments, strokeWidth, strokeStyle);
    };
    var fillTransformedLineVertexStepAndColorFill = function (iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, llo) {
        vertices[++iv] = px;
        vertices[++iv] = py;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = pprevx;
        steps[++is] = pprevy;
        steps[++is] = pnextx;
        steps[++is] = pnexty;
        colorFills[(icf += 1)] = llo;
        vertices[++iv] = px;
        vertices[++iv] = py;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = pprevx;
        steps[++is] = pprevy;
        steps[++is] = pnextx;
        steps[++is] = pnexty;
        colorFills[(icf += 4)] = llo;
    };
    var buildTransformedLineVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, lineVertexCount, lineIsClosed, lineVertices, lineSegments, strokeWidth, strokeStyle) {
        var lineSegmentsLength = lineSegments.length;
        if (0 < lineSegmentsLength) {
            if (lineIsClosed) {
                var lmax = 0;
                var lprev = 0;
                var ivoffset = voffset;
                var iseg = 0;
                var iprevseg = lineSegments[0];
                for (var i = 1; i < lineSegmentsLength; ++i) {
                    iseg = lineSegments[i];
                    if (2 <= iseg - iprevseg) {
                        lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, -1, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                        lmax = Math.max(lmax, lprev);
                        ivoffset += toLineVertexCount(iseg - iprevseg, false);
                    }
                    iprevseg = iseg;
                }
                // Last
                iseg = lineSegments[0] + lineVertexCount;
                if (2 <= iseg - iprevseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg - iprevseg, false);
                }
                else {
                    buildTransformedLineEmptyVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                }
                return lmax;
            }
            else {
                var lmax = 0;
                var lprev = 0;
                var ivoffset = voffset;
                // First
                var iseg = lineSegments[0];
                if (2 <= iseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, -1, lineVertices, 0, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg, false);
                }
                // Middle
                var iprevseg = iseg;
                for (var i = 1; i < lineSegmentsLength; ++i) {
                    iseg = lineSegments[i];
                    if (2 <= iseg - iprevseg) {
                        lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, -1, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                        lmax = Math.max(lmax, lprev);
                        ivoffset += toLineVertexCount(iseg - iprevseg, false);
                    }
                    iprevseg = iseg;
                }
                // Last
                iseg = lineVertexCount;
                if (2 <= iseg - iprevseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg - iprevseg, false);
                }
                else {
                    buildTransformedLineEmptyVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                }
                return lmax;
            }
        }
        else {
            if (lineIsClosed) {
                return buildTransformedLineClosedSegmentVertexStepAndColorFill(vertices, steps, colorFills, voffset, vcount, lineVertices, 0, lineVertexCount, lineVertexCount, strokeWidth, strokeStyle);
            }
            else {
                return buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, voffset, vcount, lineVertices, 0, lineVertexCount, lineVertexCount, strokeWidth, strokeStyle, 0);
            }
        }
    };
    var buildTransformedLineEmptyVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle, length) {
        if (0 <= vcount) {
            var scaleInvariant = toScaleInvariant(strokeStyle);
            var iv = (voffset << 1) - 1;
            var is = voffset * 6 - 1;
            var icf = (voffset << 2) - 1;
            var ivmax = ((voffset + vcount) << 1) - 1;
            var ifirst = lineVertexFrom % lineVertexCount << 1;
            var px = lineVertices[ifirst];
            var py = lineVertices[ifirst + 1];
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = scaleInvariant;
                steps[++is] = -1;
                steps[++is] = 0;
                steps[++is] = +1;
                steps[++is] = 0;
                colorFills[++icf] = length;
                colorFills[++icf] = 0;
                colorFills[++icf] = 0;
                colorFills[++icf] = length;
            }
        }
        return 0;
    };
    var buildTransformedLineOpenSegmentVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle, length) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        // First segment
        var ifirst = lineVertexFrom % lineVertexCount << 1;
        var px = lineVertices[ifirst];
        var py = lineVertices[ifirst + 1];
        var isecond = (lineVertexFrom + 1) % lineVertexCount << 1;
        var pnextx = lineVertices[isecond];
        var pnexty = lineVertices[isecond + 1];
        var pprevx = px - (pnextx - px);
        var pprevy = py - (pnexty - py);
        var iv = (voffset << 1) - 1;
        var is = voffset * 6 - 1;
        var icf = (voffset << 2) - 1;
        var l = 0;
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, length);
        iv += 4;
        is += 12;
        icf += 8;
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
        iv += 4;
        is += 12;
        icf += 8;
        // Middle segments
        for (var i = lineVertexFrom + 1, imax = lineVertexTo - 1; i < imax; ++i) {
            pprevx = px;
            pprevy = py;
            px = pnextx;
            py = pnexty;
            var imiddle = (i + 1) % lineVertexCount << 1;
            pnextx = lineVertices[imiddle];
            pnexty = lineVertices[imiddle + 1];
            l += toLength(pprevx, pprevy, px, py);
            fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
            iv += 4;
            is += 12;
            icf += 8;
            fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
            iv += 4;
            is += 12;
            icf += 8;
        }
        // Last segment
        pprevx = px;
        pprevy = py;
        px = pnextx;
        py = pnexty;
        pnextx = px + (px - pprevx);
        pnexty = py + (py - pprevy);
        l += toLength(pprevx, pprevy, px, py);
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
        iv += 4;
        is += 12;
        icf += 8;
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
        iv += 4;
        is += 12;
        icf += 8;
        // Total length
        var dash = toDash(l, strokeWidth, strokeStyle, LINE_WORK_POINT);
        var dash0 = dash.x;
        var dash1 = dash.y;
        var icf0 = (voffset << 2) - 1;
        for (var i = icf0, imax = icf0 + 8; i < imax; i += 4) {
            colorFills[i + 2] = dash0;
            colorFills[i + 3] = dash1;
            colorFills[i + 4] = length;
        }
        for (var i = icf0 + 8; i < icf; i += 4) {
            colorFills[i + 2] = dash0;
            colorFills[i + 3] = dash1;
            colorFills[i + 4] = l;
        }
        // Fill the rest
        if (0 <= vcount) {
            var ivmax = ((voffset + vcount) << 1) - 1;
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = scaleInvariant;
                steps[++is] = pprevx;
                steps[++is] = pprevy;
                steps[++is] = pnextx;
                steps[++is] = pnexty;
                colorFills[++icf] = l;
                colorFills[++icf] = dash0;
                colorFills[++icf] = dash1;
                colorFills[++icf] = l;
            }
        }
        return l;
    };
    var buildTransformedLineClosedSegmentVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var ilast = (lineVertexTo - 1) % lineVertexCount << 1;
        var pprevx = 0;
        var pprevy = 0;
        var px = lineVertices[ilast];
        var py = lineVertices[ilast + 1];
        var ifirst = lineVertexFrom % lineVertexCount << 1;
        var pnextx = lineVertices[ifirst];
        var pnexty = lineVertices[ifirst + 1];
        var l = 0;
        var iv = (voffset << 1) - 1;
        var is = voffset * 6 - 1;
        var icf = (voffset << 2) - 1;
        for (var i = lineVertexFrom; i < lineVertexTo; ++i) {
            pprevx = px;
            pprevy = py;
            px = pnextx;
            py = pnexty;
            var imiddle = (i + 1) % lineVertexCount << 1;
            pnextx = lineVertices[imiddle];
            pnexty = lineVertices[imiddle + 1];
            l += toLength(pprevx, pprevy, px, py);
            fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
            iv += 4;
            is += 12;
            icf += 8;
            fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
            iv += 4;
            is += 12;
            icf += 8;
        }
        // Last segment
        pprevx = px;
        pprevy = py;
        px = pnextx;
        py = pnexty;
        var isecond = (lineVertexFrom + 1) % lineVertexCount << 1;
        pnextx = lineVertices[isecond];
        pnexty = lineVertices[isecond + 1];
        l += toLength(pprevx, pprevy, px, py);
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
        iv += 4;
        is += 12;
        icf += 8;
        // Total length
        var dash = toDash(l, strokeWidth, strokeStyle, LINE_WORK_POINT);
        var dash0 = dash.x;
        var dash1 = dash.y;
        for (var i = (voffset << 2) - 1; i < icf; i += 4) {
            colorFills[i + 2] = dash0;
            colorFills[i + 3] = dash1;
            colorFills[i + 4] = -1;
        }
        // Fill the rest
        if (0 <= vcount) {
            var ivmax = ((voffset + vcount) << 1) - 1;
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = strokeWidth;
                steps[++is] = scaleInvariant;
                steps[++is] = pprevx;
                steps[++is] = pprevy;
                steps[++is] = pnextx;
                steps[++is] = pnexty;
                colorFills[++icf] = l;
                colorFills[++icf] = dash0;
                colorFills[++icf] = dash1;
                colorFills[++icf] = -1;
            }
        }
        return l;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineUploaded, _super);
        function EShapeLineUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) {
            var _this = _super.call(this, buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) || this;
            _this.pointId = -1;
            _this.pointCount = 0;
            _this.pointsClosed = false;
            _this.length = 1;
            return _this;
        }
        EShapeLineUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clipping & indices
            var buffer = this.buffer;
            buffer.updateIndices();
            buildLineIndex(buffer.indices, this.vertexOffset, this.indexOffset, this.indexCount - this.textIndexCount);
            // Text
            this.initText();
            //
            this.update(shape);
            return this;
        };
        EShapeLineUploaded.prototype.isCompatible = function (shape) {
            if (_super.prototype.isCompatible.call(this, shape)) {
                var vcount = toLineVertexCount(toLinePointCount(shape.points), true);
                return vcount === this.vertexCount - this.textVertexCount;
            }
            return false;
        };
        EShapeLineUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateLineClipping(buffer, shape);
            this.updateLineVertexStepAndColorFill(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateLineUv(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeLineUploaded.prototype.updateLineClipping = function (buffer, shape) {
            var points = shape.points;
            if (points) {
                var formatted = points.formatted;
                var pointCount = formatted.length;
                if (this.pointCount !== pointCount) {
                    this.pointCount = pointCount;
                    // Invalidate the pointId to update the vertices
                    this.pointId = -1;
                    buffer.updateClippings();
                    buildLineClipping(buffer.clippings, this.vertexOffset, this.vertexCount - this.textVertexCount, pointCount);
                }
            }
        };
        EShapeLineUploaded.prototype.updateLineVertexStepAndColorFill = function (buffer, shape) {
            var points = shape.points;
            if (points) {
                var pointId = points.id;
                var formatted = points.formatted;
                var pointsClosed = !!(formatted.style & EShapePointsStyle.CLOSED);
                var isPointChanged = pointId !== this.pointId || pointsClosed !== this.pointsClosed;
                var stroke = shape.stroke;
                var strokeWidth = stroke.enable ? stroke.width : 0;
                var strokeStyle = stroke.style;
                var isStrokeWidthChanged = this.strokeWidth !== strokeWidth || this.strokeStyle !== strokeStyle;
                var transformLocalId = this.toTransformLocalId(shape);
                var isTransformChanged = this.transformLocalId !== transformLocalId;
                if (isPointChanged || isTransformChanged || isStrokeWidthChanged) {
                    this.pointId = pointId;
                    this.pointsClosed = pointsClosed;
                    this.strokeWidth = strokeWidth;
                    this.strokeStyle = strokeStyle;
                    this.transformLocalId = transformLocalId;
                    if (isPointChanged || isTransformChanged) {
                        // Invalidate the text layout to update the text layout.
                        this.textSpacingHorizontal = NaN;
                    }
                    if (isPointChanged) {
                        // Invalidate the texture transform ID to update the UVs
                        this.textureTransformId = NaN;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    buffer.updateColorFills();
                    this.length = buildLineVertexStepAndColorFill(buffer.vertices, buffer.steps, buffer.colorFills, this.vertexOffset, this.vertexCount - this.textVertexCount, this.pointCount, this.pointsClosed, formatted.values, formatted.segments, strokeWidth, strokeStyle, shape.transform.internalTransform);
                }
            }
        };
        EShapeLineUploaded.prototype.updateColorFillAndStroke = function (buffer, shape, vertexCount) {
            this.updateColorStroke(buffer, shape, vertexCount);
        };
        EShapeLineUploaded.prototype.updateLineUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildLineUv(buffer.uvs, buffer.colorFills, this.vertexOffset, this.vertexCount - this.textVertexCount, this.toTextureUvs(texture), this.length);
            }
        };
        return EShapeLineUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var points = shape.points;
        var pointCount = toLinePointCount(points);
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = toLineVertexCount(pointCount, true) + tvcount;
        var icount = toLineIndexCount(pointCount, true) + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeLineUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toIndexOf = function (array, value) {
        var i0 = 0;
        var i1 = array.length - 1;
        while (i0 <= i1) {
            var i2 = i0 + ((i1 - i0) >> 1);
            var v2 = array[i2];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return -1;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var PID = Math.PI * 2;
    var PIH = Math.PI * 0.5;
    var vdot = function (x0, y0, x1, y1) {
        return x0 * x1 + y0 * y1;
    };
    var vlen = function (x0, y0) {
        return Math.sqrt(vdot(x0, y0, x0, y0));
    };
    var vcross = function (x0, y0, x1, y1) {
        return x0 * y1 - y0 * x1;
    };
    var pnew = function () {
        return {
            center: [0, 0],
            axis1: [0, 0],
            axis2: [0, 0],
            angle: [0, 0, 0]
        };
    };
    var pset = function (cx, cy, a1x, a1y, a2x, a2y, angle1, angle2, angle3, result) {
        var c = result.center;
        c[0] = cx;
        c[1] = cy;
        var a1 = result.axis1;
        a1[0] = a1x;
        a1[1] = a1y;
        var a2 = result.axis2;
        a2[0] = a2x;
        a2[1] = a2y;
        var a = result.angle;
        a[0] = angle1;
        a[1] = angle2;
        a[2] = angle3;
        return result;
    };
    var pcopy = function (source, result) {
        var c = source.center;
        var a1 = source.axis1;
        var a2 = source.axis2;
        var a = source.angle;
        return pset(c[0], c[1], a1[0], a1[1], a2[0], a2[1], a[0], a[1], a[2], result);
    };
    var acopy = function (source, result) {
        var sourceLength = source.length;
        for (var i = 0; i < sourceLength; ++i) {
            result[i] = source[i];
        }
        if (result.length !== sourceLength) {
            result.length = sourceLength;
        }
        return result;
    };
    /**
     * An utility class for spline curves based on the work of Cem Yuksel.
     * Pleaase refer to the paper `A class of C2 interpolating splines`.
     * http://www.cemyuksel.com/research/interpolating_splines/
     */
    var UtilCurve = /** @class */ (function () {
        function UtilCurve() {
        }
        UtilCurve.set = function (center1, angle10, angle11, axis11, axis12, center2, angle20, angle21, axis21, axis22, nsegment, isAdaptive, isEdge, result, resultIndex) {
            var a = Math.max(Math.abs(angle10 - angle11), Math.abs(angle20 - angle21));
            var n = isAdaptive ? Math.max(1, Math.round(nsegment * (a / PIH))) : nsegment;
            var imax = isEdge ? n + 1 : n;
            for (var i = 0; i < imax; ++i) {
                var t = i / n;
                var w0 = 1 - t;
                var w1 = t;
                var t1 = w0 * angle10 + w1 * angle11;
                var c1 = Math.cos(t1);
                var s1 = Math.sin(t1);
                var x1 = center1[0] + c1 * axis11[0] + s1 * axis12[0];
                var y1 = center1[1] + c1 * axis11[1] + s1 * axis12[1];
                var t2 = w0 * angle20 + w1 * angle21;
                var c2 = Math.cos(t2);
                var s2 = Math.sin(t2);
                var x2 = center2[0] + c2 * axis21[0] + s2 * axis22[0];
                var y2 = center2[1] + c2 * axis21[1] + s2 * axis22[1];
                var t3 = PIH * t;
                var c3 = Math.cos(t3);
                var s3 = Math.sin(t3);
                var cc3 = c3 * c3;
                var ss3 = s3 * s3;
                var x3 = cc3 * x1 + ss3 * x2;
                var y3 = cc3 * y1 + ss3 * y2;
                result[++resultIndex] = x3;
                result[++resultIndex] = y3;
            }
            return resultIndex;
        };
        /**
         * Calculate an interpolated points of the given control points.
         *
         * @param length A number of control points.
         * @param values An array of control points.
         * @param toParameter An interpolation method.
         * @param isClosed True if the line is closed.
         * @param nsegment The number of segments per 90 degree if isAdaptive is true.
         * If isAdaptive is false, the number of segments is fixed to the given number
         * regardless of arc angles.
         * @param isAdaptive True to adjust the number of segments adaptively.
         * @returns An interpolated points of the given control points.
         */
        UtilCurve.interpolate = function (length, values, segments, toParameter, isClosed, nsegment, isAdaptive, result) {
            var rvalues = result.values;
            var rsegments = result.segments;
            if (length <= 2) {
                acopy(values, rvalues);
                acopy(segments, rsegments);
                return result;
            }
            var c0 = this.WORK_P0 || pnew();
            var c1 = this.WORK_P1 || pnew();
            var c2 = this.WORK_P2 || pnew();
            this.WORK_P0 = c0;
            this.WORK_P1 = c1;
            this.WORK_P2 = c2;
            var rvaluesCount = -1;
            var rsegmentCount = -1;
            if (isClosed) {
                toParameter(0, length, values, c0);
                pcopy(c0, c1);
                for (var i = 1; i < length; ++i) {
                    toParameter(i, length, values, c2);
                    if (0 <= toIndexOf(segments, i)) {
                        var index = (i - 1) << 1;
                        rvalues[++rvaluesCount] = values[index + 0];
                        rvalues[++rvaluesCount] = values[index + 1];
                        rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                    }
                    else {
                        rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c2.center, c2.angle[0], c2.angle[1], c2.axis1, c2.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                    }
                    var c3 = c1;
                    c1 = c2;
                    c2 = c3;
                }
                if (0 <= toIndexOf(segments, 0)) {
                    var index = (length - 1) << 1;
                    rvalues[++rvaluesCount] = values[index + 0];
                    rvalues[++rvaluesCount] = values[index + 1];
                    rsegments.unshift(0);
                    rsegmentCount += 1;
                }
                else {
                    rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                }
            }
            else {
                toParameter(1, length, values, c0);
                if (0 <= toIndexOf(segments, 1)) {
                    rvalues[++rvaluesCount] = values[0];
                    rvalues[++rvaluesCount] = values[1];
                    rsegments[++rsegmentCount] = 1;
                }
                else {
                    rvaluesCount = this.set(c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                }
                pcopy(c0, c1);
                for (var i = 2, imax = length - 1; i < imax; ++i) {
                    toParameter(i, length, values, c2);
                    if (0 <= toIndexOf(segments, i)) {
                        var index = (i - 1) << 1;
                        rvalues[++rvaluesCount] = values[index + 0];
                        rvalues[++rvaluesCount] = values[index + 1];
                        rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                    }
                    else {
                        rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c2.center, c2.angle[0], c2.angle[1], c2.axis1, c2.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                    }
                    var c3 = c1;
                    c1 = c2;
                    c2 = c3;
                }
                if (0 <= toIndexOf(segments, length - 1)) {
                    var index = (length - 2) << 1;
                    rvalues[++rvaluesCount] = values[index + 0];
                    rvalues[++rvaluesCount] = values[index + 1];
                    rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                }
                else {
                    rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, nsegment, isAdaptive, true, rvalues, rvaluesCount);
                }
            }
            rvaluesCount += 1;
            if (rvalues.length !== rvaluesCount) {
                rvalues.length = rvaluesCount;
            }
            rsegmentCount += 1;
            if (rsegments.length !== rsegmentCount) {
                rsegments.length = rsegmentCount;
            }
            return result;
        };
        UtilCurve.toCircle = function (index, length, values, result) {
            var index0 = 0 < index ? index - 1 : length - 1;
            var index1 = index;
            var index2 = index < length - 1 ? index + 1 : 0;
            var i0 = index0 << 1;
            var i1 = index1 << 1;
            var i2 = index2 << 1;
            var x0 = values[i0 + 0];
            var y0 = values[i0 + 1];
            var x1 = values[i1 + 0];
            var y1 = values[i1 + 1];
            var x2 = values[i2 + 0];
            var y2 = values[i2 + 1];
            var d01x = x1 - x0;
            var d01y = y1 - y0;
            var d12x = x2 - x1;
            var d12y = y2 - y1;
            var m1x = x0 + d01x * 0.5;
            var m1y = y0 + d01y * 0.5;
            var m2x = x1 + d12x * 0.5;
            var m2y = y1 + d12y * 0.5;
            var n1x = -d01y;
            var n1y = +d01x;
            var n2x = -d12y;
            var n2y = +d12x;
            var det = vcross(n1x, n1y, n2x, n2y);
            var threshold = 0.001;
            if (Math.abs(det) < threshold) {
                if (0 <= vdot(d01x, d01y, d12x, d12y) || length <= 2) {
                    var a = 0.01;
                    var s_1 = Math.sin(a);
                    var l1 = vlen(d01x, d01y);
                    var l2 = vlen(d12x, d12y);
                    return pset(x1, y1, 0, 0, d12x / s_1, d12y / s_1, (-a * l1) / l2, 0, a, result);
                }
                else {
                    det = threshold;
                }
            }
            var s = (n2y * (m2x - m1x) + n2x * (m1y - m2y)) / det;
            var cx = m1x + s * n1x;
            var cy = m1y + s * n1y;
            var a1x = x1 - cx;
            var a1y = y1 - cy;
            var a2x = -a1y;
            var a2y = +a1x;
            var dc2x = x2 - cx;
            var dc2y = y2 - cy;
            var a2 = Math.atan2(vdot(a2x, a2y, dc2x, dc2y), vdot(a1x, a1y, dc2x, dc2y));
            var dc0x = x0 - cx;
            var dc0y = y0 - cy;
            var a1 = Math.atan2(vdot(a2x, a2y, dc0x, dc0y), vdot(a1x, a1y, dc0x, dc0y));
            if (0 < a1 * a2) {
                if (Math.abs(a1) < Math.abs(a2)) {
                    if (0 < a2) {
                        a2 -= PID;
                    }
                    else {
                        a2 += PID;
                    }
                }
                if (Math.abs(a2) < Math.abs(a1)) {
                    if (0 < a1) {
                        a1 -= PID;
                    }
                    else {
                        a1 += PID;
                    }
                }
            }
            return pset(cx, cy, a1x, a1y, a2x, a2y, a1, 0, a2, result);
        };
        UtilCurve.toEllipse = function (index, length, values, result) {
            var index0 = 0 < index ? index - 1 : length - 1;
            var index1 = index;
            var index2 = index < length - 1 ? index + 1 : 0;
            var i0 = index0 << 1;
            var i1 = index1 << 1;
            var i2 = index2 << 1;
            var x0 = values[i0 + 0];
            var y0 = values[i0 + 1];
            var x1 = values[i1 + 0];
            var y1 = values[i1 + 1];
            var x2 = values[i2 + 0];
            var y2 = values[i2 + 1];
            var d10x = x0 - x1;
            var d10y = y0 - y1;
            var d12x = x2 - x1;
            var d12y = y2 - y1;
            if (length <= 2) {
                var a_1 = 0.01;
                var s = Math.sin(a_1);
                return pset(x1, y1, 0, 0, d12x / s, d12y / s, -a_1, 0, a_1, result);
            }
            var l0 = vlen(d10x, d10y);
            var l2 = vlen(d12x, d12y);
            var cos = vdot(d10x, d10y, d12x, d12y) / (l0 * l2);
            var amax = Math.acos(cos);
            var acurrent = amax * 0.5;
            var adelta = amax * 0.25;
            var a = 0;
            var b = 0;
            var c = 0;
            var d = 0;
            var lmax = Math.max(l0, l2);
            var lmin = Math.min(l0, l2);
            for (var i = 0; i < 16; ++i) {
                var a0 = acurrent * 0.5;
                var a1 = amax - a0;
                a = lmax * Math.sin(a0);
                b = lmax * Math.cos(a0);
                c = lmin * Math.sin(a1);
                d = lmin * Math.cos(a1);
                var v = (1 - d / b) * (1 - d / b) + (c * c) / (a * a);
                if (1 < v) {
                    acurrent += adelta;
                }
                else {
                    acurrent -= adelta;
                }
                adelta *= 0.5;
            }
            var beta = Math.asin(Math.min(c / a, 1));
            if (l0 < l2) {
                var e3x = d12x / l2;
                var e3y = d12y / l2;
                var n3x = void 0, n3y = void 0;
                if (0 < vcross(d10x, d10y, d12x, d12y)) {
                    n3x = +e3y;
                    n3y = -e3x;
                }
                else {
                    n3x = -e3y;
                    n3y = +e3x;
                }
                var we = -(b * b) / l2;
                var wn = -(b * a) / l2;
                var a1x = we * e3x + wn * n3x;
                var a1y = we * e3y + wn * n3y;
                var cx = x1 - a1x;
                var cy = y1 - a1y;
                var a2x = x2 - cx;
                var a2y = y2 - cy;
                return pset(cx, cy, a1x, a1y, a2x, a2y, -beta, 0, PIH, result);
            }
            else {
                var e0x = d10x / l0;
                var e0y = d10y / l0;
                var n3x = void 0, n3y = void 0;
                if (vcross(d10x, d10y, d12x, d12y) < 0) {
                    n3x = +e0y;
                    n3y = -e0x;
                }
                else {
                    n3x = -e0y;
                    n3y = +e0x;
                }
                var we = -(b * b) / l0;
                var wn = -(b * a) / l0;
                var a1x = we * e0x + wn * n3x;
                var a1y = we * e0y + wn * n3y;
                var cx = x1 - a1x;
                var cy = y1 - a1y;
                var a2x = x0 - cx;
                var a2y = y0 - cy;
                return pset(cx, cy, a1x, a1y, -a2x, -a2y, -PIH, 0, beta, result);
            }
        };
        UtilCurve.toHybrid = function (index, length, values, result) {
            var circle = UtilCurve.toCircle(index, length, values, result);
            var a0 = circle.angle[0];
            var a2 = circle.angle[2];
            var amin = Math.min(a0, a2);
            var amax = Math.max(a0, a2);
            if (amin < -PIH || PIH < amax) {
                return UtilCurve.toEllipse(index, length, values, result);
            }
            return circle;
        };
        return UtilCurve;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var eShapePointsFormatterCurve = function (length, values, segments, style, result) {
        UtilCurve.interpolate(length, values, segments, UtilCurve.toHybrid, !!(style & EShapePointsStyle.CLOSED), EShapeDefaults.CURVE_SEGMENT_COUNT, true, result);
        result.length = result.values.length >> 1;
        result.style = style;
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLinePoints = /** @class */ (function () {
        function EShapeLinePoints(parent, points, segments, style) {
            // Calculate the boundary
            var boundary = this.toBoundary(points, [0, 0, 0, 0]);
            var cx = (boundary[2] + boundary[0]) * 0.5;
            var cy = (boundary[3] + boundary[1]) * 0.5;
            var sx = boundary[2] - boundary[0];
            var sy = boundary[3] - boundary[1];
            // Calculate values
            var values = [];
            for (var i = 0, imax = points.length; i < imax; i += 2) {
                values.push(points[i] - cx, points[i + 1] - cy);
            }
            this._parent = parent;
            this._valuesBaseLength = values.length;
            this._values = values;
            this._segments = segments.slice(0);
            this._sizeBase = new pixi_js.Point(sx, sy);
            this.size = new pixi_js.Point(sx, sy);
            this.position = new pixi_js.Point(cx, cy);
            this._id = 0;
            this._style = style;
            this._formattedId = -1;
        }
        Object.defineProperty(EShapeLinePoints.prototype, "length", {
            get: function () {
                return this._values.length >> 1;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLinePoints.prototype.fit = function () {
            var size = this.size;
            var parentSize = this._parent.size;
            var ssx = parentSize.x;
            var ssy = parentSize.y;
            var threshold = 0.00001;
            if (threshold < Math.abs(ssx - size.x) || threshold < Math.abs(ssy - size.y)) {
                size.set(ssx, ssy);
                var sizeBase = this._sizeBase;
                var hasSizeBaseX = threshold < Math.abs(sizeBase.x);
                var hasSizeBaseY = threshold < Math.abs(sizeBase.y);
                if (hasSizeBaseX || hasSizeBaseY) {
                    var scaleX = hasSizeBaseX ? ssx / sizeBase.x : 1;
                    var scaleY = hasSizeBaseY ? ssy / sizeBase.y : 1;
                    // Values
                    var values = this._values;
                    var valuesBase = this._valuesBase;
                    if (valuesBase == null) {
                        valuesBase = [];
                        this._valuesBase = valuesBase;
                        for (var i = 0, imax = values.length; i < imax; i += 2) {
                            var x = values[i];
                            var y = values[i + 1];
                            values[i] = x * scaleX;
                            values[i + 1] = y * scaleY;
                            valuesBase.push(x, y);
                        }
                    }
                    else {
                        for (var i = 0, imax = values.length; i < imax; i += 2) {
                            values[i] = valuesBase[i] * scaleX;
                            values[i + 1] = valuesBase[i + 1] * scaleY;
                        }
                    }
                    // Formatted ID, values and boundary
                    if (this._id === this._formattedId) {
                        var formatted = this._formatted;
                        if (formatted != null) {
                            // Formatted values
                            var formattedValues = formatted.values;
                            var formattedValuesBase = this._formattedValuesBase;
                            if (formattedValuesBase == null) {
                                formattedValuesBase = [];
                                this._formattedValuesBase = formattedValuesBase;
                                for (var i = 0, imax = formattedValues.length; i < imax; i += 2) {
                                    var x = formattedValues[i];
                                    var y = formattedValues[i + 1];
                                    formattedValues[i] = x * scaleX;
                                    formattedValues[i + 1] = y * scaleY;
                                    formattedValuesBase.push(x, y);
                                }
                            }
                            else {
                                for (var i = 0, imax = formattedValues.length; i < imax; i += 2) {
                                    formattedValues[i] = formattedValuesBase[i] * scaleX;
                                    formattedValues[i + 1] = formattedValuesBase[i + 1] * scaleY;
                                }
                            }
                            // Formatted boundary
                            var formattedBoundary = formatted.boundary;
                            var formattedBoundaryBase = this._formattedBoundaryBase;
                            if (formattedBoundaryBase == null) {
                                formattedBoundaryBase = [0, 0, 0, 0];
                                this._formattedBoundaryBase = formattedBoundaryBase;
                                for (var i = 0, imax = formattedBoundary.length; i < imax; i += 2) {
                                    var x = formattedBoundary[i];
                                    var y = formattedBoundary[i + 1];
                                    formattedBoundary[i] = x * scaleX;
                                    formattedBoundary[i + 1] = y * scaleY;
                                    formattedBoundaryBase[i] = x;
                                    formattedBoundaryBase[i + 1] = y;
                                }
                            }
                            else {
                                for (var i = 0, imax = formattedBoundary.length; i < imax; i += 2) {
                                    formattedBoundary[i] = formattedBoundaryBase[i] * scaleX;
                                    formattedBoundary[i + 1] = formattedBoundaryBase[i + 1] * scaleY;
                                }
                            }
                            // Formatted ID
                            this._formattedId += 1;
                        }
                    }
                    this._id += 1;
                }
            }
        };
        Object.defineProperty(EShapeLinePoints.prototype, "id", {
            get: function () {
                this.fit();
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "values", {
            get: function () {
                this.fit();
                return this._values;
            },
            set: function (values) {
                this.set(values, undefined, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            /**
             * Must be sorted in ascending order.
             */
            set: function (segments) {
                this.set(undefined, segments, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                this.set(undefined, undefined, style);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "formatter", {
            get: function () {
                return this._formatter || null;
            },
            set: function (formatter) {
                if (this._formatter !== formatter) {
                    this._formattedId = -1;
                    this._formatter = formatter;
                    this.toDirty(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "formatted", {
            get: function () {
                this.fit();
                var id = this._id;
                var result = this._formatted;
                if (this._formattedId !== id) {
                    this._formattedId = id;
                    var style = this._style;
                    var formatter = this._formatter;
                    if (formatter == null) {
                        if (style & EShapePointsStyle.CURVE) {
                            formatter = eShapePointsFormatterCurve;
                        }
                    }
                    if (formatter != null) {
                        if (result == null) {
                            result = {
                                length: 0,
                                values: [],
                                segments: [],
                                boundary: [0, 0, 0, 0],
                                style: EShapePointsStyle.NONE
                            };
                        }
                        var valuesBase = this._valuesBase;
                        var segments = this._segments;
                        if (valuesBase != null) {
                            var length_1 = valuesBase.length >> 1;
                            formatter(length_1, valuesBase, segments, style, result);
                            this.toBoundary(result.values, result.boundary);
                            var formattedValues = result.values;
                            var formattedValuesBase = formattedValues.splice(0);
                            this._formattedValuesBase = formattedValuesBase;
                            var formattedBoundary = result.boundary;
                            var formattedBoundaryBase = [
                                formattedBoundary[0],
                                formattedBoundary[1],
                                formattedBoundary[2],
                                formattedBoundary[3]
                            ];
                            this._formattedBoundaryBase = formattedBoundaryBase;
                            this.toScaled(formattedValues, formattedValuesBase, formattedBoundary, formattedBoundaryBase);
                        }
                        else {
                            var values = this._values;
                            var length_2 = values.length >> 1;
                            formatter(length_2, values, segments, style, result);
                            this.toBoundary(result.values, result.boundary);
                            this._formattedValuesBase = undefined;
                            this._formattedBoundaryBase = undefined;
                        }
                    }
                    else {
                        result = undefined;
                        this._formattedValuesBase = undefined;
                        this._formattedBoundaryBase = undefined;
                    }
                    this._formatted = result;
                }
                return result || this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLinePoints.prototype.toScaled = function (values, valuesBase, boundary, boundaryBase) {
            var size = this.size;
            var sizeBase = this._sizeBase;
            var threshold = 0.00001;
            var hasSizeBaseX = threshold < Math.abs(sizeBase.x);
            var hasSizeBaseY = threshold < Math.abs(sizeBase.y);
            if (hasSizeBaseX || hasSizeBaseY) {
                var scaleX = hasSizeBaseX ? size.x / sizeBase.x : 1;
                var scaleY = hasSizeBaseY ? size.y / sizeBase.y : 1;
                for (var i = 0, imax = valuesBase.length; i < imax; i += 2) {
                    values[i] = valuesBase[i] * scaleX;
                    values[i + 1] = valuesBase[i + 1] * scaleY;
                }
                for (var i = 0, imax = boundaryBase.length; i < imax; i += 2) {
                    boundary[i] = boundaryBase[i] * scaleX;
                    boundary[i + 1] = boundaryBase[i + 1] * scaleY;
                }
            }
        };
        EShapeLinePoints.prototype.toBoundary = function (values, result) {
            var valuesLength = values.length;
            if (2 <= valuesLength) {
                var xmin = values[0];
                var ymin = values[1];
                var xmax = xmin;
                var ymax = ymin;
                for (var i = 2, imax = values.length; i < imax; i += 2) {
                    var x = values[i];
                    var y = values[i + 1];
                    xmin = Math.min(xmin, x);
                    ymin = Math.min(ymin, y);
                    xmax = Math.max(xmax, x);
                    ymax = Math.max(ymax, y);
                }
                result[0] = xmin;
                result[1] = ymin;
                result[2] = xmax;
                result[3] = ymax;
            }
            else {
                result[0] = 0;
                result[1] = 0;
                result[2] = 0;
                result[3] = 0;
            }
            return result;
        };
        EShapeLinePoints.prototype.copy = function (source) {
            return this.set(source.values, source.segments, source.style);
        };
        EShapeLinePoints.prototype.set = function (newValues, newSegments, newStyle) {
            var isDirty = false;
            var isUpdated = false;
            // Formatter
            var style = this._style;
            var styleFormatter = style & EShapePointsStyle.FORMATTER_MASK;
            var formatter = this._formatter;
            // Values
            if (newValues != null) {
                var values = this._values;
                var valuesBaseLength = this._valuesBaseLength;
                var newValuesLength = newValues.length;
                var iupdate = Math.min(newValuesLength, valuesBaseLength);
                this._valuesBase = undefined;
                if (values !== newValues) {
                    for (var i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (var i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesBaseLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            isDirty = true;
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                }
                else {
                    if (valuesBaseLength !== newValuesLength) {
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            isDirty = true;
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                }
            }
            // Segments
            if (newSegments != null) {
                var segments = this._segments;
                if (segments !== newSegments) {
                    var newSegmentsLength = newSegments.length;
                    var iupdate = Math.min(segments.length, newSegmentsLength);
                    for (var i = 0; i < iupdate; ++i) {
                        segments[i] = newSegments[i];
                    }
                    for (var i = iupdate; i < newSegmentsLength; ++i) {
                        segments.push(newSegments[i]);
                    }
                    if (segments.length !== newSegmentsLength) {
                        segments.length = newSegmentsLength;
                    }
                }
                if (formatter != null || styleFormatter) {
                    isDirty = true;
                }
                else {
                    isUpdated = true;
                }
            }
            // Style
            if (newStyle != null) {
                if (style !== newStyle) {
                    var newStyleFormatter = newStyle & EShapePointsStyle.FORMATTER_MASK;
                    if (styleFormatter !== newStyleFormatter) {
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            var styleClosed = style & EShapePointsStyle.CLOSED;
                            var newStyleClosed = newStyle & EShapePointsStyle.CLOSED;
                            if (styleClosed !== newStyleClosed) {
                                isDirty = true;
                            }
                            else {
                                isUpdated = true;
                            }
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                    this._style = newStyle;
                }
            }
            //
            if (isUpdated || isDirty) {
                this.toDirty(isDirty);
            }
            return this;
        };
        EShapeLinePoints.prototype.toDirty = function (revalidate) {
            if (revalidate) {
                this._id += 1;
                var parent_1 = this._parent;
                var uploaded = parent_1.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent_1)) {
                        parent_1.updateUploaded();
                    }
                    else {
                        parent_1.uploaded = undefined;
                        parent_1.toDirty();
                    }
                }
                else {
                    parent_1.updateUploaded();
                }
            }
            else {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLinePoints.prototype.clone = function (parent) {
            return new EShapeLinePoints(parent, this._values, this._segments, this._style);
        };
        EShapeLinePoints.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeLinePoints.prototype.serialize = function (manager) {
            return manager.addResource("[" + JSON.stringify(this._values) + "," + JSON.stringify(this._segments) + "," + this._style + "]");
        };
        EShapeLinePoints.prototype.calcHitPointAbs = function (x, y, ax, ay, threshold, toRange, tester, result) {
            var formatted = this.formatted;
            var length = formatted.length;
            if (2 <= length) {
                var values = formatted.values;
                var segments = formatted.segments;
                var style = formatted.style;
                var istart = 0;
                var iend = length;
                if (toRange) {
                    var work = EShapeLinePoints.WORK_RANGE;
                    toRange(x, y, threshold, values, work);
                    istart = work[0];
                    iend = work[1];
                }
                for (var i = istart, imax = Math.min(iend, length - 1); i < imax; ++i) {
                    if (toIndexOf(segments, i + 1) < 0) {
                        var iv = i << 1;
                        var p0x = values[iv + 0];
                        var p0y = values[iv + 1];
                        var p1x = values[iv + 2];
                        var p1y = values[iv + 3];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
                if (2 < length && length <= iend && style & EShapePointsStyle.CLOSED) {
                    if (toIndexOf(segments, 0) < 0) {
                        var i = length - 1;
                        var iv = i << 1;
                        var p0x = values[iv + 0];
                        var p0y = values[iv + 1];
                        var p1x = values[0];
                        var p1y = values[1];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        EShapeLinePoints.WORK_RANGE = [0, 0];
        return EShapeLinePoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLine = /** @class */ (function (_super) {
        __extends(EShapeLine, _super);
        function EShapeLine(points, segments, width, style) {
            var _this = _super.call(this, EShapeType.LINE) || this;
            _this.fill.enable = false;
            _this.stroke.set(true, undefined, undefined, width);
            _this._points = new EShapeLinePoints(_this, points, segments, style);
            _this.transform.position.copyFrom(_this._points.position);
            _this.size.copyFrom(_this._points.size);
            return _this;
        }
        Object.defineProperty(EShapeLine.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLine.prototype.clone = function () {
            var points = this.points;
            var result = new EShapeLine(points.values, points.segments, this.stroke.width, points.style);
            result.copy(this, EShapeCopyPart.ALL & ~EShapeCopyPart.POINTS);
            return result;
        };
        return EShapeLine;
    }(EShapeLineBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLine = function (item, manager) {
        var _a;
        var resources = manager.resources;
        var resourceId = item[15];
        if (0 <= resourceId && resourceId < resources.length) {
            var parsed = manager.getExtension(resourceId);
            if (parsed == null) {
                parsed = JSON.parse(resources[resourceId]);
                manager.setExtension(resourceId, parsed);
            }
            var style = (_a = parsed[2]) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
            var mask = EShapePointsStyle.NON_SCALING_MASK |
                EShapePointsStyle.DOTTED_MASK |
                EShapePointsStyle.DASHED_MASK;
            var shape = new EShapeLine(parsed[0], parsed[1], EShapeDefaults.STROKE_WIDTH, style & ~mask);
            var deprecated = style & mask;
            if (deprecated) {
                shape.stroke.style |= deprecated;
            }
            return EShapeDeserializer.deserialize(item, manager, shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLine = function () {
        EShapeUploadeds[EShapeType.LINE] = createLineUploaded;
        EShapeDeserializers[EShapeType.LINE] = deserializeLine;
    };

    var toLineOfAnyPointCount = function (pointCount) {
        return Math.ceil(pointCount / 12) * 12;
    };
    var buildLineOfAnyColor = function (voffset, vcountPerPoint, point, pointCount, colors, isEnabled, colorDef, alphaDef) {
        if (isEnabled) {
            if (point.isStaticColor()) {
                var color = point.getColor(0, colorDef);
                if (point.isStaticAlpha()) {
                    var alpha = point.getAlpha(0, alphaDef);
                    buildColor(color, alpha, voffset, vcountPerPoint * pointCount, colors);
                }
                else {
                    for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                        var alpha = point.getAlpha(i, alphaDef);
                        buildColor(color, alpha, iv, vcountPerPoint, colors);
                    }
                }
            }
            else {
                if (point.isStaticAlpha()) {
                    var alpha = point.getAlpha(0, alphaDef);
                    for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                        var color = point.getColor(i, colorDef);
                        buildColor(color, alpha, iv, vcountPerPoint, colors);
                    }
                }
                else {
                    for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                        var color = point.getColor(i, colorDef);
                        var alpha = point.getAlpha(i, alphaDef);
                        buildColor(color, alpha, iv, vcountPerPoint, colors);
                    }
                }
            }
        }
        else {
            if (point.isStaticColor()) {
                var color = point.getColor(0, colorDef);
                buildColor(color, 0, voffset, vcountPerPoint * pointCount, colors);
            }
            else {
                for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                    var color = point.getColor(i, colorDef);
                    buildColor(color, 0, iv, vcountPerPoint, colors);
                }
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfAnyUploaded = function (buffer, shape, voffset, vcountPerPoint, ioffset, icountPerPoint, antialiasWeight, constructor) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var points = shape.points;
        var pointCount = toLineOfAnyPointCount(toPointsCount(points));
        var vcount = pointCount * vcountPerPoint + tvcount;
        var icount = pointCount * icountPerPoint + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new constructor(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight, pointCount).init(shape);
        }
        return null;
    };

    var buildNullClipping = function (clippings, voffset, vcount) {
        for (var i = voffset * 3, imax = (voffset + vcount) * 3; i < imax; i += 3) {
            clippings[i + 0] = 0;
            clippings[i + 1] = 0;
            clippings[i + 2] = 0;
        }
    };
    var buildNullIndex = function (indices, voffset, ioffset, icount) {
        for (var ii = ioffset * 3, iimax = (ioffset + icount) * 3; ii < iimax; ii += 3) {
            indices[ii + 0] = voffset;
            indices[ii + 1] = voffset;
            indices[ii + 2] = voffset;
        }
    };
    var buildNullVertex = function (vertices, voffset, vcount) {
        for (var i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            vertices[i + 0] = 0;
            vertices[i + 1] = 0;
        }
    };
    var buildNullStep = function (steps, voffset, vcount) {
        for (var i = voffset * 6, imax = (voffset + vcount) * 6; i < imax; i += 6) {
            steps[i + 0] = 0;
            steps[i + 1] = 0;
            steps[i + 2] = 0;
            steps[i + 3] = 0;
            steps[i + 4] = 0;
            steps[i + 5] = 0;
        }
    };
    var buildNullUv = function (uvs, voffset, vcount) {
        for (var i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            uvs[i + 0] = 0;
            uvs[i + 1] = 0;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyClipping = function (clippings, voffset, vcountPerPoint, pointCount) {
        var iv = voffset + vcountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var icd = iv * 3;
            var ics = voffset * 3;
            for (var j = 0; j < vcountPerPoint; ++j) {
                clippings[icd + 0] = clippings[ics + 0];
                clippings[icd + 1] = clippings[ics + 1];
                clippings[icd + 2] = clippings[ics + 2];
                icd += 3;
                ics += 3;
            }
            iv += vcountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyIndex = function (indices, vcountPerPoint, ioffset, icountPerPoint, pointCount) {
        var idiv = vcountPerPoint;
        var ii = ioffset + icountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var iid = ii * 3;
            var iis = ioffset * 3;
            for (var j = 0; j < icountPerPoint; ++j) {
                indices[iid + 0] = indices[iis + 0] + idiv;
                indices[iid + 1] = indices[iis + 1] + idiv;
                indices[iid + 2] = indices[iis + 2] + idiv;
                iid += 3;
                iis += 3;
            }
            idiv += vcountPerPoint;
            ii += icountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyStep = function (steps, voffset, vcountPerPoint, pointCount) {
        var iss0 = voffset * 6;
        var isd = (voffset + vcountPerPoint) * 6;
        for (var i = 1; i < pointCount; ++i) {
            var iss = iss0;
            for (var j = 0; j < vcountPerPoint; ++j) {
                steps[isd + 0] = steps[iss + 0];
                steps[isd + 1] = steps[iss + 1];
                steps[isd + 2] = steps[iss + 2];
                steps[isd + 3] = steps[iss + 3];
                steps[isd + 4] = steps[iss + 4];
                steps[isd + 5] = steps[iss + 5];
                isd += 6;
                iss += 6;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyUvs = function (uvs, voffset, vcountPerPoint, pointCount) {
        var iv = voffset + vcountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var iuvd = iv << 1;
            var iuvs = voffset << 1;
            for (var j = 0; j < vcountPerPoint; ++j) {
                uvs[iuvd] = uvs[iuvs];
                uvs[iuvd + 1] = uvs[iuvs + 1];
                iuvd += 2;
                iuvs += 2;
            }
            iv += vcountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyVertex = function (vertices, internalTransform, voffset, vcountPerPoint, pointCount, pointsValues, pointOffset) {
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var i = pointCount - 1;
        var iv = voffset + i * vcountPerPoint;
        if (pointOffset.isStaticX() && pointOffset.isStaticY()) {
            var ox = pointOffset.getX(0);
            var oy = pointOffset.getY(0);
            for (; 0 <= i; --i) {
                var ip = i << 1;
                var px = pointsValues[ip] + ox;
                var py = pointsValues[ip + 1] + oy;
                var dx = a * px + c * py;
                var dy = b * px + d * py;
                var ivd = iv << 1;
                var ivs = voffset << 1;
                for (var j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
        else {
            for (; 0 <= i; --i) {
                var ip = i << 1;
                var px = pointsValues[ip] + pointOffset.getX(i);
                var py = pointsValues[ip + 1] + pointOffset.getY(i);
                var dx = a * px + c * py;
                var dy = b * px + d * py;
                var ivd = iv << 1;
                var ivs = voffset << 1;
                for (var j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isStatic = function (value) {
        return isNumber(value) || value == null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toComputed = function (index, value, def) {
        if (isNumber(value)) {
            return value;
        }
        else if (isFunction(value)) {
            return value(index);
        }
        else if (value) {
            return value[index % value.length];
        }
        return def;
    };

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsFillImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsFillImpl(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this.set(color, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                this.set(undefined, alpha);
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsFillImpl.prototype.set = function (color, alpha) {
            var isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsFillImpl.prototype.getColor = function (index, def) {
            return toComputed(index, this._color, def);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.getAlpha = function (index, def) {
            return toComputed(index, this._alpha, def);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.isStaticColor = function () {
            return isStatic(this._color);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.isStaticAlpha = function () {
            return isStatic(this._alpha);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsFillImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsPointImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsPointImpl(parent, defX, defY) {
            this._parent = parent;
            this._id = 0;
            this._x = null;
            this._y = null;
            this._defX = defX;
            this._defY = defY;
            this._limit = null;
            this._limitComputed = 0;
            this._limitId = -1;
            this._limitParentLength = 0;
        }
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                this.set(x, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                this.set(undefined, y);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "limit", {
            get: function () {
                return this._limit;
            },
            set: function (limit) {
                this._limit = limit;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsPointImpl.prototype.set = function (x, y) {
            var isChanged = false;
            if (x !== undefined && this._x !== x) {
                isChanged = true;
                this._x = x;
            }
            if (y !== undefined && this._y !== y) {
                isChanged = true;
                this._y = y;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getX = function (index) {
            return toComputed(index, this._x, this._defX);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getY = function (index) {
            return toComputed(index, this._y, this._defY);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getLimit = function () {
            var limit = this._limit;
            if (limit != null) {
                return limit;
            }
            this.updateLimitComputed();
            return this._limitComputed;
        };
        EShapeLineOfAnyPointsPointImpl.prototype.updateLimitComputed = function () {
            var limitId = this._id;
            var parent = this._parent;
            var limitParentLength = parent.length;
            if (this._limitId !== limitId || this._limitParentLength !== limitParentLength) {
                this._limitId = limitId;
                this._limitParentLength = limitParentLength;
                this._limitComputed = Math.max(this.calcLimit(this._x, limitParentLength, this._defX), this.calcLimit(this._y, limitParentLength, this._defY));
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.calcLimit = function (value, parentLenght, def) {
            if (isNumber(value)) {
                return Math.abs(value);
            }
            else if (isFunction(value)) {
                if (0 < parentLenght) {
                    var result = Math.abs(value(0));
                    for (var i = 1; i < parentLenght; ++i) {
                        result = Math.max(result, Math.abs(value(i)));
                    }
                    return result;
                }
                return 0;
            }
            else if (value != null) {
                var l = value.length;
                if (0 < l) {
                    var result = value[0];
                    for (var i = 1; i < l; ++i) {
                        result = Math.max(result, Math.abs(value[i]));
                    }
                    return result;
                }
                return 0;
            }
            else {
                return Math.abs(def);
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.isStaticX = function () {
            return isStatic(this._x);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.isStaticY = function () {
            return isStatic(this._y);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsPointImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsStrokeImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsStrokeImpl(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this.set(color, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                this.set(undefined, alpha);
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsStrokeImpl.prototype.set = function (color, alpha) {
            var isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.getColor = function (index, def) {
            return toComputed(index, this._color, def);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.getAlpha = function (index, def) {
            return toComputed(index, this._alpha, def);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.isStaticColor = function () {
            return isStatic(this._color);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.isStaticAlpha = function () {
            return isStatic(this._alpha);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsImpl(parent) {
            this._parent = parent;
            this._values = [];
            this._valuesLength = 0;
            this._segments = [];
            this._size = new EShapeLineOfAnyPointsPointImpl(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            this._offset = new EShapeLineOfAnyPointsPointImpl(this, 0, 0);
            this._fill = new EShapeLineOfAnyPointsFillImpl(parent);
            this._stroke = new EShapeLineOfAnyPointsStrokeImpl(parent);
            this._id = 0;
        }
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "length", {
            get: function () {
                return this._values.length >> 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "values", {
            get: function () {
                return this._values;
            },
            set: function (values) {
                this.set(values, undefined, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            set: function (segments) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "style", {
            get: function () {
                return EShapePointsStyle.NONE;
            },
            set: function (style) {
                this.set(undefined, undefined, style);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "stroke", {
            get: function () {
                return this._stroke;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "formatter", {
            get: function () {
                return null;
            },
            set: function (formatter) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "formatted", {
            get: function () {
                return this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsImpl.prototype.copy = function (source) {
            return this.set(source.values, source.segments, source.style);
        };
        EShapeLineOfAnyPointsImpl.prototype.set = function (newValues, newSegments, newStyle) {
            var isDirty = false;
            var isUpdated = false;
            // Values
            if (newValues != null) {
                var values = this._values;
                var valuesLength = this._valuesLength;
                var newValuesLength = newValues.length;
                if (values !== newValues) {
                    var iupdate = Math.min(valuesLength, newValuesLength);
                    for (var i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (var i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
                else {
                    if (valuesLength !== newValuesLength) {
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
            }
            //
            if (isDirty) {
                this._id += 1;
                var parent_1 = this._parent;
                var uploaded = parent_1.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent_1)) {
                        parent_1.updateUploaded();
                    }
                    else {
                        parent_1.uploaded = undefined;
                        parent_1.toDirty();
                    }
                }
                else {
                    parent_1.updateUploaded();
                }
            }
            else if (isUpdated) {
                this._id += 1;
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeLineOfAnyPointsImpl.prototype.updateUploaded = function () {
            this._parent.updateUploaded();
        };
        EShapeLineOfAnyPointsImpl.prototype.clone = function (parent) {
            return new EShapeLineOfAnyPointsImpl(parent).copy(this);
        };
        EShapeLineOfAnyPointsImpl.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeLineOfAnyPointsImpl.prototype.serialize = function (manager) {
            return manager.addResource("[]");
        };
        EShapeLineOfAnyPointsImpl.prototype.calcHitPointAbs = function (x, y, sw, ss, threshold, toRange, tester, result) {
            var formatted = this.formatted;
            var pointCount = formatted.length;
            var pointValues = formatted.values;
            var size = this._size;
            var offset = this._offset;
            var istart = 0;
            var iend = pointCount;
            if (toRange) {
                var s = size.getLimit() * 0.5;
                var o = offset.getLimit();
                var work = EShapeLineOfAnyPointsImpl.WORK_RANGE;
                toRange(x, y, s, s, o, o, threshold, pointValues, work);
                istart = work[0];
                iend = work[1];
            }
            for (var i = istart, imax = Math.min(iend, pointCount); i < imax; ++i) {
                var iv = i << 1;
                var px = pointValues[iv];
                var py = pointValues[iv + 1];
                var sx = size.getX(i) * 0.5;
                var sy = size.getY(i) * 0.5;
                var ox = offset.getX(i);
                var oy = offset.getY(i);
                if (tester(x, y, sx, sy, ox, oy, px, py, sw, ss, i, threshold, result)) {
                    return true;
                }
            }
            return false;
        };
        EShapeLineOfAnyPointsImpl.WORK_RANGE = [0, 0];
        return EShapeLineOfAnyPointsImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfAnyUploaded, _super);
        function EShapeLineOfAnyUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight, pointCountReserved) {
            var _this = _super.call(this, buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight) || this;
            _this.pointId = -1;
            _this.pointCount = 0;
            _this.pointCountReserved = pointCountReserved;
            _this.pointSizeId = -1;
            _this.pointOffsetId = -1;
            _this.pointFillId = -1;
            _this.pointStrokeId = -1;
            return _this;
        }
        EShapeLineOfAnyUploaded.prototype.isCompatible = function (shape) {
            if (_super.prototype.isCompatible.call(this, shape)) {
                var pointCount = toLineOfAnyPointCount(toPointsCount(shape.points));
                return pointCount === this.pointCountReserved;
            }
            return false;
        };
        EShapeLineOfAnyUploaded.prototype.updateLineOfAnyColorFill = function (buffer, shape, points, vcountPerPoint) {
            var pointFill = points.fill;
            var pointFillId = pointFill.id;
            var isPointFillChanged = pointFillId !== this.pointFillId;
            var fill = shape.fill;
            var isFillEnabled = shape.visible && fill.enable;
            var colorFill = fill.color;
            var alphaFill = isFillEnabled ? fill.alpha : 0;
            var isFillChanged = colorFill !== this.colorFill || alphaFill !== this.alphaFill;
            if (isPointFillChanged || isFillChanged) {
                this.colorFill = colorFill;
                this.alphaFill = alphaFill;
                this.pointFillId = pointFillId;
                buffer.updateColorFills();
                buildLineOfAnyColor(this.vertexOffset, vcountPerPoint, pointFill, this.pointCountReserved, buffer.colorFills, isFillEnabled, colorFill, alphaFill);
            }
        };
        EShapeLineOfAnyUploaded.prototype.updateLineOfAnyColorStroke = function (buffer, shape, points, vcountPerPoint) {
            var pointStroke = points.stroke;
            var pointStrokeId = pointStroke.id;
            var isPointStrokeChanged = pointStrokeId !== this.pointStrokeId;
            var stroke = shape.stroke;
            var isStrokeEnabled = shape.visible && stroke.enable;
            var colorStroke = stroke.color;
            var alphaStroke = isStrokeEnabled ? stroke.alpha : 0;
            var isStrokeChanged = colorStroke !== this.colorStroke || alphaStroke !== this.alphaStroke;
            if (isPointStrokeChanged || isStrokeChanged) {
                this.colorStroke = colorStroke;
                this.alphaStroke = alphaStroke;
                this.pointStrokeId = pointStrokeId;
                buffer.updateColorStrokes();
                buildLineOfAnyColor(this.vertexOffset, vcountPerPoint, pointStroke, this.pointCountReserved, buffer.colorStrokes, isStrokeEnabled, colorStroke, alphaStroke);
            }
        };
        return EShapeLineOfAnyUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfCirclesUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfCirclesUploaded, _super);
        function EShapeLineOfCirclesUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfCirclesUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Clippings & indices
            var buffer = this.buffer;
            buffer.updateClippings();
            buffer.updateIndices();
            var clippings = buffer.clippings;
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildCircleClipping(clippings, voffset);
                copyClipping(clippings, voffset, CIRCLE_VERTEX_COUNT, pointCountReserved);
                buildCircleIndex(indices, voffset, ioffset);
                copyIndex(indices, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfCirclesUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexAndStep(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, CIRCLE_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, CIRCLE_VERTEX_COUNT);
                this.updateUv(buffer, shape);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfCirclesUploaded.prototype.updateVertexAndStep = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            if (isPointChanged ||
                isPointSizeChanged ||
                isSizeChanged ||
                isTransformChanged ||
                isStrokeChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeStyle = strokeStyle;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var clippings = buffer.clippings;
                var internalTransform = shape.transform.internalTransform;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    buildCircleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, CIRCLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    buildCircleStep(steps, clippings, voffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
                    copyStep(steps, voffset, CIRCLE_VERTEX_COUNT, pointCount);
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * CIRCLE_VERTEX_COUNT;
                        buildCircleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                        buildCircleStep(steps, clippings, iv, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * CIRCLE_VERTEX_COUNT;
                var vcountReserved = CIRCLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
            }
        };
        EShapeLineOfCirclesUploaded.prototype.updateUv = function (buffer, shape) {
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var uvs = buffer.uvs;
                var voffset = this.vertexOffset;
                var textureUvs = this.toTextureUvs(texture);
                var pointCountReserved = this.pointCountReserved;
                if (0 < pointCountReserved) {
                    buildCircleUv(uvs, voffset, textureUvs);
                    copyUvs(uvs, voffset, CIRCLE_VERTEX_COUNT, pointCountReserved);
                }
            }
        };
        return EShapeLineOfCirclesUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfCirclesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, antialiasWeight, EShapeLineOfCirclesUploaded);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfCircles = /** @class */ (function (_super) {
        __extends(EShapeLineOfCircles, _super);
        function EShapeLineOfCircles() {
            var _this = _super.call(this, EShapeType.LINE_OF_CIRCLES) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfCircles.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfCircles.prototype.clone = function () {
            return new EShapeLineOfCircles().copy(this);
        };
        EShapeLineOfCircles.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfCircles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss);
        };
        EShapeLineOfCircles.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfCircles.prototype.calcHitPoint = function (point, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(point);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfCircles;
    }(EShapeCircle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfCircles = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfCircles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfCircles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_CIRCLES] = createLineOfCirclesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_CIRCLES] = deserializeLineOfCircles;
    };

    var RECTANGLE_ROUNDED_VERTEX_COUNT = 36;
    var RECTANGLE_ROUNDED_INDEX_COUNT = 24;
    var RECTANGLE_ROUNDED_WORLD_SIZE = [0, 0, 0];
    var RECTANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    var buildRectangleRoundedIndex = function (indices, voffset, ioffset) {
        // Top-left corner
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 2;
        // Top-right corner
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        // Bottom-left corner
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 10;
        // Bottom-right corner
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 15;
        indices[++ii] = voffset + 14;
        // Top edge
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 21;
        // Upper middle
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 23;
        indices[++ii] = voffset + 26;
        indices[++ii] = voffset + 23;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 26;
        // Lower middle
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 28;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 28;
        indices[++ii] = voffset + 26;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 32;
        indices[++ii] = voffset + 30;
        // Bottom edge
        indices[++ii] = voffset + 29;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 33;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 33;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 31;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 31;
        indices[++ii] = voffset + 35;
        indices[++ii] = voffset + 34;
    };
    var buildRectangleRoundedVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        //  0   1       4   5
        // |---|       |---|
        // |2  |3      |6  |7
        // |---|       |---|
        //
        //
        //
        //
        //
        // |---|       |---|
        // |8  |9      |12 |13
        // |---|       |---|
        //  10  11      14  15
        //
        //
        //      16  17  18       <-- Top edge
        //     |---|---|
        //  19 |20 |21 |22  23   <-- Top
        // |---|---|---|---|
        // |       |       |
        // |24   25|26     |27   <-- Middle
        // |-------|-------|
        // |       |       |
        // |       |       |
        // |---|---|---|---|
        //  28 |29 |30 |31  32   <-- Bottom
        //     |---|---|
        //      33  34  35       <-- Bottom edge
        //
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var ax = Math.abs(sx);
        var ay = Math.abs(sy);
        var a = radius * Math.min(ax, ay);
        var rx = a / ax;
        var ry = a / ay;
        var work = RECTANGLE_ROUNDED_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x2 = work.x;
        var y2 = work.y;
        var dxh = x2 - x0;
        var dyh = y2 - y0;
        var dxhr = rx * dxh;
        var dyhr = rx * dyh;
        var x1 = x0 + dxhr;
        var y1 = y0 + dyhr;
        var x4 = x2 + dxh;
        var y4 = y2 + dyh;
        var x3 = x4 - dxhr;
        var y3 = y4 - dyhr;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var x11 = work.x;
        var y11 = work.y;
        var dxv = x11 - x2;
        var dyv = y11 - y2;
        var dxvr = ry * dxv;
        var dyvr = ry * dyv;
        var x7 = x2 + dxvr;
        var y7 = y2 + dyvr;
        var x5 = x7 - dxh;
        var y5 = y7 - dyh;
        var x6 = x5 + dxhr;
        var y6 = y5 + dyhr;
        var x9 = x7 + dxh;
        var y9 = y7 + dyh;
        var x8 = x9 - dxhr;
        var y8 = y9 - dyhr;
        var x10 = x11 - dxh;
        var y10 = y11 - dyh;
        var x12 = x11 + dxh;
        var y12 = y11 + dyh;
        var x20 = x11 + dxv;
        var y20 = y11 + dyv;
        var x15 = x20 - dxvr;
        var y15 = y20 - dyvr;
        var x13 = x15 - dxh;
        var y13 = y15 - dyh;
        var x14 = x13 + dxhr;
        var y14 = y13 + dyhr;
        var x17 = x15 + dxh;
        var y17 = y15 + dyh;
        var x16 = x17 - dxhr;
        var y16 = y17 - dyhr;
        var x18 = x20 - dxh;
        var y18 = y20 - dyh;
        var x19 = x18 + dxhr;
        var y19 = y18 + dyhr;
        var x22 = x20 + dxh;
        var y22 = y20 + dyh;
        var x21 = x22 - dxhr;
        var y21 = y22 - dyhr;
        // World size
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x2, y2);
        worldSize[2] = toLength(x0, y0, x10, y10);
        // Vertices
        var iv = voffset * 2 - 1;
        // Top-left corner
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        // Top-right corner
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
        // Bottom-left corner
        vertices[++iv] = x13;
        vertices[++iv] = y13;
        vertices[++iv] = x14;
        vertices[++iv] = y14;
        vertices[++iv] = x18;
        vertices[++iv] = y18;
        vertices[++iv] = x19;
        vertices[++iv] = y19;
        // Bottom-right corner
        vertices[++iv] = x16;
        vertices[++iv] = y16;
        vertices[++iv] = x17;
        vertices[++iv] = y17;
        vertices[++iv] = x21;
        vertices[++iv] = y21;
        vertices[++iv] = x22;
        vertices[++iv] = y22;
        // Top edge
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        // Top
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
        // Middle
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        // Bottom
        vertices[++iv] = x13;
        vertices[++iv] = y13;
        vertices[++iv] = x14;
        vertices[++iv] = y14;
        vertices[++iv] = x15;
        vertices[++iv] = y15;
        vertices[++iv] = x16;
        vertices[++iv] = y16;
        vertices[++iv] = x17;
        vertices[++iv] = y17;
        // Bottom edge
        vertices[++iv] = x19;
        vertices[++iv] = y19;
        vertices[++iv] = x20;
        vertices[++iv] = y20;
        vertices[++iv] = x21;
        vertices[++iv] = y21;
    };
    var buildRectangleRoundedClipping = function (clippings, voffset, corner, worldSize) {
        var ic = voffset * 3 - 1;
        var rxc = 1 - worldSize[0] / worldSize[1];
        var ryc = 1 - worldSize[0] / worldSize[2];
        // Top-left corner
        if (corner & EShapeCorner.TOP_LEFT) {
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
        }
        else {
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
        }
        // Top-right corner
        if (corner & EShapeCorner.TOP_RIGHT) {
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
        }
        else {
            clippings[++ic] = rxc;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
        }
        else {
            clippings[++ic] = 1;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
        }
        else {
            clippings[++ic] = rxc;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
        }
        // Top edge
        clippings[++ic] = rxc;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        // Top
        clippings[++ic] = 1;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        // Middle
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        // Bottom
        clippings[++ic] = 1;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        // Bottom edge
        clippings[++ic] = rxc;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
    };
    var buildRectangleRoundedStep = function (steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var sc = worldSize[0];
        var sx = worldSize[1];
        var sy = worldSize[2];
        var rxc = Math.max(0, 1 - worldSize[0] / worldSize[1]);
        var ryc = Math.max(0, 1 - worldSize[0] / worldSize[2]);
        var wt;
        var zt;
        var bt;
        if (strokeSide & EShapeStrokeSide.TOP) {
            wt = +2;
            zt = +1;
            bt = +1 + ryc;
        }
        else {
            wt = -2;
            zt = -1;
            bt = -1 - ryc;
        }
        var wr;
        var zr;
        var br;
        if (strokeSide & EShapeStrokeSide.RIGHT) {
            wr = +2;
            zr = +1;
            br = +1 + rxc;
        }
        else {
            wr = -2;
            zr = -1;
            br = -1 - rxc;
        }
        var wb;
        var zb;
        var bb;
        if (strokeSide & EShapeStrokeSide.BOTTOM) {
            wb = +2;
            zb = +1;
            bb = +1 + ryc;
        }
        else {
            wb = -2;
            zb = -1;
            bb = -1 - ryc;
        }
        var wl;
        var zl;
        var bl;
        if (strokeSide & EShapeStrokeSide.LEFT) {
            wl = +2;
            zl = +1;
            bl = +1 + rxc;
        }
        else {
            wl = -2;
            zl = -1;
            bl = -1 - rxc;
        }
        // Top-left corner
        var is = voffset * 6 - 1;
        if (corner & EShapeCorner.TOP_LEFT) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wl;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zl;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wl;
            steps[++is] = zt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zl;
            steps[++is] = zt;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wl;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = bl;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wl;
            steps[++is] = bt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = bl;
            steps[++is] = bt;
        }
        // Top-right corner
        if (corner & EShapeCorner.TOP_RIGHT) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zr;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wr;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zr;
            steps[++is] = zt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wr;
            steps[++is] = zt;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = br;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wr;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = br;
            steps[++is] = bt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wr;
            steps[++is] = wt;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wl;
            steps[++is] = zb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zl;
            steps[++is] = zb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wl;
            steps[++is] = wb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zl;
            steps[++is] = wb;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wl;
            steps[++is] = bb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = bl;
            steps[++is] = bb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wl;
            steps[++is] = wb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = bl;
            steps[++is] = wb;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zr;
            steps[++is] = zb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wr;
            steps[++is] = zb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zr;
            steps[++is] = wb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wr;
            steps[++is] = wb;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = br;
            steps[++is] = bb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wr;
            steps[++is] = bb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = br;
            steps[++is] = wb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wr;
            steps[++is] = wb;
        }
        // Top edge
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = bl;
        steps[++is] = wt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zl;
        steps[++is] = wt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = br;
        steps[++is] = wt;
        // Top
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wl;
        steps[++is] = bt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = bl;
        steps[++is] = bt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zl;
        steps[++is] = bt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = br;
        steps[++is] = bt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wr;
        steps[++is] = bt;
        // Middle
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wl;
        steps[++is] = zt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zl;
        steps[++is] = zt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zr;
        steps[++is] = zb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wr;
        steps[++is] = zb;
        // Bottom
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wl;
        steps[++is] = bb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = bl;
        steps[++is] = bb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zb;
        steps[++is] = bb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = br;
        steps[++is] = bb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wr;
        steps[++is] = bb;
        // Bottom edge
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = bl;
        steps[++is] = wb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zb;
        steps[++is] = wb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = br;
        steps[++is] = wb;
    };
    var buildRectangleRoundedUv = function (uvs, voffset, textureUvs, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var x5 = 0.5 * (x3 + x2);
        var y5 = 0.5 * (y3 + y2);
        var ruvx = (0.5 * worldSize[0]) / worldSize[1];
        var ruvy = (0.5 * worldSize[0]) / worldSize[2];
        var d0x = ruvx * (x1 - x0);
        var d0y = ruvx * (y1 - y0);
        var d1x = ruvy * (x3 - x0);
        var d1y = ruvy * (y3 - y0);
        // UVs
        var iuv = voffset * 2 - 1;
        // Top-left corner
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = x0 + d0x;
        uvs[++iuv] = y0 + d0y;
        uvs[++iuv] = x0 + d1x;
        uvs[++iuv] = y0 + d1y;
        uvs[++iuv] = x0 + d0x + d1x;
        uvs[++iuv] = y0 + d0y + d1y;
        // Top-right corner
        uvs[++iuv] = x1 - d0x;
        uvs[++iuv] = y1 - d0y;
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = x1 - d0x + d1x;
        uvs[++iuv] = y1 - d0y + d1y;
        uvs[++iuv] = x1 + d1x;
        uvs[++iuv] = y1 + d1y;
        // Bottom-left corner
        uvs[++iuv] = x3 - d1x;
        uvs[++iuv] = y3 - d1y;
        uvs[++iuv] = x3 + d0x - d1x;
        uvs[++iuv] = y3 + d0y - d1y;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x3 + d0x;
        uvs[++iuv] = y3 + d0y;
        // Bottom-right corner
        uvs[++iuv] = x2 - d0x - d1x;
        uvs[++iuv] = y2 - d0y - d1y;
        uvs[++iuv] = x2 - d1x;
        uvs[++iuv] = y2 - d1y;
        uvs[++iuv] = x2 - d0x;
        uvs[++iuv] = y2 - d0y;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        // Top edge
        uvs[++iuv] = x0 + d0x;
        uvs[++iuv] = y0 + d0y;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x1 - d0x;
        uvs[++iuv] = y1 - d0y;
        // Top
        uvs[++iuv] = x0 + d1x;
        uvs[++iuv] = y0 + d1y;
        uvs[++iuv] = x0 + d1x + d0x;
        uvs[++iuv] = y0 + d1y + d0y;
        uvs[++iuv] = x4 + d1x;
        uvs[++iuv] = y4 + d1y;
        uvs[++iuv] = x1 + d1x - d0x;
        uvs[++iuv] = y1 + d1y - d0y;
        uvs[++iuv] = x1 + d1x;
        uvs[++iuv] = y1 + d1y;
        // Middle
        var x02 = 0.5 * (x0 + x2);
        var y02 = 0.5 * (y0 + y2);
        uvs[++iuv] = 0.5 * (x0 + x3);
        uvs[++iuv] = 0.5 * (y0 + y3);
        uvs[++iuv] = x02;
        uvs[++iuv] = y02;
        uvs[++iuv] = x02;
        uvs[++iuv] = y02;
        uvs[++iuv] = 0.5 * (x1 + x2);
        uvs[++iuv] = 0.5 * (y1 + y2);
        // Bottom
        uvs[++iuv] = x3 - d1x;
        uvs[++iuv] = y3 - d1y;
        uvs[++iuv] = x3 - d1x + d0x;
        uvs[++iuv] = y3 - d1y + d0y;
        uvs[++iuv] = x5 - d1x;
        uvs[++iuv] = y5 - d1y;
        uvs[++iuv] = x2 - d1x - d0x;
        uvs[++iuv] = y2 - d1y - d0y;
        uvs[++iuv] = x2 - d1x;
        uvs[++iuv] = y2 - d1y;
        // Bottom edge
        uvs[++iuv] = x3 + d0x;
        uvs[++iuv] = y3 + d0y;
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x2 - d0x;
        uvs[++iuv] = y2 - d0y;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangleRoundedsUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangleRoundedsUploaded, _super);
        function EShapeLineOfRectangleRoundedsUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfRectangleRoundedsUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleRoundedIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfRectangleRoundedsUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexClippingStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, RECTANGLE_ROUNDED_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, RECTANGLE_ROUNDED_VERTEX_COUNT);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfRectangleRoundedsUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var radius = shape.radius;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = corner !== this.corner;
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged || isCornerChanged) {
                    buffer.updateClippings();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var clippings = buffer.clippings;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = this.toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isVertexChanged || isTransformChanged) {
                        buildRectangleRoundedStep(steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // Clippings
                    if (isVertexChanged || isCornerChanged) {
                        buildRectangleRoundedClipping(clippings, voffset, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyClipping(clippings, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isVertexChanged || isTextureChanged) {
                        buildRectangleRoundedUv(uvs, voffset, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * RECTANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildRectangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                        // Steps
                        if (isVertexChanged || isTransformChanged) {
                            buildRectangleRoundedStep(steps, iv, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // Clippings
                        if (isVertexChanged || isCornerChanged) {
                            buildRectangleRoundedClipping(clippings, iv, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isVertexChanged || isTextureChanged) {
                            buildRectangleRoundedUv(uvs, iv, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * RECTANGLE_ROUNDED_VERTEX_COUNT;
                var vcountReserved = RECTANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullClipping(clippings, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return EShapeLineOfRectangleRoundedsUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfRectangleRoundedsUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, EShapeLineOfRectangleRoundedsUploaded);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangleRounded = /** @class */ (function (_super) {
        __extends(EShapeRectangleRounded, _super);
        function EShapeRectangleRounded(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE_ROUNDED; }
            return _super.call(this, type) || this;
        }
        EShapeRectangleRounded.prototype.clone = function () {
            return new EShapeRectangleRounded().copy(this);
        };
        EShapeRectangleRounded.prototype.containsAbs_ = function (x, y, ax, ay, r, corner) {
            var bx0 = -ax + r;
            if (x <= bx0) {
                var by0 = -ay + r;
                if (y <= by0 && corner & EShapeCorner.TOP_LEFT) {
                    // Top-left corner
                    var dx = x - bx0;
                    var dy = y - by0;
                    return dx * dx + dy * dy <= r * r;
                }
                else {
                    var by1 = +ay - r;
                    if (by1 <= y && corner & EShapeCorner.BOTTOM_LEFT) {
                        // Bottom-left corner
                        var dx = x - bx0;
                        var dy = y - by1;
                        return dx * dx + dy * dy <= r * r;
                    }
                    else {
                        // Middle-left box
                        return -ax <= x;
                    }
                }
            }
            else {
                var bx1 = +ax - r;
                if (bx1 <= x) {
                    var by0 = -ay + r;
                    if (y <= by0 && corner & EShapeCorner.TOP_RIGHT) {
                        // Top-right corner
                        var dx = x - bx1;
                        var dy = y - by0;
                        return dx * dx + dy * dy <= r * r;
                    }
                    else {
                        var by1 = +ay - r;
                        if (by1 <= y && corner & EShapeCorner.BOTTOM_RIGHT) {
                            // Bottom-right corner
                            var dx = x - bx1;
                            var dy = y - by1;
                            return dx * dx + dy * dy <= r * r;
                        }
                        else {
                            // Middle-right box
                            return x <= +ax;
                        }
                    }
                }
                else {
                    return -ay <= y && y <= +ay;
                }
            }
        };
        EShapeRectangleRounded.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var fill = this.fill;
                if (fill.enable || 0 < sw) {
                    var r = this.radius * Math.min(ax, ay);
                    var corner = this.corner;
                    if (this.containsAbs_(x, y, ax, ay, r, corner)) {
                        if (fill.enable) {
                            return true;
                        }
                        else {
                            var s = sw * ss;
                            var wx = Math.max(0.0, ax - s);
                            var wy = Math.max(0.0, ay - s);
                            var wr = Math.max(0.0, r - s);
                            if (!this.containsAbs_(x, y, wx, wy, wr, corner)) {
                                var strokeSide = this.stroke.side;
                                if (strokeSide === EShapeStrokeSide.ALL) {
                                    return true;
                                }
                                else {
                                    if (x <= -wx + wr) {
                                        var hasLeftSide = !!(strokeSide & EShapeStrokeSide.LEFT);
                                        if (y <= -wy + wr) {
                                            var hasTopSide = !!(strokeSide & EShapeStrokeSide.TOP);
                                            if (hasTopSide && hasLeftSide) {
                                                return true;
                                            }
                                            else if (hasTopSide) {
                                                return -wx <= y;
                                            }
                                            else if (hasLeftSide) {
                                                return x <= -wx;
                                            }
                                            else {
                                                return false;
                                            }
                                        }
                                        else if (+wy - wr <= y) {
                                            var hasBottomSide = !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                            if (hasBottomSide && hasLeftSide) {
                                                return true;
                                            }
                                            else if (hasBottomSide) {
                                                return +wx <= y;
                                            }
                                            else if (hasLeftSide) {
                                                return x <= -wx;
                                            }
                                            else {
                                                return false;
                                            }
                                        }
                                        else {
                                            return hasLeftSide;
                                        }
                                    }
                                    else if (+wx - wr <= x) {
                                        var hasRightSide = !!(strokeSide & EShapeStrokeSide.RIGHT);
                                        if (y <= -wy + wr) {
                                            var hasTopSide = !!(strokeSide & EShapeStrokeSide.TOP);
                                            if (hasTopSide && hasRightSide) {
                                                return true;
                                            }
                                            else if (hasTopSide) {
                                                return -wx <= y;
                                            }
                                            else if (hasRightSide) {
                                                return +wx <= x;
                                            }
                                            else {
                                                return false;
                                            }
                                        }
                                        else if (+wy - wr <= y) {
                                            var hasBottomSide = !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                            if (hasBottomSide && hasRightSide) {
                                                return true;
                                            }
                                            else if (hasBottomSide) {
                                                return +wx <= y;
                                            }
                                            else if (hasRightSide) {
                                                return +wx <= x;
                                            }
                                            else {
                                                return false;
                                            }
                                        }
                                        else {
                                            return hasRightSide;
                                        }
                                    }
                                    else {
                                        if (y <= -wy + wr) {
                                            return !!(strokeSide & EShapeStrokeSide.TOP);
                                        }
                                        else if (+wy - wr <= y) {
                                            return !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                        }
                                        else {
                                            return false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeRectangleRounded;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangleRoundeds, _super);
        function EShapeLineOfRectangleRoundeds() {
            var _this = _super.call(this, EShapeType.LINE_OF_RECTANGLE_ROUNDEDS) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfRectangleRoundeds.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfRectangleRoundeds.prototype.clone = function () {
            return new EShapeLineOfRectangleRoundeds().copy(this);
        };
        EShapeLineOfRectangleRoundeds.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, threshold, sw, ss, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfRectangleRoundeds.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss);
        };
        EShapeLineOfRectangleRoundeds.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfRectangleRoundeds.prototype.calcHitPoint = function (point, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(point);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfRectangleRoundeds;
    }(EShapeRectangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfRectangleRoundeds = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfRectangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfRectangleRoundeds = function () {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = createLineOfRectangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = deserializeLineOfRectangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectanglesUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectanglesUploaded, _super);
        function EShapeLineOfRectanglesUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfRectanglesUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfRectanglesUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexClippingStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, RECTANGLE_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, RECTANGLE_VERTEX_COUNT);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfRectanglesUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged) {
                    buffer.updateClippings();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var clippings = buffer.clippings;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = this.toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isVertexChanged || isTransformChanged) {
                        buildRectangleStep(voffset, steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                    // Clippings
                    if (isVertexChanged) {
                        buildRectangleClipping(clippings, voffset, RECTANGLE_WORLD_SIZE);
                        copyClipping(clippings, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isVertexChanged || isTextureChanged) {
                        buildRectangleUv(uvs, voffset, textureUvs, RECTANGLE_WORLD_SIZE);
                        copyUvs(uvs, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * RECTANGLE_VERTEX_COUNT;
                        // Vertices
                        buildRectangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                        // Steps
                        if (isVertexChanged || isTransformChanged) {
                            buildRectangleStep(iv, steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                        }
                        // Clippings
                        if (isVertexChanged) {
                            buildRectangleClipping(clippings, iv, RECTANGLE_WORLD_SIZE);
                        }
                        // UVs
                        if (isVertexChanged || isTextureChanged) {
                            buildRectangleUv(uvs, iv, textureUvs, RECTANGLE_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * RECTANGLE_VERTEX_COUNT;
                var vcountReserved = RECTANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullClipping(clippings, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return EShapeLineOfRectanglesUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfRectanglesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, antialiasWeight, EShapeLineOfRectanglesUploaded);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangles = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangles, _super);
        function EShapeLineOfRectangles() {
            var _this = _super.call(this, EShapeType.LINE_OF_RECTANGLES) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfRectangles.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfRectangles.prototype.clone = function () {
            return new EShapeLineOfRectangles().copy(this);
        };
        EShapeLineOfRectangles.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfRectangles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss);
        };
        EShapeLineOfRectangles.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfRectangles.prototype.calcHitPoint = function (point, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(point);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfRectangles;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfRectangles = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfRectangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfRectangles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLES] = createLineOfRectanglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLES] = deserializeLineOfRectangles;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLES, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    var TRIANGLE_ROUNDED_VERTEX_COUNT = 22;
    var TRIANGLE_ROUNDED_INDEX_COUNT = 15;
    var TRIANGLE_ROUNDED_WORLD_SIZE = [
        0,
        0,
        0,
        0,
        0
    ];
    var TRIANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    var buildTriangleRoundedIndex = function (indices, voffset, ioffset) {
        // Top corner
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
        // Bottom-right corner
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 7;
        // Bottom-left corner
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 11;
        // Others
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 15;
        indices[++ii] = voffset + 16;
        //
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 19;
        //
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 13;
    };
    var buildTriangleRoundedVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) {
        // Calculate the transformed positions
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var sz = Math.sqrt(sx * sx + 4 * sy * sy);
        var sw = (2 * sx * sy) / (sx + sz);
        var ry = (sw * radius) / (2 * sy);
        var rz = (0.5 * (sz - sw) * radius) / sz;
        var rx = (ry * sz) / (2 * sx);
        var work = TRIANGLE_ROUNDED_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var tx = work.x;
        var ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        var dx = tx - x1;
        var dy = ty - y1;
        var x4 = work.x + dx;
        var y4 = work.y + dy;
        var x7 = tx + (tx - work.x) + dx;
        var y7 = ty + (ty - work.y) + dy;
        var dx14 = x4 - x1;
        var dy14 = y4 - y1;
        var x2 = x1 + rz * dx14;
        var y2 = y1 + rz * dy14;
        var x3 = x4 - ry * dx14;
        var y3 = y4 - ry * dy14;
        var dx47r = rx * (x7 - x4);
        var dy47r = rx * (y7 - y4);
        var x5 = x4 + dx47r;
        var y5 = y4 + dy47r;
        var x6 = x7 - dx47r;
        var y6 = y7 - dy47r;
        var dx71 = x1 - x7;
        var dy71 = y1 - y7;
        var x8 = x7 + ry * dx71;
        var y8 = y7 + ry * dy71;
        var x9 = x1 - rz * dx71;
        var y9 = y1 - rz * dy71;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        var x10 = x1 + radius * (x0 - x1);
        var y10 = y1 + radius * (y0 - y1);
        var x11 = x4 + radius * (x0 - x4);
        var y11 = y4 + radius * (y0 - y4);
        var x12 = x7 + radius * (x0 - x7);
        var y12 = y7 + radius * (y0 - y7);
        // World size
        var xb = tx + dx;
        var yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x0, y0);
        worldSize[1] = rx;
        worldSize[2] = ry;
        worldSize[3] = rz;
        worldSize[4] = 1 - (0.5 * sw) / sy;
        // Vertices
        // Top corner
        var iv = voffset * 2 - 1;
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        // Bottom-right corner
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        // Bottom-left corner
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        // Others
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
    };
    var buildTriangleRoundedClipping = function (clippings, voffset, corner, radius) {
        // Top corner
        var iv = voffset * 3 - 1;
        var w = 1 - radius;
        if (corner & EShapeCorner.TOP) {
            clippings[++iv] = 0;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
        }
        else {
            clippings[++iv] = w;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = w;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            clippings[++iv] = 0;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
        }
        else {
            clippings[++iv] = w;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = w;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            clippings[++iv] = 0;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
        }
        else {
            clippings[++iv] = w;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = w;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
        }
        // Others
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = w;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = w;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = w;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
    };
    var buildTriangleRoundedStep = function (steps, clippings, voffset, strokeWidth, strokeStyle, radius, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var s = worldSize[0];
        var sr = radius * s;
        var ic = voffset * 3;
        var is = voffset * 6 - 1;
        for (var i = 0; i < TRIANGLE_ROUNDED_VERTEX_COUNT; i += 1, ic += 3) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            if (0.5 < clippings[ic + 2]) {
                steps[++is] = sr;
                steps[++is] = sr;
                steps[++is] = 1 + clippings[ic];
                steps[++is] = 1 + clippings[ic + 1];
            }
            else {
                steps[++is] = s;
                steps[++is] = s;
                steps[++is] = 1 + clippings[ic];
                steps[++is] = 1 + clippings[ic + 1];
            }
        }
    };
    var buildTriangleRoundedUv = function (uvs, voffset, textureUvs, radius, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var c = worldSize[4];
        var x5 = x4 + c * (x3 - x0);
        var y5 = y4 + c * (y3 - y0);
        var rx = worldSize[1];
        var ry = worldSize[2];
        var rz = worldSize[3];
        var x6 = x4 + rz * (x3 - x4);
        var y6 = y4 + rz * (y3 - y4);
        var x7 = x4 + radius * (x5 - x4);
        var y7 = y4 + radius * (y5 - y4);
        var x8 = x4 + rz * (x2 - x4);
        var y8 = y4 + rz * (y2 - y4);
        var x9 = x2 + ry * (x4 - x2);
        var y9 = y2 + ry * (y4 - y2);
        var x10 = x2 + radius * (x5 - x2);
        var y10 = y2 + radius * (y5 - y2);
        var x11 = x2 + rx * (x3 - x2);
        var y11 = y2 + rx * (y3 - y2);
        var x12 = x3 + rx * (x2 - x3);
        var y12 = y3 + rx * (y2 - y3);
        var x13 = x3 + radius * (x5 - x3);
        var y13 = y3 + radius * (y5 - y3);
        var x14 = x3 + ry * (x4 - x3);
        var y14 = y3 + ry * (y4 - y3);
        // Uvs
        // Top corner
        var iuv = voffset * 2 - 1;
        uvs[++iuv] = x7;
        uvs[++iuv] = y7;
        uvs[++iuv] = x6;
        uvs[++iuv] = y6;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x8;
        uvs[++iuv] = y8;
        // Bottom-right corner
        uvs[++iuv] = x10;
        uvs[++iuv] = y10;
        uvs[++iuv] = x9;
        uvs[++iuv] = y9;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x11;
        uvs[++iuv] = y11;
        // Bottom-left corner
        uvs[++iuv] = x13;
        uvs[++iuv] = y13;
        uvs[++iuv] = x12;
        uvs[++iuv] = y12;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x14;
        uvs[++iuv] = y14;
        // Others
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x7;
        uvs[++iuv] = y7;
        uvs[++iuv] = x8;
        uvs[++iuv] = y8;
        uvs[++iuv] = x9;
        uvs[++iuv] = y9;
        uvs[++iuv] = x10;
        uvs[++iuv] = y10;
        uvs[++iuv] = x11;
        uvs[++iuv] = y11;
        uvs[++iuv] = x12;
        uvs[++iuv] = y12;
        uvs[++iuv] = x13;
        uvs[++iuv] = y13;
        uvs[++iuv] = x14;
        uvs[++iuv] = y14;
        uvs[++iuv] = x6;
        uvs[++iuv] = y6;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangleRoundedsUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangleRoundedsUploaded, _super);
        function EShapeLineOfTriangleRoundedsUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfTriangleRoundedsUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleRoundedIndex(buffer.indices, voffset, ioffset);
                copyIndex(buffer.indices, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfTriangleRoundedsUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexClippingStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, TRIANGLE_ROUNDED_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, TRIANGLE_ROUNDED_VERTEX_COUNT);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfTriangleRoundedsUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var radius = shape.radius;
            var isRadiusChanged = radius !== this.radius;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = this.corner !== corner;
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged ||
                isPointSizeChanged ||
                isSizeChanged ||
                isRadiusChanged ||
                isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isCornerChanged) {
                    buffer.updateClippings();
                }
                if (isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var clippings = buffer.clippings;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = this.toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildTriangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Clippings
                    if (isVertexChanged || isCornerChanged) {
                        buildTriangleRoundedClipping(clippings, voffset, corner, radius);
                        copyClipping(clippings, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // Steps
                    if (isVertexChanged || isTransformChanged || isCornerChanged) {
                        buildTriangleRoundedStep(steps, clippings, voffset, strokeWidth, strokeStyle, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isVertexChanged || isTextureChanged) {
                        buildTriangleRoundedUv(uvs, voffset, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * TRIANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildTriangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                        // Clippings
                        if (isVertexChanged || isCornerChanged) {
                            buildTriangleRoundedClipping(clippings, iv, corner, radius);
                        }
                        // Steps
                        if (isVertexChanged || isTransformChanged || isCornerChanged) {
                            buildTriangleRoundedStep(steps, clippings, iv, strokeWidth, strokeStyle, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isVertexChanged || isTextureChanged) {
                            buildTriangleRoundedUv(uvs, iv, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * TRIANGLE_ROUNDED_VERTEX_COUNT;
                var vcountReserved = TRIANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullClipping(clippings, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return EShapeLineOfTriangleRoundedsUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfTriangleRoundedsUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, EShapeLineOfTriangleRoundedsUploaded);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangle = /** @class */ (function (_super) {
        __extends(EShapeTriangle, _super);
        function EShapeTriangle(type) {
            if (type === void 0) { type = EShapeType.TRIANGLE; }
            return _super.call(this, type) || this;
        }
        EShapeTriangle.prototype.clone = function () {
            return new EShapeTriangle().copy(this);
        };
        EShapeTriangle.prototype.containsAbs_ = function (x, y, a, ay1, ay2) {
            // a = 2 * ay / ax
            // y = + a * x + ay1
            // y = - a * x + ay1
            // y = ay2;
            return +a * x + ay1 - y <= 0 && -a * x + ay1 - y <= 0 && y <= ay2;
        };
        EShapeTriangle.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var a = (2 * ay) / ax;
                var fill = this.fill;
                if (fill.enable) {
                    if (this.containsAbs_(x, y, a, -ay, +ay)) {
                        return true;
                    }
                }
                else {
                    if (0 < sw) {
                        var s = sw * ss;
                        if (this.containsAbs_(x, y, a, -ay, +ay)) {
                            var az = Math.sqrt(ax * ax + 4 * ay * ay);
                            var aw = (2 * ax * ay) / (ax + az);
                            var cy = ay - aw;
                            var ay1 = cy + ((-ay - cy) * Math.max(0.0, aw - s)) / aw;
                            var ay2 = ay - s;
                            if (!this.containsAbs_(x, y, a, ay1, ay2)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeTriangle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FMIN = 0.00001;
    var EShapeTriangleRounded = /** @class */ (function (_super) {
        __extends(EShapeTriangleRounded, _super);
        function EShapeTriangleRounded(type) {
            if (type === void 0) { type = EShapeType.TRIANGLE_ROUNDED; }
            return _super.call(this, type) || this;
        }
        EShapeTriangleRounded.prototype.clone = function () {
            return new EShapeTriangleRounded().copy(this);
        };
        EShapeTriangleRounded.prototype.containsCorner_ = function (x, y, r, aw, sw, ss) {
            var fill = this.fill;
            if (fill.enable) {
                if (x * x + y * y <= r * r) {
                    return true;
                }
            }
            else {
                if (0 < sw) {
                    var d = x * x + y * y;
                    if (d <= r * r) {
                        var w = Math.max(0.0, r * (1 - (sw * ss) / aw));
                        if (w * w <= d) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        EShapeTriangleRounded.prototype.containsCorner = function (x, y, x0, y0, x1, y1, x2, y2, x3, y3, r12, r13, aw, radius, sw, ss) {
            var xl = x1 + r12 * (x2 - x1) - x0;
            var yl = y1 + r12 * (y2 - y1) - y0;
            var n = Math.sqrt(xl * xl + yl * yl);
            if (FMIN < n) {
                var ni = 1 / n;
                var nlx = xl * ni;
                var nly = yl * ni;
                var xr = x1 + r13 * (x3 - x1) - x0;
                var yr = y1 + r13 * (y3 - y1) - y0;
                var nrx = xr * ni;
                var nry = yr * ni;
                var det = nlx * nry - nrx * nly;
                if (FMIN < Math.abs(det)) {
                    var deti = 1 / det;
                    var xc = x - x0;
                    var yc = y - y0;
                    var dx = (+nry * xc - nrx * yc) * deti;
                    var dy = (-nly * xc + nlx * yc) * deti;
                    if (this.containsCorner_(dx, dy, n, aw * radius, sw, ss)) {
                        return true;
                    }
                }
            }
            return false;
        };
        EShapeTriangleRounded.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                var a = (2 * ay) / ax;
                if (this.containsAbs_(x, y, a, -ay, +ay)) {
                    var az = Math.sqrt(ax * ax + 4 * ay * ay);
                    var aw = (2 * ax * ay) / (ax + az);
                    var radius = this.radius;
                    var x0 = 0;
                    var y0 = ay - aw;
                    var x1 = 0;
                    var y1 = -ay;
                    var x4 = +ax;
                    var y4 = +ay;
                    var x7 = -x4;
                    var y7 = +y4;
                    var x10 = x1 + radius * (x0 - x1);
                    var y10 = y1 + radius * (y0 - y1);
                    var x11 = x4 + radius * (x0 - x4);
                    var y11 = y4 + radius * (y0 - y4);
                    var y12 = +y11;
                    var x12 = -x11;
                    var c0 = -a * x + y10 - y <= 0;
                    var c1 = +a * x + y10 - y <= 0;
                    var c2 = y <= y11;
                    var corner = this.corner;
                    if (!c0 && !c1 && corner & EShapeCorner.TOP) {
                        // Top corner
                        var rz = (0.5 * (az - aw) * radius) / az;
                        if (this.containsCorner(x, y, x10, y10, x1, y1, x7, y7, x4, y4, rz, rz, aw, radius, sw, ss)) {
                            return true;
                        }
                    }
                    else if (!c0 && !c2 && corner & EShapeCorner.BOTTOM_LEFT) {
                        // Bottom-left corner
                        var ry = (aw * radius) / (2 * ay);
                        var rx = (ry * az) / (2 * ax);
                        if (this.containsCorner(x, y, x12, y12, x7, y7, x4, y4, x1, y1, rx, ry, aw, radius, sw, ss)) {
                            return true;
                        }
                    }
                    else if (!c1 && !c2 && corner & EShapeCorner.BOTTOM_RIGHT) {
                        // Bottom-right corner
                        var ry = (aw * radius) / (2 * ay);
                        var rx = (ry * az) / (2 * ax);
                        if (this.containsCorner(x, y, x11, y11, x4, y4, x1, y1, x7, y7, ry, rx, aw, radius, sw, ss)) {
                            return true;
                        }
                    }
                    else {
                        // Others
                        var fill = this.fill;
                        if (fill.enable) {
                            return true;
                        }
                        else {
                            if (0 < sw) {
                                var s = sw * ss;
                                var cy = ay - aw;
                                var ay1 = cy + ((-ay - cy) * Math.max(0.0, aw - s)) / aw;
                                var ay2 = ay - s;
                                if (!this.containsAbs_(x, y, a, ay1, ay2)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        };
        return EShapeTriangleRounded;
    }(EShapeTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangleRoundeds, _super);
        function EShapeLineOfTriangleRoundeds() {
            var _this = _super.call(this, EShapeType.LINE_OF_TRIANGLE_ROUNDEDS) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfTriangleRoundeds.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfTriangleRoundeds.prototype.clone = function () {
            return new EShapeLineOfTriangleRoundeds().copy(this);
        };
        EShapeLineOfTriangleRoundeds.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfTriangleRoundeds.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss);
        };
        EShapeLineOfTriangleRoundeds.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfTriangleRoundeds.prototype.calcHitPoint = function (point, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(point);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfTriangleRoundeds;
    }(EShapeTriangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfTriangleRoundeds = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfTriangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfTriangleRoundeds = function () {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = createLineOfTriangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = deserializeLineOfTriangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_TRIANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    var TRIANGLE_VERTEX_COUNT = 7;
    var TRIANGLE_INDEX_COUNT = 3;
    var TRIANGLE_WORLD_SIZE = [0, 0, 0];
    var TRIANGLE_WORK_POINT = new pixi_js.Point();
    var buildTriangleClipping = function (clippings, voffset) {
        // Clippings
        var iv = voffset * 3 - 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
    };
    var buildTriangleIndex = function (indices, voffset, ioffset) {
        // Indices
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
    };
    var buildTriangleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var sz = Math.sqrt(sx * sx + 4 * sy * sy);
        var sw = (2 * sx * sy) / (sx + sz);
        var work = TRIANGLE_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var tx = work.x;
        var ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        var dx = tx - x0;
        var dy = ty - y0;
        var x1 = work.x + dx;
        var y1 = work.y + dy;
        var x2 = tx + (tx - work.x) + dx;
        var y2 = ty + (ty - work.y) + dy;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        var x3 = work.x;
        var y3 = work.y;
        // World size
        var xb = tx + dx;
        var yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x3, y3);
        worldSize[1] = toLength(x1, y1, xb, yb);
        worldSize[2] = toLength(x0, y0, tx, ty);
        // Vertices
        var iv = (voffset << 1) - 1;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
    };
    var buildTriangleStep = function (steps, clippings, voffset, vcount, strokeWidth, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var s = worldSize[0];
        var is = voffset * 6 - 1;
        var ic = voffset * 3;
        for (var i = 0; i < vcount; i += 1, ic += 3) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = 1 + clippings[ic];
            steps[++is] = 1 + clippings[ic + 1];
        }
    };
    var buildTriangleUv = function (uvs, textureUvs, voffset, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var c = 1 - (0.5 * worldSize[0]) / worldSize[2];
        var x5 = x4 + c * (x3 - x0);
        var y5 = y4 + c * (y3 - y0);
        var iuv = (voffset << 1) - 1;
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTrianglesUploaded = /** @class */ (function (_super) {
        __extends(EShapeLineOfTrianglesUploaded, _super);
        function EShapeLineOfTrianglesUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineOfTrianglesUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            var buffer = this.buffer;
            buffer.updateClippings();
            buffer.updateIndices();
            var clippings = buffer.clippings;
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleClipping(clippings, voffset);
                copyClipping(clippings, voffset, TRIANGLE_VERTEX_COUNT, pointCountReserved);
                buildTriangleIndex(indices, voffset, ioffset);
                copyIndex(indices, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, pointCountReserved);
            }
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeLineOfTrianglesUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexStepAndUvs(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, TRIANGLE_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, TRIANGLE_VERTEX_COUNT);
                this.updateText(buffer, shape);
            }
        };
        EShapeLineOfTrianglesUploaded.prototype.updateVertexStepAndUvs = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var clippings = buffer.clippings;
                var uvs = buffer.uvs;
                var textureUvs = this.toTextureUvs(texture);
                var internalTransform = shape.transform.internalTransform;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    buildTriangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    if (isVertexChanged || isTransformChanged) {
                        buildTriangleStep(steps, clippings, voffset, TRIANGLE_VERTEX_COUNT, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                    if (isVertexChanged || isTextureChanged) {
                        buildTriangleUv(uvs, textureUvs, voffset, TRIANGLE_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * TRIANGLE_VERTEX_COUNT;
                        buildTriangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                        if (isVertexChanged || isTransformChanged) {
                            buildTriangleStep(steps, clippings, iv, TRIANGLE_VERTEX_COUNT, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                        }
                        if (isVertexChanged || isTextureChanged) {
                            buildTriangleUv(uvs, textureUvs, iv, TRIANGLE_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * TRIANGLE_VERTEX_COUNT;
                var vcountReserved = TRIANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return EShapeLineOfTrianglesUploaded;
    }(EShapeLineOfAnyUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfTrianglesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, antialiasWeight, EShapeLineOfTrianglesUploaded);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangles = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangles, _super);
        function EShapeLineOfTriangles() {
            var _this = _super.call(this, EShapeType.LINE_OF_TRIANGLES) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss);
            };
            _this._testerBBox = function (x, y, ax, ay, ox, oy, px, py) {
                return _this.containsPointAbsBBox(x, y, ax, ay, ox, oy, px, py);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfTriangles.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfTriangles.prototype.clone = function () {
            return new EShapeLineOfTriangles().copy(this);
        };
        EShapeLineOfTriangles.prototype.containsAbs = function (x, y, ax, ay, sw, ss) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfTriangles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss);
        };
        EShapeLineOfTriangles.prototype.containsPointAbsBBox = function (x, y, ax, ay, ox, oy, px, py) {
            return _super.prototype.containsAbsBBox.call(this, x - px - ox, y - py - oy, ax, ay);
        };
        EShapeLineOfTriangles.prototype.calcHitPoint = function (point, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(point);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfTriangles;
    }(EShapeTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfTriangles = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeLineOfTriangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfTriangles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLES] = createLineOfTrianglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLES] = deserializeLineOfTriangles;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeNullUploaded = /** @class */ (function (_super) {
        __extends(EShapeNullUploaded, _super);
        function EShapeNullUploaded(buffer, voffset, ioffset) {
            return _super.call(this, buffer, voffset, ioffset, 0, 0, 1) || this;
        }
        EShapeNullUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            this.texture = shape.texture || pixi_js.Texture.WHITE;
            return this;
        };
        EShapeNullUploaded.prototype.update = function (shape) {
            // DO NOTHING
        };
        return EShapeNullUploaded;
    }(EShapeUploadedBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createNullUploaded = function (buffer, shape, voffset, ioffset) {
        return new EShapeNullUploaded(buffer, voffset, ioffset).init(shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeNull = /** @class */ (function (_super) {
        __extends(EShapeNull, _super);
        function EShapeNull(type) {
            if (type === void 0) { type = EShapeType.NULL; }
            return _super.call(this, type) || this;
        }
        EShapeNull.prototype.clone = function () {
            return new EShapeNull().copy(this);
        };
        return EShapeNull;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeNull = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeNull());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeNull = function () {
        EShapeUploadeds[EShapeType.NULL] = createNullUploaded;
        EShapeDeserializers[EShapeType.NULL] = deserializeNull;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectangle = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeRectangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectangle = function () {
        EShapeUploadeds[EShapeType.RECTANGLE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE] = deserializeRectangle;
        EShapeCapabilities.set(EShapeType.RECTANGLE, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangleRoundedUploaded = /** @class */ (function (_super) {
        __extends(EShapeRectangleRoundedUploaded, _super);
        function EShapeRectangleRoundedUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeRectangleRoundedUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeRectangleRoundedUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeRectangleRoundedUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var radius = shape.radius;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = corner !== this.corner;
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isVertexChanged || isTransformChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                // Steps
                if (isVertexChanged || isCornerChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleRoundedStep(buffer.steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                }
                // Clippings
                if (isVertexChanged || isCornerChanged) {
                    buffer.updateClippings();
                    buildRectangleRoundedClipping(buffer.clippings, voffset, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                }
                // UVs
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleRoundedUv(buffer.uvs, voffset, this.toTextureUvs(texture), RECTANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        };
        return EShapeRectangleRoundedUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectangleRoundedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = RECTANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeRectangleRoundedUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectangleRounded = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeRectangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectangleRounded = function () {
        EShapeUploadeds[EShapeType.RECTANGLE_ROUNDED] = createRectangleRoundedUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE_ROUNDED] = deserializeRectangleRounded;
        EShapeCapabilities.set(EShapeType.RECTANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangleUploaded = /** @class */ (function (_super) {
        __extends(EShapeTriangleUploaded, _super);
        function EShapeTriangleUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeTriangleUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            var buffer = this.buffer;
            buffer.updateClippings();
            buffer.updateIndices();
            buildTriangleClipping(buffer.clippings, this.vertexOffset);
            buildTriangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeTriangleUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeTriangleUploaded.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isVertexChanged || isTransformChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, TRIANGLE_WORLD_SIZE);
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildTriangleStep(buffer.steps, buffer.clippings, voffset, TRIANGLE_VERTEX_COUNT, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleUv(buffer.uvs, this.toTextureUvs(texture), voffset, TRIANGLE_WORLD_SIZE);
                }
            }
        };
        return EShapeTriangleUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createTriangleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = TRIANGLE_VERTEX_COUNT + tvcount;
        var icount = TRIANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeTriangleUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeTriangle = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeTriangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeTriangle = function () {
        EShapeUploadeds[EShapeType.TRIANGLE] = createTriangleUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE] = deserializeTriangle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangleRoundedUploaded = /** @class */ (function (_super) {
        __extends(EShapeTriangleRoundedUploaded, _super);
        function EShapeTriangleRoundedUploaded() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeTriangleRoundedUploaded.prototype.init = function (shape) {
            _super.prototype.init.call(this, shape);
            // Indices
            var buffer = this.buffer;
            buffer.updateIndices();
            buildTriangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            // Text
            this.initText();
            this.update(shape);
            return this;
        };
        EShapeTriangleRoundedUploaded.prototype.update = function (shape) {
            var buffer = this.buffer;
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateText(buffer, shape);
        };
        EShapeTriangleRoundedUploaded.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var radius = shape.radius;
            var isRadiusChanged = radius !== this.radius;
            var transformLocalId = this.toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = corner !== this.corner;
            var texture = this.toTexture(shape);
            var textureTransformId = this.toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isRadiusChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                    // Invalidate the text layout to update the text layout.
                    this.textSpacingHorizontal = NaN;
                }
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                if (isRadiusChanged || isCornerChanged) {
                    buffer.updateClippings();
                    buildTriangleRoundedClipping(buffer.clippings, voffset, corner, radius);
                }
                if (isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                    buildTriangleRoundedStep(buffer.steps, buffer.clippings, voffset, strokeWidth, strokeStyle, shape.radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleRoundedUv(buffer.uvs, voffset, this.toTextureUvs(texture), radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        };
        return EShapeTriangleRoundedUploaded;
    }(EShapeTextUploaded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createTriangleRoundedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = TRIANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        var icount = TRIANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeTriangleRoundedUploaded(buffer, voffset, ioffset, tvcount, ticount, vcount, icount, antialiasWeight).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeTriangleRounded = function (item, manager) {
        return EShapeDeserializer.deserialize(item, manager, new EShapeTriangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeTriangleRounded = function () {
        EShapeUploadeds[EShapeType.TRIANGLE_ROUNDED] = createTriangleRoundedUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE_ROUNDED] = deserializeTriangleRounded;
        EShapeCapabilities.set(EShapeType.TRIANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeAll = function () {
        loadShapeBar();
        loadShapeCircle();
        loadShapeEmbedded();
        loadShapeGroupShadowed();
        loadShapeGroup();
        loadShapeImage();
        loadShapeImageSdf();
        loadShapeLabel();
        loadShapeLine();
        loadShapeNull();
        loadShapeRectangleRounded();
        loadShapeRectangle();
        loadShapeTriangleRounded();
        loadShapeTriangle();
        loadShapeLineOfCircles();
        loadShapeLineOfRectangleRoundeds();
        loadShapeLineOfRectangles();
        loadShapeLineOfTriangleRoundeds();
        loadShapeLineOfTriangles();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DImage = /** @class */ (function (_super) {
        __extends(DImage, _super);
        function DImage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImage.prototype.getType = function () {
            return "DImage";
        };
        return DImage;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemBase = /** @class */ (function (_super) {
        __extends(DMenuItemBase, _super);
        function DMenuItemBase(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : null;
            return _this;
        }
        DMenuItemBase.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.initOnClick(options);
        };
        DMenuItemBase.prototype.initOnClick = function (options) {
            var _this = this;
            UtilPointerEvent.onClick(this, function (e) {
                if (_this.state.isActionable) {
                    _this.onSelect(e);
                }
            });
        };
        Object.defineProperty(DMenuItemBase.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        DMenuItemBase.prototype.hasSelection = function (target) {
            return target && target.selection && target.selection.add;
        };
        DMenuItemBase.prototype.getSelection = function () {
            var parent = this.parent;
            while (parent) {
                if (this.hasSelection(parent)) {
                    return parent.selection;
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItemBase.prototype.onSelect = function (e) {
            this.emit("select", this);
            var selection = this.getSelection();
            if (selection) {
                selection.add(this);
            }
        };
        DMenuItemBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuItemBase.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onSelect(e);
                return true;
            }
            return false;
        };
        DMenuItemBase.prototype.getType = function () {
            return "DMenuItemBase";
        };
        return DMenuItemBase;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItem = /** @class */ (function (_super) {
        __extends(DMenuItem, _super);
        function DMenuItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItem.prototype.getContext = function () {
            var parent = this.parent;
            while (parent) {
                if (parent.getContext) {
                    return parent.getContext();
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItem.prototype.getCloseable = function () {
            var parent = this.parent;
            while (parent) {
                if (parent.getCloseable) {
                    return parent.getCloseable();
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItem.prototype.getType = function () {
            return "DMenuItem";
        };
        return DMenuItem;
    }(DMenuItemBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemText = /** @class */ (function (_super) {
        __extends(DMenuItemText, _super);
        function DMenuItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemText.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.initOnOver(options);
            this.initShortcuts(options);
        };
        DMenuItemText.prototype.initOnOver = function (options) {
            var _this = this;
            this.on(UtilPointerEvent.over, function () {
                var context = _this.getContext();
                if (context != null) {
                    var parent_1 = _this.parent;
                    if (parent_1 instanceof DBase) {
                        context.trim(_this.getCloseable());
                    }
                }
            });
        };
        DMenuItemText.prototype.initShortcuts = function (options) {
            var shortcuts = this._shortcuts;
            if (shortcuts != null && 0 < shortcuts.length) {
                var shortcut = shortcuts[0];
                var shortcutTextValue = UtilKeyboardEvent.toString(shortcut);
                this._shortcutText = this.createText(shortcutTextValue);
                this.snippet.add(this._shortcutText, true);
            }
            else {
                this._shortcutText = null;
            }
            this._shortcutMargin = this.theme.getShortcutTextMargin();
        };
        DMenuItemText.prototype.updateShortcutText = function () {
            var text = this._shortcutText;
            var margin = this._shortcutMargin;
            if (text != null && margin != null) {
                var toRounded = this.toRounded;
                text.position.set(toRounded(this.width - margin - text.width), toRounded((this.height - text.height) * 0.5));
            }
        };
        DMenuItemText.prototype.updateTextColor = function (text) {
            _super.prototype.updateTextColor.call(this, text);
            var shortcutText = this._shortcutText;
            if (shortcutText != null) {
                var theme = this.theme;
                var state = this.state;
                shortcutText.style.fill = theme.getShortcutColor(state);
                shortcutText.alpha = theme.getShortcutAlpha(state);
            }
        };
        DMenuItemText.prototype.updateText = function () {
            _super.prototype.updateText.call(this);
            this.updateShortcutText();
        };
        DMenuItemText.prototype.getType = function () {
            return "DMenuItemText";
        };
        DMenuItemText.prototype.onSelect = function (e) {
            _super.prototype.onSelect.call(this, e);
            var closeable = this.getCloseable();
            if (closeable != null) {
                closeable.emit("select", this.value, this, closeable);
            }
        };
        DMenuItemText.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.onSelect(e);
        };
        return DMenuItemText;
    }(DMenuItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemCheck = /** @class */ (function (_super) {
        __extends(DMenuItemCheck, _super);
        function DMenuItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemCheck.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            if (options === null || options === void 0 ? void 0 : options.check) {
                this.state.isActive = true;
            }
        };
        DMenuItemCheck.prototype.getType = function () {
            return "DMenuItemCheck";
        };
        DMenuItemCheck.prototype.onSelect = function (e) {
            this.state.isActive = !this.state.isActive;
            _super.prototype.onSelect.call(this, e);
        };
        return DMenuItemCheck;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemCheckIsCompatible = function (options) {
        return "check" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkMenuItemId;
    (function (DLinkMenuItemId) {
        DLinkMenuItemId[DLinkMenuItemId["OPEN_LINK_IN_NEW_WINDOW"] = 0] = "OPEN_LINK_IN_NEW_WINDOW";
        DLinkMenuItemId[DLinkMenuItemId["COPY_LINK_ADDRESS"] = 1] = "COPY_LINK_ADDRESS";
    })(DLinkMenuItemId || (DLinkMenuItemId = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenus = /** @class */ (function () {
        function DMenus() {
        }
        DMenus.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenus.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenus.setMenuCreator = function (creator) {
            this.MENU_CREATOR = creator;
        };
        DMenus.newItemOf = function (creators, creatorDefault, options, sticky) {
            for (var i = 0, imax = creators.length; i < imax; ++i) {
                var created = creators[i](options, sticky);
                if (created != null) {
                    return created;
                }
            }
            if (creatorDefault) {
                return creatorDefault(options, sticky);
            }
            return null;
        };
        DMenus.newItem = function (options, sticky) {
            return this.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky);
        };
        DMenus.newItemsOf = function (creator, parent, items, sticky) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (item instanceof pixi_js.DisplayObject) {
                    parent.addChild(item);
                }
                else if (item != null) {
                    var created = creator.newItem(item, sticky);
                    if (created != null) {
                        parent.addChild(created);
                    }
                    else {
                        throw new Error("No matching menu item creator found: " + JSON.stringify(item));
                    }
                }
            }
        };
        DMenus.newItems = function (parent, items, sticky) {
            this.newItemsOf(this, parent, items, sticky);
        };
        DMenus.newMenu = function (options) {
            if (this.MENU_CREATOR != null) {
                return this.MENU_CREATOR(options);
            }
            else {
                throw new Error("Missing DMenu creator.");
            }
        };
        DMenus.CREATORS = [];
        DMenus.CREATOR_DEFAULT = null;
        return DMenus;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkMenu = /** @class */ (function () {
        function DLinkMenu(parent, options) {
            this._parent = parent;
            this._options = options;
            this._isEnabled = true;
        }
        Object.defineProperty(DLinkMenu.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                this._isEnabled = enable;
            },
            enumerable: false,
            configurable: true
        });
        DLinkMenu.prototype.open = function (target) {
            this.get().open(target);
        };
        DLinkMenu.prototype.get = function () {
            var _this = this;
            var result = this._menu;
            if (result == null) {
                result = this.toMenu(this._options);
                this._menu = result;
                result.on("select", function (value, item, menu) {
                    _this.onSelect(value, item, menu);
                });
            }
            return result;
        };
        DLinkMenu.prototype.toMenu = function (options) {
            if (options instanceof pixi_js.DisplayObject) {
                return options;
            }
            return this.newMenu(options);
        };
        DLinkMenu.prototype.newMenu = function (options) {
            return DMenus.newMenu(options);
        };
        DLinkMenu.prototype.onSelect = function (value, item, menu) {
            var parent = this._parent;
            switch (value) {
                case DLinkMenuItemId.OPEN_LINK_IN_NEW_WINDOW:
                    parent.open(true);
                    break;
                case DLinkMenuItemId.COPY_LINK_ADDRESS:
                    parent.copy();
                    break;
            }
        };
        return DLinkMenu;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkTarget;
    (function (DLinkTarget) {
        DLinkTarget[DLinkTarget["AUTO"] = 0] = "AUTO";
        DLinkTarget[DLinkTarget["THIS_WINDOW"] = 1] = "THIS_WINDOW";
        DLinkTarget[DLinkTarget["NEW_WINDOW"] = 2] = "NEW_WINDOW";
    })(DLinkTarget || (DLinkTarget = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var getSelection = function (element) {
        var selection = document.getSelection();
        if (selection) {
            var range = document.createRange();
            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        return selection;
    };
    var toClipboardData = function (e) {
        return e.clipboardData || window.clipboardData;
    };
    var copyUsingDiv = function (text) {
        var div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        div.textContent = "Dummy";
        document.body.appendChild(div);
        var selection = getSelection(div);
        var result = false;
        if (selection) {
            var handler = function (e) {
                if (e.target === div) {
                    var clipboardData = toClipboardData(e);
                    clipboardData.setData("text/plain", text);
                    result = clipboardData.getData("text/plain") === text;
                    e.preventDefault();
                }
            };
            document.addEventListener("copy", handler);
            try {
                document.execCommand("copy");
            }
            finally {
                document.removeEventListener("copy", handler);
            }
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    var copyUsingSpan = function (text) {
        var div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        var span = document.createElement("span");
        span.innerText = text;
        var root = div.attachShadow ? div.attachShadow({ mode: "open" }) : div;
        root.appendChild(span);
        document.body.appendChild(div);
        var result = false;
        var selection = getSelection(div);
        if (selection) {
            result = document.execCommand("copy");
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    var copyUsingWindow = function (window, text) {
        if (typeof ClipboardEvent === "undefined") {
            var clipboardData = window.clipboardData;
            if (typeof clipboardData !== "undefined" && typeof clipboardData.setData !== "undefined") {
                clipboardData.setData("Text", text);
                return true;
            }
        }
        return false;
    };
    var UtilClipboard = /** @class */ (function (_super) {
        __extends(UtilClipboard, _super);
        function UtilClipboard() {
            var _this = _super.call(this) || this;
            var element = document.body;
            element.addEventListener("copy", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("copy", toClipboardData(e));
                }
            });
            element.addEventListener("cut", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("cut", toClipboardData(e));
                }
            });
            element.addEventListener("paste", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("paste", toClipboardData(e));
                }
            });
            return _this;
        }
        UtilClipboard.copy = function (text) {
            var clipboard = navigator.clipboard;
            if (clipboard && clipboard.writeText) {
                clipboard.writeText(text);
            }
            else {
                if (!copyUsingWindow(window, text)) {
                    if (!copyUsingDiv(text)) {
                        if (navigator.userAgent.indexOf("Edge") < 0) {
                            copyUsingSpan(text);
                        }
                    }
                }
            }
        };
        return UtilClipboard;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var InteractionEvent = pixi_js.interaction.InteractionEvent;
    var DLink = /** @class */ (function () {
        function DLink(theme, options) {
            var _a, _b, _c;
            this._url = (_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : null;
            this._target = toEnum((_b = options === null || options === void 0 ? void 0 : options.target) !== null && _b !== void 0 ? _b : DLinkTarget.AUTO, DLinkTarget);
            this._checker = options === null || options === void 0 ? void 0 : options.checker;
            this._theme = theme;
            this._isEnabled = true;
            this._menu = new DLinkMenu(this, (_c = options === null || options === void 0 ? void 0 : options.menu) !== null && _c !== void 0 ? _c : theme.getLinkMenuOptions());
        }
        Object.defineProperty(DLink.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                this._isEnabled = enable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "url", {
            get: function () {
                return this._url;
            },
            set: function (url) {
                this._url = url;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "target", {
            get: function () {
                return this._target;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "menu", {
            get: function () {
                return this._menu;
            },
            enumerable: false,
            configurable: true
        });
        DLink.prototype.toStringifiedUrl = function (target, onResolved) {
            var url = isFunction(target) ? target() : target;
            if (url != null) {
                if (isString(url)) {
                    onResolved(url);
                }
                else {
                    url.then(function (resolved) {
                        if (resolved != null) {
                            onResolved(resolved);
                        }
                    });
                }
            }
        };
        DLink.prototype.toNormalizedUrl = function (url) {
            var a = DLink.ANCHOR_ELEMENT || document.createElement("a");
            DLink.ANCHOR_ELEMENT = a;
            a.href = url;
            return a.href;
        };
        /**
         * Copys the URL to the clipboard.
         */
        DLink.prototype.copy = function () {
            var _this = this;
            this.toStringifiedUrl(this._url, function (url) {
                UtilClipboard.copy(_this.toNormalizedUrl(url));
            });
        };
        DLink.prototype.open = function (x) {
            var _this = this;
            this.toStringifiedUrl(this._url, function (url) {
                var inNewWindow = x === true || x === false ? x : _this.inNewWindow(x);
                _this.check(url, inNewWindow, function () {
                    _this.exec(url, inNewWindow);
                });
            });
        };
        DLink.prototype.check = function (url, inNewWindow, onResolved) {
            var checker = this._checker;
            if (checker) {
                var checked = checker();
                if (checked === true) {
                    onResolved();
                }
                else if (checked === false) ;
                else {
                    checked.then(function (resolved) {
                        if (resolved) {
                            onResolved();
                        }
                    });
                }
            }
            else {
                onResolved();
            }
        };
        /**
         * Opens the given URL.
         *
         * @param url An URL to be opened
         * @param inNewWindow True to open in a new window.
         */
        DLink.prototype.exec = function (url, inNewWindow) {
            if (inNewWindow) {
                var a_1 = document.createElement("a");
                a_1.href = url;
                a_1.target = "_blank";
                a_1.style.display = "none";
                a_1.rel = "noopener noreferrer";
                document.body.appendChild(a_1);
                a_1.click();
                setTimeout(function () {
                    document.body.removeChild(a_1);
                }, 100);
            }
            else {
                window.location.href = url;
            }
        };
        /**
         * Returns true if the URL need to be opened in a new window.
         *
         * @param e An event object.
         */
        DLink.prototype.inNewWindow = function (e) {
            switch (this._target) {
                case DLinkTarget.NEW_WINDOW:
                    return true;
                case DLinkTarget.THIS_WINDOW:
                    return false;
                case DLinkTarget.AUTO:
                    if (e != null) {
                        var oe = e instanceof InteractionEvent ? e.data.originalEvent : e;
                        return (oe.ctrlKey ||
                            oe.shiftKey ||
                            oe.altKey ||
                            oe.metaKey ||
                            ("button" in oe && oe.button !== 0));
                    }
                    return false;
            }
        };
        DLink.prototype.add = function (base, onSelect) {
            var _this = this;
            var onClick = function (e) {
                if (_this._isEnabled && base.state.isActionable) {
                    onSelect(e);
                }
            };
            if (this._target === DLinkTarget.NEW_WINDOW) {
                UtilPointerEvent.onClick(base, onClick);
            }
            else {
                var menu_1 = this._menu;
                var onLongClick = function (e) {
                    if (_this._isEnabled && base.state.isActionable) {
                        menu_1.open(base);
                    }
                };
                var isLongClickable = function (e) {
                    return menu_1.enable;
                };
                UtilPointerEvent.onLongClick(base, onClick, onLongClick, isLongClickable);
            }
        };
        return DLink;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinks = /** @class */ (function () {
        function DLinks() {
        }
        DLinks.toStateOptions = function (target, options) {
            if (options) {
                if (target === DLinkTarget.NEW_WINDOW || target === "NEW_WINDOW") {
                    var state = options.state;
                    if (state == null) {
                        options.state = DBaseState.NEW_WINDOW;
                    }
                    else if (isString(state)) {
                        if (state !== DBaseState.NEW_WINDOW) {
                            options.state = [state, DBaseState.NEW_WINDOW];
                        }
                    }
                    else {
                        if (state.indexOf(DBaseState.NEW_WINDOW) < 0) {
                            state.push(DBaseState.NEW_WINDOW);
                        }
                    }
                }
            }
            return options;
        };
        return DLinks;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemLink = /** @class */ (function (_super) {
        __extends(DMenuItemLink, _super);
        function DMenuItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemLink.prototype.toLinkOptions = function (options) {
            if (options) {
                return {
                    url: this.toUrl(options.url),
                    target: options.target,
                    checker: this.toChecker(options.checker),
                    menu: options.menu
                };
            }
            return undefined;
        };
        DMenuItemLink.prototype.toUrl = function (url) {
            var _this = this;
            if (isString(url) || url == null) {
                return url;
            }
            else {
                return function () {
                    return url(_this);
                };
            }
        };
        DMenuItemLink.prototype.toChecker = function (checker) {
            var _this = this;
            if (checker != null) {
                return function () {
                    return checker(_this);
                };
            }
            return undefined;
        };
        DMenuItemLink.prototype.init = function (options) {
            this._link = new DLink(this.theme, this.toLinkOptions(options));
            _super.prototype.init.call(this, DLinks.toStateOptions(options === null || options === void 0 ? void 0 : options.target, options));
        };
        Object.defineProperty(DMenuItemLink.prototype, "link", {
            get: function () {
                return this._link;
            },
            enumerable: false,
            configurable: true
        });
        DMenuItemLink.prototype.initOnClick = function (options) {
            var _this = this;
            this._link.add(this, function (e) { return _this.onSelect(e); });
        };
        DMenuItemLink.prototype.getType = function () {
            return "DMenuItemLink";
        };
        DMenuItemLink.prototype.onSelect = function (e) {
            _super.prototype.onSelect.call(this, e);
            this._link.open(e);
        };
        DMenuItemLink.prototype.open = function (inNewWindow) {
            this._link.open(inNewWindow);
        };
        DMenuItemLink.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.onSelect(e);
        };
        return DMenuItemLink;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemLinkIsCompatible = function (options) {
        return "url" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenu = /** @class */ (function (_super) {
        __extends(DMenuItemMenu, _super);
        function DMenuItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemMenu.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.initHover(options);
        };
        DMenuItemMenu.prototype.initHover = function (options) {
            var _this = this;
            this.on(UtilPointerEvent.over, function () {
                if (_this.state.isActionable) {
                    _this.open();
                }
            });
        };
        DMenuItemMenu.prototype.toMenu = function (options) {
            var menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof pixi_js.DisplayObject) {
                return menu;
            }
            return this.newMenu(menu);
        };
        DMenuItemMenu.prototype.newMenu = function (options) {
            return DMenus.newMenu(options);
        };
        Object.defineProperty(DMenuItemMenu.prototype, "menu", {
            get: function () {
                var _this = this;
                var result = this._menu;
                if (result == null) {
                    result = this.toMenu(this._options);
                    result.on("select", function (value, item, menu) {
                        _this.onMenuSelect(value, item, menu);
                    });
                    this._menu = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DMenuItemMenu.prototype.getType = function () {
            return "DMenuItemMenu";
        };
        DMenuItemMenu.prototype.open = function () {
            var menu = this.menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
        };
        DMenuItemMenu.prototype.onOpen = function (menu) {
            var context = this.getContext();
            if (context != null) {
                menu.open(this, this.getCloseable(), context);
            }
        };
        DMenuItemMenu.prototype.close = function () {
            this.menu.close();
        };
        DMenuItemMenu.prototype.toggle = function () {
            var menu = this.menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
            else {
                menu.close();
            }
        };
        DMenuItemMenu.prototype.onSelect = function (e) {
            this.open();
            _super.prototype.onSelect.call(this, e);
        };
        DMenuItemMenu.prototype.onMenuSelect = function (value, item, menu) {
            var closeable = this.getCloseable();
            if (closeable != null) {
                closeable.emit("select", value, item, closeable);
            }
        };
        DMenuItemMenu.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                this.onKeyDownArrowRight(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuItemMenu.prototype.onKeyDownArrowRight = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onSelect(e);
                return true;
            }
            return false;
        };
        return DMenuItemMenu;
    }(DMenuItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenuIsCompatible = function (options) {
        return "menu" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenuToSubMenuOptions = function (options, sticky) {
        var menu = options.menu;
        if (!(menu instanceof pixi_js.DisplayObject)) {
            if (menu.sticky == null) {
                menu.sticky = sticky;
            }
            if (menu.align == null) {
                menu.align = UtilAttachAlign.RIGHT;
            }
        }
        return options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSeparatorReflowable = /** @class */ (function (_super) {
        __extends(DMenuItemSeparatorReflowable, _super);
        function DMenuItemSeparatorReflowable(base) {
            var _this = _super.call(this) || this;
            base.snippet.add(_this, true);
            base.reflowable.add(_this);
            return _this;
        }
        DMenuItemSeparatorReflowable.prototype.onReflow = function (base, width, height) {
            var state = base.state;
            var border = base.border;
            var borderWidth = border.getWidth(state);
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderAlign = border.getAlign(state);
                var padding = base.padding;
                var middle = height * 0.5;
                this.clear();
                this.lineStyle(borderWidth, borderColor, borderAlpha, borderAlign);
                this.moveTo(padding.getLeft(), middle);
                this.lineTo(width - padding.getRight(), middle);
                this.visible = true;
            }
            else {
                this.clear();
                this.visible = false;
            }
        };
        return DMenuItemSeparatorReflowable;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSeparatorIsCompatible = function (options) {
        return "separator" in options;
    };
    var DMenuItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuItemSeparator, _super);
        function DMenuItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemSeparator.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
        };
        DMenuItemSeparator.prototype.initReflowable = function () {
            new DMenuItemSeparatorReflowable(this);
        };
        DMenuItemSeparator.prototype.getType = function () {
            return "DMenuItemSeparator";
        };
        return DMenuItemSeparator;
    }(DMenuItemBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSpace = /** @class */ (function (_super) {
        __extends(DMenuItemSpace, _super);
        function DMenuItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemSpace.prototype.getType = function () {
            return "DMenuItemSpace";
        };
        return DMenuItemSpace;
    }(DLayoutSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSpaceIsCompatible = function (options) {
        return "space" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItem = function () {
        DMenus.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuItemCheck(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuItemLink(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options, sticky) {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuItemSeparator(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuItemSpace(options);
            }
            return null;
        });
        DMenus.setItemCreatorDefault(function (options) {
            return new DMenuItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableBody = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableBody, _super);
        function DMenuItemExpandableBody() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableBody.prototype.getType = function () {
            return "DMenuItemExpandableBody";
        };
        return DMenuItemExpandableBody;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableHeader = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableHeader, _super);
        function DMenuItemExpandableHeader() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableHeader.prototype.getSelection = function () {
            return null;
        };
        DMenuItemExpandableHeader.prototype.getType = function () {
            return "DMenuItemExpandableHeader";
        };
        return DMenuItemExpandableHeader;
    }(DMenuItemBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandables = /** @class */ (function () {
        function DMenuItemExpandables() {
        }
        DMenuItemExpandables.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuItemExpandables.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuItemExpandables.newItem = function (options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky));
        };
        DMenuItemExpandables.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuItemExpandables.CREATORS = [];
        DMenuItemExpandables.CREATOR_DEFAULT = null;
        return DMenuItemExpandables;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandable = /** @class */ (function (_super) {
        __extends(DMenuItemExpandable, _super);
        function DMenuItemExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandable.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            // Header
            var theme = this.theme;
            var header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", function () {
                _this.toggle();
            });
            this.addChild(header);
            // Body
            var body = this.toBody(theme, options);
            this._body = body;
            var sticky = (_a = options === null || options === void 0 ? void 0 : options.sticky) !== null && _a !== void 0 ? _a : false;
            this.newItems(body, sticky, theme, options);
            this.addChild(body);
            //
            if (this.state.isActive) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        };
        DMenuItemExpandable.prototype.newItems = function (body, sticky, theme, options) {
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items != null) {
                DMenuItemExpandables.newItems(body, items, sticky);
            }
        };
        DMenuItemExpandable.prototype.toHeader = function (theme, options) {
            if (options) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        };
        DMenuItemExpandable.prototype.newHeader = function (theme, options) {
            return new DMenuItemExpandableHeader(options);
        };
        DMenuItemExpandable.prototype.toBody = function (theme, options) {
            var body = options === null || options === void 0 ? void 0 : options.body;
            if (body) {
                if (body instanceof pixi_js.DisplayObject) {
                    return body;
                }
                else {
                    return this.newBody(theme, body);
                }
            }
            return this.newBody(theme);
        };
        DMenuItemExpandable.prototype.newBody = function (theme, options) {
            return new DMenuItemExpandableBody(options);
        };
        DMenuItemExpandable.prototype.open = function () {
            this.state.isActive = true;
        };
        DMenuItemExpandable.prototype.close = function () {
            this.state.isActive = false;
        };
        DMenuItemExpandable.prototype.toggle = function () {
            this.state.isActive = !this.state.isActive;
        };
        DMenuItemExpandable.prototype.onActivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        };
        DMenuItemExpandable.prototype.onDeactivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        };
        DMenuItemExpandable.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this.onActivated();
                }
            }
            else {
                if (oldState.isActive) {
                    this.onDeactivated();
                }
            }
        };
        DMenuItemExpandable.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                if (this.state.isActionable && !this.state.isActive) {
                    var header = this._header;
                    if (header instanceof DBase && header.state.isFocused) {
                        this.state.isActive = true;
                    }
                }
            }
            else if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                if (this.state.isActionable && this.state.isActive) {
                    // Move the focus
                    var header = this._header;
                    if (header instanceof DBase) {
                        header.focus();
                    }
                    else {
                        this.focus();
                    }
                    // Deactivate
                    this.state.isActive = false;
                    // Key handling
                    _super.prototype.onKeyDown.call(this, e);
                    return true;
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuItemExpandable.prototype.getType = function () {
            return "DMenuItemExpandable";
        };
        return DMenuItemExpandable;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableIsCompatible = function (options) {
        return "header" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemCheck = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemCheck, _super);
        function DMenuItemExpandableItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemCheck.prototype.getType = function () {
            return "DMenuItemExpandableItemCheck";
        };
        return DMenuItemExpandableItemCheck;
    }(DMenuItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemLink = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemLink, _super);
        function DMenuItemExpandableItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemLink.prototype.getType = function () {
            return "DMenuItemExpandableItemLink";
        };
        return DMenuItemExpandableItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemSeparator, _super);
        function DMenuItemExpandableItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemSeparator.prototype.getType = function () {
            return "DMenuItemExpandableItemSeparator";
        };
        return DMenuItemExpandableItemSeparator;
    }(DMenuItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemSpace = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemSpace, _super);
        function DMenuItemExpandableItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemSpace.prototype.getType = function () {
            return "DMenuItemExpandableItemSpace";
        };
        return DMenuItemExpandableItemSpace;
    }(DMenuItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemText = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemText, _super);
        function DMenuItemExpandableItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemText.prototype.getType = function () {
            return "DMenuItemExpandableItemText";
        };
        return DMenuItemExpandableItemText;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItemExpandable = function () {
        DMenus.addItemCreator(function (options) {
            if (DMenuItemExpandableIsCompatible(options)) {
                return new DMenuItemExpandable(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuItemExpandables.setItemCreatorDefault(function (options) {
            return new DMenuItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemCheck = /** @class */ (function (_super) {
        __extends(DMenuSidedItemCheck, _super);
        function DMenuSidedItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemCheck.prototype.getType = function () {
            return "DMenuSidedItemCheck";
        };
        return DMenuSidedItemCheck;
    }(DMenuItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemLink = /** @class */ (function (_super) {
        __extends(DMenuSidedItemLink, _super);
        function DMenuSidedItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemLink.prototype.getSelection = function () {
            return null;
        };
        DMenuSidedItemLink.prototype.getType = function () {
            return "DMenuSidedItemLink";
        };
        return DMenuSidedItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemMenu = /** @class */ (function (_super) {
        __extends(DMenuSidedItemMenu, _super);
        function DMenuSidedItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemMenu.prototype.initHover = function (options) {
            // DO NOTHING
        };
        DMenuSidedItemMenu.prototype.onMenuSelect = function (value, item, menu) {
            _super.prototype.onMenuSelect.call(this, value, item, menu);
            var selection = _super.prototype.getSelection.call(this);
            if (selection) {
                selection.add(item);
            }
        };
        DMenuSidedItemMenu.prototype.onOpen = function (menu) {
            menu.open(this, this);
        };
        DMenuSidedItemMenu.prototype.getSelection = function () {
            return null;
        };
        DMenuSidedItemMenu.prototype.getType = function () {
            return "DMenuSidedItemMenu";
        };
        return DMenuSidedItemMenu;
    }(DMenuItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuSidedItemSeparator, _super);
        function DMenuSidedItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemSeparator.prototype.getType = function () {
            return "DMenuSidedItemSeparator";
        };
        return DMenuSidedItemSeparator;
    }(DMenuItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemSpace = /** @class */ (function (_super) {
        __extends(DMenuSidedItemSpace, _super);
        function DMenuSidedItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemSpace.prototype.getType = function () {
            return "DMenuSidedItemSpace";
        };
        return DMenuSidedItemSpace;
    }(DMenuItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemText = /** @class */ (function (_super) {
        __extends(DMenuSidedItemText, _super);
        function DMenuSidedItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemText.prototype.getType = function () {
            return "DMenuSidedItemText";
        };
        return DMenuSidedItemText;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSideds = /** @class */ (function () {
        function DMenuSideds() {
        }
        DMenuSideds.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuSideds.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuSideds.newItem = function (options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky));
        };
        DMenuSideds.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuSideds.CREATORS = [];
        DMenuSideds.CREATOR_DEFAULT = null;
        return DMenuSideds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuSidedItem = function () {
        DMenuSideds.setItemCreatorDefault(function (options) {
            return new DMenuSidedItemText(options);
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuSidedItemSpace(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuSidedItemSeparator(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options, sticky) {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuSidedItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuSidedItemLink(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuSidedItemCheck(options);
            }
            return null;
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandables = /** @class */ (function () {
        function DMenuSidedItemExpandables() {
        }
        DMenuSidedItemExpandables.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuSidedItemExpandables.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuSidedItemExpandables.newItem = function (options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenuSideds.newItem(options, sticky));
        };
        DMenuSidedItemExpandables.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuSidedItemExpandables.CREATORS = [];
        DMenuSidedItemExpandables.CREATOR_DEFAULT = null;
        return DMenuSidedItemExpandables;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandable = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandable, _super);
        function DMenuSidedItemExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandable.prototype.newItems = function (body, sticky, theme, options) {
            if (options != null && options.items != null) {
                DMenuSidedItemExpandables.newItems(body, options.items, sticky);
            }
        };
        DMenuSidedItemExpandable.prototype.getType = function () {
            return "DMenuSidedItemExpandable";
        };
        return DMenuSidedItemExpandable;
    }(DMenuItemExpandable));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemCheck = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemCheck, _super);
        function DMenuSidedItemExpandableItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemCheck.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemCheck";
        };
        return DMenuSidedItemExpandableItemCheck;
    }(DMenuItemExpandableItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemLink = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemLink, _super);
        function DMenuSidedItemExpandableItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemLink.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemLink";
        };
        return DMenuSidedItemExpandableItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemMenu = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemMenu, _super);
        function DMenuItemExpandableItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemMenu.prototype.getType = function () {
            return "DMenuItemExpandableItemMenu";
        };
        return DMenuItemExpandableItemMenu;
    }(DMenuItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemMenu = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemMenu, _super);
        function DMenuSidedItemExpandableItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemMenu.prototype.onOpen = function (menu) {
            menu.open(this, this);
        };
        DMenuSidedItemExpandableItemMenu.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemMenu";
        };
        return DMenuSidedItemExpandableItemMenu;
    }(DMenuItemExpandableItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemSeparator, _super);
        function DMenuSidedItemExpandableItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemSeparator.prototype.getType = function () {
            return "DMenuSidedItemSeparator";
        };
        return DMenuSidedItemExpandableItemSeparator;
    }(DMenuItemExpandableItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemSpace = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemSpace, _super);
        function DMenuSidedItemExpandableItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemSpace.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemSpace";
        };
        return DMenuSidedItemExpandableItemSpace;
    }(DMenuItemExpandableItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemText = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemText, _super);
        function DMenuSidedItemExpandableItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemText.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemText";
        };
        return DMenuSidedItemExpandableItemText;
    }(DMenuItemExpandableItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuSidedItemExpandable = function () {
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemExpandableIsCompatible(options)) {
                return new DMenuSidedItemExpandable(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options, sticky) {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.setItemCreatorDefault(function (options) {
            return new DMenuSidedItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItemAll = function () {
        loadMenuItem();
        loadMenuItemExpandable();
        loadMenuSidedItem();
        loadMenuSidedItemExpandable();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadAll = function () {
        loadMenuItemAll();
        loadShapeAll();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscEmitEvent, _super);
        function EShapeActionValueMiscEmitEvent(condition, target) {
            return _super.call(this, EShapeActionValueMiscType.EMIT_EVENT, condition, target, EShapeActionValueOnInputAction.EMIT_EVENT, "") || this;
        }
        return EShapeActionValueMiscEmitEvent;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscHtmlElement = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscHtmlElement, _super);
        function EShapeActionValueMiscHtmlElement(subtype, when, initializer) {
            return _super.call(this, subtype, when, "", EShapeActionValueOnInputAction.EMIT_EVENT, initializer) || this;
        }
        return EShapeActionValueMiscHtmlElement;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscInput = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscInput, _super);
        function EShapeActionValueMiscInput(subtype, when, target, onInputAction) {
            return _super.call(this, subtype, when, target, onInputAction, "") || this;
        }
        return EShapeActionValueMiscInput;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscWrite = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscWrite, _super);
        function EShapeActionValueMiscWrite(subtype, condition, target, value) {
            return _super.call(this, subtype, condition, target, EShapeActionValueOnInputAction.EMIT_EVENT, value) || this;
        }
        return EShapeActionValueMiscWrite;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER = "\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nvarying mediump vec2 vTextureCoord;\nvoid main(void) {\n\tgl_Position = vec4(aVertexPosition, 0.0, 1.0);\n\tvTextureCoord = aTextureCoord;\n}\n";
    var FRAGMENT_SHADER = "\nprecision mediump float;\n\nvarying mediump vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec2 uSize;\n\nfloat calcDistance( float x, float y, float dx, float dy ) {\n\tfloat xd = x + dx;\n\tfloat yd = y + dy;\n\tfloat u = xd / uSize.x;\n\tfloat v = yd / uSize.y;\n\tfloat ul = (xd - 1.0) / uSize.x;\n\tfloat vt = (yd - 1.0) / uSize.y;\n\n\tfloat m = texture2D(uSampler, vec2(u , v )).a;\n\tfloat l = texture2D(uSampler, vec2(ul, v )).a;\n\tfloat t = texture2D(uSampler, vec2(u , vt)).a;\n\n\tfloat xl = mix( xd - 1.0, xd, (0.5 - l) / (m - l) );\n\tfloat yt = mix( yd - 1.0, yd, (0.5 - t) / (m - t) );\n\n\tbool bl = ( min(l, m) < 0.5 && 0.5 <= max(l, m) );\n\tbool bt = ( min(t, m) < 0.5 && 0.5 <= max(t, m) );\n\n\tfloat ll = (bl ? length( vec2( xl - x, yd - y ) ) : 100.0);\n\tfloat lt = (bt ? length( vec2( xd - x, yt - y ) ) : 100.0);\n\n\treturn min( ll, lt );\n}\n\nfloat calcDistancesY( float x, float y, float dx ) {\n\tfloat d = 100.0;\n\tfor( float dy=-6.0; dy<6.5; dy++ ) {\n\t\td = min( d, calcDistance( x, y, dx, dy ) );\n\t}\n\treturn d;\n}\n\nfloat calcDistances( float x, float y ) {\n\tfloat d = 100.0;\n\tfor( float dx=-6.0; dx<6.5; dx++ ) {\n\t\td = min( d, calcDistancesY( x, y, dx ) );\n\t}\n\treturn d;\n}\n\nvoid main(void) {\n\tfloat t = texture2D(uSampler, vTextureCoord).a;\n\tfloat x = vTextureCoord.x * uSize.x;\n\tfloat y = vTextureCoord.y * uSize.y;\n\tfloat d = min( 6.0, calcDistances( x, y ) ) / 12.0;\n\td = clamp( mix( 0.5 - d, 0.5 + d, step( 0.5, t ) ), 0.0, 1.0 );\n\tgl_FragColor = vec4(1.0, 1.0, 1.0, d);\n}\n";
    var DynamicSDFFontGenerator = /** @class */ (function () {
        function DynamicSDFFontGenerator() {
            var _this = this;
            this._gl = null;
            this._texture = null;
            this._shaderProgram = null;
            this._vertexPositionAttribute = NaN;
            this._textureCoordAttribute = NaN;
            this._samplerUniform = NaN;
            this._sizeUniform = NaN;
            this._vb = null;
            this._uvb = null;
            var canvas = (this._canvas = document.createElement("canvas"));
            canvas.width = 64;
            canvas.height = 64;
            this._onLostBound = function (e) {
                e.preventDefault();
            };
            this._onRestoreBound = function () {
                _this.restore();
            };
            this._onUnloadBound = function () {
                _this.destroy();
            };
            canvas.addEventListener("webglcontextlost", this._onLostBound, false);
            canvas.addEventListener("webglcontextrestored", this._onRestoreBound, false);
            window.addEventListener("unload", this._onUnloadBound, false);
        }
        DynamicSDFFontGenerator.prototype.init = function () {
            var canvas = this._canvas;
            if (canvas != null && (this._gl == null || this._gl.isContextLost())) {
                var config = {
                    alpha: true,
                    antialias: false,
                    depth: false,
                    stencil: false,
                    premultipliedAlpha: false
                };
                var gl = canvas.getContext("webgl", config) ||
                    canvas.getContext("experimental-webgl", config);
                this._gl = gl;
                if (gl != null) {
                    gl.clearColor(1.0, 1.0, 1.0, 0.0);
                    this.makeVertexBuffer();
                    this.makeUvBuffer();
                    this.makeShaders();
                    this._texture = null;
                }
            }
            return this;
        };
        DynamicSDFFontGenerator.prototype.restore = function () {
            this.init();
        };
        DynamicSDFFontGenerator.prototype.getCanvas = function () {
            return this._canvas;
        };
        DynamicSDFFontGenerator.prototype.getShader = function (gl, code, type) {
            var shader = type
                ? gl.createShader(gl.FRAGMENT_SHADER)
                : gl.createShader(gl.VERTEX_SHADER);
            if (shader != null) {
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console &&
                        console.error("Failed to compile the shader: " + gl.getShaderInfoLog(shader));
                    return null;
                }
            }
            return shader;
        };
        DynamicSDFFontGenerator.prototype.makeShaders = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var vertexShader = this.getShader(gl, VERTEX_SHADER, false);
                if (vertexShader != null) {
                    var fragmentShader = this.getShader(gl, FRAGMENT_SHADER, true);
                    if (fragmentShader != null) {
                        var shaderProgram = (this._shaderProgram = gl.createProgram());
                        if (shaderProgram != null) {
                            gl.attachShader(shaderProgram, vertexShader);
                            gl.attachShader(shaderProgram, fragmentShader);
                            gl.linkProgram(shaderProgram);
                            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                                console &&
                                    console.error("Failed to link the program: " + gl.getError());
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                return null;
                            }
                            else {
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                gl.useProgram(shaderProgram);
                                this._vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
                                this._textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
                                this._samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
                                this._sizeUniform = gl.getUniformLocation(shaderProgram, "uSize");
                                gl.useProgram(null);
                                return shaderProgram;
                            }
                        }
                        else {
                            gl.deleteShader(vertexShader);
                            gl.deleteShader(fragmentShader);
                        }
                    }
                    else {
                        gl.deleteShader(vertexShader);
                    }
                }
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyShaders = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var shaderProgram = this._shaderProgram;
                if (shaderProgram != null) {
                    this._shaderProgram = null;
                    gl.useProgram(null);
                    gl.deleteProgram(shaderProgram);
                }
            }
        };
        DynamicSDFFontGenerator.prototype.updateTexture = function (source) {
            var gl = this._gl;
            var canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                var width = source.width;
                var height = source.height;
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, width, height);
                }
                var texture = this._texture;
                if (texture == null) {
                    texture = this._texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                return texture;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyTexture = function () {
            var gl = this._gl;
            var texture = this._texture;
            if (gl != null && gl.isContextLost() !== true && texture != null) {
                this._texture = null;
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.deleteTexture(texture);
            }
        };
        DynamicSDFFontGenerator.prototype.makeVertexBuffer = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var vb = (this._vb = gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                var vertices = [-1.0, +1.0, +1.0, +1.0, -1.0, -1.0, +1.0, -1.0];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                return vb;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyVertexBuffer = function () {
            var gl = this._gl;
            var vb = this._vb;
            if (gl != null && gl.isContextLost() !== true && vb != null) {
                this._vb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(vb);
            }
        };
        DynamicSDFFontGenerator.prototype.makeUvBuffer = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var uvb = (this._uvb = gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                var uvs = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
                return uvb;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyUvBuffer = function () {
            var gl = this._gl;
            var uvb = this._uvb;
            if (gl != null && gl.isContextLost() !== true && uvb != null) {
                this._uvb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(uvb);
            }
        };
        DynamicSDFFontGenerator.prototype.render = function () {
            var gl = this._gl;
            var canvas = this._canvas;
            var shaderProgram = this._shaderProgram;
            var vb = this._vb;
            var uvb = this._uvb;
            var texture = this._texture;
            if (gl != null &&
                gl.isContextLost() !== true &&
                canvas != null &&
                shaderProgram != null &&
                vb != null &&
                uvb != null &&
                texture != null) {
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(shaderProgram);
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                var vertexPositionAttribute = this._vertexPositionAttribute;
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.vertexAttribPointer(vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                var textureCoordAttribute = this._textureCoordAttribute;
                gl.enableVertexAttribArray(textureCoordAttribute);
                gl.vertexAttribPointer(textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(this._samplerUniform, 0);
                gl.uniform2f(this._sizeUniform, canvas.width, canvas.height);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.useProgram(null);
            }
        };
        DynamicSDFFontGenerator.prototype.read = function (copyCanvas) {
            var gl = this._gl;
            var canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                var width = canvas.width;
                var height = canvas.height;
                copyCanvas.width = width;
                copyCanvas.height = height;
                var copyContext = copyCanvas.getContext("2d");
                if (copyContext != null) {
                    copyContext.drawImage(canvas, 0, 0);
                }
            }
        };
        DynamicSDFFontGenerator.prototype.destroy = function () {
            this.destroyVertexBuffer();
            this.destroyUvBuffer();
            this.destroyShaders();
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
                canvas.removeEventListener("webglcontextlost", this._onLostBound, false);
                canvas.removeEventListener("webglcontextrestored", this._onRestoreBound, false);
                window.removeEventListener("unload", this._onUnloadBound, false);
            }
            var gl = this._gl;
            if (gl != null) {
                this._gl = null;
                var WebGLLoseContext = gl.getExtension("WEBGL_lose_context");
                if (WebGLLoseContext != null) {
                    WebGLLoseContext.loseContext();
                }
            }
        };
        DynamicSDFFontGenerator.getInstance = function () {
            if (DynamicSDFFontGenerator._INSTANCE == null) {
                DynamicSDFFontGenerator._INSTANCE = new DynamicSDFFontGenerator();
            }
            return DynamicSDFFontGenerator._INSTANCE;
        };
        DynamicSDFFontGenerator._INSTANCE = null;
        return DynamicSDFFontGenerator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImageSdf = function (dataUrl, convertToSdf) {
        if (convertToSdf) {
            return EShapeImageElements.toImageElement(dataUrl).then(function (imageElement) {
                var generator = DynamicSDFFontGenerator.getInstance().init();
                generator.updateTexture(imageElement);
                generator.render();
                var canvas = document.createElement("canvas");
                generator.read(canvas);
                return createImageSdf(canvas.toDataURL(), false);
            });
        }
        else {
            return EShapeImageElements.toImageElement(dataUrl).then(function (imageElement) {
                return new EShapeImageSdf(imageElement);
            });
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImage = function (dataUrl) {
        return EShapeImageElements.toImageElement(dataUrl).then(function (imageElement) {
            return new EShapeImage(imageElement);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLine = function (points, segments, strokeWidth, style) {
        return new EShapeLine(points, segments, strokeWidth, style);
    };
    var toLineStrokeWidth = function (index, resources) {
        if (0 <= index && index < resources.length) {
            try {
                return JSON.parse(resources[index])[3];
            }
            catch (e) {
                //
            }
        }
        return 8;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBufferUnit = /** @class */ (function () {
        function EShapeBufferUnit(texture, indexOffset) {
            this.texture = texture;
            this.indexOffset = indexOffset;
        }
        return EShapeBufferUnit;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBufferUnitBuilder = /** @class */ (function () {
        function EShapeBufferUnitBuilder() {
            this.index = 0;
            this.baseTexture = null;
            this.units = [];
        }
        EShapeBufferUnitBuilder.prototype.begin = function () {
            this.index = 0;
            this.baseTexture = null;
        };
        EShapeBufferUnitBuilder.prototype.push = function (texture, indexOffset) {
            if (this.index < this.units.length) {
                var unit = this.units[this.index];
                unit.texture = texture;
                unit.indexOffset = indexOffset;
            }
            else {
                this.units.push(new EShapeBufferUnit(texture, indexOffset));
            }
            this.index += 1;
        };
        EShapeBufferUnitBuilder.prototype.end = function () {
            if (this.units.length !== this.index) {
                this.units.length = this.index;
            }
        };
        EShapeBufferUnitBuilder.prototype.destroy = function () {
            this.units.length = 0;
        };
        return EShapeBufferUnitBuilder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBuffer = /** @class */ (function () {
        function EShapeBuffer(ntriangles, renderer) {
            var nindices = ntriangles * 3;
            var nvertices = nindices;
            this.vertices = new Float32Array(nvertices * 2);
            this._vertexCapacity = nvertices;
            this._vertexCount = 0;
            this._vertexBuffer = null;
            this.clippings = new Float32Array(nvertices * 3);
            this._clippingBuffer = null;
            this.steps = new Float32Array(nvertices * 6);
            this._stepBuffer = null;
            this.colorFills = new Float32Array(nvertices * 4);
            this._colorFillBuffer = null;
            this.colorStrokes = new Float32Array(nvertices * 4);
            this._colorStrokeBuffer = null;
            this.uvs = new Float32Array(nvertices * 2);
            this._uvBuffer = null;
            var isIndicesShort = nvertices <= 65535;
            this.indices = isIndicesShort ? new Uint16Array(nindices) : new Uint32Array(nindices);
            this._indexCapacity = ntriangles;
            this._indexCount = 0;
            this.indexCountRequested = 0;
            this._indexBuffer = null;
            this._renderer = renderer;
            this._builder = new EShapeBufferUnitBuilder();
            this._geometry = null;
        }
        EShapeBuffer.prototype.updateVertices = function () {
            var vertexBuffer = this._vertexBuffer;
            if (vertexBuffer) {
                vertexBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateClippings = function () {
            var clippingBuffer = this._clippingBuffer;
            if (clippingBuffer) {
                clippingBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateSteps = function () {
            var stepBuffer = this._stepBuffer;
            if (stepBuffer) {
                stepBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateColorFills = function () {
            var colorFillBuffer = this._colorFillBuffer;
            if (colorFillBuffer) {
                colorFillBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateColorStrokes = function () {
            var colorStrokeBuffer = this._colorStrokeBuffer;
            if (colorStrokeBuffer) {
                colorStrokeBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateUvs = function () {
            var uvBuffer = this._uvBuffer;
            if (uvBuffer) {
                uvBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateIndices = function () {
            var indexBuffer = this._indexBuffer;
            if (indexBuffer) {
                indexBuffer.update();
            }
        };
        EShapeBuffer.prototype.getGeometry = function () {
            var result = this._geometry;
            if (result == null) {
                this._vertexBuffer = new pixi_js.Buffer(this.vertices, false, false);
                this._clippingBuffer = new pixi_js.Buffer(this.clippings, false, false);
                this._stepBuffer = new pixi_js.Buffer(this.steps, false, false);
                this._colorFillBuffer = new pixi_js.Buffer(this.colorFills, false, false);
                this._colorStrokeBuffer = new pixi_js.Buffer(this.colorStrokes, false, false);
                this._uvBuffer = new pixi_js.Buffer(this.uvs, false, false);
                this._indexBuffer = new pixi_js.Buffer(this.indices, false, true);
                this._geometry = result = new pixi_js.Geometry()
                    .addIndex(this._indexBuffer)
                    .addAttribute("aPosition", this._vertexBuffer, 2)
                    .addAttribute("aClipping", this._clippingBuffer, 3)
                    .addAttribute("aStep", this._stepBuffer, 2)
                    .addAttribute("aAntialias", this._stepBuffer, 4)
                    .addAttribute("aColorFill", this._colorFillBuffer, 4)
                    .addAttribute("aColorStroke", this._colorStrokeBuffer, 4)
                    .addAttribute("aUv", this._uvBuffer, 2);
            }
            return result;
        };
        EShapeBuffer.prototype.upload = function () {
            this._renderer.geometry.bind(this.getGeometry());
        };
        EShapeBuffer.prototype.render = function (shader) {
            var renderer = this._renderer;
            renderer.geometry.bind(this.getGeometry());
            var units = this._builder.units;
            var unitCount = units.length;
            if (0 < unitCount) {
                var type = pixi_js.DRAW_MODES.TRIANGLES;
                var unit0 = null;
                var unit1 = units[0];
                var ioffset0 = 0;
                var ioffset1 = unit1.indexOffset * 3;
                var vcount = 0;
                var texture = pixi_js.Texture.WHITE;
                for (var i = 0, imax = unitCount - 1; i < imax; ++i) {
                    unit0 = unit1;
                    unit1 = units[i + 1];
                    ioffset0 = ioffset1;
                    ioffset1 = unit1.indexOffset * 3;
                    vcount = ioffset1 - ioffset0;
                    texture = unit0.texture || pixi_js.Texture.WHITE;
                    if (0 < vcount && texture.valid) {
                        shader.uniforms.sampler = renderer.texture.bind(texture);
                        renderer.geometry.draw(type, vcount, ioffset0);
                    }
                }
                vcount = this._indexCount * 3 - ioffset1;
                texture = unit1.texture || pixi_js.Texture.WHITE;
                if (0 < vcount && texture.valid) {
                    shader.uniforms.sampler = renderer.texture.bind(texture);
                    renderer.geometry.draw(type, vcount, ioffset1);
                }
            }
        };
        EShapeBuffer.prototype.isCompatible = function (shape, uploaded, vindex, iindex) {
            return (uploaded.getBuffer() === this &&
                uploaded.getVertexOffset() === vindex &&
                uploaded.getIndexOffset() === iindex &&
                uploaded.isCompatible(shape));
        };
        EShapeBuffer.prototype.update = function (iterator, antialiasWeight, noMoreThanOne) {
            var builder = this._builder;
            builder.begin();
            var vindex = 0;
            var iindex = 0;
            var shape = iterator.get();
            for (; shape != null; shape = iterator.next()) {
                var uploaded = shape.uploaded;
                if (uploaded == null || !this.isCompatible(shape, uploaded, vindex, iindex)) {
                    break;
                }
                uploaded.update(shape);
                uploaded.buildUnit(builder);
                vindex += uploaded.getVertexCount();
                iindex += uploaded.getIndexCount();
                if (noMoreThanOne) {
                    iterator.next();
                    builder.end();
                    this._vertexCount = vindex;
                    this._indexCount = iindex;
                    return 0 < builder.units.length;
                }
            }
            for (; shape != null; shape = iterator.next()) {
                var creater = EShapeUploadeds[shape.type] || EShapeUploadeds[EShapeType.GROUP];
                if (creater == null) {
                    break;
                }
                var uploaded = creater(this, shape, vindex, iindex, antialiasWeight);
                if (uploaded == null) {
                    break;
                }
                uploaded.buildUnit(builder);
                vindex += uploaded.getVertexCount();
                iindex += uploaded.getIndexCount();
                if (noMoreThanOne) {
                    iterator.next();
                    break;
                }
            }
            builder.end();
            this._vertexCount = vindex;
            this._indexCount = iindex;
            return 0 < builder.units.length;
        };
        EShapeBuffer.prototype.check = function (vindex, ioffset, vcount, icount) {
            this.indexCountRequested = icount;
            return vindex + vcount <= this._vertexCapacity && ioffset + icount <= this._indexCapacity;
        };
        EShapeBuffer.prototype.destroy = function () {
            var geometry = this._geometry;
            if (geometry) {
                geometry.destroy();
            }
            this._builder.destroy();
        };
        return EShapeBuffer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItem = /** @class */ (function () {
        function DynamicAtlasItem(id, width, height, strokeWidth, baseTexture) {
            this.id = id;
            this.ref = 0;
            var resolution = baseTexture.resolution;
            this.frame = new pixi_js.Rectangle(0, 0, width * resolution, height * resolution);
            this.texture = new pixi_js.Texture(baseTexture, new pixi_js.Rectangle(0, 0, 1, 1));
            this.width = width;
            this.height = height;
            this.strokeWidth = strokeWidth;
        }
        DynamicAtlasItem.prototype.applyFrame = function () {
            var resolutionInverse = 1 / this.texture.baseTexture.resolution;
            this.texture.frame.x = this.frame.x * resolutionInverse;
            this.texture.frame.y = this.frame.y * resolutionInverse;
            this.texture.frame.width = this.width;
            this.texture.frame.height = this.height;
            this.texture.updateUvs();
            this.texture.emit("update", this);
        };
        DynamicAtlasItem.prototype.destroy = function () {
            this.texture.destroy();
        };
        return DynamicAtlasItem;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemEmpty = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemEmpty, _super);
        function DynamicAtlasItemEmpty() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DynamicAtlasItemEmpty.prototype.render = function (context) {
            // DO NOTHING
        };
        return DynamicAtlasItemEmpty;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemWhite = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemWhite, _super);
        function DynamicAtlasItemWhite() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DynamicAtlasItemWhite.prototype.render = function (context) {
            var frame = this.frame;
            context.save();
            context.fillStyle = "#ffffff";
            context.fillRect(frame.x - 1, frame.y - 1, frame.width + 2, frame.height + 2);
            context.restore();
        };
        return DynamicAtlasItemWhite;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var MAXIMUM_TEXTURE_SIZE = 4096;
    var DynamicAtlas = /** @class */ (function () {
        function DynamicAtlas(resolution) {
            var canvas = (this._canvas = document.createElement("canvas"));
            canvas.width = canvas.height = 256;
            var baseTexture = (this._baseTexture = pixi_js.BaseTexture.from(canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution: resolution
            }));
            this._idToDatum = {};
            this._sortedData = [];
            this._predefined = {
                empty: new DynamicAtlasItemEmpty("empty", 10, 10, 0, baseTexture),
                white: new DynamicAtlasItemWhite("white", 10, 10, 0, baseTexture)
            };
            this._isDirty = true;
        }
        DynamicAtlas.prototype.updateFrames = function (width, data) {
            var padding = 4;
            var x = padding;
            var y = padding;
            var maxRowHeight = 0;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                if (width < x + datum.frame.width + padding) {
                    x = padding;
                    y += maxRowHeight + padding;
                    maxRowHeight = 0;
                }
                datum.frame.x = x | 0;
                datum.frame.y = y | 0;
                x += datum.frame.width + padding;
                maxRowHeight = Math.max(maxRowHeight, datum.frame.height);
            }
            var minHeight = y + maxRowHeight + padding;
            var result = 256;
            while (result < minHeight) {
                result <<= 1;
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result);
        };
        DynamicAtlas.prototype.renderFrames = function (width, height, data) {
            var canvas = this._canvas;
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext("2d");
            if (context != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    var datum = data[i];
                    datum.render(context);
                }
            }
        };
        DynamicAtlas.prototype.applyFrames = function (data) {
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                datum.applyFrame();
            }
        };
        DynamicAtlas.prototype.calcCanvasWidth = function (data) {
            var result = 128;
            for (var i = data.length - 1; 0 <= i; --i) {
                var datum = data[i];
                var size = Math.max(datum.frame.width, datum.frame.height);
                while (result < size) {
                    result <<= 1;
                }
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result << 1);
        };
        DynamicAtlas.prototype.cleanup = function (data) {
            data.sort(DynamicAtlas.ITEM_COMPARATOR);
            for (var i = data.length - 1; 0 <= i; --i) {
                var datum = data[i];
                if (0 < datum.ref) {
                    data.length = i + 1;
                    return;
                }
            }
            data.length = 0;
        };
        DynamicAtlas.prototype.begin = function () {
            var data = this._sortedData;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                datum.ref = 0;
            }
            this._isDirty = false;
        };
        DynamicAtlas.prototype.end = function () {
            var idToDatum = this._idToDatum;
            var data = this._sortedData;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[datum.id];
                    this._isDirty = true;
                }
            }
        };
        DynamicAtlas.prototype.repack = function (forcibly) {
            if (forcibly === true || this._isDirty) {
                this._isDirty = false;
                var data = this._sortedData;
                this.cleanup(data);
                var canvasWidth = this.calcCanvasWidth(data);
                var canvasHeight = this.updateFrames(canvasWidth, data);
                this.renderFrames(canvasWidth, canvasHeight, data);
                this._baseTexture.setRealSize(canvasWidth, canvasHeight);
                this.applyFrames(data);
            }
        };
        DynamicAtlas.prototype.get = function (id) {
            var idToDatum = this._idToDatum;
            var datum = idToDatum[id];
            if (datum != null) {
                datum.ref += 1;
                return datum;
            }
            else {
                var predefined = this._predefined[id];
                if (predefined != null) {
                    this.set(id, predefined);
                    return predefined;
                }
            }
            return null;
        };
        DynamicAtlas.prototype.set = function (id, item) {
            var result = this._idToDatum[id];
            item.ref += 1;
            this._idToDatum[id] = item;
            this._sortedData.push(item);
            this._isDirty = true;
            return result;
        };
        DynamicAtlas.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DynamicAtlas.prototype.getDefaultTexture = function () {
            return this.get("white").texture;
        };
        DynamicAtlas.prototype.getBaseTexture = function () {
            return this._baseTexture;
        };
        DynamicAtlas.prototype.release = function (id) {
            var idToDatum = this._idToDatum;
            var datum = idToDatum[id];
            if (datum != null) {
                datum.ref -= 1;
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[id];
                    this._isDirty = true;
                }
            }
        };
        DynamicAtlas.ITEM_COMPARATOR = function (a, b) {
            if (a.ref <= 0) {
                if (b.ref <= 0) {
                    return 0;
                }
                else {
                    return +1;
                }
            }
            else {
                if (b.ref <= 0) {
                    return -1;
                }
            }
            if (a.frame.height < b.frame.height) {
                return -1;
            }
            else if (b.frame.height < a.frame.height) {
                return +1;
            }
            else {
                return a.frame.width - b.frame.width;
            }
        };
        return DynamicAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemFontAtlas = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemFontAtlas, _super);
        function DynamicAtlasItemFontAtlas(atlas, baseTexture) {
            var _this = _super.call(this, atlas.id, atlas.width / baseTexture.resolution, atlas.height / baseTexture.resolution, 0, baseTexture) || this;
            _this.canvas = atlas.canvas;
            return _this;
        }
        DynamicAtlasItemFontAtlas.prototype.render = function (context) {
            var canvas = this.canvas;
            if (canvas != null) {
                var frame = this.frame;
                context.drawImage(canvas, frame.x, frame.y, frame.width, frame.height);
            }
        };
        return DynamicAtlasItemFontAtlas;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ASCII_CHARACTERS = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasCharacterOrigin = /** @class */ (function () {
        function DynamicFontAtlasCharacterOrigin(x, y) {
            this.x = x;
            this.y = y;
        }
        return DynamicFontAtlasCharacterOrigin;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasCharacter = /** @class */ (function () {
        function DynamicFontAtlasCharacter(advance, width, height, reserved) {
            this.ref = 1;
            this.life = 10;
            this.x = 0;
            this.y = 0;
            this.width = width;
            this.height = height;
            this.advance = advance;
            this.origin = new DynamicFontAtlasCharacterOrigin(0, 0);
            this.reserved = reserved;
        }
        return DynamicFontAtlasCharacter;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicSDFFontAtlas = /** @class */ (function () {
        function DynamicSDFFontAtlas(fontFamily) {
            this._id = "font-atlas:" + fontFamily;
            this._generator = DynamicSDFFontGenerator.getInstance().init();
            this._canvas = document.createElement("canvas");
            this._font = {
                family: DynamicSDFFontAtlas.toFontFamily(fontFamily),
                size: 32,
                italic: false
            };
            this._characters = {};
            this._length = 0;
            this._width = 1;
            this._height = 1;
            this._isDirty = true;
        }
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "font", {
            get: function () {
                return this._font;
            },
            set: function (font) {
                this._font.family = font.family;
                this._font.size = font.size;
                this._font.italic = font.italic;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "generator", {
            get: function () {
                return this._generator;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "characters", {
            get: function () {
                return this._characters;
            },
            enumerable: false,
            configurable: true
        });
        DynamicSDFFontAtlas.prototype.begin = function () {
            this._length = 0;
            var characters = this._characters;
            for (var character in characters) {
                characters[character].ref = 0;
            }
        };
        DynamicSDFFontAtlas.prototype.end = function () {
            var characters = this._characters;
            for (var character in characters) {
                var data = characters[character];
                if (data.ref <= 0) {
                    data.life -= 1;
                    if (data.life <= 0) {
                        delete characters[character];
                        this._isDirty = true;
                    }
                }
            }
        };
        DynamicSDFFontAtlas.prototype.addAscii = function () {
            this.add(ASCII_CHARACTERS);
            this.addChar("...");
        };
        DynamicSDFFontAtlas.prototype.addChar = function (character) {
            var characters = this._characters;
            if (character !== "\n") {
                var data = characters[character];
                if (data != null) {
                    if (data.ref <= 0) {
                        this._length += 1;
                    }
                    data.ref += 1;
                }
                else {
                    characters[character] = new DynamicFontAtlasCharacter(0, 1, 1, false);
                    this._length += 1;
                    this._isDirty = true;
                }
            }
        };
        DynamicSDFFontAtlas.prototype.add = function (characters) {
            var iterator = UtilCharacterIterator.from(characters);
            while (iterator.hasNext()) {
                this.addChar(iterator.next());
            }
        };
        DynamicSDFFontAtlas.prototype.get = function (character) {
            return this._characters[character];
        };
        DynamicSDFFontAtlas.prototype.update = function () {
            if (this._isDirty) {
                var canvas = this._canvas;
                var generator = this._generator;
                if (canvas != null && generator != null) {
                    var context = canvas.getContext("2d");
                    if (context != null) {
                        this._isDirty = false;
                        var font = this._font;
                        var characters = this._characters;
                        var characterSize = font.size + 14;
                        var width = DynamicSDFFontAtlas.toPowerOf2(Math.ceil(Math.sqrt(this._length)) * characterSize);
                        this._width = width;
                        var fontStyle = (font.italic ? "italic " : "") + (font.size + "px ") + font.family;
                        context.font = fontStyle;
                        context.textAlign = "left";
                        context.textBaseline = "middle";
                        context.lineWidth = 0;
                        context.lineCap = "round";
                        context.lineJoin = "miter";
                        context.miterLimit = 0;
                        context.fillStyle = "#FFFFFF";
                        var offsetX = 7;
                        var offsetY = characterSize >> 1;
                        var x = 0;
                        var y = 0;
                        for (var character in characters) {
                            var data = characters[character];
                            var advance = context.measureText(character).width;
                            var characterWidth = Math.ceil(offsetX + advance + offsetX);
                            var characterHeight = characterSize;
                            if (width <= x + characterWidth) {
                                x = 0;
                                y += characterSize;
                            }
                            data.x = x;
                            data.y = y;
                            data.width = characterWidth;
                            data.height = characterHeight;
                            data.advance = advance;
                            data.origin.x = x + offsetX;
                            data.origin.y = y + offsetY;
                            x += characterWidth;
                        }
                        var height = (this._height = y + characterSize);
                        // Make a input canvas
                        // Here, we need to reset the context because
                        // context settings will be lost when we set the width/height.
                        canvas.width = width;
                        canvas.height = height;
                        context.font = fontStyle;
                        context.textAlign = "left";
                        context.textBaseline = "middle";
                        context.lineWidth = 0;
                        context.lineCap = "round";
                        context.lineJoin = "miter";
                        context.miterLimit = 4;
                        context.fillStyle = "#FFFFFF";
                        context.clearRect(0, 0, width, height);
                        for (var character in characters) {
                            var data = characters[character];
                            context.fillText(character, data.origin.x, data.origin.y);
                        }
                        // Convert to SDF font texture
                        generator.updateTexture(canvas);
                        generator.render();
                        generator.read(canvas);
                        return true;
                    }
                }
            }
            return false;
        };
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: false,
            configurable: true
        });
        DynamicSDFFontAtlas.prototype.toJson = function () {
            return {
                width: this._width,
                height: this._height,
                font: this._font,
                characters: this._characters
            };
        };
        DynamicSDFFontAtlas.prototype.toString = function () {
            return JSON.stringify(this.toJson());
        };
        DynamicSDFFontAtlas.prototype.destroy = function () {
            var generator = this._generator;
            if (generator != null) {
                this._generator = null;
            }
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            var characters = this._characters;
            for (var character in characters) {
                delete characters[character];
            }
        };
        DynamicSDFFontAtlas.toFontFamily = function (fontFamily) {
            return fontFamily === "auto" ? DynamicSDFFontAtlas.getAutoFontFamily() : fontFamily;
        };
        DynamicSDFFontAtlas.toPowerOf2 = function (size) {
            var result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        };
        DynamicSDFFontAtlas.getAutoFontFamily = function () {
            if (DynamicSDFFontAtlas.FONT_FAMILY_AUTO == null) {
                DynamicSDFFontAtlas.FONT_FAMILY_AUTO = DThemes.getInstance().get("DBase").getFontFamilly();
            }
            return DynamicSDFFontAtlas.FONT_FAMILY_AUTO;
        };
        DynamicSDFFontAtlas.FONT_FAMILY_AUTO = null;
        return DynamicSDFFontAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicSDFFontAtlases = /** @class */ (function () {
        function DynamicSDFFontAtlases() {
            this._atlases = {};
        }
        DynamicSDFFontAtlases.prototype.begin = function () {
            var atlases = this._atlases;
            for (var family in atlases) {
                var atlas = atlases[family];
                atlas.begin();
            }
        };
        DynamicSDFFontAtlases.prototype.end = function () {
            var atlases = this._atlases;
            for (var family in atlases) {
                var atlas = atlases[family];
                if (0 < atlas.length) {
                    atlas.addAscii();
                }
                atlas.end();
                if (atlas.length <= 0) {
                    atlas.destroy();
                    delete atlases[family];
                }
            }
        };
        DynamicSDFFontAtlases.prototype.add = function (family, targets) {
            var atlas = this._atlases[family];
            if (atlas != null) {
                atlas.add(targets);
            }
            else {
                var newAtlas = new DynamicSDFFontAtlas(family);
                newAtlas.add(targets);
                this._atlases[family] = newAtlas;
            }
        };
        DynamicSDFFontAtlases.prototype.get = function (family) {
            var atlas = this._atlases[family];
            if (atlas != null) {
                return atlas;
            }
            return null;
        };
        DynamicSDFFontAtlases.prototype.update = function (baseAtlas) {
            var atlases = this._atlases;
            var baseTexture = baseAtlas.getBaseTexture();
            for (var family in atlases) {
                var atlas = atlases[family];
                if (atlas.update()) {
                    var atlasId = atlas.id;
                    var item = baseAtlas.get(atlasId);
                    if (item != null) {
                        var width = atlas.width;
                        var height = atlas.height;
                        var resolution = baseTexture.resolution;
                        item.frame.width = width;
                        item.frame.height = height;
                        item.width = width / resolution;
                        item.height = height / resolution;
                        baseAtlas.toDirty();
                    }
                    else {
                        baseAtlas.set(atlasId, new DynamicAtlasItemFontAtlas(atlas, baseTexture));
                    }
                }
            }
        };
        DynamicSDFFontAtlases.prototype.destroy = function () {
            var atlases = this._atlases;
            for (var family in atlases) {
                var atlas = atlases[family];
                atlas.destroy();
            }
            this._atlases = {};
        };
        return DynamicSDFFontAtlases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemImage = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemImage, _super);
        function DynamicAtlasItemImage(image, baseTexture) {
            var _this = _super.call(this, image.src, image.width / baseTexture.resolution, image.height / baseTexture.resolution, 0, baseTexture) || this;
            _this.image = image;
            return _this;
        }
        DynamicAtlasItemImage.prototype.render = function (context) {
            var frame = this.frame;
            var x = frame.x;
            var y = frame.y;
            var w = frame.width;
            var h = frame.height;
            var image = this.image;
            context.drawImage(image, x, y, w, h);
            context.drawImage(image, 0, 0, 1, h, x - 1, y - 1, 1, h + 2);
            context.drawImage(image, 0, 0, w, 1, x, y - 1, w, 1);
            context.drawImage(image, w - 1, 0, 1, h, x + w, y - 1, 1, h + 2);
            context.drawImage(image, 0, h - 1, w, 1, x, y + h, w, 1);
        };
        return DynamicAtlasItemImage;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DUMMY_SHAPES = [];
    var EShapeRendererIteratorDatum = /** @class */ (function () {
        function EShapeRendererIteratorDatum() {
            this.index = 0;
            this.shapes = DUMMY_SHAPES;
        }
        EShapeRendererIteratorDatum.prototype.reset = function (shapes) {
            this.index = -1;
            this.shapes = shapes;
        };
        EShapeRendererIteratorDatum.prototype.next = function () {
            var index = this.index + 1;
            this.index = index;
            var shapes = this.shapes;
            if (index < shapes.length) {
                return shapes[index];
            }
            return null;
        };
        return EShapeRendererIteratorDatum;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRendererIterator = /** @class */ (function () {
        function EShapeRendererIterator() {
            this._index = -1;
            this._datum = new EShapeRendererIteratorDatum();
            this._data = [this._datum];
            this._current = null;
        }
        EShapeRendererIterator.prototype.reset = function (shapes) {
            this._index = 0;
            var current = this._data[0];
            this._datum = current;
            current.reset(shapes);
            this._current = null;
            return this.next();
        };
        EShapeRendererIterator.prototype.get = function () {
            return this._current;
        };
        EShapeRendererIterator.prototype.next = function () {
            var datum = this._datum;
            var shape = datum.next();
            if (shape != null) {
                this._current = shape;
                var children = shape.children;
                if (0 < children.length) {
                    var datumIndex = (this._index = this._index + 1);
                    var data = this._data;
                    if (datumIndex < data.length) {
                        var newDatum = data[datumIndex];
                        newDatum.reset(children);
                        this._datum = newDatum;
                    }
                    else {
                        var newDatum = new EShapeRendererIteratorDatum();
                        data.push(newDatum);
                        newDatum.reset(children);
                        this._datum = newDatum;
                    }
                }
                return shape;
            }
            else {
                var datumIndex = (this._index = this._index - 1);
                var data = this._data;
                if (0 <= datumIndex) {
                    this._datum = data[datumIndex];
                    this._current = null;
                    return this.next();
                }
                else {
                    this._current = null;
                    return null;
                }
            }
        };
        return EShapeRendererIterator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER$1 = "\nattribute vec2 aPosition;\nattribute vec3 aClipping;\nattribute vec2 aStep;\nattribute vec4 aAntialias;\nattribute vec4 aColorFill;\nattribute vec4 aColorStroke;\nattribute vec2 aUv;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mediump float shapeScale;\nuniform mediump float pixelScale;\nuniform mediump float antialiasWeight;\n\nvarying mediump vec3 vClipping;\nvarying mediump vec2 vStep;\nvarying mediump vec4 vAntialias;\nvarying mediump vec4 vColorFill;\nvarying mediump vec4 vColorStroke;\nvarying mediump vec2 vUv;\n\nvec2 toInverse( in vec2 v ) {\n\treturn vec2( -v.y, v.x );\n}\n\nvec2 toTransformedPosition( in vec2 v ) {\n\treturn (projectionMatrix * translationMatrix * vec3(v, 1.0)).xy;\n}\n\nvec4 toAntialias01( in vec4 antialias ) {\n\t// Taylor series of 1 / ( 1 - a ) = 1 + a + a^2 + ....\n\treturn 1.0 + min( vec4( 1.0 ), antialias * pixelScale );\n}\n\nvec4 toAntialias2( in vec4 antialias, in float strokeWidth ) {\n\tfloat x = min( 0.4, 0.4 / 12.0 * antialias.x * pixelScale * antialiasWeight );\n\tfloat w = clamp( strokeWidth / antialias.y, 0.0, 1.0 ) * 0.4;\n\tfloat p = w * antialias.z + antialias.w;\n\tfloat y = 0.5 - p;\n\tfloat z = 0.5 - p - w;\n\treturn vec4( y, z, y - max( 0.01, y - x ), z - max( 0.01, z - x ) );\n}\n\nvec2 toPosition3456( in float type, in vec2 p, in vec2 pprev, in vec2 pnext, in float strokeWidth, out float shift ) {\n\tvec2 d0 = p - pprev;\n\tvec2 d1 = pnext - p;\n\tfloat l0 = dot( d0, d0 );\n\tfloat l1 = dot( d1, d1 );\n\tvec2 nd0 = normalize( toInverse( d0 ) );\n\tvec2 nd1 = normalize( toInverse( d1 ) );\n\tvec2 nd2 = 0.00001 < l1 ? nd1 : vec2(0.0, 0.0);\n\tvec2 n0 = 0.00001 < l0 ? nd0 : nd2;\n\tvec2 n1 = 0.00001 < l1 ? nd1 : n0;\n\tvec2 n0i = toInverse( n0 );\n\tvec2 n1i = toInverse( n1 );\n\tfloat direction = sign( 4.5 - type );\n\n\t// Offset\n\tfloat cross = dot( n0i, n1 );\n\tfloat crossInverse = ( 0.00001 < abs( cross ) ? 1.0 / cross : 0.0 );\n\tfloat b = dot(n1 - n0, n0) * crossInverse;\n\tfloat offsetSize = direction * strokeWidth * 0.5;\n\tvec2 offset = n1 + n1i * b;\n\n\t// Miter\n\tvec2 pmiter = p + offsetSize * offset;\n\tfloat miterAngle0 = dot( n0i, pmiter - pprev );\n\tfloat miterAngle1 = dot( n1i, pmiter - pnext );\n\tfloat miterLength = dot( offset, offset );\n\tfloat miterSide = direction * cross;\n\n\t// Bevel\n\tvec2 n = ( type == 4.0 || type == 6.0 ? n1 : n0 );\n\tvec2 pbevel = p + offsetSize * n;\n\n\t//\n\tvec2 presult = (\n\t\t0.0 <= miterSide ?\n\t\t( miterAngle0 < 0.0 && 0.0 <= miterAngle1 ? pmiter : pbevel ) :\n\t\t( miterLength < 6.0 ? pmiter : pbevel )\n\t);\n\tvec2 ni = ( type == 4.0 || type == 6.0 ? n1i : n0i );\n\tshift = dot( ni, p - presult );\n\treturn toTransformedPosition( presult );\n}\n\nvec2 toStep3456( in float type ) {\n\treturn ( type < 4.5 ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 ) );\n}\n\nvec4 toAntialias3456( in float strokeWidth ) {\n\tfloat a = antialiasWeight / max( 0.0001, strokeWidth );\n\treturn toAntialias01( vec4( a, a, a, a ) );\n}\n\nfloat toDotAndDashScale( in float scale, in float strokeWidthScale ) {\n\treturn (\n\t\tscale == 4.0 || scale == 5.0 || scale == 6.0 || scale == 7.0 ?\n\t\tstrokeWidthScale : 1.0\n\t);\n}\n\nvec4 toColorStroke3456( in float shift, in float scale ) {\n\tfloat x = aColorFill.x + shift;\n\tfloat y = scale * aColorFill.y;\n\tfloat z = scale * aColorFill.z;\n\tfloat w = aColorFill.w;\n\treturn vec4( x, y, z, w );\n}\n\nfloat toStrokeWidthScale( in float scale ) {\n\treturn (\n\t\tscale == 3.0 || scale == 7.0 ?\n\t\tshapeScale : (\n\t\t\tscale == 1.0 || scale == 5.0 ?\n\t\t\tmin( 1.0, shapeScale ) : (\n\t\t\t\tscale == 2.0 || scale == 6.0 ?\n\t\t\t\tmax( 1.0, shapeScale ) : 1.0\n\t\t\t)\n\t\t)\n\t);\n}\n\nvec2 toStep01(in vec2 size, in vec2 weight, in vec2 strokeWidth) {\n\treturn weight / max(vec2(0.00001), vec2(1.0) - strokeWidth / size);\n}\n\nvec4 toAntialias01b(in vec2 size, in vec2 strokeWidth) {\n\treturn antialiasWeight / max(vec4(0.00001), vec4(size - strokeWidth, size));\n}\n\nvoid main(void) {\n\tvec2 p012 = toTransformedPosition( aPosition );\n\n\tfloat type = aClipping.z;\n\tfloat strokeWidthScale = toStrokeWidthScale( aStep.y );\n\tfloat strokeWidth = strokeWidthScale * aStep.x;\n\n\t// type === 0 or 1\n\tvec2 size01 = aAntialias.xy;\n\tvec2 weight01 = abs(aAntialias.zw - sign(aAntialias.zw));\n\tvec2 strokeWidth01 = step(vec2(0.0), aAntialias.zw) * strokeWidth;\n\tvec2 step01 = toStep01( size01, weight01, strokeWidth01 );\n\tvec4 a01 = toAntialias01( toAntialias01b( size01, strokeWidth01 ) );\n\n\t// type === 2\n\tvec4 a2 = toAntialias2( aAntialias, strokeWidth );\n\n\t// type === 3, 4, 5 or 6\n\tfloat shift3456 = 0.0;\n\tvec2 p3456 = toPosition3456( type, aPosition, aAntialias.xy, aAntialias.zw, strokeWidth, shift3456 );\n\tvec2 step3456 = toStep3456( type );\n\tvec4 a3456 = toAntialias3456( strokeWidth );\n\tvec4 colorStroke3456 = toColorStroke3456( shift3456, toDotAndDashScale( aStep.y, strokeWidthScale ) );\n\n\t//\n\tgl_Position = vec4( ( 2.5 < type ? p3456 : p012 ), 0.0, 1.0 );\n\tvAntialias = ( 1.5 < type ? ( 2.5 < type ? a3456 : a2 ) : a01 );\n\tvClipping = aClipping;\n\tvStep = ( 2.5 < type ? step3456 : step01 );\n\tvColorFill = ( 2.5 < type ? aColorStroke : aColorFill );\n\tvColorStroke = ( 2.5 < type ? colorStroke3456 : aColorStroke );\n\tvUv = aUv;\n}";
    var FRAGMENT_SHADER$1 = "\nvarying mediump vec3 vClipping;\nvarying mediump vec2 vStep;\nvarying mediump vec4 vAntialias;\nvarying mediump vec4 vColorFill;\nvarying mediump vec4 vColorStroke;\nvarying mediump vec2 vUv;\n\nuniform sampler2D sampler;\nuniform mediump float pixelScale;\n\nvoid main(void) {\n\tvec4 texture = texture2D(sampler, vUv);\n\tfloat type = vClipping.z;\n\tvec2 v0 = vStep;\n\tvec2 v1 = vClipping.xy;\n\tvec2 v2 = v0 * vAntialias.xy;\n\tvec2 v3 = v1 * vAntialias.zw;\n\tvec2 d01 = ( v0.x < v0.y ? vec2( v0.y, v2.y ) : vec2( v0.x, v2.x ) );\n\tvec2 d02 = ( v1.x < v1.y ? vec2( v1.y, v3.y ) : vec2( v1.x, v3.x ) );\n\tvec4 d0 = vec4( d01.x, d02.x, d01.y, d02.y );\n\tvec4 d1 = vec4( dot( v0, v0 ), dot( v1, v1 ), dot( v2, v2 ), dot( v3, v3 ) );\n\tvec4 d = ( type == 1.0 ? d1 : d0 );\n\tvec2 s = smoothstep( 1.0 - (d.zw - d.xy), vec2( 1.0 ), d.xy );\n\tvec4 color01 = texture * (vColorStroke * (s.x - s.y) + vColorFill * (1.0 - s.x));\n\n\tfloat l = vColorStroke.x;\n\tfloat lp0 = vColorStroke.y;\n\tfloat lp1 = vColorStroke.z;\n\tfloat lt = vColorStroke.w;\n\tfloat ld = 0.5 * pixelScale;\n\tfloat lm = mod( l, lp0 + lp1 );\n\tfloat ls0 = ( 0.0 < lp1 ? smoothstep( 0.0, ld, lm ) - smoothstep( lp0, lp0 + ld, lm ) : 1.0 );\n\tfloat ls1 = ( 0.0 <= lt ? smoothstep( 0.0, ld, l ) - smoothstep( lt - ld, lt, l ) : 1.0 );\n\tvec4 color3456 = color01 * ls0 * ls1;\n\n\tvec2 a0 = vAntialias.xy;\n\tvec2 a1 = vAntialias.zw;\n\tvec2 a2 = vec2( texture.a );\n\tvec2 a = smoothstep( a0 - a1, a0 + a1, a2 );\n\tvec4 color2 = a.x * vColorFill + ( a.y - a.x ) * vColorStroke;\n\tgl_FragColor = ( type == 2.0 ? color2 : (2.5 < type ? color3456 : color01) );\n}";
    var EShapeRenderer = /** @class */ (function (_super) {
        __extends(EShapeRenderer, _super);
        function EShapeRenderer(renderer) {
            var _this = _super.call(this, renderer) || this;
            EShapeRenderer.SHADER =
                EShapeRenderer.SHADER || pixi_js.Shader.from(VERTEX_SHADER$1, FRAGMENT_SHADER$1);
            _this._shader = EShapeRenderer.SHADER;
            _this._iterator = new EShapeRendererIterator();
            _this._bufferSizeMax = _this.getBufferSizeMax(renderer);
            return _this;
        }
        EShapeRenderer.prototype.getBufferSizeMax = function (renderer) {
            var context = renderer.context;
            var extensions = context.extensions;
            if (1 < context.webGLVersion || !!extensions.uint32ElementIndex) {
                return 1431655765; // 2^32 / 3
            }
            return 21845; // 2^16 / 3
        };
        EShapeRenderer.prototype.updateAtlas = function (shape, atlas, fontAtlases, defaultTexture, baseTexture) {
            // Texture
            // Do not access the shape.image.src here.
            // It slows down the rendering speed significantly.
            var imageSrc = shape.imageSrc;
            if (imageSrc != null) {
                var textureItem = atlas.get(imageSrc);
                if (textureItem != null) {
                    shape.texture = textureItem.texture;
                }
                else {
                    var image = shape.image;
                    if (image != null) {
                        var newTextureItem = new DynamicAtlasItemImage(image, baseTexture);
                        shape.texture = newTextureItem.texture;
                        atlas.set(newTextureItem.id, newTextureItem);
                    }
                    else {
                        shape.texture = defaultTexture;
                    }
                }
            }
            else {
                shape.texture = defaultTexture;
            }
            // Font texture atlas
            var text = shape.text;
            var textValue = text.value;
            if (0 < textValue.length) {
                fontAtlases.add(text.family, textValue);
            }
        };
        EShapeRenderer.prototype.updateAtlases = function (shapes, atlas, fontAtlases, defaultTexture, baseTexture) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                this.updateAtlas(shape, atlas, fontAtlases, defaultTexture, baseTexture);
                var children = shape.children;
                for (var j = 0, jmax = children.length; j < jmax; ++j) {
                    var child = children[j];
                    this.updateAtlas(child, atlas, fontAtlases, defaultTexture, baseTexture);
                    this.updateAtlases(child.children, atlas, fontAtlases, defaultTexture, baseTexture);
                }
            }
        };
        EShapeRenderer.prototype.updateFontAtlas = function (shape, atlas, fontAtlases, defaultTexture) {
            var text = shape.text;
            var fontAtlas = fontAtlases.get(text.family);
            if (fontAtlas != null) {
                var textureItem = atlas.get(fontAtlas.id);
                if (textureItem != null) {
                    text.atlas = fontAtlas;
                    text.texture = textureItem.texture;
                }
                else {
                    text.atlas = undefined;
                    text.texture = defaultTexture;
                }
            }
            else {
                text.atlas = undefined;
                text.texture = defaultTexture;
            }
        };
        EShapeRenderer.prototype.updateFontAtlases = function (shapes, atlas, fontAtlases, defaultTexture) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                this.updateFontAtlas(shape, atlas, fontAtlases, defaultTexture);
                var children = shape.children;
                for (var j = 0, jmax = children.length; j < jmax; ++j) {
                    var child = children[j];
                    this.updateFontAtlas(child, atlas, fontAtlases, defaultTexture);
                    this.updateFontAtlases(child.children, atlas, fontAtlases, defaultTexture);
                }
            }
        };
        EShapeRenderer.prototype.render_ = function (container, shapes, isDirty) {
            var renderer = this.renderer;
            var shader = this._shader;
            if (shader != null && 0 < shapes.length) {
                var resolution = renderer.resolution;
                var buffers = container.getBuffers();
                var antialiasWeight = container.getAntialiasWeight(resolution);
                // Update textures
                if (isDirty) {
                    // Atlases
                    var atlas = container.getAtlas(resolution);
                    var fontAtlases = container.getFontAtlases();
                    atlas.begin();
                    fontAtlases.begin();
                    var defaultTexture = atlas.getDefaultTexture();
                    var baseTexture = atlas.getBaseTexture();
                    this.updateAtlases(shapes, atlas, fontAtlases, defaultTexture, baseTexture);
                    fontAtlases.end();
                    fontAtlases.update(atlas);
                    this.updateFontAtlases(shapes, atlas, fontAtlases, defaultTexture);
                    atlas.end();
                    atlas.repack();
                    // Update buffers
                    this.updateBuffers(shapes, buffers, renderer, antialiasWeight);
                }
                // Render buffers
                shader.uniforms.shapeScale = container.toShapeScale();
                shader.uniforms.pixelScale = container.toPixelScale(resolution);
                shader.uniforms.antialiasWeight = antialiasWeight;
                shader.uniforms.translationMatrix = container.worldTransform.toArray(true);
                renderer.shader.bind(shader, false);
                renderer.state.setBlendMode(pixi_js.utils.correctBlendMode(pixi_js.BLEND_MODES.NORMAL, true));
                var buffersLength = buffers.length;
                if (1 < buffersLength) {
                    for (var i = 0; i < buffersLength; ++i) {
                        buffers[i].upload();
                    }
                }
                for (var i = 0; i < buffersLength; ++i) {
                    buffers[i].render(shader);
                }
            }
        };
        EShapeRenderer.prototype.updateBuffers = function (shapes, buffers, renderer, antialiasWeight) {
            var iterator = this._iterator;
            iterator.reset(shapes);
            var ib = 0;
            var bufferSize = 0;
            var bufferSizeBase = 5000;
            var bufferSizeMax = this._bufferSizeMax;
            while (iterator.get() != null) {
                var buffer = null;
                var noMoreThanOne = false;
                if (0 < bufferSize) {
                    buffer = new EShapeBuffer(bufferSize, renderer);
                    buffers.splice(ib, 0, buffer);
                    noMoreThanOne = true;
                }
                else if (ib < buffers.length) {
                    buffer = buffers[ib];
                    noMoreThanOne = false;
                }
                else {
                    buffer = new EShapeBuffer(bufferSizeBase, renderer);
                    buffers.push(buffer);
                    noMoreThanOne = false;
                }
                if (buffer.update(iterator, antialiasWeight, noMoreThanOne)) {
                    bufferSize = 0;
                    ib += 1;
                }
                else {
                    bufferSize = buffer.indexCountRequested;
                    if (bufferSize <= bufferSizeMax) {
                        bufferSize = Math.ceil(bufferSize / bufferSizeBase) * bufferSizeBase;
                        bufferSize = Math.min(bufferSize, bufferSizeMax);
                    }
                    else {
                        // No way to render
                        break;
                    }
                }
            }
            if (ib < buffers.length) {
                for (var jb = ib, ibmax = buffers.length; jb < ibmax; ++jb) {
                    buffers[jb].destroy();
                }
                buffers.length = ib;
            }
        };
        EShapeRenderer.SHADER = null;
        return EShapeRenderer;
    }(pixi_js.ObjectRenderer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeContainer = /** @class */ (function (_super) {
        __extends(EShapeContainer, _super);
        function EShapeContainer() {
            var _this = _super.call(this) || this;
            _this._shapeRenderer = null;
            _this.children = [];
            _this._childrenId = 0;
            _this._childrenIdRendered = -1;
            _this._atlas = null;
            _this._fontAtlases = new DynamicSDFFontAtlases();
            _this._pixelScale = 1;
            _this._pixelScaleId = NaN;
            _this._shapeScale = 1;
            _this._shapeScaleId = NaN;
            _this._work = new pixi_js.Point();
            _this._buffers = [];
            return _this;
        }
        EShapeContainer.prototype.calculateBounds = function () {
            this._bounds.clear();
        };
        EShapeContainer.prototype.onChildTransformChange = function () {
            // DO NOTHING
        };
        EShapeContainer.prototype.toDirty = function () {
            return (this._childrenId += 1);
        };
        EShapeContainer.prototype.isDirty = function () {
            return this._childrenIdRendered < this._childrenId;
        };
        EShapeContainer.prototype.render = function (renderer) {
            if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
                return;
            }
            var childrenId = this._childrenId;
            var childrenIdRendered = this._childrenIdRendered;
            this._childrenIdRendered = childrenId;
            var isChildrenDirty = childrenIdRendered < childrenId;
            var children = this.children;
            var shapeRenderer = this._shapeRenderer;
            if (shapeRenderer == null) {
                shapeRenderer = this._shapeRenderer = new EShapeRenderer(renderer);
            }
            renderer.batch.setObjectRenderer(shapeRenderer);
            var mask = this.mask;
            if (mask) {
                renderer.mask.push(this, mask);
                shapeRenderer.render_(this, children, isChildrenDirty);
                renderer.mask.pop(this);
            }
            else {
                shapeRenderer.render_(this, children, isChildrenDirty);
            }
        };
        EShapeContainer.prototype.containsPoint = function (point) {
            return false;
        };
        EShapeContainer.prototype.getFontAtlases = function () {
            return this._fontAtlases;
        };
        EShapeContainer.prototype.getAtlas = function (resolution) {
            var atlas = this._atlas;
            if (atlas == null) {
                atlas = new DynamicAtlas(resolution);
                this._atlas = atlas;
            }
            return atlas;
        };
        EShapeContainer.prototype.getBuffers = function () {
            return this._buffers;
        };
        EShapeContainer.prototype.toShapeScale = function () {
            this.updateTransform();
            var transform = this.transform;
            var worldID = transform._worldID;
            if (worldID !== this._shapeScaleId) {
                this._shapeScaleId = worldID;
                var worldTransform = transform.worldTransform;
                var a = worldTransform.a;
                var b = worldTransform.b;
                this._shapeScale = 1 / Math.sqrt(a * a + b * b);
            }
            return this._shapeScale;
        };
        EShapeContainer.prototype.getShapeScale = function () {
            return this._shapeScale;
        };
        EShapeContainer.prototype.toPixelScale = function (resolution) {
            var shapeScale = this.toShapeScale();
            var shapeScaleId = this._shapeScaleId;
            if (this._pixelScaleId !== shapeScaleId) {
                this._pixelScaleId = shapeScaleId;
                this._pixelScale = (1 / resolution) * shapeScale;
            }
            return this._pixelScale;
        };
        EShapeContainer.prototype.getPixelScale = function () {
            return this._pixelScale;
        };
        EShapeContainer.prototype.getAntialiasWeight = function (resolution) {
            return 1.25 / resolution;
        };
        EShapeContainer.prototype.hitTest = function (global, handler) {
            var work = this._work;
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                if (child.visible) {
                    var childLocal = child.toLocal(global, undefined, work);
                    var childResult = child.contains(childLocal);
                    if (childResult != null) {
                        if (handler == null || handler(childResult)) {
                            return childResult;
                        }
                    }
                }
            }
            return null;
        };
        EShapeContainer.prototype.hitTestBBox = function (global, handler) {
            var work = this._work;
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                if (child.visible) {
                    var childLocal = child.toLocal(global, undefined, work);
                    if (child.containsBBox(childLocal)) {
                        if (handler == null || handler(child)) {
                            return child;
                        }
                    }
                }
            }
            return null;
        };
        EShapeContainer.prototype.destroy = function () {
            // Buffer
            var buffers = this._buffers;
            if (buffers != null) {
                for (var i = 0, imax = buffers.length; i < imax; ++i) {
                    buffers[i].destroy();
                }
            }
            this._buffers.length = 0;
            // Shapes
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            //
            _super.prototype.destroy.call(this);
        };
        return EShapeContainer;
    }(pixi_js.DisplayObject));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link EShape} search utility.
     */
    var EShapeSearch = /** @class */ (function () {
        function EShapeSearch() {
        }
        /**
         * Returns indices of the given shapes.
         *
         * @param shapes shapes
         * @return indices
         */
        EShapeSearch.toIndices = function (shapes) {
            var result = [];
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                result.push(shapes[i].index);
            }
            return result;
        };
        /**
         * Returns a depth of the given shape.
         *
         * @param shape a shape
         * @return a depth
         */
        EShapeSearch.toDepth = function (shape) {
            var result = 0;
            var parent = shape.parent;
            while (parent instanceof EShapeBase) {
                result += 1;
                parent = parent.parent;
            }
            return result;
        };
        /**
         * Returns a deepest shape on the path to the given shapes.
         *
         * @param shapeA a shape
         * @param shapeB a shape
         * @return a found shape
         */
        EShapeSearch.toSharedParent = function (shapeA, shapeB) {
            var depthA = this.toDepth(shapeA);
            var depthB = this.toDepth(shapeB);
            if (depthA < depthB) {
                var parent_1 = shapeA.parent;
                while (parent_1 instanceof EShapeBase) {
                    if (this.isParent(shapeB, parent_1)) {
                        return parent_1;
                    }
                    parent_1 = parent_1.parent;
                }
                return parent_1;
            }
            else {
                var parent_2 = shapeB.parent;
                while (parent_2 instanceof EShapeBase) {
                    if (this.isParent(shapeA, parent_2)) {
                        return parent_2;
                    }
                    parent_2 = parent_2.parent;
                }
                return parent_2;
            }
        };
        /**
         * Returns a shape on the path to the given shape whose parent is equals to the given parent.
         * If there is no such shape, returns a root shape on the path.
         *
         * @param shape a shape
         * @param parent a parent
         * @returns a found shape
         */
        EShapeSearch.toOfParent = function (shape, parent) {
            var shapeParent = shape.parent;
            while (shapeParent !== parent && shapeParent instanceof EShapeBase) {
                shape = shapeParent;
                shapeParent = shapeParent.parent;
            }
            return shape;
        };
        /**
         * Returns true if the given target is on the path to the given shape.
         *
         * @param shape a shape
         * @param target a check target
         * @return true if the given target is on the path to the given shape
         */
        EShapeSearch.isParent = function (shape, target) {
            var parent = shape.parent;
            while (parent instanceof EShapeBase) {
                if (parent === target) {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        };
        /**
         * Returns a selected shape on the path to the given shape.
         * If there are more than one selected shapes, returns a deepest selected shape.
         *
         * @param shape a shape
         * @return a found selected shape or null
         */
        EShapeSearch.toSelected = function (shape) {
            var target = shape;
            while (target instanceof EShapeBase) {
                if (target.selected) {
                    return target;
                }
                target = target.parent;
            }
            return null;
        };
        EShapeSearch.findChildById = function (shape, id, recursively) {
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child.id === id) {
                    return child;
                }
                if (recursively === true) {
                    var result = EShapeSearch.findChildById(child, id, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        EShapeSearch.findChildByType = function (shape, type, recursively) {
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child.type === type) {
                    return child;
                }
                if (recursively === true) {
                    var result = EShapeSearch.findChildByType(child, type, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        EShapeSearch.findChild = function (shape, matcher, recursively) {
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (matcher(child)) {
                    return child;
                }
                if (recursively === true) {
                    var result = EShapeSearch.findChild(child, matcher, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        EShapeSearch.findChildrenByType = function (shape, type, recursively, result) {
            result = result || [];
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child.type === type) {
                    result.push(child);
                }
                if (recursively === true) {
                    EShapeSearch.findChildrenByType(child, type, recursively, result);
                }
            }
            return result;
        };
        EShapeSearch.findChildren = function (shape, matcher, recursively, result) {
            result = result || [];
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (matcher(child)) {
                    result.push(child);
                }
                if (recursively === true) {
                    EShapeSearch.findChildren(child, matcher, recursively, result);
                }
            }
            return result;
        };
        EShapeSearch.COMPARATOR_INDEX = function (a, b) {
            return a.index - b.index;
        };
        return EShapeSearch;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDeleter = /** @class */ (function () {
        function EShapeDeleter() {
        }
        EShapeDeleter.delete = function (parent, shapes, generateListOfDetachedShapes) {
            var children = parent.children;
            var length = children.length;
            // Update indices
            for (var i = 0; i < length; ++i) {
                var child = children[i];
                if (child.selected) {
                    child.index = length + i;
                }
                else {
                    child.index = i;
                }
            }
            // Sort
            children.sort(EShapeSearch.COMPARATOR_INDEX);
            // Detach
            if (generateListOfDetachedShapes === true) {
                for (var i = length - 1; 0 <= i; --i) {
                    var child = children[i];
                    if (child.selected) {
                        child.index -= length;
                        child.parent = null;
                        child.selected = false;
                        child.uploaded = undefined;
                    }
                    else {
                        var size = children.length - (i + 1);
                        if (0 < size) {
                            var result = children.splice(i + 1, size);
                            if (shapes != null) {
                                shapes.length = 0;
                            }
                            parent.onChildTransformChange();
                            parent.toDirty();
                            return result;
                        }
                        else {
                            if (shapes != null) {
                                shapes.length = 0;
                            }
                            return null;
                        }
                    }
                }
                if (0 < children.length) {
                    var result = children.splice(0, children.length);
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    parent.onChildTransformChange();
                    parent.toDirty();
                    return result;
                }
                else {
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    return null;
                }
            }
            else {
                for (var i = length - 1; 0 <= i; --i) {
                    var child = children[i];
                    if (child.selected) {
                        child.parent = null;
                        child.selected = false;
                        child.uploaded = undefined;
                    }
                    else {
                        children.length = i + 1;
                        if (shapes != null) {
                            shapes.length = 0;
                        }
                        parent.onChildTransformChange();
                        parent.toDirty();
                        return null;
                    }
                }
                if (0 < children.length) {
                    children.length = 0;
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    parent.onChildTransformChange();
                    parent.toDirty();
                }
                else {
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                }
                return null;
            }
        };
        return EShapeDeleter;
    }());

    var EShapePointsStyles = /** @class */ (function () {
        function EShapePointsStyles() {
        }
        EShapePointsStyles.from = function (style) {
            if (isString(style)) {
                return EShapePointsStyle[style];
            }
            else if (isNumber(style)) {
                return style;
            }
            else if (style != null) {
                var result = EShapePointsStyle.NONE;
                for (var i = 0, imax = style.length; i < imax; ++i) {
                    result |= EShapePointsStyle[style[i]];
                }
                return result;
            }
            else {
                return EShapePointsStyle.NONE;
            }
        };
        return EShapePointsStyles;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerSerialization = /** @class */ (function () {
        function EShapeResourceManagerSerialization() {
            this.resources = [];
            this.resourceToIndex = new Map();
            this.tags = [];
            this.tagToIndex = new Map();
            this.pieces = [];
            this.pieceToIndex = new Map();
            this.uuids = new Set();
            this.uuidNext = 0;
        }
        EShapeResourceManagerSerialization.prototype.addResource = function (resource) {
            return this.add_(resource, this.resources, this.resourceToIndex);
        };
        EShapeResourceManagerSerialization.prototype.addTag = function (tag) {
            return this.add_(tag, this.tags, this.tagToIndex);
        };
        EShapeResourceManagerSerialization.prototype.addPiece = function (piece) {
            return this.add_(piece, this.pieces, this.pieceToIndex);
        };
        EShapeResourceManagerSerialization.prototype.addUuid = function (uuid) {
            if (uuid !== 0) {
                var uuids = this.uuids;
                if (uuids.has(uuid)) {
                    return 0;
                }
                else {
                    uuids.add(uuid);
                    return uuid;
                }
            }
            return 0;
        };
        EShapeResourceManagerSerialization.prototype.updateUuid = function (uuid) {
            var uuids = this.uuids;
            if (uuid !== 0) {
                return uuid;
            }
            else {
                var newUuid = this.newUuid();
                uuids.add(newUuid);
                return newUuid;
            }
        };
        EShapeResourceManagerSerialization.prototype.newUuid = function () {
            var uuids = this.uuids;
            var uuidNext = this.uuidNext;
            while (true) {
                uuidNext += 1;
                if (uuidNext !== 0 && !uuids.has(uuidNext)) {
                    this.uuidNext = uuidNext;
                    return uuidNext;
                }
            }
        };
        EShapeResourceManagerSerialization.prototype.add_ = function (target, array, map) {
            var result = map.get(target);
            if (result != null) {
                return result;
            }
            var index = array.length;
            array.push(target);
            map.set(target, index);
            return index;
        };
        return EShapeResourceManagerSerialization;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRuntimes = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperGrid = /** @class */ (function (_super) {
        __extends(ESnapperGrid, _super);
        function ESnapperGrid() {
            var _this = _super.call(this) || this;
            _this._isVisible = false;
            _this._isEnabled = true;
            _this._size = 10;
            return _this;
        }
        Object.defineProperty(ESnapperGrid.prototype, "visible", {
            get: function () {
                return this._isVisible;
            },
            set: function (visible) {
                if (this._isVisible !== visible) {
                    this._isVisible = visible;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperGrid.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                if (this._isEnabled !== enable) {
                    this._isEnabled = enable;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperGrid.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                if (this._size !== size) {
                    this._size = size;
                    this.emit("change", size, this);
                }
            },
            enumerable: false,
            configurable: true
        });
        ESnapperGrid.prototype.snap = function (value, result) {
            if (this._isEnabled) {
                var size = this._size;
                result.set(value, Math.round(value / size) * size);
            }
        };
        ESnapperGrid.prototype.reset = function () {
            this._isEnabled = true;
            this._size = 10;
            this.emit("change", this);
        };
        ESnapperGrid.prototype.serialize = function () {
            return [this._isEnabled ? 1 : 0, this._isVisible ? 1 : 0, this._size];
        };
        ESnapperGrid.prototype.deserialize = function (serialized) {
            this.enable = !!serialized[0];
            if (2 in serialized) {
                this.visible = !!serialized[1];
                this.size = serialized[2];
            }
            else {
                this.visible = false;
                this.size = serialized[1];
            }
        };
        return ESnapperGrid;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperResultScale = /** @class */ (function () {
        function ESnapperResultScale() {
            this.distance = NaN;
            this.scale = new pixi_js.Point();
        }
        return ESnapperResultScale;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperResult = /** @class */ (function () {
        function ESnapperResult() {
            this.distance = NaN;
            this.result = 0;
            this.threshold = 10;
        }
        ESnapperResult.prototype.reset = function (value, scale) {
            this.distance = NaN;
            this.result = value;
            this.threshold = 0.0001 < scale ? 10 / scale : 10;
        };
        ESnapperResult.prototype.set = function (value, snapped) {
            var newDistance = Math.abs(snapped - value);
            if (newDistance <= this.threshold) {
                var oldDistance = this.distance;
                if (oldDistance !== oldDistance || newDistance < oldDistance) {
                    this.distance = newDistance;
                    this.result = snapped;
                }
            }
        };
        return ESnapperResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperTargetValueType;
    (function (ESnapperTargetValueType) {
        ESnapperTargetValueType[ESnapperTargetValueType["HORIZONTAL"] = 0] = "HORIZONTAL";
        ESnapperTargetValueType[ESnapperTargetValueType["VERTICAL"] = 1] = "VERTICAL";
    })(ESnapperTargetValueType || (ESnapperTargetValueType = {}));
    var ESnapperTargetValue = /** @class */ (function () {
        function ESnapperTargetValue(type, position) {
            this.type = type;
            this.position = position;
        }
        ESnapperTargetValue.prototype.serialize = function () {
            return [this.type, this.position];
        };
        return ESnapperTargetValue;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperTarget = /** @class */ (function (_super) {
        __extends(ESnapperTarget, _super);
        function ESnapperTarget() {
            var _this = _super.call(this) || this;
            _this.values = [];
            _this._isVisible = true;
            _this._isEnabled = true;
            return _this;
        }
        Object.defineProperty(ESnapperTarget.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                if (this._isEnabled !== enable) {
                    this._isEnabled = enable;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperTarget.prototype, "visible", {
            get: function () {
                return this._isVisible;
            },
            set: function (visible) {
                if (this._isVisible !== visible) {
                    this._isVisible = visible;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperTarget.prototype, "size", {
            get: function () {
                return this.values.length;
            },
            enumerable: false,
            configurable: true
        });
        ESnapperTarget.prototype.add = function (target, index) {
            if (index != null) {
                this.values.splice(index, 0, target);
            }
            else {
                this.values.push(target);
            }
            this.emit("change", this);
        };
        ESnapperTarget.prototype.remove = function (index) {
            var values = this.values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1);
                this.emit("change", this);
            }
        };
        ESnapperTarget.prototype.replace = function (index, value) {
            var values = this.values;
            if (0 <= index && index < values.length) {
                var result = values[index];
                values[index] = value;
                this.emit("change", this);
                return result;
            }
            return null;
        };
        ESnapperTarget.prototype.swap = function (indexA, indexB) {
            if (indexA !== indexB) {
                var values = this.values;
                var valueA = values[indexA];
                values[indexA] = values[indexB];
                values[indexB] = valueA;
                this.emit("change", this);
            }
        };
        ESnapperTarget.prototype.snap = function (px, py, x, y) {
            if (this._isEnabled) {
                var values = this.values;
                for (var i = 0, imax = values.length; i < imax; ++i) {
                    var value = values[i];
                    if (value.type === ESnapperTargetValueType.VERTICAL) {
                        x.set(px, value.position);
                    }
                    else {
                        y.set(py, value.position);
                    }
                }
            }
        };
        ESnapperTarget.prototype.reset = function () {
            this._isEnabled = true;
            this._isVisible = true;
            this.values.length = 0;
            this.emit("change", this);
        };
        ESnapperTarget.prototype.serialize = function () {
            var targets = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                targets.push(values[i].serialize());
            }
            return [this._isEnabled ? 1 : 0, this._isVisible ? 1 : 0, targets];
        };
        ESnapperTarget.prototype.deserialize = function (serialized) {
            // Availability
            this._isEnabled = !!serialized[0];
            // Visibility
            this._isVisible = !!serialized[1];
            // Values
            var sources = serialized[2];
            var values = this.values;
            values.length = 0;
            for (var i = 0, imax = sources.length; i < imax; ++i) {
                var source = sources[i];
                values.push(new ESnapperTargetValue(source[0], source[1]));
            }
            this.emit("change", this);
        };
        return ESnapperTarget;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EPSILON = 0.00001;
    var ESnapperModifierAnchor;
    (function (ESnapperModifierAnchor) {
        ESnapperModifierAnchor[ESnapperModifierAnchor["NONE"] = 0] = "NONE";
        ESnapperModifierAnchor[ESnapperModifierAnchor["TOP_LEFT"] = 1] = "TOP_LEFT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["TOP_CENTER"] = 2] = "TOP_CENTER";
        ESnapperModifierAnchor[ESnapperModifierAnchor["TOP_RIGHT"] = 3] = "TOP_RIGHT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["MIDDLE_LEFT"] = 4] = "MIDDLE_LEFT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["MIDDLE_RIGHT"] = 5] = "MIDDLE_RIGHT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["BOTTOM_LEFT"] = 6] = "BOTTOM_LEFT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["BOTTOM_CENTER"] = 7] = "BOTTOM_CENTER";
        ESnapperModifierAnchor[ESnapperModifierAnchor["BOTTOM_RIGHT"] = 8] = "BOTTOM_RIGHT";
        ESnapperModifierAnchor[ESnapperModifierAnchor["ROTATION"] = 9] = "ROTATION";
    })(ESnapperModifierAnchor || (ESnapperModifierAnchor = {}));
    var ESnapper = /** @class */ (function (_super) {
        __extends(ESnapper, _super);
        function ESnapper(parent) {
            var _this = _super.call(this) || this;
            _this._points = [
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point() // Center
            ];
            _this._normals = [new pixi_js.Point(), new pixi_js.Point()];
            _this._lengths = [1, 1];
            _this._workScale = new pixi_js.Point();
            _this._workSnapResultX = new ESnapperResult();
            _this._workSnapResultY = new ESnapperResult();
            _this._workScaleResult = {
                distance: 0,
                scale: new pixi_js.Point()
            };
            _this._workTranslate = new pixi_js.Point();
            _this._workSnapRectangle = new pixi_js.Rectangle();
            _this._workSnap = new pixi_js.Point();
            // Grid
            _this.grid = new ESnapperGrid();
            // Target
            _this.target = new ESnapperTarget();
            //
            _this._parent = parent;
            _this._isEnabled = true;
            return _this;
        }
        Object.defineProperty(ESnapper.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                if (this._isEnabled !== enable) {
                    this._isEnabled = enable;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        ESnapper.prototype.prepare = function (modifier) {
            modifier.updateTransform();
            var localTransform = modifier.transform.localTransform;
            var sx = modifier.width;
            var sy = modifier.height;
            var points = this._points;
            points[0].set(0, 0);
            points[1].set(sx, 0);
            points[2].set(sx, sy);
            points[3].set(0, sy);
            points[4].set(sx * 0.5, sy * 0.5);
            localTransform.apply(points[0], points[0]);
            localTransform.apply(points[1], points[1]);
            localTransform.apply(points[2], points[2]);
            localTransform.apply(points[3], points[3]);
            localTransform.apply(points[4], points[4]);
        };
        ESnapper.prototype.prepareForTranslate = function (modifier) {
            if (this._isEnabled) {
                this.prepare(modifier);
            }
        };
        ESnapper.prototype.snap = function (point, result) {
            var px = point.x;
            var py = point.y;
            var canvas = this._parent.canvas;
            var x = this._workSnapResultX;
            var y = this._workSnapResultY;
            // Canvas
            if (canvas != null) {
                var scale = Math.max(canvas.scale.x, canvas.scale.y);
                x.reset(px, scale);
                y.reset(py, scale);
                x.set(px, 0);
                x.set(px, canvas.width);
                y.set(py, 0);
                y.set(py, canvas.height);
            }
            else {
                x.reset(px, 1);
                y.reset(py, 1);
            }
            // Target
            this.target.snap(px, py, x, y);
            // Grid
            this.grid.snap(px, x);
            this.grid.snap(py, y);
            //
            result.x = isNaN(x.distance) ? NaN : x.result;
            result.y = isNaN(y.distance) ? NaN : y.result;
            return result;
        };
        ESnapper.prototype.toSnapped = function (point, result) {
            var px = point.x;
            var py = point.y;
            if (this._isEnabled) {
                this.snap(point, result);
                var x = result.x;
                var y = result.y;
                result.set(isNaN(x) ? px : x, isNaN(y) ? py : y);
            }
            else {
                result.set(px, py);
            }
            return result;
        };
        ESnapper.prototype.toTranslationSnapped = function (delta, result) {
            var dx = delta.x;
            var dy = delta.y;
            var x = NaN;
            var y = NaN;
            if (this._isEnabled) {
                var workTranslate = this._workTranslate;
                var points = this._points;
                for (var i = 0, imax = points.length; i < imax; ++i) {
                    var point = points[i];
                    workTranslate.set(point.x + dx, point.y + dy);
                    this.snap(workTranslate, workTranslate);
                    // X
                    if (!isNaN(workTranslate.x)) {
                        var newDx = workTranslate.x - point.x;
                        if (isNaN(x) || Math.abs(newDx - dx) < Math.abs(x - dx)) {
                            x = newDx;
                        }
                    }
                    // Y
                    if (!isNaN(workTranslate.y)) {
                        var newDy = workTranslate.y - point.y;
                        if (isNaN(y) || Math.abs(newDy - dy) < Math.abs(y - dy)) {
                            y = newDy;
                        }
                    }
                }
            }
            result.x = isNaN(x) ? dx : x;
            result.y = isNaN(y) ? dy : y;
            return result;
        };
        ESnapper.prototype.prepareForRotate = function (modifier) {
            //
        };
        ESnapper.prototype.getGridSizeRotation = function () {
            return 5;
        };
        ESnapper.prototype.toRadian = function (value) {
            return (value / 180) * Math.PI;
        };
        ESnapper.prototype.toDegree = function (value) {
            return (value / Math.PI) * 180;
        };
        ESnapper.prototype.toRotationSnapped = function (baseRotation, deltaRotation) {
            if (this._isEnabled) {
                var gridSize = this.getGridSizeRotation();
                var newRotation = baseRotation + deltaRotation;
                var newRotationDegree = Math.round(this.toDegree(newRotation));
                var newRotationDegreeResidual = newRotationDegree % 90;
                if (Math.abs(newRotationDegreeResidual) <= gridSize) {
                    return this.toRadian(newRotationDegree - newRotationDegreeResidual) - baseRotation;
                }
                else {
                    if (90 - gridSize <= newRotationDegreeResidual) {
                        return (this.toRadian(newRotationDegree + (90 - newRotationDegreeResidual)) -
                            baseRotation);
                    }
                    else if (newRotationDegreeResidual <= -90 + gridSize) {
                        return (this.toRadian(newRotationDegree - (90 + newRotationDegreeResidual)) -
                            baseRotation);
                    }
                    else {
                        return deltaRotation;
                    }
                }
            }
            return deltaRotation;
        };
        ESnapper.prototype.calcNormalizedVector = function (p0, p1, result) {
            var dx = p1.x - p0.x;
            var dy = p1.y - p0.y;
            var l = Math.sqrt(dx * dx + dy * dy);
            if (EPSILON < l) {
                var d = 1 / l;
                result.x = dx * d;
                result.y = dy * d;
            }
            else {
                result.x = 1;
                result.y = 0;
            }
            return l;
        };
        ESnapper.prototype.prepareForScale = function (modifier, anchor) {
            if (this._isEnabled) {
                this.prepare(modifier);
                var points = this._points;
                var normals = this._normals;
                var lengths = this._lengths;
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[3], points[0], normals[1]);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[3], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[2], points[1], normals[1]);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[2], points[3], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[0], points[3], normals[1]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[0], points[3], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[3], points[2], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[1], points[2], normals[1]);
                        break;
                }
            }
        };
        ESnapper.prototype.setScaleSnappedResult = function (distance, length, move, axis, // true => x axis, false y axis
        result) {
            if (EPSILON < length) {
                if (isNaN(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    var newScale = 1 + move / length;
                    if (axis) {
                        result.scale.x = newScale;
                    }
                    else {
                        result.scale.y = newScale;
                    }
                }
            }
        };
        ESnapper.prototype.calcScaleSnapped1D = function (transform, point, normal, length, axis, result) {
            var work = this._workScale;
            transform.apply(point, work);
            var tx = work.x;
            var ty = work.y;
            this.snap(work, work);
            var x = work.x;
            var y = work.y;
            // X coordinate
            if (!isNaN(x)) {
                var nx = Math.abs(normal.x);
                if (EPSILON < nx) {
                    var dx = (x - tx) / normal.x;
                    var distance = Math.abs(dx);
                    var mx = (x - point.x) / normal.x;
                    this.setScaleSnappedResult(distance, length, mx, axis, result);
                }
            }
            // Y coordinate
            if (!isNaN(y)) {
                var ny = Math.abs(normal.y);
                if (EPSILON < ny) {
                    var dy = (y - ty) / normal.y;
                    var distance = Math.abs(dy);
                    var my = (y - point.y) / normal.y;
                    this.setScaleSnappedResult(distance, length, my, axis, result);
                }
            }
        };
        ESnapper.prototype.calcScaleSnappedX = function (transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, true, result);
        };
        ESnapper.prototype.calcScaleSnappedY = function (transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, false, result);
        };
        ESnapper.prototype.calcScaleSnapped2D = function (transform, point, normals, lengths, result) {
            var work = this._workScale;
            transform.apply(point, work);
            var tx = work.x;
            var ty = work.y;
            this.snap(work, work);
            var x = work.x;
            var y = work.y;
            if (isNaN(x)) {
                if (isNaN(y)) {
                    return;
                }
                else {
                    x = tx;
                }
            }
            else {
                if (isNaN(y)) {
                    y = ty;
                }
            }
            // (x, y) = (tx, ty) + normalA * a + normalB * b
            // dx = x - tx
            // dy = y - ty
            // V = ( a, b )^T
            // D = ( dx, dy )^T
            // A = | normalA.x normalB.x |
            //     | normalA.y normalB.y |
            // A V = D
            // det A = normalA.x * normalB.y - normalB.x * normalA.y
            // A^-1 = |  normalB.y -normalB.x | / det A
            //        | -normalA.y  normalA.x |
            var detA = normals[0].x * normals[1].y - normals[1].x * normals[0].y;
            if (EPSILON < Math.abs(detA)) {
                var dx = x - tx;
                var dy = y - ty;
                var distance = Math.abs(dx * dx + dy * dy);
                if (isNaN(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    var mdx = x - point.x;
                    var mdy = y - point.y;
                    var mx = (+normals[1].y * mdx - normals[1].x * mdy) / detA;
                    var my = (-normals[0].y * mdx + normals[0].x * mdy) / detA;
                    result.scale.set(1 + mx / lengths[0], 1 + my / lengths[1]);
                }
            }
        };
        ESnapper.prototype.calcScaleSnappedXY = function (transform, pointO, pointX, pointY, normals, lengths, result) {
            this.calcScaleSnapped2D(transform, pointO, normals, lengths, result);
            this.calcScaleSnappedX(transform, pointY, normals[0], lengths[0], result);
            this.calcScaleSnappedY(transform, pointX, normals[1], lengths[1], result);
        };
        ESnapper.prototype.toScaleSnapped = function (transform, anchor, keepRatio, scale) {
            if (this._isEnabled) {
                var points = this._points;
                var normals = this._normals;
                var lengths = this._lengths;
                var work = this._workScaleResult;
                work.distance = NaN;
                work.scale.set(scale.x, scale.y);
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        this.calcScaleSnappedXY(transform, points[0], points[1], points[3], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        this.calcScaleSnappedY(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[1], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        this.calcScaleSnappedXY(transform, points[1], points[0], points[2], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        this.calcScaleSnappedX(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        this.calcScaleSnappedX(transform, points[1], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[2], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        this.calcScaleSnappedXY(transform, points[3], points[2], points[0], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        this.calcScaleSnappedY(transform, points[2], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        this.calcScaleSnappedXY(transform, points[2], points[3], points[1], normals, lengths, work);
                        break;
                }
                if (!isNaN(work.distance)) {
                    scale.copyFrom(work.scale);
                    if (keepRatio) {
                        switch (anchor) {
                            case ESnapperModifierAnchor.TOP_LEFT:
                            case ESnapperModifierAnchor.TOP_RIGHT:
                            case ESnapperModifierAnchor.BOTTOM_LEFT:
                            case ESnapperModifierAnchor.BOTTOM_RIGHT:
                                scale.x = scale.y = Math.max(scale.x, scale.y);
                                break;
                            case ESnapperModifierAnchor.TOP_CENTER:
                            case ESnapperModifierAnchor.BOTTOM_CENTER:
                                scale.x = scale.y;
                                break;
                            case ESnapperModifierAnchor.MIDDLE_LEFT:
                            case ESnapperModifierAnchor.MIDDLE_RIGHT:
                                scale.y = scale.x;
                                break;
                            case ESnapperModifierAnchor.NONE:
                                break;
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        ESnapper.prototype.reset = function () {
            this.enable = true;
            this.target.reset();
            this.grid.reset();
        };
        ESnapper.prototype.serialize = function () {
            return [this._isEnabled ? 1 : 0, this.target.serialize(), this.grid.serialize()];
        };
        ESnapper.prototype.deserialize = function (serialized) {
            this.enable = !!serialized[0];
            this.target.deserialize(serialized[1]);
            this.grid.deserialize(serialized[2]);
        };
        return ESnapper;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemText = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemText, _super);
        function DynamicAtlasItemText(id, text, baseTexture) {
            var _this = _super.call(this, id, text.width, text.height, 0, baseTexture) || this;
            _this._text = text;
            return _this;
        }
        DynamicAtlasItemText.prototype.render = function (context) {
            var frame = this.frame;
            context.drawImage(this._text.canvas, frame.x, frame.y, frame.width, frame.height);
        };
        return DynamicAtlasItemText;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasFont = /** @class */ (function () {
        function DynamicFontAtlasFont(fontId, size, color, padding) {
            this.id = fontId;
            this.size = size;
            this.color = pixi_js.utils.hex2string(color);
            this.height = size + padding * 2;
            var metrics = pixi_js.TextMetrics.measureFont(fontId);
            this.ascent = metrics.ascent;
            this.descent = metrics.descent;
        }
        return DynamicFontAtlasFont;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var PADDING = 3;
    var DynamicFontAtlas = /** @class */ (function () {
        function DynamicFontAtlas(fontId, fontSize, fontColor, resolution) {
            this._id = fontId;
            this._canvas = document.createElement("canvas");
            this._context = null;
            this._font = new DynamicFontAtlasFont(fontId, fontSize, fontColor, PADDING);
            this._characters = {};
            this._length = 0;
            this._unrefCount = 0;
            this._width = 1;
            this._height = 1;
            this._revision = 0;
            this._revisionUpdated = 0;
            this._texture = pixi_js.Texture.from(this._canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution: resolution,
                scaleMode: pixi_js.SCALE_MODES.NEAREST
            });
            this.add(ASCII_CHARACTERS, true);
            this.add_("...", this._characters, true);
        }
        Object.defineProperty(DynamicFontAtlas.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "font", {
            get: function () {
                return this._font;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "characters", {
            get: function () {
                return this._characters;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: false,
            configurable: true
        });
        DynamicFontAtlas.prototype.add_ = function (character, characters, reserved) {
            if (character !== "\n") {
                var data = characters[character];
                if (data != null) {
                    if (!data.reserved) {
                        if (data.ref === 0) {
                            this._unrefCount -= 1;
                        }
                        data.ref += 1;
                    }
                }
                else {
                    var advance = this.getAdvance(character);
                    var width = Math.ceil(PADDING + advance + PADDING);
                    var height = this.font.height;
                    characters[character] = new DynamicFontAtlasCharacter(advance, width, height, !!reserved);
                    this._length += 1;
                    this._revision += 1;
                }
            }
        };
        DynamicFontAtlas.prototype.remove_ = function (character, characters) {
            if (character !== "\n") {
                var data = characters[character];
                if (data != null) {
                    if (!data.reserved && 0 < data.ref) {
                        data.ref -= 1;
                        if (data.ref === 0) {
                            this._unrefCount += 1;
                        }
                    }
                }
            }
        };
        DynamicFontAtlas.prototype.cleanup_ = function () {
            if (this._length >> 1 <= this._unrefCount) {
                var characters = this._characters;
                for (var character in characters) {
                    if (characters[character].ref <= 0) {
                        delete characters[character];
                    }
                }
                this._length -= this._unrefCount;
                this._revision += 1;
                this._unrefCount = 0;
            }
        };
        DynamicFontAtlas.prototype.add = function (targets, reserved) {
            var characters = this._characters;
            var iterator = UtilCharacterIterator.from(targets);
            while (iterator.hasNext()) {
                this.add_(iterator.next(), characters, reserved);
            }
        };
        DynamicFontAtlas.prototype.remove = function (targets) {
            var characters = this._characters;
            var iterator = UtilCharacterIterator.from(targets);
            while (iterator.hasNext()) {
                this.remove_(iterator.next(), characters);
            }
        };
        DynamicFontAtlas.prototype.get = function (character) {
            return this._characters[character];
        };
        DynamicFontAtlas.prototype.getAdvance = function (target) {
            var context = this.getContext();
            if (context != null) {
                return context.measureText(target).width;
            }
            return 0;
        };
        DynamicFontAtlas.prototype.getContext = function () {
            var context = this._context;
            if (context == null) {
                var canvas = this._canvas;
                if (canvas != null) {
                    context = this._context = canvas.getContext("2d", { alpha: true });
                    if (context == null) {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
            var font = this._font;
            if (context.font !== font.id) {
                context.font = font.id;
                font.id = context.font;
                context.textAlign = "left";
                context.textBaseline = "alphabetic";
                context.lineWidth = 0;
                context.lineCap = "round";
                context.lineJoin = "miter";
                context.miterLimit = 0;
                context.fillStyle = font.color;
                context.strokeStyle = "#0000ff";
            }
            return context;
        };
        DynamicFontAtlas.prototype.update = function () {
            this.cleanup_();
            if (this._revisionUpdated < this._revision) {
                this._revisionUpdated = this._revision;
                var canvas = this._canvas;
                if (canvas != null) {
                    var font = this._font;
                    var fontHeight = font.height;
                    var characters = this._characters;
                    var width = (this._width = this.toPowerOf2(Math.ceil(Math.sqrt(this._length)) * fontHeight));
                    var offsetX = PADDING;
                    var offsetY = Math.round((fontHeight - (font.ascent + font.descent)) * 0.5 + font.ascent);
                    var x = 0;
                    var y = 0;
                    for (var key in characters) {
                        var character = characters[key];
                        if (width <= x + character.width) {
                            x = 0;
                            y += fontHeight;
                        }
                        character.x = x;
                        character.y = y;
                        character.origin.x = x + offsetX;
                        character.origin.y = y + offsetY;
                        x += character.width;
                    }
                    var height = (this._height = y + fontHeight);
                    // Make a input canvas
                    // Here, we need to reset the context because
                    // context settings will be lost when we set the width/height.
                    var baseTexture = this._texture.baseTexture;
                    var resolution = baseTexture.resolution;
                    var realWidth = Math.ceil(width * resolution);
                    var realHeight = Math.ceil(height * resolution);
                    canvas.width = realWidth;
                    canvas.height = realHeight;
                    var context = this.getContext();
                    if (context != null) {
                        context.save();
                        context.scale(resolution, resolution);
                        context.clearRect(0, 0, width, height);
                        for (var key in characters) {
                            var character = characters[key];
                            context.fillText(key, character.origin.x, character.origin.y);
                        }
                        context.restore();
                    }
                    baseTexture.setRealSize(realWidth, realHeight);
                    return true;
                }
            }
            return false;
        };
        DynamicFontAtlas.prototype.getRevision = function () {
            return this._revision;
        };
        DynamicFontAtlas.prototype.getRevisionUpdate = function () {
            return this._revisionUpdated;
        };
        Object.defineProperty(DynamicFontAtlas.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: false,
            configurable: true
        });
        DynamicFontAtlas.prototype.destroy = function () {
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            var characters = this._characters;
            for (var character in characters) {
                delete characters[character];
            }
        };
        DynamicFontAtlas.prototype.toPowerOf2 = function (size) {
            var result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        };
        return DynamicFontAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var update = function (atlas) {
        atlas.update();
    };
    var updateAll = function (colorToAltas) {
        colorToAltas.forEach(update);
    };
    var destroy = function (atlas) {
        atlas.update();
    };
    var destroyAll = function (colorToAltas) {
        colorToAltas.forEach(destroy);
    };
    var DynamicFontAtlases = /** @class */ (function () {
        function DynamicFontAtlases(layer) {
            var _this = this;
            this._atlases = new Map();
            this._resolution = layer.renderer.resolution;
            layer.renderer.on("prerender", function () {
                _this.update();
            });
        }
        DynamicFontAtlases.prototype.add = function (fontId, fontSize, fontColor, targets) {
            var atlases = this._atlases;
            var colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                colorToAtlas = new Map();
                atlases.set(fontId, colorToAtlas);
            }
            var atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                atlas = new DynamicFontAtlas(fontId, fontSize, fontColor, this._resolution);
                colorToAtlas.set(fontColor, atlas);
            }
            atlas.add(targets);
        };
        DynamicFontAtlases.prototype.remove = function (fontId, fontColor, targets) {
            var colorToAtlas = this._atlases.get(fontId);
            if (colorToAtlas != null) {
                var atlas = colorToAtlas.get(fontColor);
                if (atlas != null) {
                    atlas.remove(targets);
                }
            }
        };
        DynamicFontAtlases.prototype.get = function (fontId, fontColor) {
            var atlases = this._atlases;
            var colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                return null;
            }
            var atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                return null;
            }
            return atlas;
        };
        DynamicFontAtlases.prototype.update = function () {
            this._atlases.forEach(updateAll);
        };
        DynamicFontAtlases.prototype.destroy = function () {
            var atlases = this._atlases;
            atlases.forEach(destroyAll);
            atlases.clear();
        };
        return DynamicFontAtlases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var Lazy = /** @class */ (function () {
        function Lazy(newInstance, options, base) {
            var _this = this;
            this.instance = null;
            this.newInstance = newInstance;
            this.options = options;
            if (base != null) {
                if (base.state.isActive) {
                    setTimeout(function () {
                        _this.get();
                    }, 0);
                }
                base.on("active", function () {
                    _this.get();
                });
            }
        }
        Lazy.prototype.get = function () {
            var result = this.instance;
            if (result == null) {
                result = new this.newInstance(this.options);
                this.instance = result;
            }
            return result;
        };
        return Lazy;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Returns a ceiling index of the given value.
     * The array must be sorted in an ascending order.
     *
     * @param array an array sorted in an ascending order
     * @param value a value to be searched
     * @returns a ceiling index of the given value
     */
    var toCeilingIndex = function (array, value, size, offset) {
        var i0 = 0;
        var i1 = Math.floor(array.length / size) - 1;
        while (i0 <= i1) {
            var i2 = i0 + ((i1 - i0) >> 1);
            var v2 = array[i2 * size + offset];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return Math.max(i0, i1);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLabel = function (target) {
        if (target != null) {
            if (isString(target)) {
                return target;
            }
            else if (isNumber(target)) {
                return String(target);
            }
            else if ("name" in target) {
                return target.name;
            }
            else if ("label" in target) {
                return target.label;
            }
            else if ("id" in target) {
                return target.id;
            }
        }
        return "";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toString = function (value) {
        return value != null ? String(value) : "";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSvgTexture = function (svg, resolution) {
        return pixi_js.Texture.from(toSvgUrl(svg), {
            resolution: resolution
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilSvgAtlasBuilder = /** @class */ (function () {
        function UtilSvgAtlasBuilder(width, ratio, margin) {
            this._width = width;
            this._ratio = ratio;
            this._margin = margin;
            this._frames = {};
            this._svg = "";
            this._nextX = 0;
            this._nextY = 0;
            this._height = 0;
        }
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "ratio", {
            get: function () {
                return this._ratio;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: false,
            configurable: true
        });
        UtilSvgAtlasBuilder.prototype.add = function (name, width, height, path) {
            var frames = this._frames;
            if (!(name in frames)) {
                // Position
                var margin = this._margin;
                var x = this._nextX;
                var y = this._nextY;
                if (this._width <= x + width) {
                    x = 0;
                    y = this._nextY + this._height + margin;
                    this._height = height;
                    this._nextY = y;
                }
                else {
                    this._height = Math.max(this._height, height);
                }
                this._nextX = x + width + margin;
                // Frame
                frames[name] = new pixi_js.Rectangle(x, y, width, height);
                // Svg
                var ratio = this._ratio;
                this._svg += "<g transform=\"translate(" + x * ratio + "," + y * ratio + ")\">" + path + "</g>";
                return true;
            }
            return false;
        };
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "mappings", {
            get: function () {
                return this.build();
            },
            enumerable: false,
            configurable: true
        });
        UtilSvgAtlasBuilder.prototype.build = function (options) {
            var _a, _b, _c;
            var built = this._built;
            if (built == null || (options === null || options === void 0 ? void 0 : options.force)) {
                var resolution = (_b = (_a = options === null || options === void 0 ? void 0 : options.resolution) !== null && _a !== void 0 ? _a : window.devicePixelRatio) !== null && _b !== void 0 ? _b : 1;
                var width = this._width;
                var height = Math.pow(2, Math.ceil(Math.log(this._nextY + this._height) / Math.LN2));
                var realWidth = width * resolution;
                var realHeight = height * resolution;
                var ratio = this._ratio;
                var attrWidth = "width=\"" + realWidth + "\"";
                var attrHeight = "height=\"" + realHeight + "\"";
                var attrViewBox = "viewBox=\"0 0 " + width * ratio + " " + height * ratio + "\"";
                var attrXmlns = "xmlns=\"http://www.w3.org/2000/svg\"";
                var url = toSvgUrl("<svg " + attrWidth + " " + attrHeight + " " + attrViewBox + " " + attrXmlns + ">" + this._svg + "</svg>");
                var scaleMode = (_c = options === null || options === void 0 ? void 0 : options.scaling) !== null && _c !== void 0 ? _c : pixi_js.SCALE_MODES.NEAREST;
                var baseTexture = pixi_js.BaseTexture.from(url, {
                    resolution: resolution,
                    scaleMode: scaleMode
                });
                var frames_1 = this._frames;
                built = this._built = {};
                for (var name_1 in frames_1) {
                    built[name_1] = new pixi_js.Texture(baseTexture, frames_1[name_1]);
                }
            }
            return built;
        };
        return UtilSvgAtlasBuilder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilExtractor = /** @class */ (function () {
        function UtilExtractor() {
        }
        UtilExtractor.toTexture = function (target, resolution, clear, skipUpdateTransform) {
            var scale = target.transform.scale;
            var result = pixi_js.RenderTexture.create({
                width: target.width * scale.x,
                height: target.height * scale.y,
                scaleMode: pixi_js.SCALE_MODES.LINEAR,
                resolution: resolution
            });
            var matrix = new pixi_js.Matrix(undefined, undefined, undefined, undefined, -target.position.x, -target.position.y);
            var layer = DApplications.getLayer(target);
            if (layer) {
                layer.renderer.render(target, result, clear, matrix, skipUpdateTransform);
            }
            return result;
        };
        UtilExtractor.toPixels = function (renderTexture, renderer) {
            var resolution = renderTexture.resolution;
            var frame = renderTexture.frame;
            var width = Math.floor(frame.width * resolution);
            var height = Math.floor(frame.height * resolution);
            var pixels = new Uint8Array(4 * width * height);
            renderer.renderTexture.bind(renderTexture);
            var gl = renderer.gl;
            gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            return {
                width: width,
                height: height,
                array: pixels
            };
        };
        UtilExtractor.toCanvas = function (pixels, scale, ignorePremutipliedAlpha) {
            var width = pixels.width;
            var height = pixels.height;
            var array = pixels.array;
            var canvasRenderTarget = new pixi_js.utils.CanvasRenderTarget(width, height, 1);
            var imageData = canvasRenderTarget.context.getImageData(0, 0, width, height);
            if (ignorePremutipliedAlpha) {
                imageData.data.set(array);
            }
            else {
                pixi_js.Extract.arrayPostDivide(array, imageData.data);
            }
            canvasRenderTarget.context.putImageData(imageData, 0, 0);
            // Scale down
            if (scale != null && scale !== 1) {
                canvasRenderTarget.context.scale(scale, scale);
                canvasRenderTarget.context.drawImage(canvasRenderTarget.canvas, 0, 0);
                var scaledWidth = Math.floor(width * scale);
                var scaledHeight = Math.floor(height * scale);
                var scaledImageData = canvasRenderTarget.context.getImageData(0, 0, scaledWidth, scaledHeight);
                canvasRenderTarget.resize(scaledWidth, scaledHeight);
                canvasRenderTarget.context.putImageData(scaledImageData, 0, 0);
            }
            return canvasRenderTarget;
        };
        UtilExtractor.toBase64 = function (canvas, format, quality) {
            return canvas.toDataURL(format, quality);
        };
        return UtilExtractor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilFileDownloader = /** @class */ (function () {
        function UtilFileDownloader() {
        }
        /**
         * Downloads a file of the given name and URL.
         *
         * @param filename a file name
         * @param url a file URL
         */
        UtilFileDownloader.downloadUrl = function (filename, url) {
            var a = document.createElement("a");
            if ("download" in a) {
                a.href = url;
                a.setAttribute("download", filename);
                a.style.display = "none";
                document.body.appendChild(a);
                a.click();
                setTimeout(function () {
                    document.body.removeChild(a);
                }, 66);
            }
            else {
                if (!window.open(url)) {
                    location.href = url;
                }
            }
        };
        /**
         * Downloads a file of the given name with the given contents.
         *
         * @param filename a file name
         * @param contents file contents
         * @param insertBom false to stop the BOM insertion
         */
        UtilFileDownloader.download = function (filename, contents, insertBom) {
            var blob = new Blob(insertBom !== false ? ["\ufeff", contents] : [contents], {
                type: "text/plain"
            });
            if (window.navigator.msSaveBlob) {
                window.navigator.msSaveBlob(blob, filename);
            }
            else {
                this.downloadUrl(filename, URL.createObjectURL(blob));
            }
        };
        return UtilFileDownloader;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toResolution = function (options) {
        var _a;
        var target = options.target;
        var resolution = options.resolution;
        if (resolution != null) {
            if (isNumber(resolution)) {
                return resolution;
            }
            else {
                var scale = target.transform.scale;
                var size = Math.max(target.width * scale.x, target.height * scale.y);
                return Math.min(1, resolution.size / size);
            }
        }
        else {
            return (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        }
    };
    var toScale = function (pixels, options) {
        var scale = options.scale;
        if (scale != null) {
            if (isNumber(scale)) {
                return scale;
            }
            else {
                var size = scale.size;
                return Math.min(1, size / pixels.width, size / pixels.height);
            }
        }
    };
    var toRenderer = function (options) {
        var renderer = options.renderer;
        if (renderer) {
            return renderer;
        }
        var application = options.application;
        if (application) {
            return application.getLayerBase().renderer;
        }
        var layer = options.layer || DApplications.getLayer(options.target);
        if (layer) {
            return layer.renderer;
        }
        throw new Error("No renderer / application / layer found.");
    };
    var UtilExtract = /** @class */ (function () {
        function UtilExtract() {
        }
        UtilExtract.texture = function (options) {
            var _a;
            var target = options.target;
            var resolution = toResolution(options);
            var skipUpdateTransform = (_a = options.transform) === null || _a === void 0 ? void 0 : _a.update;
            return UtilExtractor.toTexture(target, resolution, options.clear, skipUpdateTransform);
        };
        UtilExtract.pixels = function (options) {
            var renderer = toRenderer(options);
            var texture = this.texture(options);
            try {
                return UtilExtractor.toPixels(texture, renderer);
            }
            finally {
                if (texture) {
                    texture.destroy();
                }
            }
        };
        UtilExtract.canvas = function (options) {
            var _a, _b;
            var pixels = this.pixels(options);
            var ignorePremutipliedAlpha = (_b = (_a = options.alpha) === null || _a === void 0 ? void 0 : _a.premultiplied) === null || _b === void 0 ? void 0 : _b.ignore;
            var scale = toScale(pixels, options);
            return UtilExtractor.toCanvas(pixels, scale, ignorePremutipliedAlpha);
        };
        UtilExtract.base64 = function (options) {
            var canvas = this.canvas(options);
            try {
                return UtilExtractor.toBase64(canvas.canvas, options.format, options.quality);
            }
            finally {
                if (canvas) {
                    canvas.destroy();
                }
            }
        };
        UtilExtract.file = function (options) {
            UtilFileDownloader.downloadUrl(options.filename, this.base64(options));
        };
        return UtilExtract;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An output format.
     */
    var UtilFileAs;
    (function (UtilFileAs) {
        UtilFileAs[UtilFileAs["TEXT"] = 0] = "TEXT";
        UtilFileAs[UtilFileAs["DATA_URL"] = 1] = "DATA_URL";
        UtilFileAs[UtilFileAs["BINARY_STRING"] = 2] = "BINARY_STRING";
        UtilFileAs[UtilFileAs["ARRAY_BUTTER"] = 3] = "ARRAY_BUTTER";
        UtilFileAs[UtilFileAs["FILE"] = 4] = "FILE";
    })(UtilFileAs || (UtilFileAs = {}));
    /**
     * An utility class for opening files.
     */
    var UtilFileOpener = /** @class */ (function () {
        function UtilFileOpener(as, facade) {
            this._input = null;
            this._as = as;
            this._facade = facade;
        }
        UtilFileOpener.prototype.open = function () {
            var input = this.getOrCreateInput();
            if (input != null) {
                input.click();
            }
            else {
                this.onCancel();
            }
        };
        UtilFileOpener.prototype.getOrCreateInput = function () {
            var _this = this;
            if ("FileReader" in window && this._input == null) {
                var input_1 = document.createElement("input");
                this._input = input_1;
                input_1.setAttribute("type", "file");
                input_1.setAttribute("style", "display:none");
                input_1.addEventListener("change", function (e) {
                    _this.onInputChange(input_1);
                    input_1.value = "";
                    e.stopImmediatePropagation();
                    e.preventDefault();
                });
                document.body.appendChild(input_1);
            }
            return this._input;
        };
        UtilFileOpener.prototype.onInputChange = function (input) {
            var _this = this;
            var files = input.files;
            if (files != null && 0 < files.length) {
                var file_1 = files[0];
                if (this._as === UtilFileAs.FILE) {
                    this.onOpen(file_1, file_1);
                }
                else {
                    var fileReader = new FileReader();
                    fileReader.onload = function (e) {
                        if (e.target != null) {
                            var target = e.target;
                            _this.onOpen(target.result, file_1);
                        }
                    };
                    fileReader.onabort = function (e) {
                        _this.onAboart(e);
                    };
                    switch (this._as) {
                        case UtilFileAs.TEXT:
                            fileReader.readAsText(file_1);
                            break;
                        case UtilFileAs.DATA_URL:
                            fileReader.readAsDataURL(file_1);
                            break;
                        case UtilFileAs.BINARY_STRING:
                            fileReader.readAsBinaryString(file_1);
                            break;
                        case UtilFileAs.ARRAY_BUTTER:
                            fileReader.readAsArrayBuffer(file_1);
                            break;
                        default:
                            fileReader.readAsText(file_1);
                            break;
                    }
                }
            }
            else {
                this.onCancel();
            }
        };
        UtilFileOpener.prototype.onOpen = function (result, file) {
            var facade = this._facade;
            facade.emit("open", result, file, facade);
        };
        UtilFileOpener.prototype.onAboart = function (e) {
            var facade = this._facade;
            facade.emit("abort", e, facade);
        };
        UtilFileOpener.prototype.onCancel = function () {
            var facade = this._facade;
            facade.emit("cancel", facade);
        };
        return UtilFileOpener;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHsv = /** @class */ (function () {
        function UtilHsv() {
        }
        /**
         * Returns HSV colors.
         * Ranges of components are:
         *
         * * H: [0, 360)
         * * S: [0, 255]
         * * V: [0, 255]
         *
         * @param color a rgb color
         * @return an array of hsv components
         */
        UtilHsv.fromRgb = function (color) {
            var r = (color & 0xff0000) >> 16;
            var g = (color & 0x00ff00) >> 8;
            var b = (color & 0x0000ff) | 0;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var length = max - min;
            var h = 0;
            if (0 < length) {
                if (r === max) {
                    h = (60 * (g - b)) / length;
                }
                else if (g === max) {
                    h = (60 * (b - r)) / length + 120;
                }
                else if (b === max) {
                    h = (60 * (r - g)) / length + 240;
                }
                if (h < 0) {
                    h += 360;
                }
            }
            var s = (length / max) * 255;
            var v = max;
            return [h, s, v];
        };
        UtilHsv.toRgb = function (h, s, v) {
            var max = v;
            var min = v - (s / 255) * v;
            var length = max - min;
            var r = 0;
            var g = 0;
            var b = 0;
            if (h <= 60) {
                r = max;
                g = (h / 60) * length + min;
                b = min;
            }
            else if (h <= 120) {
                r = ((120 - h) / 60) * length + min;
                g = max;
                b = min;
            }
            else if (h <= 180) {
                r = min;
                g = max;
                b = ((h - 120) / 60) * length + min;
            }
            else if (h <= 240) {
                r = min;
                g = ((240 - h) / 60) * length + min;
                b = max;
            }
            else if (h <= 300) {
                r = ((h - 240) / 60) * length + min;
                g = min;
                b = max;
            }
            else {
                r = max;
                g = min;
                b = ((360 - h) / 60) * length + min;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            return (r << 16) | (g << 8) | b;
        };
        return UtilHsv;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilName = /** @class */ (function () {
        function UtilName() {
        }
        UtilName.create = function (type) {
            var mapping = this._mapping;
            if (type in mapping) {
                return type + " " + ++mapping[type];
            }
            else {
                mapping[type] = 1;
                return type + " 1";
            }
        };
        UtilName._mapping = {};
        return UtilName;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilRgba = /** @class */ (function () {
        function UtilRgba() {
        }
        UtilRgba.toCode = function (color, alpha) {
            var r = (color >> 16) & 0xff;
            var g = (color >> 8) & 0xff;
            var b = color & 0xff;
            return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
        };
        return UtilRgba;
    }());

    var UtilStateBlinker = /** @class */ (function () {
        function UtilStateBlinker(state, delay, interval) {
            var _this = this;
            this._isOn = true;
            this._targets = new Set();
            this._state = state;
            this._delay = delay;
            this._interval = interval;
            this._timeout = null;
            var updateBound = function () {
                _this.advance();
                _this.update();
                _this._timeout = window.setTimeout(updateBound, interval);
            };
            this._updateBound = updateBound;
        }
        UtilStateBlinker.prototype.start = function () {
            if (this._timeout == null) {
                this._timeout = window.setTimeout(this._updateBound, this._delay);
            }
            return this;
        };
        UtilStateBlinker.prototype.stop = function () {
            var timeout = this._timeout;
            if (timeout != null) {
                this._timeout = null;
                clearTimeout(timeout);
            }
            return this;
        };
        UtilStateBlinker.prototype.add = function (target) {
            this._targets.add(target);
            target.state.set(this._state, this.isOn());
            return this;
        };
        UtilStateBlinker.prototype.remove = function (target) {
            if (this._targets.delete(target)) {
                target.state.remove(this._state);
                return true;
            }
            return false;
        };
        UtilStateBlinker.prototype.contains = function (target) {
            return this._targets.has(target);
        };
        UtilStateBlinker.prototype.clear = function () {
            this._targets.clear();
            return this;
        };
        UtilStateBlinker.prototype.isOn = function () {
            return this._isOn;
        };
        UtilStateBlinker.prototype.isOff = function () {
            return !this._isOn;
        };
        UtilStateBlinker.prototype.advance = function () {
            this._isOn = !this._isOn;
            return this;
        };
        UtilStateBlinker.prototype.update = function () {
            var isOn = this.isOn();
            var state = this._state;
            this._targets.forEach(function (target) {
                target.state.set(state, isOn);
            });
            return this;
        };
        return UtilStateBlinker;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilTexturePlane = /** @class */ (function () {
        function UtilTexturePlane() {
            this._backgroundCache = new Map();
            this._backgroundAttribute = "fill=\"#fff\" stroke=\"none\"";
            this._borderCache = new Map();
            this._borderAttribute = function (width) {
                return "fill=\"none\" stroke=\"#fff\" stroke-width=\"" + width + "\"";
            };
            this._onUpdate = function () {
                DApplications.update();
            };
        }
        UtilTexturePlane.prototype.toCornerTl = function (offset, size, tl) {
            return 0 < tl ? "A" + tl + " " + tl + " 0 0 1 " + (offset + tl) + " " + offset : "";
        };
        UtilTexturePlane.prototype.toCornerBr = function (offset, size, br) {
            return 0 < br ? "A" + br + " " + br + " 0 0 1 " + (offset + size - br) + " " + (offset + size) : "";
        };
        UtilTexturePlane.prototype.make = function (radius, offset, attr) {
            var realRadius = Math.max(0, radius - offset);
            var size = realRadius * 2 + 4;
            var realSize = size + offset * 2;
            var d = "M" + (offset + realRadius) + " " + offset +
                ("L" + (offset + size) + " " + offset) +
                ("L" + (offset + size) + " " + (offset + size - realRadius)) +
                this.toCornerBr(offset, size, realRadius) +
                ("L" + offset + " " + (offset + size)) +
                ("L" + offset + " " + (offset + realRadius)) +
                this.toCornerTl(offset, size, realRadius) +
                "Z";
            return this.toSvg(realSize, attr, d);
        };
        UtilTexturePlane.prototype.toSvg = function (realSize, attr, d) {
            var _a;
            var resolution = (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
            var widthAttr = "width=\"" + realSize * resolution + "\"";
            var heightAttr = "height=\"" + realSize * resolution + "\"";
            var viewBoxAttr = "viewBox=\"0 0 " + realSize + " " + realSize + "\"";
            var svg = "<svg " + widthAttr + " " + heightAttr + " " + viewBoxAttr + " xmlns=\"http://www.w3.org/2000/svg\">" +
                ("<path " + attr + " d=\"" + d + "\"></path>") +
                "</svg>";
            return pixi_js.Texture.from(toSvgUrl(svg), {
                resolution: resolution
            });
        };
        UtilTexturePlane.prototype.newBackground = function (radius) {
            var result = this.make(radius, 0, this._backgroundAttribute);
            result.on("update", this._onUpdate);
            return result;
        };
        UtilTexturePlane.prototype.newBorder = function (radius, width) {
            var result = this.make(radius, 0.5 * width, this._borderAttribute(width));
            result.on("update", this._onUpdate);
            return result;
        };
        UtilTexturePlane.prototype.getBackground = function (radius) {
            var cache = this._backgroundCache;
            var texture = cache.get(radius);
            if (texture == null) {
                texture = this.newBackground(radius);
                cache.set(radius, texture);
            }
            return texture;
        };
        UtilTexturePlane.prototype.getBorder = function (radius, width) {
            var cache = this._borderCache;
            var maskToTexture = cache.get(radius);
            if (maskToTexture == null) {
                maskToTexture = new Map();
                cache.set(radius, maskToTexture);
            }
            var texture = maskToTexture.get(width);
            if (texture == null) {
                texture = this.newBorder(radius, width);
                maskToTexture.set(width, texture);
            }
            return texture;
        };
        UtilTexturePlane.getInstance = function () {
            if (UtilTexturePlane.INSTANCE == null) {
                UtilTexturePlane.INSTANCE = new UtilTexturePlane();
            }
            return UtilTexturePlane.INSTANCE;
        };
        UtilTexturePlane.INSTANCE = null;
        return UtilTexturePlane;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilTransition = /** @class */ (function () {
        function UtilTransition(options) {
            var _a;
            this._duration = (_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : 300;
            this._current = null;
            this._lastUpdate = 0;
            this._updateId = null;
        }
        UtilTransition.prototype.show = function (next, forcibly) {
            var _this = this;
            var updateId = this._updateId;
            if (updateId != null) {
                clearTimeout(updateId);
            }
            var current = this._current;
            if (next !== current) {
                var duration = this._duration;
                var lastUpdate = this._lastUpdate;
                var now = Date.now();
                var remaining = lastUpdate + duration - now;
                if (forcibly === true || remaining <= 0) {
                    this.update(now, next);
                }
                else {
                    this._updateId = window.setTimeout(function () {
                        _this.update(Date.now(), next);
                    }, remaining);
                }
            }
        };
        UtilTransition.prototype.update = function (now, next) {
            var current = this._current;
            if (current !== next) {
                this._lastUpdate = now;
                if (current !== null) {
                    current.hide();
                }
                this._current = next;
                if (next != null) {
                    next.show();
                }
            }
        };
        UtilTransition.prototype.hide = function () {
            this.show(null);
        };
        return UtilTransition;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /*!
     * jQuery Mousewheel 3.1.13
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * See also https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
     * and https://github.com/openlayers/openlayers/blob/v5.2.0/src/ol/interaction/MouseWheelZoom.js#L51
     */
    var UtilWheelEvent = /** @class */ (function () {
        function UtilWheelEvent() {
            this._lowest = null;
            this._timestamp = 0;
            this._lineHeight = null;
            this._pageHeight = null;
        }
        UtilWheelEvent.prototype.getNames = function () {
            var result = this._names;
            if (result == null) {
                if ("onwheel" in document || 9 <= document.documentMode) {
                    result = ["wheel"];
                }
                else {
                    result = ["mousewheel", "DOMMouseScroll", "MozMousePixelScroll"];
                }
                this._names = result;
            }
            return result;
        };
        UtilWheelEvent.prototype.on = function (target, handler, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var names = this.getNames();
            for (var i = names.length - 1; 0 <= i; --i) {
                var name_1 = names[i];
                target.addEventListener(name_1, handler, useCapture);
            }
        };
        UtilWheelEvent.prototype.off = function (target, handler, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var names = this.getNames();
            for (var i = names.length - 1; 0 <= i; --i) {
                var name_2 = names[i];
                target.removeEventListener(name_2, handler, useCapture);
            }
        };
        UtilWheelEvent.prototype.getLineHeight = function () {
            if (this._lineHeight == null) {
                var theme = DThemes.getInstance().get("DBase");
                this._lineHeight = theme.getLineHeight();
            }
            return this._lineHeight;
        };
        UtilWheelEvent.prototype.getPageHeight = function () {
            if (this._pageHeight == null) {
                this._pageHeight = this.getLineHeight() * 12;
            }
            return this._pageHeight;
        };
        UtilWheelEvent.prototype.normalize = function (e) {
            var deltaX = 0;
            var deltaY = 0;
            // Old school scrollwheel delta
            if ("detail" in e) {
                deltaY = e.detail * -1;
            }
            if ("wheelDelta" in e) {
                deltaY = e.wheelDelta;
            }
            if ("wheelDeltaY" in e) {
                deltaY = e.wheelDeltaY;
            }
            if ("wheelDeltaX" in e) {
                deltaX = e.wheelDeltaX * -1;
            }
            // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
            if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
                deltaX = deltaY * -1;
                deltaY = 0;
            }
            // New school wheel delta (wheel event)
            if ("deltaY" in e) {
                deltaY = e.deltaY * -1;
            }
            if ("deltaX" in e) {
                deltaX = e.deltaX;
            }
            // No change actually happened, no reason to go any further
            if (deltaY === 0 && deltaX === 0) {
                return null;
            }
            // Store lowest absolute delta to normalize the delta values
            var delta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
            // Reset the this._lowest to better handle multiple device types
            // that give different a different lowestDelta
            // Ex: trackpad = 3 and mouse wheel = 120
            var now = Date.now();
            if (this._timestamp + 200 <= now) {
                this._lowest = null;
            }
            this._timestamp = now;
            //
            var shouldAdjust = e.type === "mousewheel" && delta % 120 === 0;
            if (!this._lowest || delta < this._lowest) {
                this._lowest = delta;
                // Adjust older deltas if necessary
                if (shouldAdjust) {
                    this._lowest /= 40;
                }
            }
            // Adjust older deltas if necessary
            if (shouldAdjust) {
                // Divide all the things by 40!
                delta /= 40;
                deltaX /= 40;
                deltaY /= 40;
            }
            // Get a whole, normalized value for the deltas
            var lowest = this._lowest;
            delta = Math.floor(delta / lowest);
            deltaX = Math[1 <= deltaX ? "floor" : "ceil"](deltaX / lowest);
            deltaY = Math[1 <= deltaY ? "floor" : "ceil"](deltaY / lowest);
            // Mode
            var mode = e.deltaMode || 0;
            if (mode !== 0) {
                var scale = mode === 1 ? this.getLineHeight() : this.getPageHeight();
                delta *= scale;
                deltaX *= scale;
                deltaY *= scale;
            }
            return {
                mode: mode,
                delta: delta,
                deltaX: deltaX,
                deltaY: deltaY,
                lowest: lowest
            };
        };
        UtilWheelEvent.getInstance = function () {
            if (this.INSTANCE == null) {
                this.INSTANCE = new UtilWheelEvent();
            }
            return this.INSTANCE;
        };
        return UtilWheelEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationEmpty = /** @class */ (function (_super) {
        __extends(DAnimationEmpty, _super);
        function DAnimationEmpty(options) {
            var _a;
            var _this = _super.call(this) || this;
            _this._target = (_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : null;
            _this._reverse = false;
            _this._isStarted = false;
            _this._onTime = options === null || options === void 0 ? void 0 : options.onTime;
            _this._onStart = options === null || options === void 0 ? void 0 : options.onStart;
            _this._onEnd = options === null || options === void 0 ? void 0 : options.onEnd;
            return _this;
        }
        Object.defineProperty(DAnimationEmpty.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DAnimationEmpty.prototype, "duration", {
            get: function () {
                return 0;
            },
            set: function (duration) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        DAnimationEmpty.prototype.start = function (reverse) {
            if (reverse === void 0) { reverse = false; }
            this.stop();
            this._isStarted = true;
            this._reverse = reverse;
            // onStart
            this.onStart(reverse);
            if (!this._isStarted) {
                return;
            }
            // onTime
            this.onTime(reverse ? 1 : 0, reverse, 0);
            if (!this._isStarted) {
                return;
            }
            this.onTime(reverse ? 0 : 1, reverse, 0);
            if (this._isStarted) {
                return;
            }
            // OnEnd
            this.onEnd(reverse);
        };
        DAnimationEmpty.prototype.onStart = function (isReverse) {
            var onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        };
        DAnimationEmpty.prototype.onTime = function (time, isReverse, elapsedTime) {
            var onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        };
        DAnimationEmpty.prototype.onEnd = function (isReverse) {
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        };
        DAnimationEmpty.prototype.isStarted = function () {
            return this._isStarted;
        };
        DAnimationEmpty.prototype.isReverse = function () {
            return this._reverse;
        };
        DAnimationEmpty.prototype.stop = function () {
            this._isStarted = false;
        };
        DAnimationEmpty.prototype.end = function () {
            var isStarted = this._isStarted;
            if (isStarted) {
                this._isStarted = false;
                // OnTime
                var reverse = this._reverse;
                var time = reverse ? 0 : 1;
                this.onTime(time, reverse, 0);
                // OnEnd
                this.onEnd(reverse);
            }
        };
        return DAnimationEmpty;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplicationPadding = /** @class */ (function () {
        function DApplicationPadding(padding) {
            var _a, _b, _c, _d;
            if (isNumber(padding)) {
                this.top = padding;
                this.right = padding;
                this.bottom = padding;
                this.left = padding;
            }
            else if (padding != null) {
                this.top = (_a = padding.top) !== null && _a !== void 0 ? _a : 6;
                this.right = (_b = padding.right) !== null && _b !== void 0 ? _b : 6;
                this.bottom = (_c = padding.bottom) !== null && _c !== void 0 ? _c : 6;
                this.left = (_d = padding.left) !== null && _d !== void 0 ? _d : 6;
            }
            else {
                this.top = 6;
                this.right = 6;
                this.bottom = 6;
                this.left = 6;
            }
        }
        DApplicationPadding.prototype.getTheme = function () {
            throw new Error("Not supported");
        };
        DApplicationPadding.prototype.setTheme = function (theme) {
            throw new Error("Not supported");
        };
        DApplicationPadding.prototype.getTop = function () {
            return this.left;
        };
        DApplicationPadding.prototype.getRight = function () {
            return this.right;
        };
        DApplicationPadding.prototype.getBottom = function () {
            return this.bottom;
        };
        DApplicationPadding.prototype.getLeft = function () {
            return this.left;
        };
        DApplicationPadding.prototype.set = function (top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
        };
        return DApplicationPadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * DApplicationLayer options
     */
    var DApplicationLayerOptions = /** @class */ (function () {
        function DApplicationLayerOptions(options) {
            var _a;
            // Root
            var root = options.root;
            this._root = root;
            // Overlay mode or not
            this._overlay = options.overlay;
            // Padding
            this._padding = new DApplicationPadding(options === null || options === void 0 ? void 0 : options.padding);
            // Width & height
            var width = 100;
            var height = 100;
            if (options) {
                if (options.width != null) {
                    width = options.width;
                    if (options.height != null) {
                        height = options.height;
                    }
                    else {
                        height = root.getBoundingClientRect().height;
                    }
                }
                else if (options.height != null) {
                    width = root.getBoundingClientRect().width;
                    height = options.height;
                }
                else {
                    var bbox = root.getBoundingClientRect();
                    width = bbox.width;
                    height = bbox.height;
                }
            }
            else {
                var bbox = root.getBoundingClientRect();
                width = bbox.width;
                height = bbox.height;
            }
            // Background color
            var background = options === null || options === void 0 ? void 0 : options.background;
            var backgroundColor = 0;
            var transparent = true;
            if (background != null) {
                var color = background.color;
                if (color != null) {
                    backgroundColor = color;
                    transparent = false;
                }
            }
            // Resolution
            var resolution = options.resolution;
            // Antialias
            var antialias = (_a = options === null || options === void 0 ? void 0 : options.antialias) !== null && _a !== void 0 ? _a : false;
            // Pixi
            this._pixi = {
                width: width,
                height: height,
                autoStart: false,
                backgroundColor: backgroundColor,
                transparent: transparent,
                resolution: resolution,
                antialias: antialias
            };
        }
        /**
         * Returns a root element.
         * `HTMLCanvasElement` and other DOM elements are created in this element.
         * The default root element is `document.body`.
         */
        DApplicationLayerOptions.prototype.getRootElement = function () {
            return this._root;
        };
        /**
         * Sets a root element and updates the canvas width and height
         * if `updateWidthAndHeight` is not false.
         *
         * @param root new root element
         * @param updateWidthAndHeight false to preserve the canvas width / height
         */
        DApplicationLayerOptions.prototype.setRootElement = function (root, updateWidthAndHeight) {
            if (this._root !== root) {
                this._root = root;
                if (updateWidthAndHeight !== false) {
                    var bbox = root.getBoundingClientRect();
                    var pixi = this._pixi;
                    pixi.width = bbox.width;
                    pixi.height = bbox.height;
                }
            }
            return this;
        };
        /**
         * Returns a canvas width.
         */
        DApplicationLayerOptions.prototype.getWidth = function () {
            return this._pixi.width;
        };
        /**
         * Sets a canvas width.
         *
         * @param width new canvas width
         */
        DApplicationLayerOptions.prototype.setWidth = function (width) {
            this._pixi.width = width;
            return this;
        };
        /**
         * Returns a canvas height.
         */
        DApplicationLayerOptions.prototype.getHeight = function () {
            return this._pixi.height;
        };
        /**
         * Sets a canvas height.
         *
         * @param height new canvas height
         */
        DApplicationLayerOptions.prototype.setHeight = function (height) {
            this._pixi.height = height;
            return this;
        };
        /**
         * Returns padding sizes.
         * The default padding size is 6.
         */
        DApplicationLayerOptions.prototype.getPadding = function () {
            return this._padding;
        };
        /**
         * Sets padding sizes.
         *
         * @param left new left padding
         * @param top new top padding
         * @param right new right padding
         * @param bottom new bottom padding
         */
        DApplicationLayerOptions.prototype.setPadding = function (left, top, right, bottom) {
            var padding = this._padding;
            padding.left = left;
            padding.top = top;
            padding.right = right;
            padding.bottom = bottom;
            return this;
        };
        /**
         * Returns a background color.
         */
        DApplicationLayerOptions.prototype.getBackgroundColor = function () {
            return this._pixi.backgroundColor;
        };
        /**
         * Sets a background color.
         *
         * @param color new background color
         */
        DApplicationLayerOptions.prototype.setBackgroundColor = function (color) {
            this._pixi.backgroundColor = color;
            return this;
        };
        /**
         * Returns an antialias setting.
         * The default antialias setting is false.
         */
        DApplicationLayerOptions.prototype.getAntialias = function () {
            return this._pixi.antialias;
        };
        /**
         * Sets an antialias setting.
         *
         * @param antialias new antialias setting
         */
        DApplicationLayerOptions.prototype.setAntialias = function (antialias) {
            this._pixi.antialias = antialias;
            return this;
        };
        /**
         * Returns true if a layer is supposed to be an overlay layer.
         */
        DApplicationLayerOptions.prototype.isOverlay = function () {
            return this._overlay;
        };
        DApplicationLayerOptions.prototype.getPixiApplicationOptions = function () {
            return this._pixi;
        };
        return DApplicationLayerOptions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllerDefaultFocus = /** @class */ (function () {
        function DControllerDefaultFocus() {
            this._focused = null;
        }
        DControllerDefaultFocus.prototype.focus = function (focusable) {
            var previous = this._focused;
            if (previous !== focusable) {
                if (previous != null) {
                    previous.state.isFocused = false;
                }
                this._focused = focusable;
                if (this.isFocusable(focusable)) {
                    focusable.state.isFocused = true;
                }
                return previous;
            }
            return null;
        };
        DControllerDefaultFocus.prototype.blur = function (focusable) {
            if (focusable != null && this._focused === focusable) {
                this._focused = null;
                focusable.state.isFocused = false;
                return focusable;
            }
            return null;
        };
        DControllerDefaultFocus.prototype.clear = function () {
            return this.focus(null);
        };
        DControllerDefaultFocus.prototype.set = function (focusable, isFocused) {
            if (isFocused) {
                return this.focus(focusable);
            }
            else {
                return this.blur(focusable);
            }
        };
        DControllerDefaultFocus.prototype.get = function () {
            return this._focused;
        };
        DControllerDefaultFocus.prototype.findParent = function (mightBeFocusable) {
            var current = mightBeFocusable;
            while (current != null) {
                if (this.isFocusable(current)) {
                    return current;
                }
                else {
                    current = current.parent;
                }
            }
            return null;
        };
        DControllerDefaultFocus.prototype.find = function (target, includesTarget, includesTargetChildren, direction, root) {
            if (direction) {
                var result = this.findNext(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                var parent_1 = target.parent;
                if (parent_1 != null) {
                    var children = parent_1.children;
                    var index = children.indexOf(target);
                    if (0 <= index) {
                        var childrenLength = children.length;
                        if (this.isFocusReverse(parent_1)) {
                            for (var i = index - 1; 0 <= i; --i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_1, root)) {
                                var found = this.find(parent_1, false, false, true, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = childrenLength - 1; index <= i; --i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                        else {
                            for (var i = index + 1; i < childrenLength; ++i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_1, root)) {
                                var found = this.find(parent_1, false, false, true, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = 0; i <= index; ++i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                    }
                }
            }
            else {
                var result = this.findPrevious(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                var parent_2 = target.parent;
                if (parent_2 != null) {
                    var children = parent_2.children;
                    var index = children.indexOf(target);
                    if (0 <= index) {
                        var childrenLength = children.length;
                        if (this.isFocusReverse(parent_2)) {
                            for (var i = index + 1; i < childrenLength; ++i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_2, root)) {
                                var found = this.find(parent_2, true, false, false, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = 0; i <= index; ++i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                        else {
                            for (var i = index - 1; 0 <= i; --i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_2, root)) {
                                var found = this.find(parent_2, true, false, false, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = childrenLength - 1; index <= i; --i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                    }
                }
            }
            return null;
        };
        DControllerDefaultFocus.prototype.findNext = function (target, includesTarget, includesTargetChildren) {
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Target children
            if (includesTargetChildren && this.isFocusableContainer(target) && target.visible) {
                var children = target.children;
                var childrenLength = children.length;
                if (this.isFocusReverse(target)) {
                    for (var i = childrenLength - 1; 0 <= i; --i) {
                        var found = this.findNext(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
                else {
                    for (var i = 0; i < childrenLength; ++i) {
                        var found = this.findNext(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
            }
            // Found nothing
            return null;
        };
        DControllerDefaultFocus.prototype.findPrevious = function (target, includesTarget, includesTargetChildren) {
            // Target children
            if (includesTargetChildren && this.isFocusableContainer(target) && target.visible) {
                var children = target.children;
                var childrenLength = children.length;
                if (this.isFocusReverse(target)) {
                    for (var i = 0; i < childrenLength; ++i) {
                        var found = this.findPrevious(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
                else {
                    for (var i = childrenLength - 1; 0 <= i; --i) {
                        var found = this.findPrevious(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
            }
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Found nothing
            return null;
        };
        DControllerDefaultFocus.prototype.isFocusable = function (target) {
            return (target != null &&
                "state" in target &&
                target.state.inEnabled &&
                target.state.isFocusable &&
                target.visible);
        };
        DControllerDefaultFocus.prototype.isFocusableContainer = function (target) {
            return target != null && "children" in target;
        };
        DControllerDefaultFocus.prototype.isFocusRoot = function (target, root) {
            if (target === root) {
                return true;
            }
            return target != null && "state" in target && target.state.isFocusRoot && target.visible;
        };
        DControllerDefaultFocus.prototype.isFocusReverse = function (target) {
            return target != null && "state" in target && target.state.isFocusReverse;
        };
        return DControllerDefaultFocus;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandFlag;
    (function (DCommandFlag) {
        DCommandFlag[DCommandFlag["NONE"] = 0] = "NONE";
        /**
         * Commands with a `UNSTORABLE` flag will not be queued to the `done` queue.
         */
        DCommandFlag[DCommandFlag["UNSTORABLE"] = 1] = "UNSTORABLE";
        /**
         * Commands with a `CLEAR` flag clears the command queue.
         */
        DCommandFlag[DCommandFlag["CLEAR"] = 2] = "CLEAR";
    })(DCommandFlag || (DCommandFlag = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandClear = /** @class */ (function () {
        function DCommandClear() {
        }
        DCommandClear.prototype.execute = function () {
            return true;
        };
        DCommandClear.prototype.redo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandClear.prototype.undo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandClear.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandClear.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE | DCommandFlag.CLEAR;
        };
        return DCommandClear;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandRedo = /** @class */ (function () {
        function DCommandRedo() {
        }
        DCommandRedo.prototype.execute = function () {
            throw new Error("Not supported");
        };
        DCommandRedo.prototype.redo = function () {
            throw new Error("Not supported");
        };
        DCommandRedo.prototype.undo = function () {
            throw new Error("Not supported");
        };
        DCommandRedo.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandRedo.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE;
        };
        return DCommandRedo;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandUndo = /** @class */ (function () {
        function DCommandUndo() {
        }
        DCommandUndo.prototype.execute = function () {
            throw new Error("Not supported");
        };
        DCommandUndo.prototype.redo = function () {
            throw new Error("Not supported");
        };
        DCommandUndo.prototype.undo = function () {
            throw new Error("Not supported");
        };
        DCommandUndo.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandUndo.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE;
        };
        return DCommandUndo;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isCommandStorable = function (command) {
        return !(command.getFlag() & DCommandFlag.UNSTORABLE);
    };
    var isCommandClear = function (command) {
        return !!(command.getFlag() & DCommandFlag.CLEAR);
    };
    var DControllerDefaultCommand = /** @class */ (function (_super) {
        __extends(DControllerDefaultCommand, _super);
        function DControllerDefaultCommand() {
            var _this = _super.call(this) || this;
            _this._position = 0;
            _this._done = [];
            _this._waiting = [];
            _this._executing = null;
            return _this;
        }
        DControllerDefaultCommand.prototype.last = function () {
            var done = this._done;
            var waiting = this._waiting;
            if (waiting.length <= 0) {
                if (0 < done.length) {
                    return done[done.length - 1];
                }
                else {
                    return null;
                }
            }
            else {
                return waiting[waiting.length - 1];
            }
        };
        DControllerDefaultCommand.prototype.push = function (command) {
            var waiting = this._waiting;
            waiting.push(command);
            this.next();
        };
        DControllerDefaultCommand.prototype.next = function () {
            var _this = this;
            if (this._executing == null) {
                var waiting = this._waiting;
                if (0 < waiting.length) {
                    var command_1 = waiting.shift();
                    if (command_1 != null) {
                        if (command_1 instanceof DCommandUndo) {
                            var done = this._done;
                            if (this._position < done.length) {
                                var current = done[done.length - 1 - this._position];
                                this._position += 1;
                                this.emit("change", this);
                                var result = current.undo();
                                if (result === true) {
                                    this.onSuccess(command_1);
                                }
                                else if (result === false) {
                                    this.onFail(command_1);
                                }
                                else {
                                    this._executing = result.then(function () {
                                        _this.onSuccess(command_1);
                                    }, function () {
                                        _this.onFail(command_1);
                                    });
                                }
                            }
                        }
                        else if (command_1 instanceof DCommandRedo) {
                            var done = this._done;
                            if (0 < this._position) {
                                var current = done[done.length - this._position];
                                this._position -= 1;
                                this.emit("change", this);
                                var result = current.redo();
                                if (result === true) {
                                    this.onSuccess(command_1);
                                }
                                else if (result === false) {
                                    this.onFail(command_1);
                                }
                                else {
                                    this._executing = result.then(function () {
                                        _this.onSuccess(command_1);
                                    }, function () {
                                        _this.onFail(command_1);
                                    });
                                }
                            }
                        }
                        else {
                            var isClear = isCommandClear(command_1);
                            var isStorable = isCommandStorable(command_1);
                            if (isClear || isStorable) {
                                var size = isClear ? this._done.length : this._position;
                                if (0 < size) {
                                    this.remove(size);
                                    this._position = 0;
                                    this.emit("change", this);
                                }
                                this.cleanup();
                            }
                            var result = command_1.execute();
                            if (result === true) {
                                this.onSuccess(command_1);
                            }
                            else if (result === false) {
                                this.onFail(command_1);
                            }
                            else {
                                this._executing = result.then(function () {
                                    _this.onSuccess(command_1);
                                }, function () {
                                    _this.onFail(command_1);
                                });
                            }
                        }
                    }
                }
            }
        };
        DControllerDefaultCommand.prototype.cleanup = function () {
            var done = this._done;
            var size = done.length - 100;
            if (0 < size) {
                for (var i = 0; i < size; ++i) {
                    done[i].destroy();
                    done.shift();
                }
            }
        };
        DControllerDefaultCommand.prototype.remove = function (size) {
            var done = this._done;
            if (0 < size) {
                var ifrom = Math.max(0, done.length - size);
                size = done.length - ifrom;
                if (0 < size) {
                    for (var i = ifrom, imax = done.length; i < imax; ++i) {
                        done[i].destroy();
                    }
                    done.splice(ifrom, done.length - ifrom);
                    return true;
                }
            }
            return false;
        };
        DControllerDefaultCommand.prototype.onSuccess = function (command) {
            this._executing = null;
            if (isCommandStorable(command)) {
                this._done.push(command);
                this.emit("dirty", this);
            }
            else if (command instanceof DCommandUndo || command instanceof DCommandRedo) {
                this.emit("dirty", this);
            }
            this.emit("change", this);
            this.next();
        };
        DControllerDefaultCommand.prototype.onFail = function (command) {
            this._executing = null;
            var waiting = this._waiting;
            command.destroy();
            for (var i = 0, imax = waiting.length; i < imax; ++i) {
                waiting[i].destroy();
            }
            waiting.length = 0;
            this.emit("change", this);
        };
        DControllerDefaultCommand.prototype.size = function () {
            return this._done.length;
        };
        DControllerDefaultCommand.prototype.clear = function () {
            this.push(new DCommandClear());
        };
        DControllerDefaultCommand.prototype.redo = function () {
            if (this.isRedoable()) {
                this._waiting.push(new DCommandRedo());
                this.next();
            }
        };
        DControllerDefaultCommand.prototype.undo = function () {
            if (this.isUndoable()) {
                this._waiting.push(new DCommandUndo());
                this.next();
            }
        };
        DControllerDefaultCommand.prototype.isRedoable = function () {
            return 0 < this._position && this._executing == null;
        };
        DControllerDefaultCommand.prototype.isUndoable = function () {
            return this._position < this._done.length && this._executing == null;
        };
        return DControllerDefaultCommand;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllerKeyboard = /** @class */ (function (_super) {
        __extends(DControllerKeyboard, _super);
        function DControllerKeyboard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DControllerKeyboard.prototype.init = function (element, stage, focusController) {
            var _this = this;
            element.addEventListener("keydown", function (e) {
                _this.emit("keydown", e);
                var focused = focusController.get();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (_this.hasOnKeyDown(current)) {
                            if (current.onKeyDown(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
                if (UtilKeyboardEvent.isFocusKey(e)) {
                    var direction = UtilKeyboardEvent.getFocusDirection(e);
                    var next = focused != null
                        ? focusController.find(focused, false, focused.state.isFocusRoot || direction, direction)
                        : focusController.find(stage, false, true, direction);
                    if (next != null) {
                        focusController.focus(next);
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                }
            });
            element.addEventListener("keyup", function (e) {
                _this.emit("keyup", e);
                var focused = focusController.get();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (_this.hasOnKeyUp(current)) {
                            if (current.onKeyUp(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DControllerKeyboard.prototype.hasOnKeyDown = function (target) {
            return "onKeyDown" in target;
        };
        DControllerKeyboard.prototype.hasOnKeyUp = function (target) {
            return "onKeyUp" in target;
        };
        return DControllerKeyboard;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllers = /** @class */ (function () {
        function DControllers() {
        }
        // Keyboard
        DControllers.getKeyboardController = function () {
            if (this.KEYBOARD == null) {
                this.KEYBOARD = new DControllerKeyboard();
            }
            return this.KEYBOARD;
        };
        DControllers.setKeyboardController = function (instance) {
            var result = this.KEYBOARD;
            this.KEYBOARD = instance;
            return result;
        };
        // Command
        DControllers.getCommandController = function () {
            if (this.COMMAND == null) {
                this.COMMAND = new DControllerDefaultCommand();
            }
            return this.COMMAND;
        };
        DControllers.setCommandController = function (instance) {
            var result = this.COMMAND;
            this.COMMAND = instance;
            return result;
        };
        // Document
        DControllers.getDocumentController = function () {
            if (this.DOCUMENT == null) {
                throw new Error("Not supported");
            }
            return this.DOCUMENT;
        };
        DControllers.setDocumentController = function (instance) {
            var result = this.DOCUMENT;
            this.DOCUMENT = instance;
            return result;
        };
        return DControllers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isDblClickable = function (target) {
        return target != null && target.onDblClick != null;
    };
    var isWheelable = function (target) {
        return target != null && target.onWheel != null;
    };
    var DApplicationLayer = /** @class */ (function (_super) {
        __extends(DApplicationLayer, _super);
        function DApplicationLayer(application, options) {
            var _this = _super.call(this, options.getPixiApplicationOptions()) || this;
            _this._renderId = null;
            _this._dynamicFontAtlases = null;
            _this._options = options;
            _this._isLocked = false;
            _this._isVisible = true;
            _this._isOverlay = options.isOverlay();
            _this._padding = options.getPadding();
            _this._rootElement = options.getRootElement();
            _this._refitLimit = 5;
            _this._reflowLimit = 5;
            _this._elementContainer = _this.newElementContainer();
            _this.application = application;
            _this._renderBound = function () {
                if (_this._renderId != null) {
                    _this.render();
                }
            };
            _this.initStage();
            _this.initView();
            _this.initRootElement();
            _this.initFocusHandling();
            _this.initResizeHandling();
            _this.initWheelHandling();
            _this.initDoubleClickHandling();
            return _this;
        }
        DApplicationLayer.prototype.newElementContainer = function () {
            var result = document.createElement("div");
            result.setAttribute("style", "position: absolute; top: 0; left: 0; width: 0; height: 0;" +
                "margin: 0; padding: 0; outline: none;");
            return result;
        };
        DApplicationLayer.prototype.initStage = function () {
            var stage = this.stage;
            stage.layer = this;
            stage.application = this.application;
            stage.interactive = true;
        };
        DApplicationLayer.prototype.initView = function () {
            var view = this.view;
            var style = view.style;
            style.position = "absolute";
            style.top = "0";
            style.left = "0";
            style.width = "100%";
            style.height = "100%";
            style.display = "block";
            style.outline = "none";
        };
        DApplicationLayer.prototype.initRootElement = function () {
            var _this = this;
            var view = this.view;
            var isOverlay = this._isOverlay;
            var rootElement = this._rootElement;
            var elementContainer = this._elementContainer;
            // Insert elements
            var insertionPosition = isOverlay ? 2 : 0;
            var children = rootElement.children;
            if (insertionPosition < children.length) {
                var child = children[insertionPosition];
                rootElement.insertBefore(view, child);
                rootElement.insertBefore(elementContainer, child);
            }
            else {
                rootElement.appendChild(view);
                rootElement.appendChild(elementContainer);
            }
            if (isOverlay) {
                var stage_1 = this.stage;
                var oldOnChildrenChange_1 = stage_1.onChildrenChange;
                stage_1.onChildrenChange = function () {
                    _this.onStageDirty();
                    oldOnChildrenChange_1.call(stage_1);
                };
            }
            // Init styles
            var rootElementStyle = rootElement.style;
            if (rootElement !== document.body) {
                var rootElementStylePosition = window.getComputedStyle(rootElement).position;
                if (rootElementStylePosition === "static") {
                    rootElementStyle.position = "relative";
                }
            }
            rootElementStyle.margin = "0";
            rootElementStyle.padding = "0";
            rootElementStyle.overflow = "hidden";
        };
        DApplicationLayer.prototype.initFocusHandling = function () {
            var view = this.view;
            var stage = this.stage;
            var rootElement = this._rootElement;
            var focusController = this.getFocusController();
            var hasFocus = false;
            var onFocus = function () {
                hasFocus = true;
            };
            var onBlured = function () {
                if (!hasFocus) {
                    focusController.clear();
                }
            };
            var onBlur = function () {
                hasFocus = false;
                setTimeout(onBlured, 0);
            };
            rootElement.addEventListener("focus", onFocus, true);
            rootElement.addEventListener("blur", onBlur, true);
            view.setAttribute("tabindex", "0");
            DControllers.getKeyboardController().init(view, stage, focusController);
            var interactionManager = this.renderer.plugins.interaction;
            interactionManager.on(UtilPointerEvent.down, function (e) {
                if (e.target == null || e.target === stage) {
                    focusController.clear();
                }
            });
        };
        DApplicationLayer.prototype.initResizeHandling = function () {
            var _this = this;
            var onResizeBound = function () {
                _this.onResize();
            };
            window.addEventListener("resize", onResizeBound);
            window.addEventListener("orientationchange", onResizeBound);
        };
        DApplicationLayer.prototype.onResize = function () {
            var bbox = this._rootElement.getBoundingClientRect();
            var bboxWidth = bbox.width;
            var bboxHeight = bbox.height;
            this.renderer.resize(bboxWidth, bboxHeight);
            var padding = this._padding;
            var children = this.stage.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(bboxWidth, bboxHeight, padding);
                }
            }
            this.update();
        };
        DApplicationLayer.prototype.initWheelHandling = function () {
            var global = new pixi_js.Point();
            var util = UtilWheelEvent.getInstance();
            var interactionManager = this.renderer.plugins.interaction;
            util.on(this.view, function (e) {
                var wheelEvent = e;
                UtilPointerEvent.toGlobal(wheelEvent, interactionManager, global);
                var current = interactionManager.hitTest(global);
                var deltas = util.normalize(e);
                if (deltas != null) {
                    while (current != null) {
                        if (isWheelable(current)) {
                            if (current.onWheel(wheelEvent, deltas, global)) {
                                wheelEvent.preventDefault();
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DApplicationLayer.prototype.initDoubleClickHandling = function () {
            var focusController = this.getFocusController();
            var interactionManager = this.renderer.plugins.interaction;
            UtilPointerEvent.onDblClick(this.view, function (e) {
                var focused = focusController.get();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (isDblClickable(current)) {
                            if (current.onDblClick(e, interactionManager)) {
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DApplicationLayer.prototype.lock = function () {
            this._isLocked = true;
        };
        DApplicationLayer.prototype.unlock = function () {
            this._isLocked = false;
        };
        DApplicationLayer.prototype.update = function () {
            if (!this._isLocked && this._renderId == null) {
                this._renderId = requestAnimationFrame(this._renderBound);
            }
        };
        DApplicationLayer.prototype.onStageDirty = function () {
            // Update the visibility if this is a overlay layer.
            if (this._isOverlay) {
                if (0 < this.stage.children.length) {
                    // There are more than one children,
                    // therefore must be visible.
                    if (!this._isVisible) {
                        this._isVisible = true;
                        this.view.style.display = "block";
                    }
                }
                else {
                    // There is no child,
                    // therefore must not be visible.
                    if (this._isVisible) {
                        this._isVisible = false;
                        this.view.style.display = "none";
                    }
                }
            }
        };
        DApplicationLayer.prototype.render = function () {
            this.refit();
            this.reflow();
            // Please note why the following line is here.
            //
            // Before this line, the update method does not enque a rendering task
            // because `this._renderId` is not null. As a result, this prevents
            // an unintentional rendering loop caused by the refit or the reflow.
            //
            // After this line, the update method enques a rendering task.
            // Namely, in the DisplayObject#render(Renderer) method, allowed to enque
            // a rendering task. For instance, please refer to the DDiagramShape#update().
            this._renderId = null;
            // Render
            _super.prototype.render.call(this);
        };
        Object.defineProperty(DApplicationLayer.prototype, "width", {
            get: function () {
                return this.screen.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DApplicationLayer.prototype, "height", {
            get: function () {
                return this.screen.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DApplicationLayer.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        DApplicationLayer.prototype.refit = function () {
            var children = this.stage.children;
            for (var ilimit = 0, limit = this._refitLimit; ilimit < limit; ++ilimit) {
                var isChildrenDirty = false;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.refit();
                        isChildrenDirty = isChildrenDirty || child.isChildrenDirty();
                    }
                }
                // If DBases are changed during the `refit` process, need to refit again.
                if (!isChildrenDirty) {
                    break;
                }
            }
        };
        DApplicationLayer.prototype.reflow = function () {
            var children = this.stage.children;
            for (var ilimit = 0, limit = this._refitLimit; ilimit < limit; ++ilimit) {
                var isDirty = false;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                        isDirty = isDirty || child.isDirty() || child.hasDirty();
                    }
                }
                // If DBases are changed during the `reflow` process, need to reflow again.
                if (!isDirty) {
                    break;
                }
            }
        };
        DApplicationLayer.prototype.getFocusController = function () {
            if (this._focus == null) {
                this._focus = new DControllerDefaultFocus();
            }
            return this._focus;
        };
        DApplicationLayer.prototype.getRootElement = function () {
            return this._rootElement;
        };
        DApplicationLayer.prototype.getElementContainer = function () {
            return this._elementContainer;
        };
        DApplicationLayer.prototype.getDynamicFontAtlases = function () {
            if (this._dynamicFontAtlases == null) {
                this._dynamicFontAtlases = new DynamicFontAtlases(this);
            }
            return this._dynamicFontAtlases;
        };
        return DApplicationLayer;
    }(pixi_js.Application));

    var DApplication = /** @class */ (function () {
        function DApplication(options) {
            var _a, _b;
            DApplications.add(this);
            // Root
            this._root = this.toRootElement(options);
            // Resolution
            var resolution = (_b = (_a = options === null || options === void 0 ? void 0 : options.resolution) !== null && _a !== void 0 ? _a : window.devicePixelRatio) !== null && _b !== void 0 ? _b : 1;
            this._resolution = resolution;
            // Remove the accessibility plugin
            delete pixi_js.Renderer.__plugins.accessibility;
            // Options
            this._options = options;
            // Base layer
            var base = this.newLayerBase(options);
            this._base = base;
            // Overlay layer
            this._isOverlayEnabled = !!(options === null || options === void 0 ? void 0 : options.overlay);
            if (!this._isOverlayEnabled) {
                this._overlay = base;
            }
        }
        Object.defineProperty(DApplication.prototype, "stage", {
            get: function () {
                return this._base.stage;
            },
            enumerable: false,
            configurable: true
        });
        DApplication.prototype.getRootElement = function () {
            return this._root;
        };
        DApplication.prototype.getResolution = function () {
            return this._resolution;
        };
        DApplication.prototype.toRootElement = function (options) {
            var root = options === null || options === void 0 ? void 0 : options.root;
            if (root != null) {
                if (isString(root)) {
                    var found = document.querySelector(root);
                    if (found) {
                        return found;
                    }
                }
                else {
                    return root;
                }
            }
            return document.body;
        };
        DApplication.prototype.toLayerBaseOptions = function (options) {
            var root = this._root;
            var resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root: root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: options.background,
                    resolution: resolution,
                    antialias: options.antialias,
                    overlay: false
                });
            }
            return new DApplicationLayerOptions({
                root: root,
                resolution: resolution,
                overlay: false
            });
        };
        DApplication.prototype.newLayerBase = function (options) {
            return new DApplicationLayer(this, this.toLayerBaseOptions(options));
        };
        DApplication.prototype.getLayerBase = function () {
            return this._base;
        };
        DApplication.prototype.toLayerOverlayOptions = function (options) {
            var root = this._root;
            var resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root: root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: {
                        color: null
                    },
                    resolution: resolution,
                    antialias: options.antialias,
                    overlay: true
                });
            }
            return new DApplicationLayerOptions({
                root: root,
                resolution: resolution,
                overlay: true
            });
        };
        DApplication.prototype.newLayerOverlay = function (options) {
            return new DApplicationLayer(this, this.toLayerOverlayOptions(options));
        };
        DApplication.prototype.getLayerOverlay = function () {
            if (this._isOverlayEnabled) {
                if (this._overlay == null) {
                    this._overlay = this.newLayerOverlay(this._options);
                }
                return this._overlay;
            }
            else {
                return this._base;
            }
        };
        DApplication.prototype.update = function () {
            if (this._isOverlayEnabled) {
                var base = this._base;
                base.update();
                var overlay = this._overlay;
                if (overlay) {
                    overlay.update();
                }
            }
            else {
                return this._base.update();
            }
        };
        DApplication.prototype.render = function () {
            if (this._isOverlayEnabled) {
                var base = this._base;
                base.render();
                var overlay = this._overlay;
                if (overlay) {
                    overlay.render();
                }
            }
            else {
                return this._base.render();
            }
        };
        return DApplication;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePaddingAdjustable = /** @class */ (function () {
        function DBasePaddingAdjustable(target) {
            this._target = target;
            this._top = 0;
            this._right = 0;
            this._bottom = 0;
            this._left = 0;
            if (target instanceof DBasePadding) {
                this._callback = target.getCallback();
            }
        }
        DBasePaddingAdjustable.prototype.getTheme = function () {
            return this._target.getTheme();
        };
        DBasePaddingAdjustable.prototype.setTheme = function (theme) {
            this._target.setTheme(theme);
        };
        DBasePaddingAdjustable.prototype.getLeft = function () {
            return this._target.getLeft() + this._left;
        };
        DBasePaddingAdjustable.prototype.adjLeft = function (left) {
            if (this._left !== left) {
                this._left = left;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "left", {
            get: function () {
                return this._target.left;
            },
            set: function (left) {
                this._target.left = left;
            },
            enumerable: false,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getTop = function () {
            return this._target.getTop() + this._top;
        };
        DBasePaddingAdjustable.prototype.adjTop = function (top) {
            if (this._top !== top) {
                this._top = top;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "top", {
            get: function () {
                return this._target.top;
            },
            set: function (top) {
                this._target.top = top;
            },
            enumerable: false,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getRight = function () {
            return this._target.getRight() + this._right;
        };
        DBasePaddingAdjustable.prototype.adjRight = function (right) {
            if (this._right !== right) {
                this._right = right;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "right", {
            get: function () {
                return this._target.right;
            },
            set: function (right) {
                this._target.right = right;
            },
            enumerable: false,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getBottom = function () {
            return this._target.getBottom() + this._bottom;
        };
        DBasePaddingAdjustable.prototype.adjBottom = function (bottom) {
            if (this._bottom !== bottom) {
                this._bottom = bottom;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "bottom", {
            get: function () {
                return this._target.bottom;
            },
            set: function (bottom) {
                this._target.bottom = bottom;
            },
            enumerable: false,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.set = function (top, right, bottom, left) {
            var target = this._target;
            if (right == null) {
                target.set(top);
            }
            else if (bottom == null) {
                target.set(top, right);
            }
            else if (left == null) {
                target.set(top, right, bottom);
            }
            else {
                target.set(top, right, bottom, left);
            }
        };
        return DBasePaddingAdjustable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBoard = /** @class */ (function (_super) {
        __extends(DBoard, _super);
        function DBoard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DBoard.prototype.getType = function () {
            return "DBoard";
        };
        return DBoard;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonCheck = /** @class */ (function (_super) {
        __extends(DButtonCheck, _super);
        function DButtonCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonCheck.prototype.getType = function () {
            return "DButtonCheck";
        };
        return DButtonCheck;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonCheckRight = /** @class */ (function (_super) {
        __extends(DButtonCheckRight, _super);
        function DButtonCheckRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonCheckRight.prototype.getType = function () {
            return "DButtonCheckRight";
        };
        return DButtonCheckRight;
    }(DButtonCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DColorGradientPointObservable = /** @class */ (function () {
        function DColorGradientPointObservable(color, alpha, position, selected, callback) {
            this._color = color;
            this._alpha = alpha;
            this._position = position;
            this._callback = callback;
            this._selected = selected;
        }
        DColorGradientPointObservable.prototype.set = function (color, alpha, position, selected) {
            if (this._color !== color ||
                this._alpha !== alpha ||
                this._position !== position ||
                this._selected !== selected) {
                this._color = color;
                this._alpha = alpha;
                this._position = position;
                this._selected = selected;
                this._callback(this);
            }
        };
        Object.defineProperty(DColorGradientPointObservable.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientPointObservable.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientPointObservable.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                if (this._position !== position) {
                    this._position = position;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientPointObservable.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (selected) {
                if (this._selected !== selected) {
                    this._selected = selected;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DColorGradientPointObservable.prototype.toObject = function () {
            return {
                color: this._color,
                alpha: this._alpha,
                position: this._position
            };
        };
        return DColorGradientPointObservable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var POINT_SORTER = function (a, b) {
        return a.position - b.position;
    };
    var DColorGradientObservable = /** @class */ (function (_super) {
        __extends(DColorGradientObservable, _super);
        function DColorGradientObservable() {
            var _this = _super.call(this) || this;
            var onChangeBound = function (target) {
                _this.onChange(target);
            };
            _this._onChangeBound = onChangeBound;
            var first = new DColorGradientPointObservable(0xffffff, 1, 0, false, onChangeBound);
            var second = new DColorGradientPointObservable(0x808080, 1, 1, true, onChangeBound);
            _this._points = [first, second];
            _this._direction = -90;
            _this._selected = second;
            _this._workColor = [0, 0, 0];
            return _this;
        }
        DColorGradientObservable.prototype.onChange = function (target) {
            var isSelectionChanged = target.selected && this._selected !== target;
            if (isSelectionChanged) {
                var selected = this._selected;
                if (selected != null) {
                    selected._selected = false;
                }
                this._selected = target;
            }
            this._points.sort(POINT_SORTER);
            if (isSelectionChanged) {
                this.emit("selectionchange", this._selected, this);
            }
            this.emit("change", this);
        };
        Object.defineProperty(DColorGradientObservable.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientObservable.prototype, "direction", {
            get: function () {
                return this._direction;
            },
            set: function (direction) {
                if (this._direction !== direction) {
                    this._direction = direction;
                    this.emit("directionchange", direction, this);
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientObservable.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            enumerable: false,
            configurable: true
        });
        DColorGradientObservable.prototype.size = function () {
            return this._points.length;
        };
        DColorGradientObservable.prototype.get = function (index) {
            var points = this._points;
            if (0 <= index && index < points.length) {
                return points[index];
            }
            return null;
        };
        DColorGradientObservable.prototype.addAt = function (position) {
            var points = this._points;
            var previous = null;
            for (var i = 0, imax = points.length; i < imax; ++i) {
                var point = points[i];
                if (position <= point.position) {
                    if (previous != null) {
                        var span = point.position - previous.position;
                        if (0.001 < span) {
                            var rgb0 = pixi_js.utils.hex2rgb(point.color, this._workColor);
                            var r0 = rgb0[0];
                            var g0 = rgb0[1];
                            var b0 = rgb0[2];
                            var rgb1 = pixi_js.utils.hex2rgb(previous.color, this._workColor);
                            var r1 = rgb1[0];
                            var g1 = rgb1[1];
                            var b1 = rgb1[2];
                            var ratio = (position - previous.position) / span;
                            var r = r0 * ratio + r1 * (1 - ratio);
                            var g = g0 * ratio + g1 * (1 - ratio);
                            var b = b0 * ratio + b1 * (1 - ratio);
                            var rgb = this._workColor;
                            rgb[0] = r;
                            rgb[1] = g;
                            rgb[2] = b;
                            var color = pixi_js.utils.rgb2hex(rgb);
                            var alpha = point.alpha * ratio + previous.alpha * (1 - ratio);
                            return this.add(color, alpha, position, true);
                        }
                    }
                    else {
                        return this.add(point.color, point.alpha, position, true);
                    }
                }
                previous = point;
            }
            if (previous != null) {
                return this.add(previous.color, previous.alpha, position, true);
            }
            else {
                return this.add(0xffffff, 1.0, position, true);
            }
        };
        DColorGradientObservable.prototype.add = function (color, alpha, position, selected) {
            var onChangeBound = this._onChangeBound;
            var result = new DColorGradientPointObservable(color, alpha, position, selected, onChangeBound);
            this._points.push(result);
            onChangeBound(result);
            return result;
        };
        DColorGradientObservable.prototype.remove = function (point) {
            var points = this._points;
            if (2 < points.length) {
                for (var i = 0, imax = points.length; i < imax; ++i) {
                    if (points[i] === point) {
                        points.splice(i, 1);
                        var isSelectionChanged = this._selected === point;
                        if (isSelectionChanged) {
                            if (i + 1 < imax) {
                                this._selected = points[i];
                            }
                            else {
                                this._selected = points[i - 1];
                            }
                        }
                        if (isSelectionChanged) {
                            this.emit("selectionchange", this._selected, this);
                        }
                        this.emit("change", this);
                        return true;
                    }
                }
            }
            return false;
        };
        DColorGradientObservable.prototype.reset = function () {
            var oldDirection = this._direction;
            this._direction = -90;
            var points = this._points;
            var oldSelected = this._selected;
            var index = oldSelected ? points.indexOf(oldSelected) : -1;
            points.length = 0;
            var onChangeBound = this._onChangeBound;
            points.push(new DColorGradientPointObservable(0xffffff, 0, 0, false, onChangeBound));
            points.push(new DColorGradientPointObservable(0xffffff, 0, 1, false, onChangeBound));
            if (0 <= index && index < points.length) {
                var point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                var point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
            return this;
        };
        DColorGradientObservable.prototype.toObject = function () {
            var pointsCopy = [];
            var points = this._points;
            for (var i = 0, imax = points.length; i < imax; ++i) {
                pointsCopy.push(points[i].toObject());
            }
            return {
                points: pointsCopy,
                direction: this._direction
            };
        };
        DColorGradientObservable.prototype.fromObject = function (data) {
            var oldDirection = this._direction;
            this._direction = data.direction;
            var points = this._points;
            var oldSelected = this._selected;
            var index = oldSelected ? points.indexOf(oldSelected) : -1;
            points.length = 0;
            var onChangeBound = this._onChangeBound;
            for (var i = 0, imax = data.points.length; i < imax; ++i) {
                var pointLike = data.points[i];
                var point = new DColorGradientPointObservable(pointLike.color, pointLike.alpha, pointLike.position, false, onChangeBound);
                points.push(point);
            }
            points.sort(POINT_SORTER);
            if (0 <= index && index < points.length) {
                var point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                var point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
            return this;
        };
        return DColorGradientObservable;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputLabel = /** @class */ (function (_super) {
        __extends(DInputLabel, _super);
        function DInputLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputLabel.prototype.getType = function () {
            return "DInputLabel";
        };
        return DInputLabel;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputAndLabel = /** @class */ (function (_super) {
        __extends(DInputAndLabel, _super);
        function DInputAndLabel(options) {
            var _this = _super.call(this, options) || this;
            _this.addChild((_this._label = new DInputLabel(options === null || options === void 0 ? void 0 : options.label)));
            _this.addChild((_this._input = _this.createInput(options === null || options === void 0 ? void 0 : options.input)));
            var space = options === null || options === void 0 ? void 0 : options.space;
            if (space != null) {
                _this.addChild(new DLayoutSpace(space));
            }
            return _this;
        }
        Object.defineProperty(DInputAndLabel.prototype, "input", {
            get: function () {
                return this._input;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DInputAndLabel.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: false,
            configurable: true
        });
        DInputAndLabel.prototype.getType = function () {
            return "DInputAndLabel";
        };
        return DInputAndLabel;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputRealAndLabel = /** @class */ (function (_super) {
        __extends(DInputRealAndLabel, _super);
        function DInputRealAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputRealAndLabel.prototype.createInput = function (options) {
            return new DInputReal(options);
        };
        return DInputRealAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputTextAndLabel = /** @class */ (function (_super) {
        __extends(DInputTextAndLabel, _super);
        function DInputTextAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputTextAndLabel.prototype.createInput = function (options) {
            return new DInputText(options);
        };
        return DInputTextAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorAndAlpha = /** @class */ (function () {
        function DPickerColorAndAlpha(colorAndAlpha, onColorChange, onAlphaChange) {
            this._colorAndAlpha = colorAndAlpha;
            this._onColorChange = onColorChange;
            this._onAlphaChange = onAlphaChange;
        }
        Object.defineProperty(DPickerColorAndAlpha.prototype, "color", {
            get: function () {
                return this._colorAndAlpha.color;
            },
            set: function (color) {
                if (this._colorAndAlpha.color !== color) {
                    var callback = this._onColorChange;
                    if (callback != null) {
                        callback(color);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColorAndAlpha.prototype, "alpha", {
            get: function () {
                return this._colorAndAlpha.alpha;
            },
            set: function (alpha) {
                if (this._colorAndAlpha.alpha !== alpha) {
                    var callback = this._onAlphaChange;
                    if (callback != null) {
                        callback(alpha);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        return DPickerColorAndAlpha;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorRecent = /** @class */ (function (_super) {
        __extends(DPickerColorRecent, _super);
        function DPickerColorRecent(recents, capacity) {
            var _this = _super.call(this) || this;
            _this._recents = recents;
            _this._capacity = capacity;
            return _this;
        }
        DPickerColorRecent.prototype.get = function (index) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        };
        DPickerColorRecent.prototype.set = function (index, colorAndAlpha) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                var result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = {
                    color: colorAndAlpha.color,
                    alpha: colorAndAlpha.alpha
                };
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorRecent.prototype.contains = function (colorAndAlpha) {
            var recents = this._recents;
            for (var i = 0, imax = recents.length; i < imax; ++i) {
                var recent = recents[i];
                if (recent.color === colorAndAlpha.color && recent.alpha === colorAndAlpha.alpha) {
                    return true;
                }
            }
            return false;
        };
        DPickerColorRecent.prototype.add = function (colorAndAlpha) {
            var recents = this._recents;
            recents.push({
                color: colorAndAlpha.color,
                alpha: colorAndAlpha.alpha
            });
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        };
        DPickerColorRecent.prototype.pop = function () {
            var recents = this._recents;
            var result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorRecent.prototype.size = function () {
            return this._recents.length;
        };
        return DPickerColorRecent;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColor = /** @class */ (function (_super) {
        __extends(DPickerColor, _super);
        function DPickerColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DPickerColor.prototype, "current", {
            get: function () {
                return this._currentPicker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColor.prototype, "new", {
            get: function () {
                return this._newPicker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColor.prototype, "recent", {
            get: function () {
                return this._recent;
            },
            enumerable: false,
            configurable: true
        });
        DPickerColor.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
            this._base = 0xff0000;
            this._new = { color: 0xffffff, alpha: 1 };
            this._newPicker = new DPickerColorAndAlpha(this._new, function (color) {
                _this.setColorNew(color);
            }, function (alpha) {
                _this.setAlphaNew(alpha);
            });
            this._current = { color: 0xffffff, alpha: 1 };
            this._currentPicker = new DPickerColorAndAlpha(this._current, function (color) {
                _this.setColorCurrent(color);
            }, function (alpha) {
                _this.setAlphaCurrent(alpha);
            });
            var theme = this.theme;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingRight = padding.getRight();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            this._pointerPoint = new pixi_js.Point();
            // Main
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var mainBaseSprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
            this._mainBaseSprite = mainBaseSprite;
            mainBaseSprite.x = paddingLeft;
            mainBaseSprite.y = paddingTop;
            mainBaseSprite.width = mainWidth;
            mainBaseSprite.height = mainHeight;
            mainBaseSprite.interactive = true;
            this.addChild(mainBaseSprite);
            var mainSprite = new pixi_js.Sprite(theme.getMainTexture());
            this._mainSprite = mainSprite;
            mainSprite.x = paddingLeft;
            mainSprite.y = paddingTop;
            mainSprite.tint = this._base;
            mainSprite.interactive = false;
            this.addChild(mainSprite);
            // Main event handling
            this._onMainMoveBound = function (e) {
                _this.onMainMove(e);
            };
            this._onMainUpBound = function (e) {
                _this.onMainUp(e);
            };
            mainBaseSprite.on(UtilPointerEvent.down, function (e) {
                _this.onMainDown(e);
            });
            // Base color picker
            var baseSprite = new pixi_js.Sprite(theme.getBaseTexture());
            this._baseSprite = baseSprite;
            baseSprite.x = paddingLeft;
            baseSprite.y = mainBaseSprite.y + mainBaseSprite.height + theme.getBaseMargin();
            baseSprite.interactive = true;
            this.addChild(baseSprite);
            // Base event
            this._onBaseMoveBound = function (e) {
                _this.onBaseMove(e);
            };
            this._onBaseUpBound = function (e) {
                _this.onBaseUp(e);
            };
            baseSprite.on(UtilPointerEvent.down, function (e) {
                _this.onBaseDown(e);
            });
            // Alpha picker
            var alphaCheckerboardSprite = new pixi_js.Sprite(theme.getAlphaCheckerboardTexture());
            this._alphaCheckerboardSprite = alphaCheckerboardSprite;
            alphaCheckerboardSprite.x = padding.getLeft();
            alphaCheckerboardSprite.y = baseSprite.y + theme.getBaseHeight() + theme.getBaseMargin();
            alphaCheckerboardSprite.interactive = false;
            this.addChild(alphaCheckerboardSprite);
            var alphaSprite = new pixi_js.Sprite(theme.getAlphaTexture());
            alphaSprite.tint = this._new.color;
            alphaSprite.interactive = true;
            alphaCheckerboardSprite.addChild(alphaSprite);
            // Alpha event
            this._onAlphaMoveBound = function (e) {
                _this.onAlphaMove(e);
            };
            this._onAlphaUpBound = function (e) {
                _this.onAlphaUp(e);
            };
            alphaSprite.on(UtilPointerEvent.down, function (e) {
                _this.onAlphaDown(e);
            });
            // Pointers
            var mainPointerSprite = new pixi_js.Sprite(theme.getMainPointerTexture());
            this._mainPointerSprite = mainPointerSprite;
            mainPointerSprite.x = paddingLeft;
            mainPointerSprite.y = paddingTop;
            mainPointerSprite.anchor.x = 0.5;
            mainPointerSprite.anchor.y = 0.5;
            mainPointerSprite.tint = theme.getMainPointerColor();
            mainPointerSprite.alpha = theme.getMainPointerAlpha();
            mainPointerSprite.interactive = false;
            this.addChild(mainPointerSprite);
            var alphaPointerSprite = new pixi_js.Sprite(theme.getAlphaPointerTexture());
            this._alphaPointerSprite = alphaPointerSprite;
            alphaPointerSprite.x = mainWidth;
            alphaPointerSprite.y = alphaCheckerboardSprite.height * 0.5;
            alphaPointerSprite.tint = theme.getAlphaPointerColor();
            alphaPointerSprite.alpha = theme.getAlphaPointerAlpha();
            alphaPointerSprite.anchor.set(0.5, 0.5);
            alphaPointerSprite.interactive = false;
            alphaCheckerboardSprite.addChild(alphaPointerSprite);
            var basePointerSprite = new pixi_js.Sprite(theme.getBasePointerTexture());
            this._basePointerSprite = basePointerSprite;
            basePointerSprite.x = 0;
            basePointerSprite.y = baseSprite.height * 0.5;
            basePointerSprite.tint = theme.getBasePointerColor();
            basePointerSprite.alpha = theme.getBasePointerAlpha();
            basePointerSprite.anchor.set(0.5, 0.5);
            basePointerSprite.interactive = false;
            baseSprite.addChild(basePointerSprite);
            // Recently used
            this._recentColorSprites = [];
            var recentColorSprites = this._recentColorSprites;
            var recentColorCount = theme.getRecentColorCount();
            var recentColorWidth = theme.getRecentColorWidth();
            var recentColorHeight = theme.getRecentColorHeight();
            var recentColorWidthHalf = recentColorWidth * 0.5;
            var recentColorHeightHalf = recentColorHeight * 0.5;
            var recentColorMargin = theme.getRecentColorMargin();
            var recentColorY = alphaCheckerboardSprite.y + theme.getAlphaHeight() + theme.getRecentMargin();
            var recentCheckerboardTexture = theme.getRecentCheckerboardTexture();
            if (DPickerColor.RECENT_COLORS == null) {
                DPickerColor.RECENT_COLORS = new DPickerColorRecent(theme.getRecents().slice(0), recentColorCount);
            }
            var recent = (this._recent = DPickerColor.RECENT_COLORS);
            recent.on("change", function () {
                _this.onRecentChange();
            });
            var onRecentClick = function (e) {
                var checkerboardSprite = e.currentTarget;
                if (checkerboardSprite instanceof pixi_js.Container) {
                    var sprite = checkerboardSprite.children[0];
                    if (sprite instanceof pixi_js.Sprite) {
                        _this.setColorNew(sprite.tint);
                        _this.setAlphaNew(sprite.alpha);
                    }
                }
            };
            for (var i = 0; i < recentColorCount; ++i) {
                var x = paddingLeft + i * (recentColorWidth + recentColorMargin);
                var checkerboardSprite = new pixi_js.Sprite(recentCheckerboardTexture);
                checkerboardSprite.x = x + recentColorWidthHalf;
                checkerboardSprite.y = recentColorY + recentColorHeightHalf;
                checkerboardSprite.anchor.x = 0.5;
                checkerboardSprite.anchor.y = 0.5;
                checkerboardSprite.buttonMode = true;
                checkerboardSprite.interactive = true;
                UtilPointerEvent.onClick(checkerboardSprite, onRecentClick);
                this.addChild(checkerboardSprite);
                var sprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
                var recentColorAndAlpha = recent.get(i);
                if (recentColorAndAlpha != null) {
                    sprite.tint = recentColorAndAlpha.color;
                    sprite.alpha = recentColorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
                sprite.width = recentColorWidth;
                sprite.height = recentColorHeight;
                sprite.anchor.x = 0.5;
                sprite.anchor.y = 0.5;
                sprite.interactive = false;
                checkerboardSprite.addChild(sprite);
                recentColorSprites.push(sprite);
            }
            // Input color
            var inputMargin = theme.getInputMargin();
            var inputLabelWidth = theme.getInputLabelWidth();
            var inputY = recentColorY + recentColorHeight + inputMargin;
            var inputWidth = (mainWidth - inputMargin) * 0.5;
            var inputAndLabelColor = new DInputTextAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY,
                width: inputWidth,
                label: {
                    width: inputLabelWidth,
                    text: {
                        value: "#"
                    }
                },
                input: {
                    weight: 1,
                    text: {
                        value: "FFFFFF"
                    },
                    on: {
                        input: function (code) {
                            var color = UtilRgb.fromCode(code);
                            if (color != null) {
                                _this.setColorNew(color);
                            }
                        }
                    }
                }
            });
            this._inputAndLabelColor = inputAndLabelColor;
            var inputHeight = inputAndLabelColor.height;
            var inputAndLabelAlpha = new DInputRealAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY + inputHeight + inputMargin,
                width: inputWidth,
                label: {
                    width: inputLabelWidth,
                    text: {
                        value: "A"
                    }
                },
                input: {
                    weight: 1,
                    text: {
                        value: 1
                    },
                    min: 0,
                    max: 1,
                    on: {
                        input: function (value) {
                            _this.setAlphaNew(value);
                        }
                    }
                }
            });
            this._inputAndLabelAlpha = inputAndLabelAlpha;
            // Samples
            var sampleWidth = (inputWidth - inputLabelWidth - inputMargin) * 0.5;
            var sampleHeight = inputHeight + inputMargin + inputHeight;
            var sampleX = paddingLeft + (mainWidth - inputMargin) * 0.5 + inputMargin;
            var sampleY = inputY + (inputHeight + inputMargin + inputAndLabelAlpha.height - sampleHeight) * 0.5;
            var sampleCurrentCheckerboardSprite = new pixi_js.Sprite(theme.getSampleCheckerboardTexture());
            this._sampleCurrentCheckerboardSprite = sampleCurrentCheckerboardSprite;
            sampleCurrentCheckerboardSprite.x = sampleX;
            sampleCurrentCheckerboardSprite.y = sampleY;
            sampleCurrentCheckerboardSprite.width = sampleWidth;
            sampleCurrentCheckerboardSprite.height = sampleHeight;
            sampleCurrentCheckerboardSprite.interactive = false;
            this.addChild(sampleCurrentCheckerboardSprite);
            var current = this._current;
            var sampleCurrentSprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
            this._sampleCurrentSprite = sampleCurrentSprite;
            sampleCurrentSprite.x = sampleX;
            sampleCurrentSprite.y = sampleY;
            sampleCurrentSprite.tint = current.color;
            sampleCurrentSprite.alpha = current.alpha;
            sampleCurrentSprite.width = sampleWidth;
            sampleCurrentSprite.height = sampleHeight;
            sampleCurrentSprite.interactive = true;
            sampleCurrentSprite.buttonMode = true;
            UtilPointerEvent.onClick(sampleCurrentSprite, function () {
                _this.setColorNew(current.color);
                _this.setAlphaNew(current.alpha);
            });
            this.addChild(sampleCurrentSprite);
            var sampleNewCheckerboardSprite = new pixi_js.Sprite(theme.getSampleCheckerboardTexture());
            this._sampleNewCheckerboardSprite = sampleNewCheckerboardSprite;
            sampleNewCheckerboardSprite.x = sampleX + sampleWidth;
            sampleNewCheckerboardSprite.y = sampleY;
            sampleNewCheckerboardSprite.width = sampleWidth;
            sampleNewCheckerboardSprite.height = sampleHeight;
            sampleNewCheckerboardSprite.interactive = false;
            this.addChild(sampleNewCheckerboardSprite);
            var sampleNewSprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
            this._sampleNewSprite = sampleNewSprite;
            sampleNewSprite.x = sampleX + sampleWidth;
            sampleNewSprite.y = sampleY;
            sampleNewSprite.tint = this._new.color;
            sampleNewSprite.alpha = this._new.alpha;
            sampleNewSprite.width = sampleWidth;
            sampleNewSprite.height = sampleHeight;
            sampleNewSprite.interactive = false;
            this.addChild(sampleNewSprite);
            // Width
            if (options == null || options.width == null) {
                this.width = paddingLeft + mainWidth + paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height =
                    inputY +
                        inputAndLabelColor.height +
                        inputMargin +
                        inputAndLabelAlpha.height +
                        paddingBottom;
            }
        };
        DPickerColor.prototype.onMainDown = function (e) {
            this.onMainPick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onMainMoveBound);
                stage.on(UtilPointerEvent.up, this._onMainUpBound);
            }
        };
        DPickerColor.prototype.onMainMove = function (e) {
            this.onMainPick(e.data.global);
        };
        DPickerColor.prototype.onMainUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onMainMoveBound);
                stage.off(UtilPointerEvent.up, this._onMainUpBound);
            }
        };
        DPickerColor.prototype.toMainHex = function (b, w0, w1, shift) {
            return Math.max(0, Math.min(255, w0 * 255 + w1 * ((b >> shift) & 0xff))) << shift;
        };
        DPickerColor.prototype.toMainColor = function (base, tx, ty, width, height) {
            var hw = width * 0.5;
            var ux = Math.max(0, Math.min(1, ((tx - hw) * (1 - ty / height) + hw) / width));
            var uy = Math.max(0, Math.min(1, ty / height));
            var w1 = Math.abs(0.5 * uy - ux);
            var w0 = 1 - w1 - uy;
            var r = this.toMainHex(base, w0, w1, 16);
            var g = this.toMainHex(base, w0, w1, 8);
            var b = this.toMainHex(base, w0, w1, 0);
            return r | g | b;
        };
        DPickerColor.prototype.onMainPick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var paddingLeft = padding.getLeft();
            var paddingTop = padding.getTop();
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - paddingLeft));
            var y = Math.max(0, Math.min(mainHeight, point.y - paddingTop));
            var mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.position.set(paddingLeft + x, paddingTop + y);
            this.onColorNew(this.toMainColor(this._base, x, y, mainWidth, mainHeight));
        };
        DPickerColor.prototype.setColorCurrent = function (color) {
            this._sampleCurrentSprite.tint = this._current.color = color;
        };
        DPickerColor.prototype.setAlphaCurrent = function (alpha) {
            this._sampleCurrentSprite.alpha = this._current.alpha = alpha;
        };
        DPickerColor.prototype.setColorNew = function (color) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var padding = this._padding;
            // Base color
            var hsv = UtilHsv.fromRgb(color);
            this._mainSprite.tint = this._base = UtilHsv.toRgb(hsv[0], 255, 255);
            // Move the base pointer
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, hsv[0] / 360)) * mainWidth;
            // Move the main pointer
            var ns = Math.max(0, Math.min(1, hsv[1] / 255));
            var nv = Math.max(0, Math.min(1, 1 - hsv[2] / 255));
            var mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.tint = nv < 0.45 ? theme.getMainPointerColor() : 0xffffff;
            mainPointerSprite.position.set(padding.getLeft() + ns * mainWidth, padding.getTop() + nv * mainHeight);
            // New color
            this.onColorNew(color);
        };
        DPickerColor.prototype.onColorNew = function (color) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.lock();
            }
            this._sampleNewSprite.tint = this._new.color = color;
            this._inputAndLabelColor.input.value = UtilRgb.toCode(color);
            this.emit("newcolorchange", color, this);
            if (layer) {
                layer.unlock();
                layer.update();
            }
        };
        DPickerColor.prototype.onBaseDown = function (e) {
            this.onBasePick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.on(UtilPointerEvent.up, this._onBaseUpBound);
            }
        };
        DPickerColor.prototype.onBaseMove = function (e) {
            this.onBasePick(e.data.global);
        };
        DPickerColor.prototype.onBaseUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.off(UtilPointerEvent.up, this._onBaseUpBound);
            }
        };
        DPickerColor.prototype.toBaseHex = function (t, shift) {
            return Math.max(0, Math.min(255, t * 6 * 255)) << shift;
        };
        DPickerColor.prototype.toBaseColor = function (t) {
            if (t <= 0.167) {
                return 0xff0000 + this.toBaseHex(t, 8);
            }
            else if (t <= 0.333) {
                t = 0.333 - t;
                return 0x00ff00 + this.toBaseHex(t, 16);
            }
            else if (t <= 0.5) {
                t -= 0.333;
                return 0x00ff00 + this.toBaseHex(t, 0);
            }
            else if (t < 0.667) {
                t = 0.667 - t;
                return 0x0000ff + this.toBaseHex(t, 8);
            }
            else if (t < 0.883) {
                t -= 0.667;
                return 0x0000ff + this.toBaseHex(t, 16);
            }
            else {
                t = 0.883 - t;
                return 0xff0000 + this.toBaseHex(t, 0);
            }
        };
        DPickerColor.prototype.onBasePick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = x;
            this.onColorBase(this.toBaseColor(x / mainWidth));
        };
        DPickerColor.prototype.setColorBase = function (h) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, h / 360)) * mainWidth;
            this.onColorBase(UtilHsv.toRgb(h, 255, 255));
        };
        DPickerColor.prototype.onColorBase = function (color) {
            this._mainSprite.tint = this._base = color;
            var mainPointerSprite = this._mainPointerSprite;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var padding = this._padding;
            this.onColorNew(this.toMainColor(this._base, mainPointerSprite.x - padding.getLeft(), mainPointerSprite.y - padding.getTop(), mainWidth, mainHeight));
        };
        DPickerColor.prototype.onAlphaDown = function (e) {
            this.onAlphaPick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.on(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        };
        DPickerColor.prototype.onAlphaMove = function (e) {
            this.onAlphaPick(e.data.global);
        };
        DPickerColor.prototype.onAlphaUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.off(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        };
        DPickerColor.prototype.onAlphaPick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            this._alphaPointerSprite.x = x;
            this.onAlphaNew(x / mainWidth);
        };
        DPickerColor.prototype.setAlphaNew = function (alpha) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this._alphaPointerSprite.x = Math.max(0, Math.min(1, alpha)) * mainWidth;
            this.onAlphaNew(alpha);
        };
        DPickerColor.prototype.onAlphaNew = function (alpha) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.lock();
            }
            this._sampleNewSprite.alpha = this._new.alpha = alpha;
            this._inputAndLabelAlpha.input.value = Number(alpha.toFixed(2));
            this.emit("newalphachange", alpha, this);
            if (layer) {
                layer.unlock();
                layer.update();
            }
        };
        DPickerColor.prototype.onRecentChange = function () {
            var sprites = this._recentColorSprites;
            var recent = this._recent;
            for (var i = 0, imax = sprites.length; i < imax; ++i) {
                var sprite = sprites[i];
                var colorAndAlpha = recent.get(i);
                if (colorAndAlpha != null) {
                    sprite.tint = colorAndAlpha.color;
                    sprite.alpha = colorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
            }
        };
        DPickerColor.prototype.getType = function () {
            return "DPickerColor";
        };
        DPickerColor.RECENT_COLORS = null;
        return DPickerColor;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isEqual = function (a, b) {
        if (a.direction !== b.direction) {
            return false;
        }
        var ap = a.points;
        var bp = b.points;
        if (ap.length !== bp.length) {
            return false;
        }
        for (var j = 0, jmax = ap.length; j < jmax; ++j) {
            var apj = ap[j];
            var bpj = bp[j];
            if (apj.color !== bpj.color || apj.alpha !== bpj.alpha || apj.position !== bpj.position) {
                return false;
            }
        }
        return true;
    };
    var DPickerColorGradientRecent = /** @class */ (function (_super) {
        __extends(DPickerColorGradientRecent, _super);
        function DPickerColorGradientRecent(recents, capacity) {
            var _this = _super.call(this) || this;
            _this._recents = recents;
            _this._capacity = capacity;
            return _this;
        }
        DPickerColorGradientRecent.prototype.getCapacity = function () {
            return this._capacity;
        };
        DPickerColorGradientRecent.prototype.get = function (index) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.set = function (index, points) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                var result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = points;
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.contains = function (points) {
            var recents = this._recents;
            for (var i = 0, imax = recents.length; i < imax; ++i) {
                if (isEqual(recents[i], points)) {
                    return true;
                }
            }
            return false;
        };
        DPickerColorGradientRecent.prototype.add = function (points) {
            var recents = this._recents;
            recents.push(points);
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        };
        DPickerColorGradientRecent.prototype.pop = function () {
            var recents = this._recents;
            var result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.size = function () {
            return this._recents.length;
        };
        return DPickerColorGradientRecent;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER$2 = "\nattribute vec2 aPosition;\nattribute vec2 aUv;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\n\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nvoid main(void) {\n\tvec3 position = vec3(aPosition.x, aPosition.y, 1.0);\n\tgl_Position = vec4((projectionMatrix * translationMatrix * position).xy, 0.0, 1.0);\n\tvUv = aUv;\n\tvColor = aColor;\n}\n";
    var FRAGMENT_SHADER$2 = "\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform vec2 uCheckerColors;\n\nvoid main(void) {\n\tvec4 texture = texture2D(uSampler, vUv);\n\tfloat cy = step( 1.0, mod( gl_FragCoord.y / 10.0, 2.0 ) );\n\tfloat cx = step( 1.0, mod( gl_FragCoord.x / 10.0 + cy, 2.0 ) );\n\tfloat c = mix( uCheckerColors.x, uCheckerColors.y, cx );\n\tgl_FragColor = texture * vec4( mix( vec3( c ), vColor.xyz, vColor.a ), 1.0 );\n}";
    var DPickerColorGradientView = /** @class */ (function (_super) {
        __extends(DPickerColorGradientView, _super);
        function DPickerColorGradientView(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader) {
            var _this = _super.call(this, geometry, shader) || this;
            _this.interactive = true;
            _this.interactiveChildren = false;
            _this.cursor = "pointer";
            _this._nPointsPerData = nPointsPerData;
            _this._vertices = vertices;
            _this._uvs = uvs;
            _this._colors = colors;
            _this._indices = indices;
            _this._lastHitIndex = -1;
            _this._workColor = [0, 0, 0];
            _this._workPoint = new pixi_js.Point();
            _this._parts = parts;
            shader.uniforms.uSampler.on("update", function () {
                _this.update();
                DApplications.update(_this);
            });
            _this.update();
            return _this;
        }
        DPickerColorGradientView.prototype.getRectangle = function (index) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].rect;
            }
            return null;
        };
        DPickerColorGradientView.prototype.setRectangle = function (index, x, y, width, height) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                var rect = parts[index].rect;
                rect.x = x;
                rect.y = y;
                rect.width = width;
                rect.height = height;
            }
        };
        DPickerColorGradientView.prototype.getData = function (index) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].data;
            }
            return null;
        };
        DPickerColorGradientView.prototype.setData = function (index, data) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                parts[index].data = data;
            }
        };
        DPickerColorGradientView.prototype.getLastHitIndex = function () {
            return this._lastHitIndex;
        };
        DPickerColorGradientView.prototype.setColors = function (ic, colors, rgb, alpha) {
            colors[ic + 0] = rgb[0];
            colors[ic + 1] = rgb[1];
            colors[ic + 2] = rgb[2];
            colors[ic + 3] = alpha;
            colors[ic + 4] = rgb[0];
            colors[ic + 5] = rgb[1];
            colors[ic + 6] = rgb[2];
            colors[ic + 7] = alpha;
        };
        DPickerColorGradientView.prototype.setColorsHex = function (ic, colors, color, alpha) {
            var rgb = pixi_js.utils.hex2rgb(color, this._workColor);
            this.setColors(ic, colors, rgb, alpha);
        };
        DPickerColorGradientView.prototype.setColorsWhite = function (ic, colors) {
            var rgb = this._workColor;
            rgb[0] = 1;
            rgb[1] = 1;
            rgb[2] = 1;
            this.setColors(ic, colors, rgb, 0);
        };
        DPickerColorGradientView.prototype.setColorsPoint = function (ic, data, index, colors) {
            var point = data.points[index];
            if (point != null) {
                this.setColorsHex(ic, colors, point.color, point.alpha);
            }
            else {
                this.setColorsWhite(ic, colors);
            }
        };
        DPickerColorGradientView.prototype.setVertices = function (iv, vertices, position, rect) {
            var y = rect.y + rect.height * position;
            vertices[iv + 0] = rect.x;
            vertices[iv + 1] = y;
            vertices[iv + 2] = rect.x + rect.width;
            vertices[iv + 3] = y;
        };
        DPickerColorGradientView.prototype.setUvs = function (iv, uvs, position, textureUvs) {
            var x0 = textureUvs.x0 + (textureUvs.x3 - textureUvs.x0) * position;
            var y0 = textureUvs.y0 + (textureUvs.y3 - textureUvs.y0) * position;
            var x1 = textureUvs.x1 + (textureUvs.x2 - textureUvs.x1) * position;
            var y1 = textureUvs.y1 + (textureUvs.y2 - textureUvs.y1) * position;
            uvs[iv + 0] = x0;
            uvs[iv + 1] = y0;
            uvs[iv + 2] = x1;
            uvs[iv + 3] = y1;
        };
        DPickerColorGradientView.prototype.newIndices = function (ii, iv, size, indices) {
            for (var i = 0; i < size; ++i) {
                indices[ii + 0] = iv + 0;
                indices[ii + 1] = iv + 1;
                indices[ii + 2] = iv + 2;
                indices[ii + 3] = iv + 2;
                indices[ii + 4] = iv + 1;
                indices[ii + 5] = iv + 3;
                ii += 6;
                iv += 2;
            }
            return indices;
        };
        DPickerColorGradientView.prototype._calculateBounds = function () {
            var rect = this._parts[0].rect;
            var bounds = this._bounds;
            var work = this._workPoint;
            work.set(rect.x, rect.y);
            bounds.addPoint(work);
            work.set(rect.x + rect.width, rect.y + rect.height);
            bounds.addPoint(work);
        };
        DPickerColorGradientView.prototype.update = function () {
            var vertices = this._vertices;
            var uvs = this._uvs;
            var colors = this._colors;
            var indices = this._indices;
            var texture = this.shader.uniforms.uSampler;
            if (texture._uvs == null) {
                texture.updateUvs();
            }
            var textureUvs = texture._uvs;
            var iv = 0;
            var nv = 0;
            var ic = 0;
            var ii = 0;
            var parts = this._parts;
            for (var i = 0, imax = parts.length; i < imax; ++i) {
                var data = parts[i].data;
                var rect = parts[i].rect;
                if (data == null) {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsWhite(ic, colors);
                    this.setVertices(iv + 4, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsWhite(ic + 8, colors);
                    this.newIndices(ii, nv, 1, indices);
                    iv += 4 * 2;
                    ic += 4 * 4;
                    nv += 4;
                    ii += 6;
                }
                else {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsPoint(ic, data, 0, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    var pointSize = data.points.length;
                    for (var j = 0, jmax = Math.min(pointSize, this._nPointsPerData); j < jmax; ++j) {
                        var point = data.points[j];
                        this.setVertices(iv, vertices, point.position, rect);
                        this.setUvs(iv, uvs, point.position, textureUvs);
                        this.setColorsHex(ic, colors, point.color, point.alpha);
                        iv += 2 * 2;
                        ic += 2 * 4;
                    }
                    this.setVertices(iv, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsPoint(ic, data, pointSize - 1, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    this.newIndices(ii, nv, pointSize + 1, indices);
                    ii += (pointSize + 1) * 6;
                    nv += (pointSize + 2) * 2;
                }
            }
            this.size = ii;
            var geometry = this.geometry;
            geometry.getBuffer("aPosition").update();
            geometry.getBuffer("aUv").update();
            geometry.getBuffer("aColor").update();
            geometry.getIndex().update();
        };
        DPickerColorGradientView.prototype.containsPoint = function (point) {
            var local = this.toLocal(point, undefined, this._workPoint);
            var parts = this._parts;
            for (var i = 0, imax = parts.length; i < imax; ++i) {
                var rect = parts[i].rect;
                if (rect.contains(local.x, local.y)) {
                    this._lastHitIndex = i;
                    return true;
                }
            }
            return false;
        };
        DPickerColorGradientView.from = function (size, nPointsPerData, checkerColors, texture) {
            if (texture === void 0) { texture = pixi_js.Texture.WHITE; }
            var vertices = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            var uvs = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            var colors = new Float32Array(size * (nPointsPerData + 2) * 2 * 4);
            var indices = new Uint16Array(size * (nPointsPerData + 1) * 6);
            var parts = [];
            for (var i = 0; i < size; ++i) {
                parts.push({
                    data: null,
                    rect: new pixi_js.Rectangle()
                });
            }
            var geometry = new pixi_js.Geometry()
                .addIndex(new pixi_js.Buffer(indices, false, true))
                .addAttribute("aPosition", new pixi_js.Buffer(vertices, false, false), 2)
                .addAttribute("aUv", new pixi_js.Buffer(uvs, false, false), 2)
                .addAttribute("aColor", new pixi_js.Buffer(colors, false, false), 4);
            var shader = pixi_js.Shader.from(VERTEX_SHADER$2, FRAGMENT_SHADER$2, {
                uSampler: texture,
                uCheckerColors: checkerColors
            });
            return new DPickerColorGradientView(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader);
        };
        return DPickerColorGradientView;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorGradient = /** @class */ (function (_super) {
        __extends(DPickerColorGradient, _super);
        function DPickerColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerColorGradient.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
            var theme = this.theme;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingRight = padding.getRight();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            this._work = new pixi_js.Point();
            // Picker
            var gradientPointsWidth = theme.getGradientPointsWidth();
            var gradientPointsMargin = theme.getGradientPointsMargin();
            var picker = new DPickerColor({
                x: paddingLeft + gradientPointsWidth + gradientPointsMargin,
                y: paddingTop
            });
            this._picker = picker;
            picker.on("newcolorchange", function (color) {
                _this.onAnchorColorChange(color);
            });
            picker.on("newalphachange", function (alpha) {
                _this.onAnchorAlphaChange(alpha);
            });
            this.addChild(picker);
            // Points view
            var view = (this._view = DPickerColorGradientView.from(17, 10, theme.getGradientCheckerColors()));
            view.setRectangle(0, paddingLeft, paddingTop, gradientPointsWidth, picker.height);
            this.addChild(view);
            view.on(UtilPointerEvent.down, function (e) {
                if (view.getLastHitIndex() === 0) {
                    _this.onViewDown(e);
                }
            });
            // Anchor
            this._onAnchorDownBound = function (e) {
                _this.onAnchorDown(e);
            };
            this._onAnchorMoveBound = function (e) {
                _this.onAnchorMove(e);
            };
            this._onAnchorUpBound = function (e) {
                _this.onAnchorUp(e);
            };
            this._anchors = [];
            //
            var inputLabelWidth = picker.theme.getInputLabelWidth();
            var inputWidth = picker.theme.getMainWidth() * 0.5;
            var inputMargin = 5;
            var inputDirectionMargin = theme.getGradientDirectionMargin();
            var inputDirectionTexture = theme.getGradientDirectionTexture();
            var inputLeft = picker.x + picker.width + inputDirectionMargin;
            var inputDirection = new DInputReal({
                parent: this,
                x: inputLeft + inputLabelWidth + inputMargin,
                y: paddingTop,
                width: inputWidth - inputLabelWidth - inputMargin,
                step: 1,
                image: {
                    source: inputDirectionTexture,
                    align: {
                        with: DAlignWith.BORDER
                    },
                    margin: {
                        horizontal: -inputDirectionTexture.width - inputMargin
                    }
                },
                on: {
                    change: function (value) {
                        _this._value._direction = value;
                    }
                }
            });
            // Recent gradients
            var recentColumn = theme.getGradientRecentColumn();
            var recentWidth = theme.getGradientRecentWidth();
            var recentMargin = theme.getGradientRecentMargin();
            var recentWidthAndMargin = recentWidth + recentMargin;
            var x0 = inputLeft;
            var y0 = inputDirection.y + inputDirection.height + inputDirectionMargin;
            if (DPickerColorGradient.RECENT_COLOR_GRADIENT == null) {
                DPickerColorGradient.RECENT_COLOR_GRADIENT = new DPickerColorGradientRecent(theme.getGradientRecents(), theme.getGradientRecentCount());
            }
            this._recent = DPickerColorGradient.RECENT_COLOR_GRADIENT;
            var recent = this._recent;
            for (var i = 0, imax = recent.getCapacity(); i < imax; ++i) {
                var ix = i % recentColumn;
                var x = x0 + ix * recentWidthAndMargin;
                var iy = (i / recentColumn) | 0;
                var y = y0 + iy * recentWidthAndMargin;
                view.setRectangle(1 + i, x, y, recentWidth, recentWidth);
            }
            recent.on("change", function () {
                _this.onRecentUpdate();
            });
            UtilPointerEvent.onClick(view, function (e) {
                var lastHitIndex = view.getLastHitIndex();
                if (1 <= lastHitIndex) {
                    _this.onRecentClick(view.getData(lastHitIndex));
                }
            });
            // Points
            var data = new DColorGradientObservable();
            this._value = data;
            data.on("change", function () {
                _this.updateAnchors();
                view.update();
            });
            data.on("selectionchange", function (point) {
                _this.onAnchorSelect(point);
            });
            data.on("directionchange", function (value) {
                inputDirection.value = value;
            });
            view.setData(0, data);
            view.update();
            inputDirection.value = data.direction;
            this.updateAnchors();
            var selected = data.selected;
            if (selected != null) {
                this.onAnchorSelect(selected);
            }
            // Width
            if (options == null || options.width == null) {
                this.width =
                    paddingLeft +
                        gradientPointsWidth +
                        gradientPointsMargin +
                        picker.width +
                        inputDirectionMargin +
                        (recentColumn - 1) * recentMargin +
                        recentColumn * recentWidth +
                        paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height = paddingTop + picker.height + paddingBottom;
            }
        };
        Object.defineProperty(DPickerColorGradient.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColorGradient.prototype, "recent", {
            get: function () {
                return this._recent;
            },
            enumerable: false,
            configurable: true
        });
        DPickerColorGradient.prototype.onRecentClick = function (recentData) {
            var value = this._value;
            if (recentData != null) {
                value.fromObject(recentData);
            }
            else {
                value.reset();
            }
        };
        DPickerColorGradient.prototype.onRecentUpdate = function () {
            var recent = this._recent;
            var view = this._view;
            for (var i = 0, imax = recent.size(); i < imax; ++i) {
                view.setData(1 + i, recent.get(i));
            }
            view.update();
            DApplications.update(this);
        };
        DPickerColorGradient.prototype.toAnchorPosition = function (e) {
            var local = this.toLocal(e.data.global, undefined, this._work);
            return Math.max(0, Math.min(1, (local.y - this.padding.getTop()) / this._picker.height));
        };
        DPickerColorGradient.prototype.onViewDown = function (e) {
            this._value.addAt(this.toAnchorPosition(e));
            this.onAnchorDragStart();
        };
        DPickerColorGradient.prototype.onAnchorDown = function (e) {
            var target = e.target;
            if (target instanceof pixi_js.Sprite) {
                var value = this._value;
                var index = this._anchors.indexOf(target);
                if (0 <= index && index < value.points.length) {
                    value.points[index].selected = true;
                    this.onAnchorDragStart();
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorSelect = function (point) {
            var picker = this._picker;
            picker.current.color = point.color;
            picker.current.alpha = point.alpha;
            picker.new.color = point.color;
            picker.new.alpha = point.alpha;
        };
        DPickerColorGradient.prototype.onAnchorColorChange = function (color) {
            var value = this._value;
            if (value != null) {
                var selected = value.selected;
                if (selected != null) {
                    selected.color = color;
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorAlphaChange = function (alpha) {
            var value = this._value;
            if (value != null) {
                var selected = value.selected;
                if (selected != null) {
                    selected.alpha = alpha;
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorDragStart = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.on(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        };
        DPickerColorGradient.prototype.onAnchorMove = function (e) {
            var value = this._value;
            if (value != null) {
                var selected = value.selected;
                if (selected != null) {
                    selected.position = this.toAnchorPosition(e);
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.off(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        };
        DPickerColorGradient.prototype.updateAnchors = function () {
            var theme = this.theme;
            var anchorTexture = theme.getGradientAnchorTexture();
            var anchorOutlinedTexture = theme.getGradientAnchorOutlinedTexture();
            var gradientPointsWidth = theme.getGradientPointsWidth();
            var value = this._value;
            var pointSize = value.points.length;
            var anchors = this._anchors;
            var anchorSize = anchors.length;
            for (var i = anchorSize; i < pointSize; ++i) {
                var newAnchor = new pixi_js.Sprite(anchorTexture);
                newAnchor.anchor.set(0.5, 0.5);
                newAnchor.cursor = "pointer";
                newAnchor.interactive = true;
                newAnchor.on(UtilPointerEvent.down, this._onAnchorDownBound);
                anchors.push(newAnchor);
                this.addChild(newAnchor);
            }
            for (var i = anchorSize - 1; pointSize <= i; --i) {
                var oldAnchor = anchors[i];
                oldAnchor.off(UtilPointerEvent.down, this._onAnchorDownBound);
                oldAnchor.destroy();
            }
            anchors.length = pointSize;
            var y = this.padding.getTop();
            var right = this.padding.getLeft() + gradientPointsWidth;
            var height = this._picker.height;
            for (var i = 0; i < pointSize; ++i) {
                var point = value.points[i];
                var anchor = anchors[i];
                anchor.tint = point.color;
                anchor.position.set(right, y + height * point.position);
                anchor.texture = point.selected ? anchorOutlinedTexture : anchorTexture;
            }
            DApplications.update(this);
        };
        DPickerColorGradient.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isDeleteKey(e)) {
                var value = this._value;
                if (value != null) {
                    var selected = value.selected;
                    if (selected != null) {
                        value.remove(selected);
                        _super.prototype.onKeyDown.call(this, e);
                        return true;
                    }
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DPickerColorGradient.prototype.getType = function () {
            return "DPickerColorGradient";
        };
        DPickerColorGradient.RECENT_COLOR_GRADIENT = null;
        return DPickerColorGradient;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogColorGradient = /** @class */ (function (_super) {
        __extends(DDialogColorGradient, _super);
        function DDialogColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogColorGradient.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            layout.addChild(this.picker);
        };
        DDialogColorGradient.prototype.onOk = function (value) {
            _super.prototype.onOk.call(this, value);
            var picker = this.picker;
            var data = picker.value;
            var recent = picker.recent;
            if (!recent.contains(data)) {
                recent.add(data.toObject());
            }
        };
        Object.defineProperty(DDialogColorGradient.prototype, "value", {
            get: function () {
                return this.picker.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColorGradient.prototype, "recent", {
            get: function () {
                return this.picker.recent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColorGradient.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerColorGradient((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogColorGradient.prototype.getResolvedValue = function () {
            return this.picker.value;
        };
        DDialogColorGradient.prototype.onKeyDown = function (e) {
            this.picker.onKeyDown(e);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDialogColorGradient.prototype.getType = function () {
            return "DDialogColorGradient";
        };
        return DDialogColorGradient;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonColorGradient = /** @class */ (function (_super) {
        __extends(DButtonColorGradient, _super);
        function DButtonColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonColorGradient.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            var source = (_a = options === null || options === void 0 ? void 0 : options.image) === null || _a === void 0 ? void 0 : _a.source;
            if (source === undefined) {
                var theme = this.theme;
                var texture = theme.getViewBaseTexture();
                if (texture instanceof pixi_js.Texture) {
                    var checkers = theme.getCheckerColors();
                    var view = DPickerColorGradientView.from(1, 10, checkers, texture);
                    this._view = view;
                    view.setRectangle(0, 0, 0, texture.width, texture.height);
                    view.setData(0, this._textValueComputed);
                    view.update();
                    this.image = view;
                }
            }
        };
        DButtonColorGradient.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            var value = this._textValueComputed;
            var dialog = this.dialog;
            dialog.value.fromObject(value);
            dialog.open().then(function () {
                var newValue = dialog.value;
                var oldValue = new DColorGradientObservable().fromObject(value);
                value.fromObject(newValue);
                var view = _this._view;
                if (view != null) {
                    view.update();
                }
                _this.onTextChange();
                _this.createOrUpdateText();
                DApplications.update(_this);
                _this.emit("change", newValue, oldValue, _this);
            });
        };
        Object.defineProperty(DButtonColorGradient.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = new DDialogColorGradient(options);
                    }
                    else {
                        if (DButtonColorGradient.DIALOG == null) {
                            DButtonColorGradient.DIALOG = new DDialogColorGradient();
                        }
                        dialog = DButtonColorGradient.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonColorGradient.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColorGradient.prototype.getType = function () {
            return "DButtonColorGradient";
        };
        return DButtonColorGradient;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogColor = /** @class */ (function (_super) {
        __extends(DDialogColor, _super);
        function DDialogColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogColor.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            layout.addChild(this.picker);
        };
        DDialogColor.prototype.onOk = function (value) {
            _super.prototype.onOk.call(this, value);
            var picker = this.picker;
            var recent = picker.recent;
            if (!recent.contains(picker.new)) {
                recent.add(picker.new);
            }
        };
        Object.defineProperty(DDialogColor.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "recent", {
            get: function () {
                return this.picker.recent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerColor((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogColor.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogColor.prototype.getType = function () {
            return "DDialogColor";
        };
        return DDialogColor;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonColor = /** @class */ (function (_super) {
        __extends(DButtonColor, _super);
        function DButtonColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonColor.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var value = this._textValueComputed;
            this._value = new DPickerColorAndAlpha(value, function (color) {
                value.color = color;
                _this.onColorChange();
            }, function (alpha) {
                value.alpha = alpha;
                _this.updateTextForcibly();
            });
        };
        DButtonColor.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            var value = this._textValueComputed;
            var dialog = this.dialog;
            var dialogCurrent = dialog.current;
            var dialogNew = dialog.new;
            dialogCurrent.color = value.color;
            dialogCurrent.alpha = value.alpha;
            dialogNew.color = value.color;
            dialogNew.alpha = value.alpha;
            dialog.open().then(function () {
                value.color = dialogNew.color;
                value.alpha = dialogNew.alpha;
                _this.onColorChange();
                _this.onValueChange(_this.toClone(dialogNew), _this.toClone(dialogCurrent));
            });
        };
        DButtonColor.prototype.toClone = function (value) {
            return {
                color: value.color,
                alpha: value.alpha
            };
        };
        DButtonColor.prototype.onValueChange = function (newValue, oldValue) {
            this.emit("change", newValue, oldValue, this);
        };
        DButtonColor.prototype.toImageTintOptions = function (tint) {
            var _this = this;
            var color = function () { return _this._textValueComputed.color; };
            if (tint) {
                return {
                    color: tint.color || color,
                    alpha: tint.alpha
                };
            }
            return {
                color: color
            };
        };
        DButtonColor.prototype.toImageOptions = function (theme, options) {
            if (options) {
                return {
                    source: options.source,
                    tint: this.toImageTintOptions(options.tint),
                    align: options.align,
                    margin: options.margin
                };
            }
            return {
                tint: this.toImageTintOptions()
            };
        };
        DButtonColor.prototype.onColorChange = function () {
            if (this._images[0].updateTint()) {
                DApplications.update(this);
            }
            this.updateTextForcibly();
        };
        DButtonColor.prototype.updateTextForcibly = function () {
            this.onTextChange();
            this.createOrUpdateText();
        };
        Object.defineProperty(DButtonColor.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = new DDialogColor(options);
                    }
                    else {
                        if (DButtonColor.DIALOG == null) {
                            DButtonColor.DIALOG = new DDialogColor();
                        }
                        dialog = DButtonColor.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonColor.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColor.prototype.getType = function () {
            return "DButtonColor";
        };
        return DButtonColor;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDanger = /** @class */ (function (_super) {
        __extends(DButtonDanger, _super);
        function DButtonDanger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDanger.prototype.getType = function () {
            return "DButtonDanger";
        };
        return DButtonDanger;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDates = /** @class */ (function () {
        function DDialogDates() {
        }
        DDialogDates.getInstance = function () {
            if (DDialogDates.INSTANCE == null) {
                DDialogDates.INSTANCE = new DDialogDate();
            }
            return DDialogDates.INSTANCE;
        };
        return DDialogDates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDate = /** @class */ (function (_super) {
        __extends(DButtonDate, _super);
        function DButtonDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDate.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this._textValueComputed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open().then(function () {
                var newValue = dialog.new;
                var oldValue = dialog.current;
                _this.text = new Date(newValue.getTime());
                _this.emit("change", newValue, oldValue, _this);
            });
        };
        Object.defineProperty(DButtonDate.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = new DDialogDate(options);
                    }
                    else {
                        dialog = DDialogDates.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonDate.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : new Date();
            },
            set: function (value) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed === undefined || textValueComputed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonDate.prototype.getType = function () {
            return "DButtonDate";
        };
        return DButtonDate;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDatetimes = /** @class */ (function () {
        function DDialogDatetimes() {
        }
        DDialogDatetimes.getInstance = function () {
            if (DDialogDatetimes.INSTANCE == null) {
                DDialogDatetimes.INSTANCE = new DDialogDatetime();
            }
            return DDialogDatetimes.INSTANCE;
        };
        return DDialogDatetimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDates = /** @class */ (function () {
        function DPickerDates() {
        }
        DPickerDates.format = function (date) {
            var y = toPadded(String(date.getFullYear()), 4, "0");
            var M = toPadded(String(date.getMonth() + 1), 2, "0");
            var S = toPadded(String(date.getDate()), 2, "0");
            return y + "/" + M + "/" + S;
        };
        return DPickerDates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimes = /** @class */ (function () {
        function DPickerTimes() {
        }
        DPickerTimes.format = function (date, mask) {
            var result = "";
            if (mask & DPickerDatetimeMask.HOURS) {
                result += toPadded(String(date.getHours()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getMinutes()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getSeconds()), 2, "0");
            }
            return result;
        };
        DPickerTimes.toMask = function (options) {
            return DPickerDatetimeMasks.from("DPickerTime", options);
        };
        return DPickerTimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimes = /** @class */ (function () {
        function DPickerDatetimes() {
        }
        DPickerDatetimes.format = function (date, mask) {
            var hms = DPickerTimes.format(date, mask);
            if (0 < hms.length) {
                return DPickerDates.format(date) + " " + hms;
            }
            else {
                return "" + DPickerDates.format(date);
            }
        };
        DPickerDatetimes.toMask = function (options) {
            return DPickerDatetimeMasks.from("DPickerDatetime", options);
        };
        return DPickerDatetimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDatetime = /** @class */ (function (_super) {
        __extends(DButtonDatetime, _super);
        function DButtonDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDatetime.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this._textValueComputed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open().then(function () {
                var newValue = dialog.new;
                var oldValue = dialog.current;
                _this.text = new Date(newValue.getTime());
                _this.emit("change", newValue, oldValue, _this);
            });
        };
        DButtonDatetime.prototype.getDatetimeMask = function () {
            var _a, _b;
            var result = this._datetimeMask;
            if (result == null) {
                result = DPickerDatetimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        };
        Object.defineProperty(DButtonDatetime.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = new DDialogDatetime(options);
                    }
                    else {
                        dialog = DDialogDatetimes.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonDatetime.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : new Date();
            },
            set: function (value) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed === undefined || textValueComputed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonDatetime.prototype.getType = function () {
            return "DButtonDatetime";
        };
        return DButtonDatetime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonFileAs = UtilFileAs;
    /**
     * A file selector.
     */
    var DButtonFile = /** @class */ (function (_super) {
        __extends(DButtonFile, _super);
        function DButtonFile() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonFile.prototype.getChecker = function () {
            var _a, _b;
            var result = this._checker;
            if (result === undefined) {
                result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.checker) !== null && _b !== void 0 ? _b : null;
                this._checker = result;
            }
            return result;
        };
        DButtonFile.prototype.getOpener = function () {
            var result = this._opener;
            if (result == null) {
                result = this.newOpener();
                this._opener = result;
            }
            return result;
        };
        DButtonFile.prototype.newOpener = function () {
            var _a, _b;
            return new UtilFileOpener(toEnum((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.as) !== null && _b !== void 0 ? _b : DButtonFileAs.TEXT, DButtonFileAs), this);
        };
        DButtonFile.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            this.check(function () {
                _this.open();
            });
        };
        DButtonFile.prototype.check = function (onResolve) {
            var checker = this.getChecker();
            if (checker != null) {
                var result = checker();
                if (result === true) {
                    onResolve();
                }
                else if (result === false) ;
                else {
                    result.then(function () {
                        onResolve();
                    });
                }
            }
            else {
                onResolve();
            }
        };
        DButtonFile.prototype.open = function () {
            this.getOpener().open();
        };
        DButtonFile.prototype.getType = function () {
            return "DButtonFile";
        };
        return DButtonFile;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonLink = /** @class */ (function (_super) {
        __extends(DButtonLink, _super);
        function DButtonLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonLink.prototype.initOnClick = function (when, theme, options) {
            var _this = this;
            var link = new DLink(theme, options);
            this._link = link;
            link.add(this, function (e) {
                if (when === DButtonBaseWhen.CLICKED) {
                    _this.onClick(e);
                }
            });
        };
        Object.defineProperty(DButtonLink.prototype, "link", {
            get: function () {
                return this._link;
            },
            enumerable: false,
            configurable: true
        });
        DButtonLink.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this._link.open(e);
        };
        DButtonLink.prototype.open = function (inNewWindow) {
            this._link.open(inNewWindow);
        };
        DButtonLink.prototype.getType = function () {
            return "DButtonLink";
        };
        return DButtonLink;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRadio = /** @class */ (function (_super) {
        __extends(DButtonRadio, _super);
        function DButtonRadio() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonRadio.prototype.getType = function () {
            return "DButtonRadio";
        };
        return DButtonRadio;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRadioRight = /** @class */ (function (_super) {
        __extends(DButtonRadioRight, _super);
        function DButtonRadioRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonRadioRight.prototype.getType = function () {
            return "DButtonRadioRight";
        };
        return DButtonRadioRight;
    }(DButtonRadio));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRedo = /** @class */ (function (_super) {
        __extends(DButtonRedo, _super);
        function DButtonRedo(options) {
            var _this = _super.call(this, options) || this;
            var state = _this.state;
            var commandController = DControllers.getCommandController();
            state.isDisabled = !commandController.isRedoable();
            commandController.on("change", function () {
                state.isDisabled = !commandController.isRedoable();
            });
            return _this;
        }
        DButtonRedo.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            DControllers.getCommandController().redo();
        };
        return DButtonRedo;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonSecondary = /** @class */ (function (_super) {
        __extends(DButtonSecondary, _super);
        function DButtonSecondary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonSecondary.prototype.getType = function () {
            return "DButtonSecondary";
        };
        return DButtonSecondary;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionType;
    (function (DListDataSelectionType) {
        DListDataSelectionType[DListDataSelectionType["NONE"] = 0] = "NONE";
        DListDataSelectionType[DListDataSelectionType["SINGLE"] = 1] = "SINGLE";
        DListDataSelectionType[DListDataSelectionType["MULTIPLE"] = 2] = "MULTIPLE";
    })(DListDataSelectionType || (DListDataSelectionType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItem = /** @class */ (function (_super) {
        __extends(DListItem, _super);
        function DListItem(data, options) {
            var _this = _super.call(this, options) || this;
            _this._data = data;
            _this.state.isDisabled = true;
            return _this;
        }
        DListItem.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.initOnClick(options);
        };
        DListItem.prototype.initOnClick = function (options) {
            var _this = this;
            UtilPointerEvent.onClick(this, function (e) {
                if (_this.state.isActionable) {
                    var value = _this._value;
                    if (value !== undefined) {
                        _this.onSelect(e, value);
                    }
                }
            });
        };
        Object.defineProperty(DListItem.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListItem.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        DListItem.prototype.onSelect = function (e, value) {
            var data = this._data;
            var selection = data.selection;
            if (selection.type !== DListDataSelectionType.MULTIPLE) {
                selection.clearAndAdd(value);
            }
            else {
                var originalEvent = e && "data" in e ? e.data.originalEvent : e;
                if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.ctrlKey) {
                    selection.toggle(value);
                }
                else if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.shiftKey) {
                    var mapped = data.mapped;
                    var last_1 = selection.last;
                    if (value === last_1) {
                        selection.clearAndAdd(value);
                    }
                    else {
                        var isFound_1 = false;
                        var isReverse_1 = false;
                        var newSelection_1 = [];
                        mapped.each(function (item) {
                            if (isFound_1) {
                                if (isReverse_1) {
                                    newSelection_1.unshift(item);
                                    if (item === value) {
                                        return false;
                                    }
                                }
                                else {
                                    newSelection_1.push(item);
                                    if (item === last_1) {
                                        return false;
                                    }
                                }
                            }
                            else {
                                if (item === value) {
                                    isFound_1 = true;
                                    isReverse_1 = false;
                                    newSelection_1.push(item);
                                }
                                else if (item === last_1) {
                                    isFound_1 = true;
                                    isReverse_1 = true;
                                    newSelection_1.push(item);
                                }
                            }
                        });
                        selection.clearAndAddAll(newSelection_1);
                    }
                }
                else {
                    selection.clearAndAdd(value);
                }
            }
        };
        DListItem.prototype.set = function (value, index, forcibly) {
            var data = this._data;
            var isValueChanged = forcibly || this._value !== value;
            if (isValueChanged) {
                this._value = value;
                this._index = index;
                var accessor = data.accessor;
                this.text = accessor.toLabel(value);
                this.title = accessor.toTitle(value) || "";
                this.image = accessor.toImage(value);
            }
            var state = this.state;
            state.lock();
            state.set(DBaseState.ACTIVE, data.selection.contains(value));
            state.remove(DBaseState.DISABLED);
            state.unlock();
            if (isValueChanged) {
                this.emit("set", value, index, this);
            }
        };
        DListItem.prototype.unset = function () {
            if (this._value !== undefined) {
                this._value = undefined;
                this._index = undefined;
                this.text = undefined;
                this.title = "";
                this.image = undefined;
                var state = this.state;
                state.lock();
                state.add(DBaseState.DISABLED);
                state.remove(DBaseState.ACTIVE);
                state.unlock();
                this.emit("unset", this);
            }
        };
        DListItem.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DListItem.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                var value = this._value;
                if (value !== undefined) {
                    this.onSelect(e, value);
                }
                return true;
            }
            return false;
        };
        DListItem.prototype.getType = function () {
            return "DListItem";
        };
        return DListItem;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectListItem = /** @class */ (function (_super) {
        __extends(DDialogSelectListItem, _super);
        function DDialogSelectListItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelectListItem.prototype.getType = function () {
            return "DDialogSelectListItem";
        };
        return DDialogSelectListItem;
    }(DListItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * The primary purpose of this class is to minimize the number of rendered items (e.g., {@link DListItem})
     * as low as possible and to update their positions and states. For this sake, the updater calculates the
     * required number of items whenever their container size changes and creates items if needed.
     */
    var DItemUpdater = /** @class */ (function () {
        function DItemUpdater(data, content, container, options) {
            this._updateItemsCount = 0;
            this._isUpdateItemsCalled = false;
            this._isUpdateItemsCalledForcibly = false;
            this._itemHeight = -1;
            this._itemWidth = -1;
            this._multiplicity = 1;
            this._itemIndexStart = 0;
            this._itemIndexEnd = 0;
            this._workItems = [];
            this._data = data;
            this._content = content;
            this._container = container;
            this._newItem = this.toNewItem(options);
        }
        DItemUpdater.prototype.toNewItem = function (options) {
            return (options === null || options === void 0 ? void 0 : options.newItem) || this.newItem;
        };
        Object.defineProperty(DItemUpdater.prototype, "multiplicity", {
            get: function () {
                return this._multiplicity;
            },
            enumerable: false,
            configurable: true
        });
        DItemUpdater.prototype.lock = function () {
            this._updateItemsCount += 1;
            if (this._updateItemsCount === 1) {
                this._isUpdateItemsCalled = false;
                this._isUpdateItemsCalledForcibly = false;
            }
        };
        DItemUpdater.prototype.unlock = function (callIfNeeded) {
            this._updateItemsCount -= 1;
            if (this._updateItemsCount === 0) {
                if (callIfNeeded && this._isUpdateItemsCalled) {
                    this.update(this._isUpdateItemsCalledForcibly);
                }
                this._isUpdateItemsCalled = false;
                this._isUpdateItemsCalledForcibly = false;
            }
        };
        DItemUpdater.prototype.update = function (forcibly) {
            var _this = this;
            if (0 < this._updateItemsCount) {
                this._isUpdateItemsCalled = true;
                if (forcibly) {
                    this._isUpdateItemsCalledForcibly = true;
                }
                return;
            }
            var content = this._content;
            var container = this._container;
            var items = container.children;
            var height = content.parent.height;
            var data = this._data;
            var mapped = this.toMapped(data);
            var dataSize = mapped.size();
            var oldItemIndexStart = this._itemIndexStart;
            var oldItemIndexEnd = this._itemIndexEnd;
            var oldItemCount = oldItemIndexEnd - oldItemIndexStart;
            var newItem = this._newItem;
            var itemHeight = this._itemHeight;
            var itemWidth = this._itemWidth;
            if (this._itemHeight < 0) {
                var item = void 0;
                if (0 < items.length) {
                    item = items[0];
                }
                else {
                    item = newItem(data);
                    item.state.isAlternated = oldItemIndexStart % 2 === 0;
                    container.addChild(item);
                    oldItemIndexEnd += 1;
                    oldItemCount += 1;
                }
                itemHeight = Math.max(1, item.height);
                if (isNumber(item.getWidth())) {
                    itemWidth = Math.max(1, item.width);
                }
                this._itemHeight = itemHeight;
                this._itemWidth = itemWidth;
            }
            var multiplicity = 0 < itemWidth ? Math.max(1, Math.floor(content.width / itemWidth)) : 1;
            this._multiplicity = multiplicity;
            var y = content !== container ? container.transform.position.y : 0;
            var newHeight = Math.ceil(dataSize / multiplicity) * itemHeight;
            var newContentHeight = Math.max(height, newHeight);
            var newContentY = Math.max(height - newContentHeight, content.position.y);
            var newItemIndexLowerBound = Math.floor(((0 - (newContentY + y)) * multiplicity) / itemHeight);
            var newItemIndexUpperBound = Math.floor(((height - (newContentY + y)) * multiplicity) / itemHeight);
            var newItemIndexStart = newItemIndexLowerBound - multiplicity;
            if (newItemIndexStart % 2 !== 0) {
                newItemIndexStart -= 1;
            }
            var newItemIndexEnd = newItemIndexUpperBound + multiplicity + multiplicity;
            if (newItemIndexEnd % 2 !== 0) {
                newItemIndexEnd += 1;
            }
            var newItemCount = newItemIndexEnd - newItemIndexStart;
            if (newItemCount < oldItemCount && oldItemCount - 2 <= newItemCount) {
                newItemCount = oldItemCount;
                newItemIndexEnd = newItemIndexStart + newItemCount;
            }
            if (oldItemCount < newItemCount) {
                for (var i = oldItemCount; i < newItemCount; ++i) {
                    var oldItemIndex = oldItemIndexStart + i;
                    var item = newItem(data);
                    item.state.isAlternated = oldItemIndex % 2 === 0;
                    container.addChild(item);
                }
                oldItemCount = newItemCount;
                oldItemIndexEnd = oldItemIndexStart + oldItemCount;
            }
            else if (newItemCount < oldItemCount) {
                for (var i = oldItemCount - 1; newItemCount <= i; --i) {
                    container.removeChild(items[i]);
                }
                oldItemCount = newItemCount;
                oldItemIndexEnd = oldItemIndexStart + oldItemCount;
            }
            this._itemIndexStart = newItemIndexStart;
            this._itemIndexEnd = newItemIndexEnd;
            var itemIndexStartDelta = newItemIndexStart - oldItemIndexStart;
            var itemIndexStartDeltaAbs = Math.abs(itemIndexStartDelta);
            var itemsLength = items.length;
            if (0 < itemIndexStartDeltaAbs && itemIndexStartDeltaAbs < itemsLength) {
                var work = this._workItems;
                if (0 < itemIndexStartDelta) {
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        var item = items[i];
                        this.reset(item);
                        work.push(item);
                    }
                    for (var i = itemIndexStartDeltaAbs; i < itemsLength; ++i) {
                        items[i - itemIndexStartDeltaAbs] = items[i];
                    }
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        items[itemsLength - itemIndexStartDeltaAbs + i] = work[i];
                    }
                }
                else {
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        var item = items[itemsLength - itemIndexStartDeltaAbs + i];
                        this.reset(item);
                        work.push(item);
                    }
                    for (var i = itemsLength - itemIndexStartDeltaAbs - 1; 0 <= i; --i) {
                        items[i + itemIndexStartDeltaAbs] = items[i];
                    }
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        items[i] = work[i];
                    }
                }
                work.length = 0;
            }
            mapped.each(function (datum, index) {
                var item = items[index - newItemIndexStart];
                var ix = index % multiplicity;
                var iy = Math.floor(index / multiplicity);
                item.position.set(ix * itemWidth, iy * itemHeight);
                _this.set(item, datum, index, forcibly);
            }, newItemIndexStart, newItemIndexStart + itemsLength);
            for (var i = 0; newItemIndexStart + i < 0 && i < itemsLength; ++i) {
                var item = items[i];
                var index = newItemIndexStart + i;
                var ix = index % multiplicity;
                var iy = Math.floor(index / multiplicity);
                item.position.set(ix * itemWidth, iy * itemHeight);
                this.unset(item);
            }
            for (var i = itemsLength - 1; dataSize <= newItemIndexStart + i && 0 <= i; --i) {
                var item = items[i];
                var index = newItemIndexStart + i;
                var ix = index % multiplicity;
                var iy = Math.floor(index / multiplicity);
                item.position.set(ix * itemWidth, iy * itemHeight);
                this.unset(item);
            }
            this.lock();
            content.position.y = newContentY;
            content.height = newContentHeight;
            if (content !== container) {
                container.height = newHeight;
            }
            this.unlock(false);
        };
        DItemUpdater.prototype.set = function (item, value, index, forcibly) {
            item.set(value, index, forcibly);
        };
        DItemUpdater.prototype.unset = function (item) {
            item.unset();
        };
        DItemUpdater.prototype.reset = function (item) {
            item.blur(true);
            var cells = item.children;
            for (var i = 0, imax = cells.length; i < imax; ++i) {
                var cell = cells[i];
                if (cell instanceof DBase) {
                    cell.state.isPressed = false;
                }
            }
            return item;
        };
        DItemUpdater.prototype.moveFocus = function (e, target, moveVertically, moveHorizontally) {
            if (!(moveVertically || moveHorizontally)) {
                return false;
            }
            var isUp = moveVertically && UtilKeyboardEvent.isArrowUpKey(e);
            var isDown = moveVertically && UtilKeyboardEvent.isArrowDownKey(e);
            var isLeft = moveHorizontally && UtilKeyboardEvent.isArrowLeftKey(e);
            var isRight = moveHorizontally && UtilKeyboardEvent.isArrowRightKey(e);
            if (!(isUp || isDown || isLeft || isRight)) {
                return false;
            }
            if (!target.state.isActionable) {
                return false;
            }
            var layer = DApplications.getLayer(target);
            if (layer == null) {
                return false;
            }
            var focusController = layer.getFocusController();
            var focused = focusController.get();
            if (focused == null) {
                return false;
            }
            var container = this._container;
            if (focused.parent !== container) {
                return false;
            }
            var item = focused;
            var index = item.index;
            if (index == null) {
                return false;
            }
            var multiplicity = this._multiplicity;
            var data = this._data;
            var mapped = this.toMapped(data);
            var dataSize = mapped.size();
            var newIndex = index;
            if (isLeft || isRight) {
                if (isLeft) {
                    if (0 <= newIndex - 1) {
                        newIndex -= 1;
                    }
                }
                else {
                    if (newIndex + 1 < dataSize) {
                        newIndex += 1;
                    }
                }
            }
            if (isUp || isDown) {
                if (isUp) {
                    if (0 <= newIndex - multiplicity) {
                        newIndex -= multiplicity;
                    }
                }
                else {
                    if (newIndex + multiplicity < dataSize) {
                        newIndex += multiplicity;
                    }
                }
            }
            if (newIndex === index) {
                return false;
            }
            var items = container.children;
            var itemIndex = items.indexOf(item);
            if (itemIndex < 0) {
                return false;
            }
            var newItemIndex = itemIndex + (newIndex - index);
            if (newItemIndex < 0 || items.length <= newItemIndex) {
                return false;
            }
            var newItem = items[newItemIndex];
            focusController.focus(newItem);
            return true;
        };
        return DItemUpdater;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItemUpdater = /** @class */ (function (_super) {
        __extends(DListItemUpdater, _super);
        function DListItemUpdater() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DListItemUpdater.prototype.toMapped = function (data) {
            return data.mapped;
        };
        DListItemUpdater.prototype.newItem = function (data) {
            return new DListItem(data);
        };
        return DListItemUpdater;
    }(DItemUpdater));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectListItemUpdater = /** @class */ (function (_super) {
        __extends(DDialogSelectListItemUpdater, _super);
        function DDialogSelectListItemUpdater() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelectListItemUpdater.prototype.newItem = function (data) {
            return new DDialogSelectListItem(data);
        };
        return DDialogSelectListItemUpdater;
    }(DListItemUpdater));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataMappedImpl = /** @class */ (function () {
        function DListDataMappedImpl(parent) {
            this._parent = parent;
        }
        DListDataMappedImpl.prototype.size = function () {
            var parent = this._parent;
            return parent.before.length + parent.items.length + parent.after.length;
        };
        DListDataMappedImpl.prototype.each = function (iteratee, from, to) {
            var parent = this._parent;
            var index0 = this.each_(iteratee, parent.before, 0, from, to);
            if (index0 < 0) {
                return;
            }
            var index1 = this.each_(iteratee, parent.items, index0, from, to);
            if (index1 < 0) {
                return;
            }
            this.each_(iteratee, parent.after, index1, from, to);
        };
        DListDataMappedImpl.prototype.each_ = function (iteratee, items, start, from, to) {
            var end = start + items.length;
            var ifrom = from != null ? Math.max(start, from) : start;
            var ito = to != null ? Math.min(end, to) : end;
            for (var i = ifrom; i < ito; ++i) {
                if (iteratee(items[i - start], i) === false) {
                    return -1;
                }
            }
            return ito;
        };
        return DListDataMappedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionMultiple = /** @class */ (function (_super) {
        __extends(DListDataSelectionMultiple, _super);
        function DListDataSelectionMultiple(parent, accessor, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._accessor = accessor;
            _this._items = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DListDataSelectionMultiple.prototype, "type", {
            get: function () {
                return DListDataSelectionType.MULTIPLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionMultiple.prototype, "first", {
            get: function () {
                return this.get(0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionMultiple.prototype, "last", {
            get: function () {
                return this.get(this.size() - 1);
            },
            enumerable: false,
            configurable: true
        });
        DListDataSelectionMultiple.prototype.get = function (index) {
            var items = this._items;
            if (0 <= index && index < items.size) {
                var counter_1 = 0;
                var result_1 = null;
                items.forEach(function (item) {
                    if (counter_1 === index) {
                        result_1 = item;
                    }
                    counter_1 += 1;
                });
                return result_1;
            }
            return null;
        };
        DListDataSelectionMultiple.prototype.add = function (target) {
            var items = this._items;
            if (!items.has(target)) {
                items.add(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionMultiple.prototype.remove = function (target) {
            var items = this._items;
            if (items.has(target)) {
                items.delete(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionMultiple.prototype.toggle = function (target) {
            var items = this._items;
            if (items.has(target)) {
                items.delete(target);
            }
            else {
                items.add(target);
            }
            this.onChange();
            return true;
        };
        DListDataSelectionMultiple.prototype.clear = function () {
            var items = this._items;
            if (0 < items.size) {
                items.clear();
                this.onChange();
            }
        };
        DListDataSelectionMultiple.prototype.clearAndAdd = function (target) {
            var items = this._items;
            var size = items.size;
            if (size === 1) {
                if (items.has(target)) {
                    return false;
                }
                else {
                    items.clear();
                    items.add(target);
                    this.onChange();
                    return true;
                }
            }
            else {
                items.clear();
                items.add(target);
                this.onChange();
                return true;
            }
        };
        DListDataSelectionMultiple.prototype.clearAndAddAll = function (targets) {
            var isDirty = false;
            var newNodes = new Set();
            var oldNodes = this._items;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var target = targets[i];
                if (!oldNodes.has(target)) {
                    isDirty = true;
                }
                newNodes.add(target);
            }
            if (!isDirty) {
                oldNodes.forEach(function (oldItem) {
                    if (!newNodes.has(oldItem)) {
                        isDirty = true;
                    }
                });
            }
            if (isDirty) {
                this._items = newNodes;
                this.onChange();
            }
            return isDirty;
        };
        DListDataSelectionMultiple.prototype.contains = function (target) {
            return this._items.has(target);
        };
        DListDataSelectionMultiple.prototype.size = function () {
            return this._items.size;
        };
        DListDataSelectionMultiple.prototype.isEmpty = function () {
            return this.size() <= 0;
        };
        DListDataSelectionMultiple.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._items.forEach(function (item) {
                if (!isCanceled) {
                    if (iteratee(item) === false) {
                        isCanceled = true;
                    }
                }
            });
        };
        DListDataSelectionMultiple.prototype.toArray = function () {
            var result = [];
            this._items.forEach(function (item) {
                result.push(item);
            });
            return result;
        };
        DListDataSelectionMultiple.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DListDataSelectionMultiple.prototype.toItemIdMap = function (items, toId, result) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                result.set(toId(item), item);
            }
        };
        DListDataSelectionMultiple.prototype.toItemSet = function (items, result) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                result.add(items[i]);
            }
        };
        DListDataSelectionMultiple.prototype.onItemChange = function (before, items, after) {
            var oldItems = this._items;
            var newItems = new Set();
            var toId = this._accessor.toId;
            if (toId) {
                var newItemIdMap_1 = new Map();
                this.toItemIdMap(before, toId, newItemIdMap_1);
                this.toItemIdMap(items, toId, newItemIdMap_1);
                this.toItemIdMap(after, toId, newItemIdMap_1);
                oldItems.forEach(function (oldItem) {
                    var oldItemId = toId(oldItem);
                    var newItem = newItemIdMap_1.get(oldItemId);
                    if (newItem != null) {
                        newItems.add(newItem);
                    }
                });
                this._items = newItems;
                this.onChange();
            }
            else {
                var newItemSet_1 = new Set();
                this.toItemSet(before, newItemSet_1);
                this.toItemSet(items, newItemSet_1);
                this.toItemSet(after, newItemSet_1);
                oldItems.forEach(function (oldItem) {
                    if (newItemSet_1.has(oldItem)) {
                        newItems.add(oldItem);
                    }
                });
                if (oldItems.size !== newItems.size) {
                    this._items = newItems;
                    this.onChange();
                }
            }
        };
        DListDataSelectionMultiple.prototype.newItems = function (items, existing, result) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (existing.has(item)) {
                    result.add(item);
                }
            }
            return result;
        };
        return DListDataSelectionMultiple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionNone = /** @class */ (function (_super) {
        __extends(DListDataSelectionNone, _super);
        function DListDataSelectionNone(parent, accessor, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DListDataSelectionNone.prototype, "type", {
            get: function () {
                return DListDataSelectionType.NONE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionNone.prototype, "first", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionNone.prototype, "last", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DListDataSelectionNone.prototype.get = function (index) {
            return null;
        };
        DListDataSelectionNone.prototype.add = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.remove = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.toggle = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.clear = function () {
            // DO NOTHING
        };
        DListDataSelectionNone.prototype.clearAndAdd = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.clearAndAddAll = function (targets) {
            return false;
        };
        DListDataSelectionNone.prototype.contains = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.size = function () {
            return 0;
        };
        DListDataSelectionNone.prototype.isEmpty = function () {
            return true;
        };
        DListDataSelectionNone.prototype.each = function (iteratee) {
            // DO NOTHING
        };
        DListDataSelectionNone.prototype.toArray = function () {
            return [];
        };
        DListDataSelectionNone.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DListDataSelectionNone.prototype.onItemChange = function (before, items, after) {
            // DO NOTHING
        };
        return DListDataSelectionNone;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionSingle = /** @class */ (function (_super) {
        __extends(DListDataSelectionSingle, _super);
        function DListDataSelectionSingle(parent, accessor, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._accessor = accessor;
            _this._item = null;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DListDataSelectionSingle.prototype, "type", {
            get: function () {
                return DListDataSelectionType.SINGLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionSingle.prototype, "first", {
            get: function () {
                return this._item;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionSingle.prototype, "last", {
            get: function () {
                return this.get(this.size() - 1);
            },
            enumerable: false,
            configurable: true
        });
        DListDataSelectionSingle.prototype.get = function (index) {
            if (0 === index) {
                return this._item;
            }
            return null;
        };
        DListDataSelectionSingle.prototype.add = function (target) {
            if (this._item !== target) {
                this._item = target;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionSingle.prototype.remove = function (target) {
            if (this._item === target) {
                this._item = null;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionSingle.prototype.toggle = function (target) {
            if (this._item === target) {
                this._item = null;
            }
            else {
                this._item = target;
            }
            this.onChange();
            return true;
        };
        DListDataSelectionSingle.prototype.clear = function () {
            if (this._item != null) {
                this._item = null;
                this.onChange();
            }
        };
        DListDataSelectionSingle.prototype.clearAndAdd = function (target) {
            if (this._item !== target) {
                this._item = target;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionSingle.prototype.clearAndAddAll = function (targets) {
            var targetsLength = targets.length;
            if (0 < targetsLength) {
                var last = targets[targetsLength - 1];
                if (this._item !== last) {
                    this._item = last;
                    this.onChange();
                    return true;
                }
            }
            else {
                if (this._item != null) {
                    this._item = null;
                    this.onChange();
                    return true;
                }
            }
            return false;
        };
        DListDataSelectionSingle.prototype.contains = function (target) {
            return this._item === target;
        };
        DListDataSelectionSingle.prototype.size = function () {
            return this._item != null ? 1 : 0;
        };
        DListDataSelectionSingle.prototype.isEmpty = function () {
            return this.size() <= 0;
        };
        DListDataSelectionSingle.prototype.each = function (iteratee) {
            var item = this._item;
            if (item != null) {
                iteratee(item);
            }
        };
        DListDataSelectionSingle.prototype.toArray = function () {
            var item = this._item;
            if (item != null) {
                return [item];
            }
            return [];
        };
        DListDataSelectionSingle.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DListDataSelectionSingle.prototype.findById = function (id, toId, items) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                var itemId = toId(item);
                if (id === itemId) {
                    return item;
                }
            }
            return null;
        };
        DListDataSelectionSingle.prototype.find = function (target, items) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (target === item) {
                    return item;
                }
            }
            return null;
        };
        DListDataSelectionSingle.prototype.onItemChange = function (before, items, after) {
            var oldItem = this._item;
            if (oldItem == null) {
                return;
            }
            var newItem = null;
            var toId = this._accessor.toId;
            if (toId) {
                var oldItemId = toId(oldItem);
                newItem =
                    this.findById(oldItemId, toId, before) ||
                        this.findById(oldItemId, toId, items) ||
                        this.findById(oldItemId, toId, after);
            }
            else {
                newItem =
                    this.find(oldItem, before) ||
                        this.find(oldItem, items) ||
                        this.find(oldItem, after);
            }
            if (oldItem !== newItem) {
                this._item = newItem;
                this.onChange();
            }
        };
        return DListDataSelectionSingle;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toImage = function (value) {
        return value.image;
    };
    var toTitle = function (value) {
        return value.title;
    };
    var DListItemAccessorImpl = /** @class */ (function () {
        function DListItemAccessorImpl(options) {
            this.toLabel = (options === null || options === void 0 ? void 0 : options.toLabel) || toLabel;
            this.toTitle = (options === null || options === void 0 ? void 0 : options.toTitle) || toTitle;
            this.toImage = (options === null || options === void 0 ? void 0 : options.toImage) || toImage;
            this.toId = options === null || options === void 0 ? void 0 : options.toId;
        }
        return DListItemAccessorImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataImpl = /** @class */ (function () {
        function DListDataImpl(parent, options) {
            this._parent = parent;
            if (options) {
                this._before = options.before || [];
                this._items = options.items || [];
                this._after = options.after || [];
            }
            else {
                this._before = [];
                this._items = [];
                this._after = [];
            }
            var accessor = new DListItemAccessorImpl(options);
            this._accessor = accessor;
            this._selection = this.toSelection(accessor, options);
            this._mapped = new DListDataMappedImpl(this);
        }
        DListDataImpl.prototype.toSelection = function (accessor, options) {
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            switch (selection === null || selection === void 0 ? void 0 : selection.type) {
                case DListDataSelectionType.NONE:
                case "NONE":
                    return new DListDataSelectionNone(this, accessor, selection);
                case DListDataSelectionType.MULTIPLE:
                case "MULTIPLE":
                    return new DListDataSelectionMultiple(this, accessor, selection);
                default:
                    return new DListDataSelectionSingle(this, accessor, selection);
            }
        };
        Object.defineProperty(DListDataImpl.prototype, "before", {
            get: function () {
                return this._before;
            },
            set: function (before) {
                this._before = before;
                this._selection.onItemChange(before, this._items, this._after);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (items) {
                this._items = items;
                this._selection.onItemChange(this._before, items, this._after);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "after", {
            get: function () {
                return this._after;
            },
            set: function (after) {
                this._after = after;
                this._selection.onItemChange(this._before, this._items, after);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "accessor", {
            get: function () {
                return this._accessor;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DListDataImpl.prototype.update = function (forcibly) {
            this._parent.update(forcibly);
        };
        DListDataImpl.prototype.size = function () {
            return this._items.length;
        };
        DListDataImpl.prototype.clear = function () {
            var items = this._items;
            if (0 < items.length) {
                items.length = 0;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataImpl.prototype.clearAndAdd = function (item) {
            var items = this._items;
            if (items.length === 1) {
                var first = items[0];
                if (first === item) {
                    return false;
                }
                else {
                    items[0] = item;
                    this.onChange();
                    return true;
                }
            }
            else {
                items.length = 0;
                items.push(item);
                this.onChange();
                return true;
            }
        };
        DListDataImpl.prototype.clearAndAddAll = function (newItems) {
            var isChanged = false;
            var items = this._items;
            if (0 < items.length) {
                items.length = 0;
                isChanged = true;
            }
            if (0 < newItems.length) {
                for (var i = 0, imax = newItems.length; i < imax; ++i) {
                    items.push(newItems[i]);
                }
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataImpl.prototype.add = function (item, index) {
            var items = this._items;
            if (index == null) {
                items.push(item);
                this.onChange();
                return true;
            }
            else if (0 <= index && index < items.length) {
                items.splice(index, 0, item);
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataImpl.prototype.addAll = function (newItems, index) {
            if (0 < newItems.length) {
                var items = this._items;
                var itemsLength = items.length;
                if (index == null) {
                    for (var i = 0, imax = newItems.length; i < imax; ++i) {
                        items.push(newItems[i]);
                    }
                    this.onChange();
                    return true;
                }
                else if (0 <= index && index < itemsLength) {
                    for (var i = 0, imax = newItems.length; i < imax; ++i) {
                        items.splice(index + i, 0, newItems[i]);
                    }
                    this.onChange();
                    return true;
                }
            }
            return false;
        };
        DListDataImpl.prototype.get = function (index) {
            var items = this._items;
            if (0 <= index && index < items.length) {
                return items[index];
            }
            return null;
        };
        DListDataImpl.prototype.set = function (index, item) {
            var items = this._items;
            if (0 <= index && index < items.length) {
                var result = items[index];
                items[index] = item;
                this.onChange();
                return result;
            }
            return null;
        };
        DListDataImpl.prototype.remove = function (index) {
            var items = this._items;
            if (0 <= index && index < items.length) {
                var result = items.splice(index, 1)[0];
                this.onChange();
                return result;
            }
            return null;
        };
        DListDataImpl.prototype.each = function (iteratee, from, to) {
            var items = this._items;
            var size = items.length;
            var ifrom = from != null ? Math.max(0, from) : 0;
            var ito = to != null ? Math.min(size, to) : size;
            for (var i = ifrom; i < ito; ++i) {
                if (iteratee(items[i], i) === false) {
                    break;
                }
            }
        };
        DListDataImpl.prototype.onChange = function () {
            this.update();
        };
        return DListDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DContent = /** @class */ (function (_super) {
        __extends(DContent, _super);
        function DContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DContent.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
        };
        DContent.prototype.initReflowable = function () {
            // DO NOTHING
        };
        DContent.prototype.getType = function () {
            return "DContent";
        };
        return DContent;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBar = /** @class */ (function (_super) {
        __extends(DScrollBar, _super);
        function DScrollBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBar.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._start = 0;
            this._end = 1;
            var thumb = (this._thumb = this.createThumb(options === null || options === void 0 ? void 0 : options.thumb));
            this.addChild(thumb);
            this.state.isFocusable = false;
        };
        Object.defineProperty(DScrollBar.prototype, "thumb", {
            get: function () {
                return this._thumb;
            },
            enumerable: false,
            configurable: true
        });
        DScrollBar.prototype.getType = function () {
            return "DScrollBar";
        };
        DScrollBar.prototype.setRegion = function (start, end, size) {
            if (size < 1) {
                start = 0;
                end = 1;
            }
            else {
                start = Math.max(0, Math.min(1, start / size));
                end = Math.max(start, Math.min(1, end / size));
            }
            if (this._start !== start || this._end !== end) {
                this._start = start;
                this._end = end;
                this.onRegionChange();
            }
        };
        DScrollBar.prototype.isRegionVisible = function () {
            return 0 < this._start || this._end < 1;
        };
        DScrollBar.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.onRegionChange();
        };
        DScrollBar.prototype.onRegionChange = function () {
            // DO NOTHING
        };
        DScrollBar.prototype.getRegionStart = function () {
            return this._start;
        };
        DScrollBar.prototype.getRegionEnd = function () {
            return this._end;
        };
        return DScrollBar;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumb = /** @class */ (function (_super) {
        __extends(DScrollBarThumb, _super);
        function DScrollBarThumb() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumb.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
            var position = new pixi_js.Point();
            this._dragUtil = new UtilDrag({
                target: this,
                easing: false,
                on: {
                    start: function () {
                        position.copyFrom(_this.position);
                    },
                    move: function (dx, dy) {
                        position.set(position.x + dx, position.y + dy);
                        _this.onDragMove(position.x, position.y);
                    }
                }
            });
        };
        DScrollBarThumb.prototype.getMinimumLength = function () {
            return this.theme.getThumbMinimumLength();
        };
        DScrollBarThumb.prototype.getType = function () {
            return "DScrollBarThumb";
        };
        return DScrollBarThumb;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbReflowableHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbReflowableHorizontal, _super);
        function DScrollBarThumbReflowableHorizontal(base) {
            var _this = _super.call(this) || this;
            base.snippet.add(_this, true);
            base.reflowable.add(_this);
            return _this;
        }
        DScrollBarThumbReflowableHorizontal.prototype.onReflow = function (base, width, height) {
            this.clear();
            var state = base.state;
            var border = base.border;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderWidth = border.getWidth(state);
                var borderAlign = border.getAlign(state);
                this.beginFill(borderColor, borderAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(0, height - borderWidth - borderAlign, width, borderWidth);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        };
        return DScrollBarThumbReflowableHorizontal;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbHorizontal, _super);
        function DScrollBarThumbHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumbHorizontal.prototype.onDragMove = function (dx, dy) {
            this.emit("regionmove", dx, this);
        };
        DScrollBarThumbHorizontal.prototype.initReflowable = function () {
            new DScrollBarThumbReflowableHorizontal(this);
        };
        return DScrollBarThumbHorizontal;
    }(DScrollBarThumb));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarHorizontal, _super);
        function DScrollBarHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarHorizontal.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.on(UtilPointerEvent.down, function (e) {
                if (e.target === _this) {
                    var width = _this.width;
                    if (0 < width) {
                        var size = _this._end - _this._start;
                        var position = e.data.getLocalPosition(_this);
                        var newStart = Math.min(1 - size, Math.max(0, position.x / width - size * 0.5));
                        if (_this._start !== newStart) {
                            _this.emit("regionmove", newStart, _this);
                        }
                    }
                }
            });
            this._thumb.on("regionmove", function (x) {
                var width = _this.width;
                if (0 < width) {
                    var size = _this._end - _this._start;
                    var newStart = Math.min(1 - size, Math.max(0, x / width));
                    if (_this._start !== newStart) {
                        _this.emit("regionmove", newStart, _this);
                    }
                }
            });
        };
        DScrollBarHorizontal.prototype.createThumb = function (options) {
            return new DScrollBarThumbHorizontal(options);
        };
        DScrollBarHorizontal.prototype.onRegionChange = function () {
            var thumb = this._thumb;
            var width = this.width;
            var height = this.height;
            var thumbMinimumLength = Math.min(width * 0.5, thumb.getMinimumLength());
            var space = width - thumbMinimumLength;
            var barStart = space * this._start;
            var barLength = space * this._end + thumbMinimumLength - barStart;
            thumb.position.set(barStart, 0);
            thumb.resize(barLength, height);
            _super.prototype.onRegionChange.call(this);
        };
        return DScrollBarHorizontal;
    }(DScrollBar));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbReflowableVertical = /** @class */ (function (_super) {
        __extends(DScrollBarThumbReflowableVertical, _super);
        function DScrollBarThumbReflowableVertical(base) {
            var _this = _super.call(this) || this;
            base.snippet.add(_this, true);
            base.reflowable.add(_this);
            return _this;
        }
        DScrollBarThumbReflowableVertical.prototype.onReflow = function (base, width, height) {
            this.clear();
            var state = base.state;
            var border = base.border;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderWidth = border.getWidth(state);
                var borderAlign = border.getAlign(state);
                this.beginFill(borderColor, borderAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(width - borderWidth - borderAlign, 0, borderWidth, height);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        };
        return DScrollBarThumbReflowableVertical;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbVertocal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbVertocal, _super);
        function DScrollBarThumbVertocal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumbVertocal.prototype.onDragMove = function (dx, dy) {
            this.emit("regionmove", dy, this);
        };
        DScrollBarThumbVertocal.prototype.initReflowable = function () {
            new DScrollBarThumbReflowableVertical(this);
        };
        return DScrollBarThumbVertocal;
    }(DScrollBarThumb));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarVertical = /** @class */ (function (_super) {
        __extends(DScrollBarVertical, _super);
        function DScrollBarVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarVertical.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.on(UtilPointerEvent.down, function (e) {
                if (e.target === _this) {
                    var height = _this.height;
                    if (0 < height) {
                        var size = _this._end - _this._start;
                        var position = e.data.getLocalPosition(_this);
                        var newStart = Math.min(1 - size, Math.max(0, position.y / height - size * 0.5));
                        if (_this._start !== newStart) {
                            _this.emit("regionmove", newStart, _this);
                        }
                    }
                    e.stopPropagation();
                }
            });
            this._thumb.on("regionmove", function (y) {
                var height = _this.height;
                if (0 < height) {
                    var size = _this._end - _this._start;
                    var newStart = Math.min(1 - size, Math.max(0, y / height));
                    if (_this._start !== newStart) {
                        _this.emit("regionmove", newStart, _this);
                    }
                }
            });
        };
        DScrollBarVertical.prototype.createThumb = function (options) {
            return new DScrollBarThumbVertocal(options);
        };
        DScrollBarVertical.prototype.onRegionChange = function () {
            var thumb = this._thumb;
            var width = this.width;
            var height = this.height;
            var thumbMinimumLength = Math.min(height * 0.5, thumb.getMinimumLength());
            var space = height - thumbMinimumLength;
            var barStart = space * this._start;
            var barLength = space * this._end + thumbMinimumLength - barStart;
            thumb.position.set(0, barStart);
            thumb.resize(width, barLength);
            _super.prototype.onRegionChange.call(this);
        };
        return DScrollBarVertical;
    }(DScrollBar));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Class
    var DPane = /** @class */ (function (_super) {
        __extends(DPane, _super);
        function DPane() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPane.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            // Content
            var theme = this.theme;
            var content = this.toContent(options);
            this._content = content;
            if ((_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : theme.isOverflowMaskEnabled()) {
                this.mask = this.getOverflowMask();
            }
            this.addChild(content);
            // Scroll bar
            var scrollbar = this.newScrollBar(theme, options === null || options === void 0 ? void 0 : options.scrollbar);
            this._scrollbar = scrollbar;
            scrollbar.vertical.on("regionmove", function (start) {
                _this.onRegionMoveY(content, start);
            });
            scrollbar.horizontal.on("regionmove", function (start) {
                _this.onRegionMoveX(content, start);
            });
            this.addChild(scrollbar.vertical);
            this.addChild(scrollbar.horizontal);
            content.on("move", function () {
                _this.onContentChange();
            });
            content.on("resize", function () {
                _this.onContentChange();
            });
            this.updateScrollBar();
            // Drag
            this.initDrag(content, theme, options);
        };
        DPane.prototype.initDrag = function (content, theme, options) {
            var _this = this;
            var _a, _b;
            // Edge does not fire the wheel event when scrolling using the 2-fingure scroll gesture on a touchpad.
            // Instead, it fires touch events. This is why the dragging is enabled regardless of the `UtilPointerEvent.touchable`.
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7134034/
            var dragMode = toEnum((_b = (_a = options === null || options === void 0 ? void 0 : options.drag) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : theme.getDragMode(), DDragMode);
            if (dragMode === DDragMode.ON || dragMode === DDragMode.TOUCH) {
                var position_1 = new pixi_js.Point();
                this._dragUtil = new UtilDrag({
                    target: this,
                    touch: dragMode === DDragMode.TOUCH,
                    on: {
                        start: function () {
                            position_1.copyFrom(content.position);
                        },
                        move: function (dx, dy) {
                            position_1.set(position_1.x + dx, position_1.y + dy);
                            content.position.set(_this.toContentX(content, position_1.x), _this.toContentY(content, position_1.y));
                        }
                    }
                });
            }
        };
        DPane.prototype.onRegionMoveX = function (content, start) {
            var dragUtil = this._dragUtil;
            if (dragUtil != null) {
                dragUtil.stop();
            }
            content.x = -content.width * start;
        };
        DPane.prototype.onRegionMoveY = function (content, start) {
            var dragUtil = this._dragUtil;
            if (dragUtil != null) {
                dragUtil.stop();
            }
            content.y = -content.height * start;
        };
        DPane.prototype.newScrollBar = function (theme, options) {
            return {
                vertical: new DScrollBarVertical(options === null || options === void 0 ? void 0 : options.vertical),
                horizontal: new DScrollBarHorizontal(options === null || options === void 0 ? void 0 : options.horizontal)
            };
        };
        DPane.prototype.getType = function () {
            return "DPane";
        };
        Object.defineProperty(DPane.prototype, "content", {
            get: function () {
                return this._content;
            },
            enumerable: false,
            configurable: true
        });
        DPane.prototype.toContent = function (options) {
            var content = options === null || options === void 0 ? void 0 : options.content;
            if (content) {
                if (content instanceof DBase) {
                    return content;
                }
                else {
                    return this.newContent(content);
                }
            }
            return this.newContent();
        };
        DPane.prototype.newContent = function (options) {
            return new DContent(options);
        };
        DPane.prototype.getOverflowMask = function () {
            var result = this._overflowMask;
            if (result == null) {
                result = new DBaseOverflowMask(this);
                this._overflowMask = result;
                this.reflowable.add(result);
                this.toDirty();
            }
            return result;
        };
        DPane.prototype.onWheel = function (e, deltas, global) {
            var content = this._content;
            var x = this.getWheelContentX(content, deltas.deltaX * deltas.lowest);
            var y = this.getWheelContentY(content, deltas.deltaY * deltas.lowest);
            if (content.x !== x || content.y !== y) {
                var dragUtil = this._dragUtil;
                if (dragUtil != null) {
                    dragUtil.stop();
                }
                content.position.set(x, y);
                return true;
            }
            return false;
        };
        DPane.prototype.getWheelContentX = function (content, delta) {
            if (0 < delta || delta < 0) {
                var speed = this.theme.getWheelSpeed();
                return this.toContentX(content, content.x - delta * speed);
            }
            return content.x;
        };
        DPane.prototype.getWheelContentY = function (content, delta) {
            if (0 < delta || delta < 0) {
                var speed = this.theme.getWheelSpeed();
                return this.toContentY(content, content.y + delta * speed);
            }
            return content.y;
        };
        DPane.prototype.toContentX = function (content, x) {
            return Math.min(0, Math.max(this.width - content.width, x));
        };
        DPane.prototype.toContentY = function (content, y) {
            return Math.min(0, Math.max(this.height - content.height, y));
        };
        DPane.prototype.isRefitable = function (target) {
            return _super.prototype.isRefitable.call(this, target) && !(target instanceof DScrollBar);
        };
        DPane.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.updateScrollBar();
        };
        DPane.prototype.onContentChange = function () {
            this.updateScrollBar();
        };
        DPane.prototype.updateScrollBar = function () {
            var scrollbar = this._scrollbar;
            if (scrollbar != null) {
                var vertical = scrollbar.vertical;
                var horizontal = scrollbar.horizontal;
                this.updateScrollBarRegions(vertical, horizontal);
                this.updateScrollBarVisibilities(vertical, horizontal);
                this.updateScrollBarPositions(vertical, horizontal);
            }
        };
        DPane.prototype.getScrollBarOffsetHorizontalStart = function (size) {
            return size * 0.5;
        };
        DPane.prototype.getScrollBarOffsetHorizontalEnd = function (size) {
            return size * 0.5;
        };
        DPane.prototype.getScrollBarOffsetVerticalStart = function (size) {
            return size * 0.5;
        };
        DPane.prototype.getScrollBarOffsetVerticalEnd = function (size) {
            return size * 0.5;
        };
        DPane.prototype.updateScrollBarPositions = function (vertical, horizontal) {
            var width = this.width;
            var height = this.height;
            var verticalWidth = vertical.width;
            var verticalOffsetStart = this.getScrollBarOffsetVerticalStart(verticalWidth);
            var verticalOffsetEnd = this.getScrollBarOffsetVerticalEnd(verticalWidth);
            vertical.position.set(width - verticalWidth, verticalOffsetStart);
            vertical.height = height - verticalOffsetStart - verticalOffsetEnd;
            var horizontalHeight = horizontal.height;
            var horizontalOffsetStart = this.getScrollBarOffsetHorizontalStart(horizontalHeight);
            var horizontalOffsetEnd = this.getScrollBarOffsetHorizontalEnd(horizontalHeight);
            horizontal.position.set(horizontalOffsetStart, height - horizontalHeight);
            horizontal.width = width - horizontalOffsetStart - horizontalOffsetEnd;
        };
        DPane.prototype.updateScrollBarRegions = function (vertical, horizontal) {
            var content = this._content;
            var x = -content.x;
            var y = -content.y;
            horizontal.setRegion(x, x + this.width, content.width);
            vertical.setRegion(y, y + this.height, content.height);
        };
        DPane.prototype.updateScrollBarVisibilities = function (vertical, horizontal) {
            var isChangedHorizontal = this.updateScrollBarVisibility(horizontal);
            var isChangedVertical = this.updateScrollBarVisibility(vertical);
            if (isChangedHorizontal || isChangedVertical) {
                // Update the overflow mask
                var overflowMask = this._overflowMask;
                if (overflowMask != null) {
                    if (horizontal.visible || vertical.visible) {
                        var content = this._content;
                        if (content.mask !== overflowMask) {
                            content.mask = overflowMask;
                        }
                    }
                    else {
                        var content = this._content;
                        if (content.mask) {
                            content.mask = null;
                        }
                    }
                }
                // Rerender
                DApplications.update(this);
            }
        };
        DPane.prototype.updateScrollBarVisibility = function (scrollbar) {
            var isRegionVisible = scrollbar.isRegionVisible();
            if (scrollbar.visible !== isRegionVisible) {
                scrollbar.visible = isRegionVisible;
                return true;
            }
            return false;
        };
        DPane.prototype.getFocusedChildClippingRect = function (focused, contentX, contentY, contentWidth, contentHeight, width, height, result) {
            result.x = 0;
            result.y = 0;
            result.width = width;
            result.height = height;
            return result;
        };
        DPane.prototype.onChildFocus = function (focused) {
            var point = DPane.WORK_POINT || new pixi_js.Point();
            DPane.WORK_POINT = point;
            // Content rectangle
            var content = this._content;
            var contentX = content.x;
            var contentY = content.y;
            var contentWidth = content.width;
            var contentHeight = content.height;
            point.set(0, 0);
            focused.toGlobal(point, point, false);
            content.toLocal(point, undefined, point, false);
            var x0 = contentX + Math.min(contentWidth, Math.max(0, point.x));
            var y0 = contentY + Math.min(contentHeight, Math.max(0, point.y));
            point.set(focused.width, focused.height);
            focused.toGlobal(point, point, true);
            content.toLocal(point, undefined, point, true);
            var x1 = contentX + Math.min(contentWidth, Math.max(0, point.x));
            var y1 = contentY + Math.min(contentHeight, Math.max(0, point.y));
            var width = this.width;
            var height = this.height;
            var clippingRect = DPane.WORK_RECTANGLE || new pixi_js.Rectangle();
            DPane.WORK_RECTANGLE = clippingRect;
            this.getFocusedChildClippingRect(focused, contentX, contentY, contentWidth, contentHeight, width, height, clippingRect);
            var clippingRectX = clippingRect.x;
            var clippingRectY = clippingRect.y;
            var clippingRectX0 = clippingRectX;
            var clippingRectY0 = clippingRectY;
            var clippingRectX1 = clippingRectX + clippingRect.width;
            var clippingRectY1 = clippingRectY + clippingRect.height;
            var newX = null;
            if (x0 < clippingRectX0) {
                if (x1 <= clippingRectX1) {
                    newX = contentX + Math.min(clippingRectX0 - x0, clippingRectX1 - x1);
                    newX = Math.max(width - contentWidth, Math.min(0, newX));
                }
            }
            else if (clippingRectX1 < x1) {
                newX = contentX - Math.min(x0 - clippingRectX0, x1 - clippingRectX1);
                newX = Math.max(width - contentWidth, Math.min(0, newX));
            }
            var newY = null;
            if (y0 < clippingRectY0) {
                if (y1 <= clippingRectY1) {
                    newY = contentY + Math.min(clippingRectY0 - y0, clippingRectY1 - y1);
                    newY = Math.max(height - contentHeight, Math.min(0, newY));
                }
            }
            else if (clippingRectY1 < y1) {
                newY = contentY - Math.min(y0 - clippingRectY0, y1 - clippingRectY1);
                newY = Math.max(height - contentHeight, Math.min(0, newY));
            }
            var contentPosition = content.position;
            if (newX != null) {
                if (newY != null) {
                    contentPosition.set(newX, newY);
                }
                else {
                    contentPosition.x = newX;
                }
            }
            else {
                if (newY != null) {
                    contentPosition.y = newY;
                }
            }
            _super.prototype.onChildFocus.call(this, focused);
        };
        DPane.prototype.destroy = function () {
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            _super.prototype.destroy.call(this);
        };
        return DPane;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DList = /** @class */ (function (_super) {
        __extends(DList, _super);
        function DList(options) {
            var _this = _super.call(this, options) || this;
            var data = _this.toData(options);
            _this._data = data;
            var content = _this.content;
            content.on("move", function () {
                _this.update();
            });
            content.on("resize", function () {
                _this.update();
            });
            var updater = _this.newUpdater(data, content, options);
            _this._updater = updater;
            updater.update();
            return _this;
        }
        DList.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var updater = this._updater;
            if (updater) {
                updater.lock();
                _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
                updater.update();
                updater.unlock(true);
            }
            else {
                _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            }
        };
        DList.prototype.newUpdater = function (data, content, options) {
            return new DListItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        };
        DList.prototype.toData = function (options) {
            var data = options && (options.data || options.items);
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            if (data == null) {
                if (selection) {
                    return new DListDataImpl(this, {
                        selection: selection
                    });
                }
                else {
                    return new DListDataImpl(this);
                }
            }
            else if (isArray(data)) {
                if (selection) {
                    return new DListDataImpl(this, {
                        items: data,
                        selection: selection
                    });
                }
                else {
                    return new DListDataImpl(this, {
                        items: data
                    });
                }
            }
            else if ("each" in data) {
                return data;
            }
            else {
                if (selection) {
                    if (data.selection === undefined) {
                        data.selection = selection;
                    }
                    return new DListDataImpl(this, data);
                }
                else {
                    return new DListDataImpl(this, data);
                }
            }
        };
        Object.defineProperty(DList.prototype, "selection", {
            get: function () {
                return this._data.selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DList.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        DList.prototype.lock = function () {
            this._updater.lock();
        };
        DList.prototype.unlock = function (callIfNeeded) {
            this._updater.unlock(callIfNeeded);
        };
        /**
         * Updates items. If the `forcibly` is true, some dirty checkings for
         * avoiding unnecessary state changes are skipped.
         *
         * @param forcibly true to update forcibly
         */
        DList.prototype.update = function (forcibly) {
            this._updater.update(forcibly);
        };
        DList.prototype.onKeyDown = function (e) {
            this._updater.moveFocus(e, this, true, true);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DList.prototype.getType = function () {
            return "DList";
        };
        return DList;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectList = /** @class */ (function (_super) {
        __extends(DDialogSelectList, _super);
        function DDialogSelectList(options) {
            var _this = _super.call(this, options) || this;
            _this.state.isFocusable = false;
            return _this;
        }
        DDialogSelectList.prototype.newUpdater = function (data, content, options) {
            return new DDialogSelectListItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        };
        DDialogSelectList.prototype.getType = function () {
            return "DDialogSelectList";
        };
        return DDialogSelectList;
    }(DList));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectSearh = /** @class */ (function (_super) {
        __extends(DDialogSelectSearh, _super);
        function DDialogSelectSearh(search) {
            var _this = _super.call(this) || this;
            _this._search = search || (function (_) { return Promise.resolve([]); });
            _this._id = 0;
            _this._idCompleted = 0;
            _this._result = null;
            return _this;
        }
        DDialogSelectSearh.prototype.create = function (args) {
            var _this = this;
            var id = ++this._id;
            this._search(args[0]).then(function (searchResult) {
                if (_this._id === id) {
                    _this._idCompleted = id;
                    _this._result = searchResult;
                    _this.emit("success", _this, searchResult);
                    _this.emit("change", _this);
                }
            }, function () {
                if (_this._id === id) {
                    _this._idCompleted = id;
                    _this._result = null;
                    _this.emit("fail", _this);
                    _this.emit("change", _this);
                }
            });
            this.emit("change", this);
        };
        DDialogSelectSearh.prototype.isDone = function () {
            return this._id === this._idCompleted;
        };
        DDialogSelectSearh.prototype.getResult = function () {
            return this._result;
        };
        return DDialogSelectSearh;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNote = /** @class */ (function (_super) {
        __extends(DNote, _super);
        function DNote() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNote.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.visible = false;
        };
        DNote.prototype.getType = function () {
            return "DNote";
        };
        return DNote;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Helper
    var toNoteOptions = function (parent, text, options) {
        if (options != null) {
            if (options.parent == null) {
                options.parent = parent;
            }
            if (options.text == null) {
                options.text = {
                    value: text
                };
            }
            else if (options.text.value == null) {
                options.text.value = text;
            }
            return options;
        }
        return {
            parent: parent,
            text: {
                value: text
            }
        };
    };
    var toSearch = function (controller) {
        if (controller) {
            var search = controller.search;
            if ("create" in search) {
                return search;
            }
            else {
                return new DDialogSelectSearh(search);
            }
        }
        else {
            return new DDialogSelectSearh();
        }
    };
    var DDialogSelect = /** @class */ (function (_super) {
        __extends(DDialogSelect, _super);
        function DDialogSelect() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelect.prototype.onInit = function (layout, options) {
            var _this = this;
            var _a, _b;
            this._value = null;
            var theme = this.theme;
            // Search box
            var inputOptions = (options === null || options === void 0 ? void 0 : options.input) || {};
            if (inputOptions.width === undefined) {
                inputOptions.width = "padding";
            }
            var input = new DInputText(inputOptions);
            this._input = input;
            layout.addChild(input);
            // List
            var listOptions = (options === null || options === void 0 ? void 0 : options.list) || {};
            if (listOptions.width === undefined) {
                listOptions.width = "padding";
            }
            var list = new DDialogSelectList(listOptions);
            list.selection.on("change", function (selection) {
                var first = selection.first;
                if (first != null) {
                    _this._value = first;
                    _this.onOk(first);
                }
            });
            this._list = list;
            layout.addChild(list);
            // Text No Items
            var noteNoItems = new DNote(toNoteOptions(list, theme.getNoteNoItemsText(), (_a = options === null || options === void 0 ? void 0 : options.note) === null || _a === void 0 ? void 0 : _a.noItems));
            this._noteNoItems = noteNoItems;
            // Text Searching
            var noteSearching = new DNote(toNoteOptions(list, theme.getNoteSearchingText(), (_b = options === null || options === void 0 ? void 0 : options.note) === null || _b === void 0 ? void 0 : _b.searching));
            this._noteSearching = noteSearching;
            // Controller binding
            var search = toSearch(options === null || options === void 0 ? void 0 : options.controller);
            this._search = search;
            this._input.on("input", function (value) {
                search.create([value]);
            });
            search.on("success", function (e, results) {
                _this.onSearched(results);
            });
            // Visibility
            var transition = new UtilTransition();
            search.on("change", function () {
                if (search.isDone()) {
                    var result = search.getResult();
                    if (result != null && 0 < result.length) {
                        transition.hide();
                    }
                    else {
                        transition.show(noteNoItems);
                    }
                }
                else {
                    transition.show(noteSearching);
                }
            });
        };
        Object.defineProperty(DDialogSelect.prototype, "input", {
            get: function () {
                return this._input;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogSelect.prototype, "list", {
            get: function () {
                return this._list;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogSelect.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.onSearched = function (results) {
            this._list.data.items = results;
        };
        DDialogSelect.prototype.getResolvedValue = function () {
            return this._value;
        };
        DDialogSelect.prototype.getType = function () {
            return "DDialogSelect";
        };
        DDialogSelect.prototype.onOpen = function () {
            _super.prototype.onOpen.call(this);
            this._list.selection.clear();
            this._search.create([this._input.value]);
        };
        DDialogSelect.prototype.onOk = function (value) {
            this.emit("select", value, this);
            _super.prototype.onOk.call(this, value);
        };
        DDialogSelect.prototype.destroy = function () {
            this._input.destroy();
            this._noteNoItems.destroy();
            this._noteSearching.destroy();
            this._list.destroy();
            _super.prototype.destroy.call(this);
        };
        return DDialogSelect;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var defaultGetter = function (dialog) {
        // Assumes the dialog.value is VALUE.
        return dialog.value;
    };
    var defaultSetter = function () {
        // DO NOTHING
    };
    var toOptions = function (options) {
        var _a, _b, _c;
        if (options) {
            // Try to copy text.formatter to dialog.item.text.formatter at first
            var formatter = (_a = options.text) === null || _a === void 0 ? void 0 : _a.formatter;
            if (formatter !== undefined) {
                var dialog = options.dialog;
                if (!(dialog && "open" in dialog)) {
                    dialog = dialog || {};
                    var item = (dialog.item = dialog.item || {});
                    var text = (item.text = item.text || {});
                    if (text.formatter === undefined) {
                        // Assumes formatter is ( value: DIALOG_VALUE | null, caller: any ) => string.
                        text.formatter = formatter;
                    }
                }
            }
            else {
                // Try to copy dialog.item.text.formatter to text.formatter
                var dialog = options.dialog;
                if (!(dialog && "open" in dialog)) {
                    var dialogFormatter = (_c = (_b = dialog === null || dialog === void 0 ? void 0 : dialog.item) === null || _b === void 0 ? void 0 : _b.text) === null || _c === void 0 ? void 0 : _c.formatter;
                    if (dialogFormatter !== undefined) {
                        var text = options.text || {};
                        options.text = text;
                        if (text.formatter === undefined) {
                            // Assumes dialogFormatter is ( value: VALUE | null, caller: any ) => string.
                            text.formatter = dialogFormatter;
                        }
                    }
                }
            }
        }
        return options;
    };
    var DButtonSelect = /** @class */ (function (_super) {
        __extends(DButtonSelect, _super);
        function DButtonSelect(options) {
            var _a, _b;
            var _this = _super.call(this, toOptions(options)) || this;
            _this._dialogGetter = (_a = options === null || options === void 0 ? void 0 : options.getter) !== null && _a !== void 0 ? _a : defaultGetter;
            _this._dialogSetter = (_b = options === null || options === void 0 ? void 0 : options.setter) !== null && _b !== void 0 ? _b : defaultSetter;
            return _this;
        }
        DButtonSelect.prototype.onActivate = function (e) {
            var _this = this;
            var _a;
            _super.prototype.onActivate.call(this, e);
            var dialog = this.dialog;
            var oldValue = (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : null;
            this._dialogSetter(dialog, oldValue);
            dialog.open().then(function () {
                var newValue = _this._dialogGetter(dialog);
                if (newValue !== oldValue) {
                    _this.text = newValue;
                    _this.emit("change", newValue, oldValue, _this);
                }
            });
        };
        Object.defineProperty(DButtonSelect.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options && "open" in options) {
                        dialog = options;
                    }
                    else {
                        // Assumes DIALOG === DDialogSelect<DIALOG_VALUE>.
                        dialog = new DDialogSelect(options);
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonSelect.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : null;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DButtonSelect.prototype.getType = function () {
            return "DButtonSelect";
        };
        return DButtonSelect;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogTimes = /** @class */ (function () {
        function DDialogTimes() {
        }
        DDialogTimes.getInstance = function () {
            if (DDialogTimes.INSTANCE == null) {
                DDialogTimes.INSTANCE = new DDialogTime();
            }
            return DDialogTimes.INSTANCE;
        };
        return DDialogTimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonTime = /** @class */ (function (_super) {
        __extends(DButtonTime, _super);
        function DButtonTime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonTime.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this._textValueComputed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.open().then(function () {
                var newValue = dialog.new;
                var oldValue = dialog.current;
                _this.text = new Date(newValue.getTime());
                _this.emit("change", newValue, oldValue, _this);
            });
        };
        DButtonTime.prototype.getDatetimeMask = function () {
            var _a, _b;
            var result = this._datetimeMask;
            if (result == null) {
                result = DPickerTimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        };
        Object.defineProperty(DButtonTime.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = new DDialogTime(options);
                    }
                    else {
                        dialog = DDialogTimes.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonTime.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : new Date();
            },
            set: function (value) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed === undefined || textValueComputed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonTime.prototype.getType = function () {
            return "DButtonTime";
        };
        return DButtonTime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonUndo = /** @class */ (function (_super) {
        __extends(DButtonUndo, _super);
        function DButtonUndo(options) {
            var _this = _super.call(this, options) || this;
            var state = _this.state;
            var commandController = DControllers.getCommandController();
            state.isDisabled = !commandController.isUndoable();
            commandController.on("change", function () {
                state.isDisabled = !commandController.isUndoable();
            });
            return _this;
        }
        DButtonUndo.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            DControllers.getCommandController().undo();
        };
        return DButtonUndo;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCanvas = /** @class */ (function (_super) {
        __extends(DCanvas, _super);
        function DCanvas() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCanvas.prototype.getType = function () {
            return "DCanvas";
        };
        return DCanvas;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisPosition;
    (function (DChartAxisPosition) {
        DChartAxisPosition[DChartAxisPosition["TOP"] = 0] = "TOP";
        DChartAxisPosition[DChartAxisPosition["BOTTOM"] = 1] = "BOTTOM";
        DChartAxisPosition[DChartAxisPosition["LEFT"] = 2] = "LEFT";
        DChartAxisPosition[DChartAxisPosition["RIGHT"] = 3] = "RIGHT";
    })(DChartAxisPosition || (DChartAxisPosition = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisTickPosition;
    (function (DChartAxisTickPosition) {
        DChartAxisTickPosition[DChartAxisTickPosition["INSIDE"] = 0] = "INSIDE";
        DChartAxisTickPosition[DChartAxisTickPosition["OUTSIDE"] = 1] = "OUTSIDE";
    })(DChartAxisTickPosition || (DChartAxisTickPosition = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBaseOptionParser = /** @class */ (function () {
        function DChartAxisBaseOptionParser(theme, options) {
            var _a, _b;
            this._coordinateIndex = (_a = options === null || options === void 0 ? void 0 : options.coordinate) !== null && _a !== void 0 ? _a : 0;
            this._position = this.toPosition(theme, options);
            this._tick = this.toTickContainer(theme, options);
            this._label = this.toLabel(theme, options);
            this._padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : theme.getPadding();
            this._bar = this.toBar(theme, options);
        }
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "coordinateIndex", {
            get: function () {
                return this._coordinateIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "bar", {
            get: function () {
                return this._bar;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "tick", {
            get: function () {
                return this._tick;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBaseOptionParser.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseOptionParser.prototype.toPosition = function (theme, options) {
            var position = options === null || options === void 0 ? void 0 : options.position;
            if (isString(position)) {
                return DChartAxisPosition[position];
            }
            else if (position != null) {
                return position;
            }
            return theme.getPosition();
        };
        DChartAxisBaseOptionParser.prototype.toBar = function (theme, options) {
            var _a;
            return {
                style: (_a = options === null || options === void 0 ? void 0 : options.style) !== null && _a !== void 0 ? _a : theme.getStyle(),
                stroke: this.toBarStroke(theme, options === null || options === void 0 ? void 0 : options.stroke),
                shape: undefined
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickContainer = function (theme, options) {
            var _a;
            var tick = options === null || options === void 0 ? void 0 : options.tick;
            return {
                enable: (_a = tick === null || tick === void 0 ? void 0 : tick.enable) !== null && _a !== void 0 ? _a : theme.getTickEnable(),
                major: this.toTickMajor(theme, tick),
                minor: this.toMinorTick(theme, tick)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajor = function (theme, options) {
            var _a, _b, _c, _d, _e, _f;
            var major = options === null || options === void 0 ? void 0 : options.major;
            var position = (_b = (_a = major === null || major === void 0 ? void 0 : major.position) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.position) !== null && _b !== void 0 ? _b : theme.getMajorTickPosition();
            var optionsStyle = options === null || options === void 0 ? void 0 : options.style;
            var style = EShapePointsStyles.from((_d = (_c = major === null || major === void 0 ? void 0 : major.style) !== null && _c !== void 0 ? _c : optionsStyle) !== null && _d !== void 0 ? _d : theme.getMajorTickStyle());
            var optionsStroke = options === null || options === void 0 ? void 0 : options.stroke;
            var stroke = this.toTickMajorStroke(theme, major === null || major === void 0 ? void 0 : major.stroke, optionsStroke);
            return {
                count: (_e = major === null || major === void 0 ? void 0 : major.count) !== null && _e !== void 0 ? _e : theme.getMajorTickCount(),
                size: (_f = major === null || major === void 0 ? void 0 : major.size) !== null && _f !== void 0 ? _f : theme.getMajorTickSize(),
                position: this.toTickPosition(position),
                style: style,
                stroke: stroke,
                text: this.toMajorTickText(theme, major === null || major === void 0 ? void 0 : major.text),
                formatter: this.toMajorTickFormatter(theme, major),
                shapes: undefined,
                gridline: this.toTickMajorGridline(theme, major === null || major === void 0 ? void 0 : major.gridline, optionsStyle, optionsStroke)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorGridline = function (theme, options, optionsStyle, optionsStroke) {
            var _a, _b, _c;
            var style = EShapePointsStyles.from((_b = (_a = options === null || options === void 0 ? void 0 : options.style) !== null && _a !== void 0 ? _a : optionsStyle) !== null && _b !== void 0 ? _b : theme.getMajorTickGridlineStyle());
            return {
                enable: (_c = options === null || options === void 0 ? void 0 : options.enable) !== null && _c !== void 0 ? _c : theme.getMajorTickGridlineEnable(),
                style: style,
                stroke: this.toTickMajorGridlineStroke(theme, options === null || options === void 0 ? void 0 : options.stroke, optionsStroke),
                shapes: undefined
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickPosition = function (tickPosition) {
            var position = this._position;
            if (tickPosition === DChartAxisTickPosition.OUTSIDE || tickPosition === "OUTSIDE") {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.RIGHT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.LEFT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
            else {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.LEFT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.RIGHT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
        };
        DChartAxisBaseOptionParser.prototype.toMinorTick = function (theme, options) {
            var _a, _b, _c, _d, _e, _f;
            var minor = options === null || options === void 0 ? void 0 : options.major;
            var position = (_b = (_a = minor === null || minor === void 0 ? void 0 : minor.position) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.position) !== null && _b !== void 0 ? _b : theme.getMinorTickPosition();
            var style = EShapePointsStyles.from((_d = (_c = minor === null || minor === void 0 ? void 0 : minor.style) !== null && _c !== void 0 ? _c : options === null || options === void 0 ? void 0 : options.style) !== null && _d !== void 0 ? _d : theme.getMinorTickStyle());
            return {
                count: (_e = minor === null || minor === void 0 ? void 0 : minor.count) !== null && _e !== void 0 ? _e : theme.getMinorTickCount(),
                size: (_f = minor === null || minor === void 0 ? void 0 : minor.size) !== null && _f !== void 0 ? _f : theme.getMinorTickSize(),
                position: this.toTickPosition(position),
                style: style,
                stroke: this.toTickMinorStroke(theme, minor === null || minor === void 0 ? void 0 : minor.stroke, options === null || options === void 0 ? void 0 : options.stroke),
                shapes: undefined
            };
        };
        DChartAxisBaseOptionParser.prototype.toBarStroke = function (theme, options) {
            return this.toStroke(options, undefined, theme.getStrokeEnable(), theme.getStrokeColor(), theme.getStrokeAlpha(), theme.getStrokeWidth(), theme.getStrokeAlign(), theme.getStrokeSide(), theme.getStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickStrokeEnable(), theme.getMajorTickStrokeColor(), theme.getMajorTickStrokeAlpha(), theme.getMajorTickStrokeWidth(), theme.getMajorTickStrokeAlign(), theme.getMajorTickStrokeSide(), theme.getMajorTickStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorGridlineStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickGridlineStrokeEnable(), theme.getMajorTickGridlineStrokeColor(), theme.getMajorTickGridlineStrokeAlpha(), theme.getMajorTickGridlineStrokeWidth(), theme.getMajorTickGridlineStrokeAlign(), theme.getMajorTickGridlineStrokeSide(), theme.getMajorTickGridlineStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMinorTickStrokeEnable(), theme.getMinorTickStrokeColor(), theme.getMinorTickStrokeAlpha(), theme.getMinorTickStrokeWidth(), theme.getMinorTickStrokeAlign(), theme.getMinorTickStrokeSide(), theme.getMinorTickStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toStroke = function (optionsA, optionsB, enable, color, alpha, width, align, side, style) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
            if (optionsA) {
                if (optionsB) {
                    return {
                        enable: (_b = (_a = optionsA.enable) !== null && _a !== void 0 ? _a : optionsB.enable) !== null && _b !== void 0 ? _b : enable,
                        color: (_d = (_c = optionsA.color) !== null && _c !== void 0 ? _c : optionsB.color) !== null && _d !== void 0 ? _d : color,
                        alpha: (_f = (_e = optionsA.alpha) !== null && _e !== void 0 ? _e : optionsB.alpha) !== null && _f !== void 0 ? _f : alpha,
                        width: (_h = (_g = optionsA.width) !== null && _g !== void 0 ? _g : optionsB.width) !== null && _h !== void 0 ? _h : width,
                        align: (_k = (_j = optionsA.align) !== null && _j !== void 0 ? _j : optionsB.align) !== null && _k !== void 0 ? _k : align,
                        side: (_m = (_l = optionsA.side) !== null && _l !== void 0 ? _l : optionsB.side) !== null && _m !== void 0 ? _m : side,
                        style: (_p = (_o = optionsA.style) !== null && _o !== void 0 ? _o : optionsB.style) !== null && _p !== void 0 ? _p : style
                    };
                }
                else {
                    return {
                        enable: (_q = optionsA.enable) !== null && _q !== void 0 ? _q : enable,
                        color: (_r = optionsA.color) !== null && _r !== void 0 ? _r : color,
                        alpha: (_s = optionsA.alpha) !== null && _s !== void 0 ? _s : alpha,
                        width: (_t = optionsA.width) !== null && _t !== void 0 ? _t : width,
                        align: (_u = optionsA.align) !== null && _u !== void 0 ? _u : align,
                        side: (_v = optionsA.side) !== null && _v !== void 0 ? _v : side,
                        style: (_w = optionsA.style) !== null && _w !== void 0 ? _w : style
                    };
                }
            }
            else if (optionsB) {
                return {
                    enable: (_x = optionsB.enable) !== null && _x !== void 0 ? _x : enable,
                    color: (_y = optionsB.color) !== null && _y !== void 0 ? _y : color,
                    alpha: (_z = optionsB.alpha) !== null && _z !== void 0 ? _z : alpha,
                    width: (_0 = optionsB.width) !== null && _0 !== void 0 ? _0 : width,
                    align: (_1 = optionsB.align) !== null && _1 !== void 0 ? _1 : align,
                    side: (_2 = optionsB.side) !== null && _2 !== void 0 ? _2 : side,
                    style: (_3 = optionsB.style) !== null && _3 !== void 0 ? _3 : style
                };
            }
            else {
                return {
                    enable: enable,
                    color: color,
                    alpha: alpha,
                    width: width,
                    align: align,
                    side: side,
                    style: style
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickFormatter = function (theme, options) {
            var text = options === null || options === void 0 ? void 0 : options.text;
            if (text) {
                var format = text.format;
                if (format != null) {
                    return NumberFormatters.create(format);
                }
                else {
                    var formatter = text.formatter;
                    if (formatter) {
                        return {
                            format: formatter
                        };
                    }
                }
            }
            return NumberFormatters.create(theme.getMajorTickTextFormat());
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickText = function (theme, options) {
            options = options || {};
            return {
                format: options.format,
                color: this.toMajorTickTextColor(theme, options.color),
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: options.weight,
                align: this.toMajorTickTextAlign(theme, options.align),
                offset: this.toMajorTickTextOffset(theme, options.offset),
                style: options.style,
                outline: this.toMajorTickTextOutline(theme, options.outline),
                spacing: this.toMajorTickTextSpacing(theme, options.spacing),
                direction: this.toTickMajorTextDirection(theme, options.direction),
                padding: this.toMajorTickTextPadding(theme, options.padding),
                clipping: options.clipping
            };
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextAlign = function (theme, options) {
            var _a, _b;
            var position = this._position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMajorTickTextAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMajorTickTextAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextPadding = function (theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMajorTickTextPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMajorTickTextPaddingVertical()
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextDirection = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getMajorTickTextDirection();
        };
        DChartAxisBaseOptionParser.prototype.toMajorTickTextColor = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getMajorTickTextColor();
        };
        DChartAxisBaseOptionParser.prototype.toLabel = function (theme, options) {
            var label = options === null || options === void 0 ? void 0 : options.label;
            if (label) {
                return {
                    value: label.value,
                    color: this.toLabelColor(theme, label.color),
                    alpha: label.alpha,
                    family: label.family,
                    size: label.size,
                    weight: label.weight,
                    align: this.toLabelAlign(theme, label.align),
                    offset: this.toLabelOffset(theme, label.offset),
                    style: label.style,
                    outline: this.toLabelOutline(theme, label.outline),
                    spacing: this.toLabelSpacing(theme, label.spacing),
                    direction: this.toLabelDirection(theme, label.direction),
                    padding: this.toLabelPadding(theme, label.padding),
                    clipping: label.clipping
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelAlign = function (theme, options) {
            var _a, _b;
            var position = this._position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getLabelAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getLabelAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toLabelOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelPadding = function (theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getLabelPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getLabelPaddingVertical()
            };
        };
        DChartAxisBaseOptionParser.prototype.toLabelDirection = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getLabelDirection();
        };
        DChartAxisBaseOptionParser.prototype.toLabelColor = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getLabelColor();
        };
        return DChartAxisBaseOptionParser;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBase = /** @class */ (function () {
        function DChartAxisBase(options) {
            var theme = this.toTheme(options);
            this._theme = theme;
            this._index = 0;
            var parser = new DChartAxisBaseOptionParser(theme, options);
            this._coordinateIndex = parser.coordinateIndex;
            this._padding = parser.padding;
            this._position = parser.position;
            var tick = parser.tick;
            this._tick = tick;
            this._label = parser.label;
            this._bar = parser.bar;
            var tickMajorCount = tick.major.count;
            var tickMinorCount = tick.minor.count;
            this._majorTicks = new Float64Array(tickMajorCount * 3);
            this._minorTicks = new Float64Array((tickMajorCount + 1) * tickMinorCount * 3);
        }
        Object.defineProperty(DChartAxisBase.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBase.prototype.updateBar = function (container) {
            var bar = this._bar;
            var shape = bar.shape;
            if (shape) {
                var plotArea = container.plotArea;
                var plotAreaWidth = plotArea.width;
                var plotAreaHeight = plotArea.height;
                var padding = this._padding * this._index;
                shape.disallowUploadedUpdate();
                var position = shape.transform.position;
                var size = shape.size;
                switch (this._position) {
                    case DChartAxisPosition.TOP:
                        position.set(plotAreaWidth * 0.5, 0 - padding);
                        size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.BOTTOM:
                        position.set(plotAreaWidth * 0.5, plotAreaHeight + padding);
                        size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.LEFT:
                        position.set(0 - padding, plotAreaHeight * 0.5);
                        size.set(0, plotAreaHeight);
                        break;
                    case DChartAxisPosition.RIGHT:
                        position.set(plotAreaWidth + padding, plotAreaHeight * 0.5);
                        size.set(0, plotAreaHeight);
                        break;
                }
                shape.allowUploadedUpdate();
            }
        };
        DChartAxisBase.prototype.updateTicksX = function (domainMin, domainMax, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionY, transform, plotAreaHeight) {
            var tick = this._tick;
            var majorCount = tick.major.count;
            var majorFormatter = tick.major.formatter;
            var minorCountPerMajor = tick.minor.count;
            var minorCount = (majorCount + 1) * minorCountPerMajor;
            var majorTicks = this._majorTicks;
            var minorTicks = this._minorTicks;
            coordinate.ticks(domainMin, domainMax, majorCount, minorCountPerMajor, minorCount, majorTicks, minorTicks);
            var a = transform.a;
            var tx = transform.tx;
            for (var i = 0; i < majorCount; ++i) {
                var majorShape = majorShapes[i];
                var imajorTick = i * 3;
                var majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    var majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    var majotTickPositionX = a * majorTickProjectedPosition + tx;
                    var majorTickStep = majorTicks[imajorTick + 2];
                    majorShape.disallowUploadedUpdate();
                    majorShape.visible = true;
                    majorShape.transform.position.set(majotTickPositionX, shapePositionY);
                    majorShape.text.value = majorFormatter.format(majorTickPosition, majorTickStep);
                    majorShape.allowUploadedUpdate();
                    if (gridlineShapes) {
                        var gridlineShape = gridlineShapes[i];
                        gridlineShape.disallowUploadedUpdate();
                        gridlineShape.visible = true;
                        gridlineShape.transform.position.set(majotTickPositionX, plotAreaHeight * 0.5);
                        gridlineShape.size.set(0, plotAreaHeight);
                        gridlineShape.allowUploadedUpdate();
                    }
                }
                else {
                    majorShape.visible = false;
                    if (gridlineShapes) {
                        gridlineShapes[i].visible = false;
                    }
                }
            }
            for (var i = 0; i < minorCount; ++i) {
                var minorShape = minorShapes[i];
                var iminorTick = i * 3;
                var minorTickPosition = minorTicks[iminorTick + 0];
                var minorTickProjectedPosition = minorTicks[iminorTick + 1];
                if (!isNaN(minorTickPosition)) {
                    minorShape.disallowUploadedUpdate();
                    minorShape.visible = true;
                    minorShape.transform.position.set(a * minorTickProjectedPosition + tx, shapePositionY);
                    minorShape.allowUploadedUpdate();
                }
                else {
                    minorShape.visible = false;
                }
            }
        };
        DChartAxisBase.prototype.updateTicksY = function (domainMin, domainMax, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionX, transform, plotAreaWidth) {
            var tick = this._tick;
            var majorCount = tick.major.count;
            var majorFormatter = tick.major.formatter;
            var minorCountPerMajor = tick.minor.count;
            var minorCount = (majorCount + 1) * minorCountPerMajor;
            var majorTicks = this._majorTicks;
            var minorTicks = this._minorTicks;
            coordinate.ticks(domainMin, domainMax, majorCount, minorCountPerMajor, minorCount, majorTicks, minorTicks);
            var d = transform.d;
            var ty = transform.ty;
            for (var i = 0; i < majorCount; ++i) {
                var majorShape = majorShapes[i];
                var imajorTick = i * 3;
                var majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    var majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    var majotTickPositionY = d * majorTickProjectedPosition + ty;
                    var majorTickStep = majorTicks[imajorTick + 2];
                    majorShape.disallowUploadedUpdate();
                    majorShape.visible = true;
                    majorShape.transform.position.set(shapePositionX, majotTickPositionY);
                    majorShape.text.value = majorFormatter.format(majorTickPosition, majorTickStep);
                    majorShape.allowUploadedUpdate();
                    if (gridlineShapes) {
                        var gridlineShape = gridlineShapes[i];
                        gridlineShape.disallowUploadedUpdate();
                        gridlineShape.visible = true;
                        gridlineShape.transform.position.set(plotAreaWidth * 0.5, majotTickPositionY);
                        gridlineShape.size.set(plotAreaWidth, 0);
                        gridlineShape.allowUploadedUpdate();
                    }
                }
                else {
                    majorShape.visible = false;
                    if (gridlineShapes) {
                        gridlineShapes[i].visible = false;
                    }
                }
            }
            for (var i = 0; i < minorCount; ++i) {
                var minorShape = minorShapes[i];
                var iminorTick = i * 3;
                var minorTickPosition = minorTicks[iminorTick + 0];
                var minorTickProjectedPosition = minorTicks[iminorTick + 1];
                if (!isNaN(minorTickPosition)) {
                    minorShape.disallowUploadedUpdate();
                    minorShape.visible = true;
                    minorShape.transform.position.set(shapePositionX, d * minorTickProjectedPosition + ty);
                    minorShape.allowUploadedUpdate();
                }
                else {
                    minorShape.visible = false;
                }
            }
        };
        DChartAxisBase.prototype.updateTicks = function (container) {
            var tick = this._tick;
            var majorShapes = tick.major.shapes;
            var minorShapes = tick.minor.shapes;
            if (majorShapes && minorShapes) {
                var plotArea = container.plotArea;
                var bounds = plotArea.getBoundsInContainer();
                var transform = plotArea.container.transform.localTransform;
                var gridlineShapes = tick.major.gridline.shapes;
                var coordinateIndex = this._coordinateIndex;
                var padding = this._padding * this._index;
                var coordinate = void 0;
                switch (this._position) {
                    case DChartAxisPosition.TOP:
                        coordinate = plotArea.coordinate.x.get(coordinateIndex);
                        if (coordinate) {
                            var domainFrom = coordinate.unmap(coordinate.transform.unmap(bounds.x));
                            var domainTo = coordinate.unmap(coordinate.transform.unmap(bounds.x + bounds.width));
                            var plotAreaHeight = plotArea.height;
                            this.updateTicksX(domainFrom, domainTo, coordinate, majorShapes, minorShapes, gridlineShapes, 0 - padding, transform, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.BOTTOM:
                        coordinate = plotArea.coordinate.x.get(coordinateIndex);
                        if (coordinate) {
                            var domainFrom = coordinate.unmap(coordinate.transform.unmap(bounds.x));
                            var domainTo = coordinate.unmap(coordinate.transform.unmap(bounds.x + bounds.width));
                            var plotAreaHeight = plotArea.height;
                            this.updateTicksX(domainFrom, domainTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaHeight + padding, transform, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.LEFT:
                        coordinate = plotArea.coordinate.y.get(coordinateIndex);
                        if (coordinate) {
                            var domainFrom = coordinate.unmap(coordinate.transform.unmap(bounds.y));
                            var domainTo = coordinate.unmap(coordinate.transform.unmap(bounds.y + bounds.height));
                            var plotAreaWidth = plotArea.width;
                            this.updateTicksY(domainFrom, domainTo, coordinate, majorShapes, minorShapes, gridlineShapes, 0 - padding, transform, plotAreaWidth);
                        }
                        break;
                    case DChartAxisPosition.RIGHT:
                        coordinate = plotArea.coordinate.y.get(coordinateIndex);
                        if (coordinate) {
                            var domainFrom = coordinate.unmap(coordinate.transform.unmap(bounds.y));
                            var domainTo = coordinate.unmap(coordinate.transform.unmap(bounds.y + bounds.height));
                            var plotAreaWidth = plotArea.width;
                            this.updateTicksY(domainFrom, domainTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaWidth + padding, transform, plotAreaWidth);
                        }
                        break;
                }
            }
        };
        DChartAxisBase.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            var tickShapeContainer = container.container;
            // Bar
            var bar = this._bar;
            var barShape = bar.shape;
            if (!barShape) {
                var position = this._position;
                var barPosition = position === DChartAxisPosition.LEFT || position === DChartAxisPosition.RIGHT
                    ? EShapeBarPosition.TOP
                    : EShapeBarPosition.LEFT;
                barShape = new EShapeBar(barPosition, undefined, undefined, bar.style);
                barShape.stroke.copy(bar.stroke);
                barShape.text.copy(this._label);
                this._bar.shape = barShape;
            }
            barShape.attach(container.container);
            // Major tick gridline
            var tick = this._tick;
            var tickMajor = tick.major;
            var gridline = tickMajor.gridline;
            var gridlineShapes = gridline.shapes;
            if (!gridlineShapes && tick.enable && gridline.enable) {
                gridlineShapes = [];
                gridline.shapes = gridlineShapes;
                var position = this._position;
                var gridlinePosition = position === DChartAxisPosition.LEFT || position === DChartAxisPosition.RIGHT
                    ? EShapeBarPosition.LEFT
                    : EShapeBarPosition.TOP;
                var gridlineCount = tickMajor.count;
                var gridlineStyle = gridline.style;
                for (var i = 0; i < gridlineCount; ++i) {
                    var gridlineShape = new EShapeBar(gridlinePosition, undefined, undefined, gridlineStyle);
                    gridlineShape.stroke.copy(gridline.stroke);
                    gridlineShapes.push(gridlineShape);
                }
            }
            if (gridlineShapes) {
                for (var i = 0, imax = gridlineShapes.length; i < imax; ++i) {
                    gridlineShapes[i].attach(tickShapeContainer);
                }
            }
            // Major ticks
            var tickMajorShapes = tickMajor.shapes;
            if (!tickMajorShapes && tick.enable) {
                tickMajorShapes = [];
                tickMajor.shapes = tickMajorShapes;
                var tickMajorCount = tickMajor.count;
                var tickMajorSize = tickMajor.size;
                var tickMajorPosition = tickMajor.position;
                var tickMajorStyle = tickMajor.style;
                for (var i = 0; i < tickMajorCount; ++i) {
                    var tickMajorShape = new EShapeBar(tickMajorPosition, tickMajorSize, undefined, tickMajorStyle);
                    tickMajorShape.stroke.copy(tickMajor.stroke);
                    tickMajorShape.text.copy(tickMajor.text);
                    tickMajorShape.size.set(0, 0);
                    tickMajorShapes.push(tickMajorShape);
                }
            }
            if (tickMajorShapes) {
                for (var i = 0, imax = tickMajorShapes.length; i < imax; ++i) {
                    tickMajorShapes[i].attach(tickShapeContainer);
                }
            }
            // Minor ticks
            var tickMinor = tick.minor;
            var tickMinorShapes = tickMinor.shapes;
            if (!tickMinorShapes && tick.enable) {
                tickMinorShapes = [];
                tickMinor.shapes = tickMinorShapes;
                var tickMinorCount = tickMinor.count;
                var tickMinorSize = tickMinor.size;
                var tickMinorPosition = tickMinor.position;
                var tickMinorStyle = tickMinor.style;
                for (var i = 0, imax = (tickMajor.count + 1) * tickMinorCount; i < imax; ++i) {
                    var tickMinorShape = new EShapeBar(tickMinorPosition, tickMinorSize, undefined, tickMinorStyle);
                    tickMinorShape.stroke.copy(tickMinor.stroke);
                    tickMinorShape.size.set(0, 0);
                    tickMinorShapes.push(tickMinorShape);
                }
            }
            if (tickMinorShapes) {
                for (var i = 0, imax = tickMinorShapes.length; i < imax; ++i) {
                    tickMinorShapes[i].attach(tickShapeContainer);
                }
            }
        };
        DChartAxisBase.prototype.unbind = function () {
            // Bar
            var barShape = this._bar.shape;
            if (barShape) {
                barShape.detach();
            }
            // Major ticks
            var tick = this._tick;
            var tickMajorShapes = tick.major.shapes;
            if (tickMajorShapes) {
                for (var i = 0, imax = tickMajorShapes.length; i < imax; ++i) {
                    tickMajorShapes[i].detach();
                }
            }
            // Major tick gridlines
            var tickMajorGridlineShapes = tick.major.gridline.shapes;
            if (tickMajorGridlineShapes) {
                for (var i = 0, imax = tickMajorGridlineShapes.length; i < imax; ++i) {
                    tickMajorGridlineShapes[i].detach();
                }
            }
            // Minor ticks
            var tickMinorShapes = tick.minor.shapes;
            if (tickMinorShapes) {
                for (var i = 0, imax = tickMinorShapes.length; i < imax; ++i) {
                    tickMinorShapes[i].detach();
                }
            }
            //
            this._container = undefined;
        };
        DChartAxisBase.prototype.update = function () {
            var container = this._container;
            if (container) {
                this.updateBar(container);
                this.updateTicks(container);
            }
        };
        DChartAxisBase.prototype.destroy = function () {
            // Bar
            var barShape = this._bar.shape;
            if (barShape) {
                barShape.destroy();
            }
            // Major ticks
            var tick = this._tick;
            var tickMajorShapes = tick.major.shapes;
            if (tickMajorShapes) {
                for (var i = 0, imax = tickMajorShapes.length; i < imax; ++i) {
                    tickMajorShapes[i].destroy();
                }
            }
            // Major tick gridlines
            var tickMajorGridlineShapes = tick.major.gridline.shapes;
            if (tickMajorGridlineShapes) {
                for (var i = 0, imax = tickMajorGridlineShapes.length; i < imax; ++i) {
                    tickMajorGridlineShapes[i].destroy();
                }
            }
            // Minor ticks
            var tickMinorShapes = tick.minor.shapes;
            if (tickMinorShapes) {
                for (var i = 0, imax = tickMinorShapes.length; i < imax; ++i) {
                    tickMinorShapes[i].destroy();
                }
            }
            //
            this._container = undefined;
        };
        DChartAxisBase.prototype.toTheme = function (options) {
            return (options && options.theme) || this.getThemeDefault();
        };
        DChartAxisBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartAxisBase.prototype.getType = function () {
            return "DChartAxisBase";
        };
        return DChartAxisBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisContainerImpl = /** @class */ (function () {
        function DChartAxisContainerImpl(plotArea, options) {
            this._plotArea = plotArea;
            this._container = new EShapeContainer();
            this._list = new Map();
            var list = options && options.list;
            if (list) {
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    this.add(list[i]);
                }
            }
        }
        Object.defineProperty(DChartAxisContainerImpl.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisContainerImpl.prototype.add = function (axis) {
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes == null) {
                axes = [];
                list.set(axis.position, axes);
            }
            axes.push(axis);
            axis.bind(this, axes.length - 1);
        };
        DChartAxisContainerImpl.prototype.get = function (position, index) {
            var list = this._list;
            var axes = list.get(position);
            if (axes) {
                if (0 <= index && index < axes.length) {
                    return axes[index];
                }
            }
            return null;
        };
        DChartAxisContainerImpl.prototype.indexOf = function (axis) {
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes) {
                return axes.indexOf(axis);
            }
            return -1;
        };
        DChartAxisContainerImpl.prototype.clear = function (position) {
            var list = this._list;
            var axes = list.get(position);
            if (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            }
            return this;
        };
        DChartAxisContainerImpl.prototype.size = function (position) {
            var list = this._list;
            var axes = list.get(position);
            if (axes) {
                return axes.length;
            }
            return 0;
        };
        DChartAxisContainerImpl.prototype.update = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].update();
                }
            });
        };
        DChartAxisContainerImpl.prototype.destroy = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            });
        };
        return DChartAxisContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis.
     */
    var DChartAxisX = /** @class */ (function (_super) {
        __extends(DChartAxisX, _super);
        function DChartAxisX() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisX.prototype.getType = function () {
            return "DChartAxisX";
        };
        return DChartAxisX;
    }(DChartAxisBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis for datetimes.
     */
    var DChartAxisXDatetime = /** @class */ (function (_super) {
        __extends(DChartAxisXDatetime, _super);
        function DChartAxisXDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisXDatetime.prototype.getType = function () {
            return "DChartAxisXDatetime";
        };
        return DChartAxisXDatetime;
    }(DChartAxisX));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An Y axis.
     */
    var DChartAxisY = /** @class */ (function (_super) {
        __extends(DChartAxisY, _super);
        function DChartAxisY() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisY.prototype.getType = function () {
            return "DChartAxisY";
        };
        return DChartAxisY;
    }(DChartAxisBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCHART_COLOR_SET_1 = [0x10b7e3, 0xfe5420, 0xf0c312, 0x1c5d71];
    var DCHART_COLOR_SET_2 = [
        DCHART_COLOR_SET_1[0],
        UtilRgb.brighten(DCHART_COLOR_SET_1[0], 0.4),
        DCHART_COLOR_SET_1[1],
        UtilRgb.brighten(DCHART_COLOR_SET_1[1], 0.4),
        DCHART_COLOR_SET_1[2],
        UtilRgb.brighten(DCHART_COLOR_SET_1[2], 0.4),
        DCHART_COLOR_SET_1[3],
        UtilRgb.brighten(DCHART_COLOR_SET_1[3], 0.4)
    ];
    var DChartColorSet1 = function (index) {
        return DCHART_COLOR_SET_1[index % DCHART_COLOR_SET_1.length];
    };
    var DChartColorSet2 = function (index) {
        return DCHART_COLOR_SET_2[index % DCHART_COLOR_SET_2.length];
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateDirection;
    (function (DChartCoordinateDirection) {
        DChartCoordinateDirection[DChartCoordinateDirection["X"] = 0] = "X";
        DChartCoordinateDirection[DChartCoordinateDirection["Y"] = 1] = "Y";
    })(DChartCoordinateDirection || (DChartCoordinateDirection = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateContainerSubImpl = /** @class */ (function () {
        function DChartCoordinateContainerSubImpl(container, direction) {
            this._container = container;
            this._direction = direction;
            this._list = [];
        }
        Object.defineProperty(DChartCoordinateContainerSubImpl.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateContainerSubImpl.prototype.add = function (coordinate, index) {
            var list = this._list;
            if (index == null) {
                list.push(coordinate);
            }
            else if (0 <= index && index < list.length) {
                list.splice(index, 0, coordinate);
            }
            else {
                list.push(coordinate);
            }
            coordinate.bind(this, this._direction);
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartCoordinateContainerSubImpl.prototype.indexOf = function (coordinate) {
            return this._list.indexOf(coordinate);
        };
        DChartCoordinateContainerSubImpl.prototype.remove = function (coordinateOrIndex) {
            var list = this._list;
            if (isNumber(coordinateOrIndex)) {
                var index = coordinateOrIndex;
                if (0 <= index && index < list.length) {
                    var removed = list.splice(index, 1)[0];
                    removed.unbind();
                    return removed;
                }
            }
            else {
                var coordinate = coordinateOrIndex;
                var index = list.indexOf(coordinate);
                if (0 <= index) {
                    list.splice(index, 1);
                    coordinate.unbind();
                    return coordinate;
                }
            }
            return null;
        };
        DChartCoordinateContainerSubImpl.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].unbind();
            }
            list.length = 0;
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.destroy = function () {
            return this.clear();
        };
        DChartCoordinateContainerSubImpl.prototype.size = function () {
            return this._list.length;
        };
        DChartCoordinateContainerSubImpl.prototype.fit = function (from, to) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].fit(from, to);
            }
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.mark = function (from, to) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].mark(from, to);
            }
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.blend = function (ratio) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].blend(ratio);
            }
            return this;
        };
        return DChartCoordinateContainerSubImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateContainerImpl = /** @class */ (function () {
        function DChartCoordinateContainerImpl(plotArea, options) {
            this._plotArea = plotArea;
            var x = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.X);
            this._x = x;
            var y = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.Y);
            this._y = y;
            if (options) {
                var cxs = options.x;
                if (cxs) {
                    if (isArray(cxs)) {
                        for (var i = 0, imax = cxs.length; i < imax; ++i) {
                            x.add(cxs[i]);
                        }
                    }
                    else {
                        x.add(cxs);
                    }
                }
                var cys = options.y;
                if (cys) {
                    if (isArray(cys)) {
                        for (var i = 0, imax = cys.length; i < imax; ++i) {
                            y.add(cys[i]);
                        }
                    }
                    else {
                        y.add(cys);
                    }
                }
            }
        }
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateContainerImpl.prototype.fit = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.fit(domainFrom, domainTo);
            this._y.fit(rangeFrom, rangeTo);
            return this;
        };
        DChartCoordinateContainerImpl.prototype.mark = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.mark(domainFrom, domainTo);
            this._y.mark(rangeFrom, rangeTo);
            return this;
        };
        DChartCoordinateContainerImpl.prototype.blend = function (ratio) {
            this._x.blend(ratio);
            this._y.blend(ratio);
            return this;
        };
        return DChartCoordinateContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLinearTick = /** @class */ (function () {
        function DChartCoordinateLinearTick(theme) {
            this._theme = theme;
        }
        DChartCoordinateLinearTick.prototype.calcStepMajor = function (domainMin, domainMax, count) {
            if (0 < count) {
                var span = Math.abs(domainMax - domainMin) / count;
                var power = Math.floor(Math.log(span) / Math.LN10);
                var base = Math.pow(10, power);
                return this._theme.toStepScale(span / base) * base;
            }
            return -1;
        };
        DChartCoordinateLinearTick.prototype.calcStepMinor = function (step, minorCount) {
            if (0 <= step) {
                return step / (minorCount + 1);
            }
            else {
                return -1;
            }
        };
        DChartCoordinateLinearTick.prototype.calcTickMinorPositions = function (step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (var i = 0; i < count; i += 1) {
                var minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        };
        DChartCoordinateLinearTick.prototype.calculate = function (domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            var transform = coordinate.transform;
            var domainMin = Math.min(domainFrom, domainTo);
            var domainMax = Math.max(domainFrom, domainTo);
            var majorStep = this.calcStepMajor(domainMin, domainMax, majorCount);
            if (majorStep <= 0) {
                majorResult[0] = domainMin;
                majorResult[1] = transform.map(coordinate.map(domainMin));
                majorResult[2] = 0;
                for (var i = 1; i < majorCount; ++i) {
                    var imajorResult = i * 3;
                    majorResult[imajorResult + 0] = NaN;
                    majorResult[imajorResult + 1] = NaN;
                    majorResult[imajorResult + 2] = NaN;
                }
                for (var i = 0; i < minorCount; ++i) {
                    var iminorResult = i * 3;
                    minorResult[iminorResult + 0] = NaN;
                    minorResult[iminorResult + 1] = NaN;
                    minorResult[iminorResult + 2] = NaN;
                }
                return;
            }
            // Major tick start position
            var idomainStart = Math.floor(domainMin / majorStep) - 1;
            var idomainEnd = Math.ceil(domainMax / majorStep) + 1;
            // Major / minor tick positions
            var minorStep = this.calcStepMinor(majorStep, minorCountPerMajor);
            var imajor = 0;
            var iminor = 0;
            for (var i = idomainStart; i <= idomainEnd; ++i) {
                var majorPosition = i * majorStep;
                if (imajor < majorCount) {
                    if (domainMin <= majorPosition && majorPosition <= domainMax) {
                        var majorProjectedPosition = transform.map(coordinate.map(majorPosition));
                        var imajorResult = imajor * 3;
                        majorResult[imajorResult + 0] = majorPosition;
                        majorResult[imajorResult + 1] = majorProjectedPosition;
                        majorResult[imajorResult + 2] = majorStep;
                        imajor += 1;
                    }
                }
                for (var j = 0; j < minorCountPerMajor; j += 1) {
                    if (iminor < minorCount) {
                        var minorPosition = majorPosition + (j + 1) * minorStep;
                        if (domainMin <= minorPosition && minorPosition <= domainMax) {
                            var minorProjectedPosition = transform.map(coordinate.map(minorPosition));
                            var iminorResult = iminor * 3;
                            minorResult[iminorResult + 0] = minorPosition;
                            minorResult[iminorResult + 1] = minorProjectedPosition;
                            minorResult[iminorResult + 2] = minorStep;
                            iminor += 1;
                        }
                    }
                }
            }
            for (var i = imajor; i < majorCount; ++i) {
                var imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (var i = iminor; i < minorCount; ++i) {
                var iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        };
        return DChartCoordinateLinearTick;
    }());

    var DChartCoordinateTransformImpl = /** @class */ (function () {
        function DChartCoordinateTransformImpl(theme) {
            this._theme = theme;
            this._id = 0;
            this._translate = 0;
            this._scale = 1;
            this._itranslate = 0;
            this._iscale = 1;
        }
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "translate", {
            get: function () {
                return this._translate;
            },
            set: function (translate) {
                this.set(translate);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            set: function (scale) {
                this.set(undefined, scale);
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateTransformImpl.prototype.bind = function (container, direction) {
            this.set(0, direction === DChartCoordinateDirection.X ? +1 : -1);
        };
        DChartCoordinateTransformImpl.prototype.unbind = function () {
            // DO NOTHING
        };
        DChartCoordinateTransformImpl.prototype.set = function (translate, scale) {
            var isChanged = false;
            if (translate != null && this._translate !== translate) {
                isChanged = true;
                this._translate = translate;
            }
            if (scale != null && this._scale !== scale) {
                isChanged = true;
                this._scale = scale;
            }
            if (isChanged) {
                this._id += 1;
                this._iscale = this._theme.isZero(this._scale) ? 0 : 1 / this._scale;
                this._itranslate = -this._translate * this._iscale;
            }
        };
        DChartCoordinateTransformImpl.prototype.blend = function (ratio, mark) {
            var ratioi = 1 - ratio;
            var newTranslate = mark.newTranslate * ratio + mark.oldTranslate * ratioi;
            var newScale = mark.newScale * ratio + mark.oldScale * ratioi;
            this.set(newTranslate, newScale);
        };
        DChartCoordinateTransformImpl.prototype.map = function (value) {
            return this._translate + this._scale * value;
        };
        DChartCoordinateTransformImpl.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            var translate = this._translate;
            var scale = this._scale;
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = translate + scale * values[i];
            }
        };
        DChartCoordinateTransformImpl.prototype.unmap = function (value) {
            return this._itranslate + this._iscale * value;
        };
        DChartCoordinateTransformImpl.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            var itranslate = this._itranslate;
            var iscale = this._iscale;
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = itranslate + iscale * values[i];
            }
        };
        return DChartCoordinateTransformImpl;
    }());

    var DChartCoordinateTransformMarkImpl = /** @class */ (function () {
        function DChartCoordinateTransformMarkImpl() {
            this.oldTranslate = 0;
            this.oldScale = 1;
            this.newTranslate = 0;
            this.newScale = 1;
        }
        DChartCoordinateTransformMarkImpl.prototype.set = function (translate, scale) {
            if (translate != null) {
                this.newTranslate = translate;
            }
            if (scale != null) {
                this.newScale = scale;
            }
        };
        return DChartCoordinateTransformMarkImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartRegionImpl = /** @class */ (function () {
        function DChartRegionImpl(from, to) {
            this.from = from;
            this.to = to;
        }
        DChartRegionImpl.prototype.set = function (from, to) {
            if (from != null) {
                this.from = from;
            }
            if (to != null) {
                this.to = to;
            }
            return this;
        };
        DChartRegionImpl.prototype.add = function (from, to) {
            if (!isNaN(from)) {
                this.from = isNaN(this.from) ? from : Math.min(this.from, from);
            }
            if (!isNaN(to)) {
                this.to = isNaN(this.to) ? to : Math.max(this.to, to);
            }
            return this;
        };
        DChartRegionImpl.prototype.clear = function () {
            this.from = NaN;
            this.to = NaN;
            return this;
        };
        return DChartRegionImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLinear = /** @class */ (function () {
        function DChartCoordinateLinear(options) {
            this._id = 0;
            this._direction = DChartCoordinateDirection.X;
            var theme = this.toTheme(options);
            this._theme = theme;
            this._transform = new DChartCoordinateTransformImpl(theme);
            this._tick = new DChartCoordinateLinearTick(theme);
            this._work = new DChartRegionImpl(NaN, NaN);
            this._mark = new DChartCoordinateTransformMarkImpl();
        }
        DChartCoordinateLinear.prototype.bind = function (container, direction) {
            this._container = container;
            this._direction = direction;
            this._transform.bind(container, direction);
        };
        DChartCoordinateLinear.prototype.unbind = function () {
            this._container = undefined;
            this._transform.unbind();
        };
        DChartCoordinateLinear.prototype.fit = function (from, to) {
            this.doFit(from, to, this._transform);
        };
        DChartCoordinateLinear.prototype.mark = function (from, to) {
            var mark = this._mark;
            var transform = this._transform;
            mark.oldTranslate = transform.translate;
            mark.oldScale = transform.scale;
            this.doFit(from, to, mark);
        };
        DChartCoordinateLinear.prototype.blend = function (ratio) {
            this._transform.blend(ratio, this._mark);
        };
        DChartCoordinateLinear.prototype.doFit = function (from, to, result) {
            var container = this._container;
            if (container) {
                var plotArea = container.container.plotArea;
                var padding = plotArea.padding;
                var work = this._work;
                switch (this._direction) {
                    case DChartCoordinateDirection.X:
                        this.doFit_(padding.getLeft(), plotArea.width - padding.getRight(), this.toFitDomain(from, to, plotArea, work), result);
                        break;
                    case DChartCoordinateDirection.Y:
                        this.doFit_(plotArea.height - padding.getBottom(), padding.getTop(), this.toFitRange(from, to, plotArea, work), result);
                        break;
                }
            }
        };
        DChartCoordinateLinear.prototype.toFitDomain = function (from, to, plotArea, result) {
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getDomain(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateLinear.prototype.toFitRange = function (from, to, plotArea, result) {
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getRange(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateLinear.prototype.doFit_ = function (pixelFrom, pixelTo, region, result) {
            var regionFrom = region.from;
            var regionTo = region.to;
            if (!(isNaN(regionFrom) || isNaN(regionTo))) {
                // Scale
                var newScale = 1;
                var regionSize = regionTo - regionFrom;
                if (!this._theme.isZero(regionSize)) {
                    var pixelSize = pixelTo - pixelFrom;
                    newScale = pixelSize / regionSize;
                }
                else {
                    newScale = pixelTo < pixelFrom ? -1 : 1;
                }
                // Translation
                var newTranslation = pixelFrom - regionFrom * newScale;
                // Done
                result.set(newTranslation, newScale);
            }
        };
        Object.defineProperty(DChartCoordinateLinear.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateLinear.prototype, "transform", {
            get: function () {
                return this._transform;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateLinear.prototype.map = function (value) {
            return value;
        };
        DChartCoordinateLinear.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            // DO NOTHING
        };
        DChartCoordinateLinear.prototype.unmap = function (value) {
            return value;
        };
        DChartCoordinateLinear.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            // DO NOTHING
        };
        DChartCoordinateLinear.prototype.ticks = function (domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult) {
            this._tick.calculate(domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult, this);
        };
        DChartCoordinateLinear.prototype.toTheme = function (options) {
            return (options && options.theme) || this.getThemeDefault();
        };
        DChartCoordinateLinear.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateLinear.prototype.getType = function () {
            return "DChartCoordinateLinear";
        };
        return DChartCoordinateLinear;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLogTick = /** @class */ (function () {
        function DChartCoordinateLogTick(theme) {
            this._theme = theme;
        }
        DChartCoordinateLogTick.prototype.calcStepMajor = function (domainMin, domainMax, count) {
            if (0 < count) {
                var span = Math.abs(domainMax - domainMin) / count;
                var power = Math.floor(Math.log(span) / Math.LN10);
                var base = Math.pow(10, power);
                return this._theme.toStepScale(span / base) * base;
            }
            return -1;
        };
        DChartCoordinateLogTick.prototype.calcStepMinor = function (step, minorCount) {
            if (0 <= step) {
                return step / (minorCount + 1);
            }
            else {
                return -1;
            }
        };
        DChartCoordinateLogTick.prototype.calcTickMinorPositions = function (step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (var i = 0; i < count; i += 1) {
                var minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        };
        DChartCoordinateLogTick.prototype.calculate = function (domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            var transform = coordinate.transform;
            var domainFromMapped = coordinate.map(domainFrom);
            var domainToMapped = coordinate.map(domainTo);
            var domainMinMapped = Math.min(domainFromMapped, domainToMapped);
            var domainMaxMapped = Math.max(domainFromMapped, domainToMapped);
            var majorStepMapped = this.calcStepMajor(domainMinMapped, domainMaxMapped, majorCount);
            if (majorStepMapped <= 0) {
                var domainMin = Math.min(domainFrom, domainTo);
                majorResult[0] = domainMin;
                majorResult[1] = transform.map(coordinate.map(domainMin));
                majorResult[2] = 0;
                for (var i = 1; i < majorCount; ++i) {
                    var imajorResult = i * 3;
                    majorResult[imajorResult + 0] = NaN;
                    majorResult[imajorResult + 1] = NaN;
                    majorResult[imajorResult + 2] = NaN;
                }
                for (var i = 0; i < minorCount; ++i) {
                    var iminorResult = i * 3;
                    minorResult[iminorResult + 0] = NaN;
                    minorResult[iminorResult + 1] = NaN;
                    minorResult[iminorResult + 2] = NaN;
                }
                return;
            }
            // Major tick start position
            var idomainStartMapped = Math.floor(domainMinMapped / majorStepMapped) - 1;
            var idomainEndMapped = Math.ceil(domainMaxMapped / majorStepMapped) + 1;
            // Major / minor tick positions
            var minorStepMapped = this.calcStepMinor(majorStepMapped, minorCountPerMajor);
            var imajor = 0;
            var iminor = 0;
            for (var i = idomainStartMapped; i <= idomainEndMapped; ++i) {
                var majorPositionMapped = i * majorStepMapped;
                if (imajor < majorCount) {
                    if (domainMinMapped <= majorPositionMapped &&
                        majorPositionMapped <= domainMaxMapped) {
                        var majorPosition = coordinate.unmap(majorPositionMapped);
                        var majorProjectedPosition = transform.map(majorPositionMapped);
                        var majorStep = coordinate.unmap(majorPositionMapped - 1);
                        var imajorResult = imajor * 3;
                        majorResult[imajorResult + 0] = majorPosition;
                        majorResult[imajorResult + 1] = majorProjectedPosition;
                        majorResult[imajorResult + 2] = majorStep;
                        imajor += 1;
                    }
                }
                for (var j = 0; j < minorCountPerMajor; j += 1) {
                    if (iminor < minorCount) {
                        var minorPositionMapped = majorPositionMapped + (j + 1) * minorStepMapped;
                        if (domainMinMapped <= minorPositionMapped &&
                            minorPositionMapped <= domainMaxMapped) {
                            var minorPosition = coordinate.unmap(minorPositionMapped);
                            var minorProjectedPosition = transform.map(minorPositionMapped);
                            var minorStep = coordinate.unmap(minorPositionMapped - 1);
                            var iminorResult = iminor * 3;
                            minorResult[iminorResult + 0] = minorPosition;
                            minorResult[iminorResult + 1] = minorProjectedPosition;
                            minorResult[iminorResult + 2] = minorStep;
                            iminor += 1;
                        }
                    }
                }
            }
            for (var i = imajor; i < majorCount; ++i) {
                var imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (var i = iminor; i < minorCount; ++i) {
                var iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        };
        return DChartCoordinateLogTick;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLog = /** @class */ (function () {
        function DChartCoordinateLog(options) {
            this._id = 0;
            this._direction = DChartCoordinateDirection.X;
            var theme = this.toTheme(options);
            this._theme = theme;
            this._transform = new DChartCoordinateTransformImpl(theme);
            this._tick = new DChartCoordinateLogTick(theme);
            this._work = new DChartRegionImpl(NaN, NaN);
            this._mark = new DChartCoordinateTransformMarkImpl();
        }
        DChartCoordinateLog.prototype.bind = function (container, direction) {
            this._container = container;
            this._direction = direction;
        };
        DChartCoordinateLog.prototype.unbind = function () {
            this._container = undefined;
        };
        DChartCoordinateLog.prototype.fit = function (from, to) {
            this.doFit(from, to, this._transform);
        };
        DChartCoordinateLog.prototype.mark = function (from, to) {
            var mark = this._mark;
            var transform = this._transform;
            mark.oldTranslate = transform.translate;
            mark.oldScale = transform.scale;
            this.doFit(from, to, mark);
        };
        DChartCoordinateLog.prototype.blend = function (ratio) {
            this._transform.blend(ratio, this._mark);
        };
        DChartCoordinateLog.prototype.doFit = function (from, to, result) {
            var container = this._container;
            if (container) {
                var plotArea = container.container.plotArea;
                var padding = plotArea.padding;
                var work = this._work;
                switch (this._direction) {
                    case DChartCoordinateDirection.X:
                        this.doFit_(padding.getLeft(), plotArea.width - padding.getRight(), this.toFitDomain(from, to, plotArea, work), result);
                        break;
                    case DChartCoordinateDirection.Y:
                        this.doFit_(plotArea.height - padding.getBottom(), padding.getTop(), this.toFitRange(from, to, plotArea, work), result);
                        break;
                }
            }
        };
        DChartCoordinateLog.prototype.toFitDomain = function (from, to, plotArea, result) {
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getDomain(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateLog.prototype.toFitRange = function (from, to, plotArea, result) {
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getRange(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateLog.prototype.doFit_ = function (pixelFrom, pixelTo, region, result) {
            var regionFrom = region.from;
            var regionTo = region.to;
            if (!(isNaN(regionFrom) || isNaN(regionTo))) {
                // Scale
                var newScale = 1;
                var regionFromMapped = this.map(regionFrom);
                var regionToMapped = this.map(regionTo);
                var regionSizeMapped = regionToMapped - regionFromMapped;
                if (!this._theme.isZero(regionSizeMapped)) {
                    var pixelSize = pixelTo - pixelFrom;
                    newScale = pixelSize / regionSizeMapped;
                }
                else {
                    newScale = pixelTo < pixelFrom ? -1 : 1;
                }
                // Translation
                var newTranslation = pixelFrom - regionFromMapped * newScale;
                // Done
                result.set(newTranslation, newScale);
            }
        };
        Object.defineProperty(DChartCoordinateLog.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateLog.prototype, "transform", {
            get: function () {
                return this._transform;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateLog.prototype.map = function (value) {
            return Math.log(Math.max(0, value)) / Math.LN10;
        };
        DChartCoordinateLog.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            var factor = 1 / Math.LN10;
            for (var i = ifrom + offset; i < iend; i += stride) {
                var value = values[i];
                values[i] = Math.log(Math.max(0, value)) * factor;
            }
        };
        DChartCoordinateLog.prototype.unmap = function (value) {
            return Math.pow(10, value);
        };
        DChartCoordinateLog.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = Math.pow(10, values[i]);
            }
        };
        DChartCoordinateLog.prototype.ticks = function (domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult) {
            this._tick.calculate(domainFrom, domainTo, majorCount, minorCountPerMajor, minorCount, majorResult, minorResult, this);
        };
        DChartCoordinateLog.prototype.toTheme = function (options) {
            return (options && options.theme) || this.getThemeDefault();
        };
        DChartCoordinateLog.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateLog.prototype.getType = function () {
            return "DChartCoordinateLog";
        };
        return DChartCoordinateLog;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartLegendItem = /** @class */ (function (_super) {
        __extends(DChartLegendItem, _super);
        function DChartLegendItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartLegendItem.prototype.getType = function () {
            return "DChartLegendItem";
        };
        return DChartLegendItem;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartLegend = /** @class */ (function (_super) {
        __extends(DChartLegend, _super);
        function DChartLegend() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartLegend.prototype.getType = function () {
            return "DChartLegend";
        };
        return DChartLegend;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartOverview = /** @class */ (function (_super) {
        __extends(DChartOverview, _super);
        function DChartOverview() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartOverview.prototype.getType = function () {
            return "DChartOverview";
        };
        return DChartOverview;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaContainer = /** @class */ (function (_super) {
        __extends(DChartPlotAreaContainer, _super);
        function DChartPlotAreaContainer(onChange) {
            var _this = _super.call(this) || this;
            var transform = _this.transform;
            _this._position = new DBasePoint(transform.position, onChange);
            _this._scale = new DBasePoint(transform.scale, onChange);
            _this._workRect = new pixi_js.Rectangle();
            return _this;
        }
        Object.defineProperty(DChartPlotAreaContainer.prototype, "position", {
            // @ts-ignore
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaContainer.prototype, "scale", {
            // @ts-ignore
            get: function () {
                return this._scale;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaContainer.prototype.getBounds = function (skipUpdate, rect) {
            this._lastBoundsID = -1;
            return _super.prototype.getBounds.call(this, skipUpdate, rect);
        };
        DChartPlotAreaContainer.prototype.calculateBounds = function () {
            var bounds = this._bounds;
            var work = this._work;
            var rect = this._workRect;
            var worldTransform = this.transform.worldTransform;
            var xmin = 0;
            var xmax = 0;
            var ymin = 0;
            var ymax = 0;
            var children = this.children;
            if (0 < children.length) {
                var isFirst = true;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible) {
                        child.getBoundsInternal(work, false, rect);
                        if (isFirst) {
                            isFirst = false;
                            xmin = rect.x;
                            ymin = rect.y;
                            xmax = rect.x + rect.width;
                            ymax = rect.y + rect.height;
                        }
                        else {
                            xmin = Math.min(xmin, rect.x);
                            ymin = Math.min(ymin, rect.y);
                            xmax = Math.max(xmax, rect.x + rect.width);
                            ymax = Math.max(ymax, rect.y + rect.height);
                        }
                    }
                }
            }
            bounds.clear();
            work.set(xmin, ymin);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(xmax, ymax);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
        };
        return DChartPlotAreaContainer;
    }(EShapeContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesHitResult = /** @class */ (function () {
        function DChartSeriesHitResult() {
            this.shape = null;
            this.x = 0;
            this.y = 0;
            this.p0x = 0;
            this.p0y = 0;
            this.p1x = 0;
            this.p1y = 0;
            this.index = 0;
            this.t = 0;
            this.distance = 0;
        }
        DChartSeriesHitResult.prototype.copyFrom = function (other) {
            this.shape = other.shape;
            this.x = other.x;
            this.y = other.y;
            this.p0x = other.p0x;
            this.p0y = other.p0y;
            this.p1x = other.p1x;
            this.p1y = other.p1y;
            this.index = other.index;
            this.t = other.t;
            this.distance = other.distance;
            return this;
        };
        return DChartSeriesHitResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesFillComputedImpl = /** @class */ (function () {
        function DChartSeriesFillComputedImpl(enable, color, alpha) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
        }
        DChartSeriesFillComputedImpl.from = function (base, index, fill) {
            var _a, _b, _c;
            return new DChartSeriesFillComputedImpl((_a = fill === null || fill === void 0 ? void 0 : fill.enable) !== null && _a !== void 0 ? _a : base.enable(index), (_b = fill === null || fill === void 0 ? void 0 : fill.color) !== null && _b !== void 0 ? _b : base.color(index), (_c = fill === null || fill === void 0 ? void 0 : fill.alpha) !== null && _c !== void 0 ? _c : base.alpha(index));
        };
        return DChartSeriesFillComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesScalars = /** @class */ (function () {
        function DChartSeriesScalars() {
        }
        DChartSeriesScalars.from = function (value, def) {
            if (isArray(value)) {
                return function (index) { return value[index % value.length]; };
            }
            else if (isFunction(value)) {
                return value;
            }
            else if (value != null) {
                return function () { return value; };
            }
            else if (isArray(def)) {
                return function (index) { return def[index % def.length]; };
            }
            else if (isFunction(def)) {
                return def;
            }
            else {
                return function () { return def; };
            }
        };
        return DChartSeriesScalars;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesFillImpl = /** @class */ (function () {
        function DChartSeriesFillImpl(options) {
            this.enable = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.enable, true);
            this.color = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.alpha, EShapeDefaults.FILL_ALPHA);
        }
        return DChartSeriesFillImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPaddingComputedImpl = /** @class */ (function () {
        function DChartSeriesPaddingComputedImpl(outer, inner) {
            this.outer = outer;
            this.inner = inner;
        }
        DChartSeriesPaddingComputedImpl.from = function (base, index, point) {
            var _a, _b;
            return new DChartSeriesPaddingComputedImpl((_a = point === null || point === void 0 ? void 0 : point.outer) !== null && _a !== void 0 ? _a : base.outer(index), (_b = point === null || point === void 0 ? void 0 : point.inner) !== null && _b !== void 0 ? _b : base.inner(index));
        };
        return DChartSeriesPaddingComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPaddingImpl = /** @class */ (function () {
        function DChartSeriesPaddingImpl(options) {
            this.outer = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.outer, 0.2);
            this.inner = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.inner, 0.1);
        }
        return DChartSeriesPaddingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPointComputedImpl = /** @class */ (function () {
        function DChartSeriesPointComputedImpl(x, y) {
            this.x = x;
            this.y = y;
        }
        DChartSeriesPointComputedImpl.from = function (base, index, point, x, y) {
            var _a, _b;
            return new DChartSeriesPointComputedImpl((_a = point === null || point === void 0 ? void 0 : point.x) !== null && _a !== void 0 ? _a : (base.x != null ? base.x(index) : x), (_b = point === null || point === void 0 ? void 0 : point.y) !== null && _b !== void 0 ? _b : (base.y != null ? base.y(index) : y));
        };
        return DChartSeriesPointComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPointImpl = /** @class */ (function () {
        function DChartSeriesPointImpl(options) {
            if (options) {
                if (options.x != null) {
                    this.x = DChartSeriesScalars.from(options.x, 0);
                }
                if (options.y != null) {
                    this.y = DChartSeriesScalars.from(options.y, 0);
                }
            }
        }
        return DChartSeriesPointImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesStrokeComputedImpl = /** @class */ (function () {
        function DChartSeriesStrokeComputedImpl(enable, color, alpha, width, align, side, style) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
            this.width = width;
            this.align = align;
            this.side = side;
            this.style = style;
        }
        DChartSeriesStrokeComputedImpl.from = function (base, index, stroke) {
            var _a, _b, _c, _d, _e, _f, _g;
            return new DChartSeriesStrokeComputedImpl((_a = stroke === null || stroke === void 0 ? void 0 : stroke.enable) !== null && _a !== void 0 ? _a : base.enable(index), (_b = stroke === null || stroke === void 0 ? void 0 : stroke.color) !== null && _b !== void 0 ? _b : base.color(index), (_c = stroke === null || stroke === void 0 ? void 0 : stroke.alpha) !== null && _c !== void 0 ? _c : base.alpha(index), (_d = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _d !== void 0 ? _d : base.width(index), (_e = stroke === null || stroke === void 0 ? void 0 : stroke.align) !== null && _e !== void 0 ? _e : base.align(index), (_f = stroke === null || stroke === void 0 ? void 0 : stroke.side) !== null && _f !== void 0 ? _f : base.side(index), (_g = stroke === null || stroke === void 0 ? void 0 : stroke.style) !== null && _g !== void 0 ? _g : base.style(index));
        };
        return DChartSeriesStrokeComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesStrokeImpl = /** @class */ (function () {
        function DChartSeriesStrokeImpl(options) {
            this.enable = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.enable, true);
            this.color = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.alpha, EShapeDefaults.STROKE_ALPHA);
            this.width = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.width, EShapeDefaults.STROKE_WIDTH);
            this.align = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.width, EShapeDefaults.STROKE_ALIGN);
            this.side = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.side, EShapeStrokeSide.ALL);
            this.style = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.style, EShapeStrokeStyle.NON_SCALING);
        }
        return DChartSeriesStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesContainerImpl = /** @class */ (function () {
        function DChartSeriesContainerImpl(plotArea, options) {
            var _a;
            this._plotArea = plotArea;
            this._domain = new DChartRegionImpl(NaN, NaN);
            this._range = new DChartRegionImpl(NaN, NaN);
            this._selection = (_a = options === null || options === void 0 ? void 0 : options.selection) !== null && _a !== void 0 ? _a : null;
            this._fill = new DChartSeriesFillImpl(options === null || options === void 0 ? void 0 : options.fill);
            this._stroke = new DChartSeriesStrokeImpl(options === null || options === void 0 ? void 0 : options.stroke);
            this._size = new DChartSeriesPointImpl(options === null || options === void 0 ? void 0 : options.size);
            this._offset = new DChartSeriesPointImpl(options === null || options === void 0 ? void 0 : options.offset);
            this._padding = new DChartSeriesPaddingImpl(options === null || options === void 0 ? void 0 : options.padding);
            this._list = [];
            var list = options && options.list;
            if (list) {
                var listLength = list.length;
                if (0 < listLength) {
                    for (var i = 0; i < listLength; ++i) {
                        this.add(list[i]);
                    }
                    this.update();
                }
            }
        }
        DChartSeriesContainerImpl.prototype.newFill = function (index, options) {
            return DChartSeriesFillComputedImpl.from(this._fill, index, options);
        };
        DChartSeriesContainerImpl.prototype.newStroke = function (index, options) {
            return DChartSeriesStrokeComputedImpl.from(this._stroke, index, options);
        };
        DChartSeriesContainerImpl.prototype.newSize = function (index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._size, index, options, x, y);
        };
        DChartSeriesContainerImpl.prototype.newOffset = function (index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._offset, index, options, x, y);
        };
        DChartSeriesContainerImpl.prototype.newPadding = function (index, options) {
            return DChartSeriesPaddingComputedImpl.from(this._padding, index, options);
        };
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesContainerImpl.prototype.update = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].update();
            }
            var selection = this._selection;
            if (selection) {
                selection.update();
            }
        };
        DChartSeriesContainerImpl.prototype.add = function (series) {
            var list = this._list;
            series.bind(this, list.length);
            list.push(series);
        };
        DChartSeriesContainerImpl.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartSeriesContainerImpl.prototype.indexOf = function (series) {
            return this._list.indexOf(series);
        };
        DChartSeriesContainerImpl.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            return this;
        };
        DChartSeriesContainerImpl.prototype.size = function () {
            return this._list.length;
        };
        DChartSeriesContainerImpl.prototype.destroy = function () {
            this.clear();
            var selection = this._selection;
            if (selection) {
                selection.unbind();
            }
        };
        DChartSeriesContainerImpl.prototype.getDomain = function (coordinate, result) {
            result.clear();
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                var series = list[i];
                if (series.coordinate.x === coordinate) {
                    var domain = series.domain;
                    result.add(domain.from, domain.to);
                }
            }
            return result;
        };
        DChartSeriesContainerImpl.prototype.getRange = function (coordinate, result) {
            result.clear();
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                var series = list[i];
                if (series.coordinate.y === coordinate) {
                    var range = series.range;
                    result.add(range.from, range.to);
                }
            }
            return result;
        };
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "domain", {
            get: function () {
                var result = this._domain;
                result.clear();
                var list = this._list;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var domain = list[i].domain;
                    result.add(domain.from, domain.to);
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "range", {
            get: function () {
                var result = this._range;
                result.clear();
                var list = this._list;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var range = list[i].range;
                    result.add(range.from, range.to);
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesContainerImpl.prototype.hitTest = function (global) {
            var list = this._list;
            for (var i = list.length - 1; 0 <= i; --i) {
                var series = list[i];
                if (series.hitTest(global)) {
                    return series;
                }
            }
            return null;
        };
        DChartSeriesContainerImpl.prototype.calcHitPoint = function (global, result) {
            var tmp1 = result;
            var tmp2 = DChartSeriesContainerImpl.WORK_CALCHITPOINT;
            var list = this._list;
            var closest = null;
            tmp2.distance = +Infinity;
            for (var i = list.length - 1; 0 <= i; --i) {
                var series = list[i];
                if (series.calcHitPoint(global, tmp1)) {
                    if (tmp1.distance < tmp2.distance) {
                        closest = series;
                        var tmp = tmp1;
                        tmp1 = tmp2;
                        tmp2 = tmp;
                    }
                }
            }
            if (closest && tmp2 !== result) {
                result.copyFrom(tmp2);
            }
            return closest;
        };
        DChartSeriesContainerImpl.WORK_CALCHITPOINT = new DChartSeriesHitResult();
        return DChartSeriesContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotArea = /** @class */ (function (_super) {
        __extends(DChartPlotArea, _super);
        function DChartPlotArea(chart, options) {
            var _this = _super.call(this, options) || this;
            _this._chart = chart;
            _this._blendStartTime = 0;
            _this._blendDuration = 1000;
            _this._blendTimeout = null;
            _this._onBlendBound = function () {
                _this.onBlend();
            };
            return _this;
        }
        DChartPlotArea.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            var container = new DChartPlotAreaContainer(function () {
                _this._isViewDirty = true;
                _this._isBoundsInContainerDirty = true;
                DApplications.update(_this);
            });
            this._container = container;
            this._coordinate = new DChartCoordinateContainerImpl(this, options === null || options === void 0 ? void 0 : options.coordinate);
            var series = new DChartSeriesContainerImpl(this, options === null || options === void 0 ? void 0 : options.series);
            this._series = series;
            var axis = new DChartAxisContainerImpl(this, options === null || options === void 0 ? void 0 : options.axis);
            this._axis = axis;
            this._isViewDirty = true;
            this._isBoundsInContainerDirty = true;
            this._boundsInContainer = new pixi_js.Rectangle();
            this._workPoint = new pixi_js.Point();
            this.addChild(container);
            this.addChild(axis.container);
            this._view = new DViewImpl(this, function () { return container; }, options === null || options === void 0 ? void 0 : options.view);
            var selection = series.selection;
            if (selection) {
                selection.bind(series);
            }
            // Overflow mask
            var mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : this.theme.isOverflowMaskEnabled();
            if (mask) {
                container.mask = this.getOverflowMask();
            }
        };
        DChartPlotArea.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            this._isViewDirty = true;
            this._isBoundsInContainerDirty = true;
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
        };
        DChartPlotArea.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        Object.defineProperty(DChartPlotArea.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "chart", {
            get: function () {
                return this._chart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "axis", {
            get: function () {
                return this._axis;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotArea.prototype, "view", {
            get: function () {
                return this._view;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotArea.prototype.onWheel = function (e, deltas, global) {
            var vresult = this._view.onWheel(e, deltas, global);
            var sresult = _super.prototype.onWheel.call(this, e, deltas, global);
            return vresult || sresult;
        };
        DChartPlotArea.prototype.onDblClick = function (e, interactionManager) {
            var vresult = this._view.onDblClick(e, interactionManager);
            var sresult = _super.prototype.onDblClick.call(this, e, interactionManager);
            return vresult || sresult;
        };
        DChartPlotArea.prototype.onDown = function (e) {
            this._view.onDown(e);
            _super.prototype.onDown.call(this, e);
        };
        DChartPlotArea.prototype.render = function (renderer) {
            if (this._isViewDirty) {
                this._isViewDirty = false;
                this._axis.update();
                var selection = this._series.selection;
                if (selection) {
                    selection.update();
                }
            }
            _super.prototype.render.call(this, renderer);
        };
        DChartPlotArea.prototype.destroy = function () {
            this._container.destroy();
            this._series.destroy();
            this._axis.destroy();
        };
        DChartPlotArea.prototype.getType = function () {
            return "DChartPlotArea";
        };
        DChartPlotArea.prototype.getBoundsInContainer = function () {
            var result = this._boundsInContainer;
            if (this._isBoundsInContainerDirty) {
                this._isBoundsInContainerDirty = false;
                var container = this.container;
                container.updateTransform();
                var transform = container.transform.localTransform;
                var work = this._workPoint;
                work.set(0, 0);
                transform.applyInverse(work, work);
                result.x = work.x;
                result.y = work.y;
                work.set(this.width, this.height);
                transform.applyInverse(work, work);
                result.width = work.x - result.x;
                result.height = work.y - result.y;
            }
            return result;
        };
        DChartPlotArea.prototype.fit = function (duration, domainFrom, domainTo, rangeFrom, rangeTo) {
            var coordinate = this._coordinate;
            var axis = this._axis;
            var series = this._series;
            if (duration != null && duration <= 0) {
                coordinate.fit(domainFrom, domainTo, rangeFrom, rangeTo);
                axis.update();
                series.update();
            }
            else {
                this._blendDuration = duration != null ? duration : 200;
                this._blendStartTime = Date.now();
                coordinate.mark(domainFrom, domainTo, rangeFrom, rangeTo);
                var blendTimeout = this._blendTimeout;
                if (blendTimeout != null) {
                    window.clearTimeout(blendTimeout);
                }
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            return this;
        };
        DChartPlotArea.prototype.onBlend = function () {
            var now = Date.now();
            var ratio = (now - this._blendStartTime) / this._blendDuration;
            if (ratio < 1) {
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            else {
                this._blendTimeout = null;
                ratio = 1;
            }
            this._coordinate.blend(DAnimationTimings.ELASTIC(ratio));
            this._axis.update();
            this._series.update();
        };
        return DChartPlotArea;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartRegionImplObservable = /** @class */ (function () {
        function DChartRegionImplObservable(from, to, onChange) {
            this._from = from;
            this._to = to;
            this._onChange = onChange;
        }
        Object.defineProperty(DChartRegionImplObservable.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                this.set(from, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartRegionImplObservable.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                this.set(undefined, to);
            },
            enumerable: false,
            configurable: true
        });
        DChartRegionImplObservable.prototype.set = function (from, to) {
            var isChanged = false;
            if (from != null && this._from !== from) {
                if (!isNaN(this._from) || !isNaN(from)) {
                    this._from = from;
                    isChanged = true;
                }
            }
            if (to != null && this._to !== to) {
                if (!isNaN(this._to) || !isNaN(to)) {
                    this._to = to;
                    isChanged = true;
                }
            }
            if (isChanged) {
                this._onChange();
            }
            return this;
        };
        DChartRegionImplObservable.prototype.add = function (from, to) {
            var newFrom;
            if (!isNaN(from)) {
                newFrom = isNaN(this.from) ? from : Math.min(this.from, from);
            }
            var newTo;
            if (!isNaN(to)) {
                newTo = isNaN(this.to) ? to : Math.max(this.to, to);
            }
            return this.set(newFrom, newTo);
        };
        DChartRegionImplObservable.prototype.clear = function () {
            return this.set(NaN, NaN);
        };
        return DChartRegionImplObservable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionShapeBase = /** @class */ (function () {
        function DChartSelectionShapeBase(options) {
            var _a, _b, _c;
            var theme = this.toTheme(options);
            this._theme = theme;
            var state = new DBaseStateSetImpl().add((_a = options === null || options === void 0 ? void 0 : options.state) !== null && _a !== void 0 ? _a : DBaseState.HOVERED);
            this._state = state;
            this._isEnabled = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isEnabled(state);
            this._shape = options === null || options === void 0 ? void 0 : options.shape;
            this._style = (_c = options === null || options === void 0 ? void 0 : options.style) !== null && _c !== void 0 ? _c : this.setStyle;
        }
        DChartSelectionShapeBase.prototype.bind = function (container) {
            if (this._isEnabled) {
                var shape = this._shape || this.newShape(this._theme);
                this._shape = shape;
                shape.attach(container.plotArea.axis.container);
                shape.visible = false;
            }
        };
        DChartSelectionShapeBase.prototype.unbind = function () {
            var shape = this._shape;
            if (shape) {
                shape.detach();
            }
        };
        DChartSelectionShapeBase.prototype.newShape = function (theme) {
            return theme.newShape(this._state);
        };
        DChartSelectionShapeBase.prototype.set = function (container, mappedPosition, series) {
            this.update(container, mappedPosition);
            var shape = this._shape;
            if (shape) {
                this._style(shape, series);
            }
        };
        DChartSelectionShapeBase.prototype.setStyle = function (shape, series) {
            var seriesShape = series.shape;
            if (seriesShape) {
                shape.stroke.color = seriesShape.stroke.color;
            }
        };
        DChartSelectionShapeBase.prototype.unset = function () {
            var shape = this._shape;
            if (shape) {
                shape.visible = false;
            }
        };
        DChartSelectionShapeBase.prototype.toTheme = function (options) {
            var theme = options === null || options === void 0 ? void 0 : options.theme;
            if (isString(theme)) {
                return this.getTheme(theme);
            }
            else if (theme != null) {
                return theme;
            }
            else {
                return this.getTheme(this.getType());
            }
        };
        DChartSelectionShapeBase.prototype.getTheme = function (type) {
            return DThemes.getInstance().get(type);
        };
        return DChartSelectionShapeBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineX = /** @class */ (function (_super) {
        __extends(DChartSelectionGridlineX, _super);
        function DChartSelectionGridlineX() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionGridlineX.prototype.update = function (container, mappedPosition) {
            var shape = this._shape;
            if (shape) {
                var mappedX = mappedPosition.x;
                var height = container.plotArea.height;
                shape.transform.position.set(mappedX, height * 0.5);
                shape.size.set(0, height);
                shape.visible = this.isVisible(container, mappedX);
            }
        };
        DChartSelectionGridlineX.prototype.isVisible = function (container, mappedX) {
            return 0 <= mappedX && mappedX <= container.plotArea.width;
        };
        DChartSelectionGridlineX.prototype.getType = function () {
            return "DChartSelectionGridlineX";
        };
        return DChartSelectionGridlineX;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineY = /** @class */ (function (_super) {
        __extends(DChartSelectionGridlineY, _super);
        function DChartSelectionGridlineY() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionGridlineY.prototype.update = function (container, mappedPosition) {
            var shape = this._shape;
            if (shape) {
                var mappedY = mappedPosition.y;
                var width = container.plotArea.width;
                shape.transform.position.set(width * 0.5, mappedY);
                shape.size.set(width, 0);
                shape.visible = this.isVisible(container, mappedY);
            }
        };
        DChartSelectionGridlineY.prototype.isVisible = function (container, mappedY) {
            return 0 <= mappedY && mappedY <= container.plotArea.height;
        };
        DChartSelectionGridlineY.prototype.getType = function () {
            return "DChartSelectionGridlineY";
        };
        return DChartSelectionGridlineY;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineContainerImpl = /** @class */ (function () {
        function DChartSelectionGridlineContainerImpl(options) {
            this._x = new DChartSelectionGridlineX(options === null || options === void 0 ? void 0 : options.x);
            this._y = new DChartSelectionGridlineY(options === null || options === void 0 ? void 0 : options.y);
        }
        Object.defineProperty(DChartSelectionGridlineContainerImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionGridlineContainerImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: false,
            configurable: true
        });
        DChartSelectionGridlineContainerImpl.prototype.bind = function (container) {
            this._x.bind(container);
            this._y.bind(container);
        };
        DChartSelectionGridlineContainerImpl.prototype.unbind = function () {
            this._x.unbind();
            this._y.unbind();
        };
        DChartSelectionGridlineContainerImpl.prototype.set = function (container, mappedPosition, series) {
            this._x.set(container, mappedPosition, series);
            this._y.set(container, mappedPosition, series);
        };
        DChartSelectionGridlineContainerImpl.prototype.unset = function () {
            this._x.unset();
            this._y.unset();
        };
        DChartSelectionGridlineContainerImpl.prototype.update = function (container, mappedPosition) {
            this._x.update(container, mappedPosition);
            this._y.update(container, mappedPosition);
        };
        return DChartSelectionGridlineContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionMarker = /** @class */ (function (_super) {
        __extends(DChartSelectionMarker, _super);
        function DChartSelectionMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionMarker.prototype.update = function (container, mappedPosition) {
            var shape = this._shape;
            if (shape) {
                shape.transform.position.copyFrom(mappedPosition);
                shape.visible = this.isVisible(container, mappedPosition);
            }
        };
        DChartSelectionMarker.prototype.isVisible = function (container, mappedPosition) {
            var x = mappedPosition.x;
            var y = mappedPosition.y;
            var plotArea = container.plotArea;
            return 0 <= x && x <= plotArea.width && 0 <= y && y <= plotArea.height;
        };
        DChartSelectionMarker.prototype.getType = function () {
            return "DChartSelectionMarker";
        };
        return DChartSelectionMarker;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionPoint;
    (function (DChartSelectionPoint) {
        DChartSelectionPoint[DChartSelectionPoint["PREVIOUS"] = 0] = "PREVIOUS";
        DChartSelectionPoint[DChartSelectionPoint["NEXT"] = 1] = "NEXT";
        DChartSelectionPoint[DChartSelectionPoint["CLOSER"] = 2] = "CLOSER";
        DChartSelectionPoint[DChartSelectionPoint["INTERSECTION"] = 3] = "INTERSECTION";
    })(DChartSelectionPoint || (DChartSelectionPoint = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionSubImpl = /** @class */ (function (_super) {
        __extends(DChartSelectionSubImpl, _super);
        function DChartSelectionSubImpl(options) {
            var _a, _b, _c;
            var _this = _super.call(this) || this;
            _this._container = null;
            _this._series = null;
            _this._isEnabled = (_a = options.enable) !== null && _a !== void 0 ? _a : true;
            _this._gridline = new DChartSelectionGridlineContainerImpl(options.gridline);
            _this._marker = new DChartSelectionMarker(options.marker);
            _this._state = (_b = options.state) !== null && _b !== void 0 ? _b : DBaseState.HOVERED;
            _this._coordinateX = null;
            _this._coordinateY = null;
            _this._position = new pixi_js.Point();
            _this._point = (_c = options.point) !== null && _c !== void 0 ? _c : DChartSelectionPoint.CLOSER;
            _this._work = new pixi_js.Point();
            // Events
            var on = options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DChartSelectionSubImpl.prototype.bind = function (container) {
            if (this._isEnabled) {
                this._container = container;
                this._gridline.bind(container);
                this._marker.bind(container);
            }
        };
        DChartSelectionSubImpl.prototype.unbind = function () {
            this._marker.unbind();
            this._gridline.unbind();
            this._container = null;
            this._coordinateX = null;
            this._coordinateY = null;
        };
        Object.defineProperty(DChartSelectionSubImpl.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "gridline", {
            get: function () {
                return this._gridline;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "marker", {
            get: function () {
                return this._marker;
            },
            enumerable: false,
            configurable: true
        });
        DChartSelectionSubImpl.prototype.set = function (series, result) {
            var container = this._container;
            var coordinateX = (this._coordinateX = series.coordinate.x);
            var coordinateY = (this._coordinateY = series.coordinate.y);
            if (container && coordinateX && coordinateY) {
                var transform = container.plotArea.container.localTransform;
                var position = this._position;
                var work = this._work;
                if (result instanceof DChartSeriesHitResult) {
                    var x = result.x;
                    var y = result.y;
                    switch (this._point) {
                        case DChartSelectionPoint.PREVIOUS:
                            x = result.p0x;
                            y = result.p0y;
                            break;
                        case DChartSelectionPoint.NEXT:
                            x = result.p1x;
                            y = result.p1y;
                            break;
                        case DChartSelectionPoint.CLOSER:
                            if (Math.abs(result.p0x - result.x) < Math.abs(result.p1x - result.x)) {
                                x = result.p0x;
                                y = result.p0y;
                            }
                            else {
                                x = result.p1x;
                                y = result.p1y;
                            }
                    }
                    work.set(x, y);
                    transform.apply(work, work);
                    position.set(coordinateX.unmap(coordinateX.transform.unmap(x)), coordinateY.unmap(coordinateY.transform.unmap(y)));
                }
                else {
                    position.copyFrom(result.position);
                    work.set(coordinateX.transform.map(coordinateX.map(position.x)), coordinateY.transform.map(coordinateY.map(position.y)));
                    transform.apply(work, work);
                }
                this._gridline.set(container, work, series);
                this._marker.set(container, work, series);
                DApplications.update(container.plotArea);
            }
            var oldSeries = this._series;
            if (oldSeries !== series) {
                var state = this._state;
                if (oldSeries) {
                    oldSeries.state.remove(state);
                }
                this._series = series;
                series.state.add(state);
            }
            this.emit("change", this);
        };
        DChartSelectionSubImpl.prototype.setStyle = function (shape, series) {
            var seriesShape = series.shape;
            if (seriesShape) {
                shape.stroke.color = seriesShape.stroke.color;
            }
        };
        DChartSelectionSubImpl.prototype.unset = function () {
            var series = this._series;
            if (series) {
                this._series = null;
                this._coordinateX = null;
                this._coordinateY = null;
                series.state.remove(this._state);
                this._gridline.unset();
                this._marker.unset();
                this.emit("change", this);
            }
        };
        DChartSelectionSubImpl.prototype.update = function () {
            var container = this._container;
            var coordinateX = this._coordinateX;
            var coordinateY = this._coordinateY;
            if (container && coordinateX && coordinateY) {
                var position = this._position;
                var work = this._work;
                work.set(coordinateX.transform.map(coordinateX.map(position.x)), coordinateY.transform.map(coordinateY.map(position.y)));
                container.plotArea.container.localTransform.apply(work, work);
                this._gridline.update(container, work);
                this._marker.update(container, work);
            }
        };
        return DChartSelectionSubImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionSimple = /** @class */ (function (_super) {
        __extends(DChartSelectionSimple, _super);
        function DChartSelectionSimple(options) {
            var _a;
            var _this = _super.call(this) || this;
            _this._container = null;
            var point = toEnum((_a = options === null || options === void 0 ? void 0 : options.point) !== null && _a !== void 0 ? _a : DChartSelectionPoint.CLOSER, DChartSelectionPoint);
            _this._selected = _this.newSelected(point, options === null || options === void 0 ? void 0 : options.selected);
            _this._hovered = _this.newHovered(point, options === null || options === void 0 ? void 0 : options.hovered);
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            //
            _this._onMoveBound = function (e) {
                _this.onMove(e);
            };
            _this._onClickBound = function (e) {
                _this.onClick(e);
            };
            return _this;
        }
        DChartSelectionSimple.prototype.newSelected = function (point, options) {
            return new DChartSelectionSubImpl(this.toSubOptions(point, options, DBaseState.ACTIVE));
        };
        DChartSelectionSimple.prototype.newHovered = function (point, options) {
            return new DChartSelectionSubImpl(this.toSubOptions(point, options, DBaseState.HOVERED));
        };
        DChartSelectionSimple.prototype.toSubOptions = function (point, options, state) {
            options = options || {};
            if (options.point == null) {
                options.point = point;
            }
            if (options.state == null) {
                options.state = state;
            }
            var gridline = options.gridline || {};
            var gridlineX = gridline.x || {};
            if (gridlineX.state == null) {
                gridlineX.state = state;
            }
            var gridlineY = gridline.y || {};
            if (gridlineY.state == null) {
                gridlineY.state = state;
            }
            var marker = options.marker || {};
            if (marker.state == null) {
                marker.state = state;
            }
            return options;
        };
        DChartSelectionSimple.prototype.onClick = function (e) {
            var container = this._container;
            if (container && e.target === container.plotArea) {
                var hovered = this._hovered;
                var series = hovered.series;
                var selected = this._selected;
                if (series) {
                    selected.set(series, hovered);
                }
                else {
                    selected.unset();
                }
            }
        };
        DChartSelectionSimple.prototype.onMove = function (e) {
            var container = this._container;
            if (container) {
                var hovered = this._hovered;
                if (e.target === container.plotArea) {
                    var result = DChartSelectionSimple.WORK_SELECT;
                    var series = container.calcHitPoint(e.data.global, result);
                    if (series) {
                        hovered.set(series, result);
                    }
                    else {
                        hovered.unset();
                    }
                }
                else {
                    hovered.unset();
                }
            }
        };
        DChartSelectionSimple.prototype.bind = function (container) {
            this._container = container;
            this._selected.bind(container);
            this._hovered.bind(container);
            var plotArea = container.plotArea;
            plotArea.on(UtilPointerEvent.move, this._onMoveBound);
            UtilPointerEvent.onClick(plotArea, this._onClickBound);
        };
        DChartSelectionSimple.prototype.unbind = function () {
            var container = this._container;
            this._container = null;
            if (container) {
                var plotArea = container.plotArea;
                plotArea.off(UtilPointerEvent.move, this._onMoveBound);
            }
            this._selected.unbind();
            this._hovered.unbind();
        };
        Object.defineProperty(DChartSelectionSimple.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSimple.prototype, "hovered", {
            get: function () {
                return this._hovered;
            },
            enumerable: false,
            configurable: true
        });
        DChartSelectionSimple.prototype.update = function () {
            this._selected.update();
            this._hovered.update();
        };
        DChartSelectionSimple.WORK_SELECT = new DChartSeriesHitResult();
        return DChartSelectionSimple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesBaseCoordinateContainer = /** @class */ (function () {
        function DChartSeriesBaseCoordinateContainer(parent, options) {
            var _a, _b;
            this._parent = parent;
            this._coordinateIndexX = (_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0;
            this._coordinateIndexY = (_b = options === null || options === void 0 ? void 0 : options.y) !== null && _b !== void 0 ? _b : 0;
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
            this._coordinateTransformIdUpdatedX = NaN;
            this._coordinateTransformIdUpdatedY = NaN;
        }
        Object.defineProperty(DChartSeriesBaseCoordinateContainer.prototype, "x", {
            get: function () {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.x.get(this._coordinateIndexX);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBaseCoordinateContainer.prototype, "y", {
            get: function () {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.y.get(this._coordinateIndexY);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesBaseCoordinateContainer.prototype.isDirty = function (coordinateX, coordinateY) {
            var coordinateIdX = coordinateX.id;
            var coordinateIdY = coordinateY.id;
            var isCoordinateXChanged = coordinateIdX !== this._coordinateIdUpdatedX;
            var isCoordinateYChanged = coordinateIdY !== this._coordinateIdUpdatedY;
            this._coordinateIdUpdatedX = coordinateIdX;
            this._coordinateIdUpdatedY = coordinateIdY;
            return isCoordinateXChanged || isCoordinateYChanged;
        };
        DChartSeriesBaseCoordinateContainer.prototype.isTransformDirty = function (coordinateX, coordinateY) {
            var coordinateTransformIdX = coordinateX.transform.id;
            var coordinateTransformIdY = coordinateY.transform.id;
            var isCoordinateTransformXChanged = coordinateTransformIdX !== this._coordinateTransformIdUpdatedX;
            var isCoordinateTransformYChanged = coordinateTransformIdY !== this._coordinateTransformIdUpdatedY;
            this._coordinateTransformIdUpdatedX = coordinateTransformIdX;
            this._coordinateTransformIdUpdatedY = coordinateTransformIdY;
            return isCoordinateTransformXChanged || isCoordinateTransformYChanged;
        };
        DChartSeriesBaseCoordinateContainer.prototype.reset = function () {
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
        };
        DChartSeriesBaseCoordinateContainer.prototype.destroy = function () {
            this.reset();
        };
        return DChartSeriesBaseCoordinateContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     */
    var DChartSeriesBase = /** @class */ (function (_super) {
        __extends(DChartSeriesBase, _super);
        function DChartSeriesBase(options) {
            var _this = _super.call(this) || this;
            _this._coordinate = new DChartSeriesBaseCoordinateContainer(_this, options === null || options === void 0 ? void 0 : options.coordinate);
            _this._index = 0;
            _this._domain = new DChartRegionImpl(NaN, NaN);
            _this._range = new DChartRegionImpl(NaN, NaN);
            _this._regionPointId = NaN;
            _this._state = new DBaseStateSetImplObservable(function (newState, oldState) {
                _this.onStateChange(newState, oldState);
            });
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DChartSeriesBase.prototype.bind = function (container, index) {
            this._container = container;
            this._coordinate.reset();
            this._index = index;
            var chart = container.plotArea.chart;
            if (chart) {
                this._state.parent = chart.state;
            }
        };
        DChartSeriesBase.prototype.unbind = function () {
            this._container = undefined;
        };
        Object.defineProperty(DChartSeriesBase.prototype, "domain", {
            get: function () {
                this.updateRegion();
                return this._domain;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "range", {
            get: function () {
                this.updateRegion();
                return this._range;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "container", {
            get: function () {
                return this._container || null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesBase.prototype.destroy = function () {
            this._container = undefined;
            this._coordinate.destroy();
        };
        DChartSeriesBase.prototype.hitTest = function (global) {
            return false;
        };
        DChartSeriesBase.prototype.calcHitPoint = function (global, result) {
            return false;
        };
        DChartSeriesBase.prototype.onStateChange = function (newState, oldState) {
            var _a;
            this.toDirty();
            var chart = (_a = this._container) === null || _a === void 0 ? void 0 : _a.plotArea.chart;
            DApplications.update(chart);
            this.emit("statechange", newState, oldState, this);
        };
        return DChartSeriesBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of anything.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfAny = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfAny, _super);
        function DChartSeriesLineOfAny(options) {
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._points = (options && options.points) || [];
            _this._pointId = 0;
            _this._pointIdUpdated = NaN;
            return _this;
        }
        DChartSeriesLineOfAny.prototype.getSizeDefault = function () {
            return 10;
        };
        DChartSeriesLineOfAny.prototype.getOffsetDefault = function () {
            return 0;
        };
        DChartSeriesLineOfAny.prototype.bind = function (container, index) {
            var line = this._line;
            if (!line) {
                line = this._line = this.newLineOfAny();
                var options = this._options;
                this.initLine(line, options, container, index);
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
        };
        DChartSeriesLineOfAny.prototype.initLine = function (line, options, container, index) {
            var fill = container.newFill(index, options === null || options === void 0 ? void 0 : options.fill);
            this._fill = fill;
            line.fill.copy(fill);
            var stroke = container.newStroke(index, options === null || options === void 0 ? void 0 : options.stroke);
            this._stroke = stroke;
            line.stroke.copy(stroke);
            var sizeDefault = this.getSizeDefault();
            var size = container.newSize(index, options === null || options === void 0 ? void 0 : options.size, sizeDefault, sizeDefault);
            this._size = size;
            line.points.size.set(size.x, size.y);
            var offsetDefault = this.getOffsetDefault();
            var offset = container.newOffset(index, options && options.offset, offsetDefault, offsetDefault);
            this._offset = offset;
            line.points.offset.set(offset.x, offset.y);
        };
        DChartSeriesLineOfAny.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
        };
        Object.defineProperty(DChartSeriesLineOfAny.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLineOfAny.prototype, "points", {
            get: function () {
                return this._points;
            },
            set: function (points) {
                this._points = points;
                this._pointId += 1;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesLineOfAny.prototype.toDirty = function () {
            this._pointId += 1;
        };
        DChartSeriesLineOfAny.prototype.update = function () {
            var line = this._line;
            if (line) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var pointId = this._pointId;
                    var isPointChanged = pointId !== this._pointIdUpdated;
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.updateLine(line, coordinateX, coordinateY);
                    }
                }
            }
        };
        DChartSeriesLineOfAny.prototype.updateLine = function (line, xcoordinate, ycoordinate) {
            var values = line.points.values;
            var valuesLength = values.length;
            var ivalues = 0;
            var points = this._points;
            var xmin = NaN;
            var xmax = NaN;
            var ymin = NaN;
            var ymax = NaN;
            for (var i = 0, imax = points.length; i < imax; i += 2) {
                var x = points[i];
                var y = points[i + 1];
                if (x != null && y != null) {
                    if (ivalues < valuesLength) {
                        values[ivalues] = x;
                        values[ivalues + 1] = y;
                    }
                    else {
                        values.push(x, y);
                    }
                    ivalues += 2;
                    if (xmin !== xmin) {
                        xmin = x;
                        xmax = x;
                        ymin = y;
                        ymax = y;
                    }
                    else {
                        xmin = Math.min(xmin, x);
                        xmax = Math.max(xmax, x);
                        ymin = Math.min(ymin, y);
                        ymax = Math.max(ymax, y);
                    }
                }
            }
            if (values.length !== ivalues) {
                values.length = ivalues;
            }
            xcoordinate.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.mapAll(values, 0, ivalues, 2, 1);
            xcoordinate.transform.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.transform.mapAll(values, 0, ivalues, 2, 1);
            if (xmin !== xmin) {
                xmin = 0;
                xmax = 0;
                ymin = 0;
                ymax = 0;
            }
            var region = DChartSeriesLineOfAny.WORK_REGION || {
                xmin: 0,
                xmax: 0,
                ymin: 0,
                ymax: 0
            };
            DChartSeriesLineOfAny.WORK_REGION = region;
            this.adjustLineRegion(xmin, xmax, ymin, ymax, region);
            xmin = xcoordinate.transform.map(xcoordinate.map(region.xmin));
            xmax = xcoordinate.transform.map(xcoordinate.map(region.xmax));
            ymin = ycoordinate.transform.map(ycoordinate.map(region.ymin));
            ymax = ycoordinate.transform.map(ycoordinate.map(region.ymax));
            var sx = Math.abs(xmax - xmin);
            var sy = Math.abs(ymax - ymin);
            var cx = (xmin + xmax) * 0.5;
            var cy = (ymin + ymax) * 0.5;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                values[i + 0] -= cx;
                values[i + 1] -= cy;
            }
            line.disallowUploadedUpdate();
            this.applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
            line.allowUploadedUpdate();
            DApplications.update(line);
        };
        DChartSeriesLineOfAny.prototype.adjustLineRegion = function (xmin, xmax, ymin, ymax, result) {
            result.xmin = xmin;
            result.xmax = xmax;
            result.ymin = ymin;
            result.ymax = ymax;
            return result;
        };
        DChartSeriesLineOfAny.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            line.points.set(values);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
        };
        DChartSeriesLineOfAny.prototype.updateRegion = function () {
            var pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                var points = this._points;
                var domain = this._domain;
                var range = this._range;
                domain.clear();
                range.clear();
                this.calcRegion(points, domain, range);
            }
        };
        DChartSeriesLineOfAny.prototype.calcRegion = function (points, domain, range) {
            for (var i = 0, imax = points.length; i < imax; i += 2) {
                var xraw = points[i];
                if (xraw != null) {
                    domain.add(xraw, xraw);
                }
                var yraw = points[i + 1];
                if (yraw != null) {
                    range.add(yraw, yraw);
                }
            }
        };
        DChartSeriesLineOfAny.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            _super.prototype.destroy.call(this);
        };
        DChartSeriesLineOfAny.prototype.hitTest = function (global) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLineOfAny.WORK;
                var local = line.toLocal(global, undefined, work);
                return line.contains(local) != null;
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.calcHitPoint = function (global, result) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLineOfAny.WORK;
                var local = line.toLocal(global, undefined, work);
                result.shape = line;
                return line.calcHitPoint(local, null, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.calcHitPointTestRange = function (x, y, ax, ay, ox, oy, threshold, values, result) {
            var to = toCeilingIndex(values, x + ax + ox, 2, 0);
            var from = 0;
            for (var i = to - 1, iv = i << 1; 0 <= i; i -= 1, iv -= 2) {
                if (values[iv] <= x - ax) {
                    from = i;
                    break;
                }
            }
            result[0] = from;
            result[1] = from !== to ? to : Math.min(values.length << 1, to + 1);
            return result;
        };
        DChartSeriesLineOfAny.prototype.calcHitPointHitTester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, index, threshold, result) {
            var shape = result.shape;
            if (shape.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss)) {
                var transform = shape.transform;
                var position = transform.position;
                var scale = transform.scale;
                result.x = result.p0x = result.p1x = position.x + scale.x * px;
                result.y = result.p0y = result.p1y = position.y + scale.y * py;
                result.t = threshold;
                result.index = index;
                var dx = x - (px + ox);
                var dy = y - (py + oy);
                result.distance = Math.sqrt(dx * dx + dy * dy);
                return true;
            }
            return false;
        };
        DChartSeriesLineOfAny.WORK = new pixi_js.Point();
        return DChartSeriesLineOfAny;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents bars.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesBar = /** @class */ (function (_super) {
        __extends(DChartSeriesBar, _super);
        function DChartSeriesBar(options) {
            var _this = _super.call(this, options) || this;
            _this._barCount = -1;
            _this._barIndex = -1;
            _this._xcoordinateId = -1;
            _this._xcoordinateTransformId = -1;
            _this._isSizeAutomatic = (options && options.size && options.size.auto) !== false;
            return _this;
        }
        DChartSeriesBar.prototype.bind = function (container, index) {
            this._barCount = -1;
            this._barIndex = -1;
            this._xcoordinateId = -1;
            this._xcoordinateTransformId = -1;
            _super.prototype.bind.call(this, container, index);
        };
        DChartSeriesBar.prototype.initLine = function (line, options, container, index) {
            _super.prototype.initLine.call(this, line, options, container, index);
            this._padding = container.newPadding(index, options && options.padding);
        };
        DChartSeriesBar.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangles();
        };
        DChartSeriesBar.prototype.getSizeDefault = function () {
            return 1;
        };
        DChartSeriesBar.prototype.adjustLineRegion = function (xmin, xmax, ymin, ymax, result) {
            return _super.prototype.adjustLineRegion.call(this, xmin, xmax, Math.min(0, ymin), Math.max(0, ymax), result);
        };
        DChartSeriesBar.prototype.updateBarCountAndIndex = function () {
            if (this._barIndex < 0 || this._barCount < 0) {
                var barIndex = 0;
                var barCount = 0;
                var container = this._container;
                if (container) {
                    for (var i = 0, imax = container.size(); i < imax; ++i) {
                        var series = container.get(i);
                        if (series === this) {
                            barIndex = barCount;
                        }
                        if (series instanceof DChartSeriesBar) {
                            barCount += 1;
                        }
                    }
                }
                barCount = Math.max(1, barCount);
                this._barCount = barCount;
                this._barIndex = barIndex;
                return true;
            }
            return false;
        };
        DChartSeriesBar.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            var linePoints = line.points;
            var linePointsOffset = linePoints.offset;
            var linePointsSize = linePoints.size;
            // Offset
            var size = this._size;
            var offset = this._offset;
            var padding = this._padding;
            if (size && offset && padding) {
                var xcoordinateId = xcoordinate.id;
                var xcoordinateTransformId = xcoordinate.transform.id;
                if (this.updateBarCountAndIndex() ||
                    this._xcoordinateId !== xcoordinateId ||
                    this._xcoordinateTransformId !== xcoordinateTransformId) {
                    var barCount = this._barCount;
                    var barIndex = this._barIndex;
                    this._xcoordinateId = xcoordinateId;
                    this._xcoordinateTransformId = xcoordinateTransformId;
                    var x0 = xcoordinate.transform.map(xcoordinate.map(0));
                    var x1 = xcoordinate.transform.map(xcoordinate.map(size.x));
                    var totalBandWidth = Math.abs(x0 - x1) * (1 - padding.outer);
                    if (barCount <= 1) {
                        linePointsOffset.x = offset.x;
                        linePointsSize.x = totalBandWidth;
                    }
                    else {
                        var totalBarWidth = totalBandWidth * (1 - padding.inner);
                        var totalPaddingInner = totalBandWidth - totalBarWidth;
                        var barWidth = totalBarWidth / barCount;
                        var barPadding = totalPaddingInner / (barCount - 1);
                        var barX = barWidth * (barIndex + 0.5) + barIndex * barPadding;
                        linePointsOffset.x = offset.x + barX - totalBandWidth * 0.5;
                        linePointsSize.x = barWidth;
                    }
                }
            }
            // Sizes & Offsets
            var sizes = linePointsSize.y;
            if (!isArray(sizes)) {
                sizes = [];
            }
            var sizesLength = sizes.length;
            var offsets = linePointsOffset.y;
            if (!isArray(offsets)) {
                offsets = [];
            }
            var offsetsLength = offsets.length;
            var isize = 0;
            var y0 = ycoordinate.transform.map(ycoordinate.map(0)) - cy;
            for (var i = 0, imax = values.length; i < imax; i += 2, isize += 1) {
                var distance = values[i + 1] - y0;
                var s = Math.abs(distance);
                if (isize < sizesLength) {
                    sizes[isize] = s;
                }
                else {
                    sizes.push(s);
                }
                var o = -0.5 * distance;
                if (isize < offsetsLength) {
                    offsets[isize] = o;
                }
                else {
                    offsets.push(o);
                }
            }
            if (sizes.length !== isize) {
                sizes.length = isize;
            }
            if (offsets.length !== isize) {
                offsets.length = isize;
            }
            linePointsOffset.y = offsets;
            linePointsSize.y = sizes;
            // Others
            _super.prototype.applyLine.call(this, line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        };
        DChartSeriesBar.prototype.calcSizeX = function (def) {
            var points = this._points;
            if (2 < points.length) {
                var pointsLength = points.length;
                var x0 = points[pointsLength - 2];
                for (var i = pointsLength - 4; 0 <= i; i -= 2) {
                    var x1 = points[i];
                    if (x0 != null && x1 != null) {
                        return Math.abs(x0 - x1);
                    }
                    else {
                        x0 = x1;
                    }
                }
            }
            return def;
        };
        DChartSeriesBar.prototype.calcRegion = function (points, domain, range) {
            _super.prototype.calcRegion.call(this, points, domain, range);
            var size = this._size;
            if (size) {
                var sx = size.x;
                if (this._isSizeAutomatic) {
                    sx = this.calcSizeX(sx);
                    size.x = sx;
                }
                var sxh = sx * 0.5;
                domain.set(domain.from - sxh, domain.to + sxh);
            }
            range.add(0, 0);
        };
        return DChartSeriesBar;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of circles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfCircles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfCircles, _super);
        function DChartSeriesLineOfCircles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfCircles.prototype.newLineOfAny = function () {
            return new EShapeLineOfCircles();
        };
        return DChartSeriesLineOfCircles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfRectangleRoundeds, _super);
        function DChartSeriesLineOfRectangleRoundeds() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfRectangleRoundeds.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangleRoundeds();
        };
        return DChartSeriesLineOfRectangleRoundeds;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfRectangles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfRectangles, _super);
        function DChartSeriesLineOfRectangles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfRectangles.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangles();
        };
        return DChartSeriesLineOfRectangles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfTriangles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfTriangles, _super);
        function DChartSeriesLineOfTriangles(options) {
            var _this = _super.call(this, options) || this;
            _this._sizeId = 0;
            return _this;
        }
        DChartSeriesLineOfTriangles.prototype.newLineOfAny = function () {
            return new EShapeLineOfTriangles();
        };
        DChartSeriesLineOfTriangles.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            // Offset
            var size = this._size;
            var offset = this._offset;
            if (size && offset && this._sizeId !== size.y) {
                this._sizeId = size.y;
                line.points.offset.y = offset.y - size.y * 0.2;
            }
            //
            _super.prototype.applyLine.call(this, line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        };
        return DChartSeriesLineOfTriangles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfTriangleRoundeds, _super);
        function DChartSeriesLineOfTriangleRoundeds() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfTriangleRoundeds.prototype.newLineOfAny = function () {
            return new EShapeLineOfTriangleRoundeds();
        };
        return DChartSeriesLineOfTriangleRoundeds;
    }(DChartSeriesLineOfTriangles));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLine = /** @class */ (function (_super) {
        __extends(DChartSeriesLine, _super);
        function DChartSeriesLine(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._points = (_a = options === null || options === void 0 ? void 0 : options.points) !== null && _a !== void 0 ? _a : [];
            _this._pointId = 0;
            _this._pointIdUpdated = NaN;
            _this._centerX = 0;
            _this._centerY = 0;
            return _this;
        }
        DChartSeriesLine.prototype.bind = function (container, index) {
            var _a;
            var line = this._line;
            if (!line) {
                var stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                this._stroke = stroke;
                line = new EShapeLine([], [], stroke.width, EShapePointsStyle.NONE);
                line.stroke.copy(stroke);
                this._line = line;
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
        };
        DChartSeriesLine.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
        };
        Object.defineProperty(DChartSeriesLine.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLine.prototype, "points", {
            get: function () {
                return this._points;
            },
            set: function (points) {
                this._points = points;
                this._pointId += 1;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesLine.prototype.toDirty = function () {
            this._pointId += 1;
        };
        DChartSeriesLine.prototype.update = function () {
            var line = this._line;
            if (line) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var pointId = this._pointId;
                    var isPointChanged = pointId !== this._pointIdUpdated;
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.updateLine(line, coordinateX, coordinateY, isPointChanged || isCoordinateChanged);
                    }
                }
            }
        };
        DChartSeriesLine.prototype.updateLine = function (line, xcoordinate, ycoordinate, isPointsDirty) {
            line.disallowUploadedUpdate();
            if (isPointsDirty) {
                var values = line.points.values;
                var segments = line.points.segments;
                var valuesLength = values.length;
                var segmentsLength = segments.length;
                var ivalues = 0;
                var isegments = 0;
                var points = this._points;
                var xmin = NaN;
                var xmax = NaN;
                var ymin = NaN;
                var ymax = NaN;
                for (var i = 0, imax = points.length; i < imax; i += 2) {
                    var x = points[i];
                    var y = points[i + 1];
                    if (x != null && y != null) {
                        if (ivalues < valuesLength) {
                            values[ivalues] = x;
                            values[ivalues + 1] = y;
                        }
                        else {
                            values.push(x, y);
                        }
                        ivalues += 2;
                        if (xmin !== xmin) {
                            xmin = x;
                            xmax = x;
                            ymin = y;
                            ymax = y;
                        }
                        else {
                            xmin = Math.min(xmin, x);
                            xmax = Math.max(xmax, x);
                            ymin = Math.min(ymin, y);
                            ymax = Math.max(ymax, y);
                        }
                    }
                    else {
                        var segment = (i >> 1) - isegments;
                        if (isegments < segmentsLength) {
                            segments[isegments] = segment;
                        }
                        else {
                            segments.push(segment);
                        }
                        isegments += 1;
                    }
                }
                if (values.length !== ivalues) {
                    values.length = ivalues;
                }
                if (segments.length !== isegments) {
                    segments.length = isegments;
                }
                xcoordinate.mapAll(values, 0, ivalues, 2, 0);
                ycoordinate.mapAll(values, 0, ivalues, 2, 1);
                if (xmin !== xmin) {
                    xmin = 0;
                    xmax = 0;
                    ymin = 0;
                    ymax = 0;
                }
                xmin = xcoordinate.map(xmin);
                xmax = xcoordinate.map(xmax);
                ymin = ycoordinate.map(ymin);
                ymax = ycoordinate.map(ymax);
                var sx = Math.abs(xmax - xmin);
                var sy = Math.abs(ymax - ymin);
                var cx = (xmin + xmax) * 0.5;
                var cy = (ymin + ymax) * 0.5;
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    values[i + 0] -= cx;
                    values[i + 1] -= cy;
                }
                line.size.set(sx, sy);
                line.points.set(values, segments);
                this._centerX = cx;
                this._centerY = cy;
            }
            line.transform.position.set(xcoordinate.transform.map(this._centerX), ycoordinate.transform.map(this._centerY));
            line.transform.scale.set(xcoordinate.transform.scale, ycoordinate.transform.scale);
            line.allowUploadedUpdate();
            DApplications.update(line);
        };
        DChartSeriesLine.prototype.updateRegion = function () {
            var pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                var points = this._points;
                var domain = this._domain;
                var range = this._range;
                domain.clear();
                range.clear();
                if (points != null) {
                    for (var i = 0, imax = points.length; i < imax; i += 2) {
                        var xraw = points[i];
                        if (xraw != null) {
                            domain.add(xraw, xraw);
                        }
                        var yraw = points[i + 1];
                        if (yraw != null) {
                            range.add(yraw, yraw);
                        }
                    }
                }
            }
        };
        DChartSeriesLine.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            _super.prototype.destroy.call(this);
        };
        DChartSeriesLine.prototype.hitTest = function (global) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLine.WORK;
                var local = line.toLocal(global, undefined, work);
                return line.contains(local) != null;
            }
            return false;
        };
        DChartSeriesLine.prototype.calcHitPoint = function (global, result) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLine.WORK;
                var local = line.toLocal(global, undefined, work);
                result.shape = line;
                return line.calcHitPoint(local, this.toThreshold, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLine.prototype.toThreshold = function (strokeWidth, strokeScale) {
            return +Infinity;
        };
        DChartSeriesLine.prototype.calcHitPointTestRange = function (x, y, threshold, values, result) {
            var index = toCeilingIndex(values, x, 2, 0);
            result[0] = Math.max(0, index - 1);
            result[1] = index;
            return result;
        };
        DChartSeriesLine.prototype.calcHitPointHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                var l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    var t = (x - p0x) / l;
                    var p2x = x;
                    var p2y = p0y + t * (p1y - p0y);
                    var distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        var transform = result.shape.transform;
                        var position = transform.position;
                        var px = position.x;
                        var py = position.y;
                        var scale = transform.scale;
                        var sx = scale.x;
                        var sy = scale.y;
                        result.x = px + sx * p2x;
                        result.y = py + sy * p2y;
                        result.p0x = px + sx * p0x;
                        result.p0y = py + sy * p0y;
                        result.p1x = px + sx * p1x;
                        result.p1y = py + sy * p1y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLine.WORK = new pixi_js.Point();
        return DChartSeriesLine;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesExpressionParametersImpl = /** @class */ (function () {
        function DChartSeriesExpressionParametersImpl(a, b, x0, y0) {
            this._id = 0;
            this._idUpdated = NaN;
            this._a = a;
            this._b = b;
            this._x0 = x0;
            this._y0 = y0;
        }
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "a", {
            get: function () {
                return this._a;
            },
            set: function (a) {
                if (this._a !== a) {
                    this._id += 1;
                    this._a = a;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "b", {
            get: function () {
                return this._b;
            },
            set: function (b) {
                if (this._b !== b) {
                    this._id += 1;
                    this._b = b;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "x0", {
            get: function () {
                return this._x0;
            },
            set: function (x0) {
                if (this._x0 !== x0) {
                    this._id += 1;
                    this._x0 = x0;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "y0", {
            get: function () {
                return this._y0;
            },
            set: function (y0) {
                if (this._y0 !== y0) {
                    this._id += 1;
                    this._y0 = y0;
                }
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesExpressionParametersImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        DChartSeriesExpressionParametersImpl.prototype.isDirty = function () {
            return this._id !== this._idUpdated;
        };
        DChartSeriesExpressionParametersImpl.prototype.toClean = function () {
            this._idUpdated = this._id;
        };
        DChartSeriesExpressionParametersImpl.from = function (options) {
            var _c, _d, _e, _f;
            return new DChartSeriesExpressionParametersImpl((_c = options === null || options === void 0 ? void 0 : options.a) !== null && _c !== void 0 ? _c : 1, (_d = options === null || options === void 0 ? void 0 : options.b) !== null && _d !== void 0 ? _d : 1, (_e = options === null || options === void 0 ? void 0 : options.x0) !== null && _e !== void 0 ? _e : 0, (_f = options === null || options === void 0 ? void 0 : options.y0) !== null && _f !== void 0 ? _f : 0);
        };
        return DChartSeriesExpressionParametersImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a linear equation `a (x - x0) === b (y - y0)`.
     */
    var DChartSeriesLinear = /** @class */ (function (_super) {
        __extends(DChartSeriesLinear, _super);
        function DChartSeriesLinear(options) {
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._plotAreaSizeXUpdated = NaN;
            _this._plotAreaSizeYUpdated = NaN;
            _this._parameters = DChartSeriesExpressionParametersImpl.from(options);
            return _this;
        }
        DChartSeriesLinear.prototype.bind = function (container, index) {
            var _a;
            var line = this._line;
            if (!line) {
                var stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                this._stroke = stroke;
                line = new EShapeLine([], [], stroke.width, EShapePointsStyle.NONE);
                line.stroke.copy(stroke);
                this._line = line;
            }
            line.attach(container.plotArea.container, index);
            this._parameters.toDirty();
            this._plotAreaSizeXUpdated = NaN;
            this._plotAreaSizeYUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
        };
        DChartSeriesLinear.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
        };
        Object.defineProperty(DChartSeriesLinear.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLinear.prototype, "parameters", {
            get: function () {
                return this._parameters;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesLinear.prototype.toDirty = function () {
            this._parameters.toDirty();
        };
        DChartSeriesLinear.prototype.update = function () {
            var line = this._line;
            var container = this._container;
            if (line && container) {
                var plotArea = container.plotArea;
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var plotAreaWidth = plotArea.width;
                    var plotAreaHeight = plotArea.height;
                    var parameters = this._parameters;
                    var isParametersChanged = parameters.isDirty();
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    var isPlotAreaSizeChagned = plotAreaWidth !== this._plotAreaSizeXUpdated ||
                        plotAreaHeight !== this._plotAreaSizeYUpdated;
                    if (isParametersChanged ||
                        isCoordinateChanged ||
                        isCoordinateTransformChanged ||
                        isPlotAreaSizeChagned) {
                        parameters.toClean();
                        this._plotAreaSizeXUpdated = plotAreaWidth;
                        this._plotAreaSizeYUpdated = plotAreaHeight;
                        this.updateLine(line, coordinateX, coordinateY, plotAreaWidth, plotAreaHeight);
                    }
                }
            }
        };
        DChartSeriesLinear.prototype.updateLine = function (line, xcoordinate, ycoordinate, plotAreaSizeX, plotAreaSizeY) {
            var values = line.points.values;
            var segments = line.points.segments;
            var parameters = this._parameters;
            var a = parameters.a;
            var b = parameters.b;
            var x0 = parameters.x0;
            var y0 = parameters.y0;
            var aabs = Math.abs(a);
            var babs = Math.abs(b);
            var p0x = NaN;
            var p0y = NaN;
            var p1x = NaN;
            var p1y = NaN;
            var threshold = 0.00001;
            if (babs <= aabs) {
                var xfrom0 = xcoordinate.unmap(xcoordinate.transform.unmap(0));
                var xto0 = xcoordinate.unmap(xcoordinate.transform.unmap(plotAreaSizeX));
                p0x = Math.min(xfrom0, xto0);
                p1x = Math.max(xfrom0, xto0);
                if (threshold < aabs) {
                    var yfrom = ycoordinate.unmap(ycoordinate.transform.unmap(0));
                    var yto = ycoordinate.unmap(ycoordinate.transform.unmap(plotAreaSizeY));
                    var xfrom1 = (b * (yfrom - y0)) / a + x0;
                    var xto1 = (b * (yto - y0)) / a + x0;
                    var p2x = Math.min(xfrom1, xto1);
                    var p3x = Math.max(xfrom1, xto1);
                    if (p0x < p2x) {
                        p0x = p2x;
                    }
                    if (p3x < p1x) {
                        p1x = p3x;
                    }
                }
                p0y = a * (p0x - x0) + b * y0;
                p1y = a * (p1x - x0) + b * y0;
            }
            else {
                var yfrom0 = ycoordinate.unmap(ycoordinate.transform.unmap(0));
                var yto0 = ycoordinate.unmap(ycoordinate.transform.unmap(plotAreaSizeY));
                p0y = Math.min(yfrom0, yto0);
                p1y = Math.max(yfrom0, yto0);
                if (threshold < babs) {
                    var xfrom = xcoordinate.unmap(xcoordinate.transform.unmap(0));
                    var xto = xcoordinate.unmap(xcoordinate.transform.unmap(plotAreaSizeX));
                    var yfrom1 = (a * (xfrom - x0)) / b + y0;
                    var yto1 = (a * (xto - x0)) / b + y0;
                    var p2y = Math.min(yfrom1, yto1);
                    var p3y = Math.max(yfrom1, yto1);
                    if (p0y < p2y) {
                        p0y = p2y;
                    }
                    if (p3y < p1y) {
                        p1y = p3y;
                    }
                }
                p0x = b * (p0y - y0) + a * x0;
                p1x = b * (p1y - y0) + a * x0;
            }
            p0x = xcoordinate.transform.map(xcoordinate.map(p0x));
            p0y = ycoordinate.transform.map(ycoordinate.map(p0y));
            p1x = xcoordinate.transform.map(xcoordinate.map(p1x));
            p1y = ycoordinate.transform.map(ycoordinate.map(p1y));
            var cx = (p0x + p1x) * 0.5;
            var cy = (p0y + p1y) * 0.5;
            var sx = Math.abs(p1x - p0x);
            var sy = Math.abs(p1y - p0y);
            p0x -= cx;
            p0y -= cy;
            p1x -= cx;
            p1y -= cy;
            if (values.length !== 4) {
                values.length = 0;
                values.push(p0x, p0y, p1x, p1y);
            }
            else {
                values[0] = p0x;
                values[1] = p0y;
                values[2] = p1x;
                values[3] = p1y;
            }
            if (0 < segments.length) {
                segments.length = 0;
            }
            line.disallowUploadedUpdate();
            line.points.set(values, segments);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
            line.allowUploadedUpdate();
            DApplications.update(line);
        };
        DChartSeriesLinear.prototype.updateRegion = function () {
            // DO NOTHING
        };
        DChartSeriesLinear.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        DChartSeriesLinear.prototype.hitTest = function (global) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLinear.WORK;
                var local = line.toLocal(global, undefined, work);
                return line.contains(local) != null;
            }
            return false;
        };
        DChartSeriesLinear.prototype.calcHitPoint = function (global, result) {
            var line = this._line;
            if (line) {
                var work = DChartSeriesLinear.WORK;
                var local = line.toLocal(global, undefined, work);
                result.shape = line;
                return line.calcHitPoint(local, this.toThreshold, null, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLinear.prototype.toThreshold = function (strokeWidth, strokeScale) {
            return +Infinity;
        };
        DChartSeriesLinear.prototype.calcHitPointHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                var l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    var t = (x - p0x) / l;
                    var p2x = x;
                    var p2y = p0y + t * (p1y - p0y);
                    var distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        var transform = result.shape.transform;
                        var position = transform.position;
                        var px = position.x;
                        var py = position.y;
                        var scale = transform.scale;
                        var sx = scale.x;
                        var sy = scale.y;
                        result.x = result.p0x = result.p1x = px + sx * p2x;
                        result.y = result.p0y = result.p1y = py + sy * p2y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLinear.WORK = new pixi_js.Point();
        return DChartSeriesLinear;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChart = /** @class */ (function (_super) {
        __extends(DChart, _super);
        function DChart() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChart.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            var plotArea = new DChartPlotArea(this, options === null || options === void 0 ? void 0 : options.plotArea);
            this._plotArea = plotArea;
            this.addChild(plotArea);
            // Overflow mask
            var mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : this.theme.isOverflowMaskEnabled();
            if (mask) {
                plotArea.axis.container.mask = this.getOverflowMask();
            }
        };
        DChart.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        Object.defineProperty(DChart.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        DChart.prototype.getType = function () {
            return "DChart";
        };
        DChart.prototype.destroy = function () {
            if (!this._destroyed) {
                this._plotArea.destroy();
                _super.prototype.destroy.call(this);
            }
        };
        return DChart;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandCreate = /** @class */ (function () {
        function DCommandCreate() {
        }
        DCommandCreate.prototype.redo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandCreate.prototype.undo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandCreate.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandCreate.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE | DCommandFlag.CLEAR;
        };
        return DCommandCreate;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandDelete = /** @class */ (function () {
        function DCommandDelete() {
        }
        DCommandDelete.prototype.execute = function () {
            return DControllers.getDocumentController().delete();
        };
        DCommandDelete.prototype.redo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandDelete.prototype.undo = function () {
            throw new Error("Method not implemented.");
        };
        DCommandDelete.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandDelete.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE | DCommandFlag.CLEAR;
        };
        return DCommandDelete;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandSaveAs = /** @class */ (function () {
        function DCommandSaveAs(name) {
            this._name = name;
        }
        DCommandSaveAs.prototype.execute = function () {
            return DControllers.getDocumentController().saveAs(this._name);
        };
        DCommandSaveAs.prototype.redo = function () {
            return true;
        };
        DCommandSaveAs.prototype.undo = function () {
            return true;
        };
        DCommandSaveAs.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandSaveAs.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE;
        };
        return DCommandSaveAs;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandSave = /** @class */ (function () {
        function DCommandSave() {
        }
        DCommandSave.prototype.execute = function () {
            return DControllers.getDocumentController().save();
        };
        DCommandSave.prototype.redo = function () {
            return true;
        };
        DCommandSave.prototype.undo = function () {
            return true;
        };
        DCommandSave.prototype.destroy = function () {
            // DO NOTHING
        };
        DCommandSave.prototype.getFlag = function () {
            return DCommandFlag.UNSTORABLE;
        };
        return DCommandSave;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramSnapshot = /** @class */ (function (_super) {
        __extends(DDiagramSnapshot, _super);
        function DDiagramSnapshot(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._cleanup = _this.toCleanup(options === null || options === void 0 ? void 0 : options.cleanup);
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DDiagramSnapshot.prototype.toCleanup = function (options) {
            if (options == null || options === true || options === false) {
                return {
                    snap: options !== false,
                    background: options !== false
                };
            }
            return {
                snap: options.snap !== false,
                background: options.background !== false
            };
        };
        /**
         * Creates a snapshot.
         *
         * @param size a maximum image size
         * @returns an URL of a created image or undefined
         */
        DDiagramSnapshot.prototype.createAsUrl = function (size) {
            return this.create(size, function (canvas) {
                return UtilExtract.base64({ target: canvas });
            });
        };
        DDiagramSnapshot.prototype.createAsFile = function (sizeOrFilename, filename) {
            if (isString(sizeOrFilename)) {
                this.create(undefined, function (canvas) {
                    return UtilExtract.file({ target: canvas, filename: sizeOrFilename });
                });
            }
            else {
                this.create(sizeOrFilename, function (canvas) {
                    return UtilExtract.file({ target: canvas, filename: filename });
                });
            }
        };
        DDiagramSnapshot.prototype.toScale = function (size, canvas) {
            if (size == null) {
                return 1;
            }
            return size / DApplications.getResolution(canvas) / Math.max(canvas.width, canvas.height);
        };
        DDiagramSnapshot.prototype.create = function (size, extractor) {
            var parent = this._parent;
            var canvas = parent.canvas;
            if (canvas) {
                var view = parent.view;
                var viewPosition = view.position;
                var viewScale = view.scale;
                var oldPositionX = viewPosition.x;
                var oldPositionY = viewPosition.y;
                var oldScaleX = viewScale.x;
                var oldScaleY = viewScale.y;
                var newScale = this.toScale(size, canvas);
                view.transform(0, 0, newScale, newScale, 0);
                // Turns off the snap grid and targets
                var container = void 0;
                var cleanup = this._cleanup;
                if (cleanup.snap && "snap" in canvas) {
                    var snap = canvas.snap;
                    if (snap != null) {
                        container = snap.container;
                        if (container.renderable) {
                            container.renderable = false;
                        }
                        else {
                            container = undefined;
                        }
                    }
                }
                // Turns off the canvas snippets
                var snippet = void 0;
                if (cleanup.background) {
                    snippet = canvas.snippet;
                    if (snippet.renderable) {
                        snippet.renderable = false;
                    }
                    else {
                        snippet = undefined;
                    }
                }
                // Extracts
                this.emit("taking", canvas, this);
                var result = extractor(canvas);
                this.emit("took", canvas, null, this);
                // Turn on the canvas snippets
                if (snippet) {
                    snippet.renderable = true;
                }
                // Turn on the snap grid and targets
                if (container != null) {
                    container.renderable = true;
                }
                view.transform(oldPositionX, oldPositionY, oldScaleX, oldScaleY, 0);
                return result;
            }
        };
        return DDiagramSnapshot;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramBase = /** @class */ (function (_super) {
        __extends(DDiagramBase, _super);
        function DDiagramBase(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._serialized = null;
            _this._tileFactory = options === null || options === void 0 ? void 0 : options.tile;
            _this._controller = options === null || options === void 0 ? void 0 : options.controller;
            _this._isAmbient = (_a = options === null || options === void 0 ? void 0 : options.ambient) !== null && _a !== void 0 ? _a : _this.theme.isAmbient();
            _this._snapshot = new DDiagramSnapshot(_this, options === null || options === void 0 ? void 0 : options.snapshot);
            return _this;
        }
        Object.defineProperty(DDiagramBase.prototype, "snapshot", {
            get: function () {
                return this._snapshot;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramBase.prototype, "controller", {
            get: function () {
                return this._controller || null;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramBase.prototype.set = function (serialized) {
            var oldSerialized = this._serialized;
            if (oldSerialized !== serialized) {
                if (oldSerialized) {
                    this._serialized = null;
                    this.onUnset();
                }
                this._serialized = serialized;
                if (serialized) {
                    this.onSet(serialized);
                }
            }
        };
        DDiagramBase.prototype.onSet = function (serialized) {
            var _this = this;
            var canvas = this.newCanvas(serialized);
            var pieces = serialized.pieces;
            var isEditMode = this.isEditMode();
            var pieceDataOrPromise = DDiagrams.toPieceData(this._controller, pieces, isEditMode);
            if (pieceDataOrPromise == null) {
                this.newLayer(serialized, canvas, isEditMode);
            }
            else {
                pieceDataOrPromise.then(function (pieceData) {
                    _this.newLayer(serialized, canvas, isEditMode, pieces, pieceData);
                });
            }
            this.canvas = canvas;
        };
        DDiagramBase.prototype.newLayer = function (serialized, canvas, isEditMode, pieces, pieceData) {
            var _this = this;
            var layer = canvas.layer;
            var manager = new EShapeResourceManagerDeserialization(serialized, pieces, pieceData, isEditMode);
            DDiagrams.newLayer(serialized, layer, manager).then(function (shapes) {
                layer.init();
                _this.initialize(shapes);
                canvas.initialize(shapes);
                DApplications.update(_this);
                _this.emit("ready", _this);
            });
            if (this._isAmbient) {
                var background = this.toCanvasBaseBackgroundOptions(serialized, this.theme, false);
                this.background.color = background.color;
                this.background.alpha = background.alpha;
            }
        };
        DDiagramBase.prototype.toCanvasBaseOptions = function (serialized) {
            var _a;
            var theme = this.theme;
            var isAmbient = this._isAmbient;
            return {
                name: serialized.name,
                width: serialized.width,
                height: serialized.height,
                background: this.toCanvasBaseBackgroundOptions(serialized, theme, isAmbient),
                border: isAmbient ? { color: null } : undefined,
                shadow: isAmbient ? null : theme.getCanvasShadow(),
                tile: {
                    factory: this._tileFactory,
                    mapping: (_a = serialized.tile) === null || _a === void 0 ? void 0 : _a.mapping
                },
                ambient: isAmbient
            };
        };
        DDiagramBase.prototype.toCanvasBaseBackgroundOptions = function (serialized, theme, isAmbient) {
            var _a, _b;
            if (isAmbient) {
                return {
                    color: null
                };
            }
            var background = serialized.background;
            return {
                color: (_a = background === null || background === void 0 ? void 0 : background.color) !== null && _a !== void 0 ? _a : theme.getCanvasBackgroundColor(),
                alpha: (_b = background === null || background === void 0 ? void 0 : background.alpha) !== null && _b !== void 0 ? _b : theme.getCanvasBackgroundAlpha()
            };
        };
        DDiagramBase.prototype.openByName = function (name) {
            var _this = this;
            var controller = this._controller;
            if (controller) {
                controller.getByName(name).then(function (found) {
                    _this.set(DDiagrams.toSerialized(found));
                });
            }
        };
        DDiagramBase.prototype.initialize = function (shapes) {
            // DO NOTHING
        };
        DDiagramBase.prototype.onUnset = function () {
            var canvas = this.canvas;
            if (canvas) {
                this.canvas = null;
            }
        };
        DDiagramBase.prototype.get = function () {
            return this._serialized;
        };
        Object.defineProperty(DDiagramBase.prototype, "layer", {
            get: function () {
                var canvas = this.canvas;
                if (canvas) {
                    return canvas.layer.active;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramBase.prototype.getType = function () {
            return "DDiagramBase";
        };
        return DDiagramBase;
    }(DCanvasContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditorBackground = /** @class */ (function () {
        function DDiagramCanvasEditorBackground(target, base) {
            this._target = target;
            this._base = base;
        }
        DDiagramCanvasEditorBackground.prototype.getTheme = function () {
            return this._target.getTheme();
        };
        DDiagramCanvasEditorBackground.prototype.setTheme = function (theme) {
            this._target.setTheme(theme);
        };
        DDiagramCanvasEditorBackground.prototype.getBaseColor = function () {
            return this._base;
        };
        DDiagramCanvasEditorBackground.prototype.setBaseColor = function (baseColor) {
            this._base = baseColor;
        };
        DDiagramCanvasEditorBackground.prototype.getColor = function (state) {
            var target = this._target;
            var base = this._base;
            var color = target.getColor(state);
            if (base != null) {
                if (color != null) {
                    return UtilRgb.blend(base, color, target.getAlpha(state));
                }
                return base;
            }
            return color;
        };
        Object.defineProperty(DDiagramCanvasEditorBackground.prototype, "color", {
            get: function () {
                return this._target.color;
            },
            set: function (color) {
                this._target.color = color;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasEditorBackground.prototype.getAlpha = function (state) {
            var base = this._base;
            if (base != null) {
                return 1;
            }
            return this._target.getAlpha(state);
        };
        Object.defineProperty(DDiagramCanvasEditorBackground.prototype, "alpha", {
            get: function () {
                return this._target.alpha;
            },
            set: function (alpha) {
                this._target.alpha = alpha;
            },
            enumerable: false,
            configurable: true
        });
        return DDiagramCanvasEditorBackground;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTileMappingPointImpl = /** @class */ (function (_super) {
        __extends(DDiagramCanvasTileMappingPointImpl, _super);
        function DDiagramCanvasTileMappingPointImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DDiagramCanvasTileMappingPointImpl.prototype, "lon", {
            get: function () {
                return this.x;
            },
            set: function (lon) {
                this.x = lon;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingPointImpl.prototype, "lat", {
            get: function () {
                return this.y;
            },
            set: function (lat) {
                this.y = lat;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasTileMappingPointImpl.prototype.toObject = function () {
            return {
                lon: this.x,
                lat: this.y
            };
        };
        return DDiagramCanvasTileMappingPointImpl;
    }(pixi_js.ObservablePoint));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTileMappingImpl = /** @class */ (function () {
        function DDiagramCanvasTileMappingImpl(cb, mappingOrEnable, lon0, lat0, lon1, lat1) {
            this._cb = cb;
            if (mappingOrEnable === true || mappingOrEnable === false) {
                this._enable = mappingOrEnable;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, lon0, lat0);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, lon1, lat1);
            }
            else if (mappingOrEnable != null) {
                this._enable = mappingOrEnable.enable;
                var from = mappingOrEnable.from;
                var to = mappingOrEnable.to;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, from.lon, from.lat);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, to.lon, to.lat);
            }
            else {
                this._enable = false;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, -180, +85.05112877980659);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, +180, -85.05112877980659);
            }
        }
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._cb();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "from", {
            get: function () {
                return this._from;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "to", {
            get: function () {
                return this._to;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasTileMappingImpl.prototype.serialize = function () {
            return {
                enable: this._enable,
                from: this._from.toObject(),
                to: this._to.toObject()
            };
        };
        return DDiagramCanvasTileMappingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTile = /** @class */ (function () {
        function DDiagramCanvasTile(canvas, options) {
            var _this = this;
            this._canvas = canvas;
            this._factory = options === null || options === void 0 ? void 0 : options.factory;
            this._mapping = new DDiagramCanvasTileMappingImpl(function () {
                _this.onMappingChange();
            }, options === null || options === void 0 ? void 0 : options.mapping);
        }
        DDiagramCanvasTile.prototype.init = function () {
            this.onMappingChange();
        };
        DDiagramCanvasTile.prototype.onMappingChange = function () {
            var factory = this._factory;
            if (factory) {
                var mapping = this._mapping;
                if (mapping.enable) {
                    var pyramid = this._pyramid;
                    if (pyramid) {
                        pyramid.mapping = mapping;
                    }
                    else {
                        this._pyramid = factory(this._canvas).fit();
                    }
                }
                else {
                    var pyramid = this._pyramid;
                    if (pyramid) {
                        this._pyramid = undefined;
                        pyramid.destroy();
                    }
                }
            }
        };
        Object.defineProperty(DDiagramCanvasTile.prototype, "pyramid", {
            get: function () {
                return this._pyramid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTile.prototype, "factory", {
            get: function () {
                return this._factory;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTile.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasTile.prototype.serialize = function () {
            return {
                mapping: this._mapping.serialize()
            };
        };
        DDiagramCanvasTile.prototype.destroy = function () {
            var pyramid = this._pyramid;
            if (pyramid != null) {
                this._pyramid = undefined;
                pyramid.destroy();
            }
        };
        return DDiagramCanvasTile;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayer = /** @class */ (function (_super) {
        __extends(DDiagramLayer, _super);
        function DDiagramLayer(name) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.interactive = false;
            _this.reference = 0;
            return _this;
        }
        DDiagramLayer.prototype.destroy = function () {
            if (!this._destroyed) {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    children[i].destroy();
                }
                children.length = 0;
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramLayer.prototype.serialize = function (layer, manager, items) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var shape = children[i];
                var item = shape.serialize(manager);
                item[16] = layer;
                items.push(item);
            }
            return [this.name || ""];
        };
        DDiagramLayer.prototype.addUuid = function (manager) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
        };
        DDiagramLayer.prototype.updateUuid = function (manager) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
        };
        return DDiagramLayer;
    }(EShapeContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayerContainer = /** @class */ (function (_super) {
        __extends(DDiagramLayerContainer, _super);
        function DDiagramLayerContainer() {
            var _this = _super.call(this) || this;
            _this._active = null;
            _this.interactive = false;
            _this.interactiveChildren = false;
            return _this;
        }
        DDiagramLayerContainer.prototype.init = function () {
            if (this._active == null) {
                var children = this.children;
                if (0 < children.length) {
                    this._active = children[0];
                }
            }
        };
        Object.defineProperty(DDiagramLayerContainer.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (layer) {
                if (this._active !== layer && (layer == null || 0 <= this.children.indexOf(layer))) {
                    this._active = layer;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DDiagramLayerContainer.prototype.create = function (name, activate) {
            var result = new DDiagramLayer(name);
            this.attach(result, activate);
            return result;
        };
        /**
         * Adds the specified layer and activates it if the `activate` is true.
         *
         * @param layer
         * @param activate
         */
        DDiagramLayerContainer.prototype.attach = function (layer, activate) {
            this.addChild(layer);
            if (activate === true) {
                this._active = layer;
            }
            this.emit("change", this);
            DApplications.update(this);
        };
        DDiagramLayerContainer.prototype.attachAt = function (layer, index, activate) {
            this.addChildAt(layer, index);
            if (activate === true) {
                this._active = layer;
            }
            this.emit("change", this);
            DApplications.update(this);
        };
        /**
         * Removes the specified layer from this container and activates the specified layer.
         * This method does not destroy the secified layer.
         *
         * @param layer
         */
        DDiagramLayerContainer.prototype.detach = function (layer, active) {
            var children = this.children;
            var index = children.indexOf(layer);
            if (0 <= index) {
                this._active = active;
                children.splice(index, 1);
                layer.parent = undefined;
                this.emit("change", this);
                DApplications.update(this);
            }
        };
        /**
         * Removes the specified layer and activate the next layer.
         * This method does not destroy the specified layer.
         *
         * @param layer
         * @param activateNext
         */
        DDiagramLayerContainer.prototype.delete = function (layer, activateNext) {
            var children = this.children;
            var index = children.indexOf(layer);
            if (0 <= index) {
                children.splice(index, 1);
                layer.parent = undefined;
                if (this._active === layer) {
                    if (activateNext === true) {
                        if (index < children.length) {
                            this._active = children[index];
                        }
                        else if (0 < children.length) {
                            this._active = children[index - 1];
                        }
                        else {
                            this._active = null;
                        }
                    }
                    else {
                        this._active = null;
                    }
                }
                this.emit("change", this);
                DApplications.update(this);
            }
            return index;
        };
        DDiagramLayerContainer.prototype.get = function (index) {
            var child = this.children[index];
            if (child != null) {
                return child;
            }
            return null;
        };
        DDiagramLayerContainer.prototype.clear = function () {
            var children = this.children;
            if (0 < children.length) {
                for (var i = children.length - 1; 0 <= i; --i) {
                    var child = children[i];
                    child.parent = null;
                    child.destroy();
                }
                children.length = 0;
                this.emit("change", this);
                DApplications.update(this);
            }
        };
        DDiagramLayerContainer.prototype.destroy = function () {
            if (!this._destroyed) {
                this.clear();
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramLayerContainer.prototype.size = function () {
            return this.children.length;
        };
        DDiagramLayerContainer.prototype.serialize = function (manager, items) {
            var result = [];
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
            for (var i = 0, imax = children.length; i < imax; ++i) {
                result.push(children[i].serialize(i, manager, items));
            }
            return result;
        };
        return DDiagramLayerContainer;
    }(pixi_js.Container));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasBase = /** @class */ (function (_super) {
        __extends(DDiagramCanvasBase, _super);
        function DDiagramCanvasBase(options) {
            var _this = _super.call(this, options) || this;
            // Background
            var theme = _this.theme;
            if (!_this.isAmbient(theme, options)) {
                _this._background = new DDiagramCanvasEditorBackground(_this._background, _this.toBackgroundBase(theme, options));
            }
            // Layer
            var layer = new DDiagramLayerContainer();
            _this._layer = layer;
            _this.addChild(layer);
            // Tile
            var tile = new DDiagramCanvasTile(_this, options === null || options === void 0 ? void 0 : options.tile);
            _this._tile = tile;
            tile.init();
            return _this;
        }
        DDiagramCanvasBase.prototype.isAmbient = function (theme, options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.ambient) !== null && _a !== void 0 ? _a : theme.isAmbient();
        };
        DDiagramCanvasBase.prototype.toBackgroundBase = function (theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.background) === null || _a === void 0 ? void 0 : _a.base) !== null && _b !== void 0 ? _b : theme.getBackgroundBase();
        };
        Object.defineProperty(DDiagramCanvasBase.prototype, "tile", {
            get: function () {
                return this._tile;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasBase.prototype, "layer", {
            get: function () {
                return this._layer;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasBase.prototype.initialize = function (shapes) {
            // DO NOTHING
        };
        DDiagramCanvasBase.prototype.destroy = function () {
            if (!this._destroyed) {
                this._tile.destroy();
                this._layer.destroy();
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramCanvasBase.prototype.hitTest = function (global, handler) {
            var layers = this._layer.children;
            for (var i = layers.length - 1; 0 <= i; --i) {
                var layer = layers[i];
                var shape = layer.hitTest(global, handler);
                if (shape != null) {
                    return shape;
                }
            }
            return null;
        };
        DDiagramCanvasBase.prototype.getType = function () {
            return "DDiagramCanvasBase";
        };
        return DDiagramCanvasBase;
    }(DCanvas));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditorSnap = /** @class */ (function () {
        function DDiagramCanvasEditorSnap(parent, theme, options) {
            var _this = this;
            this._parent = parent;
            // Controller
            var controller = options.controller;
            this._controller = controller;
            var onChangeBound = function () {
                _this.onChange();
            };
            controller.grid.on("change", onChangeBound);
            controller.target.on("change", onChangeBound);
            // Container
            var container = new EShapeContainer();
            container.visible = false;
            this._container = container;
            parent.addChildAt(container, parent.children.length - 1);
            // Grid
            this._grid = this.toGrid(theme, options.grid);
            // Target
            this._target = this.toTarget(theme, options.target);
        }
        DDiagramCanvasEditorSnap.prototype.toGrid = function (theme, options) {
            var _a;
            return {
                major: this.toGridMajor(theme, options === null || options === void 0 ? void 0 : options.major),
                minor: this.toGridMinor(theme, options === null || options === void 0 ? void 0 : options.minor),
                size: (_a = options === null || options === void 0 ? void 0 : options.size) !== null && _a !== void 0 ? _a : theme.getSnapGridSize()
            };
        };
        DDiagramCanvasEditorSnap.prototype.toGridMajor = function (theme, options) {
            var _a, _b, _c, _d, _e;
            return {
                interval: (_a = options === null || options === void 0 ? void 0 : options.interval) !== null && _a !== void 0 ? _a : theme.getSnapGridMajorInterval(),
                color: (_b = options === null || options === void 0 ? void 0 : options.color) !== null && _b !== void 0 ? _b : theme.getSnapGridMajorColor(),
                alpha: (_c = options === null || options === void 0 ? void 0 : options.alpha) !== null && _c !== void 0 ? _c : theme.getSnapGridMajorAlpha(),
                width: (_d = options === null || options === void 0 ? void 0 : options.width) !== null && _d !== void 0 ? _d : theme.getSnapGridMajorWidth(),
                style: (_e = options === null || options === void 0 ? void 0 : options.style) !== null && _e !== void 0 ? _e : theme.getSnapGridMajorStyle()
            };
        };
        DDiagramCanvasEditorSnap.prototype.toGridMinor = function (theme, options) {
            var _a, _b, _c, _d;
            return {
                color: (_a = options === null || options === void 0 ? void 0 : options.color) !== null && _a !== void 0 ? _a : theme.getSnapGridMinorColor(),
                alpha: (_b = options === null || options === void 0 ? void 0 : options.alpha) !== null && _b !== void 0 ? _b : theme.getSnapGridMinorAlpha(),
                width: (_c = options === null || options === void 0 ? void 0 : options.width) !== null && _c !== void 0 ? _c : theme.getSnapGridMinorWidth(),
                style: (_d = options === null || options === void 0 ? void 0 : options.style) !== null && _d !== void 0 ? _d : theme.getSnapGridMinorStyle()
            };
        };
        DDiagramCanvasEditorSnap.prototype.toTarget = function (theme, options) {
            var _a, _b, _c, _d;
            return {
                color: (_a = options === null || options === void 0 ? void 0 : options.color) !== null && _a !== void 0 ? _a : theme.getSnapTargetColor(),
                alpha: (_b = options === null || options === void 0 ? void 0 : options.alpha) !== null && _b !== void 0 ? _b : theme.getSnapTargetAlpha(),
                width: (_c = options === null || options === void 0 ? void 0 : options.width) !== null && _c !== void 0 ? _c : theme.getSnapTargetWidth(),
                style: (_d = options === null || options === void 0 ? void 0 : options.style) !== null && _d !== void 0 ? _d : theme.getSnapTargetStyle()
            };
        };
        DDiagramCanvasEditorSnap.prototype.onChange = function () {
            var parent = this._parent;
            parent.toDirty();
            DApplications.update(parent);
        };
        Object.defineProperty(DDiagramCanvasEditorSnap.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasEditorSnap.prototype.serialize = function () {
            return this._controller.serialize();
        };
        DDiagramCanvasEditorSnap.prototype.onReflow = function () {
            var parent = this._parent;
            var container = this._container;
            var controller = this._controller;
            var isGridVisible = controller.grid.visible;
            var isTargetVisible = controller.target.visible;
            if (isGridVisible || isTargetVisible) {
                var w = parent.width;
                var h = parent.height;
                var wh = 0.5 * w;
                var hh = 0.5 * h;
                var TOP = EShapeBarPosition.TOP;
                var LEFT = EShapeBarPosition.LEFT;
                var shapes = container.children;
                var index = 0;
                // Grid
                if (isGridVisible) {
                    var grid = this._grid;
                    var major = grid.major;
                    var minor = grid.minor;
                    var interval = major.interval;
                    var size = grid.size(controller.grid.size, w, h);
                    for (var x = size, ix = 1; x < w; x += size, ix += 1, index += 1) {
                        var style = ix % interval === 0 ? major : minor;
                        this.update(container, shapes, index, x, hh, TOP, w, h, style);
                    }
                    for (var y = size, iy = 1; y < w; y += size, iy += 1, index += 1) {
                        var style = iy % interval === 0 ? major : minor;
                        this.update(container, shapes, index, wh, y, LEFT, w, h, style);
                    }
                }
                // Target
                if (isTargetVisible) {
                    var values = controller.target.values;
                    var target = this._target;
                    for (var i = 0, imax = values.length; i < imax; i += 1, index += 1) {
                        var value = values[i];
                        var position = value.position;
                        if (value.type === ESnapperTargetValueType.VERTICAL) {
                            this.update(container, shapes, index, position, hh, TOP, w, h, target);
                        }
                        else {
                            this.update(container, shapes, index, wh, position, LEFT, w, h, target);
                        }
                    }
                }
                for (var i = index, imax = shapes.length; i < imax; ++i) {
                    shapes[i].visible = false;
                }
                container.visible = true;
            }
            else {
                container.visible = false;
            }
        };
        DDiagramCanvasEditorSnap.prototype.update = function (container, shapes, index, x, y, position, w, h, style) {
            var shape = null;
            if (index < shapes.length) {
                shape = shapes[index];
                shape.disallowUploadedUpdate();
                shape.points.position = position;
                shape.transform.position.set(x, y);
                shape.stroke.set(true, style.color, style.alpha, style.width, undefined, undefined, style.style);
                shape.size.set(w, h);
                shape.visible = true;
                shape.allowUploadedUpdate();
            }
            else {
                shape = new EShapeBar(position, -1, style.width);
                shape.disallowUploadedUpdate();
                shape.fill.enable = false;
                shape.transform.position.set(x, y);
                shape.stroke.set(true, style.color, style.alpha, undefined, undefined, undefined, style.style);
                shape.size.set(w, h);
                shape.visible = true;
                shape.allowUploadedUpdate();
                shape.attach(container);
            }
        };
        return DDiagramCanvasEditorSnap;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramSerializedVersion = 1;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditor = /** @class */ (function (_super) {
        __extends(DDiagramCanvasEditor, _super);
        function DDiagramCanvasEditor(options) {
            var _this = _super.call(this, options) || this;
            _this._snap = _this.toSnap(_this.theme, options.snap);
            return _this;
        }
        DDiagramCanvasEditor.prototype.toSnap = function (theme, options) {
            if (options) {
                return new DDiagramCanvasEditorSnap(this, theme, options);
            }
            return null;
        };
        Object.defineProperty(DDiagramCanvasEditor.prototype, "snap", {
            get: function () {
                return this._snap;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasEditor.prototype.serialize = function (id, thumbnail) {
            var _a;
            var manager = new EShapeResourceManagerSerialization();
            var items = [];
            var background = this._background;
            var backgroundColor = background.color;
            var backgroundAlpha = background.alpha;
            return {
                version: DDiagramSerializedVersion,
                id: id,
                name: this.name,
                width: this.width,
                height: this.height,
                background: {
                    color: isNumber(backgroundColor) ? backgroundColor : 0xffffff,
                    alpha: isNumber(backgroundAlpha) ? backgroundAlpha : 0
                },
                tile: this._tile.serialize(),
                resources: manager.resources,
                tags: manager.tags,
                pieces: manager.pieces,
                layers: this._layer.serialize(manager, items),
                items: items,
                snap: (_a = this._snap) === null || _a === void 0 ? void 0 : _a.serialize(),
                thumbnail: thumbnail === null || thumbnail === void 0 ? void 0 : thumbnail.serialize()
            };
        };
        DDiagramCanvasEditor.prototype.onReflow = function () {
            var _a;
            _super.prototype.onReflow.call(this);
            (_a = this._snap) === null || _a === void 0 ? void 0 : _a.onReflow();
        };
        DDiagramCanvasEditor.prototype.getType = function () {
            return "DDiagramCanvasEditor";
        };
        return DDiagramCanvasEditor;
    }(DDiagramCanvasBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvas = /** @class */ (function (_super) {
        __extends(DDiagramCanvas, _super);
        function DDiagramCanvas(options) {
            var _this = _super.call(this, options) || this;
            _this.tags = {};
            _this.interactives = [];
            _this.actionables = [];
            _this.ids = {};
            _this._workLocal = new pixi_js.Point();
            _this._workGlobal = new pixi_js.Point();
            _this._lastOverShape = null;
            return _this;
        }
        DDiagramCanvas.prototype.initialize = function () {
            var time = Date.now();
            var tags = this.tags;
            var interactives = this.interactives;
            var actionables = this.actionables;
            var ids = this.ids;
            var layers = this._layer.children;
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                this.initializeShapes(layers[i].children, tags, interactives, actionables, ids);
            }
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                this.updateShapes(layers[i].children, time);
            }
            this.initializeFocus();
        };
        DDiagramCanvas.prototype.initializeFocus = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.find(this, false, true, true);
                if (focusable) {
                    focusController.focus(focusable);
                }
            }
        };
        DDiagramCanvas.prototype.initializeShapes = function (shapes, tags, interactives, actionables, ids) {
            var _loop_1 = function (i, imax) {
                var shape = shapes[i];
                // Tag mappings
                var tag = shape.tag;
                for (var j = 0, jmax = tag.size(); j < jmax; ++j) {
                    var value = tag.get(j);
                    if (value) {
                        var valueId = value.id;
                        if (0 < valueId.length) {
                            var values = tags[valueId];
                            if (values == null) {
                                values = [];
                                tags[valueId] = values;
                            }
                            values.push(value);
                        }
                    }
                }
                // Id mappings
                var shapeId = shape.id;
                if (0 < shapeId.length) {
                    var mapping = ids[shapeId];
                    if (mapping == null) {
                        ids[shapeId] = [shape];
                    }
                    else {
                        mapping.push(shape);
                    }
                }
                // Interactives
                var runtime = shape.runtime;
                if (shape.interactive || 0 < shape.cursor.length || (runtime && runtime.interactive)) {
                    interactives.push(shape);
                }
                // Actionables
                if (runtime && 0 < runtime.actions.length) {
                    actionables.push(shape);
                }
                // Shortcuts
                var shortcut = shape.shortcut;
                if (runtime && shortcut != null) {
                    UtilKeyboardEvent.on(this_1, shortcut, function (e) {
                        runtime.onClick(shape, e);
                    });
                }
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    this_1.initializeShapes(children, tags, interactives, actionables, ids);
                }
            };
            var this_1 = this;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                _loop_1(i);
            }
        };
        DDiagramCanvas.prototype.updateShapes = function (shapes, time) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].update(time);
            }
        };
        DDiagramCanvas.prototype.onShapeMove = function (e) {
            var global = e.data.global;
            var local = this._workLocal;
            var interactives = this.interactives;
            var found = null;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        found = interactive;
                        break;
                    }
                }
            }
            var layer = DApplications.getLayer(this);
            if (found) {
                if (layer) {
                    var cursor = found.cursor;
                    if (cursor.length <= 0) {
                        cursor = "auto";
                    }
                    var style = layer.view.style;
                    if (style.cursor !== cursor) {
                        style.cursor = cursor;
                    }
                }
                var lastOverShape = this._lastOverShape;
                if (found === lastOverShape) {
                    var runtime = lastOverShape.runtime;
                    if (runtime) {
                        runtime.onMove(lastOverShape, e);
                    }
                }
                else {
                    this._lastOverShape = found;
                    // Previous
                    if (lastOverShape) {
                        var previousRuntime = lastOverShape.runtime;
                        if (previousRuntime) {
                            previousRuntime.onOut(lastOverShape, e);
                        }
                        // Parents
                        var lastOverParent = lastOverShape.parent;
                        while (lastOverParent instanceof EShapeBase && lastOverParent !== found) {
                            var parentRuntime = lastOverShape.runtime;
                            if (parentRuntime) {
                                parentRuntime.onOut(lastOverParent, e);
                            }
                            lastOverParent = lastOverParent.parent;
                        }
                    }
                    // Next
                    var runtime = found.runtime;
                    if (runtime) {
                        runtime.onOver(found, e);
                    }
                    if (layer) {
                        layer.view.title = found.title || "";
                    }
                    // Parents
                    var parent_1 = found.parent;
                    while (parent_1 instanceof EShapeBase) {
                        var parentRuntime = parent_1.runtime;
                        if (parentRuntime) {
                            parentRuntime.onOver(parent_1, e);
                        }
                        parent_1 = parent_1.parent;
                    }
                }
                return true;
            }
            else {
                if (layer) {
                    var style = layer.view.style;
                    if (style.cursor !== "auto") {
                        style.cursor = "auto";
                    }
                }
                // Previous
                var lastOverShape = this._lastOverShape;
                this._lastOverShape = null;
                if (lastOverShape) {
                    var runtime = lastOverShape.runtime;
                    if (runtime) {
                        runtime.onOut(lastOverShape, e);
                    }
                    // Parents
                    var lastOverParent = lastOverShape.parent;
                    while (lastOverParent instanceof EShapeBase) {
                        var parentRuntime = lastOverParent.runtime;
                        if (parentRuntime) {
                            parentRuntime.onOut(lastOverParent, e);
                        }
                        lastOverParent = lastOverParent.parent;
                    }
                }
                //
                if (layer) {
                    layer.view.title = "";
                }
                return false;
            }
        };
        DDiagramCanvas.prototype.onShapeDown = function (e) {
            var interactives = this.interactives;
            var global = e.data.global;
            var local = this._workLocal;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        var runtime = interactive.runtime;
                        if (runtime) {
                            runtime.onDown(interactive, e);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeUp = function (e) {
            var interactives = this.interactives;
            var global = e.data.global;
            var local = this._workLocal;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        var runtime = interactive.runtime;
                        if (runtime) {
                            runtime.onUp(interactive, e);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeClick = function (e) {
            var interactives = this.interactives;
            var global = e.data.global;
            var local = this._workLocal;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        var target = interactive;
                        while (true) {
                            var runtime = target.runtime;
                            if (runtime) {
                                runtime.onClick(target, e);
                            }
                            var parent_2 = target.parent;
                            if (parent_2 instanceof EShapeBase) {
                                target = parent_2;
                            }
                            else {
                                break;
                            }
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeDblClick = function (e, interactionManager) {
            var interactives = this.interactives;
            var global = UtilPointerEvent.toGlobal(e, interactionManager, this._workGlobal);
            var local = this._workLocal;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local)) {
                        var target = interactive;
                        while (true) {
                            var runtime = target.runtime;
                            if (runtime) {
                                runtime.onDblClick(target, e, interactionManager);
                            }
                            var parent_3 = target.parent;
                            if (parent_3 instanceof EShapeBase) {
                                target = parent_3;
                            }
                            else {
                                break;
                            }
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DDiagramCanvas.prototype.getType = function () {
            return "DDiagramCanvas";
        };
        return DDiagramCanvas;
    }(DDiagramCanvasBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramEditorThumbnail = /** @class */ (function () {
        function DDiagramEditorThumbnail(snapshot, theme, options) {
            var _a;
            this._snapshot = snapshot;
            this._isEnabled = (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : theme.isThumbnailEnabled();
            var size = options === null || options === void 0 ? void 0 : options.size;
            this._size = size !== undefined ? size : theme.getThumbnailSize();
        }
        Object.defineProperty(DDiagramEditorThumbnail.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                this._isEnabled = enable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramEditorThumbnail.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                this._size = size;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramEditorThumbnail.prototype.serialize = function () {
            if (this._isEnabled) {
                return this._snapshot.createAsUrl(this._size);
            }
        };
        return DDiagramEditorThumbnail;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramEditor = /** @class */ (function (_super) {
        __extends(DDiagramEditor, _super);
        function DDiagramEditor(options) {
            var _this = _super.call(this, options) || this;
            _this._isChanged = false;
            _this._isChanged = false;
            var commands = DControllers.getCommandController();
            commands.on("dirty", function () {
                if (_this._isChanged !== true) {
                    _this._isChanged = true;
                    _this.emit("change", _this);
                }
            });
            _this._snapper = new ESnapper(_this);
            _this._thumbnail = new DDiagramEditorThumbnail(_this._snapshot, _this.theme, options === null || options === void 0 ? void 0 : options.thumbnail);
            return _this;
        }
        Object.defineProperty(DDiagramEditor.prototype, "thumbnail", {
            get: function () {
                return this._thumbnail;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramEditor.prototype, "snapper", {
            get: function () {
                return this._snapper;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramEditor.prototype.isEditMode = function () {
            return true;
        };
        DDiagramEditor.prototype.newCanvas = function (serialized) {
            return new DDiagramCanvasEditor(this.toCanvasOptions(serialized));
        };
        DDiagramEditor.prototype.toCanvasOptions = function (serialized) {
            var options = this.toCanvasBaseOptions(serialized);
            // Snapper
            var snapper = this._snapper;
            var snap = options.snap;
            if (snap == null) {
                options.snap = {
                    controller: snapper
                };
            }
            else if (snap.controller == null) {
                snap.controller = snapper;
            }
            return options;
        };
        DDiagramEditor.prototype.serialize = function () {
            var canvas = this.canvas;
            var serialized = this._serialized;
            if (canvas != null && serialized != null) {
                this.emit("serializing", canvas, this);
                try {
                    var result = canvas.serialize(serialized.id, this._thumbnail);
                    this.emit("serialized", canvas, null, this);
                    return result;
                }
                catch (e) {
                    this.emit("serialized", canvas, "exception", this);
                    return null;
                }
            }
            return null;
        };
        DDiagramEditor.prototype.save = function () {
            var _this = this;
            var serialized = this.serialize();
            if (serialized != null) {
                var controller = this._controller;
                if (controller) {
                    var simple = DDiagrams.toSimple(serialized);
                    this.emit("saving", simple, this);
                    return controller.save(simple).then(function (newId) {
                        _this._isChanged = false;
                        serialized.id = newId;
                        _this._serialized = serialized;
                        _this.emit("change", _this);
                        _this.emit("saved", null, _this);
                    }, function (reason) {
                        _this.emit("saved", reason, _this);
                    });
                }
                else {
                    this.emit("saved", "no-controller", this);
                    return Promise.reject();
                }
            }
            this.emit("saved", null, this);
            return Promise.resolve();
        };
        DDiagramEditor.prototype.saveAs = function (name) {
            var _this = this;
            var serialized = this.serialize();
            if (serialized != null) {
                var controller = this._controller;
                if (controller) {
                    serialized.id = undefined;
                    serialized.name = name;
                    var simple = DDiagrams.toSimple(serialized);
                    this.emit("saving", simple, this);
                    return controller.save(simple).then(function (newId) {
                        _this._isChanged = false;
                        serialized.id = newId;
                        _this._serialized = serialized;
                        var canvas = _this.canvas;
                        if (canvas != null) {
                            canvas.name = name;
                        }
                        _this.emit("change", _this);
                        _this.emit("saved", null, _this);
                    }, function (reason) {
                        _this.emit("saved", reason, _this);
                    });
                }
                else {
                    this.emit("saved", "no-controller", this);
                    return Promise.reject("no-controller");
                }
            }
            this.emit("saved", null, this);
            return Promise.resolve();
        };
        DDiagramEditor.prototype.delete = function () {
            var _this = this;
            var serialized = this._serialized;
            if (serialized && serialized.id != null) {
                var controller = this._controller;
                if (controller) {
                    this.emit("deleting", this);
                    return controller.delete(serialized.id).then(function () {
                        _this.set(null);
                        _this.emit("deleted", _this);
                    }, function (reason) {
                        _this.emit("deleted", reason, _this);
                    });
                }
                else {
                    this.emit("deleted", "no-controller", this);
                    return Promise.reject("no-controller");
                }
            }
            this.set(null);
            this.emit("deleted", null, this);
            return Promise.resolve();
        };
        DDiagramEditor.prototype.create = function (name, width, height) {
            this.set({
                version: DDiagramSerializedVersion,
                id: undefined,
                name: name,
                width: width,
                height: height,
                resources: [],
                tags: [],
                layers: [["Default layer"]],
                items: [],
                snap: undefined
            });
        };
        DDiagramEditor.prototype.onSet = function (serialized) {
            _super.prototype.onSet.call(this, serialized);
            var snap = serialized.snap;
            var snapper = this._snapper;
            if (snap != null) {
                snapper.deserialize(snap);
            }
            else {
                snapper.reset();
            }
            this._isChanged = false;
            this.emit("change", this);
        };
        DDiagramEditor.prototype.onUnset = function () {
            _super.prototype.onUnset.call(this);
            this._isChanged = false;
            this.emit("change", this);
        };
        DDiagramEditor.prototype.open = function (id) {
            var _this = this;
            var controller = this._controller;
            if (controller) {
                this.emit("opening", this);
                return controller.get(id).then(function (serialized) {
                    _this.set(DDiagrams.toSerialized(serialized));
                    _this.emit("opened", null, _this);
                }, function (reason) {
                    _this.emit("opened", reason, _this);
                });
            }
            this.emit("opened", "no-controller", this);
            return Promise.reject("no-controller");
        };
        DDiagramEditor.prototype.close = function () {
            this.set(null);
        };
        DDiagramEditor.prototype.isChanged = function () {
            return this._isChanged || this.isNew();
        };
        DDiagramEditor.prototype.isNew = function () {
            var serialized = this._serialized;
            if (serialized != null) {
                return serialized.id == null;
            }
            return false;
        };
        DDiagramEditor.prototype.getName = function () {
            var serialized = this._serialized;
            if (serialized != null) {
                return serialized.name;
            }
            return null;
        };
        DDiagramEditor.prototype.getType = function () {
            return "DDiagramEditor";
        };
        return DDiagramEditor;
    }(DDiagramBase));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A shape helper class for diagrams.
     */
    var DDiagramShape = /** @class */ (function (_super) {
        __extends(DDiagramShape, _super);
        function DDiagramShape(diagram) {
            var _this = _super.call(this) || this;
            _this._diagram = diagram;
            _this._updateBound = function () {
                DApplications.update(diagram);
            };
            return _this;
        }
        DDiagramShape.prototype.update = function () {
            var diagram = this._diagram;
            var canvas = diagram.canvas;
            if (canvas) {
                var actionables = canvas.actionables;
                if (0 < actionables.length) {
                    var effect = -1;
                    var time = Date.now();
                    for (var i = 0, imax = actionables.length; i < imax; ++i) {
                        var actionable = actionables[i];
                        actionable.update(time);
                        var runtime = actionable.runtime;
                        if (runtime && time < runtime.effect) {
                            var runtimeEffect = runtime.effect;
                            if (time < runtimeEffect) {
                                effect = effect < 0 ? runtimeEffect : Math.min(effect, runtimeEffect);
                            }
                        }
                    }
                    if (0 <= effect) {
                        setTimeout(this._updateBound, effect - Date.now());
                    }
                }
            }
        };
        DDiagramShape.prototype.onRender = function (renderer) {
            var diagram = this._diagram;
            var canvas = diagram.canvas;
            if (canvas) {
                var actionables = canvas.actionables;
                if (0 < actionables.length) {
                    var effect = -1;
                    var time = Date.now();
                    for (var i = 0, imax = actionables.length; i < imax; ++i) {
                        var actionable = actionables[i];
                        actionable.onRender(time, renderer);
                        var runtime = actionable.runtime;
                        if (runtime && time < runtime.effect) {
                            var runtimeEffect = runtime.effect;
                            if (time < runtimeEffect) {
                                effect = effect < 0 ? runtimeEffect : Math.min(effect, runtimeEffect);
                            }
                        }
                    }
                    if (0 <= effect) {
                        setTimeout(this._updateBound, effect - Date.now());
                    }
                }
            }
        };
        DDiagramShape.prototype.get = function (id) {
            var _a;
            var shapes = (_a = this._diagram.canvas) === null || _a === void 0 ? void 0 : _a.ids[id];
            return shapes && 0 < shapes.length ? shapes[0] : null;
        };
        DDiagramShape.prototype.getAll = function (id) {
            var _a;
            return ((_a = this._diagram.canvas) === null || _a === void 0 ? void 0 : _a.ids[id]) || [];
        };
        DDiagramShape.prototype.each = function (callback, reverse) {
            if (reverse === void 0) { reverse = false; }
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var layers = canvas.layer.children;
                if (!reverse) {
                    for (var i = 0, imax = layers.length; i < imax; ++i) {
                        var layer = layers[i];
                        var children = layer.children;
                        for (var j = 0, jmax = children.length; j < jmax; ++j) {
                            var child = children[j];
                            if (callback(child) === false) {
                                return child;
                            }
                        }
                    }
                }
                else {
                    for (var i = layers.length - 1; 0 <= i; --i) {
                        var layer = layers[i];
                        var children = layer.children;
                        for (var j = children.length - 1; 0 <= j; --j) {
                            var child = children[j];
                            if (callback(child) === false) {
                                return child;
                            }
                        }
                    }
                }
            }
            return null;
        };
        return DDiagramShape;
    }(pixi_js.utils.EventEmitter));

    var DDiagramTagRemote = /** @class */ (function () {
        function DDiagramTagRemote(options) {
            this._controller = options && options.controller;
        }
        DDiagramTagRemote.prototype.set = function (id, value, time) {
            var controller = this._controller;
            if (controller) {
                controller.write(id, value);
            }
        };
        return DDiagramTagRemote;
    }());

    /**
     * A tag helper class for diagrams.
     */
    var DDiagramTag = /** @class */ (function () {
        function DDiagramTag(diagram, options) {
            this._diagram = diagram;
            this._mapper = (options && options.mapper) || null;
            this._remote = new DDiagramTagRemote(options && options.remote);
        }
        DDiagramTag.prototype.update = function () {
            // DO NOTHING
        };
        Object.defineProperty(DDiagramTag.prototype, "mapper", {
            get: function () {
                return this._mapper;
            },
            set: function (mapper) {
                this._mapper = mapper;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramTag.prototype, "remote", {
            get: function () {
                return this._remote;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramTag.prototype.getIds = function () {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return Object.keys(canvas.tags);
            }
            return [];
        };
        DDiagramTag.prototype.each = function (callback) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tags = canvas.tags;
                for (var id in tags) {
                    if (callback(id) === false) {
                        return id;
                    }
                }
            }
            return null;
        };
        DDiagramTag.prototype.set = function (id, value, time, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var tagValue = tagValues[i];
                        var range = tagValue.range;
                        // Range
                        range.set(from, to);
                        // Time
                        if (time !== undefined) {
                            tagValue.time = time;
                        }
                        // Value
                        tagValue.value = value;
                    }
                }
            }
        };
        DDiagramTag.prototype.clear = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        tagValues[i].clear();
                    }
                }
            }
        };
        DDiagramTag.prototype.setAll = function (id, values, times, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var tagValue = tagValues[i];
                        var range = tagValue.range;
                        // Range
                        range.set(from, to);
                        // Time
                        if (times !== undefined) {
                            tagValue.times = times;
                        }
                        // Value
                        tagValue.values = values;
                    }
                }
            }
        };
        DDiagramTag.prototype.setValue = function (id, value, time) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var tagValue = tagValues[i];
                        if (time !== undefined) {
                            tagValue.time = time;
                        }
                        tagValue.value = value;
                    }
                }
            }
        };
        DDiagramTag.prototype.setValues = function (id, values, times) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var tagValue = tagValues[i];
                        if (times !== undefined) {
                            tagValue.times = times;
                        }
                        tagValue.values = values;
                    }
                }
            }
        };
        DDiagramTag.prototype.setTime = function (id, time) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        tagValues[i].time = time;
                    }
                }
            }
        };
        DDiagramTag.prototype.setTimes = function (id, times) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        tagValues[i].times = times;
                    }
                }
            }
        };
        DDiagramTag.prototype.setRange = function (id, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var tagValues = canvas.tags[id];
                if (tagValues != null) {
                    for (var i = 0, imax = tagValues.length; i < imax; ++i) {
                        var range = tagValues[i].range;
                        if (from !== undefined) {
                            if (from !== null) {
                                range.type |= EShapeTagValueRangeType.FROM;
                                range.from = from;
                            }
                            else {
                                range.type &= ~EShapeTagValueRangeType.FROM;
                            }
                        }
                        if (to !== undefined) {
                            if (to !== null) {
                                range.type |= EShapeTagValueRangeType.TO;
                                range.to = to;
                            }
                            else {
                                range.type &= ~EShapeTagValueRangeType.TO;
                            }
                        }
                    }
                }
            }
        };
        return DDiagramTag;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagram = /** @class */ (function (_super) {
        __extends(DDiagram, _super);
        function DDiagram(options) {
            var _this = _super.call(this, options) || this;
            // Hover handling
            _this.on(UtilPointerEvent.move, function (e) {
                if (UtilPointerEvent.contains(_this, e.target)) {
                    var canvas = _this.canvas;
                    if (canvas) {
                        canvas.onShapeMove(e);
                    }
                }
            });
            // Pointer down / up handling
            _this.on(UtilPointerEvent.up, function (e) {
                if (UtilPointerEvent.contains(_this, e.target)) {
                    var canvas = _this.canvas;
                    if (canvas) {
                        canvas.onShapeUp(e);
                    }
                }
            });
            // Click handling
            _this.on("click", function (e) {
                if (UtilPointerEvent.contains(_this, e.target)) {
                    var canvas = _this.canvas;
                    if (canvas) {
                        canvas.onShapeClick(e);
                    }
                }
            });
            //
            _this.tag = new DDiagramTag(_this, options && options.tag);
            _this.shape = new DDiagramShape(_this);
            return _this;
        }
        DDiagram.prototype.initialize = function (shapes) {
            this.initializeShapes(shapes, null, this.tag.mapper);
        };
        DDiagram.prototype.initializeShapes = function (shapes, tagShape, tagMapper) {
            var formatterMap = {};
            var initialMap = {};
            var actionMap = new Map();
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                var runtimeConstructor = EShapeRuntimes[shape.type] || EShapeRuntime;
                var runtime = (shape.runtime = new runtimeConstructor(shape));
                // Tag
                var tag = shape.tag;
                for (var j = 0, jmax = tag.size(); j < jmax; ++j) {
                    var value = tag.get(j);
                    if (value) {
                        // Mapping
                        if (tagMapper) {
                            tagMapper(value, tagShape || shape);
                        }
                        // Format
                        var tagFormat = value.format;
                        var tagInitial = value.initial;
                        if (tagFormat in formatterMap) {
                            value.formatter = formatterMap[tagFormat];
                        }
                        else if (0 < tagFormat.length) {
                            try {
                                var formatter = Function("value", 
                                /* eslint-disable prettier/prettier */
                                "try {" +
                                    ("return (" + tagFormat + ");") +
                                    "} catch( e1 ) {" +
                                    "try {" +
                                    ("return (" + (0 < tagInitial.length ? tagInitial : 0) + ");") +
                                    "} catch( e2 ) {" +
                                    "return 0;" +
                                    "}" +
                                    "}"
                                /* eslint-enable prettier/prettier */
                                );
                                formatterMap[tagFormat] = formatter;
                                value.formatter = formatter;
                            }
                            catch (e) {
                                //
                            }
                        }
                        // Initial
                        if (tagInitial in initialMap) {
                            value.value = initialMap[tagInitial];
                        }
                        else if (0 < tagInitial.length) {
                            try {
                                value.value = initialMap[tagInitial] = Function(
                                /* eslint-disable prettier/prettier */
                                "try {" +
                                    ("return (" + tagInitial + ");") +
                                    "} catch( e ) {" +
                                    "return 0;" +
                                    "}"
                                /* eslint-enable prettier/prettier */
                                )();
                            }
                            catch (e) {
                                //
                            }
                        }
                    }
                }
                // Initialize runtime actions
                var values = shape.action.values;
                var actions = runtime.actions;
                for (var j = 0, jmax = values.length; j < jmax; ++j) {
                    var value = values[j];
                    var action = actionMap.get(value);
                    if (action == null) {
                        action = value.toRuntime();
                        if (action != null) {
                            if (action instanceof EShapeActionRuntimeOpen) {
                                if (shape.cursor.length <= 0) {
                                    shape.cursor = "pointer";
                                }
                            }
                            actionMap.set(value, action);
                            actions.push(action);
                            runtime.reset |= action.reset;
                        }
                    }
                    else {
                        actions.push(action);
                        runtime.reset |= action.reset;
                    }
                }
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    this.initializeShapes(children, this.toTagShape(tagShape, shape), tagMapper);
                }
            }
        };
        DDiagram.prototype.toTagShape = function (tagShape, shape) {
            if (tagShape != null) {
                return tagShape;
            }
            if (shape.type === EShapeType.EMBEDDED) {
                return shape;
            }
            return null;
        };
        DDiagram.prototype.isEditMode = function () {
            return false;
        };
        DDiagram.prototype.newCanvas = function (serialized) {
            return new DDiagramCanvas(this.toCanvasOptions(serialized));
        };
        DDiagram.prototype.toCanvasOptions = function (serialized) {
            return this.toCanvasBaseOptions(serialized);
        };
        DDiagram.prototype.onDown = function (e) {
            var canvas = this.canvas;
            if (canvas && canvas.onShapeDown(e)) {
                return;
            }
            _super.prototype.onDown.call(this, e);
        };
        DDiagram.prototype.onDblClick = function (e, interactionManager) {
            var canvas = this.canvas;
            if (canvas && canvas.onShapeDblClick(e, interactionManager)) {
                return true;
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DDiagram.prototype.render = function (renderer) {
            this.shape.onRender(renderer);
            _super.prototype.render.call(this, renderer);
        };
        DDiagram.prototype.getType = function () {
            return "DDiagram";
        };
        return DDiagram;
    }(DDiagramBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmMessage = /** @class */ (function (_super) {
        __extends(DDialogConfirmMessage, _super);
        function DDialogConfirmMessage(options) {
            var _this = _super.call(this, options) || this;
            _this.state.isFocusable = false;
            return _this;
        }
        DDialogConfirmMessage.prototype.getType = function () {
            return "DDialogConfirmMessage";
        };
        return DDialogConfirmMessage;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirm = /** @class */ (function (_super) {
        __extends(DDialogConfirm, _super);
        function DDialogConfirm() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirm.prototype.onInit = function (layout, options) {
            _super.prototype.onInit.call(this, layout, options);
            layout.addChild(this.message);
        };
        DDialogConfirm.prototype.toMessage = function (theme, options) {
            var message = options === null || options === void 0 ? void 0 : options.message;
            if (message != null) {
                if (isString(message) || isFunction(message)) {
                    return this.newMessage(this.toMessageOptions(message));
                }
                else if (message instanceof DBase) {
                    return message;
                }
                else {
                    return this.newMessage(this.toMessageOptionsMerged(message, theme.getMessage()));
                }
            }
            return this.newMessage(this.toMessageOptions(theme.getMessage()));
        };
        DDialogConfirm.prototype.toMessageOptionsMerged = function (options, message) {
            var text = options.text;
            if (text == null) {
                text = {};
                options.text = text;
            }
            if (text.value === undefined) {
                text.value = message;
            }
            return options;
        };
        DDialogConfirm.prototype.toMessageOptions = function (message) {
            return {
                text: {
                    value: message
                }
            };
        };
        DDialogConfirm.prototype.newMessage = function (options) {
            return new DDialogConfirmMessage(options);
        };
        Object.defineProperty(DDialogConfirm.prototype, "message", {
            get: function () {
                var result = this._message;
                if (result == null) {
                    result = this.toMessage(this.theme, this._options);
                    this._message = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogConfirm.prototype.getResolvedValue = function () {
            return undefined;
        };
        DDialogConfirm.prototype.getType = function () {
            return "DDialogConfirm";
        };
        return DDialogConfirm;
    }(DDialogCommand));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmDelete = /** @class */ (function (_super) {
        __extends(DDialogConfirmDelete, _super);
        function DDialogConfirmDelete() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmDelete.prototype.getType = function () {
            return "DDialogConfirmDelete";
        };
        return DDialogConfirmDelete;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmDiscard = /** @class */ (function (_super) {
        __extends(DDialogConfirmDiscard, _super);
        function DDialogConfirmDiscard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmDiscard.prototype.getType = function () {
            return "DDialogConfirmDiscard";
        };
        return DDialogConfirmDiscard;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogMessage = /** @class */ (function (_super) {
        __extends(DDialogMessage, _super);
        function DDialogMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogMessage.prototype.getType = function () {
            return "DDialogMessage";
        };
        return DDialogMessage;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogProcessingMessage = /** @class */ (function (_super) {
        __extends(DDialogProcessingMessage, _super);
        function DDialogProcessingMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogProcessingMessage.prototype.getType = function () {
            return "DDialogProcessingMessage";
        };
        return DDialogProcessingMessage;
    }(DDialogConfirmMessage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogProcessing = /** @class */ (function (_super) {
        __extends(DDialogProcessing, _super);
        function DDialogProcessing(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._isDone = true;
            _this._startTime = 0;
            var delay = options === null || options === void 0 ? void 0 : options.delay;
            _this._delayDone = (_a = delay === null || delay === void 0 ? void 0 : delay.done) !== null && _a !== void 0 ? _a : _this.theme.getDoneDelay();
            var delayClose = delay === null || delay === void 0 ? void 0 : delay.close;
            _this._delayClose = delayClose !== undefined ? delayClose : _this.theme.getCloseDelay();
            _this._messageText = _this.message.text;
            return _this;
        }
        DDialogProcessing.prototype.newMessage = function (options) {
            return new DDialogProcessingMessage(options);
        };
        DDialogProcessing.prototype.onOpen = function () {
            this._isDone = false;
            this._startTime = Date.now();
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
            var closeTimeoutId = this._closeTimeoutId;
            if (closeTimeoutId != null) {
                clearTimeout(closeTimeoutId);
            }
            var message = this.message;
            message.text = this._messageText;
            message.state.removeAll(DBaseState.SUCCEEDED, DBaseState.FAILED);
            var buttonLayout = this._buttonLayout;
            if (buttonLayout != null) {
                buttonLayout.hide();
            }
            _super.prototype.onOpen.call(this);
        };
        DDialogProcessing.prototype.onDone = function (delay) {
            var _this = this;
            if (delay != null) {
                this._closeTimeoutId = window.setTimeout(function () {
                    _this.close();
                }, delay);
            }
            else {
                this.close();
            }
        };
        DDialogProcessing.prototype.onResolved = function (message) {
            if (message != null) {
                this.message.text = message;
            }
            this.message.state.set(DBaseState.SUCCEEDED, DBaseState.FAILED);
            var delayClose = this._delayClose;
            if (delayClose != null) {
                this.onDone(delayClose);
            }
            else {
                var buttonLayout = this._buttonLayout;
                if (buttonLayout != null) {
                    buttonLayout.show();
                }
                else {
                    this.close();
                }
            }
        };
        DDialogProcessing.prototype.onRejected = function (message) {
            if (message != null) {
                this.message.text = message;
            }
            this.message.state.set(DBaseState.FAILED, DBaseState.SUCCEEDED);
            var buttonLayout = this._buttonLayout;
            if (buttonLayout != null) {
                buttonLayout.show();
            }
            else {
                this.onDone(this._delayClose);
            }
        };
        DDialogProcessing.prototype.resolve = function (message) {
            var _this = this;
            if (!this._isDone) {
                this._isDone = true;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onResolved(message);
                    }, delay);
                }
                else {
                    this.onResolved(message);
                }
            }
        };
        DDialogProcessing.prototype.reject = function (message) {
            var _this = this;
            if (!this._isDone) {
                this._isDone = true;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onRejected(message);
                    }, delay);
                }
                else {
                    this.onRejected(message);
                }
            }
        };
        DDialogProcessing.prototype.onCloseOn = function () {
            if (this._isDone) {
                _super.prototype.onCloseOn.call(this);
            }
        };
        DDialogProcessing.prototype.getType = function () {
            return "DDialogProcessing";
        };
        return DDialogProcessing;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSaveAs = /** @class */ (function (_super) {
        __extends(DDialogSaveAs, _super);
        function DDialogSaveAs() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSaveAs.prototype.onOpen = function () {
            var name = DControllers.getDocumentController().getName();
            if (name != null) {
                this.input.value = name;
            }
            _super.prototype.onOpen.call(this);
        };
        DDialogSaveAs.prototype.onOk = function (value) {
            _super.prototype.onOk.call(this, value);
            var commandController = DControllers.getCommandController();
            if (isString(value)) {
                commandController.push(new DCommandSaveAs(value));
            }
            else {
                value.then(function (resolved) {
                    commandController.push(new DCommandSaveAs(resolved));
                });
            }
        };
        DDialogSaveAs.prototype.getType = function () {
            return "DDialogSaveAs";
        };
        return DDialogSaveAs;
    }(DDialogInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuContext = /** @class */ (function () {
        function DMenuContext(owner) {
            this._owner = owner;
            this._closeables = [];
        }
        DMenuContext.prototype.indexOf = function (target) {
            return this._closeables.indexOf(target);
        };
        DMenuContext.prototype.close = function (index) {
            var closeables = this._closeables;
            var imin = Math.max(0, index);
            for (var i = closeables.length - 1; imin <= i; --i) {
                closeables[i].close();
            }
        };
        DMenuContext.prototype.add = function (closeable) {
            this._closeables.push(closeable);
        };
        DMenuContext.prototype.trim = function (closeable) {
            this.close(this.indexOf(closeable) + 1);
        };
        DMenuContext.prototype.remove = function (closeable) {
            var index = this.indexOf(closeable);
            if (0 <= index) {
                this.close(index + 1);
                this._closeables.splice(index, 1);
            }
        };
        return DMenuContext;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenu = /** @class */ (function (_super) {
        __extends(DMenu, _super);
        function DMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenu.prototype.init = function (options) {
            var _this = this;
            var _a, _b, _c;
            _super.prototype.init.call(this, options);
            this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            this._align = toEnum((_a = options === null || options === void 0 ? void 0 : options.align) !== null && _a !== void 0 ? _a : UtilAttachAlign.BOTTOM, UtilAttachAlign);
            this._fit = (_b = options === null || options === void 0 ? void 0 : options.fit) !== null && _b !== void 0 ? _b : false;
            this._sticky = (_c = options === null || options === void 0 ? void 0 : options.sticky) !== null && _c !== void 0 ? _c : false;
            this._sub = false;
            this._owner = null;
            this._context = null;
            this.visible = false;
            this.state.isFocusRoot = true;
            // Event handlers
            UtilClickOutside.apply(this, function () {
                _this.close();
            });
            this.on("select", function () {
                _this.close();
            });
            // Items
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items) {
                DMenus.newItems(this, items, this._sticky);
            }
            // Overlay
            this._overlay = new UtilOverlay(options);
        };
        DMenu.prototype.findItem = function (value) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItem && child.value === value) {
                    return child;
                }
            }
            return null;
        };
        DMenu.prototype.getType = function () {
            return "DMenu";
        };
        DMenu.prototype.getContext = function () {
            return this._context;
        };
        DMenu.prototype.getCloseable = function () {
            return this;
        };
        DMenu.prototype.open = function (owner, closeable, context) {
            if (this.isHidden()) {
                var layer = this._overlay.pick(this);
                this._owner = owner;
                // States
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.state.removeAll(DBaseState.FOCUSED, DBaseState.HOVERED);
                    }
                }
                // Position & size
                var renderer = layer.renderer;
                var onPrerenderBound = this._onPrerenderBound;
                if (this._sticky) {
                    renderer.on("prerender", onPrerenderBound);
                }
                else {
                    renderer.once("prerender", onPrerenderBound);
                }
                if (this._fit) {
                    var bounds = owner.getBounds();
                    if (bounds != null) {
                        this.width = bounds.width;
                    }
                }
                // Target
                this._sub = context != null;
                context = context || new DMenuContext(owner);
                if (closeable != null) {
                    context.trim(closeable);
                }
                context.add(this);
                this._context = context;
                // Stage
                layer.stage.addChild(this);
                // Focus
                this._focused = layer.getFocusController().get();
                this.focus();
                // Show
                _super.prototype.show.call(this);
                // Event
                this.emit("open", this);
            }
            return this;
        };
        DMenu.prototype.onPrerender = function () {
            var owner = this._owner;
            if (owner) {
                var bounds = owner.getBounds();
                if (bounds) {
                    if (this._fit) {
                        this.width = bounds.width;
                    }
                    var layer = this._overlay.picked;
                    if (layer) {
                        var theme = this.theme;
                        UtilAttach.attach(this, bounds, theme.getOffsetX(), theme.getOffsetY(), layer.width, layer.height, this._align);
                    }
                }
            }
        };
        DMenu.prototype.close = function () {
            if (this.isShown()) {
                // Remove from the context
                var context = this._context;
                if (context) {
                    context.remove(this);
                }
                // Remove the prerender event handler
                var layer = this._overlay.picked;
                if (layer) {
                    layer.renderer.off("prerender", this._onPrerenderBound);
                }
                // Forget the owner
                this._owner = null;
                // Restore the focus
                var focused = this._focused;
                if (focused != null) {
                    this._focused = null;
                    if (layer) {
                        layer.getFocusController().focus(focused);
                    }
                    else {
                        this.blur(true);
                    }
                }
                else {
                    this.blur(true);
                }
                // Visibility
                _super.prototype.hide.call(this);
                // Remove from the tree
                var parent_1 = this.parent;
                if (parent_1) {
                    parent_1.removeChild(this);
                }
                // Emit the event
                this.emit("close", this);
            }
            return this;
        };
        DMenu.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusVertically(e, this, this._overlay);
            if (this.state.isActionable &&
                (UtilKeyboardEvent.isArrowLeftKey(e) || UtilKeyboardEvent.isCancelKey(e))) {
                this.close();
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenu.prototype.containsGlobalPoint = function (point) {
            return !this._sub;
        };
        return DMenu;
    }(DLayoutVertical));
    DMenus.setMenuCreator(function (options) { return new DMenu(options); });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dropdown base class.
     */
    var DDropdownBase = /** @class */ (function (_super) {
        __extends(DDropdownBase, _super);
        function DDropdownBase(options) {
            return _super.call(this, options) || this;
        }
        DDropdownBase.prototype.onMenuSelect = function (value, item, menu) {
            this.emit("select", value, item, this);
        };
        DDropdownBase.prototype.onMenuClose = function () {
            var menu = this.menu;
            var onMenuSelectBound = this._onMenuSelectBound;
            if (onMenuSelectBound) {
                menu.off("select", onMenuSelectBound);
            }
            var onMenuCloseBound = this._onMenuCloseBound;
            if (onMenuCloseBound) {
                menu.off("close", onMenuCloseBound);
            }
        };
        DDropdownBase.prototype.toMenu = function (theme, options) {
            var menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof DMenu) {
                return menu;
            }
            return new DMenu(this.toMenuOptions(theme, menu));
        };
        DDropdownBase.prototype.toMenuOptions = function (theme, options) {
            if (options) {
                if (options.fit == null) {
                    options.fit = true;
                }
                return options;
            }
            return {
                fit: true
            };
        };
        Object.defineProperty(DDropdownBase.prototype, "menu", {
            get: function () {
                var result = this._menu;
                if (result == null) {
                    result = this.toMenu(this.theme, this._options);
                    this._menu = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDropdownBase.prototype.getType = function () {
            return "DDropdownBase";
        };
        DDropdownBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.onKeyDownArrowDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDropdownBase.prototype.onKeyDownArrowDown = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onClick(e);
                return true;
            }
            return false;
        };
        DDropdownBase.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.start();
        };
        DDropdownBase.prototype.start = function () {
            var _this = this;
            var menu = this.menu;
            if (menu.isHidden()) {
                // In the case that the menu is created elsewhere,
                // the menu might be opened by other UI elements
                // and the `select` event might be triggered. In
                // that case, we are not supposed to catct that
                // `select` event. This is why the `select` event
                // handler is registered here. Instead of the
                // initialization time.
                var onMenuSelectBound = this._onMenuSelectBound;
                if (onMenuSelectBound == null) {
                    onMenuSelectBound = function (value, item, m) {
                        _this.onMenuSelect(value, item, m);
                    };
                    this._onMenuSelectBound = onMenuSelectBound;
                }
                var onMenuCloseBound = this._onMenuCloseBound;
                if (onMenuCloseBound == null) {
                    onMenuCloseBound = function () {
                        _this.onMenuClose();
                    };
                }
                menu.on("select", onMenuSelectBound);
                menu.on("close", onMenuCloseBound);
                menu.open(this);
            }
        };
        DDropdownBase.prototype.close = function () {
            this.menu.close();
        };
        return DDropdownBase;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDropdown = /** @class */ (function (_super) {
        __extends(DDropdown, _super);
        function DDropdown() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDropdown.prototype.getType = function () {
            return "DDropdown";
        };
        return DDropdown;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DExpandableHeader = /** @class */ (function (_super) {
        __extends(DExpandableHeader, _super);
        function DExpandableHeader(options) {
            var _this = _super.call(this, options) || this;
            _this.on(UtilPointerEvent.down, function (e) {
                if (_this.state.isActionable) {
                    _this.onSelect(e);
                }
            });
            return _this;
        }
        DExpandableHeader.prototype.onSelect = function (e) {
            this.emit("select", this);
        };
        DExpandableHeader.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DExpandableHeader.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onSelect(e);
                return true;
            }
            return false;
        };
        DExpandableHeader.prototype.getType = function () {
            return "DExpandableHeader";
        };
        return DExpandableHeader;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DExpandable = /** @class */ (function (_super) {
        __extends(DExpandable, _super);
        function DExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DExpandable.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            // Header
            var theme = this.theme;
            var header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", function () {
                _this.toggle();
            });
            this.addChild(header);
            // Body
            var body = this.toBody(theme, options);
            this._body = body;
            this.addChild(body);
            //
            if (this.state.isActive) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        };
        DExpandable.prototype.toHeader = function (theme, options) {
            if (options && options.header) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        };
        DExpandable.prototype.newHeader = function (theme, options) {
            return new DExpandableHeader(options);
        };
        DExpandable.prototype.toBody = function (theme, options) {
            return options.body;
        };
        DExpandable.prototype.open = function () {
            this.state.isActive = true;
        };
        DExpandable.prototype.close = function () {
            this.state.isActive = false;
        };
        DExpandable.prototype.toggle = function () {
            this.state.isActive = !this.state.isActive;
        };
        DExpandable.prototype.onActivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        };
        DExpandable.prototype.onDeactivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        };
        DExpandable.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this.onActivated();
                }
            }
            else {
                if (oldState.isActive) {
                    this.onDeactivated();
                }
            }
        };
        DExpandable.prototype.getType = function () {
            return "DExpandable";
        };
        return DExpandable;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputIntegerAndLabel = /** @class */ (function (_super) {
        __extends(DInputIntegerAndLabel, _super);
        function DInputIntegerAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputIntegerAndLabel.prototype.createInput = function (options) {
            return new DInputInteger(options);
        };
        return DInputIntegerAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapCoordinateEPSG3857 = /** @class */ (function () {
        function DMapCoordinateEPSG3857(tileSize) {
            if (tileSize === void 0) { tileSize = 256; }
            this._tileSize = tileSize;
        }
        DMapCoordinateEPSG3857.prototype.getTileSize = function () {
            return this._tileSize;
        };
        /**
         * Converts the given (lon, lat) point in WGS84 to (x, y) in EPSG:900913.
         * The origin of the converted point (x, y) is at the middle-left corner.
         * The `meters` can be the same instance that is passed in as the `lonlat`.
         *
         * @param lonlat (lon, lat) point
         * @param meters (x, y) point in meters converted from the given lonlat.
         * @return (x, y) point in meters
         * @see https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/
         * @see https://qiita.com/MALORGIS/items/1a9114dd090e5b891bf7
         */
        DMapCoordinateEPSG3857.prototype.lonLatToMeters = function (lonlat, meters) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = (lonlat.x * C) / 180;
            meters.y = (Math.log(Math.tan(((90 + lonlat.y) * Math.PI) / 360)) * C) / Math.PI;
            return meters;
        };
        /**
         * The `lonlat` can be the same instance that is passed in as the `meters`.
         *
         * @param meters
         * @param lonlat
         */
        DMapCoordinateEPSG3857.prototype.metersToLonLat = function (meters, lonlat) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            lonlat.x = (meters.x / C) * 180;
            lonlat.y = (Math.atan(Math.exp((meters.y * Math.PI) / C)) * 360) / Math.PI - 90;
            return lonlat;
        };
        /**
         * Converts pixel coordinates in given zoom level of pyramid to EPSG:900913.
         * The origin of the `pixels` is the top-left corner.
         * The `meters` can be the same instance that is passed in as the `pixels`.
         */
        DMapCoordinateEPSG3857.prototype.pixelsToMeters = function (pixels, tz, tileSize, meters) {
            var R = this.toResolution(tz, tileSize);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = pixels.x * R - C;
            meters.y = C - pixels.y * R;
            return meters;
        };
        /**
         * Converts EPSG:900913 to pyramid pixel coordinates in given zoom level.
         * The origin of the pixels is the top-left corner.
         * The `pixels` can be the same instance that is passed in as the `meters`.
         */
        DMapCoordinateEPSG3857.prototype.metersToPixels = function (meters, tz, tileSize, pixels) {
            var R = this.toResolution(tz, tileSize);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            pixels.x = (meters.x + C) / R;
            pixels.y = (C - meters.y) / R;
            return pixels;
        };
        /**
         * Returns a tile covering region in given pixel coordinates.
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `pixels`.
         */
        DMapCoordinateEPSG3857.prototype.pixelsToTile = function (pixels, tileSize, tile) {
            tile.x = Math.ceil(pixels.x / tileSize) - 1;
            tile.y = Math.ceil(pixels.y / tileSize) - 1;
            return tile;
        };
        /**
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `meters`.
         */
        DMapCoordinateEPSG3857.prototype.metersToTile = function (meters, tz, tile) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            var Z = 1 << tz;
            tile.x = Math.ceil(0.5 * (meters.x / C + 1) * Z) - 1;
            tile.y = Math.ceil(0.5 * (1 - meters.y / C) * Z) - 1;
            return tile;
        };
        DMapCoordinateEPSG3857.prototype.lonLatToTile = function (lonlat, tz, tile) {
            return this.metersToTile(this.lonLatToMeters(lonlat, tile), tz, tile);
        };
        DMapCoordinateEPSG3857.prototype.lonLatToPixels = function (lonlat, tz, tileSize, pixels) {
            return this.metersToPixels(this.lonLatToMeters(lonlat, pixels), tz, tileSize, pixels);
        };
        DMapCoordinateEPSG3857.prototype.pixelsToLonLat = function (pixels, tz, tileSize, lonlat) {
            return this.metersToLonLat(this.pixelsToMeters(pixels, tz, tileSize, lonlat), lonlat);
        };
        /**
         * The `pixels` can be the same instance that is passed in as the `tile`.
         */
        DMapCoordinateEPSG3857.prototype.tileToPixels = function (tile, tileSize, pixels) {
            pixels.x = tile.x * tileSize;
            pixels.y = tile.y * tileSize;
            return pixels;
        };
        /**
         * Returns bounds of the given tile in EPSG:900913 coordinates
         * The `meters` can be the same instance that is passed in as the `tile`.
         */
        DMapCoordinateEPSG3857.prototype.tileToMeters = function (tile, tz, meters) {
            var R = this.toResolutionMeter(tz);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = tile.x * R + C;
            meters.y = C - tile.y * R;
            return meters;
        };
        DMapCoordinateEPSG3857.prototype.toResolutionMeter = function (tz) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (1 << tz);
        };
        DMapCoordinateEPSG3857.prototype.toResolution = function (tz, tileSize) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (tileSize << tz);
        };
        DMapCoordinateEPSG3857.prototype.toTileCount = function (tz) {
            return 1 << tz;
        };
        DMapCoordinateEPSG3857.prototype.toTileCode = function (tz, tx, ty) {
            return (tx << tz) + ty;
        };
        DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF = Math.PI * 6378137 /* Approximate earth radius in meter */;
        return DMapCoordinateEPSG3857;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapCoordinates = /** @class */ (function () {
        function DMapCoordinates() {
        }
        Object.defineProperty(DMapCoordinates, "DEFAULT", {
            get: function () {
                if (this._default == null) {
                    this._default = new DMapCoordinateEPSG3857();
                }
                return this._default;
            },
            enumerable: false,
            configurable: true
        });
        return DMapCoordinates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTile = /** @class */ (function () {
        function DMapTile(parent, tx, ty, px, py, scale) {
            this.tx = tx;
            this.ty = ty;
            var sprite = new pixi_js.Sprite(pixi_js.Texture.EMPTY);
            sprite.parent = parent;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
            this._sprite = sprite;
        }
        DMapTile.prototype.load = function (url, onLoaded) {
            var texture = pixi_js.Texture.from(url, { resolution: 1 });
            this._sprite.texture = texture;
            if (texture.valid) {
                onLoaded();
            }
            else {
                texture.on("update", onLoaded);
            }
        };
        DMapTile.prototype.transform = function (px, py, scale) {
            var sprite = this._sprite;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
        };
        Object.defineProperty(DMapTile.prototype, "loaded", {
            get: function () {
                return this._sprite.texture.valid;
            },
            enumerable: false,
            configurable: true
        });
        DMapTile.prototype.render = function (renderer) {
            var sprite = this._sprite;
            sprite.updateTransform();
            sprite.render(renderer);
        };
        DMapTile.prototype.destroy = function () {
            var sprite = this._sprite;
            var texture = sprite.texture;
            var resource = texture.baseTexture.resource;
            var image = null;
            if (resource instanceof pixi_js.resources.BaseImageResource) {
                if (resource.source instanceof HTMLImageElement) {
                    image = resource.source;
                }
            }
            texture.destroy(true);
            sprite.destroy();
            if (image) {
                image.src = "";
            }
        };
        return DMapTile;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTilePlane = /** @class */ (function () {
        function DMapTilePlane(parent, builder, tz, mapping, coordinate, onLoaded) {
            var _this = this;
            this._parent = parent;
            this._builder = builder;
            this._onLoaded = onLoaded;
            this._isOnLoadedCalled = false;
            this._isOnLoadedAllowed = true;
            this._onLoadedBound = function () {
                _this.onLoaded();
            };
            this._tz = tz;
            this._lon0 = NaN;
            this._lat0 = NaN;
            this._lon1 = NaN;
            this._lat1 = NaN;
            this._tiles = new Map();
            this._renderTileBound = function (tile) {
                _this.renderTile(tile);
            };
            this._txmin = NaN;
            this._txmax = NaN;
            this._tymin = NaN;
            this._tymax = NaN;
            this._deleteTileBound = function (tile, tileCode, tiles) {
                _this.deleteTile(tile, tileCode, tiles);
            };
            this._destroyTileBound = function (tile) {
                _this.destroyTile(tile);
            };
            this._updateLoadingStateForEach = function (tile) {
                if (!tile.loaded) {
                    _this._isLoaded = false;
                }
            };
            this._tileCount = coordinate.toTileCount(tz);
            this._tileScaleRelative = 1 / this._tileCount;
            this._tileScale = mapping.scale * this._tileScaleRelative;
            this._tileSize = coordinate.getTileSize() * mapping.scale;
            this._mapping = mapping;
            this._coordinate = coordinate;
            this._isLoaded = true;
        }
        DMapTilePlane.prototype.newTile = function (tx, ty, px, py, scale) {
            return new DMapTile(this._parent, tx, ty, px, py, scale);
        };
        DMapTilePlane.prototype.renderTile = function (tile) {
            tile.render(this._renderer);
        };
        Object.defineProperty(DMapTilePlane.prototype, "tz", {
            get: function () {
                return this._tz;
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePlane.prototype.render = function (renderer) {
            this._renderer = renderer;
            this._tiles.forEach(this._renderTileBound);
        };
        DMapTilePlane.prototype.move = function (lon0, lat0, lon1, lat1) {
            var oldLon0 = this._lon0;
            var oldLat0 = this._lat0;
            var oldLon1 = this._lon1;
            var oldLat1 = this._lat1;
            if (oldLon0 !== lon0 || oldLat0 !== lat0 || oldLon1 !== lon1 || oldLat1 !== lat1) {
                this._lon0 = lon0;
                this._lat0 = lat0;
                this._lon1 = lon1;
                this._lat1 = lat1;
                var tz = this._tz;
                var coordinate = this._coordinate;
                var work = DMapTilePlane.WORK;
                work.set(lon0, lat0);
                coordinate.lonLatToTile(work, tz, work);
                var tx0 = work.x;
                var ty0 = work.y;
                work.set(lon1, lat1);
                coordinate.lonLatToTile(work, tz, work);
                var tx1 = work.x;
                var ty1 = work.y;
                var tileCount = this._tileCount;
                var txmin = Math.max(0, tx0);
                var txmax = Math.min(tileCount - 1, tx1);
                var tymin = Math.max(0, ty0);
                var tymax = Math.min(tileCount - 1, ty1);
                var dtxmin = txmin - this._txmin;
                var dtxmax = txmax - this._txmax;
                var dtymin = tymin - this._tymin;
                var dtymax = tymax - this._tymax;
                var isTxMinChanged = dtxmin !== dtxmin || dtxmin < 0 || 1 < dtxmin;
                var isTxMaxChanged = dtxmax !== dtxmax || 0 < dtxmax || dtxmax < -1;
                var isTyMinChanged = dtymin !== dtymin || dtymin < 0 || 1 < dtymin;
                var isTyMaxChanged = dtymax !== dtymax || 0 < dtymax || dtymax < -1;
                if (isTxMinChanged || isTxMaxChanged || isTyMinChanged || isTyMaxChanged) {
                    if (isTxMinChanged) {
                        this._txmin = txmin;
                    }
                    else {
                        txmin = this._txmin;
                    }
                    if (isTxMaxChanged) {
                        this._txmax = txmax;
                    }
                    else {
                        txmax = this._txmax;
                    }
                    if (isTyMinChanged) {
                        this._tymin = tymin;
                    }
                    else {
                        tymin = this._tymin;
                    }
                    if (isTyMaxChanged) {
                        this._tymax = tymax;
                    }
                    else {
                        tymax = this._tymax;
                    }
                    var tiles = this._tiles;
                    tiles.forEach(this._deleteTileBound);
                    var ctx = (txmin + txmax) >> 1;
                    var cty = (tymin + tymax) >> 1;
                    var ltx = Math.max(ctx - txmin, txmax - ctx);
                    var lty = Math.max(cty - tymin, tymax - cty);
                    var lt = Math.max(ltx, lty);
                    this.toOffset(work);
                    var offsetX = work.x;
                    var offsetY = work.y;
                    this._isOnLoadedCalled = false;
                    this._isOnLoadedAllowed = false;
                    this.loadTile(tz, ctx, cty, offsetX, offsetY, work);
                    for (var it = 1; it <= lt; ++it) {
                        var txa = ctx - it;
                        if (txmin <= txa) {
                            this.loadTilesY(tz, txa, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        var txb = ctx + it;
                        if (txb <= txmax) {
                            this.loadTilesY(tz, txb, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        var tya = cty - it;
                        if (tymin <= tya) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tya, offsetX, offsetY, work);
                        }
                        var tyb = cty + it;
                        if (tyb <= tymax) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tyb, offsetX, offsetY, work);
                        }
                    }
                    this._isOnLoadedAllowed = true;
                    if (this._isOnLoadedCalled) {
                        this.onLoaded();
                    }
                }
            }
        };
        DMapTilePlane.prototype.loadTilesX = function (tz, ctx, ltx, txmin, txmax, ty, ox, oy, work) {
            this.loadTile(tz, ctx, ty, ox, oy, work);
            for (var i = 1; i <= ltx; ++i) {
                var txa = ctx - i;
                if (txmin <= txa) {
                    this.loadTile(tz, txa, ty, ox, oy, work);
                }
                var txb = ctx + i;
                if (txb <= txmax) {
                    this.loadTile(tz, txb, ty, ox, oy, work);
                }
            }
        };
        DMapTilePlane.prototype.loadTilesY = function (tz, tx, cty, lty, tymin, tymax, ox, oy, work) {
            this.loadTile(tz, tx, cty, ox, oy, work);
            for (var i = 1; i <= lty; ++i) {
                var tya = cty - i;
                if (tymin <= tya) {
                    this.loadTile(tz, tx, tya, ox, oy, work);
                }
                var tyb = cty + i;
                if (tyb <= tymax) {
                    this.loadTile(tz, tx, tyb, ox, oy, work);
                }
            }
        };
        DMapTilePlane.prototype.loadTile = function (tz, tx, ty, ox, oy, work) {
            var coordinate = this._coordinate;
            var tileCode = coordinate.toTileCode(tz, tx, ty);
            var tiles = this._tiles;
            var tile = tiles.get(tileCode);
            if (tile == null) {
                this.toTilePosition(tx, ty, ox, oy, work);
                tile = this.newTile(tx, ty, work.x, work.y, this._tileScale);
                tiles.set(tileCode, tile);
                tile.load(this._builder(tz, tx, ty), this._onLoadedBound);
                this._isLoaded = false;
            }
        };
        DMapTilePlane.prototype.toTilePosition = function (tx, ty, ox, oy, result) {
            var tileSize = this._tileSize;
            var tileScaleRelative = this._tileScaleRelative;
            result.set(tx, ty);
            this._coordinate.tileToPixels(result, tileSize, result);
            result.set(result.x * tileScaleRelative + ox, result.y * tileScaleRelative + oy);
            return result;
        };
        DMapTilePlane.prototype.toOffset = function (result) {
            var parent = this._parent;
            var mapping = this._mapping;
            var tileSize = this._tileSize;
            result.set(-mapping.x * tileSize + parent.width * 0.5, -mapping.y * tileSize + parent.height * 0.5);
            return result;
        };
        DMapTilePlane.prototype.deleteTile = function (tile, tileCode, tiles) {
            var tx = tile.tx;
            var ty = tile.ty;
            if (tx < this._txmin || this._txmax < tx || ty < this._tymin || this._tymax < ty) {
                tiles.delete(tileCode);
                tile.destroy();
            }
        };
        DMapTilePlane.prototype.destroy = function () {
            var tiles = this._tiles;
            tiles.forEach(this._destroyTileBound);
            tiles.clear();
        };
        DMapTilePlane.prototype.destroyTile = function (tile) {
            tile.destroy();
        };
        DMapTilePlane.prototype.updateLoadingState = function () {
            this._isLoaded = true;
            this._tiles.forEach(this._updateLoadingStateForEach);
        };
        DMapTilePlane.prototype.onLoaded = function () {
            if (this._isOnLoadedAllowed) {
                this._onLoaded();
            }
            else {
                this._isOnLoadedCalled = true;
            }
        };
        Object.defineProperty(DMapTilePlane.prototype, "loaded", {
            get: function () {
                if (!this._isLoaded) {
                    this.updateLoadingState();
                }
                return this._isLoaded;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DMapTilePlane.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            set: function (mapping) {
                var _this = this;
                var coordinate = this._coordinate;
                var tileScale = mapping.scale * this._tileScaleRelative;
                var tileSize = coordinate.getTileSize() * mapping.scale;
                this._tileScale = tileScale;
                this._tileSize = tileSize;
                this._mapping = mapping;
                var work = DMapTilePlane.WORK;
                this.toOffset(work);
                var offsetX = work.x;
                var offsetY = work.y;
                this._tiles.forEach(function (tile) {
                    _this.toTilePosition(tile.tx, tile.ty, offsetX, offsetY, work);
                    tile.transform(work.x, work.y, tileScale);
                });
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePlane.WORK = new pixi_js.Point();
        return DMapTilePlane;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTilePyramidImpl = /** @class */ (function (_super) {
        __extends(DMapTilePyramidImpl, _super);
        function DMapTilePyramidImpl(options) {
            var _this = _super.call(this) || this;
            var canvas = options.canvas;
            _this._canvas = canvas;
            _this._builder = options.builder;
            var mapping = options.mapping;
            _this._mapping = mapping;
            var coordinate = options.coordinate;
            _this._coordinate = coordinate;
            _this._mappingInternal = _this.toMapping(canvas, mapping, coordinate);
            _this._z = NaN;
            _this._tz = NaN;
            _this._minZ = options.plane.min;
            _this._maxZ = options.plane.max;
            _this._planes = [];
            _this._onLoadedBound = function () {
                _this.onLoaded();
            };
            _this._fitBound = function () {
                _this._fitBoundTimeout = undefined;
                _this.fit();
            };
            _this._fitThrottle = options.plane.throttle;
            var fitThrottledBound = function () {
                _this.fitThrottled();
            };
            _this._fitThrottledBound = fitThrottledBound;
            canvas.on("scale", fitThrottledBound);
            canvas.on("move", fitThrottledBound);
            canvas.snippet.add(_this, true);
            return _this;
        }
        Object.defineProperty(DMapTilePyramidImpl.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePyramidImpl.prototype.fitThrottled = function () {
            if (this._fitBoundTimeout == null) {
                this._fitBoundTimeout = window.setTimeout(this._fitBound, this._fitThrottle);
            }
        };
        DMapTilePyramidImpl.prototype.toMapping = function (canvas, mapping, coordinate) {
            var work = DMapTilePyramidImpl.WORK_LONLAT;
            var tileSize = coordinate.getTileSize();
            work.set(mapping.from.lon, mapping.from.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            var x0 = work.x;
            var y0 = work.y;
            work.set(mapping.to.lon, mapping.to.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            var x1 = work.x;
            var y1 = work.y;
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var dmin = 0.0000001;
            var scale = 1;
            if (dmin < dx) {
                if (dmin < dy) {
                    scale = Math.max(canvas.width / dx, canvas.height / dy);
                }
                else {
                    scale = canvas.width / dx;
                }
            }
            else {
                if (dmin < dy) {
                    scale = canvas.height / dy;
                }
            }
            return {
                scale: scale,
                x: (0.5 * (x1 + x0)) / tileSize,
                y: (0.5 * (y1 + y0)) / tileSize
            };
        };
        Object.defineProperty(DMapTilePyramidImpl.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            set: function (mapping) {
                var oldMapping = this._mappingInternal;
                var newMapping = this.toMapping(this._canvas, mapping, this._coordinate);
                var threshold = 0.0000001;
                if (threshold < Math.abs(oldMapping.scale - newMapping.scale) ||
                    threshold < Math.abs(oldMapping.x - newMapping.x) ||
                    threshold < Math.abs(oldMapping.y - newMapping.y)) {
                    this._mappingInternal = newMapping;
                    var planes = this._planes;
                    for (var i = 0, imax = planes.length; i < imax; ++i) {
                        var plane = planes[i];
                        if (plane) {
                            plane.mapping = newMapping;
                        }
                    }
                    DApplications.update(this._canvas);
                    this._fitThrottledBound();
                }
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePyramidImpl.prototype.newPlane = function (tz) {
            return new DMapTilePlane(this._canvas, this._builder, tz, this._mappingInternal, this._coordinate, this._onLoadedBound);
        };
        DMapTilePyramidImpl.prototype.render = function (renderer) {
            var tz = this._tz;
            var planes = this._planes;
            for (var i = 0; i < tz; ++i) {
                var plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            for (var i = planes.length - 1; tz < i; --i) {
                var plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            var planeTz = planes[tz];
            if (planeTz != null) {
                planeTz.render(renderer);
            }
        };
        DMapTilePyramidImpl.prototype.toTileZ = function (tz) {
            return Math.min(this._maxZ, Math.max(this._minZ, Math.floor(tz)));
        };
        DMapTilePyramidImpl.prototype.updateTransform = function () {
            // DO NOTHING
        };
        DMapTilePyramidImpl.prototype.toZ = function (scale) {
            return Math.log(this._mappingInternal.scale * scale) / Math.log(2);
        };
        DMapTilePyramidImpl.prototype.move = function (scale, lon0, lat0, lon1, lat1) {
            var planes = this._planes;
            var z = this.toZ(scale);
            if (this._z !== z) {
                this._z = z;
                var tz = this.toTileZ(z);
                if (this._tz !== tz) {
                    this._tz = tz;
                    var newPlane = planes[tz];
                    if (newPlane == null) {
                        newPlane = this.newPlane(tz);
                        planes[tz] = newPlane;
                    }
                }
            }
            var plane = planes[this._tz];
            if (plane != null) {
                plane.move(lon0, lat0, lon1, lat1);
            }
            return this;
        };
        DMapTilePyramidImpl.prototype.fit = function () {
            var canvas = this._canvas;
            if (canvas != null) {
                var container = canvas.parent;
                if (container != null) {
                    var scale = canvas.scale;
                    var scaleX = scale.x;
                    var scaleY = scale.y;
                    var x = canvas.x;
                    var y = canvas.y;
                    var coordinate = this._coordinate;
                    var mapping = this._mappingInternal;
                    var tileSize = coordinate.getTileSize() * mapping.scale;
                    var x0 = mapping.x * tileSize - (x / scaleX + 0.5 * canvas.width);
                    var x1 = x0 + container.width / scaleX;
                    var y0 = mapping.y * tileSize - (y / scaleY + 0.5 * canvas.height);
                    var y1 = y0 + container.height / scaleY;
                    var work = DMapTilePyramidImpl.WORK_LONLAT;
                    work.set(x0, y0);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    var lon0 = work.x;
                    var lat0 = work.y;
                    work.set(x1, y1);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    var lon1 = work.x;
                    var lat1 = work.y;
                    this.move(scaleX, lon0, lat0, lon1, lat1);
                }
            }
            return this;
        };
        DMapTilePyramidImpl.prototype.destroyPlanesBefore = function (tz, planes) {
            for (var i = 0; i < tz; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        };
        DMapTilePyramidImpl.prototype.destroyPlanesAfter = function (tz, planes) {
            for (var i = tz + 1, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        };
        DMapTilePyramidImpl.prototype.cleanup = function () {
            var tz = this._tz;
            var planes = this._planes;
            var planeTz = planes[tz];
            if (planeTz && planeTz.loaded) {
                this.destroyPlanesBefore(tz, planes);
                this.destroyPlanesAfter(tz, planes);
                return;
            }
            for (var i = tz + 1, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(tz, planes);
                    this.destroyPlanesAfter(i, planes);
                    return;
                }
            }
            for (var i = tz - 1; 0 <= i; --i) {
                var plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(i, planes);
                    return;
                }
            }
        };
        DMapTilePyramidImpl.prototype.onLoaded = function () {
            this.cleanup();
            DApplications.update(this._canvas);
        };
        DMapTilePyramidImpl.prototype.destroy = function () {
            var planes = this._planes;
            for (var i = 0, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
            var canvas = this._canvas;
            var fitThrottledBound = this._fitThrottledBound;
            canvas.off("scale", fitThrottledBound);
            canvas.off("move", fitThrottledBound);
            canvas.snippet.remove(this, true);
            return this;
        };
        DMapTilePyramidImpl.WORK_LONLAT = new pixi_js.Point();
        return DMapTilePyramidImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTileUrlBuilderKokudo = function (tz, tx, ty) {
        if (5 <= tz) {
            return "https://cyberjapandata.gsi.go.jp/xyz/pale/" + tz + "/" + tx + "/" + ty + ".png";
        }
        else if (2 <= tz) {
            return "https://cyberjapandata.gsi.go.jp/xyz/std/" + tz + "/" + tx + "/" + ty + ".png";
        }
        else {
            return "https://cyberjapandata.gsi.go.jp/xyz/earthhillshade/" + tz + "/" + tx + "/" + ty + ".png";
        }
    };
    var DMapTileUrlBuilderOsm = function (tz, tx, ty) {
        return "https://" + "abc"[(tx + ty) % 3] + ".tile.openstreetmap.org/" + tz + "/" + tx + "/" + ty + ".png";
    };
    var DMapTileUrlBuilderOsmfj = function (tz, tx, ty) {
        return "https://j.tile.openstreetmap.jp/" + tz + "/" + tx + "/" + ty + ".png";
    };
    var DMapTilePyramids = /** @class */ (function () {
        function DMapTilePyramids() {
        }
        DMapTilePyramids.toPlaneOptions = function (options) {
            var _a, _b, _c;
            var plane = options.plane;
            return {
                min: (_a = plane === null || plane === void 0 ? void 0 : plane.min) !== null && _a !== void 0 ? _a : this.MIN,
                max: (_b = plane === null || plane === void 0 ? void 0 : plane.max) !== null && _b !== void 0 ? _b : this.MAX,
                throttle: (_c = plane === null || plane === void 0 ? void 0 : plane.throttle) !== null && _c !== void 0 ? _c : this.THROTTLE
            };
        };
        DMapTilePyramids.from = function (options) {
            return new DMapTilePyramidImpl({
                canvas: options.canvas,
                builder: options.builder || DMapTileUrlBuilderOsmfj,
                mapping: options.canvas.tile.mapping,
                coordinate: options.coordinate || DMapCoordinates.DEFAULT,
                plane: this.toPlaneOptions(options)
            });
        };
        DMapTilePyramids.MIN = 0;
        DMapTilePyramids.MAX = 18;
        DMapTilePyramids.THROTTLE = 333;
        return DMapTilePyramids;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuBarItem = /** @class */ (function (_super) {
        __extends(DMenuBarItem, _super);
        function DMenuBarItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuBarItem.prototype.toMenu = function (theme, options) {
            var menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof DMenu) {
                return menu;
            }
            else {
                return new DMenu(this.toMenuOptions(theme, menu));
            }
        };
        DMenuBarItem.prototype.newMenu = function (theme, options) {
            return new DMenu(this.toMenuOptions(theme, options));
        };
        DMenuBarItem.prototype.toMenuOptions = function (theme, options) {
            if (options) {
                if (options.fit == null) {
                    options.fit = false;
                }
                return options;
            }
            return {
                fit: false
            };
        };
        DMenuBarItem.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.open();
        };
        DMenuBarItem.prototype.open = function () {
            this.menu.open(this);
        };
        DMenuBarItem.prototype.close = function () {
            this.menu.close();
        };
        Object.defineProperty(DMenuBarItem.prototype, "menu", {
            get: function () {
                var _this = this;
                var result = this._menu;
                if (result == null) {
                    result = this.toMenu(this.theme, this._options);
                    result.on("select", function (value, item, menu) {
                        _this.onMenuSelect(value, item, menu);
                    });
                    this._menu = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DMenuBarItem.prototype.onMenuSelect = function (value, item, menu) {
            this.emit("select", value, item, this);
            var parent = this.parent;
            if (parent) {
                parent.emit("select", value, item, parent);
            }
        };
        DMenuBarItem.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.onKeyDownArrowDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuBarItem.prototype.onKeyDownArrowDown = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onActivate(e);
                return true;
            }
            return false;
        };
        DMenuBarItem.prototype.getType = function () {
            return "DMenuBarItem";
        };
        return DMenuBarItem;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuBar = /** @class */ (function (_super) {
        __extends(DMenuBar, _super);
        function DMenuBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuBar.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.state.isFocusRoot = true;
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items) {
                for (var i = 0, imax = items.length; i < imax; ++i) {
                    var item = this.toItem(items[i]);
                    if (item) {
                        this.addChild(item);
                    }
                }
            }
        };
        DMenuBar.prototype.toItem = function (item) {
            if (item == null) {
                return null;
            }
            else if (item instanceof pixi_js.DisplayObject) {
                return item;
            }
            else if ("space" in item) {
                return new DLayoutSpace(item);
            }
            return new DMenuBarItem(item);
        };
        DMenuBar.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusHorizontally(e, this);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuBar.prototype.getType = function () {
            return "DMenuBar";
        };
        return DMenuBar;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedContent = /** @class */ (function (_super) {
        __extends(DMenuSidedContent, _super);
        function DMenuSidedContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedContent.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
        };
        DMenuSidedContent.prototype.initReflowable = function () {
            // DO NOTHING
        };
        DMenuSidedContent.prototype.getType = function () {
            return "DMenuSidedContent";
        };
        return DMenuSidedContent;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedSelectionType;
    (function (DMenuSidedSelectionType) {
        DMenuSidedSelectionType[DMenuSidedSelectionType["NONE"] = 0] = "NONE";
        DMenuSidedSelectionType[DMenuSidedSelectionType["SINGLE"] = 1] = "SINGLE";
        DMenuSidedSelectionType[DMenuSidedSelectionType["SINGLE_ONCE"] = 2] = "SINGLE_ONCE";
        DMenuSidedSelectionType[DMenuSidedSelectionType["DEFAULT"] = 2] = "DEFAULT";
    })(DMenuSidedSelectionType || (DMenuSidedSelectionType = {}));
    var defaultFilter = function () { return true; };
    var DMenuSidedSelection = /** @class */ (function (_super) {
        __extends(DMenuSidedSelection, _super);
        function DMenuSidedSelection(content, options) {
            var _a, _b, _c;
            var _this = _super.call(this) || this;
            _this._content = content;
            _this._item = null;
            _this._isDirty = true;
            _this._type = toEnum((_b = (_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : DMenuSidedSelectionType.DEFAULT, DMenuSidedSelectionType);
            _this._filter = (_c = options === null || options === void 0 ? void 0 : options.filter) !== null && _c !== void 0 ? _c : _this.getFilterDefault();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DMenuSidedSelection.prototype.first = function () {
            return this._item;
        };
        DMenuSidedSelection.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DMenuSidedSelection.prototype.update = function () {
            if (this._isDirty) {
                this._isDirty = false;
                this.update_(this._content);
            }
        };
        DMenuSidedSelection.prototype.hasMenu = function (child) {
            return child && child.menu instanceof DMenu;
        };
        DMenuSidedSelection.prototype.update_ = function (root) {
            var children = root.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemBase) {
                    if (child.state.isActive) {
                        this.set_(child, false);
                    }
                }
                if (child instanceof pixi_js.Container) {
                    this.update_(child);
                }
                if (this.hasMenu(child)) {
                    this.update_(child.menu);
                }
            }
        };
        DMenuSidedSelection.prototype.add = function (item) {
            this.update();
            this.set_(item, true);
        };
        DMenuSidedSelection.prototype.set = function (item) {
            this.update();
            this.set_(item, true);
        };
        DMenuSidedSelection.prototype.get = function (index) {
            this.update();
            return this._item;
        };
        DMenuSidedSelection.prototype.getIndex = function (index) {
            return null;
        };
        DMenuSidedSelection.prototype.size = function () {
            return this._item ? 1 : 0;
        };
        DMenuSidedSelection.prototype.isEmpty = function () {
            return this._item == null;
        };
        DMenuSidedSelection.prototype.remove = function (item) {
            this.update();
            if (this._item === item) {
                this.set_(null, true);
            }
        };
        DMenuSidedSelection.prototype.clear = function () {
            this.update();
            this.set_(null, true);
        };
        DMenuSidedSelection.prototype.getFilterDefault = function () {
            return defaultFilter;
        };
        DMenuSidedSelection.prototype.set_ = function (item, emit) {
            var oldItem = this._item;
            var mode = this._type;
            if (mode !== DMenuSidedSelectionType.NONE && this._filter(item) && oldItem !== item) {
                this.setState(oldItem, mode, false);
                this._item = item;
                this.setState(item, mode, true);
                if (emit) {
                    this.emit("change", this);
                }
            }
        };
        DMenuSidedSelection.prototype.setState = function (item, mode, isOn) {
            if (item) {
                if (mode === DMenuSidedSelectionType.SINGLE) {
                    item.state.isActive = isOn;
                }
                else {
                    if (isOn) {
                        item.state.addAll(DBaseState.ACTIVE, DBaseState.READ_ONLY);
                    }
                    else {
                        item.state.removeAll(DBaseState.ACTIVE, DBaseState.READ_ONLY);
                    }
                }
            }
        };
        return DMenuSidedSelection;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSided = /** @class */ (function (_super) {
        __extends(DMenuSided, _super);
        function DMenuSided() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSided.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            var context = new DMenuContext(this);
            this._context = context;
            context.add(this);
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items != null) {
                var sticky = (_a = options === null || options === void 0 ? void 0 : options.sticky) !== null && _a !== void 0 ? _a : false;
                this.newItems(items, sticky);
            }
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            if (selection instanceof DMenuSidedSelection) {
                this._selection = selection;
            }
            else {
                this._selection = this.newSelection(selection);
            }
        };
        DMenuSided.prototype.newSelection = function (options) {
            return new DMenuSidedSelection(this._content, options);
        };
        DMenuSided.prototype.onChildrenDirty = function () {
            var selection = this._selection;
            if (selection != null) {
                selection.toDirty();
            }
            _super.prototype.onChildrenDirty.call(this);
        };
        DMenuSided.prototype.newItems = function (items, sticky) {
            DMenuSideds.newItems(this._content, items, sticky);
        };
        DMenuSided.prototype.newContent = function (options) {
            return new DMenuSidedContent(options);
        };
        Object.defineProperty(DMenuSided.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DMenuSided.prototype.getContext = function () {
            return this._context;
        };
        DMenuSided.prototype.getCloseable = function () {
            return this;
        };
        DMenuSided.prototype.open = function () {
            // DO NOTHING
        };
        DMenuSided.prototype.close = function () {
            // DO NOTHING
        };
        DMenuSided.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusVertically(e, this);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuSided.prototype.getType = function () {
            return "DMenuSided";
        };
        return DMenuSided;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNotification = /** @class */ (function (_super) {
        __extends(DNotification, _super);
        function DNotification() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DNotification;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationDotsButton = /** @class */ (function (_super) {
        __extends(DPaginationDotsButton, _super);
        function DPaginationDotsButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationDotsButton.prototype.getType = function () {
            return "DPaginationDotsButton";
        };
        return DPaginationDotsButton;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationDynamicButtons = /** @class */ (function (_super) {
        __extends(DPaginationDynamicButtons, _super);
        function DPaginationDynamicButtons() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationDynamicButtons.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._dotsBtnLeft = new DPaginationDotsButton({
                width: options.button.width,
                visible: !!options.button.dotsLeft
            });
            this._dotsBtnRight = new DPaginationDotsButton({
                width: options.button.width,
                visible: !!options.button.dotsRight
            });
            this.addChild(this._dotsBtnLeft);
            this.addChild(this._dotsBtnRight);
        };
        DPaginationDynamicButtons.prototype.update = function (options) {
            var _this = this;
            if (options.start == null || options.end == null) {
                return;
            }
            var btnsCount = options.end - options.start + 1 > 0 ? options.end - options.start + 1 : 0;
            var pageButtons = this.children.slice(1, this.children.length - 1);
            if (pageButtons.length < btnsCount) {
                for (var i = pageButtons.length; i < btnsCount; i++) {
                    var btn = new DButton({
                        width: options.button.width
                    });
                    this.addChildAt(btn, this.children.length - 1);
                    btn.on("active", function (clickedBtn) {
                        _this.emit("active", clickedBtn);
                    });
                }
                // re-new "pageButtons" after add new buttons
                pageButtons = this.children.slice(1, this.children.length - 1);
            }
            else if (pageButtons.length > btnsCount) {
                for (var i = btnsCount; i < pageButtons.length; i++) {
                    pageButtons[i].hide();
                }
            }
            // update button text and active state
            for (var i = 0; i < btnsCount; i++) {
                var btn = pageButtons[i];
                btn.text = options.start + i + 1;
                btn.state.isActive = options.start + i === options.selected;
                if (btn.isHidden()) {
                    btn.show();
                }
            }
            // update visible state of dots buttons
            if (options.button.dotsLeft) {
                this._dotsBtnLeft.show();
            }
            else {
                this._dotsBtnLeft.hide();
            }
            if (options.button.dotsRight) {
                this._dotsBtnRight.show();
            }
            else {
                this._dotsBtnRight.hide();
            }
        };
        DPaginationDynamicButtons.prototype.getType = function () {
            return "DPaginationDynamicButtons";
        };
        return DPaginationDynamicButtons;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationNavigationButton = /** @class */ (function (_super) {
        __extends(DPaginationNavigationButton, _super);
        function DPaginationNavigationButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationNavigationButton.prototype.getType = function () {
            return "DPaginationNavigationButton";
        };
        return DPaginationNavigationButton;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPagination = /** @class */ (function (_super) {
        __extends(DPagination, _super);
        function DPagination() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPagination.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            this.DEFAULT_SELECTED = 0; // set default selected index page is page 0
            // get total pages
            this._total = options.total;
            // get selected page
            this._selected = (_a = options.selected) !== null && _a !== void 0 ? _a : this.DEFAULT_SELECTED;
            // get button options
            var button = options.button;
            this._buttonOptions = {
                first: !!(button === null || button === void 0 ? void 0 : button.first),
                last: !!(button === null || button === void 0 ? void 0 : button.last),
                width: button === null || button === void 0 ? void 0 : button.width
            };
            this.initButtons(this.getButtonWidth());
            this.listenButtonClicked();
            this.on("resize", function () {
                _this._numberPageButtonVisible = _this.toNumberVisible();
                _this.update();
            });
        };
        Object.defineProperty(DPagination.prototype, "selected", {
            /**
             * Get selected page.
             *
             * @returns index of selected page.
             */
            get: function () {
                return this._selected;
            },
            /**
             * Set selected page.
             *
             * @param selected page's index want to select.
             */
            set: function (selected) {
                if (selected < 0 || selected >= this._total || !Number.isInteger(selected)) {
                    selected = this.DEFAULT_SELECTED;
                }
                this._selected = selected;
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "total", {
            /**
             * Get total pages.
             *
             * @returns number of total pages.
             */
            get: function () {
                return this._total;
            },
            /**
             * Set total page.
             *
             * @param total number of page want to present in pagination.
             */
            set: function (total) {
                if (total >= 0 && Number.isInteger(total)) {
                    this._total = total;
                    this._numberPageButtonVisible = this.toNumberVisible();
                    this.selected = this._selected;
                    this._lastPageBtn.text = this._total;
                    this.update();
                }
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.initButtons = function (width) {
            this._previousBtn = new DPaginationNavigationButton({
                width: width,
                image: {
                    source: DThemes.getInstance().getAtlas().mappings
                        .pagination_navigation_button_previous
                }
            });
            this._nextBtn = new DPaginationNavigationButton({
                width: width,
                image: {
                    source: DThemes.getInstance().getAtlas().mappings.pagination_navigation_button_next
                }
            });
            this._goFirstBtn = new DPaginationNavigationButton({
                width: width,
                image: {
                    source: DThemes.getInstance().getAtlas().mappings
                        .pagination_navigation_button_go_first
                },
                visible: this._buttonOptions.first
            });
            this._goLastBtn = new DPaginationNavigationButton({
                width: width,
                image: {
                    source: DThemes.getInstance().getAtlas().mappings
                        .pagination_navigation_button_go_last
                },
                visible: this._buttonOptions.last
            });
            this._dynamicPageBtns = new DPaginationDynamicButtons({
                button: {
                    width: width
                }
            });
            this._firstPageBtn = new DButton({
                width: width,
                text: {
                    value: 1
                }
            });
            this._lastPageBtn = new DButton({
                width: width,
                text: {
                    value: this._total
                }
            });
            this.addChild(this._goFirstBtn);
            this.addChild(this._previousBtn);
            this.addChild(this._firstPageBtn);
            this.addChild(this._dynamicPageBtns);
            this.addChild(this._lastPageBtn);
            this.addChild(this._nextBtn);
            this.addChild(this._goLastBtn);
        };
        DPagination.prototype.listenButtonClicked = function () {
            var _this = this;
            this._firstPageBtn.on("active", function (btn) {
                _this.onClickPageButton(btn);
            });
            this._lastPageBtn.on("active", function (btn) {
                _this.onClickPageButton(btn);
            });
            this._dynamicPageBtns.on("active", function (btn) {
                _this.onClickPageButton(btn);
            });
            this._goFirstBtn.on("active", function (btn) {
                _this.selected = _this.DEFAULT_SELECTED;
            });
            this._goLastBtn.on("active", function (btn) {
                _this.selected = _this._total - 1;
            });
            this._nextBtn.on("active", function (btn) {
                if (_this.selected !== _this._total + 1) {
                    _this.selected = _this._selected + 1;
                }
            });
            this._previousBtn.on("active", function (btn) {
                if (_this._selected !== 0) {
                    _this.selected = _this._selected - 1;
                }
            });
        };
        DPagination.prototype.update = function () {
            var startDynamic;
            var endDynamic;
            var dotsLeft;
            var dotsRight;
            var numberButtonsInLeft = 0;
            var numberButtonsInRight = 0;
            this.updateStaticButtons();
            // Number displayed buttons from first button to selected button when select center button of all buttons.
            // Not including selected button.
            var numberButtonsFirstToCenter = Math.ceil((this._numberPageButtonVisible - 1) * 0.5);
            var numberButtonsCenterToEnd = Math.floor((this._numberPageButtonVisible - 1) * 0.5);
            if (this._selected < numberButtonsFirstToCenter) {
                numberButtonsInLeft = this._selected;
                numberButtonsInRight = this._numberPageButtonVisible - numberButtonsInLeft - 1;
            }
            else if (this._selected + numberButtonsCenterToEnd > this._total - 1) {
                numberButtonsInRight = this._total - 1 - this.selected;
                numberButtonsInLeft = this._numberPageButtonVisible - numberButtonsInRight - 1;
            }
            else {
                numberButtonsInLeft = numberButtonsFirstToCenter;
                numberButtonsInRight = numberButtonsCenterToEnd;
            }
            if (this._selected <= numberButtonsInLeft) {
                startDynamic = 1;
                dotsLeft = false;
            }
            else {
                startDynamic = this._selected - numberButtonsInLeft + 2;
                dotsLeft = true;
            }
            if (this._selected + numberButtonsInRight >= this._total - 1) {
                endDynamic = this._total - 2;
                dotsRight = false;
            }
            else {
                endDynamic = this._selected + numberButtonsInRight - 2;
                dotsRight = true;
            }
            this._dynamicPageBtns.update({
                start: startDynamic,
                end: endDynamic,
                selected: this._selected,
                button: {
                    width: this.getButtonWidth(),
                    dotsLeft: dotsLeft,
                    dotsRight: dotsRight
                }
            });
        };
        DPagination.prototype.updateStaticButtons = function () {
            if (this._total > 0) {
                this._firstPageBtn.show();
            }
            else {
                this._firstPageBtn.hide();
            }
            if (this._total > 1) {
                this._lastPageBtn.show();
            }
            else {
                this._lastPageBtn.hide();
            }
            var isFirst = this._selected === this.DEFAULT_SELECTED;
            var isLast = this._selected === this._total - 1 || this._total === 0;
            this._firstPageBtn.state.isActive = isFirst;
            this._lastPageBtn.state.isActive = isLast;
            this._goFirstBtn.state.isDisabled = isFirst;
            this._previousBtn.state.isDisabled = isFirst;
            this._nextBtn.state.isDisabled = isLast;
            this._goLastBtn.state.isDisabled = isLast;
        };
        DPagination.prototype.getButtonWidth = function () {
            return this._buttonOptions.width ? this._buttonOptions.width : this.theme.getButtonWidth();
        };
        DPagination.prototype.toNumberVisible = function () {
            var numberNavigationBtn = 2; // 2 buttons always displayed are "next" and "previous" button
            if (this._buttonOptions.first) {
                numberNavigationBtn++;
            }
            if (this._buttonOptions.last) {
                numberNavigationBtn++;
            }
            var widthOfNavigationBtns = numberNavigationBtn * (this.getButtonWidth() + this._margin.horizontal * 2);
            var widthOfPageBtns = this.width - widthOfNavigationBtns;
            var numberVisible = Math.floor(widthOfPageBtns / (this.getButtonWidth() + this._margin.horizontal * 2));
            /* set numberVisible is 5, if it less than 5
                 If total pages less than numberVisible, set numberVisible equal total pages
            **/
            return Math.min(this._total, Math.max(numberVisible, 5));
        };
        DPagination.prototype.onClickPageButton = function (btn) {
            var btnIndex = Number(btn.text) - 1;
            if (this._selected !== btnIndex) {
                this._selected = btnIndex;
                this.update();
            }
        };
        DPagination.prototype.getType = function () {
            return "DPagination";
        };
        return DPagination;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeRange = /** @class */ (function (_super) {
        __extends(DPickerDatetimeRange, _super);
        function DPickerDatetimeRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DPickerDatetimeRange;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeRange = /** @class */ (function (_super) {
        __extends(DPickerTimeRange, _super);
        function DPickerTimeRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DPickerTimeRange;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A multi-value selector class.
     */
    var DSelectMultiple = /** @class */ (function (_super) {
        __extends(DSelectMultiple, _super);
        function DSelectMultiple(options) {
            var _this = _super.call(this, options) || this;
            // Default values
            _this._values = [];
            var values = options === null || options === void 0 ? void 0 : options.values;
            if (values) {
                _this.values = values;
            }
            return _this;
        }
        DSelectMultiple.prototype.onMenuSelect = function (value, item, menu) {
            _super.prototype.onMenuSelect.call(this, value, item, menu);
            if (item instanceof DMenuItemCheck) {
                var oldValues = this._values;
                var newValues = [];
                var newItems = [];
                if (item.state.isActive) {
                    this.updateMenuItems(menu, oldValues, value, undefined, newValues, newItems);
                }
                else {
                    this.updateMenuItems(menu, oldValues, undefined, value, newValues, newItems);
                }
                this._values = newValues;
                this.text = newItems;
                this.onValueChange(newValues, oldValues, newItems);
            }
        };
        DSelectMultiple.prototype.onValueChange = function (newValues, oldValues, items) {
            this.emit("change", newValues, oldValues, items, this);
        };
        DSelectMultiple.prototype.start = function () {
            this.updateMenuItems(this.menu, this._values);
            _super.prototype.start.call(this);
        };
        Object.defineProperty(DSelectMultiple.prototype, "values", {
            /**
             * Returns a selected value or null.
             */
            get: function () {
                return this._values;
            },
            /**
             * Sets to the specified value.
             */
            set: function (values) {
                var oldValues = this._values;
                if (!this.isSameValues(values, oldValues)) {
                    var newValues = [];
                    var newItems = [];
                    this.updateMenuItems(this.menu, values, undefined, undefined, newValues, newItems);
                    this._values = newValues;
                    this.text = newItems;
                }
            },
            enumerable: false,
            configurable: true
        });
        DSelectMultiple.prototype.isSameValues = function (a, b) {
            if (a.length === b.length) {
                for (var i = 0, imax = a.length; i < imax; ++i) {
                    if (b.indexOf(a[i]) < 0) {
                        return false;
                    }
                }
            }
            return false;
        };
        DSelectMultiple.prototype.updateMenuItems = function (menu, oldValues, addedValue, removedValue, newValues, newItems) {
            var children = menu.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemMenu) {
                    this.updateMenuItems(child.menu, oldValues, addedValue, removedValue, newValues, newItems);
                }
                else if (child instanceof DMenuItemCheck) {
                    var childValue = child.value;
                    if (removedValue !== undefined && removedValue === childValue) {
                        child.state.isActive = false;
                    }
                    else if ((addedValue !== undefined && child.value === addedValue) ||
                        0 <= oldValues.indexOf(child.value)) {
                        if (newValues) {
                            newValues.push(child.value);
                        }
                        if (newItems) {
                            newItems.push(child);
                        }
                        child.state.isActive = true;
                    }
                    else {
                        child.state.isActive = false;
                    }
                }
            }
        };
        DSelectMultiple.prototype.getType = function () {
            return "DSelectMultiple";
        };
        return DSelectMultiple;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A selector class.
     */
    var DSelect = /** @class */ (function (_super) {
        __extends(DSelect, _super);
        function DSelect(options) {
            var _this = _super.call(this, options) || this;
            // Default value
            _this._value = null;
            var value = options === null || options === void 0 ? void 0 : options.value;
            if (value != null) {
                _this.value = value;
            }
            return _this;
        }
        DSelect.prototype.onMenuSelect = function (newValue, item, menu) {
            _super.prototype.onMenuSelect.call(this, newValue, item, menu);
            var oldValue = this._value;
            if (oldValue !== newValue) {
                this._value = newValue;
                this.text = item;
                this.onValueChange(newValue, oldValue, item);
            }
        };
        DSelect.prototype.onValueChange = function (newValue, oldValue, item) {
            this.emit("change", newValue, oldValue, item, this);
        };
        DSelect.prototype.findMenuItem = function (menu, value) {
            var children = menu.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemMenu) {
                    var result = this.findMenuItem(child.menu, value);
                    if (result != null) {
                        return result;
                    }
                }
                else if (child instanceof DMenuItem) {
                    if (child.value === value) {
                        return child;
                    }
                }
            }
            return null;
        };
        Object.defineProperty(DSelect.prototype, "value", {
            /**
             * Returns a selected value or null.
             */
            get: function () {
                return this._value;
            },
            /**
             * Sets to the specified value.
             */
            set: function (value) {
                if (this._value !== value) {
                    var item = this.findMenuItem(this.menu, value);
                    this._value = value;
                    this.text = item;
                }
            },
            enumerable: false,
            configurable: true
        });
        DSelect.prototype.getType = function () {
            return "DSelect";
        };
        return DSelect;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DShadowImpl = /** @class */ (function (_super) {
        __extends(DShadowImpl, _super);
        function DShadowImpl(texture, width, height, offsetX, offsetY) {
            var _this = _super.call(this, texture, width, height, width, height) || this;
            _this._offsetX = offsetX;
            _this._offsetY = offsetY;
            _this._shiftX = width * 0.5;
            _this._shiftY = height * 0.5;
            _this.interactive = false;
            _this.interactiveChildren = false;
            texture.on("update", function () {
                _this.onTextureUpdate();
            });
            return _this;
        }
        DShadowImpl.prototype.onTextureUpdate = function () {
            this.emit("update", this);
        };
        DShadowImpl.prototype.onReflow = function (base, width, height) {
            var sx = this._shiftX;
            var sy = this._shiftY;
            this.x = -sx + this._offsetX;
            this.y = -sy + this._offsetY;
            this.width = sx + width + sx;
            this.height = sy + height + sy;
        };
        return DShadowImpl;
    }(pixi_js.NineSlicePlane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderLabel = /** @class */ (function (_super) {
        __extends(DSliderLabel, _super);
        function DSliderLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderLabel.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
            this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : 0;
        };
        Object.defineProperty(DSliderLabel.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        DSliderLabel.prototype.getType = function () {
            return "DSliderLabel";
        };
        return DSliderLabel;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderThumb = /** @class */ (function (_super) {
        __extends(DSliderThumb, _super);
        function DSliderThumb() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderThumb.prototype.getType = function () {
            return "DSliderThumb";
        };
        return DSliderThumb;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderValue = /** @class */ (function (_super) {
        __extends(DSliderValue, _super);
        function DSliderValue() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderValue.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            this.state.isFocusable = false;
            this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : 0;
            this._rounder = this.toRounder(options);
        };
        DSliderValue.prototype.toRounder = function (options) {
            var _a;
            var rounder = options === null || options === void 0 ? void 0 : options.rounder;
            if (rounder) {
                return rounder;
            }
            var precision = (_a = options === null || options === void 0 ? void 0 : options.precision) !== null && _a !== void 0 ? _a : this.theme.getPrecision();
            return function (value) {
                var base = Math.pow(10, precision);
                return Math.round(value * base) / base;
            };
        };
        Object.defineProperty(DSliderValue.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSliderValue.prototype, "rounder", {
            get: function () {
                return this._rounder;
            },
            enumerable: false,
            configurable: true
        });
        DSliderValue.prototype.getType = function () {
            return "DSliderValue";
        };
        return DSliderValue;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A slider class.
     */
    var DSlider = /** @class */ (function (_super) {
        __extends(DSlider, _super);
        function DSlider() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSlider.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._ratioValue = 0;
            this._track = this.newTrack(options);
            this.addChild(this._track);
            this._trackSelected = this.newTrackSelected(options);
            this._trackSelected.state.isActive = true;
            this.addChild(this._trackSelected);
            this._thumb = this.newThumb(options);
            this.addChild(this._thumb);
            this._min = this.newLabelMin(options);
            this.addChild(this._min);
            this._max = this.newLabelMax(options);
            this.addChild(this._max);
            this._value = this.newValue(options);
            this.addChild(this._value);
            // Event listeners
            this._track.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = _this.state.inEnabled;
                _this.onTrackDown(e.data.global);
            });
            this._trackSelected.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = _this.state.inEnabled;
                _this.onTrackSelectedDown(e.data.global);
            });
            this._onTrackUpBound = function (e) {
                _this.onTrackUpBound(e);
                _this._value.visible = false;
            };
            this._onTrackSelectedUpBound = function (e) {
                _this.onTrackSelectedUpBound(e);
                _this._value.visible = false;
            };
            this._thumb.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = true;
                _this.onThumbDown(e);
            });
            this._onThumbMoveBound = function (e) {
                _this.onThumbMove(e);
            };
            this._onThumbUpBound = function (e) {
                _this.onThumbUp(e);
                _this._value.visible = false;
            };
            //
            this.onValuesChange();
        };
        DSlider.prototype.newThumb = function (options) {
            return new DSliderThumb(options === null || options === void 0 ? void 0 : options.thumb);
        };
        DSlider.prototype.newValue = function (options) {
            return new DSliderValue(this.toValueOptions(options === null || options === void 0 ? void 0 : options.value));
        };
        DSlider.prototype.toValueOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            var text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = options.value;
            }
            if (options.visible == null) {
                options.visible = false;
            }
            return options;
        };
        DSlider.prototype.newLabelMin = function (options) {
            return new DSliderLabel(this.toLabelMinOptions(options === null || options === void 0 ? void 0 : options.min));
        };
        DSlider.prototype.toLabelMinOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            var text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = "" + options.value;
            }
            return options;
        };
        DSlider.prototype.newLabelMax = function (options) {
            return new DSliderLabel(this.toLabelMaxOptions(options === null || options === void 0 ? void 0 : options.max));
        };
        DSlider.prototype.toLabelMaxOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 1;
            }
            var text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = "" + options.value;
            }
            return options;
        };
        DSlider.prototype.getValueMargin = function () {
            return 14;
        };
        DSlider.prototype.onTrackDown = function (global) {
            if (this.state.inDisabled) {
                return;
            }
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                interactionManager.on(UtilPointerEvent.up, this._onTrackUpBound);
            }
            this.onPick(global);
        };
        DSlider.prototype.onTrackSelectedDown = function (global) {
            if (this.state.inDisabled) {
                return;
            }
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                interactionManager.on(UtilPointerEvent.up, this._onTrackSelectedUpBound);
            }
            this.onPick(global);
        };
        DSlider.prototype.onTrackUpBound = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                interactionManager.off(UtilPointerEvent.up, this._onTrackUpBound);
            }
        };
        DSlider.prototype.onTrackSelectedUpBound = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                interactionManager.off(UtilPointerEvent.up, this._onTrackSelectedUpBound);
            }
        };
        DSlider.prototype.onThumbMove = function (e) {
            if (this.state.inDisabled) {
                return;
            }
            this.onPick(e.data.global);
        };
        DSlider.prototype.onThumbDown = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                interactionManager.on(UtilPointerEvent.move, this._onThumbMoveBound);
                interactionManager.on(UtilPointerEvent.up, this._onThumbUpBound);
            }
        };
        DSlider.prototype.onThumbUp = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                interactionManager.off(UtilPointerEvent.move, this._onThumbMoveBound);
                interactionManager.off(UtilPointerEvent.up, this._onThumbUpBound);
            }
        };
        DSlider.prototype.updateValue = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value;
            var newValue = value.rounder(min + this._ratioValue * (max - min));
            var oldValue = value.value;
            if (newValue !== oldValue) {
                value.value = newValue;
                value.text = value.value;
                this.emit("change", newValue, oldValue, this);
            }
        };
        DSlider.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.onValuesChange();
        };
        Object.defineProperty(DSlider.prototype, "value", {
            /**
             * Returns a current value.
             */
            get: function () {
                return this._value.value;
            },
            /**
             * Sets a current value.
             */
            set: function (value) {
                value = Math.max(this._min.value, Math.min(this._max.value, value));
                // Adjust if value is new
                if (this._value.value !== value) {
                    this._value.value = value;
                    this.onValuesChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSlider.prototype, "min", {
            /**
             * Returns a minimum value.
             */
            get: function () {
                return this._min.value;
            },
            /**
             * Sets a minimum value.
             */
            set: function (newMin) {
                var min = this._min;
                newMin = Math.min(this._max.value, newMin);
                if (min.value !== newMin) {
                    var value = this._value;
                    min.text = min.value = newMin;
                    value.value = Math.max(newMin, value.value);
                    this.onValuesChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSlider.prototype, "max", {
            /**
             * Returns a maximum value.
             */
            get: function () {
                return this._max.value;
            },
            /**
             * Sets a maximum value.
             */
            set: function (newMax) {
                var max = this._max;
                newMax = Math.max(this._min.value, newMax);
                if (max.value !== newMax) {
                    var value = this._value;
                    max.text = max.value = newMax;
                    value.value = Math.min(newMax, value.value);
                    this.onValuesChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DSlider.prototype.getType = function () {
            return "DSlider";
        };
        return DSlider;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrack = /** @class */ (function (_super) {
        __extends(DSliderTrack, _super);
        function DSliderTrack() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrack.prototype.getType = function () {
            return "DSliderTrack";
        };
        return DSliderTrack;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrackHorizontal = /** @class */ (function (_super) {
        __extends(DSliderTrackHorizontal, _super);
        function DSliderTrackHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrackHorizontal.prototype.getType = function () {
            return "DSliderTrackHorizontal";
        };
        return DSliderTrackHorizontal;
    }(DSliderTrack));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderHorizontal = /** @class */ (function (_super) {
        __extends(DSliderHorizontal, _super);
        function DSliderHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderHorizontal.prototype.newTrack = function (options) {
            return new DSliderTrackHorizontal(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderHorizontal.prototype.newTrackSelected = function (options) {
            return new DSliderTrackHorizontal(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderHorizontal.prototype.toValueOptions = function (options) {
            var _this = this;
            options = _super.prototype.toValueOptions.call(this, options);
            if (options.y == null) {
                options.y = function (p, s) { return p * 0.5 - s - _this.getValueMargin(); };
            }
            return options;
        };
        DSliderHorizontal.prototype.toLabelMinOptions = function (options) {
            options = _super.prototype.toLabelMinOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s * 0.5; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s; };
            }
            return options;
        };
        DSliderHorizontal.prototype.toLabelMaxOptions = function (options) {
            options = _super.prototype.toLabelMaxOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return p - s * 0.5; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s; };
            }
            return options;
        };
        DSliderHorizontal.prototype.onPick = function (global) {
            var point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(this._track.width, point.x));
            this._ratioValue = x / this._track.width;
            this.moveThumbPosition(x);
        };
        DSliderHorizontal.prototype.onValuesChange = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            var x = this._ratioValue * this._track.width;
            this.moveThumbPosition(x);
        };
        DSliderHorizontal.prototype.moveThumbPosition = function (x) {
            var thumb = this._thumb;
            thumb.x = x - thumb.width * 0.5;
            this._trackSelected.width = x;
            var value = this._value;
            value.x = x - value.width * 0.5;
            this.updateValue();
        };
        DSliderHorizontal.prototype.toThumbCoordinate = function (x) {
            return x - this._thumb.width * 0.5;
        };
        DSliderHorizontal.prototype.getType = function () {
            return "DSliderHorizontal";
        };
        return DSliderHorizontal;
    }(DSlider));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrackVertical = /** @class */ (function (_super) {
        __extends(DSliderTrackVertical, _super);
        function DSliderTrackVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrackVertical.prototype.getType = function () {
            return "DSliderTrackVertical";
        };
        return DSliderTrackVertical;
    }(DSliderTrack));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderVertical = /** @class */ (function (_super) {
        __extends(DSliderVertical, _super);
        function DSliderVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderVertical.prototype.newTrack = function (options) {
            return new DSliderTrackVertical(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderVertical.prototype.newTrackSelected = function (options) {
            return new DSliderTrackVertical(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderVertical.prototype.toLabelMinOptions = function (options) {
            options = _super.prototype.toLabelMinOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return p - s * 0.5; };
            }
            var text = options.text || {};
            options.text = text;
            var textAlign = text.align || {};
            text.align = textAlign;
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        };
        DSliderVertical.prototype.toLabelMaxOptions = function (options) {
            options = _super.prototype.toLabelMaxOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s * 0.5; };
            }
            var text = options.text || {};
            options.text = text;
            var textAlign = text.align || {};
            text.align = textAlign;
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        };
        DSliderVertical.prototype.onPick = function (global) {
            var point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            var height = this.height;
            var y = Math.max(0, Math.min(height, point.y));
            this._ratioValue = (height - y) / height;
            this.moveThumbPosition(y);
        };
        DSliderVertical.prototype.onValuesChange = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            var y = this.height * (1 - this._ratioValue);
            this.moveThumbPosition(y);
        };
        DSliderVertical.prototype.moveThumbPosition = function (y) {
            var thumb = this._thumb;
            thumb.y = y - thumb.height * 0.5;
            var trackSelected = this._trackSelected;
            trackSelected.y = y;
            trackSelected.height = this.height - y;
            var value = this._value;
            value.y = y - value.height - this.getValueMargin();
            this.updateValue();
        };
        DSliderVertical.prototype.getType = function () {
            return "DSliderVertical";
        };
        return DSliderVertical;
    }(DSlider));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCells = /** @class */ (function () {
        function DTableBodyCells() {
        }
        DTableBodyCells.setReadOnly = function (target, row, columnIndex, column) {
            target.state.isReadOnly = this.toReadOnly(row, columnIndex, column);
        };
        DTableBodyCells.setRenderable = function (target, row, columnIndex, column) {
            var renderable = this.toRenderable(row, columnIndex, column);
            target.renderable = renderable;
            target.state.isDisabled = !renderable;
        };
        DTableBodyCells.toReadOnly = function (row, columnIndex, column) {
            var enable = column.editing.enable;
            if (enable === true) {
                return false;
            }
            else if (enable === false) {
                return true;
            }
            else {
                return !enable(row, columnIndex);
            }
        };
        DTableBodyCells.toRenderable = function (row, columnIndex, column) {
            var renderable = column.renderable;
            if (renderable === true) {
                return true;
            }
            else if (renderable === false) {
                return false;
            }
            else {
                return renderable(row, columnIndex);
            }
        };
        return DTableBodyCells;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectDialog = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectDialog, _super);
        function DTableBodyCellSelectDialog(columnIndex, column, onChange, options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            _this._isSyncEnabled = (_a = options === null || options === void 0 ? void 0 : options.sync) !== null && _a !== void 0 ? _a : _this.theme.isSyncEnabled();
            return _this;
        }
        DTableBodyCellSelectDialog.prototype.onActivate = function (e) {
            var _this = this;
            var _a;
            _super.prototype.onActivate.call(this, e);
            var selecting = this._column.selecting;
            var dialog = selecting.dialog;
            if (dialog) {
                var oldValue_1 = (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : null;
                selecting.setter(dialog, oldValue_1);
                dialog.open().then(function () {
                    var newValue = selecting.getter(dialog);
                    if (_this._isSyncEnabled) {
                        if (newValue !== oldValue_1) {
                            _this.text = newValue;
                            _this.onValueChange(newValue, oldValue_1);
                        }
                    }
                    else {
                        _this.onValueChange(newValue, null);
                    }
                });
            }
        };
        DTableBodyCellSelectDialog.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "value", {
            get: function () {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed !== undefined) {
                    return textValueComputed;
                }
                return null;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectDialog.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (forcibly) {
                this._textValue = value;
                this._textValueComputed = value;
                this.onTextChange();
                this.createOrUpdateText();
            }
            else {
                this.text = value;
            }
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellSelectDialog.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectDialog.prototype.getType = function () {
            return "DTableBodyCellSelectDialog";
        };
        return DTableBodyCellSelectDialog;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionDialog = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionDialog, _super);
        function DTableBodyCellActionDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellActionDialog.prototype.getType = function () {
            return "DTableBodyCellActionDialog";
        };
        return DTableBodyCellActionDialog;
    }(DTableBodyCellSelectDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionMenu = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionMenu, _super);
        function DTableBodyCellActionMenu(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellActionMenu.prototype.onMenuSelect = function (selected, item, menu) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, selected);
                _super.prototype.onMenuSelect.call(this, selected, item, menu);
                this._onChange(selected, null, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellActionMenu.prototype.onKeyDownArrowDown = function (e) {
            return false;
        };
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellActionMenu.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellActionMenu.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellActionMenu.prototype.getType = function () {
            return "DTableBodyCellActionMenu";
        };
        return DTableBodyCellActionMenu;
    }(DDropdown));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectPromise = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectPromise, _super);
        function DTableBodyCellSelectPromise(columnIndex, column, onChange, options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            _this._isSyncEnabled = (_a = options === null || options === void 0 ? void 0 : options.sync) !== null && _a !== void 0 ? _a : _this.theme.isSyncEnabled();
            return _this;
        }
        DTableBodyCellSelectPromise.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            var selecting = this._column.selecting;
            var promise = selecting.promise;
            if (promise) {
                promise().then(function (newValue) {
                    var _a;
                    if (_this._isSyncEnabled) {
                        var oldValue = (_a = _this._textValueComputed) !== null && _a !== void 0 ? _a : null;
                        if (newValue !== oldValue) {
                            _this.text = newValue;
                            _this.onValueChange(newValue, oldValue);
                        }
                    }
                    else {
                        _this.onValueChange(newValue, null);
                    }
                });
            }
        };
        DTableBodyCellSelectPromise.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "value", {
            get: function () {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed !== undefined) {
                    return textValueComputed;
                }
                return null;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectPromise.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (forcibly) {
                this._textValue = value;
                this._textValueComputed = value;
                this.onTextChange();
                this.createOrUpdateText();
            }
            else {
                this.text = value;
            }
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellSelectPromise.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectPromise.prototype.getType = function () {
            return "DTableBodyCellSelectPromise";
        };
        return DTableBodyCellSelectPromise;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionPromise = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionPromise, _super);
        function DTableBodyCellActionPromise() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellActionPromise.prototype.getType = function () {
            return "DTableBodyCellActionPromise";
        };
        return DTableBodyCellActionPromise;
    }(DTableBodyCellSelectPromise));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellText = /** @class */ (function (_super) {
        __extends(DTableBodyCellText, _super);
        function DTableBodyCellText(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        Object.defineProperty(DTableBodyCellText.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellText.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellText.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellText.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellText.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellText.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellText.prototype.getType = function () {
            return "DTableBodyCellText";
        };
        return DTableBodyCellText;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellButton = /** @class */ (function (_super) {
        __extends(DTableBodyCellButton, _super);
        function DTableBodyCellButton(columnIndex, column, onChange, options) {
            var _a;
            var _this = _super.call(this, columnIndex, column, onChange, options) || this;
            var when = toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : DButtonBaseWhen.CLICKED, DButtonBaseWhen);
            _this._when = when;
            _this.initOnClick(when, _this.theme, options);
            return _this;
        }
        DTableBodyCellButton.prototype.initOnClick = function (when, theme, options) {
            var _this = this;
            UtilPointerEvent.onClick(this, function (e) {
                if (when === DButtonBaseWhen.CLICKED) {
                    _this.onClick(e);
                }
            });
        };
        DTableBodyCellButton.prototype.onClick = function (e) {
            if (this.state.isActionable) {
                this.onActivate(e);
            }
        };
        DTableBodyCellButton.prototype.onDblClick = function (e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED) {
                this.onClick(e);
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DTableBodyCellButton.prototype.onActivate = function (e) {
            this.emit("active", this);
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this.emit("change", null, null, this);
                this._onChange(null, null, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellButton.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        };
        DTableBodyCellButton.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.onActivate(e);
                }
                this.state.isPressed = false;
            }
        };
        DTableBodyCellButton.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTableBodyCellButton.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTableBodyCellButton.prototype.getType = function () {
            return "DTableBodyCellButton";
        };
        return DTableBodyCellButton;
    }(DTableBodyCellText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableColumnType;
    (function (DTableColumnType) {
        DTableColumnType[DTableColumnType["INDEX"] = 0] = "INDEX";
        DTableColumnType[DTableColumnType["TEXT"] = 1] = "TEXT";
        DTableColumnType[DTableColumnType["INTEGER"] = 2] = "INTEGER";
        DTableColumnType[DTableColumnType["REAL"] = 3] = "REAL";
        DTableColumnType[DTableColumnType["CHECK"] = 4] = "CHECK";
        DTableColumnType[DTableColumnType["CHECK_SINGLE"] = 5] = "CHECK_SINGLE";
        DTableColumnType[DTableColumnType["COLOR"] = 6] = "COLOR";
        DTableColumnType[DTableColumnType["BUTTON"] = 7] = "BUTTON";
        DTableColumnType[DTableColumnType["SELECT"] = 8] = "SELECT";
        DTableColumnType[DTableColumnType["DATE"] = 9] = "DATE";
        DTableColumnType[DTableColumnType["DATETIME"] = 10] = "DATETIME";
        DTableColumnType[DTableColumnType["TIME"] = 11] = "TIME";
        DTableColumnType[DTableColumnType["ACTION"] = 12] = "ACTION";
        DTableColumnType[DTableColumnType["LINK"] = 13] = "LINK";
        DTableColumnType[DTableColumnType["TREE"] = 14] = "TREE";
    })(DTableColumnType || (DTableColumnType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellCheck = /** @class */ (function (_super) {
        __extends(DTableBodyCellCheck, _super);
        function DTableBodyCellCheck(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellCheck.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.onValueChange(true, false);
        };
        DTableBodyCellCheck.prototype.onInactivate = function (e) {
            _super.prototype.onInactivate.call(this, e);
            this.onValueChange(false, true);
        };
        DTableBodyCellCheck.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                var onChange = this._onChange;
                onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
                if (newValue && column.type === DTableColumnType.CHECK_SINGLE) {
                    this.onChangeSingle(rowIndex, columnIndex, column, onChange);
                }
            }
        };
        DTableBodyCellCheck.prototype.onChangeSingle = function (rowIndex, columnIndex, column, onChange) {
            var _this = this;
            var tableBodyRow = this.parent;
            if (tableBodyRow) {
                var tableBody = tableBodyRow.parent;
                if (tableBody) {
                    var isChanged_1 = false;
                    var getter_1 = column.getter;
                    var setter_1 = column.setter;
                    var data = tableBody.data;
                    data.each(function (row, index) {
                        if (rowIndex !== index && getter_1(row, columnIndex)) {
                            setter_1(row, columnIndex, false);
                            isChanged_1 = true;
                            onChange(false, true, row, index, columnIndex, _this);
                            return false;
                        }
                        return true;
                    });
                    if (isChanged_1) {
                        tableBody.update(true);
                    }
                }
            }
        };
        Object.defineProperty(DTableBodyCellCheck.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellCheck.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellCheck.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellCheck.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellCheck.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.state.isActive = !!value;
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellCheck.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellCheck.prototype.getType = function () {
            return "DTableBodyCellCheck";
        };
        return DTableBodyCellCheck;
    }(DButtonCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellColor = /** @class */ (function (_super) {
        __extends(DTableBodyCellColor, _super);
        function DTableBodyCellColor(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellColor.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellColor.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellColor.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellColor.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellColor.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellColor.prototype.set = function (newValue, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            var value = this._value;
            if (isNumber(newValue)) {
                value.color = newValue;
                value.alpha = 1;
            }
            else if (isString(newValue)) {
                var parsed = Number(newValue);
                value.color = parsed === parsed ? parsed : 0xffffff;
                value.alpha = 1;
            }
            else if (newValue != null) {
                var color = newValue.color;
                var alpha = newValue.alpha;
                value.color = isNumber(color) ? color : 0xffffff;
                value.alpha = isNumber(alpha) ? alpha : 1;
            }
            else {
                value.color = 0xffffff;
                value.alpha = 1;
            }
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellColor.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellColor.prototype.getType = function () {
            return "DTableBodyCellColor";
        };
        return DTableBodyCellColor;
    }(DButtonColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellDate = /** @class */ (function (_super) {
        __extends(DTableBodyCellDate, _super);
        function DTableBodyCellDate(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellDate.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this._textValueComputed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open().then(function () {
                var newValue = dialog.new;
                var oldValue = dialog.current;
                _this.text = new Date(newValue.getTime());
                var row = _this._row;
                if (row !== undefined) {
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._column.setter(row, columnIndex, newValue);
                    _this.emit("change", newValue, oldValue, _this);
                    _this._onChange(newValue, oldValue, row, rowIndex, columnIndex, _this);
                }
            });
        };
        Object.defineProperty(DTableBodyCellDate.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = new DDialogDate(options);
                    }
                    else {
                        dialog = DDialogDates.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellDate.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this._textValue = value;
                    this._textValueComputed = value;
                    this.onTextChange();
                    this.createOrUpdateText();
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed === undefined) {
                    this.text = new Date(value);
                }
                else if (textValueComputed.getTime() !== value) {
                    textValueComputed.setTime(value);
                    this.onTextChange();
                    this.createOrUpdateText();
                }
            }
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellDate.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellDate.prototype.getType = function () {
            return "DTableBodyCellDate";
        };
        return DTableBodyCellDate;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellDatetime = /** @class */ (function (_super) {
        __extends(DTableBodyCellDatetime, _super);
        function DTableBodyCellDatetime(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellDatetime.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this._textValueComputed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open().then(function () {
                var newValue = dialog.new;
                var oldValue = dialog.current;
                _this.text = new Date(newValue.getTime());
                var row = _this._row;
                if (row !== undefined) {
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._column.setter(row, columnIndex, newValue);
                    _this.emit("change", newValue, oldValue, _this);
                    _this._onChange(newValue, oldValue, row, rowIndex, columnIndex, _this);
                }
            });
        };
        DTableBodyCellDatetime.prototype.getDatetimeMask = function () {
            var _a, _b;
            var result = this._datetimeMask;
            if (result == null) {
                result = DPickerDatetimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        };
        Object.defineProperty(DTableBodyCellDatetime.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = new DDialogDatetime(options);
                    }
                    else {
                        dialog = DDialogDatetimes.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellDatetime.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this._textValue = value;
                    this._textValueComputed = value;
                    this.onTextChange();
                    this.createOrUpdateText();
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed === undefined) {
                    this.text = new Date(value);
                }
                else if (textValueComputed.getTime() !== value) {
                    textValueComputed.setTime(value);
                    this.onTextChange();
                    this.createOrUpdateText();
                }
            }
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellDatetime.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellDatetime.prototype.getType = function () {
            return "DTableBodyCellDatetime";
        };
        return DTableBodyCellDatetime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellIndex = /** @class */ (function (_super) {
        __extends(DTableBodyCellIndex, _super);
        function DTableBodyCellIndex(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        Object.defineProperty(DTableBodyCellIndex.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellIndex.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellIndex.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellIndex.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellIndex.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = rowIndex;
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellIndex.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellIndex.prototype.getType = function () {
            return "DTableBodyCellIndex";
        };
        return DTableBodyCellIndex;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputInteger = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputInteger, _super);
        function DTableBodyCellInputInteger(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputInteger.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputInteger.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = Number(value);
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellInputInteger.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputInteger.prototype.getType = function () {
            return "DTableBodyCellInputInteger";
        };
        return DTableBodyCellInputInteger;
    }(DInputInteger));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputReal = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputReal, _super);
        function DTableBodyCellInputReal(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputReal.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputReal.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputReal.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputReal.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputReal.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputReal.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = Number(value);
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellInputReal.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputReal.prototype.getType = function () {
            return "DTableBodyCellInputReal";
        };
        return DTableBodyCellInputReal;
    }(DInputReal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputText = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputText, _super);
        function DTableBodyCellInputText(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputText.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputText.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputText.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputText.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputText.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputText.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = String(value);
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellInputText.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputText.prototype.getType = function () {
            return "DTableBodyCellInputText";
        };
        return DTableBodyCellInputText;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTreeInput = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTreeInput, _super);
        function DTableBodyCellInputTreeInput(options) {
            var _this = _super.call(this, options) || this;
            _this._padding = new DBasePaddingAdjustable(_this._padding);
            return _this;
        }
        Object.defineProperty(DTableBodyCellInputTreeInput.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputTreeInput.prototype.getType = function () {
            return "DTableBodyCellInputTreeInput";
        };
        return DTableBodyCellInputTreeInput;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTreeMarker = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTreeMarker, _super);
        function DTableBodyCellInputTreeMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellInputTreeMarker.prototype.getType = function () {
            return "DTableBodyCellInputTreeMarker";
        };
        return DTableBodyCellInputTreeMarker;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTable} states.
     */
    var DTableState = {
        /**
         * Start cells in rows.
         */
        START: "START",
        /**
         * End cells in rows.
         */
        END: "END",
        /**
         * Cells of frozen columns.
         */
        FROZEN: "FROZEN",
        /**
         * Cells of a right-most frozen column.
         */
        FROZEN_END: "FROZEN_END",
        /**
         * Header cells of sortable columns.
         */
        SORTABLE: "SORTABLE",
        /**
         * Header cells of columns sorted in the ascending order.
         */
        SORTED_ASCENDING: "SORTED_ASCENDING",
        /**
         * Header cells of columns sorted in the descending order.
         */
        SORTED_DESCENDING: "SORTED_DESCENDING",
        /**
         * Tree cells with child cells.
         */
        HAS_CHILDREN: "HAS_CHILDREN",
        /**
         * Tree cells opened.
         */
        OPENED: "OPENED",
        /**
         * Header cells of checkable columns.
         */
        CHECKABLE: "CHECKABLE",
        /**
         * Selectable row
         */
        SELECTABLE: "SELECTABLE"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toBaseOptions = function (options) {
        if (options != null) {
            return {
                weight: options.weight,
                width: options.width
            };
        }
        return undefined;
    };
    var DTableBodyCellInputTree = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTree, _super);
        function DTableBodyCellInputTree(columnIndex, column, onChange, options) {
            var _this = _super.call(this, toBaseOptions(options)) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            // Input
            var input = _this.newInput(options);
            _this._input = input;
            _this.addChild(input);
            // Marker
            var marker = _this.newMarker(options);
            _this._marker = marker;
            _this.addChild(marker);
            _this.state.isFocusable = false;
            _this.state.isFocusReverse = true;
            return _this;
        }
        DTableBodyCellInputTree.prototype.newInput = function (options) {
            return new DTableBodyCellInputTreeInput(this.toInputOptions(options));
        };
        DTableBodyCellInputTree.prototype.toInputOptions = function (options) {
            var _this = this;
            return {
                weight: 1,
                text: options === null || options === void 0 ? void 0 : options.text,
                editing: options === null || options === void 0 ? void 0 : options.editing,
                when: options === null || options === void 0 ? void 0 : options.when,
                cursor: options === null || options === void 0 ? void 0 : options.cursor,
                on: {
                    change: function (newValue, oldValue) {
                        _this.onInputChange(newValue, oldValue);
                    }
                }
            };
        };
        DTableBodyCellInputTree.prototype.onInputChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellInputTree.prototype.newMarker = function (options) {
            var _this = this;
            return new DTableBodyCellInputTreeMarker({
                visible: false,
                on: {
                    active: function () {
                        _this.onMarkerActive();
                    }
                }
            });
        };
        DTableBodyCellInputTree.prototype.onMarkerActive = function () {
            if (this._marker.state.is(DTableState.HAS_CHILDREN)) {
                var row = this.parent;
                if (row) {
                    var body = row.parent;
                    if (body) {
                        var data = body.data;
                        if (data && data.toggle) {
                            data.toggle(this._row);
                            this.emit("cellchange", null, null, this._row, this._rowIndex, this._columnIndex, this);
                        }
                    }
                }
            }
        };
        Object.defineProperty(DTableBodyCellInputTree.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTree.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTree.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTree.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputTree.prototype.onRowSelect = function (e, local) {
            if (local.x <= this.position.x + this._input.padding.getLeft()) {
                return true;
            }
            return false;
        };
        DTableBodyCellInputTree.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            var input = this._input;
            input.visible = true;
            input.text = String(value);
            var marker = this._marker;
            if (isNumber(supplimental)) {
                var isOpened = !!(supplimental & 0x1);
                var hasChildren = !!(supplimental & 0x2);
                var level = supplimental >> 2;
                var markerState = marker.state;
                markerState.lock();
                markerState.set(DTableState.HAS_CHILDREN, hasChildren);
                markerState.set(DBaseState.DISABLED, !hasChildren);
                markerState.set(DTableState.OPENED, isOpened);
                markerState.unlock();
                var padding = this.theme.getLevelPadding(level);
                marker.width = padding;
                if (hasChildren) {
                    marker.show();
                }
                else {
                    marker.hide();
                }
                input.padding.adjLeft(padding);
            }
            else {
                marker.state.removeAll(DTableState.OPENED, DTableState.HAS_CHILDREN);
                marker.hide();
                input.padding.adjLeft(0);
            }
            var column = this._column;
            DTableBodyCells.setReadOnly(this._input, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellInputTree.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
            this._input.visible = false;
            this._marker.hide();
        };
        DTableBodyCellInputTree.prototype.getType = function () {
            return "DTableBodyCellInputTree";
        };
        return DTableBodyCellInputTree;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLinkOptions = function (cell, options) {
        if (options) {
            return {
                url: toUrl(cell, options.url),
                target: options.target,
                checker: toChecker$1(cell, options.checker),
                menu: options.menu
            };
        }
        return undefined;
    };
    var toUrl = function (cell, url) {
        if (isString(url) || url == null) {
            return url;
        }
        else {
            return function () {
                var row = cell.row;
                if (row !== undefined) {
                    return url(row, cell.rowIndex, cell.columnIndex, cell);
                }
                return null;
            };
        }
    };
    var toChecker$1 = function (cell, checker) {
        if (checker != null) {
            return function () {
                var row = cell.row;
                if (row !== undefined) {
                    return checker(row, cell.rowIndex, cell.columnIndex, cell);
                }
                return false;
            };
        }
        return undefined;
    };
    var DTableBodyCellLink = /** @class */ (function (_super) {
        __extends(DTableBodyCellLink, _super);
        function DTableBodyCellLink(columnIndex, column, onChange, options) {
            var _a;
            return _super.call(this, columnIndex, column, onChange, DLinks.toStateOptions((_a = options === null || options === void 0 ? void 0 : options.link) === null || _a === void 0 ? void 0 : _a.target, options)) || this;
        }
        DTableBodyCellLink.prototype.initOnClick = function (when, theme, options) {
            var _this = this;
            this.link.add(this, function (e) {
                if (when === DButtonBaseWhen.CLICKED) {
                    _this.onClick(e);
                }
            });
        };
        Object.defineProperty(DTableBodyCellLink.prototype, "link", {
            get: function () {
                var _a;
                var result = this._link;
                if (result == null) {
                    result = new DLink(this.theme, toLinkOptions(this, (_a = this._options) === null || _a === void 0 ? void 0 : _a.link));
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellLink.prototype.getType = function () {
            return "DTableBodyCellLink";
        };
        DTableBodyCellLink.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.link.open(e);
        };
        DTableBodyCellLink.prototype.open = function (inNewWindow) {
            this.link.open(inNewWindow);
        };
        return DTableBodyCellLink;
    }(DTableBodyCellButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectMenu = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectMenu, _super);
        function DTableBodyCellSelectMenu(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellSelectMenu.prototype.onValueChange = function (newValue, oldValue, item) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue, item);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellSelectMenu.prototype.onKeyDownArrowDown = function (e) {
            return false;
        };
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectMenu.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.value = value;
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellSelectMenu.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectMenu.prototype.getType = function () {
            return "DTableBodyCellSelectMenu";
        };
        return DTableBodyCellSelectMenu;
    }(DSelect));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectMultiple = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectMultiple, _super);
        function DTableBodyCellSelectMultiple(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellSelectMultiple.prototype.onValueChange = function (newValues, oldValues, items) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValues);
                _super.prototype.onValueChange.call(this, newValues, oldValues, items);
                this._onChange(newValues, oldValues, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellSelectMultiple.prototype.onKeyDownArrowDown = function (e) {
            return false;
        };
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectMultiple.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.values = value;
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellSelectMultiple.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectMultiple.prototype.getType = function () {
            return "DTableBodyCellSelectMultiple";
        };
        return DTableBodyCellSelectMultiple;
    }(DSelectMultiple));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellTime = /** @class */ (function (_super) {
        __extends(DTableBodyCellTime, _super);
        function DTableBodyCellTime(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellTime.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this._textValueComputed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.open().then(function () {
                var newValue = dialog.new;
                var oldValue = dialog.current;
                _this.text = new Date(newValue.getTime());
                var row = _this._row;
                if (row !== undefined) {
                    var rowIndex = _this._rowIndex;
                    var columnIndex = _this._columnIndex;
                    _this._column.setter(row, columnIndex, newValue);
                    _this.emit("change", newValue, oldValue, _this);
                    _this._onChange(newValue, oldValue, row, rowIndex, columnIndex, _this);
                }
            });
        };
        DTableBodyCellTime.prototype.getDatetimeMask = function () {
            var _a, _b;
            var result = this._datetimeMask;
            if (result == null) {
                result = DPickerTimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        };
        Object.defineProperty(DTableBodyCellTime.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = new DDialogTime(options);
                    }
                    else {
                        dialog = DDialogTimes.getInstance();
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellTime.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this._textValue = value;
                    this._textValueComputed = value;
                    this.onTextChange();
                    this.createOrUpdateText();
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed == null) {
                    this.text = new Date(value);
                }
                else if (textValueComputed.getTime() !== value) {
                    textValueComputed.setTime(value);
                    this.onTextChange();
                    this.createOrUpdateText();
                }
            }
            var column = this._column;
            DTableBodyCells.setReadOnly(this, row, columnIndex, column);
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
        };
        DTableBodyCellTime.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellTime.prototype.getType = function () {
            return "DTableBodyCellTime";
        };
        return DTableBodyCellTime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellTree = /** @class */ (function (_super) {
        __extends(DTableBodyCellTree, _super);
        function DTableBodyCellTree(columnIndex, column, onChange, options) {
            var _a;
            var _this = _super.call(this, columnIndex, column, onChange, DLinks.toStateOptions((_a = options === null || options === void 0 ? void 0 : options.link) === null || _a === void 0 ? void 0 : _a.target, options)) || this;
            _this._padding = new DBasePaddingAdjustable(_this._padding);
            return _this;
        }
        DTableBodyCellTree.prototype.initOnClick = function (when, theme, options) {
            var _this = this;
            var link = this.link;
            if (link) {
                link.add(this, function (e) {
                    if (when === DButtonBaseWhen.CLICKED) {
                        _this.onClick(e);
                    }
                });
            }
            else {
                _super.prototype.initOnClick.call(this, when, theme, options);
            }
        };
        Object.defineProperty(DTableBodyCellTree.prototype, "link", {
            get: function () {
                var result = this._link;
                if (result === undefined) {
                    result = this.newLink();
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellTree.prototype.newLink = function () {
            var _a;
            var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.link;
            if (options) {
                return new DLink(this.theme, toLinkOptions(this, options));
            }
            return null;
        };
        DTableBodyCellTree.prototype.onActivate = function (e) {
            var _a;
            _super.prototype.onActivate.call(this, e);
            if (this.state.is(DTableState.HAS_CHILDREN)) {
                this.toggle();
            }
            else {
                (_a = this.link) === null || _a === void 0 ? void 0 : _a.open(e);
            }
        };
        DTableBodyCellTree.prototype.toggle = function () {
            var row = this._row;
            if (row === undefined) {
                return;
            }
            var parent = this.parent;
            if (parent == null) {
                return;
            }
            var body = parent.parent;
            if (body == null) {
                return;
            }
            var data = body.data;
            if (data && data.toggle) {
                data.toggle(row);
            }
        };
        DTableBodyCellTree.prototype.onRowSelect = function (e, local) {
            if (local.x <= this.position.x + this.padding.getLeft()) {
                this.toggle();
                return true;
            }
            return false;
        };
        DTableBodyCellTree.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            var column = this._column;
            DTableBodyCells.setRenderable(this, row, columnIndex, column);
            var link = this.link;
            var padding = this._padding;
            if (isNumber(supplimental)) {
                var isOpened = !!(supplimental & 0x1);
                var hasChildren = !!(supplimental & 0x2);
                var level = supplimental >> 2;
                var state = this.state;
                state.lock();
                state.set(DTableState.HAS_CHILDREN, hasChildren);
                state.set(DTableState.OPENED, isOpened);
                state.unlock();
                padding.adjLeft(this.theme.getLevelPadding(level));
                if (link) {
                    link.menu.enable = !hasChildren;
                }
            }
            else {
                this.state.removeAll(DTableState.OPENED, DTableState.HAS_CHILDREN);
                padding.adjLeft(0);
                if (link) {
                    link.menu.enable = false;
                }
            }
        };
        DTableBodyCellTree.prototype.getType = function () {
            return "DTableBodyCellTree";
        };
        return DTableBodyCellTree;
    }(DTableBodyCellButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataSelectionType;
    (function (DTableDataSelectionType) {
        DTableDataSelectionType[DTableDataSelectionType["NONE"] = 0] = "NONE";
        DTableDataSelectionType[DTableDataSelectionType["SINGLE"] = 1] = "SINGLE";
        DTableDataSelectionType[DTableDataSelectionType["MULTIPLE"] = 2] = "MULTIPLE";
    })(DTableDataSelectionType || (DTableDataSelectionType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableRow = /** @class */ (function (_super) {
        __extends(DTableRow, _super);
        function DTableRow(options) {
            var _a, _b;
            var _this = _super.call(this, options) || this;
            _this.state.isFocusReverse = true;
            _this._reverse = true;
            _this._frozen = (_a = options.frozen) !== null && _a !== void 0 ? _a : 0;
            _this._columns = (_b = options.columns) !== null && _b !== void 0 ? _b : [];
            return _this;
        }
        DTableRow.prototype.initCells = function (options, columns, frozen) {
            var iend = this.toIndexEnd(columns);
            for (var i = columns.length - 1; 0 <= i; --i) {
                var cell = this.newCell(i, columns[i], columns, options);
                var cellState = cell.state;
                cellState.lock(false);
                if (i === 0) {
                    cellState.add(DTableState.START);
                }
                if (i === iend) {
                    cellState.add(DTableState.END);
                }
                if (i < frozen) {
                    cellState.add(DTableState.FROZEN);
                }
                if (i === frozen - 1) {
                    cellState.add(DTableState.FROZEN_END);
                }
                cellState.unlock();
                this.addChild(cell);
            }
        };
        DTableRow.prototype.toIndexEnd = function (columns) {
            var imax = columns.length;
            for (var i = 0; i < imax; ++i) {
                var column = columns[i];
                if (column.weight !== undefined) {
                    return imax - 1;
                }
            }
            return imax;
        };
        DTableRow.prototype.onRefit = function () {
            _super.prototype.onRefit.call(this);
            this.resetFrozenCellPosition();
        };
        DTableRow.prototype.updateFrozenCellPosition = function (x) {
            var columns = this._columns;
            var cells = this.children;
            var cellsLength = cells.length;
            var frozen = this._frozen;
            for (var i = 0; i < frozen; ++i) {
                var column = columns[i];
                var cell = cells[cellsLength - 1 - i];
                cell.position.x = -x + column.offset;
            }
        };
        DTableRow.prototype.resetFrozenCellPosition = function () {
            var columns = this._columns;
            var cells = this.children;
            var cellsLength = cells.length;
            var frozen = this._frozen;
            var x = this.getContentPositionX();
            for (var i = 0; i < frozen; ++i) {
                var column = columns[i];
                var cell = cells[cellsLength - 1 - i];
                column.offset = cell.position.x;
                cell.position.x = -x + column.offset;
            }
        };
        DTableRow.prototype.getClippingRect = function (target, result) {
            _super.prototype.getClippingRect.call(this, target, result);
            var frozen = this._frozen;
            if (0 < frozen) {
                var cell = target;
                if (cell && cell.parent === this) {
                    var cells = this.children;
                    var cellIndex = cells.indexOf(cell);
                    if (0 <= cellIndex) {
                        var columnIndex = cells.length - 1 - cellIndex;
                        if (frozen <= columnIndex) {
                            var previous = cells[cellIndex + 1];
                            var shiftX = previous.position.x + previous.width;
                            result.x += shiftX;
                            result.width -= shiftX;
                        }
                    }
                }
            }
        };
        DTableRow.prototype.getType = function () {
            return "DTableRow";
        };
        return DTableRow;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyRow = /** @class */ (function (_super) {
        __extends(DTableBodyRow, _super);
        function DTableBodyRow(onChange, isEven, options) {
            var _this = _super.call(this, options) || this;
            _this._index = -1;
            _this._onCellChangeBound = function (newValue, oldValue, row, rowIndex, columnIndex) {
                _this.emit("change", newValue, oldValue, row, rowIndex, columnIndex, _this);
                onChange(newValue, oldValue, row, rowIndex, columnIndex, _this);
            };
            _this.state.isAlternated = isEven;
            _this.initCells(options, _this._columns, _this._frozen);
            return _this;
        }
        DTableBodyRow.prototype.newCell = function (columnIndex, column, columns, options) {
            var onChange = this._onCellChangeBound;
            var cellOptions = this.toCellOptions(columnIndex, column, options);
            if (column.editing.enable !== false) {
                return this.newCellEditable(columnIndex, column, onChange, cellOptions);
            }
            else {
                var cell = this.newCellUnediable(columnIndex, column, onChange, cellOptions);
                if (column.type !== DTableColumnType.TREE) {
                    cell.state.isReadOnly = true;
                }
                return cell;
            }
        };
        DTableBodyRow.prototype.newCellEditable = function (columnIndex, column, onChange, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellInputText(columnIndex, column, onChange, options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellInputTree(columnIndex, column, onChange, options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellInputInteger(columnIndex, column, onChange, options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellInputReal(columnIndex, column, onChange, options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(columnIndex, column, onChange, options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(columnIndex, column, onChange, options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(columnIndex, column, onChange, options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(columnIndex, column, onChange, options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(columnIndex, column, onChange, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(columnIndex, column, onChange, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(columnIndex, column, onChange, options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(columnIndex, column, onChange, options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(columnIndex, column, onChange, options);
                default:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.newCellUnediable = function (columnIndex, column, onChange, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellTree(columnIndex, column, onChange, options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(columnIndex, column, onChange, options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(columnIndex, column, onChange, options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(columnIndex, column, onChange, options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(columnIndex, column, onChange, options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(columnIndex, column, onChange, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(columnIndex, column, onChange, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(columnIndex, column, onChange, options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(columnIndex, column, onChange, options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(columnIndex, column, onChange, options);
                default:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.newCellSelect = function (columnIndex, column, onChange, options) {
            var selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellSelectMenu(columnIndex, column, onChange, options);
            }
            else if (selecting.multiple != null) {
                return new DTableBodyCellSelectMultiple(columnIndex, column, onChange, options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellSelectDialog(columnIndex, column, onChange, options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellSelectPromise(columnIndex, column, onChange, options);
            }
            else {
                return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.newCellAction = function (columnIndex, column, onChange, options) {
            var selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellActionMenu(columnIndex, column, onChange, options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellActionDialog(columnIndex, column, onChange, options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellActionPromise(columnIndex, column, onChange, options);
            }
            else {
                return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.toCellOptions = function (columnIndex, column, options) {
            var _a, _b;
            var result = column.body || options.cell;
            var columnWeight = column.weight;
            var columnWidth = column.width;
            var columnFormatter = column.formatter;
            var columnAlign = column.align;
            var columnSelecting = column.selecting;
            var columnSelectingMenu = columnSelecting.menu || columnSelecting.multiple;
            if (result != null) {
                result.weight = columnWeight;
                result.width = columnWidth;
                var text = result.text || {};
                result.text = text;
                text.formatter || (text.formatter = columnFormatter);
                var textAlign = text.align || {};
                text.align = textAlign;
                textAlign.horizontal = columnAlign;
                result.menu || (result.menu = columnSelectingMenu);
            }
            else {
                result = {
                    weight: columnWeight,
                    width: columnWidth,
                    text: {
                        formatter: columnFormatter,
                        align: {
                            horizontal: columnAlign
                        }
                    },
                    menu: columnSelectingMenu
                };
            }
            var columnEditing = column.editing;
            if (columnEditing.enable !== false) {
                var editing = result.editing || {};
                result.editing = editing;
                editing.formatter || (editing.formatter = columnEditing.formatter);
                editing.unformatter || (editing.unformatter = columnEditing.unformatter);
                editing.validator || (editing.validator = columnEditing.validator);
            }
            var columnLink = column.link;
            if (columnLink) {
                result.link = columnLink;
            }
            var selectionType = (_b = (_a = options === null || options === void 0 ? void 0 : options.selection) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : DTableDataSelectionType.NONE;
            if (selectionType !== DTableDataSelectionType.NONE) {
                result.when = "DOUBLE_CLICKED";
                result.cursor = function (state) {
                    if (state.in(DTableState.SELECTABLE)) {
                        return "pointer";
                    }
                    return undefined;
                };
            }
            return result;
        };
        DTableBodyRow.prototype.getType = function () {
            return "DTableBodyRow";
        };
        Object.defineProperty(DTableBodyRow.prototype, "value", {
            /**
             * Returns a row data if exists.
             * Returns undefined if a row data does not exit.
             *
             * @returns a row data or undefined.
             */
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyRow.prototype, "index", {
            /**
             * Returns a row index if a row data exists.
             * Returns -1 if a row data does not exit.
             *
             * @returns a row index or -1.
             */
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyRow.prototype.isCell = function (target) {
            return target != null && "set" in target;
        };
        DTableBodyRow.prototype.set = function (value, supplimental, rowIndex, forcibly) {
            if (forcibly || this._value !== value || this._index !== rowIndex) {
                this._value = value;
                this._index = rowIndex;
                var cells = this.children;
                var cellsLength = cells.length;
                var columns = this._columns;
                var columnsLength = columns.length;
                for (var i = 0; i < cellsLength; ++i) {
                    var cell = cells[i];
                    var columnIndex = columnsLength - 1 - i;
                    var column = columns[columnIndex];
                    if (this.isCell(cell)) {
                        cell.set(column.getter(value, columnIndex), value, supplimental, rowIndex, columnIndex, forcibly);
                    }
                }
                this.onSet(value, rowIndex);
            }
        };
        DTableBodyRow.prototype.onSet = function (value, rowIndex) {
            this.emit("set", value, rowIndex, this);
        };
        DTableBodyRow.prototype.unset = function () {
            if (this._value !== undefined) {
                this._value = undefined;
                this._index = -1;
                var cells = this.children;
                var cellsLength = cells.length;
                for (var i = 0; i < cellsLength; ++i) {
                    var cell = cells[i];
                    if (this.isCell(cell)) {
                        cell.unset();
                    }
                }
                this.onUnset();
            }
        };
        DTableBodyRow.prototype.onUnset = function () {
            this.emit("unset", this);
        };
        DTableBodyRow.prototype.getContentPositionX = function () {
            var parent = this.parent;
            if (parent) {
                var content = parent.parent;
                if (content) {
                    return content.position.x;
                }
            }
            return 0;
        };
        return DTableBodyRow;
    }(DTableRow));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataListFilter = /** @class */ (function (_super) {
        __extends(DTableDataListFilter, _super);
        function DTableDataListFilter(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._sorterId = -1;
            _this._parent = parent;
            _this._filter = null;
            _this._filtered = null;
            return _this;
        }
        Object.defineProperty(DTableDataListFilter.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListFilter.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataListFilter.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataListFilter.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataListFilter.prototype.newFiltered = function () {
            var filter = this._filter;
            if (filter != null) {
                var filtered = [];
                var parent_1 = this._parent;
                var sorter = parent_1.sorter;
                var rows = parent_1.rows;
                if (isFunction(filter)) {
                    var indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (var i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            var indexSorted = indicesSorted[i];
                            if (filter(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (var i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                else {
                    var indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (var i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            var indexSorted = indicesSorted[i];
                            if (filter.test(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (var i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter.test(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                return filtered;
            }
            else {
                return null;
            }
        };
        DTableDataListFilter.prototype.get = function () {
            return this._filter;
        };
        DTableDataListFilter.prototype.set = function (filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        };
        DTableDataListFilter.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataListFilter.prototype.update = function () {
            if (this._id !== this._idUpdated || this._parent.sorter.id !== this._sorterId) {
                this._idUpdated = this._id;
                this._sorterId = this._parent.sorter.id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataListFilter.prototype, "indices", {
            get: function () {
                this.update();
                return this._filtered;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListFilter.prototype.map = function (sortedIndex) {
            var result = sortedIndex;
            var indicesFiltered = this.indices;
            if (indicesFiltered) {
                var index = indicesFiltered.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataListFilter.prototype.unmap = function (index) {
            var result = index;
            var indicesFiltered = this.indices;
            if (indicesFiltered) {
                result = indicesFiltered[result];
            }
            return result;
        };
        return DTableDataListFilter;
    }(pixi_js.utils.EventEmitter));

    var DTableDataListMapped = /** @class */ (function () {
        function DTableDataListMapped(parent) {
            this._parent = parent;
        }
        DTableDataListMapped.prototype.map = function (unmappedIndex) {
            var parent = this._parent;
            var sortedIndex = parent.sorter.map(unmappedIndex);
            if (sortedIndex != null) {
                return parent.filter.map(sortedIndex);
            }
            return null;
        };
        DTableDataListMapped.prototype.unmap = function (index) {
            var parent = this._parent;
            return parent.sorter.unmap(parent.filter.unmap(index));
        };
        DTableDataListMapped.prototype.size = function () {
            var parent = this._parent;
            var indicesFiltered = parent.filter.indices;
            return indicesFiltered != null ? indicesFiltered.length : parent.size();
        };
        DTableDataListMapped.prototype.get = function (index) {
            var parent = this._parent;
            return parent.get(this.unmap(index));
        };
        DTableDataListMapped.prototype.each = function (iteratee, ifrom, ito) {
            var parent = this._parent;
            var rows = parent.rows;
            var supplimentals = parent.supplimentals;
            var indicesFiltered = parent.filter.indices;
            var indicesSorted = parent.sorter.indices;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            if (indicesFiltered) {
                var size = indicesFiltered.length;
                ito = ito != null ? Math.min(size, ito) : size;
                if (indicesSorted) {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesSorted[indicesFiltered[i]];
                        var row = rows[unmappedIndex];
                        var supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesFiltered[i];
                        var row = rows[unmappedIndex];
                        var supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
            }
            else {
                var size = rows.length;
                ito = ito != null ? Math.min(size, ito) : size;
                if (indicesSorted) {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesSorted[i];
                        var row = rows[unmappedIndex];
                        var supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (var i = ifrom; i < ito; ++i) {
                        var row = rows[i];
                        var supplimental = supplimentals ? supplimentals[i] : null;
                        if (iteratee(row, supplimental, i, i) === false) {
                            break;
                        }
                    }
                }
            }
        };
        return DTableDataListMapped;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var COMPARATOR = function (a, b) {
        return a[0] - b[0];
    };
    var DTableDataListSelection = /** @class */ (function (_super) {
        __extends(DTableDataListSelection, _super);
        function DTableDataListSelection(parent, options) {
            var _a;
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._type = toEnum((_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : DTableDataSelectionType.NONE, DTableDataSelectionType);
            _this._indices = new Set();
            return _this;
        }
        Object.defineProperty(DTableDataListSelection.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSelection.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTableDataListSelection.prototype.toggle = function (rowIndex) {
            var indices = this._indices;
            if (indices.has(rowIndex)) {
                indices.delete(rowIndex);
            }
            else {
                indices.add(rowIndex);
            }
            this.onChange();
        };
        DTableDataListSelection.prototype.add = function (rowIndex) {
            var indices = this._indices;
            var oldSize = indices.size;
            indices.add(rowIndex);
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        Object.defineProperty(DTableDataListSelection.prototype, "first", {
            get: function () {
                var indices = this._indices;
                if (0 < indices.size) {
                    var result_1 = NaN;
                    indices.forEach(function (index) {
                        if (result_1 !== result_1) {
                            result_1 = index;
                        }
                    });
                    return result_1;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSelection.prototype, "last", {
            get: function () {
                var indices = this._indices;
                if (0 < indices.size) {
                    var result_2 = 0;
                    indices.forEach(function (index) {
                        result_2 = index;
                    });
                    return result_2;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSelection.prototype.addTo = function (rowIndex) {
            var lastRowIndex = this.last;
            if (lastRowIndex != null) {
                this.addRange(lastRowIndex, false, rowIndex, true);
            }
        };
        DTableDataListSelection.prototype.addRange = function (from, includeFrom, to, includeTo) {
            var indices = this._indices;
            var oldSize = indices.size;
            if (from < to) {
                var ifrom = from + (includeFrom ? 0 : 1);
                var ito = to + (includeTo ? 1 : 0);
                for (var i = ifrom; i < ito; ++i) {
                    indices.add(i);
                }
            }
            else {
                var ifrom = to + (includeTo ? 0 : 1);
                var ito = from + (includeFrom ? 1 : 0);
                for (var i = ifrom; i < ito; ++i) {
                    indices.add(i);
                }
            }
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.addAll = function (rowIndices) {
            var indices = this._indices;
            var oldSize = indices.size;
            for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                indices.add(rowIndices[i]);
            }
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.contains = function (rowIndex) {
            return this._indices.has(rowIndex);
        };
        DTableDataListSelection.prototype.remove = function (rowIndex) {
            if (this._indices.delete(rowIndex)) {
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.clear = function () {
            var indices = this._indices;
            if (0 < indices.size) {
                indices.clear();
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.clearAndAdd = function (rowIndex) {
            var indices = this._indices;
            if (!indices.has(rowIndex) || indices.size !== 1) {
                indices.clear();
                indices.add(rowIndex);
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.clearAndAddAll = function (rowIndices) {
            var indices = this._indices;
            if (0 < indices.size || 0 < rowIndices.length) {
                indices.clear();
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    indices.add(rowIndices[i]);
                }
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.shift = function (rowIndex, amount) {
            var shifted = [];
            var indices = this._indices;
            indices.forEach(function (index) {
                if (rowIndex <= index) {
                    shifted.push(index);
                }
            });
            var shiftedLength = shifted.length;
            if (0 < shiftedLength) {
                for (var i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.delete(shifted[i]);
                }
                for (var i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.add(shifted[i] + amount);
                }
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.size = function () {
            return this._indices.size;
        };
        DTableDataListSelection.prototype.isEmpty = function () {
            return this._indices.size === 0;
        };
        Object.defineProperty(DTableDataListSelection.prototype, "indices", {
            /**
             * Returns a copy of an index array of selected rows.
             * The order of indices is an insertion order.
             */
            get: function () {
                var result = [];
                this._indices.forEach(function (index) {
                    result.push(index);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSelection.prototype, "rows", {
            /**
             * Returns a copy of an array of selected row value.
             * The order is an insertion order.
             */
            get: function () {
                var result = [];
                var parent = this._parent;
                this._indices.forEach(function (index) {
                    result.push(parent.get(index));
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns an array of the (index, row value) pairs of selected rows.
         * The order of pairs is an insertion order.
         */
        DTableDataListSelection.prototype.toArray = function () {
            var result = [];
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result.push([index, parent.get(index)]);
            });
            return result;
        };
        /**
         * Returns an sorted array of the (index, row value) pairs of selected rows.
         */
        DTableDataListSelection.prototype.toSortedArray = function () {
            return this.toArray().sort(COMPARATOR);
        };
        DTableDataListSelection.prototype.toObject = function () {
            var result = {};
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result[index] = parent.get(index);
            });
            return result;
        };
        DTableDataListSelection.prototype.toMap = function () {
            var result = new Map();
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result.set(index, parent.get(index));
            });
            return result;
        };
        return DTableDataListSelection;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A sort order.
     */
    var DTableDataOrder;
    (function (DTableDataOrder) {
        DTableDataOrder[DTableDataOrder["ASCENDING"] = 0] = "ASCENDING";
        DTableDataOrder[DTableDataOrder["DESCENDING"] = 1] = "DESCENDING";
    })(DTableDataOrder || (DTableDataOrder = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataListSorter = /** @class */ (function (_super) {
        __extends(DTableDataListSorter, _super);
        function DTableDataListSorter(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._parent = parent;
            _this._comparator = null;
            _this._sorted = null;
            _this._order = DTableDataOrder.ASCENDING;
            return _this;
        }
        Object.defineProperty(DTableDataListSorter.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSorter.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (order) {
                this._order = order;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSorter.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataListSorter.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataListSorter.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataListSorter.prototype.newSorted = function () {
            var comparator = this._comparator;
            if (comparator != null) {
                var parent_1 = this._parent;
                var sorted = [];
                var rows = parent_1.rows;
                for (var i = 0, imax = rows.length; i < imax; ++i) {
                    sorted.push(i);
                }
                sorted.sort(this.toComparator(rows, comparator));
                return sorted;
            }
            else {
                return null;
            }
        };
        DTableDataListSorter.prototype.toComparator = function (rows, comparator) {
            var order = this._order;
            if (isFunction(comparator)) {
                if (order === DTableDataOrder.ASCENDING) {
                    return function (indexA, indexB) {
                        return comparator(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return function (indexA, indexB) {
                        return comparator(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
            else {
                if (order === DTableDataOrder.ASCENDING) {
                    return function (indexA, indexB) {
                        return comparator.compare(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return function (indexA, indexB) {
                        return comparator.compare(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
        };
        DTableDataListSorter.prototype.get = function () {
            return this._comparator;
        };
        DTableDataListSorter.prototype.set = function (comparator) {
            if (this._comparator !== comparator) {
                this._comparator = comparator;
            }
        };
        DTableDataListSorter.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataListSorter.prototype.update = function () {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._sorted = this.newSorted();
                    this.emit("change", this);
                }
                else if (this._sorted != null) {
                    this._sorted = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataListSorter.prototype, "indices", {
            get: function () {
                this.update();
                return this._sorted;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSorter.prototype.map = function (unmappedIndex) {
            var result = unmappedIndex;
            var indicesSorted = this.indices;
            if (indicesSorted) {
                var index = indicesSorted.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataListSorter.prototype.unmap = function (index) {
            var result = index;
            var indicesSorted = this.indices;
            if (indicesSorted) {
                result = indicesSorted[result];
            }
            return result;
        };
        return DTableDataListSorter;
    }(pixi_js.utils.EventEmitter));

    var DTableDataList = /** @class */ (function (_super) {
        __extends(DTableDataList, _super);
        function DTableDataList(options) {
            var _this = _super.call(this) || this;
            _this._parent = null;
            _this._rows = _this.toRows(options === null || options === void 0 ? void 0 : options.rows);
            _this._mapped = new DTableDataListMapped(_this);
            _this._selection = _this.toSelection(options === null || options === void 0 ? void 0 : options.selection);
            _this._filter = new DTableDataListFilter(_this);
            _this._sorter = new DTableDataListSorter(_this);
            if (options) {
                // Filter
                var filter = options.filter;
                if (filter) {
                    _this._filter.set(filter);
                }
                // Comparator
                var comparator = options.comparator;
                if (comparator) {
                    _this._sorter.set(comparator);
                }
                // Events
                var on = options.on;
                if (on) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            return _this;
        }
        DTableDataList.prototype.toSelection = function (options) {
            if (options instanceof pixi_js.utils.EventEmitter) {
                return options;
            }
            else if (isFunction(options)) {
                return options(this);
            }
            return this.newSelection(options);
        };
        DTableDataList.prototype.newSelection = function (options) {
            return new DTableDataListSelection(this, options);
        };
        DTableDataList.prototype.bind = function (parent) {
            this._parent = parent;
        };
        DTableDataList.prototype.toRows = function (row) {
            var result = [];
            if (row != null) {
                for (var i = 0, imax = row.length; i < imax; ++i) {
                    result.push(row[i]);
                }
            }
            return result;
        };
        Object.defineProperty(DTableDataList.prototype, "rows", {
            get: function () {
                return this._rows;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataList.prototype.update = function () {
            var parent = this._parent;
            if (parent) {
                parent.update();
            }
        };
        DTableDataList.prototype.lock = function () {
            var parent = this._parent;
            if (parent) {
                parent.lock();
            }
        };
        DTableDataList.prototype.unlock = function () {
            var parent = this._parent;
            if (parent) {
                parent.unlock(false);
                parent.update();
            }
        };
        DTableDataList.prototype.size = function () {
            return this._rows.length;
        };
        DTableDataList.prototype.clear = function () {
            var rows = this._rows;
            if (0 < rows.length) {
                rows.length = 0;
                this.lock();
                this._selection.clear();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.unlock();
            }
        };
        DTableDataList.prototype.clearAndAdd = function (row) {
            var rows = this._rows;
            rows.length = 0;
            rows.push(row);
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.unlock();
        };
        DTableDataList.prototype.clearAndAddAll = function (newRows) {
            var rows = this._rows;
            rows.length = 0;
            for (var i = 0, imax = newRows.length; i < imax; ++i) {
                rows.push(newRows[i]);
            }
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.unlock();
        };
        DTableDataList.prototype.add = function (row, index) {
            var rows = this._rows;
            var selection = this._selection;
            var sorter = this._sorter;
            var filter = this._filter;
            if (index == null) {
                rows.push(row);
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
            else if (0 <= index && index < rows.length) {
                rows.splice(index, 0, row);
                this.lock();
                selection.shift(index, 1);
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
        };
        DTableDataList.prototype.addAll = function (newRows, index) {
            var rows = this._rows;
            var rowsLength = rows.length;
            var selection = this._selection;
            var sorter = this._sorter;
            var filter = this._filter;
            if (index == null) {
                var newRowsLength = newRows.length;
                for (var i = 0, imax = newRowsLength; i < imax; ++i) {
                    rows.push(newRows[i]);
                }
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
            else if (0 <= index && index < rowsLength) {
                var newRowsLength = newRows.length;
                for (var i = 0; i < newRowsLength; ++i) {
                    rows.splice(index + i, 0, newRows[i]);
                }
                this.lock();
                selection.shift(index, newRowsLength);
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
        };
        DTableDataList.prototype.get = function (index) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableDataList.prototype.set = function (index, row) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                var result = rows[index];
                rows[index] = row;
                this.lock();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.unlock();
                return result;
            }
            return null;
        };
        DTableDataList.prototype.remove = function (index) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                var result = rows.splice(index, 1)[0];
                this.lock();
                this._selection.remove(index);
                this._sorter.toDirty();
                this._filter.toDirty();
                this.unlock();
                return result;
            }
            return null;
        };
        DTableDataList.prototype.each = function (iteratee, ifrom, ito) {
            var rows = this._rows;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            ito = ito != null ? Math.min(rows.length, ito) : rows.length;
            for (var i = ifrom; i < ito; ++i) {
                var row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        };
        Object.defineProperty(DTableDataList.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "filter", {
            get: function () {
                return this._filter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "sorter", {
            get: function () {
                return this._sorter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        return DTableDataList;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toRowOptions = function (theme, options, selectionType) {
        var columns = options.columns || [];
        var result = options.row;
        if (result != null) {
            if (result.height == null) {
                result.height = theme.getRowHeight();
            }
            if (result.columns === undefined) {
                result.columns = columns;
            }
            if (result.frozen == null) {
                result.frozen = options.frozen;
            }
            if (result.selection === undefined) {
                result.selection = {
                    type: selectionType
                };
            }
            else if (result.selection.type === undefined) {
                result.selection.type = selectionType;
            }
        }
        else {
            result = {
                columns: columns,
                height: theme.getRowHeight(),
                frozen: options.frozen,
                selection: {
                    type: selectionType
                }
            };
        }
        return result;
    };
    var DTableBody = /** @class */ (function (_super) {
        __extends(DTableBody, _super);
        function DTableBody(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            _this.state.isFocusable = false;
            _this.transform.position.y = (_a = options.offset) !== null && _a !== void 0 ? _a : 0;
            var data = _this.toData(options.data);
            _this._data = data;
            data.bind(_this);
            var theme = _this.theme;
            var rowOptions = toRowOptions(theme, options, data.selection.type);
            _this._rowOptions = rowOptions;
            _this._rowHeight = rowOptions.height != null ? rowOptions.height : theme.getRowHeight();
            _this._columns = rowOptions.columns || [];
            _this._rowIndexMappedStart = 0;
            _this._rowIndexMappedEnd = 0;
            _this._updateRowsCount = 0;
            _this._isUpdateRowsCalled = false;
            _this._isUpdateRowsCalledForcibly = false;
            _this._workRows = [];
            _this._onRowChangeBound = function (newValue, oldValue, row, rowIndex, columnIndex) {
                data.emit("change", newValue, oldValue, row, rowIndex, columnIndex, data);
            };
            _this._data.emit("init", _this._data);
            return _this;
        }
        DTableBody.prototype.toData = function (options) {
            if (this.isData(options)) {
                return options;
            }
            return new DTableDataList(options);
        };
        DTableBody.prototype.isData = function (target) {
            return target != null && "mapped" in target;
        };
        DTableBody.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.update();
        };
        Object.defineProperty(DTableBody.prototype, "selection", {
            get: function () {
                return this._data.selection;
            },
            enumerable: false,
            configurable: true
        });
        DTableBody.prototype.lock = function () {
            this._updateRowsCount += 1;
            if (this._updateRowsCount === 1) {
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        };
        DTableBody.prototype.unlock = function (callIfNeeded) {
            this._updateRowsCount -= 1;
            if (this._updateRowsCount === 0) {
                if (callIfNeeded && this._isUpdateRowsCalled) {
                    this.update(this._isUpdateRowsCalledForcibly);
                }
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        };
        /**
         * Updates rows. If the `forcibly` is true, some dirty checkings for
         * avoiding unnecessary state changes are skipped.
         *
         * @param forcibly true to update forcibly
         */
        DTableBody.prototype.update = function (forcibly) {
            if (0 < this._updateRowsCount) {
                this._isUpdateRowsCalled = true;
                if (forcibly) {
                    this._isUpdateRowsCalledForcibly = true;
                }
                return;
            }
            var content = this.parent;
            var rows = this.children;
            var height = content.parent.height;
            var rowHeight = this._rowHeight;
            var data = this._data;
            var dataMappedSize = data.mapped.size();
            var oldRowIndexMappedStart = this._rowIndexMappedStart;
            var oldRowIndexMappedEnd = this._rowIndexMappedEnd;
            var oldRowCount = oldRowIndexMappedEnd - oldRowIndexMappedStart;
            var y = this.transform.position.y;
            var newHeight = y + dataMappedSize * rowHeight;
            var newContentHeight = Math.max(height, newHeight);
            var newContentY = Math.max(height - newContentHeight, content.position.y);
            var newRowIndexMappedLowerBound = Math.floor((0 - (newContentY + y)) / rowHeight);
            var newRowIndexMappedUpperBound = Math.floor((height - (newContentY + y)) / rowHeight);
            var newRowIndexMappedStart = newRowIndexMappedLowerBound - (newRowIndexMappedLowerBound % 2 === 0 ? 2 : 1);
            var newRowIndexMappedEnd = newRowIndexMappedUpperBound +
                ((newRowIndexMappedUpperBound - newRowIndexMappedStart + 1) % 2 === 0 ? 3 : 2);
            var newRowCount = newRowIndexMappedEnd - newRowIndexMappedStart;
            if (newRowCount < oldRowCount && oldRowCount - 2 <= newRowCount) {
                newRowCount = oldRowCount;
                newRowIndexMappedEnd = newRowIndexMappedStart + newRowCount;
            }
            if (oldRowCount < newRowCount) {
                for (var i = oldRowCount; i < newRowCount; ++i) {
                    var oldRowIndexMapped = oldRowIndexMappedStart + i;
                    var newRow = this.newRow(oldRowIndexMapped % 2 === 0);
                    this.addChild(newRow);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            else if (newRowCount < oldRowCount) {
                for (var i = oldRowCount - 1; newRowCount <= i; --i) {
                    this.removeChild(rows[i]);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            this._rowIndexMappedStart = newRowIndexMappedStart;
            this._rowIndexMappedEnd = newRowIndexMappedEnd;
            var rowIndexMappedStartDelta = newRowIndexMappedStart - oldRowIndexMappedStart;
            var rowIndexMappedStartDeltaAbs = Math.abs(rowIndexMappedStartDelta);
            var rowsLength = rows.length;
            if (0 < rowIndexMappedStartDeltaAbs && rowIndexMappedStartDeltaAbs < rowsLength) {
                var work = this._workRows;
                if (0 < rowIndexMappedStartDelta) {
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[i]));
                    }
                    for (var i = rowIndexMappedStartDeltaAbs; i < rowsLength; ++i) {
                        rows[i - rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[rowsLength - rowIndexMappedStartDeltaAbs + i] = work[i];
                    }
                }
                else {
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[rowsLength - rowIndexMappedStartDeltaAbs + i]));
                    }
                    for (var i = rowsLength - rowIndexMappedStartDeltaAbs - 1; 0 <= i; --i) {
                        rows[i + rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[i] = work[i];
                    }
                }
                work.length = 0;
            }
            var selection = data.selection;
            var isRowSelectable = selection.type !== DTableDataSelectionType.NONE;
            data.mapped.each(function (datum, supplimental, index, unmappedIndex) {
                var row = rows[index - newRowIndexMappedStart];
                // Position
                row.position.y = index * rowHeight;
                // State
                var rowState = row.state;
                rowState.lock();
                rowState.set(DTableState.SELECTABLE, isRowSelectable);
                rowState.set(DBaseState.ACTIVE, selection.contains(unmappedIndex));
                rowState.remove(DBaseState.DISABLED);
                rowState.unlock();
                // Data
                row.set(datum, supplimental, unmappedIndex, forcibly);
            }, newRowIndexMappedStart, newRowIndexMappedStart + rowsLength);
            for (var i = 0; newRowIndexMappedStart + i < 0 && i < rowsLength; ++i) {
                var row = rows[i];
                // Position
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                // State
                var rowState = row.state;
                rowState.lock();
                rowState.add(DBaseState.DISABLED);
                rowState.removeAll(DTableState.SELECTABLE, DBaseState.ACTIVE);
                rowState.unlock();
                // Data
                row.unset();
            }
            for (var i = rowsLength - 1; dataMappedSize <= newRowIndexMappedStart + i && 0 <= i; --i) {
                var row = rows[i];
                // Position
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                // State
                var rowState = row.state;
                rowState.lock();
                rowState.add(DBaseState.DISABLED);
                rowState.removeAll(DTableState.SELECTABLE, DBaseState.ACTIVE);
                rowState.unlock();
                // Data
                row.unset();
            }
            this.lock();
            content.position.y = newContentY;
            content.height = newContentHeight;
            this.height = newHeight;
            this.unlock(false);
        };
        DTableBody.prototype.resetRow = function (row) {
            row.blur(true);
            var cells = row.children;
            for (var i = 0, imax = cells.length; i < imax; ++i) {
                var cell = cells[i];
                if (cell instanceof DBase) {
                    cell.state.isPressed = false;
                }
            }
            return row;
        };
        DTableBody.prototype.newRow = function (isEven) {
            return new DTableBodyRow(this._onRowChangeBound, isEven, this._rowOptions);
        };
        DTableBody.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            _super.prototype.onParentMove.call(this, newX, newY, oldX, oldY);
            this.updateFrozenCellPosition(newX);
        };
        DTableBody.prototype.updateFrozenCellPosition = function (x) {
            var frozen = this._rowOptions.frozen;
            if (frozen != null && 0 < frozen) {
                var rows = this.children;
                for (var i = 0, imax = rows.length; i < imax; ++i) {
                    rows[i].updateFrozenCellPosition(x);
                }
            }
        };
        DTableBody.prototype.getClippingRect = function (target, result) {
            _super.prototype.getClippingRect.call(this, target, result);
            var parent = this.parent;
            if (parent) {
                var dy = -parent.transform.position.y;
                result.y += dy;
                result.height -= dy;
            }
        };
        DTableBody.prototype.toRowIndexMapped = function (local) {
            if (0 <= this.parent.position.y + local.y) {
                return Math.floor(local.y / this._rowHeight);
            }
            return -1;
        };
        DTableBody.prototype.toRow = function (rowIndexMapped) {
            var index = rowIndexMapped - this._rowIndexMappedStart;
            var rows = this.children;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableBody.prototype.toCell = function (row, local) {
            var cells = row.children;
            var cellsLength = cells.length;
            var columns = this._columns;
            var columnsLength = columns.length;
            for (var i = 0, imax = Math.min(cellsLength, columnsLength); i < imax; ++i) {
                var cell = cells[cellsLength - i - 1];
                var x = local.x - cell.position.x;
                if (0 <= x && x <= cell.width) {
                    return cell;
                }
            }
            return null;
        };
        DTableBody.prototype.onRowClick = function (e) {
            if (this.state.isActionable) {
                var local = DTableBody.WORK_ON_CLICK;
                local.copyFrom(e.data.global);
                this.toLocal(local, undefined, local, false);
                var rowIndexMapped = this.toRowIndexMapped(local);
                if (0 <= rowIndexMapped && rowIndexMapped < this._data.mapped.size()) {
                    // Delegate to the cell at first
                    var row = this.toRow(rowIndexMapped);
                    if (row) {
                        var cell = this.toCell(row, local);
                        if (cell && cell.onRowSelect && cell.onRowSelect(e, local)) {
                            return;
                        }
                    }
                    // Fallback to the default
                    this.onRowSelect(e, rowIndexMapped);
                }
            }
        };
        DTableBody.prototype.onRowSelect = function (e, rowIndexMapped) {
            var data = this._data;
            var selection = data.selection;
            var isSingle = selection.type === DTableDataSelectionType.SINGLE;
            var isNotSingle = !isSingle;
            var rowIndex = data.mapped.unmap(rowIndexMapped);
            var originalEvent = e.data.originalEvent;
            var ctrlKey = originalEvent.ctrlKey;
            var shiftKey = originalEvent.shiftKey;
            if (isSingle || selection.isEmpty() || !(isNotSingle && (ctrlKey || shiftKey))) {
                selection.clearAndAdd(rowIndex);
            }
            else if (ctrlKey) {
                selection.toggle(rowIndex);
            }
            else if (shiftKey) {
                var lastRowIndex = selection.last;
                if (lastRowIndex != null) {
                    var sorter = data.sorter;
                    var filter = data.filter;
                    var rowIndexSorted = sorter.map(rowIndex);
                    var lastRowIndexSorted = sorter.map(lastRowIndex);
                    if (rowIndexSorted != null && lastRowIndexSorted != null) {
                        var istart = lastRowIndexSorted + 1;
                        var iend = rowIndexSorted + 1;
                        if (rowIndexSorted < lastRowIndexSorted) {
                            istart = rowIndexSorted;
                            iend = lastRowIndexSorted;
                        }
                        if (istart < iend) {
                            var rowIndices = [];
                            var indicesFiltered = filter.indices;
                            var indicesSorted = sorter.indices;
                            if (indicesFiltered) {
                                if (indicesSorted) {
                                    for (var i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                        var indexFiltered = indicesFiltered[i];
                                        if (istart <= indexFiltered && indexFiltered < iend) {
                                            rowIndices.push(indicesSorted[indexFiltered]);
                                        }
                                    }
                                }
                                else {
                                    for (var i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                        var indexFiltered = indicesFiltered[i];
                                        if (istart <= indexFiltered && indexFiltered < iend) {
                                            rowIndices.push(indexFiltered);
                                        }
                                    }
                                }
                            }
                            else {
                                if (indicesSorted) {
                                    for (var i = istart; i < iend; ++i) {
                                        rowIndices.push(indicesSorted[i]);
                                    }
                                }
                                else {
                                    for (var i = istart; i < iend; ++i) {
                                        rowIndices.push(i);
                                    }
                                }
                            }
                            selection.addAll(rowIndices);
                        }
                    }
                }
            }
        };
        DTableBody.prototype.getType = function () {
            return "DTableBody";
        };
        Object.defineProperty(DTableBody.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        DTableBody.WORK_ON_CLICK = new pixi_js.Point();
        return DTableBody;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCategoryCell = /** @class */ (function (_super) {
        __extends(DTableCategoryCell, _super);
        function DTableCategoryCell() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableCategoryCell.prototype.getType = function () {
            return "DTableCategoryCell";
        };
        return DTableCategoryCell;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCategory = /** @class */ (function (_super) {
        __extends(DTableCategory, _super);
        function DTableCategory(options) {
            var _a;
            var _this = _super.call(this, options) || this;
            var offset = (_a = options.offset) !== null && _a !== void 0 ? _a : 0;
            _this._offset = offset;
            _this.transform.position.y = offset;
            _this.initCells(options, _this._columns, _this._frozen);
            return _this;
        }
        DTableCategory.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            _super.prototype.onParentMove.call(this, newX, newY, oldX, oldY);
            this.transform.position.y = -newY + this._offset;
            this.updateFrozenCellPosition(newX);
        };
        DTableCategory.prototype.getContentPositionX = function () {
            var content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        };
        DTableCategory.prototype.newCell = function (columnIndex, column, columns, options) {
            return new DTableCategoryCell(this.toCellOptions(columnIndex, column, options));
        };
        DTableCategory.prototype.toCellOptions = function (columnIndex, column, options) {
            var result = options.cell;
            if (result) {
                result.weight = column.weight;
                result.width = column.width;
                var text = result.text || {};
                result.text = text;
                text.value = text.value || column.label;
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    }
                };
            }
        };
        DTableCategory.prototype.getType = function () {
            return "DTableCategory";
        };
        return DTableCategory;
    }(DTableRow));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataTreeFilter = /** @class */ (function (_super) {
        __extends(DTableDataTreeFilter, _super);
        function DTableDataTreeFilter(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._parent = parent;
            _this._filter = null;
            _this._filtered = null;
            return _this;
        }
        Object.defineProperty(DTableDataTreeFilter.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeFilter.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataTreeFilter.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataTreeFilter.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataTreeFilter.prototype.isFiltered = function (node, index, filter) {
            if (isFunction(filter)) {
                return filter(node, index);
            }
            else {
                return filter.test(node, index);
            }
        };
        DTableDataTreeFilter.prototype.hasFiltered = function (parent, nodes, filter) {
            var toChildren = this._parent.accessor.toChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (this.isFiltered(node, -1, filter)) {
                    return true;
                }
                var children = toChildren(node);
                if (children != null &&
                    0 < children.length &&
                    this.hasFiltered(parent, children, filter)) {
                    return true;
                }
            }
            return false;
        };
        DTableDataTreeFilter.prototype.addAllToFiltered = function (parent, nodes, filtered, cursor) {
            var toChildren = this._parent.accessor.toChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                filtered.push(cursor[0]);
                cursor[0] += 1;
                var children = toChildren(node);
                if (children != null && 0 < children.length && parent.isOpened(node)) {
                    this.addAllToFiltered(parent, children, filtered, cursor);
                }
            }
        };
        DTableDataTreeFilter.prototype.newFilteredSub = function (parent, nodes, filter, filtered, cursor) {
            var result = false;
            var toChildren = this._parent.accessor.toChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                var index = cursor[0];
                cursor[0] += 1;
                var isFiltered = this.isFiltered(node, index, filter);
                var children = toChildren(node);
                if (children != null && 0 < children.length) {
                    if (parent.isOpened(node)) {
                        if (isFiltered) {
                            filtered.push(index);
                            result = true;
                            this.addAllToFiltered(parent, children, filtered, cursor);
                        }
                        else {
                            var position = filtered.length;
                            if (this.newFilteredSub(parent, children, filter, filtered, cursor)) {
                                filtered.splice(position, 0, index);
                                result = true;
                            }
                        }
                    }
                    else if (isFiltered || this.hasFiltered(parent, children, filter)) {
                        filtered.push(index);
                        result = true;
                    }
                }
                else if (isFiltered) {
                    filtered.push(index);
                    result = true;
                }
            }
            return result;
        };
        DTableDataTreeFilter.prototype.newFiltered = function () {
            var filter = this._filter;
            if (filter != null) {
                var filtered = [];
                var parent_1 = this._parent;
                var nodes = parent_1.nodes;
                if (nodes) {
                    var cursor = [0];
                    this.newFilteredSub(parent_1, nodes, filter, filtered, cursor);
                }
                return filtered;
            }
            return null;
        };
        DTableDataTreeFilter.prototype.get = function () {
            return this._filter;
        };
        DTableDataTreeFilter.prototype.set = function (filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        };
        DTableDataTreeFilter.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataTreeFilter.prototype.update = function () {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataTreeFilter.prototype, "indices", {
            get: function () {
                this.update();
                return this._filtered;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeFilter.prototype.map = function (sortedIndex) {
            var result = sortedIndex;
            var indices = this.indices;
            if (indices) {
                var index = indices.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataTreeFilter.prototype.unmap = function (index) {
            var result = index;
            var indices = this.indices;
            if (indices) {
                result = indices[result];
            }
            return result;
        };
        return DTableDataTreeFilter;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toParent = function (node) {
        return node.parent;
    };
    var toChildren = function (node) {
        return node.children;
    };
    var DTableDataTreeItemAccessor = /** @class */ (function () {
        function DTableDataTreeItemAccessor(options) {
            var _a, _b;
            this.toParent = (_a = options === null || options === void 0 ? void 0 : options.toParent) !== null && _a !== void 0 ? _a : toParent;
            this.toChildren = (_b = options === null || options === void 0 ? void 0 : options.toChildren) !== null && _b !== void 0 ? _b : toChildren;
        }
        return DTableDataTreeItemAccessor;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var COMPARATOR$1 = function (a, b) {
        return a[0] - b[0];
    };
    var DTableDataTreeSelectionImpl = /** @class */ (function (_super) {
        __extends(DTableDataTreeSelectionImpl, _super);
        function DTableDataTreeSelectionImpl(parent, options) {
            var _a;
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._type = toEnum((_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : DTableDataSelectionType.NONE, DTableDataSelectionType);
            _this._rows = new Set();
            return _this;
        }
        DTableDataTreeSelectionImpl.prototype.onNodeChange = function (nodes) {
            if (nodes != null) {
                var toChildren = this._parent.accessor.toChildren;
                var oldRows = this._rows;
                var newRows = this.newRows(nodes, toChildren, oldRows, new Set());
                if (oldRows.size !== newRows.size) {
                    this._rows = newRows;
                    this.onChange();
                }
            }
            else {
                var rows = this._rows;
                if (0 < rows.size) {
                    rows.clear();
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.newRows = function (nodes, toChildren, rows, result) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (rows.has(node)) {
                    result.add(node);
                }
                var children = toChildren(node);
                if (children != null) {
                    this.newRows(children, toChildren, rows, result);
                }
            }
            return result;
        };
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "indices", {
            get: function () {
                var rows = this._rows;
                var result = [];
                this._parent.each(function (row, index) {
                    if (rows.has(row)) {
                        result.push(index);
                    }
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "rows", {
            get: function () {
                var result = [];
                this._rows.forEach(function (row) {
                    result.push(row);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSelectionImpl.prototype.getFirst = function () {
            var rows = this._rows;
            if (0 < rows.size) {
                var result_1 = null;
                rows.forEach(function (row) {
                    if (result_1 == null) {
                        result_1 = row;
                    }
                });
                return result_1;
            }
            return null;
        };
        DTableDataTreeSelectionImpl.prototype.getLast = function () {
            var rows = this._rows;
            if (0 < rows.size) {
                var result_2 = null;
                rows.forEach(function (row) {
                    result_2 = row;
                });
                return result_2;
            }
            return null;
        };
        DTableDataTreeSelectionImpl.prototype.toIndex = function (target) {
            var result = null;
            this._parent.each(function (row, index) {
                if (target === row) {
                    result = index;
                    return false;
                }
                return true;
            });
            return result;
        };
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "first", {
            get: function () {
                var row = this.getFirst();
                if (row) {
                    return this.toIndex(row);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "last", {
            get: function () {
                var row = this.getLast();
                if (row) {
                    return this.toIndex(row);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSelectionImpl.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTableDataTreeSelectionImpl.prototype.toggle = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (rows.has(row)) {
                    rows.delete(row);
                }
                else {
                    rows.add(row);
                }
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.add = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (!rows.has(row)) {
                    rows.add(row);
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.addTo = function (rowIndex) {
            var lastRowIndex = this.last;
            if (lastRowIndex != null) {
                this.addRange(lastRowIndex, false, rowIndex, true);
            }
        };
        DTableDataTreeSelectionImpl.prototype.addRange = function (from, includeFrom, to, includeTo) {
            var rows = this._rows;
            var oldSize = rows.size;
            var parent = this._parent;
            if (from < to) {
                parent.each(function (row) {
                    rows.add(row);
                }, from + (includeFrom ? 0 : 1), to + (includeTo ? 1 : 0));
            }
            else {
                parent.each(function (row) {
                    rows.add(row);
                }, to + (includeTo ? 0 : 1), from + (includeFrom ? 1 : 0));
            }
            var newSize = rows.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.addAll = function (rowIndices) {
            if (0 < rowIndices.length) {
                var rows = this._rows;
                var parent_1 = this._parent;
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    var row = parent_1.get(rowIndices[i]);
                    if (row) {
                        rows.add(row);
                    }
                }
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.contains = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                return this._rows.has(row);
            }
            return false;
        };
        DTableDataTreeSelectionImpl.prototype.remove = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (rows.has(row)) {
                    rows.delete(row);
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.clear = function () {
            var rows = this._rows;
            if (0 < rows.size) {
                rows.clear();
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.clearAndAdd = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (rows.has(row)) {
                    if (1 < rows.size) {
                        rows.clear();
                        rows.add(row);
                        this.onChange();
                    }
                }
                else {
                    rows.clear();
                    rows.add(row);
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.clearAndAddAll = function (rowIndices) {
            var rows = this._rows;
            if (0 < rows.size || 0 < rowIndices.length) {
                rows.clear();
                var parent_2 = this._parent;
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    var row = parent_2.get(rowIndices[i]);
                    if (row) {
                        rows.add(row);
                    }
                }
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.shift = function (rowIndex, amount) {
            // DO NOTHING
        };
        DTableDataTreeSelectionImpl.prototype.size = function () {
            return this._rows.size;
        };
        DTableDataTreeSelectionImpl.prototype.isEmpty = function () {
            return this._rows.size <= 0;
        };
        DTableDataTreeSelectionImpl.prototype.toArray = function () {
            var rows = this._rows;
            var result = [];
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    result.push([index, row]);
                }
            });
            return result;
        };
        DTableDataTreeSelectionImpl.prototype.toSortedArray = function () {
            return this.toArray().sort(COMPARATOR$1);
        };
        DTableDataTreeSelectionImpl.prototype.toObject = function () {
            var rows = this._rows;
            var result = {};
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    result[index] = row;
                }
            });
            return result;
        };
        DTableDataTreeSelectionImpl.prototype.toMap = function () {
            var rows = this._rows;
            var result = new Map();
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    result.set(index, row);
                }
            });
            return result;
        };
        return DTableDataTreeSelectionImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataTreeSorter = /** @class */ (function (_super) {
        __extends(DTableDataTreeSorter, _super);
        function DTableDataTreeSorter() {
            return _super.call(this) || this;
        }
        Object.defineProperty(DTableDataTreeSorter.prototype, "id", {
            get: function () {
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSorter.prototype, "order", {
            get: function () {
                return DTableDataOrder.ASCENDING;
            },
            set: function (order) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSorter.prototype.apply = function () {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.unapply = function () {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.isApplied = function () {
            return false;
        };
        DTableDataTreeSorter.prototype.get = function () {
            return null;
        };
        DTableDataTreeSorter.prototype.set = function (comparator) {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.toDirty = function () {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.update = function () {
            // DO NOTHING
        };
        Object.defineProperty(DTableDataTreeSorter.prototype, "indices", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSorter.prototype.map = function (unmappedIndex) {
            return unmappedIndex;
        };
        DTableDataTreeSorter.prototype.unmap = function (index) {
            return index;
        };
        return DTableDataTreeSorter;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Please note that this data class does not support the sorter.
     */
    var DTableDataTree = /** @class */ (function (_super) {
        __extends(DTableDataTree, _super);
        function DTableDataTree(options) {
            var _this = _super.call(this) || this;
            _this._parent = null;
            _this._accessor = _this.toAccessor(options);
            _this._mapped = new DTableDataListMapped(_this);
            _this._rows = [];
            _this._isRowsDirty = false;
            _this._supplimentals = [];
            _this._flags = new WeakMap();
            _this._selection = _this.toSelection(options === null || options === void 0 ? void 0 : options.selection);
            _this._filter = new DTableDataTreeFilter(_this);
            _this._sorter = new DTableDataTreeSorter();
            if (options) {
                // Filter
                var filter = options.filter;
                if (filter) {
                    _this._filter.set(filter);
                }
                // Events
                var on = options.on;
                if (on) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            // Update rows
            _this.nodes = options === null || options === void 0 ? void 0 : options.nodes;
            return _this;
        }
        DTableDataTree.prototype.toSelection = function (options) {
            if (options instanceof pixi_js.utils.EventEmitter) {
                return options;
            }
            else if (isFunction(options)) {
                return options(this);
            }
            return this.newSelection(options);
        };
        DTableDataTree.prototype.newSelection = function (options) {
            return new DTableDataTreeSelectionImpl(this, options);
        };
        DTableDataTree.prototype.toAccessor = function (options) {
            return new DTableDataTreeItemAccessor(options);
        };
        DTableDataTree.prototype.bind = function (parent) {
            this._parent = parent;
        };
        Object.defineProperty(DTableDataTree.prototype, "nodes", {
            get: function () {
                return this._nodes;
            },
            set: function (nodes) {
                this._nodes = nodes;
                this._isRowsDirty = true;
                this._selection.onNodeChange(nodes);
                this._filter.toDirty();
                this.update(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "rows", {
            get: function () {
                if (this._isRowsDirty) {
                    this._isRowsDirty = false;
                    this.updateRows(this._nodes);
                }
                return this._rows;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "supplimentals", {
            get: function () {
                return this._supplimentals;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "accessor", {
            get: function () {
                return this._accessor;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTree.prototype.updateRows = function (nodes) {
            var rows = this._rows;
            var supplimentals = this._supplimentals;
            var flags = this._flags;
            if (nodes != null) {
                var irows = this.newRows(nodes, 0, 0, rows, supplimentals, flags);
                if (irows !== rows.length) {
                    rows.length = irows;
                    supplimentals.length = irows;
                }
            }
            else {
                rows.length = 0;
                supplimentals.length = 0;
            }
        };
        DTableDataTree.prototype.toSupplimental = function (ilevel, hasChildren, isOpened) {
            return (ilevel << 2) | (hasChildren ? 2 : 0) | (isOpened ? 1 : 0);
        };
        DTableDataTree.prototype.newRows = function (nodes, irows, ilevel, rows, supplimentals, flags) {
            var toChildren = this._accessor.toChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                var children = toChildren(node);
                var isOpened = flags.has(node);
                var supplimental = this.toSupplimental(ilevel, !!(children && 0 < children.length), isOpened);
                if (irows < rows.length) {
                    rows[irows] = node;
                    supplimentals[irows] = supplimental;
                }
                else {
                    rows.push(node);
                    supplimentals.push(supplimental);
                }
                irows += 1;
                if (isOpened && children) {
                    irows = this.newRows(children, irows, ilevel + 1, rows, supplimentals, flags);
                }
            }
            return irows;
        };
        DTableDataTree.prototype.update = function (forcibly) {
            var parent = this._parent;
            if (parent) {
                parent.update(forcibly);
            }
        };
        DTableDataTree.prototype.size = function () {
            return this.rows.length;
        };
        DTableDataTree.prototype.get = function (index) {
            var rows = this.rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableDataTree.prototype.open = function (node) {
            var flags = this._flags;
            if (!flags.has(node)) {
                flags.set(node, 1);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
            }
        };
        DTableDataTree.prototype.close = function (node) {
            var flags = this._flags;
            if (flags.has(node)) {
                flags.delete(node);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
            }
        };
        DTableDataTree.prototype.isOpened = function (node) {
            return this._flags.has(node);
        };
        DTableDataTree.prototype.toggle = function (node) {
            var flags = this._flags;
            if (flags.has(node)) {
                flags.delete(node);
            }
            else {
                flags.set(node, 1);
            }
            this._isRowsDirty = true;
            this._filter.toDirty();
            this.update(true);
        };
        DTableDataTree.prototype.each = function (iteratee, ifrom, ito) {
            var rows = this.rows;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            ito = ito != null ? Math.min(rows.length, ito) : rows.length;
            for (var i = ifrom; i < ito; ++i) {
                var row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        };
        Object.defineProperty(DTableDataTree.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "filter", {
            get: function () {
                return this._filter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "sorter", {
            get: function () {
                return this._sorter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        return DTableDataTree;
    }(pixi_js.utils.EventEmitter));

    var DTableHeaderCellCheck = /** @class */ (function () {
        function DTableHeaderCellCheck(parent, options) {
            var _a, _b, _c;
            this._parent = parent;
            this._isEnabled = (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : false;
            this._isFilterable = (_b = options === null || options === void 0 ? void 0 : options.filterable) !== null && _b !== void 0 ? _b : true;
            this._isEmittable = (_c = options === null || options === void 0 ? void 0 : options.emittable) !== null && _c !== void 0 ? _c : true;
        }
        Object.defineProperty(DTableHeaderCellCheck.prototype, "isEnabled", {
            get: function () {
                return this._isEnabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCellCheck.prototype, "isFilterable", {
            get: function () {
                return this._isFilterable;
            },
            set: function (isFilterable) {
                this._isFilterable = isFilterable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCellCheck.prototype, "isEmittable", {
            get: function () {
                return this._isEmittable;
            },
            set: function (isEmittable) {
                this._isEmittable = isEmittable;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCellCheck.prototype.newIteratee = function (table, isChecked) {
            var parent = this._parent;
            var column = parent.column;
            var columnIndex = parent.columnIndex;
            if (column != null && columnIndex != null) {
                var getter_1 = column.getter;
                var setter_1 = column.setter;
                if (this._isEmittable) {
                    var data_1 = table.data;
                    return function (row, rowIndex) {
                        if (getter_1(row, columnIndex) !== isChecked) {
                            setter_1(row, columnIndex, isChecked);
                            data_1.emit("change", isChecked, !isChecked, row, rowIndex, columnIndex, data_1);
                            return true;
                        }
                        return false;
                    };
                }
                else {
                    return function (row) {
                        if (getter_1(row, columnIndex) !== isChecked) {
                            setter_1(row, columnIndex, isChecked);
                            return true;
                        }
                        return false;
                    };
                }
            }
            return null;
        };
        DTableHeaderCellCheck.prototype.execute = function (isChecked) {
            var _a;
            var table = (_a = this._parent.header) === null || _a === void 0 ? void 0 : _a.table;
            if (table) {
                var iteratee_1 = this.newIteratee(table, isChecked);
                if (iteratee_1) {
                    var isChanged_1 = false;
                    if (this._isFilterable) {
                        table.data.mapped.each(function (row, supplimental, index, unmappedIndex) {
                            if (iteratee_1(row, unmappedIndex)) {
                                isChanged_1 = true;
                            }
                        });
                    }
                    else {
                        table.data.each(function (row, index) {
                            if (iteratee_1(row, index)) {
                                isChanged_1 = true;
                            }
                        });
                    }
                    if (isChanged_1) {
                        table.body.update(true);
                    }
                }
            }
        };
        return DTableHeaderCellCheck;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableHeaderCell = /** @class */ (function (_super) {
        __extends(DTableHeaderCell, _super);
        function DTableHeaderCell() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableHeaderCell.prototype.init = function (options) {
            if (options != null) {
                this._header = options.header;
                this._column = options.column;
                this._columnIndex = options.columnIndex;
                this._check = new DTableHeaderCellCheck(this, options.check);
            }
            else {
                this._check = new DTableHeaderCellCheck(this);
            }
            _super.prototype.init.call(this, options);
            this.initOnClick(options);
        };
        Object.defineProperty(DTableHeaderCell.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "header", {
            get: function () {
                return this._header;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "check", {
            get: function () {
                return this._check;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCell.prototype.initOnClick = function (options) {
            var _this = this;
            var column = this._column;
            if (column) {
                var sortable = column.sorting.enable;
                var checkable = this._check.isEnabled;
                if (checkable || sortable) {
                    UtilPointerEvent.onClick(this, function (e) {
                        _this.onClick(e);
                    });
                    var state = this.state;
                    state.lock();
                    state.set(DTableState.SORTABLE, sortable);
                    state.set(DTableState.CHECKABLE, checkable);
                    state.unlock();
                }
            }
        };
        Object.defineProperty(DTableHeaderCell.prototype, "sorter", {
            get: function () {
                var _this = this;
                var sorter = this._sorter;
                if (sorter == null) {
                    var header = this._header;
                    if (header) {
                        var table = header.table;
                        if (table) {
                            sorter = table.data.sorter;
                            this._sorter = sorter;
                            this._onSorterChangeBound =
                                this._onSorterChangeBound ||
                                    (function () {
                                        _this.onSorterChange();
                                    });
                            sorter.on("change", this._onSorterChangeBound);
                        }
                        else {
                            return null;
                        }
                    }
                    else {
                        return null;
                    }
                }
                return sorter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "comparator", {
            get: function () {
                var column = this._column;
                if (column) {
                    return column.sorting.comparator || null;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCell.prototype.onSorterChange = function () {
            var comparator = this.comparator;
            if (comparator) {
                var sorter = this._sorter;
                if (sorter) {
                    var SORTED_ASCENDING = DTableState.SORTED_ASCENDING;
                    var SORTED_DESCENDING = DTableState.SORTED_DESCENDING;
                    if (sorter.isApplied() && sorter.get() === comparator) {
                        if (sorter.order === DTableDataOrder.ASCENDING) {
                            this.state.set(SORTED_ASCENDING, SORTED_DESCENDING);
                        }
                        else {
                            this.state.set(SORTED_DESCENDING, SORTED_ASCENDING);
                        }
                    }
                    else {
                        this.state.removeAll(SORTED_ASCENDING, SORTED_DESCENDING);
                    }
                }
            }
        };
        DTableHeaderCell.prototype.toClickPosition = function (e) {
            var checkWork = this._checkWork || new pixi_js.Point();
            this._checkWork = checkWork;
            return e.data.getLocalPosition(this, checkWork).x;
        };
        DTableHeaderCell.prototype.isCheckClicked = function (e) {
            if (this._check.isEnabled) {
                if (this.isSortable) {
                    var image = this._images[1];
                    if (image && image.image != null) {
                        var position = this.toClickPosition(e);
                        var bound = image.bound;
                        var margin = image.margin.horizontal;
                        return bound.left - margin <= position && position <= bound.right + margin;
                    }
                }
                else {
                    return true;
                }
            }
            return false;
        };
        DTableHeaderCell.prototype.onClick = function (e) {
            if (this.state.isActionable) {
                if (this.isCheckClicked(e)) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
                else {
                    this.onActivate(e);
                }
            }
        };
        DTableHeaderCell.prototype.onActivate = function (e) {
            this.doSort(e);
            this.emit("active", this);
        };
        DTableHeaderCell.prototype.doSort = function (e) {
            if (this.isSortable) {
                var comparator = this.comparator;
                if (comparator) {
                    var sorter = this.sorter;
                    if (sorter) {
                        if (sorter.get() === comparator) {
                            if (sorter.order === DTableDataOrder.ASCENDING) {
                                sorter.order = DTableDataOrder.DESCENDING;
                                sorter.apply();
                            }
                            else {
                                sorter.set(null);
                                sorter.apply();
                            }
                        }
                        else {
                            sorter.set(comparator);
                            sorter.order = DTableDataOrder.ASCENDING;
                            sorter.apply();
                        }
                    }
                }
            }
        };
        Object.defineProperty(DTableHeaderCell.prototype, "isSortable", {
            get: function () {
                var column = this._column;
                if (column) {
                    return column.sorting.enable;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "isToggle", {
            get: function () {
                return this._check.isEnabled;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCell.prototype.toggle = function () {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
            }
        };
        DTableHeaderCell.prototype.onToggleStart = function () {
            this.state.isActive = !this.state.isActive;
        };
        DTableHeaderCell.prototype.onToggleEnd = function () {
            if (this.state.isActive) {
                this._check.execute(true);
                this.emit("active", this);
            }
            else {
                this._check.execute(false);
                this.emit("inactive", this);
            }
        };
        DTableHeaderCell.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleStart();
                }
                else {
                    this.state.isPressed = true;
                }
            }
        };
        DTableHeaderCell.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleEnd();
                }
                else {
                    if (this.state.isPressed) {
                        this.onActivate(e);
                    }
                    this.state.isPressed = false;
                }
            }
        };
        DTableHeaderCell.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTableHeaderCell.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTableHeaderCell.prototype.getType = function () {
            return "DTableHeaderCell";
        };
        DTableHeaderCell.prototype.destroy = function () {
            var sorter = this._sorter;
            var onSorterChangeBound = this._onSorterChangeBound;
            if (sorter && onSorterChangeBound) {
                sorter.off("change", onSorterChangeBound);
            }
            this._sorter = undefined;
            this._onSorterChangeBound = undefined;
            _super.prototype.destroy.call(this);
        };
        return DTableHeaderCell;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableHeader = /** @class */ (function (_super) {
        __extends(DTableHeader, _super);
        function DTableHeader(options) {
            var _a, _b;
            var _this = _super.call(this, options) || this;
            _this._table = (_a = options.table) !== null && _a !== void 0 ? _a : null;
            var offset = (_b = options.offset) !== null && _b !== void 0 ? _b : 0;
            _this._offset = offset;
            _this.transform.position.y = offset;
            _this.initCells(options, _this._columns, _this._frozen);
            return _this;
        }
        Object.defineProperty(DTableHeader.prototype, "table", {
            get: function () {
                return this._table;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeader.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            _super.prototype.onParentMove.call(this, newX, newY, oldX, oldY);
            this.transform.position.y = -newY + this._offset;
            this.updateFrozenCellPosition(newX);
        };
        DTableHeader.prototype.getContentPositionX = function () {
            var content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        };
        DTableHeader.prototype.newCell = function (columnIndex, column, columns, options) {
            return new DTableHeaderCell(this.toCellOptions(columnIndex, column, options));
        };
        DTableHeader.prototype.toCellOptions = function (columnIndex, column, options) {
            var result = column.header || options.cell;
            if (result != null) {
                if (result.weight === undefined) {
                    result.weight = column.weight;
                }
                if (result.width === undefined) {
                    result.width = column.width;
                }
                if (result.text === undefined) {
                    result.text = {
                        value: column.label
                    };
                }
                else if (result.text.value === undefined) {
                    result.text.value = column.label;
                }
                if (result.header === undefined) {
                    result.header = this;
                }
                if (result.column === undefined) {
                    result.column = column;
                }
                if (result.columnIndex === undefined) {
                    result.columnIndex = columnIndex;
                }
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    },
                    header: this,
                    column: column,
                    columnIndex: columnIndex
                };
            }
        };
        DTableHeader.prototype.getType = function () {
            return "DTableHeader";
        };
        return DTableHeader;
    }(DTableRow));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var defaultGetter$1 = function (row, columnIndex) {
        return row[columnIndex];
    };
    var defaultSetter$1 = function (row, columnIndex, cell) {
        row[columnIndex] = cell;
    };
    var defaultGetterEmpty = function () { return ""; };
    var defaultSetterEmpty = function () {
        // DO NOTHING
    };
    var toPathGetter = function (path, def) {
        if (path.length <= 1) {
            var key_1 = path[0];
            if (def === undefined) {
                return function (row) {
                    return row[key_1];
                };
            }
            else {
                return function (row) {
                    return key_1 in row ? row[key_1] : def;
                };
            }
        }
        else {
            if (def === undefined) {
                return function (row) {
                    for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    return row[path[path.length - 1]];
                };
            }
            else {
                return function (row) {
                    for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    var key = path[path.length - 1];
                    return key in row ? row[key] : def;
                };
            }
        }
    };
    var toPathSetter = function (path) {
        if (path.length <= 1) {
            var key_2 = path[0];
            return function (row, columnIndex, cell) {
                row[key_2] = cell;
            };
        }
        else {
            return function (row, columnIndex, cell) {
                for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                    row = row[path[i]] || {};
                }
                row[path[path.length - 1]] = cell;
            };
        }
    };
    var toColumnAlign = function (options, type) {
        var align = options.align;
        if (align != null) {
            if (isString(align)) {
                return DAlignHorizontal[align];
            }
            else {
                return align;
            }
        }
        switch (type) {
            case DTableColumnType.TEXT:
                return DAlignHorizontal.LEFT;
            case DTableColumnType.REAL:
            case DTableColumnType.INTEGER:
                return DAlignHorizontal.RIGHT;
            case DTableColumnType.BUTTON:
            case DTableColumnType.INDEX:
            case DTableColumnType.SELECT:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return DAlignHorizontal.CENTER;
            default:
                return DAlignHorizontal.LEFT;
        }
    };
    var toColumnDataChecker = function (path) {
        if (path != null) {
            if (path.length <= 1) {
                var key_3 = path[0];
                return function (row) {
                    return key_3 in row;
                };
            }
            else {
                return function (row) {
                    for (var i = 0, imax = path.length; i < imax; ++i) {
                        var part = path[i];
                        if (part in row) {
                            row = row[part];
                        }
                        else {
                            return false;
                        }
                    }
                    return true;
                };
            }
        }
        return function (row, columnIndex) {
            return columnIndex < row.length;
        };
    };
    var toColumnEditingEnable = function (enable, path) {
        if (isString(enable)) {
            return toColumnDataChecker(path);
        }
        else if (enable != null) {
            return enable;
        }
        else {
            return false;
        }
    };
    var toColumnEditing = function (options, path) {
        var _a;
        var editing = options.editing;
        var editable = options.editable;
        if (editing) {
            return {
                enable: toColumnEditingEnable((_a = editing.enable) !== null && _a !== void 0 ? _a : editable, path),
                formatter: editing.formatter,
                unformatter: editing.unformatter,
                validator: editing.validator
            };
        }
        return {
            enable: toColumnEditingEnable(editable, path)
        };
    };
    var toComparator = function (getter, index) {
        return function (rowA, rowB) {
            var valueA = getter(rowA, index);
            var valueB = getter(rowB, index);
            return valueA < valueB ? -1 : valueB < valueA ? +1 : 0;
        };
    };
    var toColumnSorting = function (getter, index, options) {
        var sorting = options.sorting;
        var sortable = options.sortable;
        if (sorting) {
            if (sorting.enable || sortable) {
                return {
                    enable: true,
                    comparator: sorting.comparator || toComparator(getter, index)
                };
            }
            return {
                enable: false
            };
        }
        if (sortable) {
            return {
                enable: true,
                comparator: toComparator(getter, index)
            };
        }
        return {
            enable: false
        };
    };
    var toColumnMenu = function (options) {
        if (options == null) {
            return undefined;
        }
        else if (options instanceof DMenu) {
            return options;
        }
        else {
            return new DMenu(options);
        }
    };
    var toColumnDialog = function (options) {
        if (options == null) {
            return undefined;
        }
        else if ("open" in options) {
            return options;
        }
        else {
            return new DDialogSelect(options);
        }
    };
    var defaultSelectingGetter = function (dialog) {
        return dialog.value;
    };
    var defaultSelectingSetter = function () {
        // DO NOTHING
    };
    var toColumnSelecting = function (options) {
        if (options) {
            return {
                getter: options.getter || defaultSelectingGetter,
                setter: options.setter || defaultSelectingSetter,
                menu: toColumnMenu(options.menu),
                multiple: toColumnMenu(options.multiple),
                dialog: toColumnDialog(options.dialog),
                promise: options.promise
            };
        }
        return {
            getter: defaultSelectingGetter,
            setter: defaultSelectingSetter
        };
    };
    var toColumnGetter = function (options, type, parts) {
        var getter = options.getter;
        if (getter) {
            return getter;
        }
        switch (type) {
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultGetterEmpty;
            default:
                if (parts == null) {
                    return defaultGetter$1;
                }
                else {
                    return toPathGetter(parts, options.default);
                }
        }
    };
    var toColumnSetter = function (options, type, path) {
        var setter = options.setter;
        if (setter) {
            return setter;
        }
        switch (type) {
            case DTableColumnType.BUTTON:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultSetterEmpty;
            default:
                if (path == null) {
                    return defaultSetter$1;
                }
                else {
                    return toPathSetter(path);
                }
        }
    };
    var toColumnPath = function (options) {
        return options.path != null ? options.path.split(".") : null;
    };
    var toColumnRenderable = function (options, path) {
        var renderable = options.renderable;
        if (isString(renderable)) {
            return toColumnDataChecker(path);
        }
        else if (renderable != null) {
            return renderable;
        }
        return true;
    };
    var toColumn = function (index, options) {
        var _a;
        var weight = options.weight;
        var width = options.width;
        if (weight != null) {
            if (width != null) {
                width = undefined;
            }
        }
        else if (width == null) {
            weight = 1;
        }
        var type = toEnum((_a = options.type) !== null && _a !== void 0 ? _a : DTableColumnType.TEXT, DTableColumnType);
        var align = toColumnAlign(options, type);
        var label = options.label || "";
        var path = toColumnPath(options);
        var getter = toColumnGetter(options, type, path);
        var setter = toColumnSetter(options, type, path);
        return {
            weight: weight,
            width: width,
            type: type,
            label: label,
            getter: getter,
            setter: setter,
            formatter: options.formatter,
            renderable: toColumnRenderable(options, path),
            align: align,
            editing: toColumnEditing(options, path),
            sorting: toColumnSorting(getter, index, options),
            header: options.header,
            body: options.body,
            selecting: toColumnSelecting(options.selecting),
            category: options.category,
            frozen: options.frozen,
            offset: 0.0,
            link: options.link
        };
    };
    var toColumns = function (options) {
        var result = [];
        for (var i = 0, imax = options.length; i < imax; ++i) {
            result.push(toColumn(i, options[i]));
        }
        return result;
    };
    var toFrozen = function (columns) {
        for (var i = columns.length - 1; 0 <= i; --i) {
            if (columns[i].frozen === true) {
                return i + 1;
            }
        }
        return 0;
    };
    var DTable = /** @class */ (function (_super) {
        __extends(DTable, _super);
        function DTable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTable.prototype.init = function (options) {
            // Column
            var columns = toColumns(options.columns);
            // Frozen
            var frozen = toFrozen(columns);
            this._frozen = frozen;
            // Categories
            var categories = this.newCategories(options, columns, frozen);
            this._categories = categories;
            // Header
            var headerOffset = 0;
            for (var i = 0, imax = categories.length; i < imax; ++i) {
                headerOffset += categories[i].height;
            }
            var header = this.newHeader(options, columns, frozen, headerOffset);
            this._header = header;
            // Body
            var bodyOffset = headerOffset + ((header === null || header === void 0 ? void 0 : header.height) || 0);
            this._bodyOffset = bodyOffset;
            var body = this.newBody(options, columns, frozen, bodyOffset);
            this._body = body;
            // Super
            _super.prototype.init.call(this, options);
            // Content
            var content = this._content;
            content.setWidth(this.toContentWidth(options));
            content.addChild(body);
            if (header) {
                content.addChild(header);
            }
            for (var i = categories.length - 1; 0 <= i; --i) {
                content.addChild(categories[i]);
            }
            content.on("move", function () {
                body.update();
            });
            content.on("resize", function () {
                body.update();
            });
            if (body.data.selection.type !== DTableDataSelectionType.NONE) {
                UtilPointerEvent.onClick(this, function (e) {
                    body.onRowClick(e);
                });
            }
            content.state.isFocusReverse = true;
            body.update();
        };
        DTable.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var body = this._body;
            body.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            body.update();
            body.unlock(true);
        };
        DTable.prototype.getCategoryCount = function (columns) {
            var result = 0;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var category = columns[i].category;
                if (category != null) {
                    var count = isString(category) ? 1 : category.length;
                    result = Math.max(result, count);
                }
            }
            return result;
        };
        DTable.prototype.toCategoryLabel = function (index, category) {
            if (category) {
                if (isString(category)) {
                    if (index === 0) {
                        return category;
                    }
                }
                else {
                    if (index < category.length) {
                        return category[index];
                    }
                }
            }
            return undefined;
        };
        DTable.prototype.isSameCategory = function (index, a, b) {
            if (a != null) {
                if (b != null) {
                    if (isString(a)) {
                        if (isString(b)) {
                            if (0 < index) {
                                return true;
                            }
                            else {
                                return a === b;
                            }
                        }
                        else {
                            if (0 < index) {
                                return b.length <= index;
                            }
                            else {
                                return b.length === 1 && a === b[0];
                            }
                        }
                    }
                    else {
                        if (isString(b)) {
                            if (0 < index) {
                                return a.length <= index;
                            }
                            else {
                                return a.length === 1 && a[0] === b;
                            }
                        }
                        else {
                            if (a.length <= index && b.length <= index) {
                                return true;
                            }
                            else if (b.length === a.length) {
                                for (var i = index, imax = a.length; i < imax; ++i) {
                                    if (a[i] !== b[i]) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                            return false;
                        }
                    }
                }
                else {
                    if (isString(a)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (a.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            else {
                if (b != null) {
                    if (isString(b)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (b.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    return true;
                }
            }
        };
        DTable.prototype.toCategoryColumns = function (index, columns, frozen) {
            var result = [];
            var tcolumn = null;
            var ccolumn = null;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var column = columns[i];
                if (i !== frozen &&
                    ccolumn &&
                    tcolumn &&
                    this.isSameCategory(index, tcolumn.category, column.category)) {
                    if (ccolumn.weight != null && column.weight != null) {
                        ccolumn.weight += column.weight;
                    }
                    else if (ccolumn.width != null && column.width != null) {
                        ccolumn.width += column.width;
                    }
                    else {
                        tcolumn = column;
                        ccolumn = {
                            label: this.toCategoryLabel(index, column.category),
                            weight: column.weight,
                            width: column.width,
                            offset: 0.0
                        };
                        result.push(ccolumn);
                    }
                }
                else {
                    tcolumn = column;
                    ccolumn = {
                        label: this.toCategoryLabel(index, column.category),
                        weight: column.weight,
                        width: column.width,
                        offset: 0.0
                    };
                    result.push(ccolumn);
                }
            }
            return result;
        };
        DTable.prototype.toCategoryOptions = function (index, options, columns, frozen, offset) {
            if (options) {
                if (options.columns === undefined) {
                    options.columns = this.toCategoryColumns(index, columns, frozen);
                }
                if (options.frozen == null) {
                    options.frozen = frozen;
                }
                if (options.offset == null) {
                    options.offset = offset;
                }
                return options;
            }
            return {
                columns: this.toCategoryColumns(index, columns, frozen),
                frozen: frozen,
                offset: offset
            };
        };
        DTable.prototype.newCategories = function (options, columns, frozen) {
            var count = this.getCategoryCount(columns);
            var result = [];
            var offset = 0;
            for (var i = count - 1; 0 <= i; --i) {
                var category = new DTableCategory(this.toCategoryOptions(i, options.category, columns, frozen, offset));
                result.push(category);
                offset += category.height;
            }
            return result;
        };
        DTable.prototype.onDblClick = function (e, interactionManager) {
            var result = this._body.onDblClick(e, interactionManager);
            return _super.prototype.onDblClick.call(this, e, interactionManager) || result;
        };
        DTable.prototype.getScrollBarOffsetVerticalStart = function (size) {
            return size * 0.5 + this._body.position.y;
        };
        DTable.prototype.toContentWidth = function (options) {
            var columnWidthTotal = 0;
            var columns = options.columns;
            if (columns) {
                for (var i = 0, imax = columns.length; i < imax; ++i) {
                    var column = columns[i];
                    var columnWidth = column.width;
                    if (columnWidth != null) {
                        columnWidthTotal += columnWidth;
                    }
                }
            }
            if (0 < columnWidthTotal) {
                return function (p) {
                    return Math.max(p, columnWidthTotal);
                };
            }
            return "100%";
        };
        DTable.prototype.hasHeader = function (options) {
            var columns = options.columns;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                if (columns[i].label != null) {
                    return true;
                }
            }
            return false;
        };
        DTable.prototype.newHeader = function (options, columns, frozen, offset) {
            if (this.hasHeader(options)) {
                return new DTableHeader(this.toHeaderOptions(options.header, columns, frozen, offset));
            }
            return null;
        };
        DTable.prototype.toHeaderOptions = function (options, columns, frozen, offset) {
            if (options) {
                if (options.columns === undefined) {
                    options.columns = columns;
                }
                if (options.frozen == null) {
                    options.frozen = frozen;
                }
                if (options.offset === undefined) {
                    options.offset = offset;
                }
                if (options.table === undefined) {
                    options.table = this;
                }
                return options;
            }
            return {
                columns: columns,
                frozen: frozen,
                offset: offset,
                table: this
            };
        };
        DTable.prototype.newBody = function (options, columns, frozen, offset) {
            return new DTableBody(this.toBodyOptions(options.body, columns, frozen, offset, options.data));
        };
        DTable.prototype.toBodyOptions = function (options, columns, frozen, offset, data) {
            if (options != null) {
                if (options.columns === undefined) {
                    options.columns = columns;
                }
                if (options.frozen == null) {
                    options.frozen = frozen;
                }
                if (options.offset === undefined) {
                    options.offset = offset;
                }
                if (options.data === undefined && data !== undefined) {
                    if (isArray(data)) {
                        options.data = {
                            rows: data
                        };
                    }
                    else {
                        options.data = data;
                    }
                }
                if (options.height === undefined && options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            if (isArray(data)) {
                return {
                    columns: columns,
                    frozen: frozen,
                    offset: offset,
                    data: {
                        rows: data
                    },
                    weight: 1
                };
            }
            else {
                return {
                    columns: columns,
                    frozen: frozen,
                    offset: offset,
                    data: data,
                    weight: 1
                };
            }
        };
        DTable.prototype.getFocusedChildClippingRect = function (focused, contentX, contentY, contentWidth, contentHeight, width, height, result) {
            _super.prototype.getFocusedChildClippingRect.call(this, focused, contentX, contentY, contentWidth, contentHeight, width, height, result);
            var cell = this.toCell(focused);
            if (cell) {
                // X
                var dx = contentX + this.toFrozenCellX(cell) - result.x;
                if (0 < dx) {
                    result.x += dx;
                    result.width -= dx;
                }
                // Y
                if (cell.parent.parent === this._body) {
                    var dy = this._bodyOffset;
                    result.y += dy;
                    result.height -= dy;
                }
            }
            // Done
            return result;
        };
        DTable.prototype.toFrozenCellX = function (cell) {
            var frozen = this._frozen;
            if (0 < frozen) {
                var cells = cell.parent.children;
                var cellIndex = cells.indexOf(cell);
                if (0 <= cellIndex) {
                    var cellsLength = cells.length;
                    var columnIndex = cellsLength - 1 - cellIndex;
                    if (frozen <= columnIndex) {
                        var cellFrozen = cells[cellsLength - frozen];
                        return cellFrozen.position.x + cellFrozen.width;
                    }
                }
            }
            return 0;
        };
        DTable.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusHorizontally(e, this);
            var isArrowUpKey = UtilKeyboardEvent.isArrowUpKey(e);
            var isArrowDownKey = UtilKeyboardEvent.isArrowDownKey(e);
            if (isArrowUpKey || isArrowDownKey) {
                this.onKeyDownArrowUpOrDown(e, isArrowDownKey);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTable.prototype.onKeyDownArrowUpOrDown = function (e, isDown) {
            var layer = DApplications.getLayer(this);
            if (layer == null) {
                return false;
            }
            var focusController = layer.getFocusController();
            var oldFocusable = focusController.get();
            if (oldFocusable == null) {
                return false;
            }
            var oldCell = this.toCell(oldFocusable);
            if (oldCell == null) {
                return false;
            }
            var oldRow = oldCell.parent;
            if (oldRow == null) {
                return false;
            }
            var newRowChild = focusController.find(oldRow, false, false, isDown, this);
            if (newRowChild == null) {
                return false;
            }
            var newCellSibling = this.toCell(newRowChild);
            if (newCellSibling == null) {
                return false;
            }
            var newRow = newCellSibling.parent;
            if (newRow == null) {
                return false;
            }
            var oldCellIndex = oldRow.children.indexOf(oldCell);
            if (oldCellIndex < 0) {
                return false;
            }
            var newCell = newRow.children[oldCellIndex];
            if (newCell == null || newCell === oldCell || !("state" in newCell)) {
                return false;
            }
            var newFocusable = focusController.find(newCell, true, true, isDown, this);
            if (newFocusable == null) {
                return false;
            }
            focusController.focus(newFocusable);
            return true;
        };
        DTable.prototype.toCell = function (focused) {
            var current = focused;
            while (current != null) {
                var parent_1 = current.parent;
                if (parent_1 instanceof DTableRow) {
                    if (current instanceof DBase) {
                        return current;
                    }
                    return null;
                }
                current = parent_1;
            }
            return null;
        };
        DTable.prototype.getType = function () {
            return "DTable";
        };
        Object.defineProperty(DTable.prototype, "categories", {
            get: function () {
                return this._categories;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "header", {
            get: function () {
                return this._header;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "body", {
            get: function () {
                return this._body;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "data", {
            get: function () {
                return this._body.data;
            },
            enumerable: false,
            configurable: true
        });
        return DTable;
    }(DPane));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLabel$1 = function (item) {
        var text = item.text;
        if (isString(text)) {
            return text;
        }
        var label = item.label;
        if (isString(label)) {
            return label;
        }
        var name = item.name;
        if (isString(name)) {
            return name;
        }
        return undefined;
    };
    var toTitle$1 = function (item) {
        var title = item.title;
        if (isString(title)) {
            return title;
        }
        return undefined;
    };
    var toImage$1 = function (item) {
        return item.image;
    };
    var toChildren$1 = function (item) {
        return item.children;
    };
    var newChildren = function (item) {
        return (item.children = []);
    };
    var DTreeNodeAccessorImpl = /** @class */ (function () {
        function DTreeNodeAccessorImpl(options) {
            var _a, _b, _c, _d, _e;
            this.toLabel = (_a = options === null || options === void 0 ? void 0 : options.toLabel) !== null && _a !== void 0 ? _a : toLabel$1;
            this.toTitle = (_b = options === null || options === void 0 ? void 0 : options.toTitle) !== null && _b !== void 0 ? _b : toTitle$1;
            this.toImage = (_c = options === null || options === void 0 ? void 0 : options.toImage) !== null && _c !== void 0 ? _c : toImage$1;
            this.toChildren = (_d = options === null || options === void 0 ? void 0 : options.toChildren) !== null && _d !== void 0 ? _d : toChildren$1;
            this.newChildren = (_e = options === null || options === void 0 ? void 0 : options.newChildren) !== null && _e !== void 0 ? _e : newChildren;
        }
        return DTreeNodeAccessorImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionType;
    (function (DTreeDataSelectionType) {
        DTreeDataSelectionType[DTreeDataSelectionType["NONE"] = 0] = "NONE";
        DTreeDataSelectionType[DTreeDataSelectionType["SINGLE"] = 1] = "SINGLE";
        DTreeDataSelectionType[DTreeDataSelectionType["MULTIPLE"] = 2] = "MULTIPLE";
    })(DTreeDataSelectionType || (DTreeDataSelectionType = {}));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataMappedImpl = /** @class */ (function () {
        function DTreeDataMappedImpl(parent) {
            this._parent = parent;
            this._nodes = [];
            this._levels = [];
            this._isDirty = false;
        }
        Object.defineProperty(DTreeDataMappedImpl.prototype, "nodes", {
            get: function () {
                this.update();
                return this._nodes;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataMappedImpl.prototype, "levels", {
            get: function () {
                this.update();
                return this._levels;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataMappedImpl.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DTreeDataMappedImpl.prototype.size = function () {
            this.update();
            return this._nodes.length;
        };
        DTreeDataMappedImpl.prototype.each = function (iteratee, from, to) {
            this.update();
            var nodes = this._nodes;
            var ifrom = from != null ? Math.max(0, from) : 0;
            var ito = to != null ? Math.min(nodes.length, to) : nodes.length;
            for (var i = ifrom; i < ito; ++i) {
                if (iteratee(nodes[i], i) === false) {
                    break;
                }
            }
        };
        DTreeDataMappedImpl.prototype.update = function () {
            if (this._isDirty) {
                this._isDirty = false;
                var parent_1 = this._parent;
                var parentNodes = parent_1.nodes;
                var toChildren = parent_1.accessor.toChildren;
                var nodes = this._nodes;
                var levels = this._levels;
                var size = this.newNodes(parent_1, parentNodes, 0, 0, nodes, levels, toChildren);
                if (nodes.length !== size) {
                    nodes.length = size;
                    levels.length = size;
                }
            }
        };
        DTreeDataMappedImpl.prototype.newNodes = function (parent, parentNodes, index, level, nodes, levels, toChildren) {
            for (var i = 0, imax = parentNodes.length; i < imax; ++i) {
                var parentNode = parentNodes[i];
                if (index < nodes.length) {
                    nodes[index] = parentNode;
                    levels[index] = level;
                }
                else {
                    nodes.push(parentNode);
                    levels.push(level);
                }
                index += 1;
                var children = toChildren(parentNode);
                if (children && parent.isExpanded(parentNode)) {
                    index = this.newNodes(parent, children, index, level + 1, nodes, levels, toChildren);
                }
            }
            return index;
        };
        return DTreeDataMappedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionMultiple = /** @class */ (function (_super) {
        __extends(DTreeDataSelectionMultiple, _super);
        function DTreeDataSelectionMultiple(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._nodes = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTreeDataSelectionMultiple.prototype, "type", {
            get: function () {
                return DTreeDataSelectionType.MULTIPLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionMultiple.prototype, "first", {
            get: function () {
                var nodes = this._nodes;
                if (0 < nodes.size) {
                    var result_1 = null;
                    nodes.forEach(function (item) {
                        if (result_1 == null) {
                            result_1 = item;
                        }
                    });
                    return result_1;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionMultiple.prototype, "last", {
            get: function () {
                var nodes = this._nodes;
                if (0 < nodes.size) {
                    var result_2 = null;
                    nodes.forEach(function (row) {
                        result_2 = row;
                    });
                    return result_2;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataSelectionMultiple.prototype.get = function (index) {
            var nodes = this._nodes;
            if (0 <= index && index < nodes.size) {
                var counter_1 = 0;
                var result_3 = null;
                nodes.forEach(function (node) {
                    if (counter_1 === index) {
                        result_3 = node;
                    }
                    counter_1 += 1;
                });
                return result_3;
            }
            return null;
        };
        DTreeDataSelectionMultiple.prototype.add = function (target) {
            var nodes = this._nodes;
            if (!nodes.has(target)) {
                nodes.add(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionMultiple.prototype.remove = function (target) {
            var nodes = this._nodes;
            if (nodes.has(target)) {
                nodes.delete(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionMultiple.prototype.toggle = function (target) {
            var nodes = this._nodes;
            if (nodes.has(target)) {
                nodes.delete(target);
            }
            else {
                nodes.add(target);
            }
            this.onChange();
            return true;
        };
        DTreeDataSelectionMultiple.prototype.clear = function () {
            var nodes = this._nodes;
            if (0 < nodes.size) {
                nodes.clear();
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionMultiple.prototype.clearAndAdd = function (target) {
            var nodes = this._nodes;
            var size = nodes.size;
            if (size === 1) {
                if (nodes.has(target)) {
                    return false;
                }
                else {
                    nodes.clear();
                    nodes.add(target);
                    this.onChange();
                    return true;
                }
            }
            else {
                nodes.clear();
                nodes.add(target);
                this.onChange();
                return true;
            }
        };
        DTreeDataSelectionMultiple.prototype.clearAndAddAll = function (targets) {
            var isDirty = false;
            var newNodes = new Set();
            var oldNodes = this._nodes;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var target = targets[i];
                if (!oldNodes.has(target)) {
                    isDirty = true;
                }
                newNodes.add(target);
            }
            if (!isDirty) {
                oldNodes.forEach(function (oldItem) {
                    if (!newNodes.has(oldItem)) {
                        isDirty = true;
                    }
                });
            }
            if (isDirty) {
                this._nodes = newNodes;
                this.onChange();
            }
            return isDirty;
        };
        DTreeDataSelectionMultiple.prototype.contains = function (target) {
            return this._nodes.has(target);
        };
        DTreeDataSelectionMultiple.prototype.size = function () {
            return this._nodes.size;
        };
        DTreeDataSelectionMultiple.prototype.isEmpty = function () {
            return this._nodes.size <= 0;
        };
        DTreeDataSelectionMultiple.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._nodes.forEach(function (item) {
                if (!isCanceled) {
                    if (iteratee(item) === false) {
                        isCanceled = true;
                    }
                }
            });
        };
        DTreeDataSelectionMultiple.prototype.toArray = function () {
            var result = [];
            this._nodes.forEach(function (item) {
                result.push(item);
            });
            return result;
        };
        DTreeDataSelectionMultiple.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTreeDataSelectionMultiple.prototype.onNodeChange = function (nodes) {
            var oldNodes = this._nodes;
            var newNodes = this.newNodes(nodes, oldNodes, new Set());
            if (oldNodes.size !== newNodes.size) {
                this._nodes = newNodes;
                this.onChange();
            }
        };
        DTreeDataSelectionMultiple.prototype.newNodes = function (items, existing, result) {
            var toChildren = this._parent.accessor.toChildren;
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (existing.has(item)) {
                    result.add(item);
                }
                var children = toChildren(item);
                if (children) {
                    this.newNodes(children, existing, result);
                }
            }
            return result;
        };
        return DTreeDataSelectionMultiple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionSingle = /** @class */ (function (_super) {
        __extends(DTreeDataSelectionSingle, _super);
        function DTreeDataSelectionSingle(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._node = null;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTreeDataSelectionSingle.prototype, "type", {
            get: function () {
                return DTreeDataSelectionType.SINGLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionSingle.prototype, "first", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionSingle.prototype, "last", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataSelectionSingle.prototype.get = function (index) {
            if (index === 0) {
                return this._node;
            }
            return null;
        };
        DTreeDataSelectionSingle.prototype.add = function (target) {
            if (this._node !== target) {
                this._node = target;
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionSingle.prototype.remove = function (target) {
            if (this._node === target) {
                this._node = null;
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionSingle.prototype.toggle = function (target) {
            if (this._node === target) {
                this._node = null;
            }
            else {
                this._node = target;
            }
            this.onChange();
            return true;
        };
        DTreeDataSelectionSingle.prototype.clear = function () {
            if (this._node != null) {
                this._node = null;
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionSingle.prototype.clearAndAdd = function (target) {
            if (this._node === target) {
                return false;
            }
            else {
                this._node = target;
                this.onChange();
                return true;
            }
        };
        DTreeDataSelectionSingle.prototype.clearAndAddAll = function (targets) {
            if (0 < targets.length) {
                var last = targets[targets.length - 1];
                return this.clearAndAdd(last);
            }
            else {
                return this.clear();
            }
        };
        DTreeDataSelectionSingle.prototype.contains = function (target) {
            return this._node === target;
        };
        DTreeDataSelectionSingle.prototype.size = function () {
            return this._node != null ? 1 : 0;
        };
        DTreeDataSelectionSingle.prototype.isEmpty = function () {
            return this._node == null;
        };
        DTreeDataSelectionSingle.prototype.each = function (iteratee) {
            var node = this._node;
            if (node != null) {
                iteratee(node);
            }
        };
        DTreeDataSelectionSingle.prototype.toArray = function () {
            var node = this._node;
            if (node != null) {
                return [node];
            }
            return [];
        };
        DTreeDataSelectionSingle.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTreeDataSelectionSingle.prototype.onNodeChange = function (nodes) {
            var oldNode = this._node;
            var newNode = this.newNode(nodes, oldNode);
            if (oldNode !== newNode) {
                this._node = newNode;
                this.onChange();
            }
        };
        DTreeDataSelectionSingle.prototype.newNode = function (items, existing) {
            var toChildren = this._parent.accessor.toChildren;
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (existing === item) {
                    return item;
                }
                var children = toChildren(item);
                if (children) {
                    var result = this.newNode(children, existing);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        return DTreeDataSelectionSingle;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionNone = /** @class */ (function (_super) {
        __extends(DTreeDataSelectionNone, _super);
        function DTreeDataSelectionNone(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTreeDataSelectionNone.prototype, "type", {
            get: function () {
                return DTreeDataSelectionType.NONE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionNone.prototype, "first", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionNone.prototype, "last", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataSelectionNone.prototype.get = function (index) {
            return null;
        };
        DTreeDataSelectionNone.prototype.add = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.remove = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.toggle = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.clear = function () {
            return false;
        };
        DTreeDataSelectionNone.prototype.clearAndAdd = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.clearAndAddAll = function (targets) {
            return false;
        };
        DTreeDataSelectionNone.prototype.contains = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.size = function () {
            return 0;
        };
        DTreeDataSelectionNone.prototype.isEmpty = function () {
            return true;
        };
        DTreeDataSelectionNone.prototype.each = function (iteratee) {
            // DO NOTHING
        };
        DTreeDataSelectionNone.prototype.toArray = function () {
            return [];
        };
        DTreeDataSelectionNone.prototype.onNodeChange = function (nodes) {
            // DO NOTHING
        };
        return DTreeDataSelectionNone;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataImpl = /** @class */ (function () {
        function DTreeDataImpl(parent, options) {
            this._parent = parent;
            this._nodeToFlag = new WeakMap();
            this._selection = this.toSelection(options);
            this._accessor = new DTreeNodeAccessorImpl(options);
            var mapped = new DTreeDataMappedImpl(this);
            this._mapped = mapped;
            var nodes = options === null || options === void 0 ? void 0 : options.nodes;
            if (nodes != null) {
                this._nodes = nodes;
                mapped.toDirty();
            }
            else {
                this._nodes = [];
            }
        }
        DTreeDataImpl.prototype.toSelection = function (options) {
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            switch (selection === null || selection === void 0 ? void 0 : selection.type) {
                case DTreeDataSelectionType.NONE:
                case "NONE":
                    return new DTreeDataSelectionNone(this, selection);
                case DTreeDataSelectionType.MULTIPLE:
                case "MULTIPLE":
                    return new DTreeDataSelectionMultiple(this, selection);
                default:
                    return new DTreeDataSelectionSingle(this, selection);
            }
        };
        Object.defineProperty(DTreeDataImpl.prototype, "nodes", {
            get: function () {
                return this._nodes;
            },
            set: function (nodes) {
                this._nodes = nodes;
                this._mapped.toDirty();
                this._selection.onNodeChange(nodes);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataImpl.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataImpl.prototype, "accessor", {
            get: function () {
                return this._accessor;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataImpl.prototype.update = function () {
            this._parent.update();
        };
        DTreeDataImpl.prototype.toggle = function (target) {
            var nodeToFlag = this._nodeToFlag;
            if (nodeToFlag.has(target)) {
                nodeToFlag.delete(target);
            }
            else {
                nodeToFlag.set(target, 1);
            }
            this._mapped.toDirty();
            this.update();
            return true;
        };
        DTreeDataImpl.prototype.expand = function (target) {
            var nodeToFlag = this._nodeToFlag;
            if (!nodeToFlag.has(target)) {
                nodeToFlag.set(target, 1);
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.collapse = function (target) {
            var nodeToFlag = this._nodeToFlag;
            if (nodeToFlag.has(target)) {
                nodeToFlag.delete(target);
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.expandAll = function () {
            var isDirty = false;
            var nodeToFlag = this._nodeToFlag;
            this.each(function (node) {
                if (!nodeToFlag.has(node)) {
                    nodeToFlag.set(node, 1);
                    isDirty = true;
                }
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.collapseAll = function () {
            var isDirty = false;
            var nodeToFlag = this._nodeToFlag;
            this.each(function (node) {
                if (nodeToFlag.has(node)) {
                    nodeToFlag.delete(node);
                    isDirty = true;
                }
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.isCollapsed = function (target) {
            return !this.isExpanded(target);
        };
        DTreeDataImpl.prototype.isExpanded = function (target) {
            return this._nodeToFlag.has(target);
        };
        DTreeDataImpl.prototype.clear = function () {
            var nodes = this._nodes;
            if (0 < nodes.length) {
                nodes.length = 0;
                this._mapped.toDirty();
                this._selection.clear();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.remove = function (target) {
            var isDirty = false;
            this.each(function (node, index, nodes) {
                if (node === target) {
                    nodes.splice(index, 1);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this._selection.remove(target);
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.add = function (target, parent) {
            var isDirty = false;
            if (parent) {
                var accessor = this._accessor;
                var children = accessor.toChildren(parent);
                if (children) {
                    children.push(target);
                    isDirty = true;
                }
                else {
                    var newChildren = accessor.newChildren(parent);
                    if (newChildren) {
                        newChildren.push(target);
                        isDirty = true;
                    }
                }
            }
            else {
                var nodes = this._nodes;
                if (nodes) {
                    nodes.push(target);
                }
                else {
                    this._nodes = [target];
                }
                isDirty = true;
            }
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return true;
        };
        DTreeDataImpl.prototype.addBefore = function (target, sibling) {
            var isDirty = false;
            this.each(function (node, index, nodes) {
                if (node === sibling) {
                    nodes.splice(index, 0, target);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return isDirty;
        };
        DTreeDataImpl.prototype.addAfter = function (target, sibling) {
            var isDirty = false;
            this.each(function (node, index, nodes) {
                if (node === sibling) {
                    nodes.splice(index + 1, 0, target);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return isDirty;
        };
        DTreeDataImpl.prototype.each = function (iteratee) {
            var value = this._nodes;
            if (value) {
                this.each_(value, null, iteratee);
            }
        };
        DTreeDataImpl.prototype.each_ = function (nodes, parent, iteratee) {
            var toChildren = this._accessor.toChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (iteratee(node, i, nodes, parent) === false) {
                    return;
                }
                var children = toChildren(node);
                if (children) {
                    this.each_(children, node, iteratee);
                }
            }
        };
        return DTreeDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Tree item states.
     */
    var DTreeItemState = {
        /**
         * A node has children.
         */
        HAS_CHILDREN: "HAS_CHILDREN",
        /**
         * A node is opened.
         */
        OPENED: "OPENED"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemText = /** @class */ (function (_super) {
        __extends(DTreeItemText, _super);
        function DTreeItemText(data, options) {
            var _this = _super.call(this, options) || this;
            _this._padding = new DBasePaddingAdjustable(_this._padding);
            _this._data = data;
            _this.state.isDisabled = true;
            return _this;
        }
        Object.defineProperty(DTreeItemText.prototype, "node", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeItemText.prototype, "value", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeItemText.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeItemText.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        DTreeItemText.prototype.toggle = function () {
            var node = this._node;
            if (node !== undefined) {
                this._data.toggle(node);
            }
        };
        DTreeItemText.prototype.set = function (node, index, forcibly) {
            var _a;
            var data = this._data;
            var isNodeChanged = forcibly || this._node !== node;
            if (isNodeChanged) {
                this._node = node;
                this._index = index;
                var accessor = data.accessor;
                this.text = accessor.toLabel(node);
                this.title = (_a = accessor.toTitle(node)) !== null && _a !== void 0 ? _a : "";
                this.image = accessor.toImage(node);
            }
            var level = data.mapped.levels[index];
            this._padding.adjLeft(this.theme.getLevelPadding(level));
            var children = data.accessor.toChildren(node);
            var hasChildren = !!(children && 0 < children.length);
            var state = this.state;
            state.lock();
            state.set(DBaseState.ACTIVE, data.selection.contains(node));
            state.remove(DBaseState.DISABLED);
            state.set(DTreeItemState.HAS_CHILDREN, hasChildren);
            state.set(DTreeItemState.OPENED, data.isExpanded(node));
            state.unlock();
            if (isNodeChanged) {
                this.emit("set", node, index, this);
            }
        };
        DTreeItemText.prototype.unset = function () {
            if (this._node !== undefined) {
                this._node = undefined;
                this._index = undefined;
                this.text = undefined;
                this.title = "";
                this.image = undefined;
                var state = this.state;
                state.lock();
                state.add(DBaseState.DISABLED);
                state.remove(DBaseState.ACTIVE);
                state.unlock();
                this.emit("unset", this);
            }
        };
        DTreeItemText.prototype.onSelect = function (e, value) {
            var data = this._data;
            var selection = data.selection;
            if (selection.type !== DTreeDataSelectionType.MULTIPLE) {
                selection.clearAndAdd(value);
            }
            else {
                var originalEvent = e && "data" in e ? e.data.originalEvent : e;
                if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.ctrlKey) {
                    selection.toggle(value);
                }
                else if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.shiftKey) {
                    var mapped = data.mapped;
                    var last_1 = selection.last;
                    if (value === last_1) {
                        selection.clearAndAdd(value);
                    }
                    else {
                        var isFound_1 = false;
                        var isReverse_1 = false;
                        var newSelection_1 = [];
                        mapped.each(function (node) {
                            if (isFound_1) {
                                if (isReverse_1) {
                                    newSelection_1.unshift(node);
                                    if (node === value) {
                                        return false;
                                    }
                                }
                                else {
                                    newSelection_1.push(node);
                                    if (node === last_1) {
                                        return false;
                                    }
                                }
                            }
                            else {
                                if (node === value) {
                                    isFound_1 = true;
                                    isReverse_1 = false;
                                    newSelection_1.push(node);
                                }
                                else if (node === last_1) {
                                    isFound_1 = true;
                                    isReverse_1 = true;
                                    newSelection_1.push(node);
                                }
                            }
                        });
                        selection.clearAndAddAll(newSelection_1);
                    }
                }
                else {
                    selection.clearAndAdd(value);
                }
            }
        };
        DTreeItemText.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                var node = this._node;
                if (node !== undefined) {
                    if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                        this._data.expand(node);
                    }
                }
            }
            if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                var node = this._node;
                if (node !== undefined) {
                    if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                        this._data.collapse(node);
                    }
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTreeItemText.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                var node = this._node;
                if (node !== undefined) {
                    this.onSelect(e, node);
                }
                return true;
            }
            return false;
        };
        DTreeItemText.prototype.getType = function () {
            return "DTreeItemText";
        };
        return DTreeItemText;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemButton = /** @class */ (function (_super) {
        __extends(DTreeItemButton, _super);
        function DTreeItemButton(data, options) {
            var _a;
            var _this = _super.call(this, data, options) || this;
            var when = toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : DButtonBaseWhen.CLICKED, DButtonBaseWhen);
            _this._when = when;
            _this.initOnClick(when, _this.theme, options);
            return _this;
        }
        DTreeItemButton.prototype.initOnClick = function (when, theme, options) {
            var _this = this;
            UtilPointerEvent.onClick(this, function (e) {
                if (when === DButtonBaseWhen.CLICKED) {
                    _this.onClick(e);
                }
            });
        };
        DTreeItemButton.prototype.onClick = function (e) {
            if (this.state.isActionable) {
                this.onActivate(e);
            }
        };
        DTreeItemButton.prototype.onDblClick = function (e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED) {
                this.onClick(e);
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DTreeItemButton.prototype.onActivate = function (e) {
            this.emit("active", this);
        };
        DTreeItemButton.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        };
        DTreeItemButton.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.onActivate(e);
                }
                this.state.isPressed = false;
            }
        };
        DTreeItemButton.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTreeItemButton.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTreeItemButton.prototype.getType = function () {
            return "DTreeItemButton";
        };
        return DTreeItemButton;
    }(DTreeItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemNonEditable = /** @class */ (function (_super) {
        __extends(DTreeItemNonEditable, _super);
        function DTreeItemNonEditable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTreeItemNonEditable.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            var node = this._node;
            if (node !== undefined) {
                if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                    if (e && "data" in e) {
                        var local = this.toLocal(e.data.global, undefined, DTreeItemNonEditable.WORK_CONTAINS_POINT);
                        if (local.x <= this.padding.getLeft()) {
                            this.toggle();
                        }
                        else {
                            this.onSelect(e, node);
                        }
                    }
                }
                else {
                    this.onSelect(e, node);
                }
            }
        };
        DTreeItemNonEditable.prototype.getType = function () {
            return "DTreeItemNonEditable";
        };
        return DTreeItemNonEditable;
    }(DTreeItemButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemUpdater = /** @class */ (function (_super) {
        __extends(DTreeItemUpdater, _super);
        function DTreeItemUpdater() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTreeItemUpdater.prototype.toMapped = function (data) {
            return data.mapped;
        };
        DTreeItemUpdater.prototype.newItem = function (data) {
            return new DTreeItemNonEditable(data);
        };
        return DTreeItemUpdater;
    }(DItemUpdater));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTree = /** @class */ (function (_super) {
        __extends(DTree, _super);
        function DTree(options) {
            var _this = _super.call(this, options) || this;
            var content = _this._content;
            content.on("move", function () {
                _this.update();
            });
            content.on("resize", function () {
                _this.update();
            });
            var data = _this.toData(options);
            _this._data = data;
            _this._updater = _this.newUpdater(data, content, options);
            _this.update();
            return _this;
        }
        DTree.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var updater = this._updater;
            if (updater) {
                updater.lock();
                _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
                updater.update();
                updater.unlock(true);
            }
            else {
                _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            }
        };
        DTree.prototype.newUpdater = function (data, content, options) {
            return new DTreeItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        };
        DTree.prototype.toData = function (options) {
            var data = (options && (options.data || options.nodes || options.value)) || [];
            if (isArray(data)) {
                return new DTreeDataImpl(this, {
                    nodes: data
                });
            }
            else if ("add" in data) {
                return data;
            }
            else {
                return new DTreeDataImpl(this, data);
            }
        };
        DTree.prototype.update = function (forcibly) {
            this._updater.update(forcibly);
        };
        DTree.prototype.lock = function () {
            this._updater.lock();
        };
        DTree.prototype.unlock = function (callIfNeeded) {
            this._updater.unlock(callIfNeeded);
        };
        Object.defineProperty(DTree.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTree.prototype, "selection", {
            get: function () {
                return this._data.selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTree.prototype, "value", {
            get: function () {
                return this._data.nodes;
            },
            set: function (value) {
                this._data.nodes = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTree.prototype, "nodes", {
            get: function () {
                return this._data.nodes;
            },
            set: function (nodes) {
                this._data.nodes = nodes;
            },
            enumerable: false,
            configurable: true
        });
        DTree.prototype.toggle = function (target) {
            return this._data.toggle(target);
        };
        DTree.prototype.expand = function (target) {
            return this._data.expand(target);
        };
        DTree.prototype.collapse = function (target) {
            return this._data.collapse(target);
        };
        DTree.prototype.expandAll = function () {
            return this._data.expandAll();
        };
        DTree.prototype.collapseAll = function () {
            return this._data.collapseAll();
        };
        DTree.prototype.isCollapsed = function (target) {
            return this._data.isCollapsed(target);
        };
        DTree.prototype.isExpanded = function (target) {
            return this._data.isExpanded(target);
        };
        DTree.prototype.clear = function () {
            return this._data.clear();
        };
        DTree.prototype.remove = function (target) {
            return this._data.remove(target);
        };
        DTree.prototype.add = function (target, parent) {
            return this._data.add(target, parent);
        };
        DTree.prototype.addBefore = function (target, sibling) {
            return this._data.addBefore(target, sibling);
        };
        DTree.prototype.addAfter = function (target, sibling) {
            return this._data.addAfter(target, sibling);
        };
        DTree.prototype.each = function (iteratee) {
            return this._data.each(iteratee);
        };
        DTree.prototype.onKeyDown = function (e) {
            this._updater.moveFocus(e, this, true, false);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTree.prototype.getType = function () {
            return "DTree";
        };
        return DTree;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */

    var ui = {
        __proto__: null,
        loadAll: loadAll,
        loadMenuItemAll: loadMenuItemAll,
        loadMenuItemExpandable: loadMenuItemExpandable,
        loadMenuItem: loadMenuItem,
        loadMenuSidedItemExpandable: loadMenuSidedItemExpandable,
        loadMenuSidedItem: loadMenuSidedItem,
        EShapeActionBases: EShapeActionBases,
        EShapeActionExpressions: EShapeActionExpressions,
        EShapeActionRuntimeBlinkBrighten: EShapeActionRuntimeBlinkBrighten,
        EShapeActionRuntimeBlinkColorFill: EShapeActionRuntimeBlinkColorFill,
        EShapeActionRuntimeBlinkColorStroke: EShapeActionRuntimeBlinkColorStroke,
        EShapeActionRuntimeBlinkDarken: EShapeActionRuntimeBlinkDarken,
        EShapeActionRuntimeBlinkOpacity: EShapeActionRuntimeBlinkOpacity,
        EShapeActionRuntimeBlinkVisibility: EShapeActionRuntimeBlinkVisibility,
        EShapeActionRuntimeBlink: EShapeActionRuntimeBlink,
        EShapeActionRuntimeChangeColorBrightness: EShapeActionRuntimeChangeColorBrightness,
        EShapeActionRuntimeChangeColorCode: EShapeActionRuntimeChangeColorCode,
        EShapeActionRuntimeChangeColor: EShapeActionRuntimeChangeColor,
        EShapeActionRuntimeChangeCursor: EShapeActionRuntimeChangeCursor,
        EShapeActionRuntimeChangeTextNumber: EShapeActionRuntimeChangeTextNumber,
        EShapeActionRuntimeChangeTextText: EShapeActionRuntimeChangeTextText,
        EShapeActionRuntimeConditional: EShapeActionRuntimeConditional,
        EShapeActionRuntimeEmitEvent: EShapeActionRuntimeEmitEvent,
        EShapeActionRuntimeMiscEmitEvent: EShapeActionRuntimeMiscEmitEvent,
        EShapeActionRuntimeMiscHtmlElement: EShapeActionRuntimeMiscHtmlElement,
        EShapeActionRuntimeMiscInputInteger: EShapeActionRuntimeMiscInputInteger,
        EShapeActionRuntimeMiscInputReal: EShapeActionRuntimeMiscInputReal,
        EShapeActionRuntimeMiscInputText: EShapeActionRuntimeMiscInputText,
        EShapeActionRuntimeMiscInput: EShapeActionRuntimeMiscInput,
        EShapeActionRuntimeMiscWriteBoth: EShapeActionRuntimeMiscWriteBoth,
        EShapeActionRuntimeMiscWriteLocal: EShapeActionRuntimeMiscWriteLocal,
        EShapeActionRuntimeMiscWriteRemote: EShapeActionRuntimeMiscWriteRemote,
        EShapeActionRuntimeMiscWrite: EShapeActionRuntimeMiscWrite,
        EShapeActionRuntimeOpenDiagram: EShapeActionRuntimeOpenDiagram,
        EShapeActionRuntimeOpenDialogBoolean: EShapeActionRuntimeOpenDialogBoolean,
        EShapeActionRuntimeOpenDialogInteger: EShapeActionRuntimeOpenDialogInteger,
        EShapeActionRuntimeOpenDialogReal: EShapeActionRuntimeOpenDialogReal,
        EShapeActionRuntimeOpenDialogText: EShapeActionRuntimeOpenDialogText,
        EShapeActionRuntimeOpenDialog: EShapeActionRuntimeOpenDialog,
        EShapeActionRuntimeOpenPageInplace: EShapeActionRuntimeOpenPageInplace,
        EShapeActionRuntimeOpenPage: EShapeActionRuntimeOpenPage,
        EShapeActionRuntimeOpen: EShapeActionRuntimeOpen,
        EShapeActionRuntimeShowHide: EShapeActionRuntimeShowHide,
        EShapeActionRuntimeTransformMoveAbsoluteX: EShapeActionRuntimeTransformMoveAbsoluteX,
        EShapeActionRuntimeTransformMoveAbsoluteY: EShapeActionRuntimeTransformMoveAbsoluteY,
        EShapeActionRuntimeTransformMoveForwardOrBackward: EShapeActionRuntimeTransformMoveForwardOrBackward,
        EShapeActionRuntimeTransformMoveLeftOrRight: EShapeActionRuntimeTransformMoveLeftOrRight,
        EShapeActionRuntimeTransformMoveRelativeX: EShapeActionRuntimeTransformMoveRelativeX,
        EShapeActionRuntimeTransformMoveRelativeY: EShapeActionRuntimeTransformMoveRelativeY,
        EShapeActionRuntimeTransformMove: EShapeActionRuntimeTransformMove,
        EShapeActionRuntimeTransformResizeHeightAbsolute: EShapeActionRuntimeTransformResizeHeightAbsolute,
        EShapeActionRuntimeTransformResizeHeightRelative: EShapeActionRuntimeTransformResizeHeightRelative,
        EShapeActionRuntimeTransformResizeSizeAbsolute: EShapeActionRuntimeTransformResizeSizeAbsolute,
        EShapeActionRuntimeTransformResizeSizeRelative: EShapeActionRuntimeTransformResizeSizeRelative,
        EShapeActionRuntimeTransformResizeWidthAbsolute: EShapeActionRuntimeTransformResizeWidthAbsolute,
        EShapeActionRuntimeTransformResizeWidthRelative: EShapeActionRuntimeTransformResizeWidthRelative,
        EShapeActionRuntimeTransformResize: EShapeActionRuntimeTransformResize,
        EShapeActionRuntimeTransformRotateAbsolute: EShapeActionRuntimeTransformRotateAbsolute,
        EShapeActionRuntimeTransformRotateRelative: EShapeActionRuntimeTransformRotateRelative,
        EShapeActionRuntimeTransformRotate: EShapeActionRuntimeTransformRotate,
        EShapeActionRuntime: EShapeActionRuntime,
        EShapeActionRuntimes: EShapeActionRuntimes,
        EShapeActionValueBase: EShapeActionValueBase,
        get EShapeActionValueBlinkType () { return EShapeActionValueBlinkType; },
        EShapeActionValueBlink: EShapeActionValueBlink,
        EShapeActionValueChangeColorBrightness: EShapeActionValueChangeColorBrightness,
        EShapeActionValueChangeColorCode: EShapeActionValueChangeColorCode,
        get EShapeActionValueChangeColorTarget () { return EShapeActionValueChangeColorTarget; },
        get EShapeActionValueChangeColorTypeLegacy () { return EShapeActionValueChangeColorTypeLegacy; },
        get EShapeActionValueChangeColorType () { return EShapeActionValueChangeColorType; },
        EShapeActionValueChangeColorTypes: EShapeActionValueChangeColorTypes,
        EShapeActionValueChangeColor: EShapeActionValueChangeColor,
        EShapeActionValueChangeCursor: EShapeActionValueChangeCursor,
        get EShapeActionValueChangeTextType () { return EShapeActionValueChangeTextType; },
        EShapeActionValueChangeText: EShapeActionValueChangeText,
        EShapeActionValueDeserializer: EShapeActionValueDeserializer,
        EShapeActionValueEmitEvent: EShapeActionValueEmitEvent,
        EShapeActionValueMiscEmitEvent: EShapeActionValueMiscEmitEvent,
        EShapeActionValueMiscHtmlElement: EShapeActionValueMiscHtmlElement,
        EShapeActionValueMiscInput: EShapeActionValueMiscInput,
        get EShapeActionValueMiscType () { return EShapeActionValueMiscType; },
        EShapeActionValueMiscWrite: EShapeActionValueMiscWrite,
        EShapeActionValueMisc: EShapeActionValueMisc,
        get EShapeActionValueOnInputAction () { return EShapeActionValueOnInputAction; },
        EShapeActionValueOnInputActions: EShapeActionValueOnInputActions,
        get EShapeActionValueOpenType () { return EShapeActionValueOpenType; },
        EShapeActionValueOpen: EShapeActionValueOpen,
        EShapeActionValueOpetyped: EShapeActionValueOpetyped,
        get EShapeActionValueShowHideType () { return EShapeActionValueShowHideType; },
        EShapeActionValueShowHide: EShapeActionValueShowHide,
        EShapeActionValueSubtyped: EShapeActionValueSubtyped,
        get EShapeActionValueTransformMoveType () { return EShapeActionValueTransformMoveType; },
        EShapeActionValueTransformMove: EShapeActionValueTransformMove,
        get EShapeActionValueTransformResizeType () { return EShapeActionValueTransformResizeType; },
        EShapeActionValueTransformResize: EShapeActionValueTransformResize,
        get EShapeActionValueTransformRotateType () { return EShapeActionValueTransformRotateType; },
        EShapeActionValueTransformRotate: EShapeActionValueTransformRotate,
        get EShapeActionValueTransformType () { return EShapeActionValueTransformType; },
        get EShapeActionValueType () { return EShapeActionValueType; },
        EShapeActionValues: EShapeActionValues,
        EShapeAction: EShapeAction,
        loadShapeAll: loadShapeAll,
        loadShapeBar: loadShapeBar,
        loadShapeCircle: loadShapeCircle,
        loadShapeEmbedded: loadShapeEmbedded,
        loadShapeGroupShadowed: loadShapeGroupShadowed,
        loadShapeGroup: loadShapeGroup,
        loadShapeImage: loadShapeImage,
        loadShapeLabel: loadShapeLabel,
        loadShapeLineOfCircles: loadShapeLineOfCircles,
        loadShapeLineOfRectangleRoundeds: loadShapeLineOfRectangleRoundeds,
        loadShapeLineOfRectangles: loadShapeLineOfRectangles,
        loadShapeLineOfTriangleRoundeds: loadShapeLineOfTriangleRoundeds,
        loadShapeLineOfTriangles: loadShapeLineOfTriangles,
        loadShapeLine: loadShapeLine,
        loadShapeNull: loadShapeNull,
        loadShapeRectangleRounded: loadShapeRectangleRounded,
        loadShapeRectangle: loadShapeRectangle,
        loadShapeTriangleRounded: loadShapeTriangleRounded,
        loadShapeTriangle: loadShapeTriangle,
        BAR_VERTEX_COUNT: BAR_VERTEX_COUNT,
        BAR_INDEX_COUNT: BAR_INDEX_COUNT,
        buildBarClipping: buildBarClipping,
        buildBarIndex: buildBarIndex,
        buildBarVertexStepAndColorFill: buildBarVertexStepAndColorFill,
        buildBarUv: buildBarUv,
        CIRCLE_VERTEX_COUNT: CIRCLE_VERTEX_COUNT,
        CIRCLE_INDEX_COUNT: CIRCLE_INDEX_COUNT,
        CIRCLE_WORLD_SIZE: CIRCLE_WORLD_SIZE,
        buildCircleClipping: buildCircleClipping,
        buildCircleIndex: buildCircleIndex,
        buildCircleVertex: buildCircleVertex,
        buildCircleStep: buildCircleStep,
        buildCircleUv: buildCircleUv,
        buildColor: buildColor,
        IMAGE_SDF_VERTEX_COUNT: IMAGE_SDF_VERTEX_COUNT,
        IMAGE_SDF_INDEX_COUNT: IMAGE_SDF_INDEX_COUNT,
        IMAGE_SDF_WORLD_SIZE: IMAGE_SDF_WORLD_SIZE,
        buildImageSdfClipping: buildImageSdfClipping,
        buildImageSdfIndex: buildImageSdfIndex,
        buildImageSdfStep: buildImageSdfStep,
        buildImageSdfVertex: buildImageSdfVertex,
        buildImageSdfUv: buildImageSdfUv,
        toLineOfAnyPointCount: toLineOfAnyPointCount,
        buildLineOfAnyColor: buildLineOfAnyColor,
        toPointsCount: toPointsCount,
        toLinePointCount: toLinePointCount,
        toLineVertexCount: toLineVertexCount,
        toLineIndexCount: toLineIndexCount,
        buildLineClipping: buildLineClipping,
        buildLineIndex: buildLineIndex,
        buildLineUv: buildLineUv,
        buildLineVertexStepAndColorFill: buildLineVertexStepAndColorFill,
        buildNullClipping: buildNullClipping,
        buildNullIndex: buildNullIndex,
        buildNullVertex: buildNullVertex,
        buildNullStep: buildNullStep,
        buildNullUv: buildNullUv,
        RECTANGLE_ROUNDED_VERTEX_COUNT: RECTANGLE_ROUNDED_VERTEX_COUNT,
        RECTANGLE_ROUNDED_INDEX_COUNT: RECTANGLE_ROUNDED_INDEX_COUNT,
        RECTANGLE_ROUNDED_WORLD_SIZE: RECTANGLE_ROUNDED_WORLD_SIZE,
        buildRectangleRoundedIndex: buildRectangleRoundedIndex,
        buildRectangleRoundedVertex: buildRectangleRoundedVertex,
        buildRectangleRoundedClipping: buildRectangleRoundedClipping,
        buildRectangleRoundedStep: buildRectangleRoundedStep,
        buildRectangleRoundedUv: buildRectangleRoundedUv,
        RECTANGLE_VERTEX_COUNT: RECTANGLE_VERTEX_COUNT,
        RECTANGLE_INDEX_COUNT: RECTANGLE_INDEX_COUNT,
        RECTANGLE_WORLD_SIZE: RECTANGLE_WORLD_SIZE,
        buildRectangleClipping: buildRectangleClipping,
        buildRectangleIndex: buildRectangleIndex,
        buildRectangleVertex: buildRectangleVertex,
        buildRectangleStep: buildRectangleStep,
        buildRectangleUv: buildRectangleUv,
        TEXT_VERTEX_COUNT: TEXT_VERTEX_COUNT,
        TEXT_INDEX_COUNT: TEXT_INDEX_COUNT,
        toTextBufferCount: toTextBufferCount,
        buildTextClipping: buildTextClipping,
        buildTextIndex: buildTextIndex,
        buildTextStep: buildTextStep,
        buildTextVertex: buildTextVertex,
        TRIANGLE_ROUNDED_VERTEX_COUNT: TRIANGLE_ROUNDED_VERTEX_COUNT,
        TRIANGLE_ROUNDED_INDEX_COUNT: TRIANGLE_ROUNDED_INDEX_COUNT,
        TRIANGLE_ROUNDED_WORLD_SIZE: TRIANGLE_ROUNDED_WORLD_SIZE,
        buildTriangleRoundedIndex: buildTriangleRoundedIndex,
        buildTriangleRoundedVertex: buildTriangleRoundedVertex,
        buildTriangleRoundedClipping: buildTriangleRoundedClipping,
        buildTriangleRoundedStep: buildTriangleRoundedStep,
        buildTriangleRoundedUv: buildTriangleRoundedUv,
        TRIANGLE_VERTEX_COUNT: TRIANGLE_VERTEX_COUNT,
        TRIANGLE_INDEX_COUNT: TRIANGLE_INDEX_COUNT,
        TRIANGLE_WORLD_SIZE: TRIANGLE_WORLD_SIZE,
        buildTriangleClipping: buildTriangleClipping,
        buildTriangleIndex: buildTriangleIndex,
        buildTriangleVertex: buildTriangleVertex,
        buildTriangleStep: buildTriangleStep,
        buildTriangleUv: buildTriangleUv,
        copyClipping: copyClipping,
        copyIndex: copyIndex,
        copyStep: copyStep,
        copyUvs: copyUvs,
        copyVertex: copyVertex,
        createBarUploaded: createBarUploaded,
        createCircle: createCircle,
        createGroupUploaded: createGroupUploaded,
        createImageSdfUploaded: createImageSdfUploaded,
        createImageSdf: createImageSdf,
        createImage: createImage,
        createLabelUploaded: createLabelUploaded,
        createLineOfAnyUploaded: createLineOfAnyUploaded,
        createLineOfCirclesUploaded: createLineOfCirclesUploaded,
        createLineOfRectangleRoundedsUploaded: createLineOfRectangleRoundedsUploaded,
        createLineOfRectanglesUploaded: createLineOfRectanglesUploaded,
        createLineOfTriangleRoundedsUploaded: createLineOfTriangleRoundedsUploaded,
        createLineOfTrianglesUploaded: createLineOfTrianglesUploaded,
        createLineUploaded: createLineUploaded,
        createLine: createLine,
        toLineStrokeWidth: toLineStrokeWidth,
        createNullUploaded: createNullUploaded,
        createRectangleRoundedUploaded: createRectangleRoundedUploaded,
        createRectangleUploaded: createRectangleUploaded,
        createTriangleRoundedUploaded: createTriangleRoundedUploaded,
        createTriangleUploaded: createTriangleUploaded,
        deserializeBar: deserializeBar,
        deserializeCircle: deserializeCircle,
        deserializeEmbedded: deserializeEmbedded,
        deserializeGroupShadowed: deserializeGroupShadowed,
        deserializeGroup: deserializeGroup,
        deserializeImageSdf: deserializeImageSdf,
        deserializeImage: deserializeImage,
        deserializeLabel: deserializeLabel,
        deserializeLineOfCircles: deserializeLineOfCircles,
        deserializeLineOfRectangleRoundeds: deserializeLineOfRectangleRoundeds,
        deserializeLineOfRectangles: deserializeLineOfRectangles,
        deserializeLineOfTriangleRoundeds: deserializeLineOfTriangleRoundeds,
        deserializeLineOfTriangles: deserializeLineOfTriangles,
        deserializeLine: deserializeLine,
        deserializeNull: deserializeNull,
        deserializeRectangleRounded: deserializeRectangleRounded,
        deserializeRectangle: deserializeRectangle,
        deserializeTriangleRounded: deserializeTriangleRounded,
        deserializeTriangle: deserializeTriangle,
        EShapeBarPoints: EShapeBarPoints,
        get EShapeBarPosition () { return EShapeBarPosition; },
        EShapeBarUploaded: EShapeBarUploaded,
        EShapeBar: EShapeBar,
        EShapeBaseHitTestData: EShapeBaseHitTestData,
        EShapeBase: EShapeBase,
        EShapeCircleUploaded: EShapeCircleUploaded,
        EShapeCircle: EShapeCircle,
        EShapeEmbeddedDatum: EShapeEmbeddedDatum,
        EShapeEmbeddedLayerContainer: EShapeEmbeddedLayerContainer,
        EShapeEmbeddedLayer: EShapeEmbeddedLayer,
        EShapeEmbedded: EShapeEmbedded,
        EShapeEmbeddeds: EShapeEmbeddeds,
        EShapeFillImpl: EShapeFillImpl,
        EShapeGradients: EShapeGradients,
        EShapeGroupFillEditor: EShapeGroupFillEditor,
        EShapeGroupFillViewer: EShapeGroupFillViewer,
        EShapeGroupPoints: EShapeGroupPoints,
        EShapeGroupShadowed: EShapeGroupShadowed,
        EShapeGroupSizeEditor: EShapeGroupSizeEditor,
        EShapeGroupSizeLayout: EShapeGroupSizeLayout,
        EShapeGroupSizeShadowed: EShapeGroupSizeShadowed,
        EShapeGroupSizeViewer: EShapeGroupSizeViewer,
        EShapeGroupStrokeEditor: EShapeGroupStrokeEditor,
        EShapeGroupStrokeViewer: EShapeGroupStrokeViewer,
        EShapeGroupTextAlignEditor: EShapeGroupTextAlignEditor,
        EShapeGroupTextAlignViewer: EShapeGroupTextAlignViewer,
        EShapeGroupTextEditor: EShapeGroupTextEditor,
        EShapeGroupTextOffsetEditor: EShapeGroupTextOffsetEditor,
        EShapeGroupTextOffsetViewer: EShapeGroupTextOffsetViewer,
        EShapeGroupTextOutlineEditor: EShapeGroupTextOutlineEditor,
        EShapeGroupTextOutlineViewer: EShapeGroupTextOutlineViewer,
        EShapeGroupTextPaddingEditor: EShapeGroupTextPaddingEditor,
        EShapeGroupTextPaddingViewer: EShapeGroupTextPaddingViewer,
        EShapeGroupTextSpacingEditor: EShapeGroupTextSpacingEditor,
        EShapeGroupTextSpacingViewer: EShapeGroupTextSpacingViewer,
        EShapeGroupTextViewer: EShapeGroupTextViewer,
        EShapeGroupUploaded: EShapeGroupUploaded,
        EShapeGroupViewer: EShapeGroupViewer,
        EShapeGroup: EShapeGroup,
        EShapeImageSdfUploaded: EShapeImageSdfUploaded,
        EShapeImageSdf: EShapeImageSdf,
        EShapeImage: EShapeImage,
        EShapeLabelUploaded: EShapeLabelUploaded,
        EShapeLabel: EShapeLabel,
        EShapeLineBase: EShapeLineBase,
        EShapeLineOfAnyPointsFillImpl: EShapeLineOfAnyPointsFillImpl,
        EShapeLineOfAnyPointsImpl: EShapeLineOfAnyPointsImpl,
        EShapeLineOfAnyPointsPointImpl: EShapeLineOfAnyPointsPointImpl,
        EShapeLineOfAnyPointsStrokeImpl: EShapeLineOfAnyPointsStrokeImpl,
        EShapeLineOfAnyUploaded: EShapeLineOfAnyUploaded,
        EShapeLineOfCirclesUploaded: EShapeLineOfCirclesUploaded,
        EShapeLineOfCircles: EShapeLineOfCircles,
        EShapeLineOfRectangleRoundedsUploaded: EShapeLineOfRectangleRoundedsUploaded,
        EShapeLineOfRectangleRoundeds: EShapeLineOfRectangleRoundeds,
        EShapeLineOfRectanglesUploaded: EShapeLineOfRectanglesUploaded,
        EShapeLineOfRectangles: EShapeLineOfRectangles,
        EShapeLineOfTriangleRoundedsUploaded: EShapeLineOfTriangleRoundedsUploaded,
        EShapeLineOfTriangleRoundeds: EShapeLineOfTriangleRoundeds,
        EShapeLineOfTrianglesUploaded: EShapeLineOfTrianglesUploaded,
        EShapeLineOfTriangles: EShapeLineOfTriangles,
        EShapeLinePoints: EShapeLinePoints,
        EShapeLineUploaded: EShapeLineUploaded,
        EShapeLine: EShapeLine,
        EShapeNullUploaded: EShapeNullUploaded,
        EShapeNull: EShapeNull,
        EShapePrimitive: EShapePrimitive,
        EShapeRectangleRoundedUploaded: EShapeRectangleRoundedUploaded,
        EShapeRectangleRounded: EShapeRectangleRounded,
        EShapeRectangleUploaded: EShapeRectangleUploaded,
        EShapeRectangle: EShapeRectangle,
        EShapeStrokeImpl: EShapeStrokeImpl,
        EShapeTagImpl: EShapeTagImpl,
        EShapeTagValueImpl: EShapeTagValueImpl,
        EShapeTagValueRangeImpl: EShapeTagValueRangeImpl,
        EShapeTextAlignImpl: EShapeTextAlignImpl,
        EShapeTextImpl: EShapeTextImpl,
        EShapeTextOffsetImpl: EShapeTextOffsetImpl,
        EShapeTextOutlineImpl: EShapeTextOutlineImpl,
        EShapeTextUploaded: EShapeTextUploaded,
        EShapeTriangleRoundedUploaded: EShapeTriangleRoundedUploaded,
        EShapeTriangleRounded: EShapeTriangleRounded,
        EShapeTriangleUploaded: EShapeTriangleUploaded,
        EShapeTriangle: EShapeTriangle,
        isStatic: isStatic,
        toComputed: toComputed,
        toDash: toDash,
        toThresholdDefault: toThresholdDefault,
        toLength: toLength,
        toScaleInvariant: toScaleInvariant,
        EShapeBufferUnitBuilder: EShapeBufferUnitBuilder,
        EShapeBufferUnit: EShapeBufferUnit,
        EShapeBuffer: EShapeBuffer,
        EShapeCapabilities: EShapeCapabilities,
        get EShapeCapability () { return EShapeCapability; },
        EShapeContainer: EShapeContainer,
        get EShapeCopyPart () { return EShapeCopyPart; },
        get EShapeCorner () { return EShapeCorner; },
        EShapeDefaults: EShapeDefaults,
        EShapeDeleter: EShapeDeleter,
        EShapeDeserializer: EShapeDeserializer,
        EShapeDeserializers: EShapeDeserializers,
        EShapeEditor: EShapeEditor,
        EShapeImageElements: EShapeImageElements,
        eShapePointsFormatterCurve: eShapePointsFormatterCurve,
        get EShapePointsStyle () { return EShapePointsStyle; },
        EShapePointsStyles: EShapePointsStyles,
        EShapeRendererIteratorDatum: EShapeRendererIteratorDatum,
        EShapeRendererIterator: EShapeRendererIterator,
        EShapeRenderer: EShapeRenderer,
        EShapeResourceManagerDeserialization: EShapeResourceManagerDeserialization,
        EShapeResourceManagerSerialization: EShapeResourceManagerSerialization,
        get EShapeRuntimeReset () { return EShapeRuntimeReset; },
        EShapeRuntime: EShapeRuntime,
        EShapeRuntimes: EShapeRuntimes,
        EShapeSearch: EShapeSearch,
        EShapeSizes: EShapeSizes,
        EShapeStateSetImplObservable: EShapeStateSetImplObservable,
        EShapeState: EShapeState,
        get EShapeStrokeSide () { return EShapeStrokeSide; },
        get EShapeStrokeStyle () { return EShapeStrokeStyle; },
        get EShapeTagValueRangeType () { return EShapeTagValueRangeType; },
        get EShapeTagValueOrder () { return EShapeTagValueOrder; },
        get EShapeTextAlignHorizontal () { return EShapeTextAlignHorizontal; },
        get EShapeTextAlignVertical () { return EShapeTextAlignVertical; },
        get EShapeTextDirection () { return EShapeTextDirection; },
        get EShapeTextWeight () { return EShapeTextWeight; },
        get EShapeTextStyle () { return EShapeTextStyle; },
        EShapeTransformImpl: EShapeTransformImpl,
        EShapeTransforms: EShapeTransforms,
        get EShapeType () { return EShapeType; },
        EShapeUploadedBase: EShapeUploadedBase,
        EShapeUploadeds: EShapeUploadeds,
        ESnapperGrid: ESnapperGrid,
        ESnapperResultScale: ESnapperResultScale,
        ESnapperResult: ESnapperResult,
        get ESnapperTargetValueType () { return ESnapperTargetValueType; },
        ESnapperTargetValue: ESnapperTargetValue,
        ESnapperTarget: ESnapperTarget,
        get ESnapperModifierAnchor () { return ESnapperModifierAnchor; },
        ESnapper: ESnapper,
        DThemes: DThemes,
        DynamicAtlasItemEmpty: DynamicAtlasItemEmpty,
        DynamicAtlasItemFontAtlas: DynamicAtlasItemFontAtlas,
        DynamicAtlasItemImage: DynamicAtlasItemImage,
        DynamicAtlasItemText: DynamicAtlasItemText,
        DynamicAtlasItemWhite: DynamicAtlasItemWhite,
        DynamicAtlasItem: DynamicAtlasItem,
        DynamicAtlas: DynamicAtlas,
        DynamicFontAtlasCharacterOrigin: DynamicFontAtlasCharacterOrigin,
        DynamicFontAtlasCharacter: DynamicFontAtlasCharacter,
        DynamicFontAtlasFont: DynamicFontAtlasFont,
        DynamicFontAtlas: DynamicFontAtlas,
        DynamicFontAtlases: DynamicFontAtlases,
        DynamicSDFFontAtlas: DynamicSDFFontAtlas,
        DynamicSDFFontAtlases: DynamicSDFFontAtlases,
        DynamicSDFFontGenerator: DynamicSDFFontGenerator,
        isArray: isArray,
        isFunction: isFunction,
        isNaN: isNaN,
        isNumber: isNumber,
        isString: isString,
        Lazy: Lazy,
        NumberFormatterImpl: NumberFormatterImpl,
        NumberFormatters: NumberFormatters,
        toCeilingIndex: toCeilingIndex,
        toEnum: toEnum,
        toIndexOf: toIndexOf,
        toLabel: toLabel,
        toPadded: toPadded,
        toString: toString,
        toSvgTexture: toSvgTexture,
        toSvgUrl: toSvgUrl,
        UtilAlpha: UtilAlpha,
        UtilSvgAtlasBuilder: UtilSvgAtlasBuilder,
        get UtilAttachAlign () { return UtilAttachAlign; },
        UtilAttach: UtilAttach,
        UtilClickOutside: UtilClickOutside,
        UtilClipboard: UtilClipboard,
        UtilDragEasingHistory: UtilDragEasingHistory,
        UtilDragEasing: UtilDragEasing,
        UtilDrag: UtilDrag,
        UtilExtract: UtilExtract,
        UtilExtractor: UtilExtractor,
        UtilFileDownloader: UtilFileDownloader,
        get UtilFileAs () { return UtilFileAs; },
        UtilFileOpener: UtilFileOpener,
        UtilHsv: UtilHsv,
        get UtilHtmlElementWhen () { return UtilHtmlElementWhen; },
        UtilHtmlElement: UtilHtmlElement,
        UtilInputNumber: UtilInputNumber,
        UtilInputText: UtilInputText,
        UtilInput: UtilInput,
        UtilKeyboardEvent: UtilKeyboardEvent,
        UtilName: UtilName,
        UtilOverlay: UtilOverlay,
        UtilPointerEvent: UtilPointerEvent,
        UtilRgb: UtilRgb,
        UtilRgba: UtilRgba,
        UtilStateBlinker: UtilStateBlinker,
        UtilTexturePlane: UtilTexturePlane,
        UtilTransition: UtilTransition,
        UtilWheelEvent: UtilWheelEvent,
        get DAlignHorizontal () { return DAlignHorizontal; },
        get DAlignVertical () { return DAlignVertical; },
        get DAlignWith () { return DAlignWith; },
        DAnimationBase: DAnimationBase,
        DAnimationEmpty: DAnimationEmpty,
        DAnimationFadeIn: DAnimationFadeIn,
        DAnimationTimings: DAnimationTimings,
        DApplicationLayerOptions: DApplicationLayerOptions,
        DApplicationLayer: DApplicationLayer,
        DApplicationPadding: DApplicationPadding,
        DApplication: DApplication,
        DApplications: DApplications,
        DBaseAutoSet: DBaseAutoSet,
        DBaseAuto: DBaseAuto,
        DBaseBackgroundMeshGeometry: DBaseBackgroundMeshGeometry,
        DBaseBackgroundMesh: DBaseBackgroundMesh,
        DBaseBackgroundSnippet: DBaseBackgroundSnippet,
        DBaseBackground: DBaseBackground,
        DBaseBorderMeshGeometry: DBaseBorderMeshGeometry,
        DBaseBorderMesh: DBaseBorderMesh,
        DBaseBorderSnippet: DBaseBorderSnippet,
        DBaseBorder: DBaseBorder,
        DBaseCorner: DBaseCorner,
        get DBaseInteractive () { return DBaseInteractive; },
        DBaseOutlineSnippet: DBaseOutlineSnippet,
        DBaseOutline: DBaseOutline,
        DBaseOverflowMaskSimple: DBaseOverflowMaskSimple,
        DBaseOverflowMask: DBaseOverflowMask,
        DBasePaddingAdjustable: DBasePaddingAdjustable,
        DBasePadding: DBasePadding,
        DBasePoint: DBasePoint,
        DBaseReflowableContainer: DBaseReflowableContainer,
        DBaseReflowableImpl: DBaseReflowableImpl,
        DBaseSnippetContainer: DBaseSnippetContainer,
        DBaseStateSetDataImpl: DBaseStateSetDataImpl,
        DBaseStateSetImplObservable: DBaseStateSetImplObservable,
        DBaseStateSetImpl: DBaseStateSetImpl,
        DBaseState: DBaseState,
        DBase: DBase,
        DBoard: DBoard,
        get DBorderMask () { return DBorderMask; },
        DButtonAmbient: DButtonAmbient,
        get DButtonBaseWhen () { return DButtonBaseWhen; },
        DButtonBase: DButtonBase,
        DButtonCheckRight: DButtonCheckRight,
        DButtonCheck: DButtonCheck,
        DButtonColorGradient: DButtonColorGradient,
        DButtonColor: DButtonColor,
        DButtonDanger: DButtonDanger,
        DButtonDate: DButtonDate,
        DButtonDatetime: DButtonDatetime,
        DButtonFileAs: DButtonFileAs,
        DButtonFile: DButtonFile,
        DButtonGroup: DButtonGroup,
        DButtonLink: DButtonLink,
        DButtonPrimary: DButtonPrimary,
        DButtonRadioRight: DButtonRadioRight,
        DButtonRadio: DButtonRadio,
        DButtonRedo: DButtonRedo,
        DButtonSecondary: DButtonSecondary,
        DButtonSelect: DButtonSelect,
        DButtonTime: DButtonTime,
        DButtonUndo: DButtonUndo,
        DButton: DButton,
        DCanvasContainer: DCanvasContainer,
        DCanvas: DCanvas,
        DChartAxisBaseOptionParser: DChartAxisBaseOptionParser,
        DChartAxisBase: DChartAxisBase,
        DChartAxisContainerImpl: DChartAxisContainerImpl,
        get DChartAxisPosition () { return DChartAxisPosition; },
        get DChartAxisTickPosition () { return DChartAxisTickPosition; },
        DChartAxisXDatetime: DChartAxisXDatetime,
        DChartAxisX: DChartAxisX,
        DChartAxisY: DChartAxisY,
        DChartColorSet1: DChartColorSet1,
        DChartColorSet2: DChartColorSet2,
        DChartCoordinateContainerImpl: DChartCoordinateContainerImpl,
        DChartCoordinateContainerSubImpl: DChartCoordinateContainerSubImpl,
        DChartCoordinateLinearTick: DChartCoordinateLinearTick,
        DChartCoordinateLinear: DChartCoordinateLinear,
        DChartCoordinateLogTick: DChartCoordinateLogTick,
        DChartCoordinateLog: DChartCoordinateLog,
        DChartCoordinateTransformImpl: DChartCoordinateTransformImpl,
        DChartCoordinateTransformMarkImpl: DChartCoordinateTransformMarkImpl,
        get DChartCoordinateDirection () { return DChartCoordinateDirection; },
        DChartLegendItem: DChartLegendItem,
        DChartLegend: DChartLegend,
        DChartOverview: DChartOverview,
        DChartPlotAreaContainer: DChartPlotAreaContainer,
        DChartPlotArea: DChartPlotArea,
        DChartRegionImplObservable: DChartRegionImplObservable,
        DChartRegionImpl: DChartRegionImpl,
        DChartSelectionGridlineContainerImpl: DChartSelectionGridlineContainerImpl,
        DChartSelectionGridlineX: DChartSelectionGridlineX,
        DChartSelectionGridlineY: DChartSelectionGridlineY,
        DChartSelectionMarker: DChartSelectionMarker,
        DChartSelectionShapeBase: DChartSelectionShapeBase,
        DChartSelectionSimple: DChartSelectionSimple,
        DChartSelectionSubImpl: DChartSelectionSubImpl,
        get DChartSelectionPoint () { return DChartSelectionPoint; },
        DChartSeriesBar: DChartSeriesBar,
        DChartSeriesBaseCoordinateContainer: DChartSeriesBaseCoordinateContainer,
        DChartSeriesBase: DChartSeriesBase,
        DChartSeriesContainerImpl: DChartSeriesContainerImpl,
        DChartSeriesFillComputedImpl: DChartSeriesFillComputedImpl,
        DChartSeriesFillImpl: DChartSeriesFillImpl,
        DChartSeriesLineOfAny: DChartSeriesLineOfAny,
        DChartSeriesLineOfCircles: DChartSeriesLineOfCircles,
        DChartSeriesLineOfRectangleRoundeds: DChartSeriesLineOfRectangleRoundeds,
        DChartSeriesLineOfRectangles: DChartSeriesLineOfRectangles,
        DChartSeriesLineOfTriangleRoundeds: DChartSeriesLineOfTriangleRoundeds,
        DChartSeriesLineOfTriangles: DChartSeriesLineOfTriangles,
        DChartSeriesLine: DChartSeriesLine,
        DChartSeriesExpressionParametersImpl: DChartSeriesExpressionParametersImpl,
        DChartSeriesLinear: DChartSeriesLinear,
        DChartSeriesPaddingComputedImpl: DChartSeriesPaddingComputedImpl,
        DChartSeriesPaddingImpl: DChartSeriesPaddingImpl,
        DChartSeriesPointComputedImpl: DChartSeriesPointComputedImpl,
        DChartSeriesPointImpl: DChartSeriesPointImpl,
        DChartSeriesScalars: DChartSeriesScalars,
        DChartSeriesStrokeComputedImpl: DChartSeriesStrokeComputedImpl,
        DChartSeriesStrokeImpl: DChartSeriesStrokeImpl,
        DChartSeriesHitResult: DChartSeriesHitResult,
        DChart: DChart,
        DColorGradientObservable: DColorGradientObservable,
        DColorGradientPointObservable: DColorGradientPointObservable,
        DCommandClear: DCommandClear,
        DCommandCreate: DCommandCreate,
        DCommandDelete: DCommandDelete,
        get DCommandFlag () { return DCommandFlag; },
        DCommandRedo: DCommandRedo,
        DCommandSaveAs: DCommandSaveAs,
        DCommandSave: DCommandSave,
        DCommandUndo: DCommandUndo,
        DContent: DContent,
        DControllerDefaultCommand: DControllerDefaultCommand,
        DControllerDefaultFocus: DControllerDefaultFocus,
        DControllerKeyboard: DControllerKeyboard,
        DControllers: DControllers,
        get DCornerMask () { return DCornerMask; },
        DDiagramBase: DDiagramBase,
        DDiagramCanvasBase: DDiagramCanvasBase,
        DDiagramCanvasEditorBackground: DDiagramCanvasEditorBackground,
        DDiagramCanvasEditorSnap: DDiagramCanvasEditorSnap,
        DDiagramCanvasEditor: DDiagramCanvasEditor,
        DDiagramCanvasTileMappingImpl: DDiagramCanvasTileMappingImpl,
        DDiagramCanvasTileMappingPointImpl: DDiagramCanvasTileMappingPointImpl,
        DDiagramCanvasTile: DDiagramCanvasTile,
        DDiagramCanvas: DDiagramCanvas,
        DDiagramEditorThumbnail: DDiagramEditorThumbnail,
        DDiagramEditor: DDiagramEditor,
        DDiagramLayerContainer: DDiagramLayerContainer,
        DDiagramLayer: DDiagramLayer,
        DDiagramSerializedVersion: DDiagramSerializedVersion,
        DDiagramShape: DDiagramShape,
        DDiagramSnapshot: DDiagramSnapshot,
        DDiagramTagRemote: DDiagramTagRemote,
        DDiagramTag: DDiagramTag,
        DDiagram: DDiagram,
        DDiagrams: DDiagrams,
        get DDialogAlign () { return UtilAttachAlign; },
        get DDialogCloseOn () { return DDialogCloseOn; },
        DDialogColorGradient: DDialogColorGradient,
        DDialogColor: DDialogColor,
        DDialogCommand: DDialogCommand,
        DDialogConfirmDelete: DDialogConfirmDelete,
        DDialogConfirmDiscard: DDialogConfirmDiscard,
        DDialogConfirmMessage: DDialogConfirmMessage,
        DDialogConfirm: DDialogConfirm,
        DDialogDate: DDialogDate,
        DDialogDates: DDialogDates,
        DDialogDatetime: DDialogDatetime,
        DDialogDatetimes: DDialogDatetimes,
        DDialogInputBoolean: DDialogInputBoolean,
        DDialogInputInteger: DDialogInputInteger,
        DDialogInputReal: DDialogInputReal,
        DDialogInputText: DDialogInputText,
        DDialogInput: DDialogInput,
        DDialogMessage: DDialogMessage,
        get DDialogMode () { return DDialogMode; },
        DDialogProcessingMessage: DDialogProcessingMessage,
        DDialogProcessing: DDialogProcessing,
        DDialogSaveAs: DDialogSaveAs,
        DDialogSelectListItem: DDialogSelectListItem,
        DDialogSelectList: DDialogSelectList,
        DDialogSelectSearh: DDialogSelectSearh,
        DDialogSelect: DDialogSelect,
        DDialogState: DDialogState,
        DDialogTime: DDialogTime,
        DDialogTimes: DDialogTimes,
        DDialog: DDialog,
        get DDragMode () { return DDragMode; },
        DDropdownBase: DDropdownBase,
        DDropdown: DDropdown,
        DDynamicTextGeometry: DDynamicTextGeometry,
        DDynamicTextMeasureResultCharacter: DDynamicTextMeasureResultCharacter,
        DDynamicTextMeasureResult: DDynamicTextMeasureResult,
        DDynamicTextMeasure: DDynamicTextMeasure,
        DDynamicTextStyle: DDynamicTextStyle,
        DDynamicText: DDynamicText,
        DExpandableHeader: DExpandableHeader,
        DExpandable: DExpandable,
        DHtmlElementState: DHtmlElementState,
        DHtmlElement: DHtmlElement,
        DImageBaseThemeWrapperSecondary: DImageBaseThemeWrapperSecondary,
        DImageBaseThemeWrapperTertiary: DImageBaseThemeWrapperTertiary,
        DImageBase: DImageBase,
        DImagePiece: DImagePiece,
        DImage: DImage,
        DInputAndLabel: DInputAndLabel,
        DInputBooleanButtonOff: DInputBooleanButtonOff,
        DInputBooleanButtonOn: DInputBooleanButtonOn,
        DInputBoolean: DInputBoolean,
        DInputIntegerAndLabel: DInputIntegerAndLabel,
        DInputInteger: DInputInteger,
        DInputLabel: DInputLabel,
        DInputNumber: DInputNumber,
        DInputRealAndLabel: DInputRealAndLabel,
        DInputReal: DInputReal,
        DInputTextAndLabel: DInputTextAndLabel,
        DInputText: DInputText,
        DInput: DInput,
        DItemUpdater: DItemUpdater,
        get DLayoutClearType () { return DLayoutClearType; },
        get DLayoutDirection () { return DLayoutDirection; },
        DLayoutHorizontal: DLayoutHorizontal,
        DLayoutSpace: DLayoutSpace,
        DLayoutVertical: DLayoutVertical,
        DLayout: DLayout,
        get DLinkMenuItemId () { return DLinkMenuItemId; },
        DLinkMenu: DLinkMenu,
        get DLinkTarget () { return DLinkTarget; },
        DLink: DLink,
        DLinks: DLinks,
        DListDataImpl: DListDataImpl,
        DListDataMappedImpl: DListDataMappedImpl,
        DListDataSelectionMultiple: DListDataSelectionMultiple,
        DListDataSelectionNone: DListDataSelectionNone,
        DListDataSelectionSingle: DListDataSelectionSingle,
        get DListDataSelectionType () { return DListDataSelectionType; },
        DListItemAccessorImpl: DListItemAccessorImpl,
        DListItemUpdater: DListItemUpdater,
        DListItem: DListItem,
        DList: DList,
        DMapCoordinateEPSG3857: DMapCoordinateEPSG3857,
        DMapCoordinates: DMapCoordinates,
        DMapTilePlane: DMapTilePlane,
        DMapTilePyramidImpl: DMapTilePyramidImpl,
        DMapTileUrlBuilderKokudo: DMapTileUrlBuilderKokudo,
        DMapTileUrlBuilderOsm: DMapTileUrlBuilderOsm,
        DMapTileUrlBuilderOsmfj: DMapTileUrlBuilderOsmfj,
        DMapTilePyramids: DMapTilePyramids,
        DMapTile: DMapTile,
        get DMenuAlign () { return UtilAttachAlign; },
        DMenuBarItem: DMenuBarItem,
        DMenuBar: DMenuBar,
        DMenuContext: DMenuContext,
        DMenuItemBase: DMenuItemBase,
        DMenuItemCheckIsCompatible: DMenuItemCheckIsCompatible,
        DMenuItemCheck: DMenuItemCheck,
        DMenuItemExpandableBody: DMenuItemExpandableBody,
        DMenuItemExpandableHeader: DMenuItemExpandableHeader,
        DMenuItemExpandableIsCompatible: DMenuItemExpandableIsCompatible,
        DMenuItemExpandableItemCheck: DMenuItemExpandableItemCheck,
        DMenuItemExpandableItemLink: DMenuItemExpandableItemLink,
        DMenuItemExpandableItemMenu: DMenuItemExpandableItemMenu,
        DMenuItemExpandableItemSeparator: DMenuItemExpandableItemSeparator,
        DMenuItemExpandableItemSpace: DMenuItemExpandableItemSpace,
        DMenuItemExpandableItemText: DMenuItemExpandableItemText,
        DMenuItemExpandable: DMenuItemExpandable,
        DMenuItemExpandables: DMenuItemExpandables,
        DMenuItemLinkIsCompatible: DMenuItemLinkIsCompatible,
        DMenuItemLink: DMenuItemLink,
        DMenuItemMenuIsCompatible: DMenuItemMenuIsCompatible,
        DMenuItemMenuToSubMenuOptions: DMenuItemMenuToSubMenuOptions,
        DMenuItemMenu: DMenuItemMenu,
        DMenuItemSeparatorReflowable: DMenuItemSeparatorReflowable,
        DMenuItemSeparatorIsCompatible: DMenuItemSeparatorIsCompatible,
        DMenuItemSeparator: DMenuItemSeparator,
        DMenuItemSpaceIsCompatible: DMenuItemSpaceIsCompatible,
        DMenuItemSpace: DMenuItemSpace,
        DMenuItemText: DMenuItemText,
        DMenuItem: DMenuItem,
        DMenuSidedContent: DMenuSidedContent,
        DMenuSidedItemCheck: DMenuSidedItemCheck,
        DMenuSidedItemExpandableItemCheck: DMenuSidedItemExpandableItemCheck,
        DMenuSidedItemExpandableItemLink: DMenuSidedItemExpandableItemLink,
        DMenuSidedItemExpandableItemMenu: DMenuSidedItemExpandableItemMenu,
        DMenuSidedItemExpandableItemSeparator: DMenuSidedItemExpandableItemSeparator,
        DMenuSidedItemExpandableItemSpace: DMenuSidedItemExpandableItemSpace,
        DMenuSidedItemExpandableItemText: DMenuSidedItemExpandableItemText,
        DMenuSidedItemExpandable: DMenuSidedItemExpandable,
        DMenuSidedItemExpandables: DMenuSidedItemExpandables,
        DMenuSidedItemLink: DMenuSidedItemLink,
        DMenuSidedItemMenu: DMenuSidedItemMenu,
        DMenuSidedItemSeparator: DMenuSidedItemSeparator,
        DMenuSidedItemSpace: DMenuSidedItemSpace,
        DMenuSidedItemText: DMenuSidedItemText,
        get DMenuSidedSelectionType () { return DMenuSidedSelectionType; },
        DMenuSidedSelection: DMenuSidedSelection,
        DMenuSided: DMenuSided,
        DMenuSideds: DMenuSideds,
        DMenu: DMenu,
        DMenus: DMenus,
        get DMouseModifier () { return DMouseModifier; },
        DMouseModifiers: DMouseModifiers,
        DNote: DNote,
        DNotification: DNotification,
        DPaginationDotsButton: DPaginationDotsButton,
        DPaginationDynamicButtons: DPaginationDynamicButtons,
        DPaginationNavigationButton: DPaginationNavigationButton,
        DPagination: DPagination,
        DPane: DPane,
        DPickerColorAndAlpha: DPickerColorAndAlpha,
        DPickerColorGradientRecent: DPickerColorGradientRecent,
        DPickerColorGradientView: DPickerColorGradientView,
        DPickerColorGradient: DPickerColorGradient,
        DPickerColorRecent: DPickerColorRecent,
        DPickerColor: DPickerColor,
        DPickerDate: DPickerDate,
        DPickerDates: DPickerDates,
        DPickerDatetimeButtonBack: DPickerDatetimeButtonBack,
        DPickerDatetimeButtonDate: DPickerDatetimeButtonDate,
        DPickerDatetimeButtonNext: DPickerDatetimeButtonNext,
        DPickerDatetimeLabelDate: DPickerDatetimeLabelDate,
        DPickerDatetimeLabel: DPickerDatetimeLabel,
        get DPickerDatetimeMask () { return DPickerDatetimeMask; },
        DPickerDatetimeMasks: DPickerDatetimeMasks,
        DPickerDatetimeRange: DPickerDatetimeRange,
        DPickerDatetimeSpace: DPickerDatetimeSpace,
        DPickerDatetime: DPickerDatetime,
        DPickerDatetimes: DPickerDatetimes,
        DPickerTimeBoundHours: DPickerTimeBoundHours,
        DPickerTimeBoundMinutes: DPickerTimeBoundMinutes,
        DPickerTimeBoundSeconds: DPickerTimeBoundSeconds,
        DPickerTimeBound: DPickerTimeBound,
        DPickerTimeBounds: DPickerTimeBounds,
        DPickerTimeRange: DPickerTimeRange,
        DPickerTime: DPickerTime,
        DPickerTimes: DPickerTimes,
        DScalarExpression: DScalarExpression,
        DScalarFunctions: DScalarFunctions,
        DScrollBarHorizontal: DScrollBarHorizontal,
        DScrollBarThumbHorizontal: DScrollBarThumbHorizontal,
        DScrollBarThumbReflowableHorizontal: DScrollBarThumbReflowableHorizontal,
        DScrollBarThumbReflowableVertical: DScrollBarThumbReflowableVertical,
        DScrollBarThumbVertocal: DScrollBarThumbVertocal,
        DScrollBarThumb: DScrollBarThumb,
        DScrollBarVertical: DScrollBarVertical,
        DScrollBar: DScrollBar,
        DSelectMultiple: DSelectMultiple,
        DSelect: DSelect,
        DShadowImpl: DShadowImpl,
        DSliderHorizontal: DSliderHorizontal,
        DSliderLabel: DSliderLabel,
        DSliderThumb: DSliderThumb,
        DSliderTrackHorizontal: DSliderTrackHorizontal,
        DSliderTrackVertical: DSliderTrackVertical,
        DSliderTrack: DSliderTrack,
        DSliderValue: DSliderValue,
        DSliderVertical: DSliderVertical,
        DSlider: DSlider,
        DTableBodyCellActionDialog: DTableBodyCellActionDialog,
        DTableBodyCellActionMenu: DTableBodyCellActionMenu,
        DTableBodyCellActionPromise: DTableBodyCellActionPromise,
        DTableBodyCellButton: DTableBodyCellButton,
        DTableBodyCellCheck: DTableBodyCellCheck,
        DTableBodyCellColor: DTableBodyCellColor,
        DTableBodyCellDate: DTableBodyCellDate,
        DTableBodyCellDatetime: DTableBodyCellDatetime,
        DTableBodyCellIndex: DTableBodyCellIndex,
        DTableBodyCellInputInteger: DTableBodyCellInputInteger,
        DTableBodyCellInputReal: DTableBodyCellInputReal,
        DTableBodyCellInputText: DTableBodyCellInputText,
        DTableBodyCellInputTreeInput: DTableBodyCellInputTreeInput,
        DTableBodyCellInputTreeMarker: DTableBodyCellInputTreeMarker,
        DTableBodyCellInputTree: DTableBodyCellInputTree,
        toLinkOptions: toLinkOptions,
        toUrl: toUrl,
        toChecker: toChecker$1,
        DTableBodyCellLink: DTableBodyCellLink,
        DTableBodyCellSelectDialog: DTableBodyCellSelectDialog,
        DTableBodyCellSelectMenu: DTableBodyCellSelectMenu,
        DTableBodyCellSelectMultiple: DTableBodyCellSelectMultiple,
        DTableBodyCellSelectPromise: DTableBodyCellSelectPromise,
        DTableBodyCellText: DTableBodyCellText,
        DTableBodyCellTime: DTableBodyCellTime,
        DTableBodyCellTree: DTableBodyCellTree,
        DTableBodyCells: DTableBodyCells,
        DTableBodyRow: DTableBodyRow,
        DTableBody: DTableBody,
        DTableCategoryCell: DTableCategoryCell,
        DTableCategory: DTableCategory,
        get DTableColumnType () { return DTableColumnType; },
        DTableDataListFilter: DTableDataListFilter,
        DTableDataListMapped: DTableDataListMapped,
        DTableDataListSelection: DTableDataListSelection,
        DTableDataListSorter: DTableDataListSorter,
        DTableDataList: DTableDataList,
        get DTableDataSelectionType () { return DTableDataSelectionType; },
        get DTableDataOrder () { return DTableDataOrder; },
        DTableDataTreeFilter: DTableDataTreeFilter,
        DTableDataTreeItemAccessor: DTableDataTreeItemAccessor,
        DTableDataTreeSelectionImpl: DTableDataTreeSelectionImpl,
        DTableDataTreeSorter: DTableDataTreeSorter,
        DTableDataTree: DTableDataTree,
        DTableHeaderCellCheck: DTableHeaderCellCheck,
        DTableHeaderCell: DTableHeaderCell,
        DTableHeader: DTableHeader,
        DTableRow: DTableRow,
        DTableState: DTableState,
        DTable: DTable,
        DTextBase: DTextBase,
        DText: DText,
        DTreeDataImpl: DTreeDataImpl,
        DTreeDataMappedImpl: DTreeDataMappedImpl,
        DTreeDataSelectionMultiple: DTreeDataSelectionMultiple,
        DTreeDataSelectionNone: DTreeDataSelectionNone,
        DTreeDataSelectionSingle: DTreeDataSelectionSingle,
        get DTreeDataSelectionType () { return DTreeDataSelectionType; },
        DTreeItemButton: DTreeItemButton,
        DTreeItemNonEditable: DTreeItemNonEditable,
        DTreeItemState: DTreeItemState,
        DTreeItemText: DTreeItemText,
        DTreeItemUpdater: DTreeItemUpdater,
        DTreeNodeAccessorImpl: DTreeNodeAccessorImpl,
        DTree: DTree,
        DViewDragImpl: DViewDragImpl,
        DViewImpl: DViewImpl,
        DViewTransformImpl: DViewTransformImpl
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    loadAll();
    var global = window;
    global.wcardinal = global.wcardinal || {};
    global.wcardinal.ui = ui;

}(PIXI));
