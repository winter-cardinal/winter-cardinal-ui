/*
 Winter Cardinal UI v0.315.0
 Copyright (C) 2019 Toshiba Corporation
 SPDX-License-Identifier: Apache-2.0

 Material Design icons by Google
 Apache license version 2.0.
*/
(function (pixi_js) {
    'use strict';

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Mappings of shape types and deserializers.
     */
    var EShapeDeserializers = {};
    /**
     * Mappings of shape types and `onDeserialized` handlers.
     */
    var EShapeOnDeserializeds = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeType = {
        CIRCLE: 0,
        RECTANGLE: 1,
        RECTANGLE_ROUNDED: 2,
        TRIANGLE: 3,
        TRIANGLE_ROUNDED: 4,
        LINE: 5,
        IMAGE: 6,
        IMAGE_SDF: 7,
        GROUP: 8,
        BAR: 9,
        LABEL: 10,
        NULL: 11,
        GROUP_SHADOWED: 12,
        LINE_OF_CIRCLES: 13,
        LINE_OF_RECTANGLES: 14,
        LINE_OF_RECTANGLE_ROUNDEDS: 15,
        LINE_OF_TRIANGLES: 16,
        LINE_OF_TRIANGLE_ROUNDEDS: 17,
        EMBEDDED: 18,
        EMBEDDED_LAYER: 19,
        BUTTON: 20,
        RECTANGLE_PIVOTED: 21,
        CONNECTOR_LINE: 22,
        CONNECTOR_ELBOW: 23,
        SEMICIRCLE: 24,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUploadeds = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUploadedImpl = /** @class */ (function () {
        function EShapeUploadedImpl(buffer, vertexOffset, indexOffset, vertexCount, indexCount, builders) {
            this.buffer = buffer;
            this._builders = builders;
            this._vertexOffset = vertexOffset;
            this._indexOffset = indexOffset;
            this._vertexCount = vertexCount;
            this._indexCount = indexCount;
        }
        EShapeUploadedImpl.prototype.init = function (shape) {
            shape.uploaded = this;
            var buffer = this.buffer;
            var builders = this._builders;
            for (var i = 0, imax = builders.length; i < imax; ++i) {
                builders[i].init(buffer);
            }
            this.update(shape);
            return this;
        };
        EShapeUploadedImpl.prototype.update = function (shape) {
            var buffer = this.buffer;
            var builders = this._builders;
            for (var i = 0, imax = builders.length; i < imax; ++i) {
                builders[i].update(buffer, shape);
            }
        };
        EShapeUploadedImpl.prototype.isCompatible = function (shape) {
            var builders = this._builders;
            for (var i = 0, imax = builders.length; i < imax; ++i) {
                if (!builders[i].isCompatible(shape)) {
                    return false;
                }
            }
            return true;
        };
        EShapeUploadedImpl.prototype.getBuffer = function () {
            return this.buffer;
        };
        EShapeUploadedImpl.prototype.getVertexOffset = function () {
            return this._vertexOffset;
        };
        EShapeUploadedImpl.prototype.getVertexCount = function () {
            return this._vertexCount;
        };
        EShapeUploadedImpl.prototype.getIndexOffset = function () {
            return this._indexOffset;
        };
        EShapeUploadedImpl.prototype.getIndexCount = function () {
            return this._indexCount;
        };
        EShapeUploadedImpl.prototype.buildUnit = function (builder) {
            var builders = this._builders;
            for (var i = 0, imax = builders.length; i < imax; ++i) {
                builders[i].buildUnit(builder);
            }
        };
        return EShapeUploadedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var NON_EXPANDING_WIDTH$1 = 2;
    var NON_SHRINKING_WIDTH$1 = 4;
    var NON_SCALING_DOT_AND_DASH$1 = 8;
    var DOTTED$1 = 16;
    var DOTTED_DENSELY$1 = 32;
    var DOTTED_LOOSELY$1 = 64;
    var DASHED$1 = 128;
    var DASHED_DENSELY$1 = 256;
    var DASHED_LOOSELY$1 = 512;
    var EShapeStrokeStyle = {
        NONE: 0,
        NON_EXPANDING_WIDTH: NON_EXPANDING_WIDTH$1,
        NON_SHRINKING_WIDTH: NON_SHRINKING_WIDTH$1,
        NON_SCALING_DOT_AND_DASH: NON_SCALING_DOT_AND_DASH$1,
        NON_SCALING: NON_EXPANDING_WIDTH$1 | NON_SHRINKING_WIDTH$1 | NON_SCALING_DOT_AND_DASH$1,
        NON_SCALING_MASK: NON_EXPANDING_WIDTH$1 | NON_SHRINKING_WIDTH$1 | NON_SCALING_DOT_AND_DASH$1,
        DOTTED: DOTTED$1,
        DOTTED_DENSELY: DOTTED_DENSELY$1,
        DOTTED_LOOSELY: DOTTED_LOOSELY$1,
        DOTTED_MASK: DOTTED$1 | DOTTED_DENSELY$1 | DOTTED_LOOSELY$1,
        DASHED: DASHED$1,
        DASHED_DENSELY: DASHED_DENSELY$1,
        DASHED_LOOSELY: DASHED_LOOSELY$1,
        DASHED_MASK: DASHED$1 | DASHED_DENSELY$1 | DASHED_LOOSELY$1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toDash = function (length, strokeWidth, style, result) {
        if (style & EShapeStrokeStyle.DOTTED_MASK) {
            if (style & EShapeStrokeStyle.DOTTED) {
                result.set(strokeWidth, strokeWidth);
            }
            else if (style & EShapeStrokeStyle.DOTTED_DENSELY) {
                result.set(strokeWidth, strokeWidth * 0.5);
            }
            else {
                result.set(strokeWidth, strokeWidth * 2);
            }
        }
        else if (style & EShapeStrokeStyle.DASHED_MASK) {
            if (style & EShapeStrokeStyle.DASHED) {
                result.set(strokeWidth * 2, strokeWidth);
            }
            else if (style & EShapeStrokeStyle.DASHED_DENSELY) {
                result.set(strokeWidth * 2, strokeWidth * 0.5);
            }
            else {
                result.set(strokeWidth * 2, strokeWidth * 2);
            }
        }
        else {
            result.set(2 * length, 0);
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toScaleInvariant = function (style) {
        var nonExpandingWidth = style & EShapeStrokeStyle.NON_EXPANDING_WIDTH ? 1 : 0;
        var nonShrinkingWidth = style & EShapeStrokeStyle.NON_SHRINKING_WIDTH ? 2 : 0;
        var nonScalingDotAndDash = style & EShapeStrokeStyle.NON_SCALING_DOT_AND_DASH ? 4 : 0;
        if (style & (EShapeStrokeStyle.DOTTED_MASK || EShapeStrokeStyle.DASHED_MASK)) {
            return nonExpandingWidth | nonShrinkingWidth | nonScalingDotAndDash;
        }
        else {
            return nonExpandingWidth | nonShrinkingWidth;
        }
    };

    var BAR_VERTEX_COUNT = 4;
    var BAR_INDEX_COUNT = 2;
    var BAR_FMIN = 0.00001;
    var BAR_WORK_POINT = new pixi_js.Point();
    var buildBarClipping = function (clippings, voffset) {
        var ic = voffset * 3 - 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 3;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 5;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 3;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 5;
    };
    var buildBarIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
    };
    var buildBarVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, pointValues, pointsSize, strokeWidth, strokeStyle, internalTransform) {
        // First point
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var tx = internalTransform.tx;
        var ty = internalTransform.ty;
        var pv0 = pointValues[0];
        var pv1 = pointValues[1];
        var p1x = a * pv0 + c * pv1 + tx;
        var p1y = b * pv0 + d * pv1 + ty;
        // Last point
        var pv2 = pointValues[2];
        var pv3 = pointValues[3];
        var p2x = a * pv2 + c * pv3 + tx;
        var p2y = b * pv2 + d * pv3 + ty;
        // Normal
        var dx = p2x - p1x;
        var dy = p2y - p1y;
        var distance = Math.sqrt(dx * dx + dy * dy);
        var l = distance;
        if (0 <= pointsSize && BAR_FMIN < distance) {
            var ratio = pointsSize / distance;
            dx *= ratio;
            dy *= ratio;
            p2x = p1x + dx;
            p2y = p1y + dy;
            l = pointsSize;
        }
        // Other points
        var p0x = p1x - dx;
        var p0y = p1y - dy;
        var p3x = p2x + dx;
        var p3y = p2y + dy;
        //
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var dash = toDash(l, strokeWidth, strokeStyle, BAR_WORK_POINT);
        var dash0 = dash.x;
        var dash1 = dash.y;
        var iv = (voffset << 1) - 1;
        var icf = (voffset << 2) - 1;
        var is = voffset * 6 - 1;
        vertices[++iv] = p1x;
        vertices[++iv] = p1y;
        vertices[++iv] = p1x;
        vertices[++iv] = p1y;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = p0x;
        steps[++is] = p0y;
        steps[++is] = p2x;
        steps[++is] = p2y;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = p0x;
        steps[++is] = p0y;
        steps[++is] = p2x;
        steps[++is] = p2y;
        colorFills[++icf] = 0;
        colorFills[++icf] = dash0;
        colorFills[++icf] = dash1;
        colorFills[++icf] = l;
        colorFills[++icf] = 0;
        colorFills[++icf] = dash0;
        colorFills[++icf] = dash1;
        colorFills[++icf] = l;
        vertices[++iv] = p2x;
        vertices[++iv] = p2y;
        vertices[++iv] = p2x;
        vertices[++iv] = p2y;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = p1x;
        steps[++is] = p1y;
        steps[++is] = p3x;
        steps[++is] = p3y;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = p1x;
        steps[++is] = p1y;
        steps[++is] = p3x;
        steps[++is] = p3y;
        colorFills[++icf] = l;
        colorFills[++icf] = dash0;
        colorFills[++icf] = dash1;
        colorFills[++icf] = l;
        colorFills[++icf] = l;
        colorFills[++icf] = dash0;
        colorFills[++icf] = dash1;
        colorFills[++icf] = l;
    };
    var buildBarUv = function (uvs, voffset, textureUvs) {
        var iuv = (voffset << 1) - 1;
        uvs[++iuv] = textureUvs.x0;
        uvs[++iuv] = textureUvs.y0;
        uvs[++iuv] = textureUvs.x3;
        uvs[++iuv] = textureUvs.y3;
        uvs[++iuv] = textureUvs.x1;
        uvs[++iuv] = textureUvs.y1;
        uvs[++iuv] = textureUvs.x2;
        uvs[++iuv] = textureUvs.y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilCharacterIterator = /** @class */ (function () {
        function UtilCharacterIterator() {
            this.target = "";
            this.position = 0;
        }
        UtilCharacterIterator.prototype.init = function (target) {
            this.target = target;
            this.position = 0;
        };
        UtilCharacterIterator.prototype.hasNext = function () {
            return this.position < this.target.length;
        };
        UtilCharacterIterator.prototype.findNextBreak = function (target, istart) {
            var iend = target.length;
            for (var i = istart; i < iend; ++i) {
                var code = target.charCodeAt(i);
                if (!this.isLowSurrogate(code) && !this.isVariationSelector(code)) {
                    return i;
                }
            }
            return iend;
        };
        UtilCharacterIterator.prototype.isHighSurrogate = function (code) {
            return 0xd800 <= code && code <= 0xdbff;
        };
        UtilCharacterIterator.prototype.isLowSurrogate = function (code) {
            return 0xdc00 <= code && code <= 0xdfff;
        };
        UtilCharacterIterator.prototype.isVariationSelector = function (code) {
            return 0xfe00 <= code && code <= 0xfe0f;
        };
        UtilCharacterIterator.prototype.next = function () {
            var target = this.target;
            var position = this.position;
            var nextBreak = this.findNextBreak(target, position + 1);
            var result = target.substring(position, nextBreak);
            this.position = nextBreak;
            return result;
        };
        /**
         * Advances the position if the next character is not equal to
         * the given `except`.
         *
         * @param except
         * @return true if the position is advanced
         */
        UtilCharacterIterator.prototype.advance = function (except) {
            var target = this.target;
            var position = this.position;
            var nextBreak = this.findNextBreak(target, position + 1);
            if (target.substring(position, nextBreak) !== except) {
                this.position = nextBreak;
                return true;
            }
            return false;
        };
        /**
         * Closes this iterator.
         *
         * @returns true if closed.
         */
        UtilCharacterIterator.prototype.close = function () {
            var length = this.target.length;
            if (this.position < length) {
                this.position = length;
                return true;
            }
            return false;
        };
        UtilCharacterIterator.from = function (target) {
            if (UtilCharacterIterator._instance == null) {
                UtilCharacterIterator._instance = new UtilCharacterIterator();
            }
            var instance = UtilCharacterIterator._instance;
            instance.init(target);
            return instance;
        };
        UtilCharacterIterator._instance = null;
        return UtilCharacterIterator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextWeight = {
        NORMAL: 0,
        BOLD: 1
    };
    var EShapeTextStyle = {
        NORMAL: 0,
        ITALIC: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignHorizontal = {
        LEFT: 0,
        CENTER: 1,
        RIGHT: 2,
        OUTSIDE_LEFT: 3,
        OUTSIDE_RIGHT: 4
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignVertical = {
        TOP: 0,
        MIDDLE: 1,
        BOTTOM: 2,
        OUTSIDE_TOP: 3,
        OUTSIDE_BOTTOM: 4
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextDirection = {
        LEFT_TO_RIGHT: 0,
        TOP_TO_BOTTOM: 1,
        BOTTOM_TO_TOP: 2,
        RIGHT_TO_LEFT: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLength = function (p0x, p0y, p1x, p1y) {
        var dx01 = p1x - p0x;
        var dy01 = p1y - p0y;
        return Math.sqrt(dx01 * dx01 + dy01 * dy01);
    };

    var TEXT_VERTEX_COUNT = 4;
    var TEXT_INDEX_COUNT = 2;
    var TEXT_FMIN = 0.00001;
    var TEXT_WORK_POINT = new pixi_js.Point();
    var toTextBufferCount = function (shape) {
        return Math.ceil(shape.text.value.length / 12) * 12;
    };
    var buildTextClipping = function (clippings, voffset, vcount) {
        var ic = voffset * 3 - 1;
        var icmax = (voffset + vcount) * 3 - 1;
        for (; ic < icmax;) {
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 2;
        }
    };
    var buildTextIndex = function (indices, voffset, ioffset, icount) {
        var ii = ioffset * 3 - 1;
        var iimax = (ioffset + icount) * 3 - 1;
        var iv = voffset;
        for (; ii < iimax;) {
            indices[++ii] = iv;
            indices[++ii] = iv + 1;
            indices[++ii] = iv + 3;
            indices[++ii] = iv + 1;
            indices[++ii] = iv + 2;
            indices[++ii] = iv + 3;
            iv += 4;
        }
    };
    var buildTextStep = function (steps, voffset, vcount, textAtlas, textSize, textOutlineWidth, textWeight, scaleX, scaleY) {
        var is = voffset * 6 - 1;
        var ismax = (voffset + vcount) * 6 - 1;
        var scaleInvariant = toScaleInvariant(EShapeStrokeStyle.NONE);
        if (textAtlas != null) {
            var scale = textAtlas.font.size / (textSize * (scaleX + scaleY) * 0.5);
            var position = textWeight === EShapeTextWeight.NORMAL ? 0.0 : 0.05;
            for (; is < ismax;) {
                steps[++is] = textOutlineWidth;
                steps[++is] = scaleInvariant;
                steps[++is] = scale;
                steps[++is] = 1;
                steps[++is] = 0;
                steps[++is] = position;
            }
        }
        else {
            for (; is < ismax;) {
                steps[++is] = 0;
                steps[++is] = scaleInvariant;
                steps[++is] = 0;
                steps[++is] = 1;
                steps[++is] = 0;
                steps[++is] = 0;
            }
        }
    };
    var getTextBBox = function (halign, valign, hoffset, voffset, hpadding, vpadding, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, result) {
        switch (halign) {
            case EShapeTextAlignHorizontal.LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y0 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x3) +
                                hnx * (hoffset + hpadding) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y3) +
                                hny * (hoffset + hpadding) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x3 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y3 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x0 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y0 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y3 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.CENTER:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x =
                            0.5 * (x0 + x1) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset + vpadding);
                        result.y =
                            0.5 * (y0 + y1) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            0.5 * (x3 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            0.5 * (y3 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            0.5 * (x0 + x1) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            0.5 * (y0 + y1) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x =
                            0.5 * (x3 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset + vpadding);
                        result.y =
                            0.5 * (y3 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y1 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x1 + x2) +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y1 + y2) +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x2 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y2 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x1 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y1 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y2 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y0 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x3) +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y3) +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x3 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y3 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x0 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y0 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y3 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y1 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x1 + x2) +
                                hnx * (hoffset + hpadding) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y1 + y2) +
                                hny * (hoffset + hpadding) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x2 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y2 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x1 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y1 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y2 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                }
                break;
        }
    };
    var rotateAlignHorizontalRight = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
        }
    };
    var rotateAlignVerticalRight = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
        }
    };
    var rotateAlignHorizontalLeft = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
        }
    };
    var rotateAlignVerticalLeft = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
        }
    };
    var invertAlignHorizontal = function (align) {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
        }
    };
    var invertAlignVertical = function (align) {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
        }
    };
    var buildTextVertex = function (vertices, uvs, voffset, vcount, originX, originY, sizeX, sizeY, textAtlas, textSize, textValue, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textFitting, textWorld, textureUvs, internalTransform) {
        // Calculate the transformed positions
        //
        //  0               1
        // |---------------|
        // |               |
        // |3              |2
        // |---------------|
        //
        var sx = sizeX * 0.5;
        var sy = sizeY * 0.5;
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var tx = internalTransform.tx;
        var ty = internalTransform.ty;
        var ltx = originX - sx;
        var lty = originY - sy;
        var rtx = originX + sx;
        var rty = originY - sy;
        var rbx = originX + sx;
        var rby = originY + sy;
        var x0 = a * ltx + c * lty + tx;
        var y0 = b * ltx + d * lty + ty;
        var x1 = a * rtx + c * rty + tx;
        var y1 = b * rtx + d * rty + ty;
        var x2 = a * rbx + c * rby + tx;
        var y2 = b * rbx + d * rby + ty;
        var x3 = x0 + (x2 - x1);
        var y3 = y0 + (y2 - y1);
        // Horizontal normal
        var hl = toLength(x0, y0, x1, y1);
        var hnl = toLength(0, 0, a, b);
        var hnx = 1;
        var hny = 0;
        if (TEXT_FMIN < hnl) {
            var hnli = 1 / hnl;
            hnx = a * hnli;
            hny = b * hnli;
        }
        // Vertical normal
        var vl = toLength(x0, y0, x3, y3);
        var vnl = toLength(0, 0, c, d);
        var vnx = 0;
        var vny = 1;
        if (TEXT_FMIN < hnl) {
            var vnli = 1 / vnl;
            vnx = c * vnli;
            vny = d * vnli;
        }
        var work = TEXT_WORK_POINT;
        switch (textDirection) {
            case EShapeTextDirection.LEFT_TO_RIGHT:
                // DO NOTHING
                break;
            case EShapeTextDirection.TOP_TO_BOTTOM:
                work.set(vnx, vny);
                vnx = -hnx;
                vny = -hny;
                hnx = work.x;
                hny = work.y;
                work.x = vnl;
                vnl = hnl;
                hnl = work.x;
                break;
            case EShapeTextDirection.BOTTOM_TO_TOP:
                work.set(vnx, vny);
                vnx = hnx;
                vny = hny;
                hnx = -work.x;
                hny = -work.y;
                work.x = vnl;
                vnl = hnl;
                hnl = work.x;
                break;
            case EShapeTextDirection.RIGHT_TO_LEFT:
                hnx = -hnx;
                hny = -hny;
                vnx = -vnx;
                vny = -vny;
                break;
        }
        // Calculate the width / height
        var width = 0;
        var height = 0;
        var heightChar = 0;
        var textSizeY = textSize * vnl;
        var lineHeight = Math.max(0, textSize + textSpacingVertical) * vnl;
        var lineWidth = 0;
        var lineCount = 1;
        var textAtlasCharacters = textAtlas.characters;
        var iterator = UtilCharacterIterator.from(textValue);
        var advancePrevious = 0;
        while (iterator.hasNext()) {
            var character = iterator.next();
            if (character !== "\n") {
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                var data = textAtlasCharacters[character];
                if (data) {
                    advancePrevious = data.advance;
                    heightChar = data.height;
                }
                else {
                    advancePrevious = 0;
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                width = Math.max(width, lineWidth);
                lineWidth = 0;
                height += lineHeight;
                lineCount += 1;
            }
        }
        lineWidth += advancePrevious;
        width = Math.max(width, lineWidth);
        height += textSizeY;
        lineWidth = 0;
        if (textFitting && isIn(textAlignHorizontal, textAlignVertical)) {
            var w0 = 0;
            var h0 = 0;
            switch (textDirection) {
                case EShapeTextDirection.LEFT_TO_RIGHT:
                case EShapeTextDirection.RIGHT_TO_LEFT:
                    w0 = Math.max(0, hl - textPaddingHorizontal * 2);
                    h0 = Math.max(0, vl - textPaddingVertical * 2);
                    break;
                case EShapeTextDirection.TOP_TO_BOTTOM:
                case EShapeTextDirection.BOTTOM_TO_TOP:
                    w0 = Math.max(0, vl - textPaddingVertical * 2);
                    h0 = Math.max(0, hl - textPaddingHorizontal * 2);
                    break;
            }
            var w1 = width * hnl * (textSize / textAtlas.font.size);
            var h1 = height;
            var s = Math.min(1, Math.min(w0 / w1, h0 / h1));
            textSize *= s;
            textSizeY *= s;
            lineHeight *= s;
            height *= s;
        }
        var scaleZ = textSize / textAtlas.font.size;
        var scaleX = hnl * scaleZ;
        var scaleY = vnl * scaleZ;
        width *= scaleX;
        heightChar *= scaleY;
        //
        var tx0 = 0;
        var ty0 = 0;
        var lineWidthMaximum = NaN;
        switch (textDirection) {
            case EShapeTextDirection.LEFT_TO_RIGHT:
                getTextBBox(textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textPaddingHorizontal, textPaddingVertical, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = hl - textPaddingHorizontal * 2;
                }
                break;
            case EShapeTextDirection.TOP_TO_BOTTOM:
                getTextBBox(rotateAlignVerticalRight(textAlignVertical), rotateAlignHorizontalRight(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x1, y1, x2, y2, x3, y3, x0, y0, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = vl - textPaddingVertical * 2;
                }
                break;
            case EShapeTextDirection.BOTTOM_TO_TOP:
                getTextBBox(rotateAlignVerticalLeft(textAlignVertical), rotateAlignHorizontalLeft(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x3, y3, x0, y0, x1, y1, x2, y2, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = vl - textPaddingVertical * 2;
                }
                break;
            case EShapeTextDirection.RIGHT_TO_LEFT:
                getTextBBox(invertAlignHorizontal(textAlignHorizontal), invertAlignVertical(textAlignVertical), textOffsetHorizontal, textOffsetVertical, textPaddingHorizontal, textPaddingVertical, width, height, x2, y2, x3, y3, x0, y0, x1, y1, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = hl - textPaddingHorizontal * 2;
                }
                break;
        }
        //
        if (lineWidthMaximum < width) {
            var dwidth = (width - lineWidthMaximum) * 0.5;
            textWorld[0] = tx0 + hnx * dwidth;
            textWorld[1] = ty0 + hny * dwidth;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = lineWidthMaximum;
            textWorld[7] = height;
            textWorld[8] = hnl;
            textWorld[9] = vnl;
        }
        else {
            textWorld[0] = tx0;
            textWorld[1] = ty0;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = width;
            textWorld[7] = height;
            textWorld[8] = hnl;
            textWorld[9] = vnl;
        }
        // Texture
        var uvx0 = textureUvs.x0;
        var uvx1 = textureUvs.x1;
        var uvx3 = textureUvs.x3;
        var uvy0 = textureUvs.y0;
        var uvy1 = textureUvs.y1;
        var uvy3 = textureUvs.y3;
        var duvx01 = uvx1 - uvx0;
        var duvy01 = uvy1 - uvy0;
        var duvx03 = uvx3 - uvx0;
        var duvy03 = uvy3 - uvy0;
        // Vertices & UVs
        var lhx = lineHeight * vnx;
        var lhy = lineHeight * vny;
        var snx = scaleX * hnx;
        var sny = scaleX * hny;
        var offsetY = (heightChar - textSizeY) * 0.5;
        var oyx = offsetY * vnx;
        var oyy = offsetY * vny;
        var offsetItalic = textStyle === EShapeTextStyle.NORMAL ? 0 : textSize * 0.25;
        var bx0 = tx0 - oyx + offsetItalic * snx;
        var by0 = ty0 - oyy + offsetItalic * sny;
        var bx3 = tx0 + oyx + textSizeY * vnx;
        var by3 = ty0 + oyy + textSizeY * vny;
        var cx0 = bx0;
        var cy0 = by0;
        var cx3 = bx3;
        var cy3 = by3;
        lineWidth = 0;
        advancePrevious = 0;
        iterator.position = 0;
        lineCount = 0;
        var iv = voffset * 2;
        for (; iterator.hasNext(); iv += 8) {
            var character = iterator.next();
            if (character !== "\n") {
                var lineWidthPrevious = lineWidth;
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                var ax = lineWidth * snx;
                var ay = lineWidth * sny;
                cx0 = bx0 + ax;
                cy0 = by0 + ay;
                cx3 = bx3 + ax;
                cy3 = by3 + ay;
                var data = textAtlasCharacters[character];
                lineCount += 1;
                if (data) {
                    var advance = data.advance;
                    if (lineWidthMaximum < (lineWidth + advance) * scaleX) {
                        var dots = textAtlasCharacters["..."];
                        if (dots) {
                            if (1 < lineCount &&
                                lineWidthMaximum < (lineWidth + dots.advance) * scaleX) {
                                lineWidth = lineWidthPrevious;
                                iv -= 8;
                                lineCount -= 1;
                                var bx = lineWidth * snx;
                                var by = lineWidth * sny;
                                cx0 = bx0 + bx;
                                cy0 = by0 + by;
                                cx3 = bx3 + bx;
                                cy3 = by3 + by;
                            }
                            advancePrevious = dots.advance;
                            writeCharacter(vertices, uvs, iv, dots, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                            for (iv += 8; true; iv += 8) {
                                if (iterator.hasNext() && iterator.advance("\n")) {
                                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                                    lineCount += 1;
                                }
                                else {
                                    iv -= 8;
                                    break;
                                }
                            }
                        }
                        else {
                            advancePrevious = advance;
                            writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                        }
                    }
                    else {
                        advancePrevious = advance;
                        writeCharacter(vertices, uvs, iv, data, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                    }
                }
                else {
                    advancePrevious = 0;
                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                bx0 += lhx;
                by0 += lhy;
                bx3 += lhx;
                by3 += lhy;
                cx0 = bx0;
                cy0 = by0;
                cx3 = bx3;
                cy3 = by3;
                writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scaleX, textDirection, textAlignHorizontal, textAlignVertical);
                lineWidth = 0;
                lineCount = 0;
            }
        }
        lineWidth += advancePrevious;
        adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scaleX, textDirection, textAlignHorizontal, textAlignVertical);
        for (var ivmax = (voffset + vcount) * 2; iv < ivmax; iv += 2) {
            vertices[iv + 0] = tx0;
            vertices[iv + 1] = ty0;
            uvs[iv + 0] = uvx0;
            uvs[iv + 1] = uvy0;
        }
    };
    var isIn = function (textAlignHorizontal, textAlignVertical) {
        switch (textAlignHorizontal) {
            case EShapeTextAlignHorizontal.LEFT:
            case EShapeTextAlignHorizontal.CENTER:
            case EShapeTextAlignHorizontal.RIGHT:
                switch (textAlignVertical) {
                    case EShapeTextAlignVertical.TOP:
                    case EShapeTextAlignVertical.MIDDLE:
                    case EShapeTextAlignVertical.BOTTOM:
                        return true;
                }
                break;
        }
        return false;
    };
    var writeCharacterEmpty = function (vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3) {
        vertices[iv + 0] = cx0;
        vertices[iv + 1] = cy0;
        vertices[iv + 2] = cx0;
        vertices[iv + 3] = cy0;
        vertices[iv + 4] = cx3;
        vertices[iv + 5] = cy3;
        vertices[iv + 6] = cx3;
        vertices[iv + 7] = cy3;
        uvs[iv + 0] = uvx0;
        uvs[iv + 1] = uvy0;
        uvs[iv + 2] = uvx0;
        uvs[iv + 3] = uvy0;
        uvs[iv + 4] = uvx3;
        uvs[iv + 5] = uvy3;
        uvs[iv + 6] = uvx3;
        uvs[iv + 7] = uvy3;
    };
    var writeCharacter = function (vertices, uvs, iv, data, atlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0) {
        // Vertices
        var dataOffsetX = data.x - data.origin.x;
        var dataWidth = data.width;
        var dx0 = dataOffsetX * snx;
        var dy0 = dataOffsetX * sny;
        var dx1 = (dataOffsetX + dataWidth) * snx;
        var dy1 = (dataOffsetX + dataWidth) * sny;
        vertices[iv + 0] = cx0 + dx0;
        vertices[iv + 1] = cy0 + dy0;
        vertices[iv + 2] = cx0 + dx1;
        vertices[iv + 3] = cy0 + dy1;
        vertices[iv + 4] = cx3 + dx1;
        vertices[iv + 5] = cy3 + dy1;
        vertices[iv + 6] = cx3 + dx0;
        vertices[iv + 7] = cy3 + dy0;
        // UVs
        var px0 = data.x / atlas.width;
        var py0 = data.y / atlas.height;
        var px1 = (data.x + data.width) / atlas.width;
        var py1 = (data.y + data.height) / atlas.height;
        var dux0 = duvx01 * px0;
        var duy0 = duvy01 * px0;
        var dux1 = duvx01 * px1;
        var duy1 = duvy01 * px1;
        var dvx0 = duvx03 * py0;
        var dvy0 = duvy03 * py0;
        var dvx1 = duvx03 * py1;
        var dvy1 = duvy03 * py1;
        uvs[iv + 0] = uvx0 + dux0 + dvx0;
        uvs[iv + 1] = uvy0 + duy0 + dvy0;
        uvs[iv + 2] = uvx0 + dux1 + dvx0;
        uvs[iv + 3] = uvy0 + duy1 + dvy0;
        uvs[iv + 4] = uvx0 + dux1 + dvx1;
        uvs[iv + 5] = uvy0 + duy1 + dvy1;
        uvs[iv + 6] = uvx0 + dux0 + dvx1;
        uvs[iv + 7] = uvy0 + duy0 + dvy1;
    };
    var moveText = function (vertices, vertexIndex, textCount, dx, dy) {
        var iv = vertexIndex - 8 * textCount - 1;
        for (var i = 0; i < textCount; ++i) {
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
        }
    };
    var moveTextHalf = function (vertices, vertexIndex, textCount, offset, nx, ny) {
        offset *= 0.5;
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    var moveTextFull = function (vertices, vertexIndex, textCount, offset, nx, ny) {
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    var adjustTextAlignment = function (vertices, nx, ny, lineCount, vertexIndex, offset, textDirection, textAlignHorizontal, textAlignVertical) {
        if (TEXT_FMIN < offset) {
            switch (textDirection) {
                case EShapeTextDirection.LEFT_TO_RIGHT:
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                        case EShapeTextAlignHorizontal.LEFT:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignHorizontal.CENTER:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                        case EShapeTextAlignHorizontal.RIGHT:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.TOP_TO_BOTTOM:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.BOTTOM_TO_TOP:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            // DO NOTHING
                            break;
                    }
                    break;
                case EShapeTextDirection.RIGHT_TO_LEFT:
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                        case EShapeTextAlignHorizontal.LEFT:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.CENTER:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                        case EShapeTextAlignHorizontal.RIGHT:
                            // DO NOTHING
                            break;
                    }
                    break;
            }
        }
    };

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var CLOSED = 1;
    var NON_EXPANDING_WIDTH = 2;
    var NON_SHRINKING_WIDTH = 4;
    var NON_SCALING_DOT_AND_DASH = 8;
    var DOTTED = 16;
    var DOTTED_DENSELY = 32;
    var DOTTED_LOOSELY = 64;
    var DASHED = 128;
    var DASHED_DENSELY = 256;
    var DASHED_LOOSELY = 512;
    var CURVE = 1024;
    var FORMATTER_SHIFT = 10;
    var FORMATTER_MASK = 0xffc00;
    var FORMATTER_EXTENSION_LOWEST = 512;
    var FORMATTER_EXTENSION_HIGHEST = 1023;
    var FORMATTER_CURVE = 1;
    /**
     * EShape point style.
     *
     * * Bits 0 to 9: Bit field of styles.
     * * Bits 10 to 19: Formatter ID.
     */
    var EShapePointsStyle = {
        NONE: 0,
        CLOSED: CLOSED,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_EXPANDING_WIDTH: NON_EXPANDING_WIDTH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_SHRINKING_WIDTH: NON_SHRINKING_WIDTH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_SCALING_DOT_AND_DASH: NON_SCALING_DOT_AND_DASH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_SCALING_MASK: NON_EXPANDING_WIDTH | NON_SHRINKING_WIDTH | NON_SCALING_DOT_AND_DASH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED: DOTTED,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED_DENSELY: DOTTED_DENSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED_LOOSELY: DOTTED_LOOSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED_MASK: DOTTED | DOTTED_DENSELY | DOTTED_LOOSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED: DASHED,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED_DENSELY: DASHED_DENSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED_LOOSELY: DASHED_LOOSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED_MASK: DASHED | DASHED_DENSELY | DASHED_LOOSELY,
        CURVE: CURVE,
        FORMATTER_SHIFT: FORMATTER_SHIFT,
        FORMATTER_MASK: FORMATTER_MASK,
        FORMATTER_EXTENSION_LOWEST: FORMATTER_EXTENSION_LOWEST,
        FORMATTER_EXTENSION_HIGHEST: FORMATTER_EXTENSION_HIGHEST,
        FORMATTER_CURVE: FORMATTER_CURVE
    };

    var buildColor = function (color, alpha, voffset, vcount, colors) {
        var r = (((color >> 16) & 0xff) / 255.0) * alpha;
        var g = (((color >> 8) & 0xff) / 255.0) * alpha;
        var b = (((color >> 0) & 0xff) / 255.0) * alpha;
        var a = alpha;
        var ic = (voffset << 2) - 1;
        var icmax = ((voffset + vcount) << 2) - 1;
        for (; ic < icmax;) {
            colors[++ic] = r;
            colors[++ic] = g;
            colors[++ic] = b;
            colors[++ic] = a;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderBase = /** @class */ (function () {
        function BuilderBase(vertexOffset, indexOffset, vertexCount, indexCount) {
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = vertexCount;
            this.indexCount = indexCount;
            this.sizeX = NaN;
            this.sizeY = NaN;
            this.transformLocalId = -1;
            this.strokeAlign = NaN;
            this.strokeWidth = NaN;
            this.strokeSide = NaN;
            this.strokeStyle = NaN;
            this.colorFill = NaN;
            this.alphaFill = -1;
            this.colorStroke = NaN;
            this.alphaStroke = -1;
            this.texture = null;
            this.textureTransformId = NaN;
        }
        BuilderBase.prototype.isCompatible = function (shape) {
            return true;
        };
        BuilderBase.prototype.updateColorFill = function (buffer, shape) {
            var fill = shape.fill;
            var isEnabled = shape.visible && fill.enable;
            var color = fill.color;
            var alpha = isEnabled ? fill.alpha : 0;
            if (color !== this.colorFill || alpha !== this.alphaFill) {
                this.colorFill = color;
                this.alphaFill = alpha;
                buffer.updateColorFills();
                buildColor(color, alpha, this.vertexOffset, this.vertexCount, buffer.colorFills);
            }
        };
        BuilderBase.prototype.updateColorStroke = function (buffer, shape) {
            var stroke = shape.stroke;
            var isEnabled = shape.visible && stroke.enable && 0 < stroke.width;
            var color = stroke.color;
            var alpha = isEnabled ? stroke.alpha : 0;
            if (color !== this.colorStroke || alpha !== this.alphaStroke) {
                this.colorStroke = color;
                this.alphaStroke = alpha;
                buffer.updateColorStrokes();
                buildColor(color, alpha, this.vertexOffset, this.vertexCount, buffer.colorStrokes);
            }
        };
        BuilderBase.prototype.buildUnit = function (builder) {
            var texture = this.texture || pixi_js.Texture.WHITE;
            var baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                var indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        };
        return BuilderBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toTransformLocalId = function (shape) {
        shape.updateTransform();
        return shape.transform.getLocalId();
    };
    var toTexture = function (shape) {
        return shape.texture || pixi_js.Texture.WHITE;
    };
    var toTextureTransformId = function (texture) {
        var textureAny = texture;
        if (textureAny._uvs == null) {
            texture.updateUvs();
        }
        return textureAny._updateID;
    };
    var toTextureUvs = function (texture) {
        return texture._uvs;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DThemes = /** @class */ (function () {
        function DThemes() {
        }
        DThemes.setDefaultThemeClass = function (theme) {
            this.DEFAULT_THEME_CLASS = theme;
        };
        DThemes.getDefaultThemeClass = function () {
            return this.DEFAULT_THEME_CLASS;
        };
        DThemes.getInstance = function () {
            if (this.INSTANCE == null) {
                var defaultThemeClass = this.getDefaultThemeClass();
                if (defaultThemeClass == null) {
                    throw new Error("No default theme class found");
                }
                this.INSTANCE = new defaultThemeClass();
            }
            return this.INSTANCE;
        };
        DThemes.setInstance = function (instance) {
            var result = this.INSTANCE;
            this.INSTANCE = instance;
            return result;
        };
        DThemes.get = function (type) {
            return this.getInstance().get(type);
        };
        DThemes.set = function (type, instance) {
            this.getInstance().set(type, instance);
        };
        DThemes.getClass = function (type) {
            return this.getInstance().getClass(type);
        };
        DThemes.setClass = function (type, themeClass) {
            this.getInstance().setClass(type, themeClass);
        };
        DThemes.getAtlas = function () {
            return this.getInstance().getAtlas();
        };
        DThemes.DEFAULT_THEME_CLASS = null;
        DThemes.INSTANCE = null;
        return DThemes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDefaults = /** @class */ (function () {
        function EShapeDefaults() {
        }
        Object.defineProperty(EShapeDefaults, "THEME", {
            get: function () {
                var theme = this._THEME;
                if (theme != null) {
                    return theme;
                }
                var newTheme = DThemes.getInstance().get("EShape");
                this._THEME = newTheme;
                return newTheme;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "FILL_COLOR", {
            get: function () {
                return this.THEME.getFillColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "FILL_ALPHA", {
            get: function () {
                return this.THEME.getFillAlpha();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_COLOR", {
            get: function () {
                return this.THEME.getStrokeColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_ALPHA", {
            get: function () {
                return this.THEME.getStrokeAlpha();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_WIDTH", {
            get: function () {
                return this.THEME.getStrokeWidth();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_ALIGN", {
            get: function () {
                return this.THEME.getStrokeAlign();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_SIDE", {
            get: function () {
                return this.THEME.getStrokeSide();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "STROKE_STYLE", {
            get: function () {
                return this.THEME.getStrokeStyle();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_VALUE", {
            get: function () {
                return this.THEME.getTextValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_COLOR", {
            get: function () {
                return this.THEME.getTextColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_ALPHA", {
            get: function () {
                return this.THEME.getTextAlpha();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_FAMILY", {
            get: function () {
                return this.THEME.getTextFamily();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "TEXT_SIZE", {
            get: function () {
                return this.THEME.getTextSize();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "RADIUS", {
            get: function () {
                return this.THEME.getRadius();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "SIZE_X", {
            get: function () {
                return this.THEME.getSizeX();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "SIZE_Y", {
            get: function () {
                return this.THEME.getSizeY();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "HIGHLIGHT_COLOR", {
            get: function () {
                return this.THEME.getHighlightColor();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDefaults, "CURVE_SEGMENT_COUNT", {
            get: function () {
                return this.THEME.getCurveSegmentCount();
            },
            enumerable: false,
            configurable: true
        });
        return EShapeDefaults;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerType = {
        NONE: 0,
        CIRCLE: 1,
        TRIANGLE: 2,
        RECTANGLE: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeFillImpl = /** @class */ (function () {
        function EShapeFillImpl(parent, enable, color, alpha) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
        }
        Object.defineProperty(EShapeFillImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeFillImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeFillImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeFillImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha);
            }
        };
        EShapeFillImpl.prototype.set = function (enable, color, alpha) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeFillImpl.prototype.clone = function () {
            return new EShapeFillImpl(this._parent, this._enable, this._color, this._alpha);
        };
        EShapeFillImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha
            };
        };
        EShapeFillImpl.prototype.serialize = function (manager) {
            var stringified = "[".concat(this._enable ? 1 : 0, ",").concat(this._color, ",").concat(this._alpha, "]");
            return manager.addResource(stringified);
        };
        EShapeFillImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getFill(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setFill(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2]);
                }
            }
        };
        return EShapeFillImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerNoop = /** @class */ (function () {
        function EShapePointsMarkerNoop() {
        }
        EShapePointsMarkerNoop.prototype.lock = function () {
            return this;
        };
        EShapePointsMarkerNoop.prototype.unlock = function () {
            return this;
        };
        Object.defineProperty(EShapePointsMarkerNoop.prototype, "type", {
            get: function () {
                return EShapePointsMarkerType.NONE;
            },
            set: function (type) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerNoop.prototype, "size", {
            get: function () {
                var result = this._size;
                if (result == null) {
                    result = new pixi_js.Point();
                    this._size = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerNoop.prototype, "transform", {
            get: function () {
                var result = this._transform;
                if (result == null) {
                    result = new pixi_js.Matrix();
                    this._transform = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerNoop.prototype, "fill", {
            get: function () {
                var result = this._fill;
                if (result == null) {
                    result = new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, 1);
                    this._fill = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerNoop.prototype.updateUploaded = function () {
            // DO NOTHING
        };
        EShapePointsMarkerNoop.prototype.copy = function (source) {
            return this;
        };
        EShapePointsMarkerNoop.prototype.set = function (type, sizeX, sizeY) {
            return this;
        };
        EShapePointsMarkerNoop.prototype.serialize = function (manager) {
            return -1;
        };
        EShapePointsMarkerNoop.prototype.deserialize = function (resourceId, manager) {
            // DO NOTHING
        };
        return EShapePointsMarkerNoop;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerContainerImplNoop = /** @class */ (function () {
        function EShapePointsMarkerContainerImplNoop() {
            this._marker = new EShapePointsMarkerNoop();
        }
        EShapePointsMarkerContainerImplNoop.prototype.lock = function () {
            return this;
        };
        EShapePointsMarkerContainerImplNoop.prototype.unlock = function () {
            return this;
        };
        Object.defineProperty(EShapePointsMarkerContainerImplNoop.prototype, "head", {
            get: function () {
                return this._marker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerContainerImplNoop.prototype, "tail", {
            get: function () {
                return this._marker;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerContainerImplNoop.prototype.copy = function (source) {
            return this;
        };
        EShapePointsMarkerContainerImplNoop.prototype.serialize = function (manager) {
            return -1;
        };
        EShapePointsMarkerContainerImplNoop.prototype.deserialize = function (resourceId, manager) {
            // DO NOTHING
        };
        EShapePointsMarkerContainerImplNoop.getInstance = function () {
            var result = this.INSTANCE;
            if (result == null) {
                result = new EShapePointsMarkerContainerImplNoop();
                this.INSTANCE = result;
            }
            return result;
        };
        return EShapePointsMarkerContainerImplNoop;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarPosition = {
        TOP: 0,
        LEFT: 1,
        RIGHT: 2,
        BOTTOM: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBarPoints = /** @class */ (function () {
        function EShapeBarPoints(parent) {
            this._parent = parent;
            this._id = 0;
            this._values = [0, 0, 0, 0];
            this._segments = [];
            this._style = EShapePointsStyle.NONE;
            this._size = -1;
            this._position = EShapeBarPosition.TOP;
            this._updatedSize = NaN;
            this._updatedParentSizeX = NaN;
            this._updatedParentSizeY = NaN;
            this._updatedPosition = NaN;
        }
        EShapeBarPoints.prototype.getComputedSize = function (size, position, sizeX, sizeY) {
            if (0 <= size) {
                return size;
            }
            else {
                switch (position) {
                    case EShapeBarPosition.TOP:
                    case EShapeBarPosition.BOTTOM:
                        return Math.abs(sizeY);
                    case EShapeBarPosition.RIGHT:
                    case EShapeBarPosition.LEFT:
                        return Math.abs(sizeX);
                }
                return 0;
            }
        };
        EShapeBarPoints.prototype.onSizeChange = function () {
            this.update();
        };
        EShapeBarPoints.prototype.update = function () {
            var parentSize = this._parent.size;
            var parentSizeX = parentSize.x;
            var parentSizeY = parentSize.y;
            var position = this._position;
            var size = this._size;
            if (this._updatedSize !== size ||
                this._updatedParentSizeX !== parentSizeX ||
                this._updatedParentSizeY !== parentSizeY ||
                this._updatedPosition !== position) {
                this._id += 1;
                this._updatedSize = size;
                this._updatedParentSizeX = parentSizeX;
                this._updatedParentSizeY = parentSizeY;
                this._updatedPosition = position;
                var psxh = parentSizeX * 0.5;
                var psyh = parentSizeY * 0.5;
                var computedSize = this.getComputedSize(size, position, parentSizeX, parentSizeY);
                var values = this._values;
                switch (position) {
                    case EShapeBarPosition.TOP:
                        values[0] = 0;
                        values[1] = -psyh;
                        values[2] = 0;
                        values[3] = -psyh + computedSize;
                        break;
                    case EShapeBarPosition.RIGHT:
                        values[0] = psxh;
                        values[1] = 0;
                        values[2] = psxh - computedSize;
                        values[3] = 0;
                        break;
                    case EShapeBarPosition.BOTTOM:
                        values[0] = 0;
                        values[1] = psyh;
                        values[2] = 0;
                        values[3] = psyh - computedSize;
                        break;
                    case EShapeBarPosition.LEFT:
                        values[0] = -psxh;
                        values[1] = 0;
                        values[2] = -psxh + computedSize;
                        values[3] = 0;
                        break;
                }
            }
        };
        Object.defineProperty(EShapeBarPoints.prototype, "length", {
            get: function () {
                return 2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "id", {
            get: function () {
                this.update();
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "values", {
            get: function () {
                this.update();
                return this._values;
            },
            set: function (values) {
                // SUPPOSED NOT TO BE CALLED
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            set: function (segments) {
                // SUPPOSED NOT TO BE CALLED
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                this.moveTo(undefined, size, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this.moveTo(position, undefined, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                this.moveTo(undefined, undefined, style);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "marker", {
            get: function () {
                var result = this._marker;
                if (result == null) {
                    result = EShapePointsMarkerContainerImplNoop.getInstance();
                    this._marker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBarPoints.prototype.getMarker = function () {
            return undefined;
        };
        Object.defineProperty(EShapeBarPoints.prototype, "formatter", {
            get: function () {
                return null;
            },
            set: function (formatter) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBarPoints.prototype, "formatted", {
            get: function () {
                return this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBarPoints.prototype.copy = function (source) {
            if (source instanceof EShapeBarPoints) {
                return this.moveTo(source.position, source.size, source.style);
            }
            else {
                return this.moveTo(undefined, undefined, source.style);
            }
        };
        EShapeBarPoints.prototype.set = function (newValues, newSegments, newStyle) {
            var newPosition;
            var newSize;
            if (newValues != null) {
                var x0 = newValues[0];
                if (x0 === 0) {
                    var y0 = newValues[1];
                    newPosition = y0 <= 0 ? EShapeBarPosition.TOP : EShapeBarPosition.BOTTOM;
                    newSize = Math.abs(newValues[3] - y0);
                }
                else {
                    newPosition = x0 <= 0 ? EShapeBarPosition.LEFT : EShapeBarPosition.RIGHT;
                    newSize = Math.abs(newValues[2] - x0);
                }
            }
            return this.moveTo(newPosition, newSize, newStyle);
        };
        EShapeBarPoints.prototype.moveTo = function (position, size, style) {
            var isChanged = false;
            if (style != null && this._style !== style) {
                this._style = style;
                isChanged = true;
            }
            if (position != null && this._position !== position) {
                this._position = position;
                isChanged = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeBarPoints.prototype.clone = function (parent) {
            return new EShapeBarPoints(parent).copy(this);
        };
        EShapeBarPoints.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeBarPoints.prototype.serialize = function (manager) {
            return manager.addResource("[".concat(this._position, ",").concat(this._size, ",").concat(this._style, "]"));
        };
        EShapeBarPoints.prototype.deserialize = function (resourceId, manager) {
            if (0 <= resourceId && resourceId < manager.resources.length) {
                var resource = manager.resources[resourceId];
                var parsed = JSON.parse(resource);
                this.moveTo(parsed[0], parsed[1], parsed[2]);
            }
        };
        EShapeBarPoints.prototype.calcHitPointAbs = function (x, y, ax, ay, threshold, toRange, tester, result) {
            var length = this.length;
            if (2 <= length) {
                var values = this._values;
                var v0x = values[0];
                var v0y = values[1];
                var v1x = values[2];
                var v1y = values[3];
                if (tester(x, y, v0x, v0y, v1x, v1y, 0, threshold, result)) {
                    return true;
                }
            }
            return false;
        };
        return EShapeBarPoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineBaseHitPart = {
        NONE: 0,
        LINE: 1,
        MARKER_TAIL: 2,
        MARKER_HEAD: 3,
        TEXT: 4,
        CHILDREN: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TOP_LEFT$1 = 1;
    var TOP_RIGHT$1 = 2;
    var BOTTOM_LEFT$1 = 4;
    var BOTTOM_RIGHT$1 = 8;
    var EShapeCorner = {
        NONE: 0,
        TOP_LEFT: TOP_LEFT$1,
        TOP_RIGHT: TOP_RIGHT$1,
        BOTTOM_LEFT: BOTTOM_LEFT$1,
        BOTTOM_RIGHT: BOTTOM_RIGHT$1,
        TOP: TOP_LEFT$1 | TOP_RIGHT$1,
        BOTTOM: BOTTOM_LEFT$1 | BOTTOM_RIGHT$1,
        LEFT: TOP_LEFT$1 | BOTTOM_LEFT$1,
        RIGHT: TOP_RIGHT$1 | BOTTOM_RIGHT$1,
        ALL: TOP_LEFT$1 | TOP_RIGHT$1 | BOTTOM_LEFT$1 | BOTTOM_RIGHT$1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplications = /** @class */ (function () {
        function DApplications() {
        }
        DApplications.add = function (instance) {
            var instances = DApplications.INSTANCES;
            instances.push(instance);
        };
        DApplications.first = function () {
            var instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[0];
            }
            throw new Error("No application found.");
        };
        DApplications.last = function () {
            var instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[instances.length - 1];
            }
            throw new Error("No application found.");
        };
        DApplications.get = function (index) {
            var instances = DApplications.INSTANCES;
            if (0 <= index && index < instances.length) {
                return instances[index];
            }
            return null;
        };
        DApplications.indexOf = function (instance) {
            return DApplications.INSTANCES.indexOf(instance);
        };
        DApplications.size = function () {
            return DApplications.INSTANCES.length;
        };
        DApplications.getStage = function (target) {
            var stage = target;
            while (stage.parent) {
                stage = stage.parent;
            }
            if ("application" in stage && "layer" in stage) {
                return stage;
            }
            return null;
        };
        DApplications.find = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer.application;
            }
            return null;
        };
        DApplications.getLayerBase = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer.application.getLayerBase();
            }
            return null;
        };
        DApplications.getLayerOverlay = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer.application.getLayerOverlay();
            }
            return null;
        };
        DApplications.getLayer = function (target) {
            var stage = this.getStage(target);
            if (stage) {
                return stage.layer;
            }
            return null;
        };
        DApplications.getResolution = function (target) {
            var _a;
            var layer = this.getLayer(target);
            if (layer) {
                return layer.renderer.resolution;
            }
            return (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        };
        DApplications.update = function (target) {
            if (target) {
                var stage = this.getStage(target);
                if (stage) {
                    stage.layer.update();
                }
            }
            else {
                var instances = DApplications.INSTANCES;
                for (var i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].update();
                }
            }
        };
        DApplications.render = function (target) {
            if (target) {
                var stage = this.getStage(target);
                if (stage) {
                    stage.layer.render();
                }
            }
            else {
                var instances = DApplications.INSTANCES;
                for (var i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].render();
                }
            }
        };
        DApplications.INSTANCES = [];
        return DApplications;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAction = /** @class */ (function () {
        function EShapeAction() {
            this.values = [];
        }
        EShapeAction.prototype.add = function (value, index) {
            var values = this.values;
            if (index != null) {
                values.splice(index, 0, value);
            }
            else {
                values.push(value);
            }
            return this;
        };
        EShapeAction.prototype.addAll = function (values) {
            var destination = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                destination.push(values[i]);
            }
            return this;
        };
        EShapeAction.prototype.clearAndAdd = function (value) {
            this.clear();
            this.add(value);
            return this;
        };
        EShapeAction.prototype.clearAndAddAll = function (values) {
            this.clear();
            this.addAll(values);
            return this;
        };
        EShapeAction.prototype.indexOf = function (target) {
            var values = this.values;
            // Instance-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value.isEquals(target)) {
                    return i;
                }
            }
            return -1;
        };
        EShapeAction.prototype.get = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values[index];
            }
            return null;
        };
        EShapeAction.prototype.set = function (index, value) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                var result = values[index];
                values[index] = value;
                return result;
            }
            return null;
        };
        EShapeAction.prototype.remove = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values.splice(index, 1)[0];
            }
            return null;
        };
        EShapeAction.prototype.clear = function () {
            this.values.length = 0;
            return this;
        };
        EShapeAction.prototype.size = function () {
            return this.values.length;
        };
        EShapeAction.prototype.swap = function (indexA, indexB) {
            var values = this.values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
            return this;
        };
        EShapeAction.prototype.serialize = function (manager) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                result.push(values[i].serialize(manager));
            }
            return result;
        };
        return EShapeAction;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorContainerImpl = /** @class */ (function () {
        function EShapeConnectorContainerImpl(parent) {
            this._parent = parent;
            this._edges = new Set();
        }
        EShapeConnectorContainerImpl.prototype.add = function (target) {
            var edges = this._edges;
            if (!edges.has(target)) {
                edges.add(target);
                return true;
            }
            return false;
        };
        EShapeConnectorContainerImpl.prototype.contains = function (target) {
            return this._edges.has(target);
        };
        EShapeConnectorContainerImpl.prototype.size = function () {
            return this._edges.size;
        };
        EShapeConnectorContainerImpl.prototype.remove = function (target) {
            return this._edges.delete(target);
        };
        EShapeConnectorContainerImpl.prototype.clear = function () {
            var edges = this._edges;
            if (0 < edges.size) {
                this._edges.clear();
                return true;
            }
            return false;
        };
        EShapeConnectorContainerImpl.prototype.copy = function (source) {
            var edges = this._edges;
            edges.clear();
            source.each(function (edge) {
                edges.add(edge);
            });
            return this;
        };
        EShapeConnectorContainerImpl.prototype.each = function (iteratee) {
            this._edges.forEach(iteratee);
            return this;
        };
        EShapeConnectorContainerImpl.prototype.fit = function (forcibly) {
            this._edges.forEach(this.toOnFitBound(forcibly));
        };
        EShapeConnectorContainerImpl.prototype.toOnFitBound = function (forcibly) {
            if (forcibly) {
                var result = this._onFitBoundForcibly;
                if (result == null) {
                    result = this.newOnFitBound(true);
                    this._onFitBoundForcibly = result;
                }
                return result;
            }
            else {
                var result = this._onFitBound;
                if (result == null) {
                    result = this.newOnFitBound(false);
                    this._onFitBound = result;
                }
                return result;
            }
        };
        EShapeConnectorContainerImpl.prototype.newOnFitBound = function (forcibly) {
            var _this = this;
            return function (edge) {
                _this.onFit(edge, forcibly);
            };
        };
        EShapeConnectorContainerImpl.prototype.onFit = function (target, forcibly) {
            target.fit(forcibly);
        };
        EShapeConnectorContainerImpl.prototype.attach = function () {
            var parent = this._parent;
            this._edges.forEach(function (edge) {
                edge.set(parent);
            });
            return this;
        };
        EShapeConnectorContainerImpl.prototype.detach = function () {
            this._edges.forEach(function (edge) {
                edge.set(null);
            });
            return this;
        };
        return EShapeConnectorContainerImpl;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TRANSFORM = 1;
    var SIZE = 2;
    var STYLE = 4;
    var ACTION$1 = 8;
    var POINTS = 16;
    var STATE = 32;
    var IMAGE = 64;
    var DATA$1 = 128;
    var CONNECTOR$1 = 256;
    var CAPABILITY = 512;
    var EShapeCopyPart = {
        NONE: 0,
        TRANSFORM: TRANSFORM,
        SIZE: SIZE,
        STYLE: STYLE,
        ACTION: ACTION$1,
        POINTS: POINTS,
        STATE: STATE,
        IMAGE: IMAGE,
        DATA: DATA$1,
        /** @deprecated in favor of {@link DATA} */
        TAG: DATA$1,
        CONNECTOR: CONNECTOR$1,
        CAPABILITY: CAPABILITY,
        ALL: TRANSFORM | SIZE | STYLE | ACTION$1 | POINTS | STATE | IMAGE | DATA$1 | CONNECTOR$1 | CAPABILITY
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseState = {
        HOVERED: "HOVERED",
        ACTIVE: "ACTIVE",
        FOCUSED: "FOCUSED",
        UNFOCUSABLE: "UNFOCUSABLE",
        FOCUS_ROOT: "FOCUS_ROOT",
        FOCUS_REVERSE: "FOCUS_REVERSE",
        READ_ONLY: "READ_ONLY",
        DISABLED: "DISABLED",
        GESTURING: "GESTURING",
        PRESSED: "PRESSED",
        INVALID: "INVALID",
        SUCCEEDED: "SUCCEEDED",
        FAILED: "FAILED",
        WARNED: "WARNED",
        CHANGED: "CHANGED",
        ALTERNATED: "ALTERNATED",
        NEW_WINDOW: "NEW_WINDOW"
    };

    var DBaseStateSetSubDatumImp = /** @class */ (function () {
        function DBaseStateSetSubDatumImp(interval) {
            var _this = this;
            this._stateToTargets = new Map();
            this._interval = interval;
            this._onTimeBound = function () { return _this.onTime(); };
        }
        Object.defineProperty(DBaseStateSetSubDatumImp.prototype, "interval", {
            get: function () {
                return this._interval;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetSubDatumImp.prototype.add = function (state, target) {
            var stateToTargets = this._stateToTargets;
            var targets = stateToTargets.get(state);
            if (targets == null) {
                targets = new Set();
                targets.add(target);
                stateToTargets.set(state, targets);
                if (stateToTargets.size <= 1) {
                    this.start();
                }
            }
            else {
                targets.add(target);
            }
            return this;
        };
        DBaseStateSetSubDatumImp.prototype.remove = function (state, target) {
            var stateToTargets = this._stateToTargets;
            var targets = stateToTargets.get(state);
            if (targets != null && targets.has(target)) {
                targets.delete(target);
                target.remove(state);
                if (targets.size <= 0) {
                    stateToTargets.delete(state);
                }
                if (stateToTargets.size <= 0) {
                    this.stop();
                }
            }
            return this;
        };
        DBaseStateSetSubDatumImp.prototype.start = function () {
            if (this._timeoutId == null) {
                this.onTime();
            }
            return this;
        };
        DBaseStateSetSubDatumImp.prototype.stop = function () {
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
                this._timeoutId = undefined;
            }
            return this;
        };
        DBaseStateSetSubDatumImp.prototype.onTime = function () {
            var now = Date.now();
            var interval = this.interval;
            var value = this.newValue(now, interval);
            var on = this.newOn(now, interval);
            this._stateToTargets.forEach(function (targets, state) {
                targets.forEach(function (target) {
                    target.set(state, value, on);
                });
            });
            this._timeoutId = window.setTimeout(this._onTimeBound, Math.max(0, interval - (now % interval)));
        };
        return DBaseStateSetSubDatumImp;
    }());

    var DBaseStateSetBlinkerDatumImpl = /** @class */ (function (_super) {
        __extends(DBaseStateSetBlinkerDatumImpl, _super);
        function DBaseStateSetBlinkerDatumImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DBaseStateSetBlinkerDatumImpl.prototype.newValue = function (now, interval) {
            return null;
        };
        DBaseStateSetBlinkerDatumImpl.prototype.newOn = function (now, interval) {
            return Math.round(now / interval) % 2 === 0;
        };
        return DBaseStateSetBlinkerDatumImpl;
    }(DBaseStateSetSubDatumImp));

    var DBaseStateSetSubImpl = /** @class */ (function () {
        function DBaseStateSetSubImpl(parent, intervalToDatum) {
            this._parent = parent;
            this._stateToInterval = new Map();
            this._intervalToDatum = intervalToDatum;
        }
        DBaseStateSetSubImpl.prototype.add = function (state, interval) {
            // Check if the interval is not same
            var stateToInterval = this._stateToInterval;
            var oldInterval = stateToInterval.get(state);
            if (oldInterval === interval) {
                return this;
            }
            // Remove the existing one
            if (oldInterval != null) {
                stateToInterval.delete(state);
                var datum_1 = this._intervalToDatum.get(oldInterval);
                if (datum_1 != null) {
                    datum_1.remove(state, this._parent);
                }
            }
            // Add a new one
            stateToInterval.set(state, interval);
            var datum = this._intervalToDatum.get(interval);
            if (datum == null) {
                datum = this.newDatum(interval);
                this._intervalToDatum.set(interval, datum);
            }
            datum.add(state, this._parent);
            // Done
            return this;
        };
        DBaseStateSetSubImpl.prototype.remove = function (state) {
            var interval = this._stateToInterval.get(state);
            if (interval == null) {
                return this;
            }
            this._stateToInterval.delete(state);
            var datum = this._intervalToDatum.get(interval);
            if (datum == null) {
                return this;
            }
            datum.remove(state, this._parent);
            return this;
        };
        DBaseStateSetSubImpl.prototype.set = function (state, interval, on) {
            if (on) {
                return this.add(state, interval);
            }
            else {
                return this.remove(state);
            }
        };
        DBaseStateSetSubImpl.prototype.has = function (state) {
            return this._stateToInterval.has(state);
        };
        DBaseStateSetSubImpl.prototype.clear = function () {
            var _this = this;
            var parent = this._parent;
            var stateToInterval = this._stateToInterval;
            stateToInterval.forEach(function (interval, state) {
                var datum = _this._intervalToDatum.get(interval);
                if (datum != null) {
                    datum.remove(state, parent);
                }
            });
            stateToInterval.clear();
            return this;
        };
        return DBaseStateSetSubImpl;
    }());

    var intervalToDatum$1;
    var DBaseStateSetBlinkerImpl = /** @class */ (function (_super) {
        __extends(DBaseStateSetBlinkerImpl, _super);
        function DBaseStateSetBlinkerImpl(parent) {
            return _super.call(this, parent, (intervalToDatum$1 !== null && intervalToDatum$1 !== void 0 ? intervalToDatum$1 : (intervalToDatum$1 = new Map()))) || this;
        }
        DBaseStateSetBlinkerImpl.prototype.newDatum = function (interval) {
            return new DBaseStateSetBlinkerDatumImpl(interval);
        };
        return DBaseStateSetBlinkerImpl;
    }(DBaseStateSetSubImpl));

    var DBaseStateSetTickerDatumImpl = /** @class */ (function (_super) {
        __extends(DBaseStateSetTickerDatumImpl, _super);
        function DBaseStateSetTickerDatumImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DBaseStateSetTickerDatumImpl.prototype.newValue = function (now, interval) {
            return Math.round(now / interval);
        };
        DBaseStateSetTickerDatumImpl.prototype.newOn = function (now, interval) {
            return true;
        };
        return DBaseStateSetTickerDatumImpl;
    }(DBaseStateSetSubDatumImp));

    var intervalToDatum;
    var DBaseStateSetTickerImpl = /** @class */ (function (_super) {
        __extends(DBaseStateSetTickerImpl, _super);
        function DBaseStateSetTickerImpl(parent) {
            return _super.call(this, parent, (intervalToDatum !== null && intervalToDatum !== void 0 ? intervalToDatum : (intervalToDatum = new Map()))) || this;
        }
        DBaseStateSetTickerImpl.prototype.newDatum = function (interval) {
            return new DBaseStateSetTickerDatumImpl(interval);
        };
        return DBaseStateSetTickerImpl;
    }(DBaseStateSetSubImpl));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isArray = Array.isArray ||
        (function (target) {
            return Object.prototype.toString.call(target) === "[object Array]";
        });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    var isFunction = function (target) {
        return typeof target === "function";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isNumber = function (target) {
        return (typeof target === "number" || Object.prototype.toString.call(target) === "[object Number]");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isString = function (target) {
        return (typeof target === "string" || Object.prototype.toString.call(target) === "[object String]");
    };

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseStateSetImpl = /** @class */ (function () {
        function DBaseStateSetImpl() {
            this._local = new Map();
            this._parent = null;
        }
        Object.defineProperty(DBaseStateSetImpl.prototype, "local", {
            get: function () {
                return this._local;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                if (this._parent !== parent) {
                    this.begin();
                    this._parent = parent;
                    this.end();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.onParentChange = function (newState, oldState) {
            this._parent = oldState;
            this.begin();
            this._parent = newState;
            this.end();
        };
        Object.defineProperty(DBaseStateSetImpl.prototype, "blinker", {
            get: function () {
                var result = this._blinker;
                if (result == null) {
                    result = this.newBlinker();
                    this._blinker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.newBlinker = function () {
            return new DBaseStateSetBlinkerImpl(this);
        };
        Object.defineProperty(DBaseStateSetImpl.prototype, "ticker", {
            get: function () {
                var result = this._ticker;
                if (result == null) {
                    result = this.newTicker();
                    this._ticker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.newTicker = function () {
            return new DBaseStateSetTickerImpl(this);
        };
        DBaseStateSetImpl.prototype.is = function (state, value) {
            var v = this._local.get(state);
            return v !== undefined && (value === undefined || value === v);
        };
        DBaseStateSetImpl.prototype.in = function (state, value) {
            return this.is(state, value) || this.under(state, value);
        };
        DBaseStateSetImpl.prototype.on = function (state, value) {
            var parent = this._parent;
            return parent != null && parent.is(state, value);
        };
        DBaseStateSetImpl.prototype.under = function (state, value) {
            var parent = this._parent;
            return parent != null && parent.in(state, value);
        };
        DBaseStateSetImpl.prototype.lock = function (callOnChange) {
            return this;
        };
        DBaseStateSetImpl.prototype.unlock = function () {
            return this;
        };
        DBaseStateSetImpl.prototype.begin = function () {
            return this;
        };
        DBaseStateSetImpl.prototype.end = function () {
            return this;
        };
        DBaseStateSetImpl.prototype.checkAdded = function (added, value) {
            var v = this._local.get(added);
            return v === undefined || v !== value;
        };
        DBaseStateSetImpl.prototype.add = function (state, value) {
            if (value === void 0) { value = null; }
            if (this.checkAdded(state, value)) {
                this.begin();
                this._local.set(state, value);
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.checkAddedsString = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                var v = local.get(states[i]);
                if (v === undefined || v !== null) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.checkAddedsObject = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                var state = states[i];
                var v = local.get(state.state);
                if (v === undefined || v !== state.value) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.addAll = function (first) {
            if (isString(first)) {
                return this.addAllString(arguments); // eslint-disable-line prefer-rest-params
            }
            else if (isArray(first)) {
                if (0 < first.length) {
                    var element = first[0];
                    if (isString(element)) {
                        return this.addAllString(first);
                    }
                    else {
                        return this.addAllObject(first);
                    }
                }
                return this;
            }
            else {
                return this.addAllObject(arguments); // eslint-disable-line prefer-rest-params
            }
        };
        DBaseStateSetImpl.prototype.addAllString = function (states) {
            if (this.checkAddedsString(states)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = states.length; i < imax; ++i) {
                    local.set(states[i], null);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.addAllObject = function (states) {
            if (this.checkAddedsObject(states)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = states.length; i < imax; ++i) {
                    var state = states[i];
                    local.set(state.state, state.value);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.checkRemoved = function (removed) {
            return this._local.has(removed);
        };
        DBaseStateSetImpl.prototype.remove = function (state) {
            if (this.checkRemoved(state)) {
                this.begin();
                this._local.delete(state);
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.checkRemovedsString = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                if (local.has(states[i])) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.checkRemovedsObject = function (states) {
            var local = this._local;
            for (var i = 0, imax = states.length; i < imax; ++i) {
                if (local.has(states[i].state)) {
                    return true;
                }
            }
            return false;
        };
        DBaseStateSetImpl.prototype.removeAll = function (first) {
            if (isFunction(first)) {
                return this.removeAllMatcher(first);
            }
            else if (isString(first)) {
                return this.removeAllString(arguments); // eslint-disable-line prefer-rest-params
            }
            else if (isArray(first)) {
                if (0 < first.length) {
                    var element = first[0];
                    if (isString(element)) {
                        return this.removeAllString(first);
                    }
                    else {
                        return this.removeAllObject(first);
                    }
                }
                return this;
            }
            else {
                return this.removeAllObject(arguments); // eslint-disable-line prefer-rest-params
            }
        };
        DBaseStateSetImpl.prototype.removeAllMatcher = function (matcher) {
            var _this = this;
            var isDirty = false;
            var local = this._local;
            local.forEach(function (value, state) {
                if (matcher(state)) {
                    if (!isDirty) {
                        isDirty = true;
                        _this.begin();
                    }
                    local.delete(state);
                }
            });
            if (isDirty) {
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.removeAllString = function (states) {
            if (this.checkRemovedsString(states)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = states.length; i < imax; ++i) {
                    local.delete(states[i]);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.removeAllObject = function (states) {
            if (this.checkRemovedsObject(states)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = states.length; i < imax; ++i) {
                    local.delete(states[i].state);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.set = function (first, second, third) {
            if (second === true) {
                if (first != null) {
                    this.add(first);
                }
            }
            else if (second === false) {
                if (first != null) {
                    this.remove(first);
                }
            }
            else if (second == null || isNumber(second)) {
                if (third === true) {
                    if (first != null) {
                        this.add(first, second);
                    }
                }
                else if (third === false) {
                    if (first != null) {
                        this.remove(first);
                    }
                }
                else {
                    return this.doSet(first, second, third);
                }
            }
            else {
                return this.doSet(first, null, second);
            }
            return this;
        };
        DBaseStateSetImpl.prototype.doSet = function (added, value, removed) {
            if (added != null) {
                if (removed != null) {
                    if (this.checkAdded(added, value) || this.checkRemoved(removed)) {
                        this.begin();
                        this._local.set(added, value).delete(removed);
                        this.end();
                    }
                }
                else {
                    this.add(added, value);
                }
            }
            else if (removed != null) {
                this.remove(removed);
            }
            return this;
        };
        DBaseStateSetImpl.prototype.setAll = function (first, second) {
            if (second === true) {
                if (first != null) {
                    this.addAll(first);
                }
            }
            else if (second === false) {
                if (first != null) {
                    this.removeAll(first);
                }
            }
            else {
                if (first != null && 0 < first.length) {
                    if (second != null && 0 < second.length) {
                        var added = first[0];
                        if (isString(added)) {
                            return this.setAllString(first, second);
                        }
                        else {
                            return this.setAllObject(first, second);
                        }
                    }
                    else {
                        this.addAll(first);
                    }
                }
                else if (second != null) {
                    this.removeAll(second);
                }
            }
            return this;
        };
        DBaseStateSetImpl.prototype.setAllString = function (addeds, removeds) {
            if (this.checkAddedsString(addeds) || this.checkRemovedsString(removeds)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = addeds.length; i < imax; ++i) {
                    local.set(addeds[i], null);
                }
                for (var i = 0, imax = removeds.length; i < imax; ++i) {
                    local.delete(removeds[i]);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.setAllObject = function (addeds, removeds) {
            if (this.checkAddedsObject(addeds) || this.checkRemovedsString(removeds)) {
                this.begin();
                var local = this._local;
                for (var i = 0, imax = addeds.length; i < imax; ++i) {
                    var added = addeds[i];
                    local.set(added.state, added.value);
                }
                for (var i = 0, imax = removeds.length; i < imax; ++i) {
                    local.delete(removeds[i]);
                }
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.clear = function () {
            var local = this._local;
            if (0 < local.size) {
                this.begin();
                local.clear();
                this.end();
            }
            return this;
        };
        DBaseStateSetImpl.prototype.valueOf = function (state, def) {
            var result = this._local.get(state);
            if (result !== undefined) {
                return result;
            }
            var parent = this._parent;
            if (parent != null) {
                return parent.valueOf(state, def);
            }
            return def;
        };
        DBaseStateSetImpl.prototype.each = function (iteratee) {
            this._local.forEach(function (value, state) {
                iteratee(state, value);
            });
            return this;
        };
        DBaseStateSetImpl.prototype.size = function () {
            return this._local.size;
        };
        DBaseStateSetImpl.prototype.copy = function (other) {
            if (other instanceof DBaseStateSetImpl) {
                this.begin();
                var local_1 = this._local;
                local_1.clear();
                other.local.forEach(function (value, state) {
                    local_1.set(state, value);
                });
                this._parent = other.parent;
                this.end();
            }
            return this;
        };
        Object.defineProperty(DBaseStateSetImpl.prototype, "isHovered", {
            get: function () {
                return this.is(DBaseState.HOVERED);
            },
            set: function (isHovered) {
                this.set(DBaseState.HOVERED, isHovered);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inHovered", {
            get: function () {
                return this.in(DBaseState.HOVERED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onHovered", {
            get: function () {
                return this.on(DBaseState.HOVERED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underHovered", {
            get: function () {
                return this.under(DBaseState.HOVERED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isActive", {
            get: function () {
                return this.is(DBaseState.ACTIVE);
            },
            set: function (isActive) {
                this.set(DBaseState.ACTIVE, isActive);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inActive", {
            get: function () {
                return this.in(DBaseState.ACTIVE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onActive", {
            get: function () {
                return this.on(DBaseState.ACTIVE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underActive", {
            get: function () {
                return this.under(DBaseState.ACTIVE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isPressed", {
            get: function () {
                return this.is(DBaseState.PRESSED);
            },
            set: function (isPressed) {
                this.set(DBaseState.PRESSED, isPressed);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inPressed", {
            get: function () {
                return this.in(DBaseState.PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onPressed", {
            get: function () {
                return this.on(DBaseState.PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underPressed", {
            get: function () {
                return this.under(DBaseState.PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isReadOnly", {
            get: function () {
                return this.is(DBaseState.READ_ONLY);
            },
            set: function (isReadOnly) {
                this.set(DBaseState.READ_ONLY, isReadOnly);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inReadOnly", {
            get: function () {
                return this.in(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onReadOnly", {
            get: function () {
                return this.on(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underReadOnly", {
            get: function () {
                return this.under(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isEnabled", {
            get: function () {
                return !this.is(DBaseState.DISABLED);
            },
            set: function (isEnabled) {
                this.set(DBaseState.DISABLED, !isEnabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inEnabled", {
            get: function () {
                return !this.in(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onEnabled", {
            get: function () {
                return !this.on(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underEnabled", {
            get: function () {
                return !this.under(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isDisabled", {
            get: function () {
                return this.is(DBaseState.DISABLED);
            },
            set: function (isDisabled) {
                this.set(DBaseState.DISABLED, isDisabled);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inDisabled", {
            get: function () {
                return this.in(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onDisabled", {
            get: function () {
                return this.on(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underDisabled", {
            get: function () {
                return this.under(DBaseState.DISABLED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isActionable", {
            get: function () {
                return !this.in(DBaseState.DISABLED) && !this.in(DBaseState.READ_ONLY);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isGesturing", {
            get: function () {
                return this.is(DBaseState.GESTURING);
            },
            set: function (isGesturing) {
                this.set(DBaseState.GESTURING, isGesturing);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inGesturing", {
            get: function () {
                return this.in(DBaseState.GESTURING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onGesturing", {
            get: function () {
                return this.on(DBaseState.GESTURING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underGesturing", {
            get: function () {
                return this.under(DBaseState.GESTURING);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocused", {
            get: function () {
                return this.is(DBaseState.FOCUSED);
            },
            set: function (isFocused) {
                this.set(DBaseState.FOCUSED, isFocused);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocused", {
            get: function () {
                return this.in(DBaseState.FOCUSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocused", {
            get: function () {
                return this.on(DBaseState.FOCUSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocused", {
            get: function () {
                return this.under(DBaseState.FOCUSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocusRoot", {
            get: function () {
                return this.is(DBaseState.FOCUS_ROOT);
            },
            set: function (isFocusRoot) {
                this.set(DBaseState.FOCUS_ROOT, isFocusRoot);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocusRoot", {
            get: function () {
                return this.in(DBaseState.FOCUS_ROOT);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocusRoot", {
            get: function () {
                return this.on(DBaseState.FOCUS_ROOT);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocusRoot", {
            get: function () {
                return this.under(DBaseState.FOCUS_ROOT);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocusReverse", {
            get: function () {
                return this.is(DBaseState.FOCUS_REVERSE);
            },
            set: function (isFocusReverse) {
                this.set(DBaseState.FOCUS_REVERSE, isFocusReverse);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocusReverse", {
            get: function () {
                return this.in(DBaseState.FOCUS_REVERSE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocusReverse", {
            get: function () {
                return this.on(DBaseState.FOCUS_REVERSE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocusReverse", {
            get: function () {
                return this.under(DBaseState.FOCUS_REVERSE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFocusable", {
            get: function () {
                return !this.is(DBaseState.UNFOCUSABLE);
            },
            set: function (isFocusable) {
                this.set(DBaseState.UNFOCUSABLE, !isFocusable);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFocusable", {
            get: function () {
                return !this.in(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFocusable", {
            get: function () {
                return !this.on(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFocusable", {
            get: function () {
                return !this.under(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isUnfocusable", {
            get: function () {
                return this.is(DBaseState.UNFOCUSABLE);
            },
            set: function (unfocusable) {
                this.set(DBaseState.UNFOCUSABLE, unfocusable);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inUnfocusable", {
            get: function () {
                return this.in(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onUnfocusable", {
            get: function () {
                return this.on(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underUnfocusable", {
            get: function () {
                return this.under(DBaseState.UNFOCUSABLE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isInvalid", {
            get: function () {
                return this.is(DBaseState.INVALID);
            },
            set: function (invalid) {
                this.set(DBaseState.INVALID, invalid);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inInvalid", {
            get: function () {
                return this.in(DBaseState.INVALID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onInvalid", {
            get: function () {
                return this.on(DBaseState.INVALID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underInvalid", {
            get: function () {
                return this.on(DBaseState.INVALID);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isSucceeded", {
            get: function () {
                return this.is(DBaseState.SUCCEEDED);
            },
            set: function (succeeded) {
                this.set(DBaseState.SUCCEEDED, succeeded);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inSucceeded", {
            get: function () {
                return this.in(DBaseState.SUCCEEDED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onSucceeded", {
            get: function () {
                return this.on(DBaseState.SUCCEEDED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underSucceeded", {
            get: function () {
                return this.under(DBaseState.SUCCEEDED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isFailed", {
            get: function () {
                return this.is(DBaseState.FAILED);
            },
            set: function (failed) {
                this.set(DBaseState.FAILED, failed);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inFailed", {
            get: function () {
                return this.in(DBaseState.FAILED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onFailed", {
            get: function () {
                return this.on(DBaseState.FAILED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underFailed", {
            get: function () {
                return this.under(DBaseState.FAILED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isWarned", {
            get: function () {
                return this.is(DBaseState.WARNED);
            },
            set: function (isWarned) {
                this.set(DBaseState.WARNED, isWarned);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inWarned", {
            get: function () {
                return this.in(DBaseState.WARNED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onWarned", {
            get: function () {
                return this.on(DBaseState.WARNED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underWarned", {
            get: function () {
                return this.on(DBaseState.WARNED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isChanged", {
            get: function () {
                return this.is(DBaseState.CHANGED);
            },
            set: function (isChanged) {
                this.set(DBaseState.CHANGED, isChanged);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inChanged", {
            get: function () {
                return this.in(DBaseState.CHANGED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onChanged", {
            get: function () {
                return this.on(DBaseState.CHANGED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underChanged", {
            get: function () {
                return this.on(DBaseState.CHANGED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "isAlternated", {
            get: function () {
                return this.is(DBaseState.ALTERNATED);
            },
            set: function (isAlternated) {
                this.set(DBaseState.ALTERNATED, isAlternated);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "inAlternated", {
            get: function () {
                return this.in(DBaseState.ALTERNATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "onAlternated", {
            get: function () {
                return this.on(DBaseState.ALTERNATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseStateSetImpl.prototype, "underAlternated", {
            get: function () {
                return this.on(DBaseState.ALTERNATED);
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImpl.prototype.toObject = function () {
            var states = [];
            this._local.forEach(function (value, state) {
                states.push(state);
            });
            return {
                local: states
            };
        };
        DBaseStateSetImpl.prototype.toString = function () {
            return JSON.stringify(this.toObject());
        };
        return DBaseStateSetImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseStateSetImplObservable = /** @class */ (function (_super) {
        __extends(DBaseStateSetImplObservable, _super);
        function DBaseStateSetImplObservable(onChange) {
            var _this = _super.call(this) || this;
            _this._onChange = onChange;
            _this._isLocked = 0;
            _this._isSaved = false;
            _this._doSave = true;
            return _this;
        }
        DBaseStateSetImplObservable.prototype.lock = function (callOnChange) {
            this._isLocked += 1;
            if (callOnChange === false) {
                this._doSave = false;
            }
            return this;
        };
        DBaseStateSetImplObservable.prototype.unlock = function () {
            this._isLocked -= 1;
            return this.end();
        };
        Object.defineProperty(DBaseStateSetImplObservable.prototype, "saved", {
            get: function () {
                var result = this._saved;
                if (result == null) {
                    result = new DBaseStateSetImpl();
                    this._saved = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DBaseStateSetImplObservable.prototype.begin = function () {
            if (this._doSave && !this._isSaved) {
                this._isSaved = true;
                this.saved.copy(this);
            }
            return this;
        };
        DBaseStateSetImplObservable.prototype.end = function () {
            if (this._isLocked <= 0) {
                this._doSave = true;
                if (this._isSaved) {
                    this._isSaved = false;
                    this.onChange(this, this.saved);
                }
            }
            return this;
        };
        DBaseStateSetImplObservable.prototype.onChange = function (newState, oldState) {
            this._onChange(newState, oldState);
        };
        return DBaseStateSetImplObservable;
    }(DBaseStateSetImpl));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeState = {
        CLICKED: "CLICKED",
        DBL_CLICKED: "DBL_CLICKED",
        DOWN: "DOWN",
        UP: "UP",
        UP_OUTSIDE: "UP_OUTSIDE",
        RIGHT_CLICKED: "RIGHT_CLICKED",
        RIGHT_DOWN: "RIGHT_DOWN",
        RIGHT_UP: "RIGHT_UP",
        RIGHT_UP_OUTSIDE: "RIGHT_UP_OUTSIDE",
        RIGHT_PRESSED: "RIGHT_PRESSED",
        ACTIVATED: "ACTIVATED",
        DEACTIVATED: "DEACTIVATED"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStateSetImplObservable = /** @class */ (function (_super) {
        __extends(EShapeStateSetImplObservable, _super);
        function EShapeStateSetImplObservable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeStateSetImplObservable.prototype.onChange = function (newState, oldState) {
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this._local.set(EShapeState.ACTIVATED, null).delete(EShapeState.DEACTIVATED);
                }
            }
            else {
                if (oldState.isActive) {
                    this._local.set(EShapeState.DEACTIVATED, null).delete(EShapeState.ACTIVATED);
                }
            }
            _super.prototype.onChange.call(this, newState, oldState);
        };
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isClicked", {
            get: function () {
                return this.is(EShapeState.CLICKED);
            },
            set: function (isClicked) {
                this.set(EShapeState.CLICKED, isClicked);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inClicked", {
            get: function () {
                return this.in(EShapeState.CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onClicked", {
            get: function () {
                return this.on(EShapeState.CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underClicked", {
            get: function () {
                return this.under(EShapeState.CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isDblClicked", {
            get: function () {
                return this.is(EShapeState.DBL_CLICKED);
            },
            set: function (isDblClicked) {
                this.set(EShapeState.DBL_CLICKED, isDblClicked);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inDblClicked", {
            get: function () {
                return this.in(EShapeState.DBL_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onDblClicked", {
            get: function () {
                return this.on(EShapeState.DBL_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underDblClicked", {
            get: function () {
                return this.under(EShapeState.DBL_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isDown", {
            get: function () {
                return this.is(EShapeState.DOWN);
            },
            set: function (isDown) {
                this.set(EShapeState.DOWN, isDown);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inDown", {
            get: function () {
                return this.in(EShapeState.DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onDown", {
            get: function () {
                return this.on(EShapeState.DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underDown", {
            get: function () {
                return this.under(EShapeState.DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isUp", {
            get: function () {
                return this.is(EShapeState.UP);
            },
            set: function (isUp) {
                this.set(EShapeState.UP, isUp);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inUp", {
            get: function () {
                return this.in(EShapeState.UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onUp", {
            get: function () {
                return this.on(EShapeState.UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underUp", {
            get: function () {
                return this.under(EShapeState.UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isUpOutside", {
            get: function () {
                return this.is(EShapeState.UP_OUTSIDE);
            },
            set: function (isUpOutside) {
                this.set(EShapeState.UP_OUTSIDE, isUpOutside);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inUpOutside", {
            get: function () {
                return this.in(EShapeState.UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onUpOutside", {
            get: function () {
                return this.on(EShapeState.UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underUpOutside", {
            get: function () {
                return this.under(EShapeState.UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightClicked", {
            get: function () {
                return this.is(EShapeState.RIGHT_CLICKED);
            },
            set: function (isRightClicked) {
                this.set(EShapeState.RIGHT_CLICKED, isRightClicked);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightClicked", {
            get: function () {
                return this.in(EShapeState.RIGHT_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightClicked", {
            get: function () {
                return this.on(EShapeState.RIGHT_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightClicked", {
            get: function () {
                return this.under(EShapeState.RIGHT_CLICKED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightDown", {
            get: function () {
                return this.is(EShapeState.RIGHT_DOWN);
            },
            set: function (isRightDown) {
                this.set(EShapeState.RIGHT_DOWN, isRightDown);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightDown", {
            get: function () {
                return this.in(EShapeState.RIGHT_DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightDown", {
            get: function () {
                return this.on(EShapeState.RIGHT_DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightDown", {
            get: function () {
                return this.under(EShapeState.RIGHT_DOWN);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightUp", {
            get: function () {
                return this.is(EShapeState.RIGHT_UP);
            },
            set: function (isRightUp) {
                this.set(EShapeState.RIGHT_UP, isRightUp);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightUp", {
            get: function () {
                return this.in(EShapeState.RIGHT_UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightUp", {
            get: function () {
                return this.on(EShapeState.RIGHT_UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightUp", {
            get: function () {
                return this.under(EShapeState.RIGHT_UP);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightUpOutside", {
            get: function () {
                return this.is(EShapeState.RIGHT_UP_OUTSIDE);
            },
            set: function (isRightUpOutside) {
                this.set(EShapeState.RIGHT_UP_OUTSIDE, isRightUpOutside);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightUpOutside", {
            get: function () {
                return this.in(EShapeState.RIGHT_UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightUpOutside", {
            get: function () {
                return this.on(EShapeState.RIGHT_UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightUpOutside", {
            get: function () {
                return this.under(EShapeState.RIGHT_UP_OUTSIDE);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isRightPressed", {
            get: function () {
                return this.is(EShapeState.RIGHT_PRESSED);
            },
            set: function (isRightPressed) {
                this.set(EShapeState.RIGHT_PRESSED, isRightPressed);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inRightPressed", {
            get: function () {
                return this.in(EShapeState.RIGHT_PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onRightPressed", {
            get: function () {
                return this.on(EShapeState.RIGHT_PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underRightPressed", {
            get: function () {
                return this.under(EShapeState.RIGHT_PRESSED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isActivated", {
            get: function () {
                return this.is(EShapeState.ACTIVATED);
            },
            set: function (isActivated) {
                this.set(EShapeState.ACTIVATED, isActivated);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inActivated", {
            get: function () {
                return this.in(EShapeState.ACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onActivated", {
            get: function () {
                return this.on(EShapeState.ACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underActivated", {
            get: function () {
                return this.under(EShapeState.ACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "isDeactivated", {
            get: function () {
                return this.is(EShapeState.DEACTIVATED);
            },
            set: function (isDeactivated) {
                this.set(EShapeState.DEACTIVATED, isDeactivated);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "inDeactivated", {
            get: function () {
                return this.in(EShapeState.DEACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "onDeactivated", {
            get: function () {
                return this.on(EShapeState.DEACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStateSetImplObservable.prototype, "underDeactivated", {
            get: function () {
                return this.under(EShapeState.DEACTIVATED);
            },
            enumerable: false,
            configurable: true
        });
        return EShapeStateSetImplObservable;
    }(DBaseStateSetImplObservable));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTransformImpl = /** @class */ (function (_super) {
        __extends(EShapeTransformImpl, _super);
        function EShapeTransformImpl(parent) {
            var _this = _super.call(this) || this;
            _this.internalTransform = new pixi_js.Matrix();
            _this._parent = parent;
            return _this;
        }
        EShapeTransformImpl.prototype.onChange = function () {
            _super.prototype.onChange.call(this);
            this._parent.onTransformChange();
        };
        EShapeTransformImpl.prototype.updateSkew = function () {
            _super.prototype.updateSkew.call(this);
            this._parent.onTransformChange();
        };
        EShapeTransformImpl.prototype.getLocalIdCurrent = function () {
            return this._currentLocalID;
        };
        EShapeTransformImpl.prototype.getLocalId = function () {
            return this._localID;
        };
        EShapeTransformImpl.prototype.getParentId = function () {
            return this._parentID;
        };
        EShapeTransformImpl.prototype.getWorldId = function () {
            return this._worldID;
        };
        EShapeTransformImpl.prototype.updateTransform = function (parentTransform) {
            var oldLocalId = this._currentLocalID;
            var oldWorldId = this._worldID;
            _super.prototype.updateTransform.call(this, parentTransform);
            var newLocalId = this._currentLocalID;
            var newWorldId = this._worldID;
            if (oldLocalId !== newLocalId) {
                var localTransform = this.localTransform;
                var internalTransform = this.internalTransform;
                localTransform.copyTo(internalTransform);
                if (parentTransform instanceof EShapeTransformImpl) {
                    internalTransform.prepend(parentTransform.internalTransform);
                }
            }
            else if (oldWorldId !== newWorldId) {
                var localTransform = this.localTransform;
                var internalTransform = this.internalTransform;
                if (parentTransform instanceof EShapeTransformImpl) {
                    localTransform.copyTo(internalTransform).prepend(parentTransform.internalTransform);
                    this._currentLocalID += 1;
                    this._localID = this._currentLocalID;
                }
            }
        };
        return EShapeTransformImpl;
    }(pixi_js.Transform));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBaseHitTestData = /** @class */ (function () {
        function EShapeBaseHitTestData() {
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            this.strokeWidth = 0;
            this.strokeScale = 1;
            this.strokeAlign = 0;
        }
        EShapeBaseHitTestData.prototype.set = function (x, y, width, height, strokeWidth, strokeScale, strokeAlign) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.strokeWidth = strokeWidth;
            this.strokeScale = strokeScale;
            this.strokeAlign = strokeAlign;
            return this;
        };
        return EShapeBaseHitTestData;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestBBox = function (x, y, ax, ay) {
        return -ax <= x && x <= +ax && -ay <= y && y <= +ay;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toGradientSerialized = function (gradient) {
        var points = gradient.points;
        var result = "[".concat(gradient.direction);
        for (var i = 0, imax = points.length, j = 1; i < imax; i += 1, j += 3) {
            var point = points[i];
            result += ",".concat(point.color, ",").concat(point.alpha, ",").concat(point.position);
        }
        result += "]";
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /* eslint-disable prettier/prettier */
    var NONE = 0x0;
    var ID = 0x1;
    var POSITION = 0x2;
    var WIDTH$1 = 0x4;
    var HEIGHT$1 = 0x8;
    var ROTATION$1 = 0x10;
    var SKEW = 0x20;
    var REPLACING = 0x40;
    var GROUPING = 0x80;
    var UNGROUPING = 0x100;
    var FILL$1 = 0x200;
    var STROKE$1 = 0x400;
    var STROKE_SIDE = 0x800;
    var BORDER_RADIUS = 0x1000;
    var TEXT$2 = 0x2000;
    var TEXTURE = 0x4000;
    var DATA = 0x8000;
    var ACTION = 0x10000;
    var CURSOR$1 = 0x20000;
    var ORDER_IN_LAYER = 0x40000;
    var CHILDREN$1 = 0x80000;
    var DATA_MAPPING = 0x100000;
    var COORDINATE = POSITION | WIDTH$1 | HEIGHT$1 | ROTATION$1 | SKEW;
    var SHAPE = REPLACING | GROUPING | FILL$1 | STROKE$1;
    var LAYER = ORDER_IN_LAYER;
    var PRIMITIVE = ID | COORDINATE | SHAPE | TEXT$2 | TEXTURE | DATA | ACTION | CURSOR$1 | LAYER | CHILDREN$1;
    var GROUP = PRIMITIVE | UNGROUPING;
    var EMBEDDED = ID | COORDINATE | REPLACING | GROUPING | TEXT$2 | DATA | ACTION | LAYER | DATA_MAPPING;
    var CONNECTOR = ID | REPLACING | FILL$1 | STROKE$1 | TEXT$2 | TEXTURE | DATA | ACTION | CURSOR$1 | LAYER | CHILDREN$1;
    var ALL = PRIMITIVE | STROKE_SIDE | BORDER_RADIUS | DATA_MAPPING | UNGROUPING;
    var EShapeCapability = {
        NONE: NONE,
        /**
         * Allows shape IDs to be modified.
         */
        ID: ID,
        /**
         * Allows shape positions to be modified.
         */
        POSITION: POSITION,
        /**
         * Allows shape widths to be modified.
         */
        WIDTH: WIDTH$1,
        /**
         * Allows shape heights to be modified.
         */
        HEIGHT: HEIGHT$1,
        /**
         * Allows shape rotations to be modified.
         */
        ROTATION: ROTATION$1,
        /**
         * Allows shape skews to be modified.
         */
        SKEW: SKEW,
        /** @deprecated */
        ALIGN: NONE,
        /**
         * Allows shapes to be replaced with other shapes.
         */
        REPLACING: REPLACING,
        /**
         * Allows shapes to be grouped.
         */
        GROUPING: GROUPING,
        /**
         * Allows grouped shapes to be ungrouped.
         */
        UNGROUPING: UNGROUPING,
        /**
         * Allows shape fills to be modified.
         */
        FILL: FILL$1,
        /**
         * Allows shape strokes to be modified.
         */
        STROKE: STROKE$1,
        /**
         * Allows shape stroke sides to be modified.
         */
        STROKE_SIDE: STROKE_SIDE,
        /**
         * Allows shape border radiuses to be modified.
         */
        BORDER_RADIUS: BORDER_RADIUS,
        /**
         * Allows shape texts to be modified.
         */
        TEXT: TEXT$2,
        /**
         * Allows shape textures to be modified.
         */
        TEXTURE: TEXTURE,
        /** @deprecated in favor of {@link DATA} */
        TAG: DATA,
        /**
         * Allows shape data to be modified.
         */
        DATA: DATA,
        /**
         * Allows shape data mapping to be modified.
         */
        DATA_MAPPING: DATA_MAPPING,
        /**
         * Allows shape actions to be modified.
         */
        ACTION: ACTION,
        /**
         * Allows shape cursors to be modified.
         */
        CURSOR: CURSOR$1,
        /**
         * Allows shape orders in layer to be modified.
         */
        ORDER_IN_LAYER: ORDER_IN_LAYER,
        /**
         * Allows shape children to be modified.
         */
        CHILDREN: CHILDREN$1,
        COORDINATE: COORDINATE,
        SHAPE: SHAPE,
        LAYER: LAYER,
        PRIMITIVE: PRIMITIVE,
        GROUP: GROUP,
        EMBEDDED: EMBEDDED,
        CONNECTOR: CONNECTOR,
        ALL: ALL
    };

    var EShapeCapabilityContainerImpl = /** @class */ (function () {
        function EShapeCapabilityContainerImpl() {
            this.added = EShapeCapability.NONE;
            this.removed = EShapeCapability.NONE;
            this.locked = EShapeCapability.NONE;
        }
        EShapeCapabilityContainerImpl.prototype.add = function (target) {
            this.removed &= ~target;
            this.added |= target;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.remove = function (target) {
            this.added &= ~target;
            this.removed |= target;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.lock = function (target) {
            this.locked |= target;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.unlock = function (target) {
            this.locked &= ~target;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.clear = function () {
            this.added = EShapeCapability.NONE;
            this.removed = EShapeCapability.NONE;
            this.locked = EShapeCapability.NONE;
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.set = function (added, removed, locked) {
            if (added != null) {
                this.added = added;
            }
            if (removed != null) {
                this.removed = removed;
            }
            if (locked != null) {
                this.locked = locked;
            }
            return this;
        };
        EShapeCapabilityContainerImpl.prototype.copy = function (target) {
            this.added = target.added;
            this.removed = target.removed;
            this.locked = target.locked;
            return this;
        };
        return EShapeCapabilityContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBase = /** @class */ (function (_super) {
        __extends(EShapeBase, _super);
        function EShapeBase(type) {
            var _this = _super.call(this) || this;
            _this.id = "";
            _this.uuid = 0;
            _this.type = type;
            _this.transform = _this.newTransform();
            _this._onTransformChangeLock = 0;
            _this._isOnTransformChanged = false;
            _this.action = new EShapeAction();
            _this._visible = true;
            _this._uploadedUpdateLock = 0;
            _this._isUploadedUpdated = false;
            _this._isUploadedUpdatedRecursively = false;
            _this._boundsTransformId = NaN;
            _this._boundsInternalTransformId = NaN;
            _this._boundsLocalTransformId = NaN;
            _this.interactive = false;
            //
            _this.parent = null;
            _this.children = [];
            //
            _this.selected = false;
            _this.index = 0;
            _this.reference = 0;
            return _this;
        }
        EShapeBase.prototype.newTransform = function () {
            return new EShapeTransformImpl(this);
        };
        EShapeBase.prototype.onSizeChange = function () {
            this._boundsTransformId = NaN;
            this._boundsInternalTransformId = NaN;
            this._boundsLocalTransformId = NaN;
            this.onTransformChange_();
            var points = this._points;
            if (points != null) {
                points.onSizeChange();
            }
            this.updateUploaded();
            var connector = this._connector;
            if (connector != null) {
                connector.fit(true);
            }
            var runtime = this.runtime;
            if (runtime != null) {
                runtime.onResize(this);
            }
        };
        EShapeBase.prototype.onTransformChange = function () {
            this.onTransformChange_();
            this.onParentTransformChange();
        };
        EShapeBase.prototype.onParentTransformChange = function () {
            this.updateUploaded();
            var connector = this._connector;
            if (connector != null) {
                connector.fit(true);
            }
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].onParentTransformChange();
            }
        };
        EShapeBase.prototype.onTransformChange_ = function () {
            if (this._onTransformChangeLock === 0) {
                var parent_1 = this.parent;
                if (parent_1 != null) {
                    parent_1.onChildTransformChange();
                }
            }
            else {
                this._isOnTransformChanged = true;
            }
        };
        EShapeBase.prototype.disallowOnTransformChange = function () {
            this._onTransformChangeLock += 1;
            if (this._onTransformChangeLock === 1) {
                this._isOnTransformChanged = false;
            }
        };
        EShapeBase.prototype.allowOnTransformChange = function (invokeOnTransformChange) {
            this._onTransformChangeLock -= 1;
            if (this._onTransformChangeLock === 0) {
                if (this._isOnTransformChanged) {
                    this._isOnTransformChanged = false;
                    if (invokeOnTransformChange) {
                        this.onTransformChange();
                    }
                }
            }
        };
        EShapeBase.prototype.onChildTransformChange = function () {
            //
        };
        EShapeBase.prototype.disallowUploadedUpdate = function () {
            this._uploadedUpdateLock += 1;
            if (this._uploadedUpdateLock === 1) {
                this._isUploadedUpdated = false;
                this._isUploadedUpdatedRecursively = false;
            }
        };
        EShapeBase.prototype.allowUploadedUpdate = function () {
            this._uploadedUpdateLock -= 1;
            if (this._uploadedUpdateLock === 0) {
                if (this._isUploadedUpdatedRecursively) {
                    this._isUploadedUpdatedRecursively = false;
                    this._isUploadedUpdated = false;
                    this.updateUploadedRecursively();
                }
                else if (this._isUploadedUpdated) {
                    this._isUploadedUpdated = false;
                    this.updateUploaded();
                }
            }
        };
        EShapeBase.prototype.updateUploadedRecursively = function () {
            if (this._uploadedUpdateLock === 0) {
                this.updateUploaded();
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].updateUploadedRecursively();
                }
            }
            else {
                this._isUploadedUpdatedRecursively = true;
            }
        };
        EShapeBase.prototype.updateUploaded = function () {
            if (this._uploadedUpdateLock === 0) {
                var uploaded = this.uploaded;
                if (uploaded != null) {
                    uploaded.update(this);
                }
            }
            else {
                this._isUploadedUpdated = true;
            }
        };
        Object.defineProperty(EShapeBase.prototype, "image", {
            get: function () {
                return this._image;
            },
            set: function (image) {
                this._image = image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "root", {
            get: function () {
                var root = this;
                while (root.parent instanceof EShapeBase) {
                    root = root.parent;
                }
                return root;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "connector", {
            get: function () {
                var result = this._connector;
                if (result == null) {
                    result = new EShapeConnectorContainerImpl(this);
                    this._connector = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "visible", {
            get: function () {
                if (this._visible) {
                    var parent_2 = this.parent;
                    if (parent_2 instanceof EShapeBase) {
                        return parent_2.visible;
                    }
                    return true;
                }
                return false;
            },
            set: function (visible) {
                if (this._visible !== visible) {
                    this._visible = visible;
                    this.updateUploadedRecursively();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "worldVisible", {
            get: function () {
                if (this._visible) {
                    var parent_3 = this.parent;
                    if (parent_3) {
                        return parent_3.worldVisible;
                    }
                    return true;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        //
        EShapeBase.prototype.toDirty = function () {
            var parent = this.parent;
            if (parent != null) {
                parent.toDirty();
            }
        };
        // Hierarchy
        EShapeBase.prototype.attach = function (parent, at) {
            this.detach();
            this.parent = parent;
            var children = parent.children;
            if (at != null && 0 <= at && at < children.length) {
                children.splice(at, 0, this);
            }
            else {
                children.push(this);
            }
            parent.onChildTransformChange();
            parent.toDirty();
            this.onAttach();
            return this;
        };
        EShapeBase.prototype.onAttach = function () {
            this.uploaded = undefined;
            var connector = this._connector;
            if (connector) {
                connector.attach();
                connector.fit(true);
            }
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].onAttach();
            }
        };
        EShapeBase.prototype.detach = function () {
            var parent = this.parent;
            if (parent) {
                this.parent = null;
                var children = parent.children;
                var index = children.indexOf(this);
                if (0 <= index) {
                    children.splice(index, 1);
                    parent.onChildTransformChange();
                    parent.toDirty();
                    this.onDetach();
                }
            }
            return this;
        };
        EShapeBase.prototype.onDetach = function () {
            this.uploaded = undefined;
            var connector = this._connector;
            if (connector) {
                connector.detach();
            }
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].onDetach();
            }
        };
        // Transform
        EShapeBase.prototype.updateTransform = function () {
            var parent = this.parent;
            if (parent) {
                if (parent.parent) {
                    parent.updateTransform();
                }
                this.transform.updateTransform(parent.transform);
            }
            else {
                this.transform.updateTransform(pixi_js.Transform.IDENTITY);
            }
        };
        // Serialization
        EShapeBase.prototype.serializeChildren = function (manager) {
            var children = this.children;
            var childrenSerialized = [];
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                childrenSerialized.push(child.serialize(manager));
            }
            return childrenSerialized;
        };
        EShapeBase.prototype.serializeImage = function (manager) {
            var image = this._image;
            return image != null ? manager.addResource(image.src) : -1;
        };
        EShapeBase.prototype.serializeGradient = function (manager) {
            var gradient = this.gradient;
            if (gradient != null) {
                if (gradient.serialized == null) {
                    gradient.serialized = toGradientSerialized(gradient);
                }
                return manager.addResource(gradient.serialized);
            }
            return -1;
        };
        EShapeBase.prototype.serializeState = function (manager) {
            var state = this.state;
            return (this.interactive ? 1 : 0) | (state.isFocusable ? 0 : 2) | (state.isActive ? 4 : 0);
        };
        EShapeBase.prototype.serialize = function (manager) {
            var transform = this.transform;
            var position = transform.position;
            var pivot = transform.pivot;
            var size = this.size;
            var shortcut = this.shortcut;
            var shortcutId = shortcut != null ? manager.addResource(shortcut) : -1;
            var cursor = this.cursor;
            var cursorId = cursor != null ? manager.addResource(cursor) : -1;
            var title = this.title;
            var titleId = title != null ? manager.addResource(title) : -1;
            var capabilitiesAdded = EShapeCapability.NONE;
            var capabilitiesRemoved = EShapeCapability.NONE;
            var capabilitiesLocked = EShapeCapability.NONE;
            var capability = this._capability;
            if (capability != null) {
                capabilitiesAdded = capability.added;
                capabilitiesRemoved = capability.removed;
                capabilitiesLocked = capability.locked;
            }
            return [
                this.type,
                manager.addResource(this.id),
                position.x,
                position.y,
                size.x,
                size.y,
                transform.rotation,
                transform.skew.x,
                this.fill.serialize(manager),
                this.stroke.serialize(manager),
                cursorId,
                this.text.serialize(manager),
                this.data.serialize(manager),
                this.radius,
                this.corner,
                -1,
                -1,
                this.action.serialize(manager),
                this.serializeImage(manager),
                this.serializeGradient(manager),
                this.serializeChildren(manager),
                pivot.x,
                pivot.y,
                this.serializeState(manager),
                shortcutId,
                titleId,
                this.uuid,
                capabilitiesAdded,
                capabilitiesRemoved,
                capabilitiesLocked
            ];
        };
        EShapeBase.prototype.addUuid = function (manager) {
            this.uuid = manager.addUuid(this.uuid);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
        };
        EShapeBase.prototype.updateUuid = function (manager) {
            this.uuid = manager.updateUuid(this.uuid);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
        };
        // Hit test
        EShapeBase.prototype.getShapeScale = function () {
            var container = this.root.parent;
            if (container != null && container.getShapeScale != null) {
                return container.getShapeScale();
            }
            return 1.0;
        };
        EShapeBase.prototype.getStrokeWidthScale = function (style) {
            if (style & EShapeStrokeStyle.NON_EXPANDING_WIDTH) {
                if (style & EShapeStrokeStyle.NON_SHRINKING_WIDTH) {
                    return this.getShapeScale();
                }
                else {
                    return Math.min(1.0, this.getShapeScale());
                }
            }
            else {
                if (style & EShapeStrokeStyle.NON_SHRINKING_WIDTH) {
                    return Math.max(1.0, this.getShapeScale());
                }
                else {
                    return 1.0;
                }
            }
        };
        EShapeBase.prototype.getHitTestSize = function (result) {
            var size = this.size;
            result.width = 0.5 * size.x;
            result.height = 0.5 * size.y;
            return result;
        };
        EShapeBase.prototype.toHitTestData = function (x, y) {
            var _a;
            var result = this.getHitTestSize(((_a = EShapeBase.WORK_HIT_TEST_DATA) !== null && _a !== void 0 ? _a : (EShapeBase.WORK_HIT_TEST_DATA = new EShapeBaseHitTestData())));
            var sx = result.width;
            var sy = result.height;
            var pivot = this.transform.pivot;
            var dx = x - pivot.x;
            var dy = y - pivot.y;
            var stroke = this.stroke;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeScale = this.getStrokeWidthScale(stroke.style);
            var strokeAlign = stroke.align;
            var s = strokeWidth * strokeScale * strokeAlign;
            return result.set(0 <= sx ? +dx : -dx, 0 <= sy ? +dy : -dy, Math.abs(sx) + s, Math.abs(sy) + s, strokeWidth, strokeScale, strokeAlign);
        };
        EShapeBase.prototype.contains = function (x, y) {
            var data = this.toHitTestData(x, y);
            if (this.containsAbs(data.x, data.y, data.width, data.height, data.strokeWidth, data.strokeScale, data.strokeAlign)) {
                return this;
            }
            return this.containsText(x, y) || this.containsChildren(x, y);
        };
        EShapeBase.prototype.containsText = function (x, y) {
            var text = this.text;
            var textAtlas = text.atlas;
            if (textAtlas != null) {
                var textWorld = text.world;
                if (textWorld != null) {
                    var transform = this.transform.internalTransform;
                    var tx = transform.a * x + transform.c * y + transform.tx - textWorld[0];
                    var ty = transform.b * x + transform.d * y + transform.ty - textWorld[1];
                    var th = textWorld[2] * tx + textWorld[3] * ty;
                    var tv = textWorld[4] * tx + textWorld[5] * ty;
                    var w = textWorld[6];
                    var h = textWorld[7];
                    if (0 <= th && th <= w && 0 <= tv && tv <= h) {
                        return this;
                    }
                }
            }
            return null;
        };
        EShapeBase.prototype.containsChildren = function (x, y) {
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                child.updateTransform();
                var localTransform = child.transform.localTransform;
                var a = localTransform.a;
                var b = localTransform.b;
                var c = localTransform.c;
                var d = localTransform.d;
                var tx = localTransform.tx;
                var ty = localTransform.ty;
                var id = 1 / (a * d - c * b);
                var lx = (d * x - c * y + ty * c - tx * d) * id;
                var ly = (a * y - b * x - ty * a + tx * b) * id;
                var childResult = child.contains(lx, ly);
                if (childResult != null) {
                    return childResult;
                }
            }
            return null;
        };
        EShapeBase.prototype.containsBBox = function (x, y) {
            var data = this.toHitTestData(x, y);
            return this.containsAbsBBox(data.x, data.y, data.width, data.height);
        };
        EShapeBase.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            return this.containsAbsBBox(x, y, ax, ay);
        };
        EShapeBase.prototype.containsAbsBBox = function (x, y, ax, ay) {
            return hitTestBBox(x, y, ax, ay);
        };
        EShapeBase.prototype.select = function (point) {
            return false;
        };
        //
        EShapeBase.prototype.toGlobal = function (position, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            result.copyFrom(position);
            this.transform.worldTransform.apply(result, result);
            return result;
        };
        EShapeBase.prototype.toLocal = function (position, from, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            if (result === undefined) {
                result = new pixi_js.Point();
            }
            result.copyFrom(position);
            this.transform.worldTransform.applyInverse(result, result);
            return result;
        };
        EShapeBase.prototype.getBounds = function (skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var bounds = this._bounds || new pixi_js.Rectangle();
            this._bounds = bounds;
            var worldId = this.transform.getWorldId();
            if (worldId !== this._boundsTransformId) {
                this._boundsTransformId = worldId;
                this.getBounds_(this.transform.worldTransform, bounds);
            }
            result.copyFrom(bounds);
            return result;
        };
        EShapeBase.prototype.getBoundsInternal = function (skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var boundsInternal = this._boundsInternal || new pixi_js.Rectangle();
            this._boundsInternal = boundsInternal;
            var currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsInternalTransformId) {
                this._boundsInternalTransformId = currentLocalId;
                this.getBounds_(this.transform.internalTransform, boundsInternal);
            }
            result.copyFrom(boundsInternal);
            return result;
        };
        EShapeBase.prototype.getBoundsLocal = function (skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            var boundsLocal = this._boundsLocal || new pixi_js.Rectangle();
            this._boundsLocal = boundsLocal;
            var currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsLocalTransformId) {
                this._boundsLocalTransformId = currentLocalId;
                this.getBounds_(this.transform.localTransform, boundsLocal);
            }
            result.copyFrom(boundsLocal);
            return result;
        };
        EShapeBase.prototype.getBoundsSize = function () {
            return this.size;
        };
        EShapeBase.prototype.getBounds_ = function (transform, result) {
            var pivot = this.transform.pivot;
            var px = pivot.x;
            var py = pivot.y;
            var size = this.getBoundsSize();
            var sx = 0.5 * size.x;
            var sy = 0.5 * size.y;
            var a = transform.a;
            var b = transform.b;
            var c = transform.c;
            var d = transform.d;
            var x = -sx + px;
            var y = -sy + py;
            var x0 = a * x + c * y;
            var y0 = b * x + d * y;
            x = +sx + px;
            y = -sy + py;
            var x1 = a * x + c * y;
            var y1 = b * x + d * y;
            x = -sx + px;
            y = +sy + py;
            var x2 = a * x + c * y;
            var y2 = b * x + d * y;
            x = +sx + px;
            y = +sy + py;
            var x3 = a * x + c * y;
            var y3 = b * x + d * y;
            var xmin = Math.min(x0, x1, x2, x3);
            var ymin = Math.min(y0, y1, y2, y3);
            var xmax = Math.max(x0, x1, x2, x3);
            var ymax = Math.max(y0, y1, y2, y3);
            result.x = xmin + transform.tx;
            result.y = ymin + transform.ty;
            result.width = xmax - xmin;
            result.height = ymax - ymin;
            return result;
        };
        //
        EShapeBase.prototype.destroy = function () {
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
        };
        //
        EShapeBase.prototype.onStateChange = function (newState, oldState) {
            var runtime = this.runtime;
            if (runtime != null) {
                runtime.onStateChange(this, newState, oldState);
            }
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof EShapeBase) {
                    child.state.onParentChange(newState, oldState);
                }
            }
        };
        Object.defineProperty(EShapeBase.prototype, "state", {
            get: function () {
                var _this = this;
                var result = this._state;
                if (result == null) {
                    result = new EShapeStateSetImplObservable(function (newState, oldState) {
                        _this.onStateChange(newState, oldState);
                    });
                    this._state = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeBase.prototype, "capability", {
            get: function () {
                var result = this._capability;
                if (result == null) {
                    result = new EShapeCapabilityContainerImpl();
                    this._capability = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBase.prototype.getCapability = function () {
            return this._capability;
        };
        EShapeBase.prototype.focus = function () {
            this.setFocused(true);
            return this;
        };
        EShapeBase.prototype.blur = function () {
            this.setFocused(false);
            return this;
        };
        EShapeBase.prototype.setFocused = function (isFocused) {
            if (this.state.isFocused !== isFocused) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().set(this, isFocused);
                }
            }
        };
        EShapeBase.prototype.onKeyDown = function (e) {
            var runtime = this.runtime;
            if (runtime) {
                return runtime.onKeyDown(this, e);
            }
            return false;
        };
        EShapeBase.prototype.onKeyUp = function (e) {
            var runtime = this.runtime;
            if (runtime) {
                return runtime.onKeyUp(this, e);
            }
            return false;
        };
        //
        EShapeBase.prototype.update = function (time) {
            var runtime = this.runtime;
            if (runtime) {
                runtime.update(this, time);
            }
        };
        EShapeBase.prototype.onRender = function (time, renderer) {
            var runtime = this.runtime;
            if (runtime) {
                runtime.onRender(this, time, renderer);
            }
        };
        EShapeBase.prototype.updateRecursively = function (time) {
            this.update(time);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].update(time);
            }
        };
        EShapeBase.prototype.copy = function (source, part) {
            if (part === void 0) { part = EShapeCopyPart.ALL; }
            this.id = source.id;
            this.uuid = source.uuid;
            if (part & EShapeCopyPart.TRANSFORM) {
                var transform = this.transform;
                var sourceTransform = source.transform;
                transform.position.copyFrom(sourceTransform.position);
                transform.rotation = sourceTransform.rotation;
                transform.skew.copyFrom(sourceTransform.skew);
                transform.pivot.copyFrom(sourceTransform.pivot);
                transform.scale.copyFrom(sourceTransform.scale);
            }
            if (part & EShapeCopyPart.SIZE) {
                this.size.copyFrom(source.size);
            }
            if (part & EShapeCopyPart.STYLE) {
                this.fill.copy(source.fill);
                this.stroke.copy(source.stroke);
                this.text.copy(source.text);
                this.radius = source.radius;
                this.corner = source.corner;
            }
            if (part & EShapeCopyPart.DATA) {
                this.data.copy(source.data);
            }
            if (part & EShapeCopyPart.IMAGE) {
                this.image = source.image;
            }
            if (part & EShapeCopyPart.ACTION) {
                this.action.clearAndAddAll(source.action.values);
                this.interactive = source.interactive;
                this.cursor = source.cursor;
                this.shortcut = source.shortcut;
            }
            if (part & EShapeCopyPart.POINTS) {
                var sourcePoints = source.points;
                if (sourcePoints != null) {
                    var points = this.points;
                    if (points != null) {
                        points.copy(sourcePoints);
                    }
                }
            }
            if (part & EShapeCopyPart.STATE) {
                this.state.lock(false).copy(source.state).unlock();
            }
            if (part & EShapeCopyPart.CONNECTOR) {
                if (source instanceof EShapeBase) {
                    var sourceConnector = source._connector;
                    if (sourceConnector) {
                        this.connector.copy(sourceConnector);
                    }
                    else {
                        var connector = this._connector;
                        if (connector) {
                            connector.clear();
                        }
                    }
                }
                else {
                    var connector = this._connector;
                    if (connector) {
                        connector.clear();
                    }
                }
            }
            if (part & EShapeCopyPart.CAPABILITY) {
                var sourceCapability = source.getCapability();
                if (sourceCapability != null) {
                    this.capability.copy(sourceCapability);
                }
                else {
                    var capability = this._capability;
                    if (capability != null) {
                        capability.clear();
                    }
                }
            }
            return this;
        };
        return EShapeBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeStrokeImpl = /** @class */ (function () {
        function EShapeStrokeImpl(parent, enable, color, alpha, width, align, side, style) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
            this._align = align;
            this._side = side;
            this._style = style;
        }
        Object.defineProperty(EShapeStrokeImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "side", {
            get: function () {
                return this._side;
            },
            set: function (side) {
                if (this._side !== side) {
                    this._side = side;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeStrokeImpl.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                if (this._style !== style) {
                    this._style = style;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeStrokeImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width, target.align, target.side, target.style);
            }
        };
        EShapeStrokeImpl.prototype.set = function (enable, color, alpha, width, align, side, style) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (align !== undefined && this._align !== align) {
                this._align = align;
                isChanged = true;
            }
            if (side !== undefined && this._side !== side) {
                this._side = side;
                isChanged = true;
            }
            if (style !== undefined && this._style !== style) {
                this._style = style;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeStrokeImpl.prototype.clone = function () {
            return new EShapeStrokeImpl(this._parent, this._enable, this._color, this._alpha, this._width, this._align, this._side, this._style);
        };
        EShapeStrokeImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width,
                align: this._align,
                side: this._side,
                style: this._style
            };
        };
        EShapeStrokeImpl.prototype.serialize = function (manager) {
            var enable = this._enable ? 1 : 0;
            var serialized = "[".concat(enable, ",").concat(this._color, ",").concat(this._alpha, ",").concat(this._width, ",").concat(this._align, ",").concat(this._side, ",").concat(this._style, "]");
            return manager.addResource(serialized);
        };
        EShapeStrokeImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getStroke(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2], parsed[3], parsed[4], parsed[5], parsed[6]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setStroke(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2], deserialized[3], deserialized[4], deserialized[5], deserialized[6]);
                }
            }
        };
        return EShapeStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FROM = 1;
    var TO = 2;
    var EShapeDataValueRangeType = {
        NONE: 0,
        FROM: FROM,
        TO: TO,
        FROM_TO: FROM | TO
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueRangeImpl = /** @class */ (function () {
        function EShapeDataValueRangeImpl() {
            this._type = EShapeDataValueRangeType.NONE;
            this._from = 0;
            this._to = 1;
        }
        Object.defineProperty(EShapeDataValueRangeImpl.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (type) {
                if (this._type !== type) {
                    this._type = type;
                    var parent_1 = this.parent;
                    if (parent_1 != null) {
                        parent_1.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueRangeImpl.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                if (this._from !== from) {
                    this._from = from;
                    var parent_2 = this.parent;
                    if (parent_2 != null) {
                        parent_2.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueRangeImpl.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                if (this._to !== to) {
                    this._to = to;
                    var parent_3 = this.parent;
                    if (parent_3 != null) {
                        parent_3.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataValueRangeImpl.prototype.set = function (from, to) {
            var result = false;
            if (from !== undefined && to !== undefined) {
                if (from !== null && to !== null) {
                    var type = this._type | EShapeDataValueRangeType.FROM | EShapeDataValueRangeType.TO;
                    if (this._type !== type || this._from !== from || this._to !== to) {
                        this._type = type;
                        this._from = from;
                        this._to = to;
                        result = true;
                    }
                }
                else if (from !== null) {
                    var type = (this._type | EShapeDataValueRangeType.FROM) & ~EShapeDataValueRangeType.TO;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else if (to !== null) {
                    var type = (this._type | EShapeDataValueRangeType.TO) & ~EShapeDataValueRangeType.FROM;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    var type = this._type & ~(EShapeDataValueRangeType.TO | EShapeDataValueRangeType.FROM);
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (from !== undefined) {
                if (from !== null) {
                    var type = this._type | EShapeDataValueRangeType.FROM;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else {
                    var type = this._type & ~EShapeDataValueRangeType.FROM;
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (to !== undefined) {
                if (to !== null) {
                    var type = this._type | EShapeDataValueRangeType.TO;
                    if (this._type !== type || this._to !== to) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    var type = this._type & ~EShapeDataValueRangeType.TO;
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            if (result) {
                var parent_4 = this.parent;
                if (parent_4 != null) {
                    parent_4.isChanged = true;
                }
            }
            return result;
        };
        EShapeDataValueRangeImpl.prototype.normalize = function (value) {
            var type = this._type;
            var from = this._from;
            var to = this._to;
            switch (type) {
                case EShapeDataValueRangeType.FROM_TO:
                    return (value - from) / (to - from);
                case EShapeDataValueRangeType.FROM:
                    return value - from;
                case EShapeDataValueRangeType.TO:
                    return to - value;
                case EShapeDataValueRangeType.NONE:
                default:
                    return value;
            }
        };
        EShapeDataValueRangeImpl.prototype.isEquals = function (target) {
            return this._type === target.type && this._from === target.from && this._to === target.to;
        };
        EShapeDataValueRangeImpl.prototype.copy = function (target) {
            return this.copy_(target.type, target.from, target.to);
        };
        EShapeDataValueRangeImpl.prototype.copy_ = function (type, from, to) {
            var isChanged = false;
            if (this._type !== type) {
                this._type = type;
                isChanged = true;
            }
            if (this._from !== from) {
                this._from = from;
                isChanged = true;
            }
            if (this._to !== to) {
                this._to = to;
                isChanged = true;
            }
            if (isChanged) {
                var parent_5 = this.parent;
                if (parent_5 != null) {
                    parent_5.isChanged = true;
                }
            }
            return this;
        };
        EShapeDataValueRangeImpl.prototype.toObject = function () {
            return {
                type: this.type,
                from: this.from,
                to: this.to
            };
        };
        EShapeDataValueRangeImpl.prototype.serialize = function (manager) {
            var serialized = "[".concat(this._type, ",").concat(this._from, ",").concat(this._to, "]");
            return manager.addResource(serialized);
        };
        EShapeDataValueRangeImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getRange(target);
                if (parsed != null) {
                    this.copy_(parsed[0], parsed[1], parsed[2]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setRange(target, deserialized);
                    this.copy_(deserialized[0], deserialized[1], deserialized[2]);
                }
            }
        };
        return EShapeDataValueRangeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueOrder = {
        ASCENDING: 0,
        DESCENDING: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueType = {
        BOOLEAN: 7,
        BOOLEAN_ARRAY: 8,
        NUMBER: 0,
        NUMBER_ARRAY: 1,
        STRING: 2,
        STRING_ARRAY: 3,
        OBJECT: 4,
        OBJECT_ARRAY: 5,
        TICKER: 6,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueScope = {
        /**
         * A private data is accessible only from inside the graphic that this data belongs to.
         * The data is not accessible from anywhere outside the graphic.
         */
        PRIVATE: 0,
        /**
         * A public data is accessible from anywhere outside graphics.
         */
        PUBLIC: 1,
        /**
         * A protected data is accessible only from inside graphics.
         * Unlike the private data, the protected data is also accessible from parent graphics
         * containing the graphic that this data belongs to.
         */
        PROTECTED: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueState = {
        /**
         * The data status is not known.
         * This is the default state.
         */
        UNKNOWN: -1,
        /**
         * The request succeeded.
         */
        FOUND: 0,
        /**
         * The server can not find the requested data.
         */
        NOT_FOUND: 1,
        /**
         * The settings or something provided by clients are considered incorrect.
         */
        BAD_REQUEST: 2,
        /**
         * The server has encountered unknown errors.
         */
        SERVER_ERROR: 3,
        /**
         * The server is not ready to handle the request.
         */
        SERVICE_UNAVAILABLE: 4,
        /**
         * A client is not allowed to access this data.
         */
        FORBIDDEN: 5,
        /**
         * The server can not find the definition of the requested data.
         */
        NOT_DEFINED: 6
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var INDEX_COMPARATOR = function (a, b) {
        return a - b;
    };
    var EShapeDataValueImpl = /** @class */ (function () {
        function EShapeDataValueImpl() {
            this.id = "";
            this.as = "";
            this.type = EShapeDataValueType.NUMBER;
            this.scope = EShapeDataValueScope.PUBLIC;
            this.initial = "";
            this.format = "";
            this.range = new EShapeDataValueRangeImpl();
            this._value = 0;
            this._time = 0;
            this._state = EShapeDataValueState.UNKNOWN;
            this._capacity = 0;
            this._order = EShapeDataValueOrder.ASCENDING;
        }
        Object.defineProperty(EShapeDataValueImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            set: function (parent) {
                if (this._parent !== parent) {
                    this._parent = parent;
                    this.range.parent = parent;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (newValue) {
                var formatter = this.formatter;
                if (formatter != null) {
                    newValue = formatter(newValue);
                }
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._value !== newValue) {
                        this._value = newValue;
                        var parent_1 = this.parent;
                        if (parent_1 != null) {
                            parent_1.isChanged = true;
                        }
                    }
                }
                else {
                    var values = this._values;
                    if (values == null) {
                        values = [];
                        this._values = values;
                    }
                    // Update the value
                    this._value = newValue;
                    // Update the values
                    var order = this._order;
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        values.push(newValue);
                    }
                    else {
                        values.unshift(newValue);
                    }
                    // Remove the unnecessary values
                    var count = values.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                values.shift();
                            }
                        }
                        else {
                            values.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_2 = this.parent;
                    if (parent_2 != null) {
                        parent_2.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "nvalue", {
            get: function () {
                return this.range.normalize(this._value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "values", {
            get: function () {
                var result = this._values;
                if (result == null) {
                    result = [];
                    this._values = result;
                }
                return result;
            },
            set: function (newValues) {
                var newValuesLength = newValues.length;
                if (0 < newValuesLength) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newValue = newValues[newValuesLength - 1];
                        var formatter = this.formatter;
                        if (formatter != null) {
                            newValue = formatter(newValue);
                        }
                        if (this._value !== newValue) {
                            this._value = newValue;
                            var parent_3 = this.parent;
                            if (parent_3 != null) {
                                parent_3.isChanged = true;
                            }
                        }
                    }
                    else {
                        var values = this._values;
                        if (values == null) {
                            values = [];
                            this._values = values;
                        }
                        var order = this._order;
                        var formatter = this.formatter;
                        if (formatter != null) {
                            // Update the value
                            this._value = formatter(newValues[newValuesLength - 1]);
                            // Update the values
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < newValuesLength; ++i) {
                                    values.push(formatter(newValues[i]));
                                }
                            }
                            else {
                                for (var i = 0; i < newValuesLength; ++i) {
                                    values.unshift(formatter(newValues[i]));
                                }
                            }
                        }
                        else {
                            // Update the value
                            this._value = newValues[newValuesLength - 1];
                            // Update the values
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < newValuesLength; ++i) {
                                    values.push(newValues[i]);
                                }
                            }
                            else {
                                for (var i = 0; i < newValuesLength; ++i) {
                                    values.unshift(newValues[i]);
                                }
                            }
                        }
                        // Remove the unnecessary values
                        var count = values.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    values.shift();
                                }
                            }
                            else {
                                values.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_4 = this.parent;
                        if (parent_4 != null) {
                            parent_4.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "time", {
            get: function () {
                return this._time;
            },
            set: function (newTime) {
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._time !== newTime) {
                        this._time = newTime;
                        var parent_5 = this.parent;
                        if (parent_5 != null) {
                            parent_5.isChanged = true;
                        }
                    }
                }
                else {
                    // Update the times
                    var times = this._times;
                    if (times == null) {
                        times = [];
                        this._times = times;
                    }
                    // Update the time
                    this._time = newTime;
                    // Update the times
                    var order = this._order;
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        times.push(newTime);
                    }
                    else {
                        times.unshift(newTime);
                    }
                    // Remove the unnecessary times
                    var count = times.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                times.shift();
                            }
                        }
                        else {
                            times.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_6 = this.parent;
                    if (parent_6 != null) {
                        parent_6.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "times", {
            get: function () {
                var result = this._times;
                if (result == null) {
                    result = [];
                    this._times = result;
                }
                return result;
            },
            set: function (newTimes) {
                var newTimesLength = newTimes.length;
                if (0 < newTimesLength) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newTime = newTimes[newTimesLength - 1];
                        if (this._time !== newTime) {
                            this._time = newTime;
                            var parent_7 = this.parent;
                            if (parent_7 != null) {
                                parent_7.isChanged = true;
                            }
                        }
                    }
                    else {
                        // Update the times
                        var times = this._times;
                        if (times == null) {
                            times = [];
                            this._times = times;
                        }
                        // Update the value
                        this._time = newTimes[newTimesLength - 1];
                        //
                        var order = this._order;
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < newTimesLength; ++i) {
                                times.push(newTimes[i]);
                            }
                        }
                        else {
                            for (var i = 0; i < newTimesLength; ++i) {
                                times.unshift(newTimes[i]);
                            }
                        }
                        //
                        var count = times.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    times.shift();
                                }
                            }
                            else {
                                times.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_8 = this.parent;
                        if (parent_8 != null) {
                            parent_8.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "state", {
            get: function () {
                return this._state;
            },
            set: function (newState) {
                var capacity = this._capacity;
                if (capacity <= 0) {
                    if (this._state !== newState) {
                        this._state = newState;
                        var parent_9 = this.parent;
                        if (parent_9 != null) {
                            parent_9.isChanged = true;
                        }
                    }
                }
                else {
                    // Update the states
                    var states = this._states;
                    if (states == null) {
                        states = [];
                        this._states = states;
                    }
                    // Update the state
                    this._state = newState;
                    // Update the states
                    var order = this._order;
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        states.push(newState);
                    }
                    else {
                        states.unshift(newState);
                    }
                    // Remove the unnecessary states
                    var count = states.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < count; ++i) {
                                states.shift();
                            }
                        }
                        else {
                            states.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    var parent_10 = this.parent;
                    if (parent_10 != null) {
                        parent_10.isChanged = true;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "states", {
            get: function () {
                var result = this._states;
                if (result == null) {
                    result = [];
                    this._states = result;
                }
                return result;
            },
            set: function (newStates) {
                var newStatesLength = newStates.length;
                if (0 < newStatesLength) {
                    var capacity = this._capacity;
                    if (capacity <= 0) {
                        var newState = newStates[newStatesLength - 1];
                        if (this._state !== newState) {
                            this._state = newState;
                            var parent_11 = this.parent;
                            if (parent_11 != null) {
                                parent_11.isChanged = true;
                            }
                        }
                    }
                    else {
                        // Update the states
                        var states = this._states;
                        if (states == null) {
                            states = [];
                            this._states = states;
                        }
                        // Update the value
                        this._state = newStates[newStatesLength - 1];
                        //
                        var order = this._order;
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (var i = 0; i < newStatesLength; ++i) {
                                states.push(newStates[i]);
                            }
                        }
                        else {
                            for (var i = 0; i < newStatesLength; ++i) {
                                states.unshift(newStates[i]);
                            }
                        }
                        //
                        var count = states.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    states.shift();
                                }
                            }
                            else {
                                states.length = capacity;
                            }
                        }
                        // Tell the parent it's changed
                        var parent_12 = this.parent;
                        if (parent_12 != null) {
                            parent_12.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "capacity", {
            get: function () {
                return this._capacity;
            },
            set: function (capacity) {
                if (this._capacity < capacity) {
                    this._capacity = capacity;
                }
                else if (capacity < this._capacity) {
                    this._capacity = capacity;
                    var isChanged = false;
                    // Values
                    var order = this._order;
                    var values = this._values;
                    if (values != null) {
                        var count = values.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    values.shift();
                                }
                            }
                            else {
                                values.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    // Times
                    var times = this._times;
                    if (times != null) {
                        var count = times.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    times.shift();
                                }
                            }
                            else {
                                times.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    // States
                    var states = this._states;
                    if (states != null) {
                        var count = states.length - capacity;
                        if (0 < count) {
                            if (order === EShapeDataValueOrder.ASCENDING) {
                                for (var i = 0; i < count; ++i) {
                                    states.shift();
                                }
                            }
                            else {
                                states.length = capacity;
                            }
                            isChanged = true;
                        }
                    }
                    if (isChanged) {
                        var parent_13 = this.parent;
                        if (parent_13 != null) {
                            parent_13.isChanged = true;
                        }
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataValueImpl.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (order) {
                this._order = order;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataValueImpl.prototype.remove = function (index) {
            var isChanged = false;
            // Values
            var values = this._values;
            if (values != null) {
                if (0 <= index && index < values.length) {
                    values.splice(index, 1);
                    isChanged = true;
                }
            }
            // Times
            var times = this._times;
            if (times != null) {
                if (0 <= index && index < times.length) {
                    times.splice(index, 1);
                    isChanged = true;
                }
            }
            // States
            var states = this._states;
            if (states != null) {
                if (0 <= index && index < states.length) {
                    states.splice(index, 1);
                    isChanged = true;
                }
            }
            if (isChanged) {
                var parent_14 = this.parent;
                if (parent_14 != null) {
                    parent_14.isChanged = true;
                }
            }
        };
        EShapeDataValueImpl.prototype.removeAll = function (indices) {
            var isChanged = false;
            var sorted = indices.slice(0).sort(INDEX_COMPARATOR);
            var sortedLength = sorted.length;
            // Values
            var values = this._values;
            if (values != null) {
                for (var i = sortedLength - 1; 0 <= i; --i) {
                    var index = sorted[i];
                    if (0 <= index && index < values.length) {
                        values.splice(index, 1);
                        isChanged = true;
                    }
                }
            }
            // Times
            var times = this._times;
            if (times != null) {
                for (var i = sortedLength - 1; 0 <= i; --i) {
                    var index = sorted[i];
                    if (0 <= index && index < times.length) {
                        times.splice(index, 1);
                        isChanged = true;
                    }
                }
            }
            // States
            var states = this._states;
            if (states != null) {
                for (var i = sortedLength - 1; 0 <= i; --i) {
                    var index = sorted[i];
                    if (0 <= index && index < states.length) {
                        states.splice(index, 1);
                        isChanged = true;
                    }
                }
            }
            if (isChanged) {
                var parent_15 = this.parent;
                if (parent_15 != null) {
                    parent_15.isChanged = true;
                }
            }
        };
        EShapeDataValueImpl.prototype.clear = function () {
            var isChanged = false;
            // Values
            var values = this._values;
            if (values != null) {
                values.length = 0;
                isChanged = true;
            }
            // Times
            var times = this._times;
            if (times != null) {
                times.length = 0;
                isChanged = true;
            }
            // States
            var states = this._states;
            if (states != null) {
                states.length = 0;
                isChanged = true;
            }
            // Change flag
            if (isChanged) {
                var parent_16 = this.parent;
                if (parent_16 != null) {
                    parent_16.isChanged = true;
                }
            }
        };
        EShapeDataValueImpl.prototype.toDirty = function () {
            var parent = this.parent;
            if (parent != null) {
                parent.isChanged = true;
            }
        };
        /**
         * This method does not copy the `#values` and `#times` for the performance.
         *
         * @param target a copy target
         */
        EShapeDataValueImpl.prototype.copy = function (target) {
            this.id = target.id;
            this.as = target.as;
            this.type = target.type;
            this.scope = target.scope;
            this.initial = target.initial;
            this.format = target.format;
            this.formatter = target.formatter;
            this.range.copy(target.range);
            this._value = target.value;
            this._time = target.time;
            this._state = target.state;
            this._capacity = target.capacity;
            return this;
        };
        EShapeDataValueImpl.prototype.isEquals = function (target) {
            return (this.id === target.id &&
                this.as === target.as &&
                this.type === target.type &&
                this.scope === target.scope &&
                this.initial === target.initial &&
                this.formatter === target.formatter &&
                this.range.isEquals(target.range));
        };
        EShapeDataValueImpl.prototype.serialize = function (manager) {
            var id = manager.addData(this.id);
            var as = manager.addResource(this.as);
            var initial = manager.addResource(this.initial);
            var format = manager.addResource(this.format.trim());
            var range = this.range.serialize(manager);
            return manager.addResource("[".concat(id, ",").concat(initial, ",").concat(format, ",").concat(range, ",").concat(this._capacity, ",").concat(this._order, ",").concat(this.type, ",").concat(this.scope, ",").concat(as, "]"));
        };
        EShapeDataValueImpl.prototype.deserialize = function (target, manager) {
            var _a, _b;
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getDataValue(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setDataValue(target, parsed);
                }
                this.id = manager.data[parsed[0]] || "";
                var as = parsed[8];
                this.as = as != null ? resources[as] || "" : "";
                this.type = (_a = parsed[6]) !== null && _a !== void 0 ? _a : EShapeDataValueType.NUMBER;
                this.scope = (_b = parsed[7]) !== null && _b !== void 0 ? _b : EShapeDataValueScope.PUBLIC;
                this.initial = resources[parsed[1]] || "";
                this.format = resources[parsed[2]] || "";
                this.range.deserialize(parsed[3], manager);
                this._capacity = parsed[4];
                this._order = parsed[5];
            }
            return this;
        };
        return EShapeDataValueImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataMappingImpl = /** @class */ (function () {
        function EShapeDataMappingImpl() {
            this.values = [];
        }
        EShapeDataMappingImpl.prototype.add = function (value, index) {
            var values = this.values;
            if (index != null) {
                values.splice(index, 0, value);
            }
            else {
                values.push(value);
            }
            return this;
        };
        EShapeDataMappingImpl.prototype.addAll = function (values) {
            var destination = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                destination.push(values[i]);
            }
            return this;
        };
        EShapeDataMappingImpl.prototype.clearAndAdd = function (value) {
            this.clear();
            this.add(value);
            return this;
        };
        EShapeDataMappingImpl.prototype.clearAndAddAll = function (values) {
            this.clear();
            this.addAll(values);
            return this;
        };
        EShapeDataMappingImpl.prototype.indexOf = function (target) {
            var values = this.values;
            // Instance-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                if (value[0] === target[0] && value[1] === target[1] && value[2] === target[2]) {
                    return i;
                }
            }
            return -1;
        };
        EShapeDataMappingImpl.prototype.get = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values[index];
            }
            return null;
        };
        EShapeDataMappingImpl.prototype.set = function (index, value) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                var result = values[index];
                values[index] = value;
                return result;
            }
            return null;
        };
        EShapeDataMappingImpl.prototype.remove = function (index) {
            var values = this.values;
            if (0 <= index || index < values.length) {
                return values.splice(index, 1)[0];
            }
            return null;
        };
        EShapeDataMappingImpl.prototype.clear = function () {
            this.values.length = 0;
            return this;
        };
        EShapeDataMappingImpl.prototype.size = function () {
            return this.values.length;
        };
        EShapeDataMappingImpl.prototype.swap = function (indexA, indexB) {
            var values = this.values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
            return this;
        };
        EShapeDataMappingImpl.prototype.copy = function (target) {
            this.clearAndAddAll(target.values);
        };
        EShapeDataMappingImpl.prototype.serialize = function (manager) {
            var values = this.values;
            var valuesLength = values.length;
            if (valuesLength <= 0) {
                return -1;
            }
            var result = "[";
            var delimiter = "";
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                var s = manager.addResource(value[0]);
                var d = manager.addResource(value[1]);
                var t = manager.addResource(value[2]);
                result += "".concat(delimiter).concat(s, ",").concat(d, ",").concat(t);
                delimiter = ",";
            }
            result += "]";
            return manager.addResource(result);
        };
        EShapeDataMappingImpl.prototype.deserialize = function (target, manager) {
            var values = this.values;
            values.length = 0;
            var resources = manager.resources;
            var resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                var parsed = manager.getDataMapping(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setDataMapping(target, parsed);
                }
                for (var i = 0, imax = parsed.length; i < imax; i += 3) {
                    var is = parsed[i];
                    var id = parsed[i + 1];
                    var it = parsed[i + 2];
                    values.push([
                        0 <= is && is < resourcesLength ? resources[is] : "",
                        0 <= id && id < resourcesLength ? resources[id] : "",
                        0 <= it && it < resourcesLength ? resources[it] : ""
                    ]);
                }
            }
        };
        return EShapeDataMappingImpl;
    }());

    var EShapeDataScopedImpl = /** @class */ (function () {
        function EShapeDataScopedImpl() {
        }
        Object.defineProperty(EShapeDataScopedImpl.prototype, "ids", {
            get: function () {
                var data = this._data;
                if (data == null) {
                    return [];
                }
                var result = [];
                data.forEach(function (value, id) {
                    result.push(id);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataScopedImpl.prototype.add = function (id, value) {
            var _a;
            var data = ((_a = this._data) !== null && _a !== void 0 ? _a : (this._data = new Map()));
            var list = data.get(id);
            if (list == null) {
                data.set(id, [value]);
            }
            else {
                list.push(value);
            }
        };
        EShapeDataScopedImpl.prototype.set = function (id, value, time, state, from, to) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                var datumValue = datum[i];
                var range = datumValue.range;
                // Range
                range.set(from, to);
                // Time
                if (time !== undefined) {
                    datumValue.time = time;
                }
                // State
                if (state !== undefined) {
                    datumValue.state = state;
                }
                // Value
                datumValue.value = value;
            }
            return true;
        };
        EShapeDataScopedImpl.prototype.toDirty = function (id) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].toDirty();
            }
            return true;
        };
        EShapeDataScopedImpl.prototype.each = function (iteratee) {
            var data = this._data;
            if (data == null) {
                return null;
            }
            var result = null;
            data.forEach(function (values, id) {
                if (result == null) {
                    if (iteratee(id) === false) {
                        result = id;
                    }
                }
            });
            return result;
        };
        return EShapeDataScopedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataSystemImpl = /** @class */ (function () {
        function EShapeDataSystemImpl() {
            this._data = new Map();
        }
        EShapeDataSystemImpl.prototype.set = function (key, value) {
            this._data.set(key, value);
            return this;
        };
        EShapeDataSystemImpl.prototype.get = function (key) {
            var _a;
            return (_a = this._data.get(key)) !== null && _a !== void 0 ? _a : null;
        };
        EShapeDataSystemImpl.prototype.contains = function (key) {
            return this._data.has(key);
        };
        EShapeDataSystemImpl.prototype.remove = function (key) {
            var data = this._data;
            var result = data.get(key);
            data.delete(key);
            return result !== null && result !== void 0 ? result : null;
        };
        EShapeDataSystemImpl.prototype.clear = function () {
            this._data.clear();
            return this;
        };
        EShapeDataSystemImpl.prototype.size = function () {
            return this._data.size;
        };
        EShapeDataSystemImpl.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._data.forEach(function (value, key) {
                if (!isCanceled) {
                    if (iteratee(value, key) === false) {
                        isCanceled = true;
                    }
                }
            });
            return this;
        };
        EShapeDataSystemImpl.prototype.copy = function (target) {
            var data = this._data;
            data.clear();
            target.each(function (value, key) {
                data.set(key, value);
            });
            return this;
        };
        EShapeDataSystemImpl.prototype.serialize = function (manager) {
            var data = this._data;
            if (data.size <= 0) {
                return -1;
            }
            var result = [];
            data.forEach(function (value, key) {
                var valueId = manager.addResource(value);
                var keyId = manager.addResource(key);
                result.push(keyId, valueId);
            });
            return manager.addResource(JSON.stringify(result));
        };
        EShapeDataSystemImpl.prototype.deserialize = function (target, manager) {
            var data = this._data;
            data.clear();
            var resources = manager.resources;
            var resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                var parsed = manager.getDataSystem(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setDataSystem(target, parsed);
                }
                for (var i = 0, imax = parsed.length; i < imax; i += 2) {
                    var keyId = parsed[i];
                    if (0 <= keyId && keyId < resourcesLength) {
                        var key = resources[keyId];
                        var valueId = parsed[i + 1];
                        if (0 <= valueId && valueId < resourcesLength) {
                            data.set(key, resources[valueId]);
                        }
                    }
                }
            }
        };
        return EShapeDataSystemImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var RANGE_DUMMY;
    var ALIAS_DUMMY;
    var EShapeDataImpl = /** @class */ (function () {
        function EShapeDataImpl() {
            this._values = [];
            this._isChanged = true;
        }
        Object.defineProperty(EShapeDataImpl.prototype, "values", {
            get: function () {
                return this._values;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "isChanged", {
            get: function () {
                return this._isChanged;
            },
            set: function (isChanged) {
                this._isChanged = isChanged;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "id", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].id;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "as", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].as;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "type", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].type;
                }
                return EShapeDataValueType.NUMBER;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "scope", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].scope;
                }
                return EShapeDataValueScope.PRIVATE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "initial", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].initial;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "format", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].format;
                }
                return "";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "range", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].range;
                }
                return (RANGE_DUMMY !== null && RANGE_DUMMY !== void 0 ? RANGE_DUMMY : (RANGE_DUMMY = new EShapeDataValueRangeImpl()));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "value", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].value;
                }
                return 0;
            },
            set: function (value) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].value = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "nvalue", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].nvalue;
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "time", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].time;
                }
                return 0;
            },
            set: function (time) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].time = time;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "state", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].state;
                }
                return EShapeDataValueState.UNKNOWN;
            },
            set: function (state) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].state = state;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "capacity", {
            get: function () {
                var values = this._values;
                if (0 < values.length) {
                    return values[0].capacity;
                }
                return 0;
            },
            set: function (capacity) {
                var values = this._values;
                if (0 < values.length) {
                    values[0].capacity = capacity;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeDataImpl.prototype, "alias", {
            get: function () {
                var result = this._alias;
                if (result == null) {
                    result = this.newAlias();
                    this._alias = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataImpl.prototype.newAlias = function () {
            var values = this._values;
            var valuesLength = values.length;
            if (0 < valuesLength) {
                var result = {};
                for (var i = 0; i < valuesLength; ++i) {
                    var value = values[i];
                    result[value.as || value.id] = value;
                }
                return result;
            }
            else {
                return (ALIAS_DUMMY !== null && ALIAS_DUMMY !== void 0 ? ALIAS_DUMMY : (ALIAS_DUMMY = {}));
            }
        };
        Object.defineProperty(EShapeDataImpl.prototype, "mapping", {
            get: function () {
                var result = this._mapping;
                if (result == null) {
                    result = this.newMapping();
                    this._mapping = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataImpl.prototype.newMapping = function () {
            return new EShapeDataMappingImpl();
        };
        EShapeDataImpl.prototype.getMapping = function () {
            return this._mapping;
        };
        Object.defineProperty(EShapeDataImpl.prototype, "private", {
            get: function () {
                var result = this._private;
                if (result == null) {
                    result = this.newPrivate();
                    this._private = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataImpl.prototype.newPrivate = function () {
            return new EShapeDataScopedImpl();
        };
        EShapeDataImpl.prototype.getPrivate = function () {
            return this._private;
        };
        Object.defineProperty(EShapeDataImpl.prototype, "system", {
            get: function () {
                var result = this._system;
                if (result == null) {
                    result = this.newSystem();
                    this._system = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeDataImpl.prototype.newSystem = function () {
            return new EShapeDataSystemImpl();
        };
        EShapeDataImpl.prototype.getSystem = function () {
            return this._system;
        };
        EShapeDataImpl.prototype.add = function (value, index) {
            var values = this._values;
            value.parent = this;
            if (index === undefined) {
                values.push(value);
            }
            else {
                values.splice(index, 0, value);
            }
        };
        EShapeDataImpl.prototype.set = function (index, value) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                var result = values[index];
                value.parent = this;
                values[index] = value;
                result.parent = undefined;
                return result;
            }
            return null;
        };
        EShapeDataImpl.prototype.remove = function (index) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1)[0].parent = undefined;
            }
        };
        EShapeDataImpl.prototype.indexOf = function (target) {
            var values = this._values;
            var valuesLength = values.length;
            // Instance-based matching
            for (var i = 0; i < valuesLength; ++i) {
                if (values[i] === target) {
                    return i;
                }
            }
            // Data-based matching
            for (var i = 0; i < valuesLength; ++i) {
                if (values[i].isEquals(target)) {
                    return i;
                }
            }
            // ID-based matching
            for (var i = 0; i < valuesLength; ++i) {
                if (values[i].id === target.id) {
                    return i;
                }
            }
            return -1;
        };
        EShapeDataImpl.prototype.get = function (index) {
            var values = this._values;
            if (0 <= index && index < values.length) {
                return values[index];
            }
            return null;
        };
        EShapeDataImpl.prototype.size = function () {
            return this._values.length;
        };
        EShapeDataImpl.prototype.swap = function (indexA, indexB) {
            var values = this._values;
            var tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
        };
        EShapeDataImpl.prototype.copy = function (target) {
            var values = this._values;
            values.length = 0;
            for (var i = 0, imax = target.size(); i < imax; ++i) {
                var value = target.get(i);
                if (value != null) {
                    var newValue = new EShapeDataValueImpl().copy(value);
                    newValue.parent = this;
                    values.push(newValue);
                }
            }
            var targetMapping = target.getMapping();
            if (targetMapping) {
                this.mapping.copy(targetMapping);
            }
            var targetSystem = target.getSystem();
            if (targetSystem) {
                this.system.copy(targetSystem);
            }
            return this;
        };
        EShapeDataImpl.prototype.serialize = function (manager) {
            var values = this._values;
            var result = [];
            for (var i = 0, imax = values.length; i < imax; ++i) {
                result.push(values[i].serialize(manager));
            }
            var mapping = this._mapping;
            if (mapping != null) {
                result.push(mapping.serialize(manager));
                var system = this._system;
                if (system != null) {
                    return manager.addResource("[".concat(JSON.stringify(result), ",").concat(system.serialize(manager), "]"));
                }
                else {
                    return manager.addResource("[".concat(JSON.stringify(result), "]"));
                }
            }
            else {
                var system = this._system;
                if (system != null) {
                    result.push(-1);
                    return manager.addResource("[".concat(JSON.stringify(result), ",").concat(system.serialize(manager), "]"));
                }
                else {
                    return manager.addResource(JSON.stringify(result));
                }
            }
        };
        EShapeDataImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getData(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setData(target, parsed);
                }
                var values = this._values;
                values.length = 0;
                if (this.isMapped(parsed)) {
                    var first = parsed[0];
                    var firstLength = first.length;
                    for (var i = 0, imax = firstLength - 1; i < imax; ++i) {
                        var index = first[i];
                        var value = new EShapeDataValueImpl();
                        value.parent = this;
                        value.deserialize(index, manager);
                        values.push(value);
                    }
                    var mappingId = first[firstLength - 1];
                    if (0 <= mappingId) {
                        this.mapping.deserialize(mappingId, manager);
                    }
                    var systemId = parsed[1];
                    if (systemId != null && 0 <= systemId) {
                        this.system.deserialize(systemId, manager);
                    }
                }
                else {
                    for (var i = 0, imax = parsed.length; i < imax; ++i) {
                        var index = parsed[i];
                        var value = new EShapeDataValueImpl();
                        value.parent = this;
                        value.deserialize(index, manager);
                        values.push(value);
                    }
                }
            }
        };
        EShapeDataImpl.prototype.isMapped = function (target) {
            return 0 < target.length && isArray(target[0]);
        };
        return EShapeDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextAlignImpl = /** @class */ (function () {
        function EShapeTextAlignImpl(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        Object.defineProperty(EShapeTextAlignImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextAlignImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextAlignImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        };
        EShapeTextAlignImpl.prototype.set = function (horizontal, vertical) {
            var isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextAlignImpl.prototype.toObject = function () {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        };
        EShapeTextAlignImpl.prototype.serialize = function (manager) {
            return manager.addResource("[".concat(this._horizontal, ",").concat(this._vertical, "]"));
        };
        EShapeTextAlignImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getAlign(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setAlign(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        };
        return EShapeTextAlignImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextOffsetImpl = /** @class */ (function () {
        function EShapeTextOffsetImpl(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        Object.defineProperty(EShapeTextOffsetImpl.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (horizontal) {
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOffsetImpl.prototype, "vertical", {
            get: function () {
                return this._vertical;
            },
            set: function (vertical) {
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextOffsetImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        };
        EShapeTextOffsetImpl.prototype.set = function (horizontal, vertical) {
            var isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextOffsetImpl.prototype.toObject = function () {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        };
        EShapeTextOffsetImpl.prototype.serialize = function (manager) {
            return manager.addResource("[".concat(this._horizontal, ",").concat(this._vertical, "]"));
        };
        EShapeTextOffsetImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getMargin(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setMargin(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        };
        return EShapeTextOffsetImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextOutlineImpl = /** @class */ (function () {
        function EShapeTextOutlineImpl(parent, enable, color, alpha, width) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
        }
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextOutlineImpl.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextOutlineImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width);
            }
        };
        EShapeTextOutlineImpl.prototype.set = function (enable, color, alpha, width) {
            var isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        };
        EShapeTextOutlineImpl.prototype.clone = function () {
            return new EShapeTextOutlineImpl(this._parent, this._enable, this._color, this._alpha, this._width);
        };
        EShapeTextOutlineImpl.prototype.toObject = function () {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width
            };
        };
        EShapeTextOutlineImpl.prototype.serialize = function (manager) {
            var serialized = "[".concat(this._enable ? 1 : 0, ",").concat(this._color, ",").concat(this._alpha, ",").concat(this._width, "]");
            return manager.addResource(serialized);
        };
        EShapeTextOutlineImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getTextOutline(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2], parsed[3]);
                }
                else {
                    var deserialized = JSON.parse(resources[target]);
                    manager.setTextOutline(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2], deserialized[3]);
                }
            }
        };
        return EShapeTextOutlineImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTextImpl = /** @class */ (function () {
        function EShapeTextImpl(parent, value, color, alpha, family, size) {
            this._parent = parent;
            this._enable = true;
            this._value = value;
            this._color = color;
            this._alpha = alpha;
            this._family = family;
            this._size = size;
            this._weight = EShapeTextWeight.NORMAL;
            this.align = new EShapeTextAlignImpl(parent, EShapeTextAlignHorizontal.CENTER, EShapeTextAlignVertical.MIDDLE);
            this.offset = new EShapeTextOffsetImpl(parent, 0, 0);
            this._style = EShapeTextStyle.NORMAL;
            this.spacing = new EShapeTextOffsetImpl(parent, 0, 0);
            this.outline = new EShapeTextOutlineImpl(parent, false, 0xffffff, 1.0, 0.5);
            this._direction = EShapeTextDirection.LEFT_TO_RIGHT;
            this.padding = new EShapeTextOffsetImpl(parent, 10, 10);
            this._clipping = false;
            this._fitting = false;
        }
        Object.defineProperty(EShapeTextImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                if (this._value !== value) {
                    this._value = value;
                    // Compatibility check
                    var parent_1 = this._parent;
                    var uploaded = parent_1.uploaded;
                    if (uploaded == null || !uploaded.isCompatible(parent_1)) {
                        this.atlas = undefined;
                        parent_1.toDirty();
                        return;
                    }
                    // Character code check
                    var atlas = this.atlas;
                    var characters = atlas && atlas.characters;
                    if (characters != null) {
                        for (var i = 0, imax = value.length; i < imax; ++i) {
                            var char = value[i];
                            if (!(char in characters)) {
                                this.atlas = undefined;
                                parent_1.toDirty();
                                return;
                            }
                        }
                    }
                    else {
                        this.atlas = undefined;
                        parent_1.toDirty();
                        return;
                    }
                    // Update uploaded
                    parent_1.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "family", {
            get: function () {
                return this._family;
            },
            set: function (family) {
                if (this._family !== family) {
                    this._family = family;
                    this._parent.toDirty();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                if (this._size !== size) {
                    this._size = size;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            set: function (weight) {
                if (this._weight !== weight) {
                    this._weight = weight;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                if (this._style !== style) {
                    this._style = style;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "direction", {
            get: function () {
                return this._direction;
            },
            set: function (direction) {
                if (this._direction !== direction) {
                    this._direction = direction;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "clipping", {
            get: function () {
                return this._clipping;
            },
            set: function (clipping) {
                if (this._clipping !== clipping) {
                    this._clipping = clipping;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeTextImpl.prototype, "fitting", {
            get: function () {
                return this._fitting;
            },
            set: function (fitting) {
                if (this._fitting !== fitting) {
                    this._fitting = fitting;
                    this._parent.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeTextImpl.prototype.copy = function (target) {
            if (target) {
                this.set(target.value, target.color, target.alpha, target.family, target.size, target.weight, target.style, target.direction, target.clipping, target.fitting);
                this.align.copy(target.align);
                this.offset.copy(target.offset);
                this.outline.copy(target.outline);
                this.spacing.copy(target.spacing);
                this.padding.copy(target.padding);
            }
            return this;
        };
        EShapeTextImpl.prototype.set = function (value, color, alpha, family, size, weight, style, direction, clipping, fitting) {
            var isChangedDirty = false;
            var isChangedUploaded = false;
            if (value != null && this._value !== value) {
                this._value = value;
                isChangedDirty = true;
            }
            if (color != null && this._color !== color) {
                this._color = color;
                isChangedUploaded = true;
            }
            if (alpha != null && this._alpha !== alpha) {
                this._alpha = alpha;
                isChangedUploaded = true;
            }
            if (family != null && this._family !== family) {
                this._family = family;
                isChangedDirty = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChangedUploaded = true;
            }
            if (weight != null && this._weight !== weight) {
                this._weight = weight;
                isChangedUploaded = true;
            }
            if (style != null && this._style !== style) {
                this._style = style;
                isChangedUploaded = true;
            }
            if (direction != null && this._direction !== direction) {
                this._direction = direction;
                isChangedUploaded = true;
            }
            if (clipping != null && this._clipping !== clipping) {
                this._clipping = clipping;
                isChangedUploaded = true;
            }
            if (fitting != null && this._fitting !== fitting) {
                this._fitting = fitting;
                isChangedUploaded = true;
            }
            if (isChangedDirty) {
                this._parent.toDirty();
            }
            else if (isChangedUploaded) {
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeTextImpl.prototype.toObject = function () {
            return {
                value: this._value,
                color: this._color,
                alpha: this._alpha,
                family: this._family,
                size: this._size,
                weight: this._weight,
                align: this.align.toObject(),
                offset: this.offset.toObject(),
                style: this._style,
                outline: this.outline.toObject(),
                direction: this._direction,
                spacing: this.spacing.toObject(),
                padding: this.padding.toObject(),
                clipping: this._clipping,
                fitting: this._fitting
            };
        };
        EShapeTextImpl.prototype.serialize = function (manager) {
            var valueId = manager.addResource(this._value);
            var familyId = manager.addResource(this._family);
            var alignId = this.align.serialize(manager);
            var offsetId = this.offset.serialize(manager);
            var outlineId = this.outline.serialize(manager);
            var spacingId = this.spacing.serialize(manager);
            var paddingId = this.padding.serialize(manager);
            var clipping = this._clipping ? 1 : 0;
            var fitting = this._fitting ? 1 : 0;
            var serialized = "[".concat(valueId, ",").concat(this._color, ",").concat(this._alpha, ",").concat(familyId, ",").concat(this._size, ",") +
                "".concat(this._weight, ",").concat(alignId, ",").concat(offsetId, ",").concat(this._style, ",").concat(outlineId, ",") +
                "".concat(spacingId, ",").concat(this._direction, ",").concat(paddingId, ",").concat(clipping, ",").concat(fitting, "]");
            return manager.addResource(serialized);
        };
        EShapeTextImpl.prototype.deserialize = function (target, manager) {
            var resources = manager.resources;
            if (0 <= target && target < resources.length) {
                var parsed = manager.getText(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setText(target, parsed);
                }
                this.set(resources[parsed[0]] || "", parsed[1], parsed[2], resources[parsed[3]] || "auto", parsed[4], parsed[5], parsed[8], parsed[11], !!parsed[13], !!parsed[14]);
                this.align.deserialize(parsed[6], manager);
                this.offset.deserialize(parsed[7], manager);
                this.outline.deserialize(parsed[9], manager);
                this.spacing.deserialize(parsed[10], manager);
                this.padding.deserialize(parsed[12], manager);
            }
        };
        return EShapeTextImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePrimitive = /** @class */ (function (_super) {
        __extends(EShapePrimitive, _super);
        function EShapePrimitive(type) {
            var _this = _super.call(this, type) || this;
            _this.size = _this.newSize();
            _this.fill = _this.newFill();
            _this.stroke = _this.newStroke();
            _this._radius = EShapeDefaults.RADIUS;
            _this._corner = EShapeCorner.ALL;
            var data = new EShapeDataImpl();
            _this.data = data;
            _this.tag = data;
            _this.text = _this.newText();
            return _this;
        }
        EShapePrimitive.prototype.newSize = function () {
            var _this = this;
            return new pixi_js.ObservablePoint(function () {
                _this.onSizeChange();
            }, undefined, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
        };
        EShapePrimitive.prototype.newFill = function () {
            return new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, EShapeDefaults.FILL_ALPHA);
        };
        EShapePrimitive.prototype.newStroke = function () {
            return new EShapeStrokeImpl(this, true, EShapeDefaults.STROKE_COLOR, EShapeDefaults.STROKE_ALPHA, EShapeDefaults.STROKE_WIDTH, EShapeDefaults.STROKE_ALIGN, EShapeDefaults.STROKE_SIDE, EShapeDefaults.STROKE_STYLE);
        };
        EShapePrimitive.prototype.newText = function () {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.TEXT_COLOR, EShapeDefaults.TEXT_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        };
        Object.defineProperty(EShapePrimitive.prototype, "corner", {
            get: function () {
                return this._corner;
            },
            set: function (corner) {
                if (this._corner !== corner) {
                    this._corner = corner;
                    this.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePrimitive.prototype, "radius", {
            get: function () {
                return this._radius;
            },
            set: function (radius) {
                if (this._radius !== radius) {
                    this._radius = radius;
                    this.updateUploaded();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePrimitive.prototype, "image", {
            get: function () {
                return this._image;
            },
            set: function (image) {
                if (this._image !== image) {
                    if (image != null) {
                        this._image = image;
                        this.imageSrc = image.src;
                    }
                    else {
                        this._image = undefined;
                        this.imageSrc = undefined;
                    }
                    var parent_1 = this.parent;
                    if (parent_1 != null) {
                        parent_1.toDirty();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        return EShapePrimitive;
    }(EShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestCircle = function (shape, x, y, ax, ay, sw, ss) {
        var fill = shape.fill;
        if (fill.enable) {
            var x2 = x * x;
            var y2 = y * y;
            var ax2 = ax * ax;
            var ay2 = ay * ay;
            if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                return true;
            }
        }
        else {
            if (0 < sw) {
                var s = sw * ss;
                var x2 = x * x;
                var y2 = y * y;
                var wx = Math.max(0.0, ax - s);
                var wy = Math.max(0.0, ay - s);
                var wx2 = wx * wx;
                var wy2 = wy * wy;
                if (wx2 * wy2 <= x2 * wy2 + y2 * wx2) {
                    var ax2 = ax * ax;
                    var ay2 = ay * ay;
                    if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                        return true;
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TOP$1 = 1;
    var RIGHT$1 = 2;
    var BOTTOM$1 = 4;
    var LEFT$1 = 8;
    var EShapeStrokeSide = {
        NONE: 0,
        TOP: TOP$1,
        RIGHT: RIGHT$1,
        BOTTOM: BOTTOM$1,
        LEFT: LEFT$1,
        TOP_OR_LEFT: TOP$1 | LEFT$1,
        TOP_OR_RIGHT: TOP$1 | RIGHT$1,
        BOTTOM_OR_LEFT: BOTTOM$1 | LEFT$1,
        BOTTOM_OR_RIGHT: BOTTOM$1 | RIGHT$1,
        ALL: TOP$1 | RIGHT$1 | BOTTOM$1 | LEFT$1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestRectangle = function (shape, x, y, ax, ay, sw, ss) {
        if (hitTestBBox(x, y, ax, ay)) {
            var fill = shape.fill;
            if (fill.enable) {
                return true;
            }
            else {
                var strokeSide = shape.stroke.side;
                if (0 < sw && strokeSide !== EShapeStrokeSide.NONE) {
                    var s = sw * ss;
                    var wx = Math.max(0.0, ax - s);
                    var wy = Math.max(0.0, ay - s);
                    if (!hitTestBBox(x, y, wx, wy)) {
                        if (strokeSide === EShapeStrokeSide.ALL) {
                            return true;
                        }
                        else {
                            if (x <= -wx) {
                                if (y <= -wy) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP_OR_LEFT);
                                }
                                else if (+wy <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM_OR_LEFT);
                                }
                                else {
                                    return !!(strokeSide & EShapeStrokeSide.LEFT);
                                }
                            }
                            else if (+wx <= x) {
                                if (y <= -wy) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP_OR_RIGHT);
                                }
                                else if (+wy <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM_OR_RIGHT);
                                }
                                else {
                                    return !!(strokeSide & EShapeStrokeSide.RIGHT);
                                }
                            }
                            else {
                                if (y <= -wy) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP);
                                }
                                else if (+wy <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                }
                                else {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestTriangleFilled = function (x, y, a, ay1, ay2) {
        // a = 2 * ay / ax
        // y = + a * x + ay1
        // y = - a * x + ay1
        // y = ay2;
        return +a * x + ay1 - y <= 0 && -a * x + ay1 - y <= 0 && y <= ay2;
    };
    var hitTestTriangle = function (shape, x, y, ax, ay, sw, ss) {
        var a = (2 * ay) / ax;
        var fill = shape.fill;
        if (fill.enable) {
            if (hitTestTriangleFilled(x, y, a, -ay, +ay)) {
                return true;
            }
        }
        else {
            if (0 < sw) {
                var s = sw * ss;
                if (hitTestTriangleFilled(x, y, a, -ay, +ay)) {
                    var az = Math.sqrt(ax * ax + 4 * ay * ay);
                    var aw = (2 * ax * ay) / (ax + az);
                    var cy = ay - aw;
                    var ay1 = cy + ((-ay - cy) * Math.max(0.0, aw - s)) / aw;
                    var ay2 = ay - s;
                    if (!hitTestTriangleFilled(x, y, a, ay1, ay2)) {
                        return true;
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toThresholdDefault = function (size, scale, offset) {
        return 0.5 * (offset + size * scale);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineBase = /** @class */ (function (_super) {
        __extends(EShapeLineBase, _super);
        function EShapeLineBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeLineBase.prototype.getHitTestSize = function (result) {
            var formatted = this._points.formatted;
            if ("boundary" in formatted) {
                var boundary = formatted.boundary;
                result.width = Math.max(Math.abs(boundary[0]), Math.abs(boundary[2]));
                result.height = Math.max(Math.abs(boundary[1]), Math.abs(boundary[3]));
            }
            else {
                _super.prototype.getHitTestSize.call(this, result);
            }
            return result;
        };
        EShapeLineBase.prototype.toMarkerSize = function (points) {
            var result = 0;
            var marker = points.getMarker();
            if (marker) {
                var head = marker.head;
                if (head.type !== EShapePointsMarkerType.NONE) {
                    var size = head.size;
                    result = Math.max(result, Math.max(Math.abs(size.x), Math.abs(size.y)) * 2);
                }
                var tail = marker.tail;
                if (tail.type !== EShapePointsMarkerType.NONE) {
                    var size = tail.size;
                    result = Math.max(result, Math.max(Math.abs(size.x), Math.abs(size.y)) * 2);
                }
            }
            return result;
        };
        EShapeLineBase.prototype.containsAbsMarker = function (marker, x, y, sw, ss, sa) {
            var type = marker.type;
            if (type !== EShapePointsMarkerType.NONE) {
                var transform = marker.transform;
                var a = transform.a;
                var b = transform.b;
                var c = transform.c;
                var d = transform.d;
                var tx = transform.tx;
                var ty = transform.ty;
                var id = 1 / (a * d - c * b);
                var lx = (d * x - c * y + ty * c - tx * d) * id;
                var ly = (a * y - b * x - ty * a + tx * b) * id;
                var size = marker.size;
                var sx = 0.5 * size.x;
                var sy = 0.5 * size.y;
                if (sx < 0) {
                    sx = -sx;
                    x = -x;
                }
                if (sy < 0) {
                    sy = -sy;
                    y = -y;
                }
                var s = sw * ss * sa;
                sx += s;
                sy += s;
                switch (type) {
                    case EShapePointsMarkerType.CIRCLE:
                        return hitTestCircle(this, lx, ly, sx, sy, sw, ss);
                    case EShapePointsMarkerType.TRIANGLE:
                        return hitTestTriangle(this, lx, ly, sx, sy, sw, ss);
                    case EShapePointsMarkerType.RECTANGLE:
                        return hitTestRectangle(this, lx, ly, sx, sy, sw, ss);
                }
            }
            return false;
        };
        EShapeLineBase.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var points = this._points;
            var threshold = toThresholdDefault(sw, ss, 0);
            var margin = threshold + this.toMarkerSize(points);
            if (this.containsAbsBBox(x, y, ax + margin, ay + margin)) {
                var marker = points.getMarker();
                if (marker) {
                    if (this.containsAbsMarker(marker.head, x, y, sw, ss, sa)) {
                        return true;
                    }
                    if (this.containsAbsMarker(marker.tail, x, y, sw, ss, sa)) {
                        return true;
                    }
                }
                var tester = this.calcHitPointAbsHitTester;
                return points.calcHitPointAbs(x, y, ax, ay, threshold, null, tester, null);
            }
            return false;
        };
        EShapeLineBase.prototype.calcHitPart = function (x, y) {
            var data = this.toHitTestData(x, y);
            var sw = data.strokeWidth;
            var ss = data.strokeScale;
            var threshold = toThresholdDefault(sw, ss, 0);
            var points = this._points;
            var margin = threshold + this.toMarkerSize(points);
            var dx = data.x;
            var dy = data.y;
            var ax = data.width;
            var ay = data.height;
            if (this.containsAbsBBox(dx, dy, ax + margin, ay + margin)) {
                var marker = points.getMarker();
                if (marker) {
                    var sa = data.strokeAlign;
                    if (this.containsAbsMarker(marker.head, dx, dy, sw, ss, sa)) {
                        return EShapeLineBaseHitPart.MARKER_HEAD;
                    }
                    if (this.containsAbsMarker(marker.tail, dx, dy, sw, ss, sa)) {
                        return EShapeLineBaseHitPart.MARKER_TAIL;
                    }
                }
                var tester = this.calcHitPointAbsHitTester;
                if (points.calcHitPointAbs(dx, dy, ax, ay, threshold, null, tester, null)) {
                    return EShapeLineBaseHitPart.LINE;
                }
            }
            if (this.containsText(x, y)) {
                return EShapeLineBaseHitPart.TEXT;
            }
            if (this.containsChildren(x, y)) {
                return EShapeLineBaseHitPart.CHILDREN;
            }
            return EShapeLineBaseHitPart.NONE;
        };
        EShapeLineBase.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var points = this._points;
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, 0);
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return points.calcHitPointAbs(data.x, data.y, data.width, data.height, threshold, toRange, tester, result);
            }
            return false;
        };
        EShapeLineBase.prototype.calcHitPointAbsHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            // (x, y) = p0 + (p1 - p0) * t where 0 <= t <= 1
            // d0 := p1 - p0
            // d1 := v - p0
            // (p0.x + d0.x * t - x)^2 + (p0.y + d0.y * t - y)^2
            // (d0.x t - d1.x)^2 + (d0.y t - d1.y)^2
            // (d0.x^2 + d0.y^2) t^2 - 2 (d0.x * d1.x + d0.y * d1.y) t + (d1.x^2 + d1.y^2)
            // a := dot( d0, d0 )
            // b := dot( d0, d1 )
            // c := dot( d1, d1 )
            // a t^2 - 2 b t + c = a (t - b / a)^2 + c - b * b / a
            // t0 = b / a  min = c - b * b / a
            var d0x = p1x - p0x;
            var d0y = p1y - p0y;
            var d1x = x - p0x;
            var d1y = y - p0y;
            var a = d0x * d0x + d0y * d0y;
            var b = d0x * d1x + d0y * d1y;
            var c = d1x * d1x + d1y * d1y;
            if (0.0001 < a) {
                var t = Math.max(0, Math.min(1, b / a));
                var d = a * t * t - 2 * b * t + c;
                if (d < threshold * threshold) {
                    return true;
                }
            }
            return false;
        };
        return EShapeLineBase;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBar = /** @class */ (function (_super) {
        __extends(EShapeBar, _super);
        function EShapeBar(type) {
            if (type === void 0) { type = EShapeType.BAR; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeBarPoints(_this);
            return _this;
        }
        Object.defineProperty(EShapeBar.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeBar.prototype.clone = function () {
            return new EShapeBar(this.type).copy(this);
        };
        EShapeBar.prototype.containsAbsBBox = function (x, y, ax, ay) {
            var size = Math.max(0, this._points.size);
            return _super.prototype.containsAbsBBox.call(this, x, y, ax + size, ay + size);
        };
        EShapeBar.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = this._points.serialize(manager);
            return result;
        };
        return EShapeBar;
    }(EShapeLineBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderBar = /** @class */ (function (_super) {
        __extends(BuilderBar, _super);
        function BuilderBar(vertexOffset, indexOffset) {
            var _this = _super.call(this, vertexOffset, indexOffset, BAR_VERTEX_COUNT, BAR_INDEX_COUNT) || this;
            _this.pointsId = NaN;
            _this.pointsStyle = EShapePointsStyle.NONE;
            return _this;
        }
        BuilderBar.prototype.init = function (buffer) {
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            buffer.updateClippings();
            buffer.updateIndices();
            buildBarClipping(buffer.clippings, voffset);
            buildBarIndex(buffer.indices, voffset, ioffset);
        };
        BuilderBar.prototype.update = function (buffer, shape) {
            this.updateVertexStepAndColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderBar.prototype.updateVertexStepAndColorFill = function (buffer, shape) {
            if (shape instanceof EShapeBar) {
                var size = shape.size;
                var sizeX = size.x;
                var sizeY = size.y;
                var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
                var stroke = shape.stroke;
                var strokeWidth = stroke.enable ? stroke.width : 0;
                var strokeStyle = stroke.style;
                var isStrokeWidthChanged = strokeWidth !== this.strokeWidth || strokeStyle !== this.strokeStyle;
                var transformLocalId = toTransformLocalId(shape);
                var isTransformChanged = this.transformLocalId !== transformLocalId;
                var points = shape.points;
                var pointsId = points.id;
                var isPointsIdChanged = pointsId !== this.pointsId;
                var pointsStyle = points.style;
                var isPointsStyleChanged = pointsStyle !== this.pointsStyle;
                if (isSizeChanged ||
                    isTransformChanged ||
                    isStrokeWidthChanged ||
                    isPointsIdChanged ||
                    isPointsStyleChanged) {
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                    this.strokeWidth = strokeWidth;
                    this.strokeStyle = strokeStyle;
                    this.transformLocalId = transformLocalId;
                    this.pointsId = pointsId;
                    this.pointsStyle = pointsStyle;
                    if (isPointsIdChanged) {
                        // Invalidate the texture transform ID to update the UVs
                        this.textureTransformId = NaN;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    buffer.updateColorFills();
                    buildBarVertexStepAndColorFill(buffer.vertices, buffer.steps, buffer.colorFills, this.vertexOffset, points.values, points.size, strokeWidth, strokeStyle, shape.transform.internalTransform);
                }
            }
        };
        BuilderBar.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildBarUv(buffer.uvs, this.vertexOffset, toTextureUvs(texture));
            }
        };
        return BuilderBar;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderText = /** @class */ (function () {
        function BuilderText(vertexOffset, indexOffset, vertexCount, indexCount) {
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = vertexCount;
            this.indexCount = indexCount;
            this.sizeX = NaN;
            this.sizeY = NaN;
            this.transformLocalId = NaN;
            this.scaleX = 1;
            this.scaleY = 1;
            this.size = NaN;
            this.family = "auto";
            this.value = "";
            this.texture = null;
            this.textureTransformId = NaN;
            this.color = NaN;
            this.alpha = NaN;
            this.weight = NaN;
            this.style = NaN;
            this.alignHorizontal = NaN;
            this.alignVertical = NaN;
            this.offsetHorizontal = NaN;
            this.offsetVertical = NaN;
            this.outlineWidth = NaN;
            this.outlineColor = NaN;
            this.outlineAlpha = NaN;
            this.spacingHorizontal = NaN;
            this.spacingVertical = NaN;
            this.direction = NaN;
            this.paddingHorizontal = NaN;
            this.paddingVertical = NaN;
            this.clipping = false;
            this.fitting = false;
        }
        BuilderText.prototype.init = function (buffer) {
            var vcount = this.vertexCount;
            if (0 < vcount) {
                // Clippings
                var voffset = this.vertexOffset;
                buffer.updateClippings();
                buildTextClipping(buffer.clippings, voffset, vcount);
                // Indices
                buffer.updateIndices();
                buildTextIndex(buffer.indices, voffset, this.indexOffset, this.indexCount);
            }
        };
        BuilderText.prototype.isCompatible = function (shape) {
            return toTextBufferCount(shape) * TEXT_VERTEX_COUNT === this.vertexCount;
        };
        BuilderText.prototype.update = function (buffer, shape) {
            var vcount = this.vertexCount;
            if (0 < vcount) {
                var textAtlas = shape.text.atlas;
                if (textAtlas != null) {
                    this.updateVertex(buffer, shape, textAtlas);
                    this.updateColorFill(buffer, shape);
                    this.updateColorStroke(buffer, shape);
                    this.updateStep(buffer, shape);
                }
            }
        };
        BuilderText.prototype.updateVertex = function (buffer, shape, textAtlas) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var text = shape.text;
            var textSize = text.size;
            var textFamily = text.family;
            var textValue = text.value;
            var textStyle = text.style;
            var textAlignHorizontal = text.align.horizontal;
            var textAlignVertical = text.align.vertical;
            var textOffsetHorizontal = text.offset.horizontal;
            var textOffsetVertical = text.offset.vertical;
            var textSpacingHorizontal = text.spacing.horizontal;
            var textSpacingVertical = text.spacing.vertical;
            var textDirection = text.direction;
            var textPaddingHorizontal = text.padding.horizontal;
            var textPaddingVertical = text.padding.vertical;
            var textClipping = text.clipping;
            var textFitting = text.fitting;
            var textTexture = text.texture || pixi_js.Texture.WHITE;
            var textTextureTransformId = toTextureTransformId(textTexture);
            var isCharChanged = textValue !== this.value || textFamily !== this.family;
            var isCharSizeChanged = textSize !== this.size;
            var isCharStyleChanged = textStyle !== this.style;
            var isCharAlignChanged = textAlignHorizontal !== this.alignHorizontal ||
                textAlignVertical !== this.alignVertical;
            var isCharOffsetChanged = textOffsetHorizontal !== this.offsetHorizontal ||
                textOffsetVertical !== this.offsetVertical;
            var isCharSpacingChanged = textSpacingHorizontal !== this.spacingHorizontal ||
                textSpacingVertical !== this.spacingVertical ||
                textPaddingHorizontal !== this.paddingHorizontal ||
                textPaddingVertical !== this.paddingVertical;
            var isCharDirectionChanged = textDirection !== this.direction;
            var isClippingChanged = this.clipping !== textClipping;
            var isFittingChanged = this.fitting !== textFitting;
            var isTextureChanged = textTexture !== this.texture || textTextureTransformId !== this.textureTransformId;
            if (isSizeChanged ||
                isTransformChanged ||
                isCharChanged ||
                isCharSizeChanged ||
                isCharStyleChanged ||
                isCharAlignChanged ||
                isCharOffsetChanged ||
                isCharSpacingChanged ||
                isCharDirectionChanged ||
                isClippingChanged ||
                isFittingChanged ||
                isTextureChanged) {
                this.size = textSize;
                this.family = textFamily;
                this.value = textValue;
                this.style = textStyle;
                this.alignHorizontal = textAlignHorizontal;
                this.alignVertical = textAlignVertical;
                this.offsetHorizontal = textOffsetHorizontal;
                this.offsetVertical = textOffsetVertical;
                this.spacingHorizontal = textSpacingHorizontal;
                this.spacingVertical = textSpacingVertical;
                this.direction = textDirection;
                this.paddingHorizontal = textPaddingHorizontal;
                this.paddingVertical = textPaddingVertical;
                this.clipping = textClipping;
                this.fitting = textFitting;
                this.texture = textTexture;
                this.textureTransformId = textTextureTransformId;
                if (isCharSizeChanged || isFittingChanged || (textFitting && isSizeChanged)) {
                    // Invalidate the text weight to update the text steps.
                    this.weight = NaN;
                }
                // Vertices & UVs
                buffer.updateVertices();
                buffer.updateUvs();
                var shapeSize = shape.size;
                var textWorld = text.world;
                if (textWorld == null) {
                    textWorld = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    text.world = textWorld;
                }
                buildTextVertex(buffer.vertices, buffer.uvs, this.vertexOffset, this.vertexCount, 0, 0, shapeSize.x, shapeSize.y, textAtlas, textSize, textValue, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textFitting, textWorld, toTextureUvs(textTexture), shape.transform.internalTransform);
            }
        };
        BuilderText.prototype.updateColorFill = function (buffer, shape) {
            var text = shape.text;
            var color = text.color;
            var alpha = shape.visible && text.enable ? text.alpha : 0;
            if (color !== this.color || alpha !== this.alpha) {
                this.color = color;
                this.alpha = alpha;
                buffer.updateColorFills();
                buildColor(color, alpha, this.vertexOffset, this.vertexCount, buffer.colorFills);
            }
        };
        BuilderText.prototype.updateColorStroke = function (buffer, shape) {
            var text = shape.text;
            var outline = text.outline;
            var color = outline.color;
            var alpha = shape.visible && text.enable ? outline.alpha : 0;
            if (color !== this.outlineColor || alpha !== this.outlineAlpha) {
                this.outlineColor = color;
                this.outlineAlpha = alpha;
                buffer.updateColorStrokes();
                buildColor(color, alpha, this.vertexOffset, this.vertexCount, buffer.colorStrokes);
            }
        };
        BuilderText.prototype.updateStep = function (buffer, shape) {
            var text = shape.text;
            var textOutline = text.outline;
            var textOutlineWidth = textOutline.enable ? textOutline.width : 0;
            var isOutlineWidthChanged = textOutlineWidth !== this.outlineWidth;
            var textWeight = text.weight;
            var isWeightChanged = textWeight !== this.weight;
            var scaleX = 1;
            var scaleY = 1;
            var textWorld = text.world;
            if (textWorld != null) {
                scaleX = textWorld[8];
                scaleY = textWorld[9];
            }
            var isScaleChanged = TEXT_FMIN < Math.abs(this.scaleX - scaleX) ||
                TEXT_FMIN < Math.abs(this.scaleY - scaleY);
            if (isWeightChanged || isOutlineWidthChanged || isScaleChanged) {
                this.weight = textWeight;
                this.outlineWidth = textOutlineWidth;
                this.scaleX = scaleX;
                this.scaleY = scaleY;
                buffer.updateSteps();
                buildTextStep(buffer.steps, this.vertexOffset, this.vertexCount, text.atlas, text.size, textOutlineWidth, textWeight, this.scaleX, this.scaleY);
            }
        };
        BuilderText.prototype.buildUnit = function (builder) {
            if (0 < this.vertexCount) {
                var textTexture = this.texture || pixi_js.Texture.WHITE;
                var textBaseTexture = textTexture.baseTexture;
                if (textBaseTexture !== builder.baseTexture) {
                    builder.baseTexture = textBaseTexture;
                    builder.push(textTexture, this.indexOffset);
                }
            }
        };
        return BuilderText;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createBarUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = BAR_VERTEX_COUNT + tvcount;
        var icount = BAR_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderBar(voffset, ioffset),
                new BuilderText(voffset + BAR_VERTEX_COUNT, ioffset + BAR_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toPadded = function (str, length, c) {
        var strLength = str.length;
        if (length < strLength) {
            return str;
        }
        var padding = "";
        for (var i = 0, imax = length - strLength; i < imax; ++i) {
            padding += c;
        }
        return padding + str;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilRgb = /** @class */ (function () {
        function UtilRgb() {
        }
        UtilRgb.toCode = function (color) {
            return toPadded(color.toString(16).toUpperCase(), 6, "0");
        };
        UtilRgb.fromCode = function (code) {
            var trimmed = code.trim().toLowerCase();
            if (trimmed.length === 6) {
                var color = Number("0x".concat(trimmed));
                if (color === color) {
                    return color;
                }
            }
            return null;
        };
        UtilRgb.fromRgb = function (r, g, b) {
            return ((r * 0xff) << 16) | ((g * 0xff) << 8) | ((b * 0xff) | 0);
        };
        UtilRgb.blend = function (colorA, colorB, t) {
            var ar = (colorA >> 16) & 0xff;
            var ag = (colorA >> 8) & 0xff;
            var ab = (colorA | 0) & 0xff;
            var br = (colorB >> 16) & 0xff;
            var bg = (colorB >> 8) & 0xff;
            var bb = (colorB | 0) & 0xff;
            var w1 = Math.max(0, Math.min(1, t));
            var w0 = 1 - w1;
            var cr = Math.max(0, Math.min(0xff, ar * w0 + br * w1));
            var cg = Math.max(0, Math.min(0xff, ag * w0 + bg * w1));
            var cb = Math.max(0, Math.min(0xff, ab * w0 + bb * w1));
            return (cr << 16) | (cg << 8) | (cb | 0);
        };
        UtilRgb.brighten = function (color, amount) {
            if (0 <= amount) {
                return this.blend(color, 0xffffff, amount);
            }
            else {
                return this.blend(color, 0x000000, -amount);
            }
        };
        UtilRgb.darken = function (color, amount) {
            if (0 <= amount) {
                return this.blend(color, 0x000000, amount);
            }
            else {
                return this.blend(color, 0xffffff, -amount);
            }
        };
        /**
         * Convertes the given color to a grayscale color.
         *
         * @param color a color to be converted
         * @returns a grayscale color
         * @see https://en.wikipedia.org/wiki/Grayscale
         */
        UtilRgb.toGrayscale = function (color) {
            var l = this.toLuma(color);
            return (l << 16) | (l << 8) | l;
        };
        /**
         * Convertes the given color to a luma in the range [0, 255].
         *
         * @param color a color to be converted
         * @returns a luma in the range [0, 255]
         * @see https://en.wikipedia.org/wiki/Grayscale
         */
        UtilRgb.toLuma = function (color) {
            var r = (color >> 16) & 0xff;
            var g = (color >> 8) & 0xff;
            var b = (color | 0) & 0xff;
            return (0.2126 * r + 0.7152 * g + 0.0722 * b) & 0xff;
        };
        return UtilRgb;
    }());

    var POSITION_X = 1;
    var POSITION_Y = 2;
    var ROTATION = 4;
    var COLOR_FILL = 8;
    var COLOR_STROKE = 16;
    var COLOR_TEXT = 32;
    var COLOR_TEXT_OUTLINE = 64;
    var VISIBILITY = 128;
    var HEIGHT = 256;
    var WIDTH = 512;
    var TEXT$1 = 1024;
    var CURSOR = 2048;
    var EShapeRuntimeReset = {
        NONE: 0,
        POSITION_X: POSITION_X,
        POSITION_Y: POSITION_Y,
        POSITION: POSITION_X | POSITION_Y,
        ROTATION: ROTATION,
        COLOR_FILL: COLOR_FILL,
        COLOR_STROKE: COLOR_STROKE,
        COLOR_FILL_AND_STROKE: COLOR_FILL | COLOR_STROKE,
        COLOR_TEXT: COLOR_TEXT,
        COLOR_TEXT_OUTLINE: COLOR_TEXT_OUTLINE,
        COLOR: COLOR_FILL | COLOR_STROKE | COLOR_TEXT | COLOR_TEXT_OUTLINE,
        VISIBILITY: VISIBILITY,
        HEIGHT: HEIGHT,
        WIDTH: WIDTH,
        SIZE: HEIGHT | WIDTH,
        TEXT: TEXT$1,
        CURSOR: CURSOR
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionBases = /** @class */ (function () {
        function EShapeActionBases() {
        }
        EShapeActionBases.toBaseFill = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_FILL ? shape : runtime).fill;
        };
        EShapeActionBases.toBaseStroke = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_STROKE ? shape : runtime).stroke;
        };
        EShapeActionBases.toBaseText = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT ? shape : runtime).text;
        };
        EShapeActionBases.toBaseTextOutline = function (shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT_OUTLINE ? shape : runtime).text
                .outline;
        };
        return EShapeActionBases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionEnvironment = {
        isInitializing: false
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link EShape} action expression utility class.
     */
    var EShapeActionExpressions = /** @class */ (function () {
        function EShapeActionExpressions() {
        }
        EShapeActionExpressions.from = function (expression, caster, def, defLiteral, nullable, parameter) {
            if (expression.trim().length <= 0) {
                return def;
            }
            try {
                /* eslint-disable prettier/prettier */
                var body = "" +
                    "try {" +
                    "with (shape) {" +
                    "with (state) {" +
                    "with (data.alias) {" +
                    "with (environment) {" +
                    (nullable ?
                        ("var result = (".concat(expression, ");") +
                            "return (result != null ? ".concat(caster, "(result) : null);")) :
                        "return ".concat(caster, "(").concat(expression, ");")) +
                    "}" +
                    "}" +
                    "}" +
                    "}" +
                    "} catch (e) {" +
                    "return ".concat(defLiteral, ";") +
                    "}";
                /* eslint-enable prettier/prettier */
                if (parameter == null) {
                    return Function("shape", "time", "environment", body);
                }
                else {
                    return Function("shape", "time", "environment", parameter, body);
                }
            }
            catch (e) {
                return def;
            }
        };
        EShapeActionExpressions.ofNumberOrNull = function (expression) {
            return this.from(expression, "Number", this.NULL, "null", true);
        };
        EShapeActionExpressions.ofStringOrNull = function (expression) {
            return this.from(expression, "String", this.NULL, "null", true);
        };
        EShapeActionExpressions.ofUnknown = function (expression) {
            return this.from(expression, "", this.NULL, "null", false);
        };
        EShapeActionExpressions.ofNumber = function (expression) {
            return this.from(expression, "Number", this.ZERO, "0", false);
        };
        EShapeActionExpressions.ofNumberOrOne = function (expression) {
            return this.from(expression, "Number", this.ONE, "1", false);
        };
        EShapeActionExpressions.ofNumberOrOneHundred = function (expression) {
            return this.from(expression, "Number", this.ONE_HUNDRED, "100", false);
        };
        EShapeActionExpressions.ofString = function (expression) {
            return this.from(expression, "String", this.EMPTY, '""', false);
        };
        EShapeActionExpressions.ofBoolean = function (expression) {
            return this.from(expression, "Boolean", this.TRUE, "true", false);
        };
        EShapeActionExpressions.ofBooleanOrTrue = function (expression) {
            return this.from(expression, "Boolean", this.TRUE, "true", false);
        };
        EShapeActionExpressions.ofBooleanOrFalse = function (expression) {
            return this.from(expression, "Boolean", this.FALSE, "false", false);
        };
        EShapeActionExpressions.ofElementOrNull = function (expression) {
            return this.from(expression, "", undefined, "null", false, "container");
        };
        EShapeActionExpressions.NULL = function () { return null; };
        EShapeActionExpressions.ZERO = function () { return 0; };
        EShapeActionExpressions.ONE = function () { return 1; };
        EShapeActionExpressions.ONE_HUNDRED = function () { return 100; };
        EShapeActionExpressions.EMPTY = function () { return ""; };
        EShapeActionExpressions.TRUE = function () { return true; };
        EShapeActionExpressions.FALSE = function () { return false; };
        return EShapeActionExpressions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class of action runtimes.
     */
    var EShapeActionRuntimeBase = /** @class */ (function () {
        function EShapeActionRuntimeBase(reset) {
            this.reset = reset || EShapeRuntimeReset.NONE;
        }
        EShapeActionRuntimeBase.prototype.initialize = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.execute = function (shape, runtime, time) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onResize = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onFocus = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onBlur = function (shape, runtime) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onClick = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onDblClick = function (shape, runtime, e, manager) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onDowning = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onDown = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onMove = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onOver = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onOut = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onUp = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onUpOutside = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onPressed = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onUnpressed = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onKeyDown = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onKeyUp = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightClick = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightDowning = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightDown = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightUp = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightUpOutside = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightPressed = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRightUnpressed = function (shape, runtime, e) {
            // DO NOTHING
        };
        EShapeActionRuntimeBase.prototype.onRender = function (shape, runtime, time, renderer) {
            // DO NOTHING
        };
        return EShapeActionRuntimeBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeConditional = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeConditional, _super);
        function EShapeActionRuntimeConditional(value, reset) {
            var _this = _super.call(this, reset) || this;
            _this.condition = EShapeActionExpressions.ofBoolean(value.condition);
            return _this;
        }
        return EShapeActionRuntimeConditional;
    }(EShapeActionRuntimeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlink = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlink, _super);
        function EShapeActionRuntimeBlink(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.interval = value.interval;
            return _this;
        }
        EShapeActionRuntimeBlink.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var interval = this.interval;
                var dinterval = interval << 1;
                var elapsed = time % dinterval;
                if (elapsed < interval) {
                    this.toOff(shape, runtime);
                    runtime.effect = time + (interval - elapsed);
                }
                else {
                    this.toOn(shape, runtime);
                    runtime.effect = time + (dinterval - elapsed);
                }
            }
        };
        EShapeActionRuntimeBlink.prototype.toOn = function (shape, runtime) {
            //
        };
        EShapeActionRuntimeBlink.prototype.toOff = function (shape, runtime) {
            //
        };
        return EShapeActionRuntimeBlink;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkBrighten = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkBrighten, _super);
        function EShapeActionRuntimeBlinkBrighten(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeBlinkBrighten.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.brighten(fill.color, 0.5), fill.alpha);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.brighten(stroke.color, 0.5), stroke.alpha);
            var text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.brighten(text.color, 0.5), text.alpha);
            var outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.brighten(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkBrighten;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkColorFill = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkColorFill, _super);
        function EShapeActionRuntimeBlinkColorFill(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.COLOR_FILL) || this;
            _this.color = value.color;
            _this.alpha = value.alpha;
            return _this;
        }
        EShapeActionRuntimeBlinkColorFill.prototype.toOn = function (shape, runtime) {
            shape.fill.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkColorFill;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkColorStroke = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkColorStroke, _super);
        function EShapeActionRuntimeBlinkColorStroke(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.COLOR_STROKE) || this;
            _this.color = value.color;
            _this.alpha = value.alpha;
            return _this;
        }
        EShapeActionRuntimeBlinkColorStroke.prototype.toOn = function (shape, runtime) {
            shape.stroke.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkColorStroke;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkDarken = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkDarken, _super);
        function EShapeActionRuntimeBlinkDarken(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR) || this;
        }
        EShapeActionRuntimeBlinkDarken.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.darken(fill.color, 0.5), fill.alpha);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.darken(stroke.color, 0.5), stroke.alpha);
            var text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.darken(text.color, 0.5), text.alpha);
            var outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.darken(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkDarken;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkOpacity = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkOpacity, _super);
        function EShapeActionRuntimeBlinkOpacity(value) {
            return _super.call(this, value, EShapeRuntimeReset.COLOR_FILL_AND_STROKE) || this;
        }
        EShapeActionRuntimeBlinkOpacity.prototype.toOn = function (shape, runtime) {
            var fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, fill.color, fill.alpha * 0.5);
            var stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, stroke.color, stroke.alpha * 0.5);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkOpacity;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeBlinkVisibility = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeBlinkVisibility, _super);
        function EShapeActionRuntimeBlinkVisibility(value) {
            return _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
        }
        EShapeActionRuntimeBlinkVisibility.prototype.toOn = function (shape, runtime) {
            shape.visible = true;
            runtime.written |= this.reset;
        };
        EShapeActionRuntimeBlinkVisibility.prototype.toOff = function (shape, runtime) {
            shape.visible = false;
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeBlinkVisibility;
    }(EShapeActionRuntimeBlink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBlinkType = {
        VISIBILITY: 0,
        BRIGHTEN: 1,
        DARKEN: 2,
        OPACITY: 3,
        COLOR_FILL: 4,
        COLOR_STROKE: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBase = /** @class */ (function () {
        function EShapeActionValueBase(type, condition) {
            this.type = type;
            this.condition = condition;
        }
        EShapeActionValueBase.prototype.isEquals = function (value) {
            return this.type === value.type && this.condition === value.condition;
        };
        EShapeActionValueBase.prototype.toLabel = function () {
            return this.getTheme().toLabel(this);
        };
        EShapeActionValueBase.prototype.getTheme = function () {
            var _a;
            return ((_a = EShapeActionValueBase.THEME) !== null && _a !== void 0 ? _a : (EShapeActionValueBase.THEME = DThemes.getInstance().get("EShapeActionValue")));
        };
        return EShapeActionValueBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueSubtyped = /** @class */ (function (_super) {
        __extends(EShapeActionValueSubtyped, _super);
        function EShapeActionValueSubtyped(type, condition, subtype) {
            var _this = _super.call(this, type, condition) || this;
            _this.subtype = subtype;
            return _this;
        }
        EShapeActionValueSubtyped.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueSubtyped &&
                this.subtype === value.subtype);
        };
        return EShapeActionValueSubtyped;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueType = {
        SHOW_HIDE: 0,
        BLINK: 1,
        TRANSFORM: 2,
        OPEN: 3,
        /** @deprecated in favor of {@link EShapeActionValueMiscType}'s MISC */
        EMIT_EVENT: 4,
        /** @deprecated in favor of {@link EShapeActionValueType}'s CHANGE_COLOR */
        CHANGE_COLOR_LEGACY: 5,
        CHANGE_TEXT: 6,
        CHANGE_CURSOR: 7,
        MISC: 8,
        CHANGE_COLOR: 9,
        GESTURE: 10,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValues = /** @class */ (function () {
        function EShapeActionValues() {
        }
        EShapeActionValues.toResource = function (index, parsed, resources) {
            if (0 <= index && index < parsed.length) {
                var id = parsed[index];
                if (isNumber(id) && 0 <= id && id < resources.length) {
                    return resources[id];
                }
            }
            return "";
        };
        return EShapeActionValues;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueBlink = /** @class */ (function (_super) {
        __extends(EShapeActionValueBlink, _super);
        function EShapeActionValueBlink(subtype, condition, interval, color, alpha) {
            var _this = _super.call(this, EShapeActionValueType.BLINK, condition, subtype) || this;
            _this.interval = interval;
            _this.color = color;
            _this.alpha = alpha;
            return _this;
        }
        EShapeActionValueBlink.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueBlink &&
                this.interval === value.interval &&
                this.color === value.color &&
                this.alpha === value.alpha);
        };
        EShapeActionValueBlink.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueBlinkType.BRIGHTEN:
                    return new EShapeActionRuntimeBlinkBrighten(this);
                case EShapeActionValueBlinkType.COLOR_FILL:
                    return new EShapeActionRuntimeBlinkColorFill(this);
                case EShapeActionValueBlinkType.COLOR_STROKE:
                    return new EShapeActionRuntimeBlinkColorStroke(this);
                case EShapeActionValueBlinkType.DARKEN:
                    return new EShapeActionRuntimeBlinkDarken(this);
                case EShapeActionValueBlinkType.OPACITY:
                    return new EShapeActionRuntimeBlinkOpacity(this);
                case EShapeActionValueBlinkType.VISIBILITY:
                    return new EShapeActionRuntimeBlinkVisibility(this);
            }
        };
        EShapeActionValueBlink.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.interval, ",").concat(this.color, ",").concat(this.alpha, "]"));
        };
        EShapeActionValueBlink.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueBlink(serialized[2], condition, serialized[3], serialized[4], serialized[5]);
        };
        return EShapeActionValueBlink;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilAlpha = /** @class */ (function () {
        function UtilAlpha() {
        }
        UtilAlpha.blend = function (alphaA, alphaB, t) {
            var w = Math.max(0, Math.min(1, t));
            return Math.max(0, Math.min(1, alphaA * (1 - w) + alphaB * w));
        };
        return UtilAlpha;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toReset = function (type) {
        return type << 3;
    };
    var EShapeActionRuntimeChangeColorBase = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBase, _super);
        function EShapeActionRuntimeChangeColorBase(value) {
            return _super.call(this, value, toReset(value.subtype)) || this;
        }
        EShapeActionRuntimeChangeColorBase.prototype.set = function (shape, runtime, time, color, alpha, blend) {
            var reset = this.reset;
            if (color != null) {
                if (alpha != null) {
                    if (blend != null) {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            var base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            var base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            var base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                    }
                    else {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            shape.fill.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            shape.stroke.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            shape.text.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            shape.text.outline.set(undefined, color, alpha);
                        }
                    }
                }
                else {
                    if (blend != null) {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            var base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            var base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            var base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                    }
                    else {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            var base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            var base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            var base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, color, base.alpha);
                        }
                    }
                }
                runtime.written |= reset;
            }
            else if (alpha != null) {
                if (blend != null) {
                    if (reset & EShapeRuntimeReset.COLOR_FILL) {
                        var base = EShapeActionBases.toBaseFill(shape, runtime);
                        shape.fill.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                        var base = EShapeActionBases.toBaseStroke(shape, runtime);
                        shape.stroke.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                        var base = EShapeActionBases.toBaseText(shape, runtime);
                        shape.text.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                        var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                        shape.text.outline.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                }
                else {
                    if (reset & EShapeRuntimeReset.COLOR_FILL) {
                        var base = EShapeActionBases.toBaseFill(shape, runtime);
                        shape.fill.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                        var base = EShapeActionBases.toBaseStroke(shape, runtime);
                        shape.stroke.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                        var base = EShapeActionBases.toBaseText(shape, runtime);
                        shape.text.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                        var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                        shape.text.outline.set(undefined, base.color, alpha);
                    }
                }
                runtime.written |= reset;
            }
        };
        return EShapeActionRuntimeChangeColorBase;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTarget = {
        COLOR_AND_ALPHA: 0,
        COLOR: 1,
        ALPHA: 2,
        CODE: 3,
        BRIGHTNESS: 4
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColor = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColor, _super);
        function EShapeActionRuntimeChangeColor(value) {
            var _this = _super.call(this, value) || this;
            switch (value.target) {
                case EShapeActionValueChangeColorTarget.COLOR:
                    _this.color = value.color;
                    _this.alpha = null;
                    break;
                case EShapeActionValueChangeColorTarget.ALPHA:
                    _this.color = null;
                    _this.alpha = value.alpha;
                    break;
                default:
                    _this.color = value.color;
                    _this.alpha = value.alpha;
                    break;
            }
            _this.blend = EShapeActionExpressions.ofNumberOrNull(value.blend);
            return _this;
        }
        EShapeActionRuntimeChangeColor.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var color = this.color;
                var alpha = this.alpha;
                var blend = this.blend(shape, time, EShapeActionEnvironment);
                this.set(shape, runtime, time, color, alpha, blend);
            }
        };
        return EShapeActionRuntimeChangeColor;
    }(EShapeActionRuntimeChangeColorBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FILL = 1;
    var STROKE = 2;
    var TEXT = 4;
    var TEXT_OUTLINE = 8;
    var EShapeActionValueChangeColorType = {
        NONE: 0,
        FILL: FILL,
        STROKE: STROKE,
        TEXT: TEXT,
        TEXT_OUTLINE: TEXT_OUTLINE,
        FILL_AND_STROKE: FILL | STROKE,
        ALL: FILL | STROKE | TEXT | TEXT_OUTLINE
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTypeLegacy = {
        FILL: 0,
        STROKE: 1,
        FILL_AND_STROKE: 2,
        TEXT: 3,
        TEXT_OUTLINE: 4,
        ALL: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorTypes = /** @class */ (function () {
        function EShapeActionValueChangeColorTypes() {
        }
        EShapeActionValueChangeColorTypes.from = function (serialized) {
            if (serialized[0] === EShapeActionValueType.CHANGE_COLOR) {
                return serialized[2];
            }
            switch (serialized[2]) {
                case EShapeActionValueChangeColorTypeLegacy.FILL:
                    return EShapeActionValueChangeColorType.FILL;
                case EShapeActionValueChangeColorTypeLegacy.STROKE:
                    return EShapeActionValueChangeColorType.STROKE;
                case EShapeActionValueChangeColorTypeLegacy.FILL_AND_STROKE:
                    return EShapeActionValueChangeColorType.FILL_AND_STROKE;
                case EShapeActionValueChangeColorTypeLegacy.TEXT:
                    return EShapeActionValueChangeColorType.TEXT;
                case EShapeActionValueChangeColorTypeLegacy.TEXT_OUTLINE:
                    return EShapeActionValueChangeColorType.TEXT_OUTLINE;
                case EShapeActionValueChangeColorTypeLegacy.ALL:
                    return EShapeActionValueChangeColorType.ALL;
            }
        };
        EShapeActionValueChangeColorTypes.unpack = function (type) {
            var result = [];
            if (type & EShapeActionValueChangeColorType.FILL) {
                result.push(EShapeActionValueChangeColorType.FILL);
            }
            if (type & EShapeActionValueChangeColorType.STROKE) {
                result.push(EShapeActionValueChangeColorType.STROKE);
            }
            if (type & EShapeActionValueChangeColorType.TEXT) {
                result.push(EShapeActionValueChangeColorType.TEXT);
            }
            if (type & EShapeActionValueChangeColorType.TEXT_OUTLINE) {
                result.push(EShapeActionValueChangeColorType.TEXT_OUTLINE);
            }
            return result;
        };
        EShapeActionValueChangeColorTypes.pack = function (types) {
            var result = EShapeActionValueChangeColorType.NONE;
            for (var i = 0, imax = types.length; i < imax; ++i) {
                result |= types[i];
            }
            return result;
        };
        return EShapeActionValueChangeColorTypes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColor = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColor, _super);
        function EShapeActionValueChangeColor(subtype, condition, target, color, alpha, blend) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.target = target;
            _this.color = color;
            _this.alpha = alpha;
            _this.blend = blend;
            return _this;
        }
        EShapeActionValueChangeColor.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeColor &&
                this.target === value.target &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        };
        EShapeActionValueChangeColor.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeColor(this);
        };
        EShapeActionValueChangeColor.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var blendId = manager.addResource(this.blend);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.target, ",").concat(this.color, ",").concat(this.alpha, ",").concat(blendId, "]"));
        };
        EShapeActionValueChangeColor.deserialize = function (serialized, manager) {
            var subtype = EShapeActionValueChangeColorTypes.from(serialized);
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColor(subtype, condition, serialized[3], serialized[4], serialized[5], blend);
        };
        return EShapeActionValueChangeColor;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorBrightness = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorBrightness, _super);
        function EShapeActionRuntimeChangeColorBrightness(value) {
            var _this = _super.call(this, value) || this;
            _this.brightness = EShapeActionExpressions.ofNumberOrNull(value.brightness);
            return _this;
        }
        EShapeActionRuntimeChangeColorBrightness.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var brightness = this.brightness(shape, time, EShapeActionEnvironment);
                this.set(shape, runtime, time, brightness);
            }
        };
        EShapeActionRuntimeChangeColorBrightness.prototype.set = function (shape, runtime, time, brightness) {
            var reset = this.reset;
            if (brightness != null) {
                var toAdjusted = this.toAdjusted;
                if (reset & EShapeRuntimeReset.COLOR_FILL) {
                    var base = EShapeActionBases.toBaseFill(shape, runtime);
                    shape.fill.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                    var base = EShapeActionBases.toBaseStroke(shape, runtime);
                    shape.stroke.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                    var base = EShapeActionBases.toBaseText(shape, runtime);
                    shape.text.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                    var base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                    shape.text.outline.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                runtime.written |= reset;
            }
        };
        EShapeActionRuntimeChangeColorBrightness.prototype.toAdjusted = function (color, brightness) {
            if (0 <= brightness) {
                return UtilRgb.brighten(color, +brightness);
            }
            else {
                return UtilRgb.darken(color, -brightness);
            }
        };
        return EShapeActionRuntimeChangeColorBrightness;
    }(EShapeActionRuntimeChangeColorBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorBrightness = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColorBrightness, _super);
        function EShapeActionValueChangeColorBrightness(subtype, condition, brightness) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.brightness = brightness;
            return _this;
        }
        EShapeActionValueChangeColorBrightness.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeColorBrightness &&
                this.brightness === value.brightness);
        };
        EShapeActionValueChangeColorBrightness.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeColorBrightness(this);
        };
        EShapeActionValueChangeColorBrightness.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var target = EShapeActionValueChangeColorTarget.BRIGHTNESS;
            var brightnessId = manager.addResource(this.brightness);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(target, ",").concat(brightnessId, "]"));
        };
        EShapeActionValueChangeColorBrightness.deserialize = function (serialized, manager) {
            var subtype = EShapeActionValueChangeColorTypes.from(serialized);
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var brightness = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueChangeColorBrightness(subtype, condition, brightness);
        };
        return EShapeActionValueChangeColorBrightness;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeColorCode = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeColorCode, _super);
        function EShapeActionRuntimeChangeColorCode(value) {
            var _this = _super.call(this, value) || this;
            _this.color = EShapeActionExpressions.ofNumberOrNull(value.color);
            _this.alpha = EShapeActionExpressions.ofNumberOrNull(value.alpha);
            _this.blend = EShapeActionExpressions.ofNumberOrNull(value.blend);
            return _this;
        }
        EShapeActionRuntimeChangeColorCode.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var color = this.color(shape, time, EShapeActionEnvironment);
                var alpha = this.alpha(shape, time, EShapeActionEnvironment);
                var blend = this.blend(shape, time, EShapeActionEnvironment);
                this.set(shape, runtime, time, color, alpha, blend);
            }
        };
        return EShapeActionRuntimeChangeColorCode;
    }(EShapeActionRuntimeChangeColorBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeColorCode = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeColorCode, _super);
        function EShapeActionValueChangeColorCode(subtype, condition, color, alpha, blend) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_COLOR, condition, subtype) || this;
            _this.color = color;
            _this.alpha = alpha;
            _this.blend = blend;
            return _this;
        }
        EShapeActionValueChangeColorCode.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeColorCode &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        };
        EShapeActionValueChangeColorCode.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeColorCode(this);
        };
        EShapeActionValueChangeColorCode.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var target = EShapeActionValueChangeColorTarget.CODE;
            var colorId = manager.addResource(this.color);
            var alphaId = manager.addResource(this.alpha);
            var blendId = manager.addResource(this.blend);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(target, ",").concat(colorId, ",").concat(alphaId, ",").concat(blendId, "]"));
        };
        EShapeActionValueChangeColorCode.deserialize = function (serialized, manager) {
            var subtype = EShapeActionValueChangeColorTypes.from(serialized);
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var color = EShapeActionValues.toResource(4, serialized, manager.resources);
            var alpha = EShapeActionValues.toResource(5, serialized, manager.resources);
            var blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColorCode(subtype, condition, color, alpha, blend);
        };
        return EShapeActionValueChangeColorCode;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeCursor = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeCursor, _super);
        function EShapeActionRuntimeChangeCursor(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.CURSOR) || this;
            _this.name = EShapeActionExpressions.ofStringOrNull(value.name);
            return _this;
        }
        EShapeActionRuntimeChangeCursor.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var name_1 = this.name(shape, time, EShapeActionEnvironment);
                if (name_1 != null) {
                    shape.cursor = name_1;
                    runtime.written |= this.reset;
                }
            }
        };
        return EShapeActionRuntimeChangeCursor;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeCursor = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeCursor, _super);
        function EShapeActionValueChangeCursor(condition, name) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_CURSOR, condition) || this;
            _this.name = name;
            return _this;
        }
        EShapeActionValueChangeCursor.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeCursor &&
                this.name === value.name);
        };
        EShapeActionValueChangeCursor.prototype.toRuntime = function () {
            return new EShapeActionRuntimeChangeCursor(this);
        };
        EShapeActionValueChangeCursor.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var nameId = manager.addResource(this.name);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(nameId, "]"));
        };
        EShapeActionValueChangeCursor.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueChangeCursor(condition, name);
        };
        return EShapeActionValueChangeCursor;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeA = /** @class */ (function () {
        function FormatNodeA() {
        }
        FormatNodeA.prototype.format = function (target, step, date) {
            return date.getHours() < 12 ? "AM" : "PM";
        };
        return FormatNodeA;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodea = /** @class */ (function () {
        function FormatNodea() {
        }
        FormatNodea.prototype.format = function (target, step, date) {
            return date.getHours() < 12 ? "am" : "pm";
        };
        return FormatNodea;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeD = /** @class */ (function () {
        function FormatNodeD() {
        }
        FormatNodeD.prototype.format = function (target, step, date) {
            return String(date.getDate());
        };
        return FormatNodeD;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoded = /** @class */ (function () {
        function FormatNoded() {
        }
        FormatNoded.prototype.format = function (target, step, date) {
            return "".concat(target | 0);
        };
        return FormatNoded;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePrecision = /** @class */ (function () {
        function FormatNodePrecision(precision) {
            if (precision != null) {
                this.precision = +precision.substring(1, precision.length);
            }
            else {
                this.precision = undefined;
            }
        }
        return FormatNodePrecision;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodee = /** @class */ (function (_super) {
        __extends(FormatNodee, _super);
        function FormatNodee() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodee.prototype.format = function (target, step, date) {
            return target.toExponential(this.precision);
        };
        return FormatNodee;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodef = /** @class */ (function (_super) {
        __extends(FormatNodef, _super);
        function FormatNodef() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodef.prototype.format = function (target, step, date) {
            return target.toFixed(this.precision);
        };
        return FormatNodef;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodefsi = /** @class */ (function (_super) {
        __extends(FormatNodefsi, _super);
        function FormatNodefsi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodefsi.prototype.format = function (target, step, date) {
            var abs = this.toAbs(target, step, date);
            if (abs < 1e-24) {
                return this.format_(target, 1, "");
            }
            else if (abs < 1e-21) {
                return this.format_(target, 1e24, "y");
            }
            else if (abs < 1e-18) {
                return this.format_(target, 1e21, "z");
            }
            else if (abs < 1e-15) {
                return this.format_(target, 1e18, "a");
            }
            else if (abs < 1e-12) {
                return this.format_(target, 1e15, "f");
            }
            else if (abs < 1e-9) {
                return this.format_(target, 1e12, "p");
            }
            else if (abs < 1e-6) {
                return this.format_(target, 1e9, "n");
            }
            else if (abs < 1e-3) {
                return this.format_(target, 1e6, "");
            }
            else if (abs < 1) {
                return this.format_(target, 1e3, "m");
            }
            else if (abs < 1e3) {
                return this.format_(target, 1, "");
            }
            else if (abs < 1e6) {
                return this.format_(target, 1e-3, "k");
            }
            else if (abs < 1e9) {
                return this.format_(target, 1e-6, "M");
            }
            else if (abs < 1e12) {
                return this.format_(target, 1e-9, "G");
            }
            else if (abs < 1e15) {
                return this.format_(target, 1e-12, "T");
            }
            else if (abs < 1e18) {
                return this.format_(target, 1e-15, "P");
            }
            else if (abs < 1e21) {
                return this.format_(target, 1e-18, "E");
            }
            else if (abs < 1e24) {
                return this.format_(target, 1e-21, "Z");
            }
            else {
                return this.format_(target, 1e-24, "Y");
            }
        };
        FormatNodefsi.prototype.toAbs = function (target, step, date) {
            return Math.abs(target);
        };
        FormatNodefsi.prototype.format_ = function (target, unitInverse, postfix) {
            var value = target * unitInverse;
            return "".concat(value.toFixed(this.precision)).concat(postfix);
        };
        return FormatNodefsi;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeg = /** @class */ (function (_super) {
        __extends(FormatNodeg, _super);
        function FormatNodeg() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodeg.prototype.format = function (target, step, date) {
            return target.toPrecision(this.precision);
        };
        return FormatNodeg;
    }(FormatNodePrecision));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeH = /** @class */ (function () {
        function FormatNodeH() {
        }
        FormatNodeH.prototype.format = function (target, step, date) {
            return String(date.getHours());
        };
        return FormatNodeH;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeh = /** @class */ (function () {
        function FormatNodeh() {
        }
        FormatNodeh.prototype.format = function (target, step, date) {
            return String(date.getHours() % 12);
        };
        return FormatNodeh;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeM = /** @class */ (function () {
        function FormatNodeM() {
        }
        FormatNodeM.prototype.format = function (target, step, date) {
            return String(date.getMonth() + 1);
        };
        return FormatNodeM;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodem = /** @class */ (function () {
        function FormatNodem() {
        }
        FormatNodem.prototype.format = function (target, step, date) {
            return String(date.getMinutes());
        };
        return FormatNodem;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodemi = /** @class */ (function () {
        function FormatNodemi() {
        }
        FormatNodemi.prototype.format = function (target, step, date) {
            return String(date.getMilliseconds());
        };
        return FormatNodemi;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeP = /** @class */ (function () {
        function FormatNodeP() {
        }
        FormatNodeP.prototype.format = function (target, step, date) {
            return "".concat((target * 100) | 0, "%");
        };
        return FormatNodeP;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodep = /** @class */ (function () {
        function FormatNodep() {
        }
        FormatNodep.prototype.format = function (target, step, date) {
            return "".concat(target | 0, "%");
        };
        return FormatNodep;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePadding = /** @class */ (function () {
        function FormatNodePadding(length, character, node) {
            this.length = length;
            this.character = character;
            this.node = node;
        }
        FormatNodePadding.prototype.format = function (target, step, date) {
            return toPadded(this.node.format(target, step, date), this.length, this.character);
        };
        return FormatNodePadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeParenthesis = /** @class */ (function () {
        function FormatNodeParenthesis(node) {
            this.node = node;
        }
        FormatNodeParenthesis.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] === "-") {
                return "(".concat(result.substring(1, result.length), ")");
            }
            return result;
        };
        return FormatNodeParenthesis;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodePlus = /** @class */ (function () {
        function FormatNodePlus(node) {
            this.node = node;
        }
        FormatNodePlus.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return "+".concat(result);
            }
            return result;
        };
        return FormatNodePlus;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeRP = /** @class */ (function () {
        function FormatNodeRP() {
        }
        FormatNodeRP.prototype.format = function (target, step, date) {
            return "".concat(Math.round(target * 100), "%");
        };
        return FormatNodeRP;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoderp = /** @class */ (function () {
        function FormatNoderp() {
        }
        FormatNoderp.prototype.format = function (target, step, date) {
            return "".concat(Math.round(target), "%");
        };
        return FormatNoderp;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodesdt = /** @class */ (function () {
        function FormatNodesdt(Y, M, D, H, m, s, mi) {
            this.Y = Y;
            this.M = M;
            this.D = D;
            this.H = H;
            this.m = m;
            this.s = s;
            this.mi = mi;
        }
        FormatNodesdt.prototype.format = function (target, step, date) {
            if (step < 1000) {
                return "".concat(this.s.format(target, step, date), ".").concat(this.mi.format(target, step, date));
            }
            else if (step < 60000) {
                return "".concat(this.m.format(target, step, date), ":").concat(this.s.format(target, step, date));
            }
            else if (step < 3600000) {
                return "".concat(this.H.format(target, step, date), ":").concat(this.m.format(target, step, date));
            }
            else if (step < 86400000) {
                var M = this.M.format(target, step, date);
                var D = this.D.format(target, step, date);
                return "".concat(M, "/").concat(D, " ").concat(this.H.format(target, step, date));
            }
            else if (step < 2592000000) {
                return "".concat(this.M.format(target, step, date), "/").concat(this.D.format(target, step, date));
            }
            else {
                return "".concat(this.Y.format(target, step, date), "/").concat(this.M.format(target, step, date));
            }
        };
        return FormatNodesdt;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeSpace = /** @class */ (function () {
        function FormatNodeSpace(node) {
            this.node = node;
        }
        FormatNodeSpace.prototype.format = function (target, step, date) {
            var result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return " ".concat(result);
            }
            return result;
        };
        return FormatNodeSpace;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodessi = /** @class */ (function (_super) {
        __extends(FormatNodessi, _super);
        function FormatNodessi() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FormatNodessi.prototype.toAbs = function (target, step, date) {
            return Math.abs(step);
        };
        return FormatNodessi;
    }(FormatNodefsi));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeString = /** @class */ (function () {
        function FormatNodeString(str) {
            this.str = str;
        }
        FormatNodeString.prototype.format = function (target, step, date) {
            return this.str;
        };
        return FormatNodeString;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodeY = /** @class */ (function () {
        function FormatNodeY() {
        }
        FormatNodeY.prototype.format = function (target, step, date) {
            return String(date.getFullYear());
        };
        return FormatNodeY;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodey = /** @class */ (function () {
        function FormatNodey() {
        }
        FormatNodey.prototype.format = function (target, step, date) {
            return String(date.getFullYear() % 100);
        };
        return FormatNodey;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodez = /** @class */ (function () {
        function FormatNodez() {
        }
        FormatNodez.prototype.format = function (target, step, date) {
            var z = date.getTimezoneOffset();
            var tzs = z <= 0 ? "+" : "-";
            var tzh = toPadded(String(Math.floor(Math.abs(z) / 60)), 2, "0");
            var tzm = toPadded(String(Math.floor(Math.abs(z) % 60)), 2, "0");
            return "".concat(tzs).concat(tzh, ":").concat(tzm);
        };
        return FormatNodez;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNoderd = /** @class */ (function () {
        function FormatNoderd() {
        }
        FormatNoderd.prototype.format = function (target, step, date) {
            return "".concat(Math.round(target));
        };
        return FormatNoderd;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var FormatNodes = /** @class */ (function () {
        function FormatNodes() {
        }
        FormatNodes.prototype.format = function (target, step, date) {
            return String(date.getSeconds());
        };
        return FormatNodes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var REGEXP = undefined;
    var getRegExp = function () {
        var result = REGEXP;
        if (result) {
            result.lastIndex = 0;
        }
        else {
            result =
                /%(0|_|-|\+|\()?(\.\d+)?(Y(?:MD?)?|y(?:MD?)?|MD?|D|H(?:ms?)?|h(?:ms?)?|m(?:i|s)?|a|A|s(?:s?i|dt)?|z|%|f(?:si)?|e|g|d|r(?:d|p)|p|P|RP)/g;
            REGEXP = result;
        }
        return result;
    };
    var toModifiedDatetime = function (modifier, length, node) {
        switch (modifier) {
            case "_":
                return new FormatNodePadding(length, " ", node);
            case "-":
                return node;
            default:
                return new FormatNodePadding(length, "0", node);
        }
    };
    var toModifiedNumber = function (modifier, node) {
        switch (modifier) {
            case "_": // space for non-negative numbers
                return new FormatNodeSpace(node);
            case "+": // plus sign for non-negative numbers
                return new FormatNodePlus(node);
            case "(": // parenthesis for the negative numbers
                return new FormatNodeParenthesis(node);
            default:
                return node;
        }
    };
    var toParsed = function (format) {
        var previousIndex = 0;
        var isDateRequired = false;
        var result = [];
        var regExp = getRegExp();
        while (true) {
            var matched = regExp.exec(format);
            if (matched != null) {
                var index = matched.index;
                if (previousIndex < index) {
                    result.push(new FormatNodeString(format.substring(previousIndex, index)));
                }
                previousIndex = index + matched[0].length;
                var all = matched[0];
                var modifier = matched[1];
                var precision = matched[2];
                var specifier = matched[3];
                switch (specifier) {
                    case "Y": // full year
                        isDateRequired = true;
                        result.push(new FormatNodeY());
                        break;
                    case "YM":
                        isDateRequired = true;
                        result.push(new FormatNodeY(), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()));
                        break;
                    case "YMD":
                        isDateRequired = true;
                        result.push(new FormatNodeY(), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "y": // short year: [0, 99]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodey()));
                        break;
                    case "yM":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodey()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()));
                        break;
                    case "yMD":
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodey()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "M": // month: [1, 12]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeM()));
                        break;
                    case "MD":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeM()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "D": // day of the month: [1, 31]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "H": // 24-hour clock: [0, 23]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeH()));
                        break;
                    case "Hm":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeH()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()));
                        break;
                    case "Hms":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeH()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "h": // 12-hour clock: [1, 12]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeh()));
                        break;
                    case "hm":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeh()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()));
                        break;
                    case "hms":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeh()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "m": // minute [0, 59]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodem()));
                        break;
                    case "ms":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodem()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "mi": // milliseconds [0, 999]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 3, new FormatNodemi()));
                        break;
                    case "a": // am or pm
                        isDateRequired = true;
                        result.push(new FormatNodea());
                        break;
                    case "A": // AM or PM
                        isDateRequired = true;
                        result.push(new FormatNodeA());
                        break;
                    case "s": // seconds: [0, 61]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "sdt":
                        isDateRequired = true;
                        result.push(new FormatNodesdt(new FormatNodeY(), toModifiedDatetime(modifier, 2, new FormatNodeM()), toModifiedDatetime(modifier, 2, new FormatNodeD()), toModifiedDatetime(modifier, 2, new FormatNodeH()), toModifiedDatetime(modifier, 2, new FormatNodem()), toModifiedDatetime(modifier, 2, new FormatNodes()), toModifiedDatetime(modifier, 3, new FormatNodemi())));
                        break;
                    case "z": // time zone
                        isDateRequired = true;
                        result.push(new FormatNodez());
                        break;
                    case "%": // a % literal
                        result.push(new FormatNodeString("%"));
                        break;
                    case "f": // fixed point notation
                        result.push(toModifiedNumber(modifier, new FormatNodef(precision)));
                        break;
                    case "e": // exponent notation
                        result.push(toModifiedNumber(modifier, new FormatNodee(precision)));
                        break;
                    case "g": // %f or %e
                        result.push(toModifiedNumber(modifier, new FormatNodeg(precision)));
                        break;
                    case "rd": // rounded decimal notation
                        result.push(toModifiedNumber(modifier, new FormatNoderd()));
                        break;
                    case "d": // decimal notation
                        result.push(toModifiedNumber(modifier, new FormatNoded()));
                        break;
                    case "P": // percent notation (Multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNodeP()));
                        break;
                    case "p": // percent notation (Not multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNodep()));
                        break;
                    case "RP": // percent notation (Multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNodeRP()));
                        break;
                    case "rp": // percent notation (Not multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNoderp()));
                        break;
                    case "fsi": // fixed point notation with a SI prefix
                        result.push(toModifiedNumber(modifier, new FormatNodefsi(precision)));
                        break;
                    case "ssi": // Step-based fixed point notation with a SI prefix
                        result.push(toModifiedNumber(modifier, new FormatNodessi(precision)));
                        break;
                    default:
                        result.push(new FormatNodeString(all));
                        break;
                }
            }
            else {
                if (previousIndex < format.length) {
                    result.push(new FormatNodeString(format.substring(previousIndex, format.length)));
                }
                break;
            }
        }
        return {
            nodes: result,
            date: isDateRequired
        };
    };
    /**
     * A NumberFormatter implementation class.
     */
    var NumberFormatterImpl = /** @class */ (function () {
        function NumberFormatterImpl(format) {
            var parsed = toParsed(format);
            this.date = parsed.date;
            this.nodes = parsed.nodes;
        }
        NumberFormatterImpl.prototype.format = function (target, step) {
            var nodes = this.nodes;
            var date = NumberFormatterImpl.DATE;
            if (date == null) {
                date = new Date();
                NumberFormatterImpl.DATE = date;
            }
            if (this.date) {
                date.setTime(target);
            }
            var result = "";
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                result += nodes[i].format(target, step, date);
            }
            return result;
        };
        return NumberFormatterImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An number formatter utility class.
     */
    var NumberFormatters = /** @class */ (function () {
        function NumberFormatters() {
        }
        /**
         * Creates a number formatter of the given format.
         * Please refer to {@link NumberFormatter} for format details.
         *
         * @return A created number formatter
         */
        NumberFormatters.create = function (format) {
            return new NumberFormatterImpl(format);
        };
        return NumberFormatters;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeTextNumber = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeTextNumber, _super);
        function EShapeActionRuntimeChangeTextNumber(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.TEXT) || this;
            _this.number = EShapeActionExpressions.ofNumber(value.value);
            _this.formatters = new Map();
            return _this;
        }
        EShapeActionRuntimeChangeTextNumber.prototype.getFormatter = function (shape, runtime) {
            var formatters = this.formatters;
            var text = runtime.text.value;
            var result = formatters.get(text);
            if (result === undefined) {
                result = this.newFormatter(text);
                formatters.set(text, result);
            }
            return result;
        };
        EShapeActionRuntimeChangeTextNumber.prototype.newFormatter = function (format) {
            format = format.trim();
            if (0 < format.length) {
                return NumberFormatters.create(format);
            }
            return null;
        };
        EShapeActionRuntimeChangeTextNumber.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var value = this.number(shape, time, EShapeActionEnvironment);
                var formatter = this.getFormatter(shape, runtime);
                shape.text.value = formatter != null ? formatter.format(value, 0) : String(value);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeTextNumber;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeChangeTextText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeChangeTextText, _super);
        function EShapeActionRuntimeChangeTextText(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.TEXT) || this;
            _this.text = EShapeActionExpressions.ofString(value.value);
            return _this;
        }
        EShapeActionRuntimeChangeTextText.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                shape.text.value = this.text(shape, time, EShapeActionEnvironment);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeChangeTextText;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeTextType = {
        TEXT: 0,
        NUMBER: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueChangeText = /** @class */ (function (_super) {
        __extends(EShapeActionValueChangeText, _super);
        function EShapeActionValueChangeText(subtype, condition, value) {
            var _this = _super.call(this, EShapeActionValueType.CHANGE_TEXT, condition, subtype) || this;
            _this.value = value;
            return _this;
        }
        EShapeActionValueChangeText.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueChangeText &&
                this.value === value.value);
        };
        EShapeActionValueChangeText.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueChangeTextType.TEXT:
                    return new EShapeActionRuntimeChangeTextText(this);
                case EShapeActionValueChangeTextType.NUMBER:
                    return new EShapeActionRuntimeChangeTextNumber(this);
            }
        };
        EShapeActionValueChangeText.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var valueId = manager.addResource(this.value);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(valueId, "]"));
        };
        EShapeActionValueChangeText.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var value = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueChangeText(serialized[2], condition, value);
        };
        return EShapeActionValueChangeText;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackground = /** @class */ (function () {
        function DBaseBackground(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var background = options === null || options === void 0 ? void 0 : options.background;
            if (background) {
                this._color = background.color;
                this._alpha = background.alpha;
            }
        }
        DBaseBackground.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseBackground.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseBackground.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBackgroundColor(state);
        };
        Object.defineProperty(DBaseBackground.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackground.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBackgroundAlpha(state);
        };
        Object.defineProperty(DBaseBackground.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackground.prototype.onChange = function () {
            var callback = this._callback;
            if (callback != null) {
                callback();
            }
        };
        return DBaseBackground;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TOP = 1;
    var RIGHT = 2;
    var BOTTOM = 4;
    var LEFT = 8;
    /**
     * A border mask.
     * Borders on masked parts are not rendered.
     */
    var DBorderMask = {
        NONE: 0,
        TOP: TOP,
        RIGHT: RIGHT,
        BOTTOM: BOTTOM,
        LEFT: LEFT,
        TOP_RIGHT: TOP | RIGHT,
        TOP_BOTTOM: TOP | BOTTOM,
        TOP_LEFT: TOP | LEFT,
        RIGHT_BOTTOM: RIGHT | BOTTOM,
        RIGHT_LEFT: RIGHT | LEFT,
        BOTTOM_LEFT: BOTTOM | LEFT,
        NOT_TOP: RIGHT | BOTTOM | LEFT,
        NOT_RIGHT: TOP | BOTTOM | LEFT,
        NOT_BOTTOM: TOP | RIGHT | LEFT,
        NOT_LEFT: TOP | RIGHT | BOTTOM,
        ALL: TOP | RIGHT | BOTTOM | LEFT
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toEnum = function (target, te) {
        return isString(target) ? te[target] : target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorder = /** @class */ (function () {
        function DBaseBorder(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var border = options === null || options === void 0 ? void 0 : options.border;
            if (border) {
                this._color = border.color;
                this._alpha = border.alpha;
                this._width = border.width;
                this._align = border.align;
                this._mask = toEnum(border.mask, DBorderMask);
            }
        }
        DBaseBorder.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseBorder.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseBorder.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBorderColor(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBorderAlpha(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getWidth = function (state) {
            var width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    var result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getBorderWidth(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getAlign = function (state) {
            var align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    var result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getBorderAlign(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.getMask = function (state) {
            var mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    var result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getBorderMask(state);
        };
        Object.defineProperty(DBaseBorder.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorder.prototype.onChange = function () {
            var callback = this._callback;
            if (callback != null) {
                callback();
            }
        };
        return DBaseBorder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var TOP_LEFT = 1;
    var TOP_RIGHT = 2;
    var BOTTOM_LEFT = 4;
    var BOTTOM_RIGHT = 8;
    /**
     * A corner mask.
     * Masked corners are rendered as if the corner radius is zero.
     */
    var DCornerMask = {
        NONE: 0,
        TOP_LEFT: TOP_LEFT,
        TOP_RIGHT: TOP_RIGHT,
        BOTTOM_LEFT: BOTTOM_LEFT,
        BOTTOM_RIGHT: BOTTOM_RIGHT,
        TOP: TOP_LEFT | TOP_RIGHT,
        BOTTOM: BOTTOM_LEFT | BOTTOM_RIGHT,
        LEFT: TOP_LEFT | BOTTOM_LEFT,
        RIGHT: TOP_RIGHT | BOTTOM_RIGHT,
        ALL: TOP_LEFT | TOP_RIGHT | BOTTOM_LEFT | BOTTOM_RIGHT
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseCorner = /** @class */ (function () {
        function DBaseCorner(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var corner = options === null || options === void 0 ? void 0 : options.corner;
            if (corner) {
                if (isNumber(corner)) {
                    this._radius = corner;
                    this._mask = undefined;
                }
                else {
                    this._radius = corner.radius;
                    this._mask = toEnum(corner.mask, DCornerMask);
                }
            }
        }
        DBaseCorner.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseCorner.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseCorner.prototype.getRadius = function () {
            var _a;
            return (_a = this._radius) !== null && _a !== void 0 ? _a : this._theme.getCornerRadius();
        };
        Object.defineProperty(DBaseCorner.prototype, "radius", {
            get: function () {
                return this._radius;
            },
            set: function (radius) {
                if (this._radius !== radius) {
                    this._radius = radius;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseCorner.prototype.getMask = function () {
            var _a;
            return (_a = this._mask) !== null && _a !== void 0 ? _a : this._theme.getCornerMask();
        };
        Object.defineProperty(DBaseCorner.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseCorner.prototype.set = function (radius, mask) {
            var isChanged = false;
            if (this._radius !== radius) {
                this._radius = radius;
                isChanged = true;
            }
            if (this._mask !== mask) {
                this._mask = mask;
                isChanged = true;
            }
            var callback = this._callback;
            if (isChanged && callback != null) {
                callback();
            }
        };
        return DBaseCorner;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var SELF = 1;
    var CHILDREN = 2;
    /**
     * DBase interactivity.
     * Mouse / touch events are triggered only on interactive objects.
     */
    var DBaseInteractive = {
        /**
         * Not interactive.
         */
        NONE: 0,
        /**
         * Interactive.
         */
        SELF: SELF,
        /**
         * Children are interactive.
         */
        CHILDREN: CHILDREN,
        /**
         * Interactive.
         * And also children are interactive.
         */
        BOTH: SELF | CHILDREN
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOutline = /** @class */ (function () {
        function DBaseOutline(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var outline = options === null || options === void 0 ? void 0 : options.outline;
            if (outline) {
                this._color = outline.color;
                this._alpha = outline.alpha;
                this._width = outline.width;
                this._offset = outline.offset;
                this._align = outline.align;
                this._mask = toEnum(outline.mask, DBorderMask);
            }
        }
        DBaseOutline.prototype.getTheme = function () {
            return this._theme;
        };
        DBaseOutline.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBaseOutline.prototype.getColor = function (state) {
            var color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getOutlineColor(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getAlpha = function (state) {
            var alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getOutlineAlpha(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getWidth = function (state) {
            var width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    var result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getOutlineWidth(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getOffset = function (state) {
            var offset = this._offset;
            if (offset !== undefined) {
                if (isFunction(offset)) {
                    var result = offset(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return offset;
                }
            }
            return this._theme.getOutlineOffset(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            set: function (offset) {
                if (this._offset !== offset) {
                    this._offset = offset;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getAlign = function (state) {
            var align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    var result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getOutlineAlign(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (align) {
                if (this._align !== align) {
                    this._align = align;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseOutline.prototype.getMask = function (state) {
            var mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    var result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getOutlineMask(state);
        };
        Object.defineProperty(DBaseOutline.prototype, "mask", {
            get: function () {
                return this._mask;
            },
            set: function (mask) {
                if (this._mask !== mask) {
                    this._mask = mask;
                    var callback = this._callback;
                    if (callback != null) {
                        callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        return DBaseOutline;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePadding = /** @class */ (function () {
        function DBasePadding(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            var padding = options === null || options === void 0 ? void 0 : options.padding;
            if (padding != null) {
                if (isNumber(padding)) {
                    this._left = padding;
                    this._top = padding;
                    this._right = padding;
                    this._bottom = padding;
                }
                else {
                    this._left = padding.left;
                    this._top = padding.top;
                    this._right = padding.right;
                    this._bottom = padding.bottom;
                }
            }
        }
        DBasePadding.prototype.getTheme = function () {
            return this._theme;
        };
        DBasePadding.prototype.setTheme = function (theme) {
            this._theme = theme;
        };
        DBasePadding.prototype.getCallback = function () {
            return this._callback;
        };
        DBasePadding.prototype.getLeft = function () {
            var _a;
            return (_a = this._left) !== null && _a !== void 0 ? _a : this._theme.getPaddingLeft();
        };
        Object.defineProperty(DBasePadding.prototype, "left", {
            get: function () {
                return this._left;
            },
            set: function (left) {
                if (this._left !== left) {
                    this._left = left;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.getTop = function () {
            var _a;
            return (_a = this._top) !== null && _a !== void 0 ? _a : this._theme.getPaddingTop();
        };
        Object.defineProperty(DBasePadding.prototype, "top", {
            get: function () {
                return this._top;
            },
            set: function (top) {
                if (this._top !== top) {
                    this._top = top;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.getRight = function () {
            var _a;
            return (_a = this._right) !== null && _a !== void 0 ? _a : this._theme.getPaddingRight();
        };
        Object.defineProperty(DBasePadding.prototype, "right", {
            get: function () {
                return this._right;
            },
            set: function (right) {
                if (this._right !== right) {
                    this._right = right;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.getBottom = function () {
            var _a;
            return (_a = this._bottom) !== null && _a !== void 0 ? _a : this._theme.getPaddingBottom();
        };
        Object.defineProperty(DBasePadding.prototype, "bottom", {
            get: function () {
                return this._bottom;
            },
            set: function (bottom) {
                if (this._bottom !== bottom) {
                    this._bottom = bottom;
                    if (this._callback != null) {
                        this._callback();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePadding.prototype.set = function (top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
            if (this._callback != null) {
                this._callback();
            }
        };
        return DBasePadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePoint = /** @class */ (function () {
        function DBasePoint(point, onChange) {
            this._point = point;
            this._onChange = onChange;
        }
        Object.defineProperty(DBasePoint.prototype, "x", {
            get: function () {
                return this._point.x;
            },
            set: function (x) {
                var point = this._point;
                var oldX = point.x;
                if (oldX !== x) {
                    point.x = x;
                    var y = point.y;
                    this._onChange(x, y, oldX, y);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBasePoint.prototype, "y", {
            get: function () {
                return this._point.y;
            },
            set: function (y) {
                var point = this._point;
                var oldY = point.y;
                if (oldY !== y) {
                    point.y = y;
                    var x = point.x;
                    this._onChange(x, y, x, oldY);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBasePoint.prototype.set = function (x, y) {
            var point = this._point;
            var oldX = point.x;
            var oldY = point.y;
            if (oldX !== x || oldY !== y) {
                point.set(x, y);
                this._onChange(x, y, oldX, oldY);
            }
            return this;
        };
        DBasePoint.prototype.copyFrom = function (target) {
            var x = target.x;
            var y = target.y;
            var point = this._point;
            var oldX = point.x;
            var oldY = point.y;
            if (oldX !== x || oldY !== y) {
                point.copyFrom(target);
                this._onChange(x, y, oldX, oldY);
            }
            return this;
        };
        DBasePoint.prototype.copyTo = function (target) {
            return target.copyFrom(this._point);
        };
        DBasePoint.prototype.copy = function () {
            // eslint-disable-next-line prefer-rest-params
            return this.copyFrom(arguments[0]);
        };
        DBasePoint.prototype.clone = function (onChange) {
            return new DBasePoint(this._point, onChange || this._onChange);
        };
        DBasePoint.prototype.equals = function (p) {
            return this._point.equals(p);
        };
        return DBasePoint;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseMeshGeometry, _super);
        function DBaseMeshGeometry(vertices, uvs, indices) {
            var _this = _super.call(this, vertices, uvs, indices) || this;
            _this._width = 100;
            _this._height = 100;
            _this._cornerRadius = 0;
            _this._cornerMask = DCornerMask.NONE;
            _this._isDirty = true;
            _this._resolution = 1;
            _this._vertexBuffer = _this.getBuffer("aVertexPosition");
            _this._vertices = _this._vertexBuffer.data;
            _this._uvBuffer = _this.getBuffer("aTextureCoord");
            _this._uvs = _this._uvBuffer.data;
            _this._indexBuffer = _this.getIndex();
            _this._indices = _this._indexBuffer.data;
            return _this;
        }
        Object.defineProperty(DBaseMeshGeometry.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (width) {
                if (this._width !== width) {
                    this._width = width;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseMeshGeometry.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (height) {
                if (this._height !== height) {
                    this._height = height;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseMeshGeometry.prototype, "cornerRadius", {
            get: function () {
                return this._cornerRadius;
            },
            set: function (borderSize) {
                if (this._cornerRadius !== borderSize) {
                    this._cornerRadius = borderSize;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseMeshGeometry.prototype, "cornerMask", {
            get: function () {
                return this._cornerMask;
            },
            set: function (cornerMask) {
                if (this._cornerMask !== cornerMask) {
                    this._cornerMask = cornerMask;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseMeshGeometry.prototype.getTables = function () {
            var result = DBaseMeshGeometry.TABLES;
            if (result == null) {
                result = this.newTables(DBaseMeshGeometry.N);
                DBaseMeshGeometry.TABLES = result;
            }
            return result;
        };
        DBaseMeshGeometry.prototype.newTables = function (n) {
            var dp = 1.0 / (n - 1);
            var da = 0.5 * dp;
            return [
                this.newTable(n, 1.0, da),
                this.newTable(n, 0.5, da),
                this.newTable(n, 0.0, da),
                this.newTable(n, 1.5, da)
            ];
        };
        DBaseMeshGeometry.prototype.newTable = function (n, a0, da) {
            var cos = [];
            var sin = [];
            var pi = Math.PI;
            for (var i = 0, a = a0; i < n; i += 1, a -= da) {
                var t = a * pi;
                var c = +Math.cos(t);
                var s = -Math.sin(t);
                cos.push(c);
                sin.push(s);
            }
            return {
                cos: cos,
                sin: sin
            };
        };
        DBaseMeshGeometry.N = 4;
        return DBaseMeshGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseBackgroundMeshGeometry, _super);
        function DBaseBackgroundMeshGeometry() {
            return _super.call(this, new Float32Array(16 * DBaseMeshGeometry.N), new Float32Array(16 * DBaseMeshGeometry.N), new Uint16Array(3 * (12 * DBaseMeshGeometry.N - 2))) || this;
        }
        DBaseBackgroundMeshGeometry.prototype.fillVertices = function (vertices, uvs, iv, iuv, n, x, y, r, dr, table) {
            var cos = table.cos;
            var sin = table.sin;
            var cos0 = cos[0];
            var sin0 = sin[0];
            var cos1 = cos[n - 1];
            var sin1 = sin[n - 1];
            for (var i = 0; i < n; ++i) {
                var c = cos[i];
                var s = sin[i];
                var dro = dr;
                var d0 = c * cos0 + s * sin0;
                if (0.0001 < d0) {
                    dro = Math.min(dro, (1 / d0 - 1) * r);
                }
                var d1 = c * cos1 + s * sin1;
                if (0.0001 < d1) {
                    dro = Math.min(dro, (1 / d1 - 1) * r);
                }
                var ro = r + dro;
                vertices[++iv] = x + c * r;
                vertices[++iv] = y + s * r;
                vertices[++iv] = x + c * ro;
                vertices[++iv] = y + s * ro;
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5 * (1 + c);
                uvs[++iuv] = 0.5 * (1 + s);
            }
        };
        DBaseBackgroundMeshGeometry.prototype.fillIndices = function (indices, ia, ii, n) {
            for (var i = 0; i < n; ++i) {
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 3;
                ia += 2;
            }
        };
        DBaseBackgroundMeshGeometry.prototype.fillIndicesEnd = function (indices, ia, ii, n) {
            for (var i = 0, imax = n - 1; i < imax; ++i) {
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 3;
                ia += 2;
            }
            indices[++ii] = ia + 0;
            indices[++ii] = ia + 1;
            indices[++ii] = 0;
            indices[++ii] = 0;
            indices[++ii] = ia + 1;
            indices[++ii] = 1;
            ia += 2;
        };
        DBaseBackgroundMeshGeometry.prototype.update = function (renderer) {
            var resolution = renderer.resolution;
            if (this._isDirty || this._resolution !== resolution) {
                this._isDirty = false;
                this._resolution = resolution;
                var vertices = this._vertices;
                var uvs = this._uvs;
                var indices = this._indices;
                var w = this._width;
                var h = this._height;
                var r = Math.min(0.5 * w, 0.5 * h, this._cornerRadius);
                var a = 1 / resolution;
                var x0 = 0;
                var x1 = r;
                var x2 = w - r;
                var x3 = w;
                var y0 = 0;
                var y1 = r;
                var y2 = h - r;
                var y3 = h;
                var cornerMask = this._cornerMask;
                var ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                var ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                var cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                var cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                var iv = -1;
                var iuv = -1;
                var ia = 0;
                var ii = -1;
                var n = DBaseMeshGeometry.N;
                var n4 = n << 2;
                var n2 = n << 1;
                var n6 = 6 * n;
                var tables = this.getTables();
                var tlt = tables[0];
                var ttr = tables[1];
                var trb = tables[2];
                var tbl = tables[3];
                // left -> top
                if (ctl) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x1, y1, r, a, tlt);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x0, y0, 0, 0, tlt);
                }
                this.fillIndices(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // top -> right
                if (ctr) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x2, y1, r, a, ttr);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x3, y0, 0, 0, ttr);
                }
                this.fillIndices(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // right -> bottom
                if (cbr) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x2, y2, r, a, trb);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x3, y3, 0, 0, trb);
                }
                this.fillIndices(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // bottom -> left
                if (cbl) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x1, y2, r, a, tbl);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x0, y3, 0, 0, tbl);
                }
                this.fillIndicesEnd(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // Center
                ia = 2;
                for (var i = 1, imax = 4 * n - 1; i < imax; i += 1, ia += 2) {
                    indices[++ii] = 0;
                    indices[++ii] = ia;
                    indices[++ii] = ia + 2;
                }
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        };
        return DBaseBackgroundMeshGeometry;
    }(DBaseMeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundMesh = /** @class */ (function (_super) {
        __extends(DBaseBackgroundMesh, _super);
        function DBaseBackgroundMesh(texture) {
            var _this = _super.call(this, new DBaseBackgroundMeshGeometry(), new pixi_js.MeshMaterial(texture)) || this;
            texture.on("update", function () {
                DApplications.update(_this);
            });
            return _this;
        }
        Object.defineProperty(DBaseBackgroundMesh.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this.geometry.width;
            },
            set: function (width) {
                this.geometry.width = width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this.geometry.height;
            },
            set: function (height) {
                this.geometry.height = height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "cornerRadius", {
            get: function () {
                return this.geometry.cornerRadius;
            },
            set: function (cornerRadius) {
                this.geometry.cornerRadius = cornerRadius;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBackgroundMesh.prototype, "cornerMask", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (cornerMask) {
                this.geometry.cornerMask = cornerMask;
            },
            enumerable: false,
            configurable: true
        });
        DBaseBackgroundMesh.prototype._render = function (renderer) {
            this.geometry.update(renderer);
            _super.prototype._render.call(this, renderer);
        };
        return DBaseBackgroundMesh;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBackgroundSnippet = /** @class */ (function () {
        function DBaseBackgroundSnippet() {
        }
        DBaseBackgroundSnippet.prototype.get = function (base, theme) {
            var result = this._mesh;
            if (result == null) {
                result = new DBaseBackgroundMesh(theme.getBackgroundTexture());
                result.parent = base;
                this._mesh = result;
            }
            return result;
        };
        DBaseBackgroundSnippet.prototype.hide = function () {
            var mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        };
        DBaseBackgroundSnippet.prototype.onReflow = function (base, width, height, theme, state, cornerRadius, cornerMask) {
            var background = base.background;
            var backgroundColor = background.getColor(state);
            if (backgroundColor != null) {
                var backgroundAlpha = background.getAlpha(state);
                if (0 < backgroundAlpha) {
                    var backgroundMesh = this.get(base, theme);
                    backgroundMesh.tint = backgroundColor;
                    backgroundMesh.alpha = backgroundAlpha;
                    backgroundMesh.width = width;
                    backgroundMesh.height = height;
                    backgroundMesh.cornerRadius = cornerRadius;
                    backgroundMesh.cornerMask = cornerMask;
                    backgroundMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        };
        DBaseBackgroundSnippet.prototype.render = function (renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        };
        DBaseBackgroundSnippet.prototype.updateTransform = function () {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        };
        return DBaseBackgroundSnippet;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderMeshGeometry = /** @class */ (function (_super) {
        __extends(DBaseBorderMeshGeometry, _super);
        function DBaseBorderMeshGeometry() {
            var _this = _super.call(this, new Float32Array(32 * DBaseMeshGeometry.N), new Float32Array(32 * DBaseMeshGeometry.N), new Uint16Array(4 * 18 * DBaseMeshGeometry.N)) || this;
            _this._borderWidth = 0;
            _this._borderMask = DBorderMask.NONE;
            return _this;
        }
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "borderWidth", {
            get: function () {
                return this._borderWidth;
            },
            set: function (borderWidth) {
                if (this._borderWidth !== borderWidth) {
                    this._borderWidth = borderWidth;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMeshGeometry.prototype, "borderMask", {
            get: function () {
                return this._borderMask;
            },
            set: function (borderMask) {
                if (this._borderMask !== borderMask) {
                    this._borderMask = borderMask;
                    this._isDirty = true;
                }
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorderMeshGeometry.prototype.fillVertices = function (vertices, uvs, iv, iuv, n, x, y, r, dr, borderWidth, table) {
            var borderWidthHalf = 0.5 * borderWidth;
            var r0 = r - borderWidthHalf;
            var r2 = r + borderWidthHalf;
            var cos = table.cos;
            var sin = table.sin;
            var cos0 = cos[0];
            var sin0 = sin[0];
            var cos1 = cos[n - 1];
            var sin1 = sin[n - 1];
            var x1 = x + (cos0 + cos1) * r0;
            var y1 = y + (sin0 + sin1) * r0;
            for (var i = 0; i < n; ++i) {
                var c = cos[i];
                var s = sin[i];
                var dr1 = dr;
                var dr2 = dr;
                var d0 = c * cos0 + s * sin0;
                if (0.0001 < d0) {
                    var d0i = 1 / d0 - 1;
                    dr1 = Math.min(dr1, d0i * r0);
                    dr2 = Math.min(dr2, d0i * r2);
                }
                var d1 = c * cos1 + s * sin1;
                if (0.0001 < d1) {
                    var d1i = 1 / d1 - 1;
                    dr1 = Math.min(dr1, d1i * r0);
                    dr2 = Math.min(dr2, d1i * r2);
                }
                var r1 = r0 + dr1;
                var r3 = r2 + dr2;
                if (0 < r0) {
                    vertices[++iv] = x + c * r0;
                    vertices[++iv] = y + s * r0;
                    vertices[++iv] = x + c * r1;
                    vertices[++iv] = y + s * r1;
                }
                else {
                    vertices[++iv] = x1;
                    vertices[++iv] = y1;
                    vertices[++iv] = x1;
                    vertices[++iv] = y1;
                }
                vertices[++iv] = x + c * r2;
                vertices[++iv] = y + s * r2;
                vertices[++iv] = x + c * r3;
                vertices[++iv] = y + s * r3;
                uvs[++iuv] = 0.5 * (1 + c);
                uvs[++iuv] = 0.5 * (1 + s);
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5 * (1 + c);
                uvs[++iuv] = 0.5 * (1 + s);
            }
        };
        DBaseBorderMeshGeometry.prototype.fillIndices = function (indices, ia, ii, n, end, loop) {
            for (var i = 0, imax = n - 1; i < imax; ++i) {
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 5;
                ia += 1;
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 5;
                ia += 1;
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 5;
                ia += 2;
            }
            if (end) {
                if (loop) {
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 0;
                    indices[++ii] = 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 1;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 1;
                    indices[++ii] = 1;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 2;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 2;
                    indices[++ii] = 2;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 3;
                    ia += 2;
                }
                else {
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 5;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 5;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 5;
                    ia += 2;
                }
            }
            else {
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                ia += 1;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                ia += 1;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                ia += 2;
            }
        };
        DBaseBorderMeshGeometry.prototype.update = function (renderer) {
            var resolution = renderer.resolution;
            if (this._isDirty || this._resolution !== resolution) {
                this._isDirty = false;
                this._resolution = resolution;
                var vrtcs = this._vertices;
                var uvs = this._uvs;
                var indices = this._indices;
                var w = this._width;
                var h = this._height;
                var bw = this._borderWidth;
                var r = Math.min(0.5 * w, 0.5 * h, this._cornerRadius);
                var a = 1 / resolution;
                var x0 = 0;
                var x1 = r;
                var x2 = w - r;
                var x3 = w;
                var y0 = 0;
                var y1 = r;
                var y2 = h - r;
                var y3 = h;
                var borderMask = this._borderMask;
                var bt = !(borderMask & DBorderMask.TOP);
                var bb = !(borderMask & DBorderMask.BOTTOM);
                var bl = !(borderMask & DBorderMask.LEFT);
                var br = !(borderMask & DBorderMask.RIGHT);
                var cornerMask = this._cornerMask;
                var ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                var ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                var cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                var cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                var iv = -1;
                var iuv = -1;
                var ia = 0;
                var ii = -1;
                var n = DBaseMeshGeometry.N;
                var n4 = n << 2;
                var n8 = n << 3;
                var n18 = 18 * n;
                var tables = this.getTables();
                var tlt = tables[0];
                var ttr = tables[1];
                var trb = tables[2];
                var tbl = tables[3];
                // left -> top
                if (ctl) {
                    if (bl || bt) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y1, r, a, bw, tlt);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y1, r, 0, 0, tlt);
                    }
                }
                else {
                    if (bl || bt) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y0, 0, 0, bw, tlt);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y0, 0, 0, 0, tlt);
                    }
                }
                this.fillIndices(indices, ia, ii, n, bt, false);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                // top -> right
                if (ctr) {
                    if (bt || br) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y1, r, a, bw, ttr);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y1, r, 0, 0, ttr);
                    }
                }
                else {
                    if (bt || br) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y0, 0, 0, bw, ttr);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y0, 0, 0, 0, ttr);
                    }
                }
                this.fillIndices(indices, ia, ii, n, br, false);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                // right -> bottom
                if (cbr) {
                    if (br || bb) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y2, r, a, bw, trb);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y2, r, 0, 0, trb);
                    }
                }
                else {
                    if (br || bb) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y3, 0, 0, bw, trb);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y3, 0, 0, 0, trb);
                    }
                }
                this.fillIndices(indices, ia, ii, n, bb, false);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                // bottom -> left
                if (cbl) {
                    if (bb || bl) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y2, r, a, bw, tbl);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y2, r, 0, 0, tbl);
                    }
                }
                else {
                    if (bb || bl) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y3, 0, 0, bw, tbl);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y3, 0, 0, 0, tbl);
                    }
                }
                this.fillIndices(indices, ia, ii, n, bl, true);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        };
        return DBaseBorderMeshGeometry;
    }(DBaseMeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderMesh = /** @class */ (function (_super) {
        __extends(DBaseBorderMesh, _super);
        function DBaseBorderMesh(texture) {
            var _this = _super.call(this, new DBaseBorderMeshGeometry(), new pixi_js.MeshMaterial(texture)) || this;
            texture.on("update", function () {
                DApplications.update(_this);
            });
            return _this;
        }
        Object.defineProperty(DBaseBorderMesh.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this.geometry.width;
            },
            set: function (width) {
                this.geometry.width = width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this.geometry.height;
            },
            set: function (height) {
                this.geometry.height = height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "cornerRadius", {
            get: function () {
                return this.geometry.cornerRadius;
            },
            set: function (cornerRadius) {
                this.geometry.cornerRadius = cornerRadius;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "cornerMask", {
            get: function () {
                return this.geometry.cornerMask;
            },
            set: function (cornerMask) {
                this.geometry.cornerMask = cornerMask;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "borderWidth", {
            get: function () {
                return this.geometry.borderWidth;
            },
            set: function (borderWidth) {
                this.geometry.borderWidth = borderWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseBorderMesh.prototype, "borderMask", {
            get: function () {
                return this.geometry.borderMask;
            },
            set: function (borderMask) {
                this.geometry.borderMask = borderMask;
            },
            enumerable: false,
            configurable: true
        });
        DBaseBorderMesh.prototype._render = function (renderer) {
            this.geometry.update(renderer);
            _super.prototype._render.call(this, renderer);
        };
        return DBaseBorderMesh;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseBorderSnippet = /** @class */ (function () {
        function DBaseBorderSnippet() {
        }
        DBaseBorderSnippet.prototype.get = function (base, theme) {
            var result = this._mesh;
            if (result == null) {
                result = new DBaseBorderMesh(theme.getBorderTexture());
                result.parent = base;
                this._mesh = result;
            }
            return result;
        };
        DBaseBorderSnippet.prototype.hide = function () {
            var mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        };
        DBaseBorderSnippet.prototype.onReflow = function (base, width, height, theme, state, cornerRadius, cornerMask) {
            var border = base.border;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                if (0 < borderAlpha) {
                    var borderWidth = border.getWidth(state);
                    var borderMask = border.getMask(state);
                    var borderMesh = this.get(base, theme);
                    var borderOffset = (border.getAlign(state) - 0.5) * borderWidth;
                    borderMesh.tint = borderColor;
                    borderMesh.alpha = borderAlpha;
                    borderMesh.x = -borderOffset;
                    borderMesh.y = -borderOffset;
                    borderMesh.width = width + borderOffset * 2;
                    borderMesh.height = height + borderOffset * 2;
                    borderMesh.cornerRadius = cornerRadius;
                    borderMesh.cornerMask = cornerMask;
                    borderMesh.borderWidth = borderWidth;
                    borderMesh.borderMask = borderMask;
                    borderMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        };
        DBaseBorderSnippet.prototype.render = function (renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        };
        DBaseBorderSnippet.prototype.updateTransform = function () {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        };
        return DBaseBorderSnippet;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOutlineSnippet = /** @class */ (function () {
        function DBaseOutlineSnippet() {
        }
        DBaseOutlineSnippet.prototype.get = function (base, theme) {
            var result = this._mesh;
            if (result == null) {
                result = new DBaseBorderMesh(theme.getBorderTexture());
                result.parent = base;
                this._mesh = result;
            }
            return result;
        };
        DBaseOutlineSnippet.prototype.hide = function () {
            var mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        };
        DBaseOutlineSnippet.prototype.onReflow = function (base, width, height, theme, state, cornerRadius, cornerMask) {
            var outline = base.outline;
            var outlineColor = outline.getColor(state);
            if (outlineColor != null) {
                var outlineAlpha = outline.getAlpha(state);
                if (0 < outlineAlpha) {
                    var outlineWidth = outline.getWidth(state);
                    var outlineMask = outline.getMask(state);
                    var outlineMesh = this.get(base, theme);
                    var outlineOffset = outline.getOffset(state) + (outline.getAlign(state) - 0.5) * outlineWidth;
                    outlineMesh.tint = outlineColor;
                    outlineMesh.alpha = outlineAlpha;
                    outlineMesh.x = -outlineOffset;
                    outlineMesh.y = -outlineOffset;
                    outlineMesh.width = width + outlineOffset * 2;
                    outlineMesh.height = height + outlineOffset * 2;
                    outlineMesh.cornerRadius = cornerRadius;
                    outlineMesh.cornerMask = cornerMask;
                    outlineMesh.borderWidth = outlineWidth;
                    outlineMesh.borderMask = outlineMask;
                    outlineMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        };
        DBaseOutlineSnippet.prototype.render = function (renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        };
        DBaseOutlineSnippet.prototype.updateTransform = function () {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        };
        return DBaseOutlineSnippet;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseReflowableImpl = /** @class */ (function () {
        function DBaseReflowableImpl(base) {
            var background = new DBaseBackgroundSnippet();
            this._background = background;
            base.snippet.add(background, true);
            var border = new DBaseBorderSnippet();
            this._border = border;
            base.snippet.add(border, true);
            var outline = new DBaseOutlineSnippet();
            this._outline = outline;
            base.snippet.add(outline, false);
            base.reflowable.add(this);
        }
        DBaseReflowableImpl.prototype.onReflow = function (base, width, height) {
            var theme = base.theme;
            var state = base.state;
            var corner = base.corner;
            var cornerRadius = corner.getRadius();
            var cornerMask = corner.getMask();
            this._background.onReflow(base, width, height, theme, state, cornerRadius, cornerMask);
            this._border.onReflow(base, width, height, theme, state, cornerRadius, cornerMask);
            this._outline.onReflow(base, width, height, theme, state, cornerRadius, cornerMask);
        };
        return DBaseReflowableImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BEFORE = 1;
    var AFTER = 2;
    var DLayoutClearType = {
        NONE: 0,
        BEFORE: BEFORE,
        AFTER: AFTER,
        BOTH: BEFORE | AFTER
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScalarExpressionNodeType = {
        // Parensesis
        OPEN: 0,
        CLOSE: 1,
        PARENSESIS: 2,
        // Operations
        ADD_OR_PLUS: 3,
        SUB_OR_MINUS: 4,
        PLUS: 5,
        MINUS: 6,
        ADD: 7,
        SUB: 8,
        MUL: 9,
        DIV: 10,
        // Functions
        MIN: 11,
        MAX: 12,
        COMMA: 13,
        // Literals
        PARENT: 14,
        SELF: 15,
        PADDING: 16,
        CURRENT: 17,
        NUMBER: 18
    };
    /**
     * Parser and evaluator of the scalar expressions like `100% - 50s`.
     *
     * Literals
     *
     * * x%: 0.01 * x * parent value
     * * xs: 0.01 * x * self value
     * * xp: 0.01 * x * padding value
     * * xc: 0.01 * x * current value
     *
     * Operators
     *
     * * `+`
     * * `-`
     * * `*`
     * * `/`
     * * `(` and `)`
     *
     * Functions
     *
     * * min( a, b, ... )
     * * max( a, b, ... )
     *
     * Examples
     *
     * * `90%`: 0.9 * parent value
     * * `50s`: 0.5 * self value
     * * `90% - 50s`: 0.9 * parent value - 0.5 * self value
     * * `90% - (50s + 100) * 2`: 0.9 * parent value - ( 0.5 * self value + 100 ) * 2
     */
    var DScalarExpression = /** @class */ (function () {
        function DScalarExpression(expression) {
            var nodes = this.toToken(expression);
            var i = 0;
            do {
                i = this.toParensesis(nodes, i);
            } while (i < nodes.length);
            this.toUnary(nodes);
            this.toArithmetic(nodes, DScalarExpressionNodeType.MUL, DScalarExpressionNodeType.DIV);
            this.toArithmetic(nodes, DScalarExpressionNodeType.ADD, DScalarExpressionNodeType.SUB);
            if (nodes.length === 1) {
                var node = nodes[0];
                if (!isNumber(node)) {
                    this._node = node;
                    return;
                }
            }
            throw new Error("Failed to parse '".concat(expression, "'"));
        }
        DScalarExpression.prototype.toParensesis = function (nodes, ifrom) {
            var ito = nodes.length;
            for (var i = ifrom; i < ito; ++i) {
                var inode = nodes[i];
                if (inode === DScalarExpressionNodeType.OPEN) {
                    var istart = i;
                    var nodeType = DScalarExpressionNodeType.PARENSESIS;
                    if (0 < i) {
                        var nodeTypePrev = nodes[i - 1];
                        if (nodeTypePrev === DScalarExpressionNodeType.MIN ||
                            nodeTypePrev === DScalarExpressionNodeType.MAX) {
                            istart -= 1;
                            nodeType = nodeTypePrev;
                        }
                    }
                    for (var j = i + 1; j < ito; ++j) {
                        var jnode = nodes[j];
                        if (jnode === DScalarExpressionNodeType.CLOSE) {
                            nodes[istart] = [nodeType, this.toComma(nodes, i + 1, j)];
                            nodes.splice(istart + 1, j - istart);
                            return istart + 1;
                        }
                        else if (jnode === DScalarExpressionNodeType.OPEN) {
                            j = this.toParensesis(nodes, j) - 1;
                            ito = nodes.length;
                        }
                    }
                    throw new Error("Malformed parensesis");
                }
            }
            return ito;
        };
        DScalarExpression.prototype.toCommaOf = function (nodes, ifrom, ito) {
            var l = ito - ifrom;
            if (l <= 0) {
                return [DScalarExpressionNodeType.NUMBER, 0];
            }
            else if (l <= 1) {
                return nodes[ifrom];
            }
            else {
                var operand = [];
                for (var j = ifrom; j < ito; ++j) {
                    operand.push(nodes[j]);
                }
                return [DScalarExpressionNodeType.PARENSESIS, operand];
            }
        };
        DScalarExpression.prototype.toComma = function (nodes, ifrom, ito) {
            var result = null;
            var iprev = ifrom;
            for (var i = ifrom; i < ito; ++i) {
                var node = nodes[i];
                if (node === DScalarExpressionNodeType.COMMA) {
                    result = result || [];
                    result.push(this.toCommaOf(nodes, iprev, i));
                    iprev = i + 1;
                }
            }
            if (iprev < ito) {
                if (result == null) {
                    var operand = [];
                    for (var i = iprev; i < ito; ++i) {
                        operand.push(nodes[i]);
                    }
                    return operand;
                }
                else {
                    result.push(this.toCommaOf(nodes, iprev, ito));
                }
            }
            return result || [];
        };
        DScalarExpression.prototype.toUnaryNode = function (node) {
            if (!isNumber(node)) {
                if (node[0] === DScalarExpressionNodeType.PARENSESIS ||
                    node[0] === DScalarExpressionNodeType.MIN ||
                    node[0] === DScalarExpressionNodeType.MAX) {
                    this.toUnary(node[1]);
                }
            }
        };
        DScalarExpression.prototype.toUnary = function (nodes) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (node === DScalarExpressionNodeType.ADD_OR_PLUS ||
                    node === DScalarExpressionNodeType.SUB_OR_MINUS) {
                    if (i <= 0 || isNumber(nodes[i - 1])) {
                        if (i + 1 < imax && !isNumber(nodes[i + 1])) {
                            var operand = nodes.splice(i + 1, 1)[0];
                            var type = node === DScalarExpressionNodeType.ADD_OR_PLUS
                                ? DScalarExpressionNodeType.PLUS
                                : DScalarExpressionNodeType.MINUS;
                            nodes[i] = [type, operand];
                            imax = nodes.length;
                            this.toUnaryNode(operand);
                        }
                        else {
                            throw new Error("Malformed unary operator");
                        }
                    }
                    else {
                        var type = node === DScalarExpressionNodeType.ADD_OR_PLUS
                            ? DScalarExpressionNodeType.ADD
                            : DScalarExpressionNodeType.SUB;
                        nodes[i] = type;
                    }
                }
                else {
                    this.toUnaryNode(node);
                    imax = nodes.length;
                }
            }
        };
        DScalarExpression.prototype.toArithmeticNode = function (node, operatorA, operatorB) {
            if (!isNumber(node)) {
                if (node[0] === DScalarExpressionNodeType.PARENSESIS ||
                    node[0] === DScalarExpressionNodeType.MIN ||
                    node[0] === DScalarExpressionNodeType.MAX) {
                    this.toArithmetic(node[1], operatorA, operatorB);
                }
                else if (node[0] === DScalarExpressionNodeType.PLUS ||
                    node[0] === DScalarExpressionNodeType.MINUS) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                }
                else if (node[0] === DScalarExpressionNodeType.ADD ||
                    node[0] === DScalarExpressionNodeType.SUB ||
                    node[0] === DScalarExpressionNodeType.MUL ||
                    node[0] === DScalarExpressionNodeType.DIV) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                    this.toArithmeticNode(node[2], operatorA, operatorB);
                }
            }
        };
        DScalarExpression.prototype.toArithmetic = function (nodes, operatorA, operatorB) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (node === operatorA || node === operatorB) {
                    if (0 < i && i + 1 < imax) {
                        var left = nodes[i - 1];
                        var right = nodes[i + 1];
                        if (!isNumber(left) && !isNumber(right)) {
                            nodes.splice(i, 2);
                            nodes[i - 1] = [node, left, right];
                            i -= 1;
                            imax = nodes.length;
                            this.toArithmeticNode(left, operatorA, operatorB);
                            this.toArithmeticNode(right, operatorA, operatorB);
                            continue;
                        }
                    }
                    throw new Error("Malformed operands for the operator ".concat(node));
                }
                else {
                    this.toArithmeticNode(node, operatorA, operatorB);
                    imax = nodes.length;
                }
            }
        };
        DScalarExpression.prototype.toToken = function (expression) {
            var tokens = [];
            while (true) {
                var matched = DScalarExpression.TOKEN_REGEX.exec(expression);
                if (matched != null) {
                    var token = matched[0];
                    var tokenTypeOperator = this.toTokenOperator(token);
                    if (tokenTypeOperator != null) {
                        tokens.push(tokenTypeOperator);
                    }
                    else {
                        var parsedToken = parseFloat(token);
                        if (parsedToken !== parsedToken) {
                            throw new Error("Unexpected token '".concat(token, "' at ").concat(matched.index, " in '").concat(expression, "'"));
                        }
                        var tokenTypeLiteral = this.toTokenLiteral(token);
                        if (tokenTypeLiteral != null) {
                            tokens.push([tokenTypeLiteral, parsedToken * 0.01]);
                        }
                        else {
                            tokens.push([DScalarExpressionNodeType.NUMBER, parsedToken]);
                        }
                    }
                }
                else {
                    break;
                }
            }
            return tokens;
        };
        DScalarExpression.prototype.toTokenOperator = function (token) {
            switch (token) {
                case "+":
                    return DScalarExpressionNodeType.ADD_OR_PLUS;
                case "-":
                    return DScalarExpressionNodeType.SUB_OR_MINUS;
                case "*":
                    return DScalarExpressionNodeType.MUL;
                case "/":
                    return DScalarExpressionNodeType.DIV;
                case "(":
                    return DScalarExpressionNodeType.OPEN;
                case ")":
                    return DScalarExpressionNodeType.CLOSE;
                case ",":
                    return DScalarExpressionNodeType.COMMA;
                case "min":
                    return DScalarExpressionNodeType.MIN;
                case "max":
                    return DScalarExpressionNodeType.MAX;
            }
            return null;
        };
        DScalarExpression.prototype.toTokenLiteral = function (token) {
            var tokenLength = token.length;
            if (0 < tokenLength) {
                switch (token[tokenLength - 1]) {
                    case "%":
                        return DScalarExpressionNodeType.PARENT;
                    case "s":
                        return DScalarExpressionNodeType.SELF;
                    case "p":
                        return DScalarExpressionNodeType.PADDING;
                    case "c":
                        return DScalarExpressionNodeType.CURRENT;
                }
            }
            return null;
        };
        DScalarExpression.prototype.evaluate = function (node, parent, self, padding, current) {
            switch (node[0]) {
                case DScalarExpressionNodeType.PARENSESIS:
                    var nodes = node[1];
                    return this.evaluate(nodes[nodes.length - 1], parent, self, padding, current);
                // Unary operators
                case DScalarExpressionNodeType.PLUS:
                    return +this.evaluate(node[1], parent, self, padding, current);
                case DScalarExpressionNodeType.MINUS:
                    return -this.evaluate(node[1], parent, self, padding, current);
                // Four arithmetic operators
                case DScalarExpressionNodeType.ADD:
                    return (this.evaluate(node[1], parent, self, padding, current) +
                        this.evaluate(node[2], parent, self, padding, current));
                case DScalarExpressionNodeType.SUB:
                    return (this.evaluate(node[1], parent, self, padding, current) -
                        this.evaluate(node[2], parent, self, padding, current));
                case DScalarExpressionNodeType.MUL:
                    return (this.evaluate(node[1], parent, self, padding, current) *
                        this.evaluate(node[2], parent, self, padding, current));
                case DScalarExpressionNodeType.DIV:
                    return (this.evaluate(node[1], parent, self, padding, current) /
                        this.evaluate(node[2], parent, self, padding, current));
                // Functions
                case DScalarExpressionNodeType.MIN:
                    if (0 < node[1].length) {
                        var args = node[1];
                        var result = this.evaluate(args[0], parent, self, padding, current);
                        for (var i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.min(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                case DScalarExpressionNodeType.MAX:
                    if (0 < node[1].length) {
                        var args = node[1];
                        var result = this.evaluate(args[0], parent, self, padding, current);
                        for (var i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.max(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                // Literals
                case DScalarExpressionNodeType.PARENT:
                    return node[1] * parent;
                case DScalarExpressionNodeType.SELF:
                    return node[1] * self;
                case DScalarExpressionNodeType.PADDING:
                    return node[1] * padding;
                case DScalarExpressionNodeType.CURRENT:
                    return node[1] * current;
                case DScalarExpressionNodeType.NUMBER:
                    return node[1];
            }
            return 0;
        };
        DScalarExpression.prototype.calculate = function (parent, self, padding, current) {
            return this.evaluate(this._node, parent, self, padding, current);
        };
        DScalarExpression.TOKEN_REGEX = /(?:\+|-|\*|\/|\(|\)|min|max|,|(?:\d+(?:\.\d*)?[%psc]?))/g;
        return DScalarExpression;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var POSITION_CENTER = function (p, s) { return (p - s) * 0.5; };
    var POSITION_PADDING = function (p, s, d) { return d; };
    var SIZE_MAXIMIZED = function (p) { return p; };
    var SIZE_PADDING = function (p, s, d) { return p - d; };
    var DScalarFunctions = /** @class */ (function () {
        function DScalarFunctions() {
        }
        DScalarFunctions.position = function (coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "center":
                    case "CENTER":
                        return POSITION_CENTER;
                    case "padding":
                    case "PADDING":
                        return POSITION_PADDING;
                }
                var scalarExpression_1 = new DScalarExpression(coordinate);
                return function (parent, self, padding, current) {
                    return scalarExpression_1.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                var scalar_1 = coordinate;
                return function (parent, self, padding, current) {
                    return scalar_1.calculate(parent, self, padding, current);
                };
            }
        };
        DScalarFunctions.size = function (coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "100%":
                    case "maximized":
                    case "MAXIMIZED":
                        return SIZE_MAXIMIZED;
                    case "padding":
                    case "PADDING":
                        return SIZE_PADDING;
                }
                var scalarExpression_2 = new DScalarExpression(coordinate);
                return function (parent, self, padding, current) {
                    return scalarExpression_2.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                var scalar_2 = coordinate;
                return function (parent, self, padding, current) {
                    return scalar_2.calculate(parent, self, padding, current);
                };
            }
        };
        return DScalarFunctions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var setShortcutKeyAndWhich = function (shortcut) {
        var key = shortcut.key;
        if (key.length <= 1) {
            if (shortcut.shift) {
                shortcut.key = key.toUpperCase();
            }
            var code = key.charCodeAt(0);
            shortcut.which = 97 <= code && code <= 122 ? code - 32 : code;
        }
        else {
            switch (key) {
                case "enter":
                    shortcut.key = "Enter";
                    shortcut.which = 13;
                    break;
                case "space":
                    shortcut.key = " ";
                    shortcut.which = 32;
                    break;
                case "escape":
                    shortcut.key = "Escape";
                    shortcut.which = 27;
                    break;
                case "f1":
                    shortcut.key = "F1";
                    shortcut.which = 112;
                    break;
                case "f2":
                    shortcut.key = "F2";
                    shortcut.which = 113;
                    break;
                case "f3":
                    shortcut.key = "F3";
                    shortcut.which = 114;
                    break;
                case "f4":
                    shortcut.key = "F4";
                    shortcut.which = 115;
                    break;
                case "f5":
                    shortcut.key = "F5";
                    shortcut.which = 116;
                    break;
                case "f6":
                    shortcut.key = "F6";
                    shortcut.which = 117;
                    break;
                case "f7":
                    shortcut.key = "F7";
                    shortcut.which = 118;
                    break;
                case "f8":
                    shortcut.key = "F8";
                    shortcut.which = 119;
                    break;
                case "f9":
                    shortcut.key = "F9";
                    shortcut.which = 120;
                    break;
                case "f10":
                    shortcut.key = "F10";
                    shortcut.which = 121;
                    break;
                case "f11":
                    shortcut.key = "F11";
                    shortcut.which = 122;
                    break;
                case "f12":
                    shortcut.key = "F12";
                    shortcut.which = 123;
                    break;
                case "capslock":
                    shortcut.key = "CapsLock";
                    if (shortcut.shift) {
                        shortcut.which = 20;
                    }
                    else {
                        shortcut.which = 240;
                    }
                    break;
                case "arrowup":
                    shortcut.key = "ArrowUp";
                    shortcut.which = 38;
                    break;
                case "arrowdown":
                    shortcut.key = "ArrowDown";
                    shortcut.which = 40;
                    break;
                case "arrowleft":
                    shortcut.key = "ArrowLeft";
                    shortcut.which = 37;
                    break;
                case "arrowright":
                    shortcut.key = "ArrowRight";
                    shortcut.which = 39;
                    break;
                case "insert":
                    shortcut.key = "Insert";
                    shortcut.which = 45;
                    break;
                case "delete":
                    shortcut.key = "Delete";
                    shortcut.which = 46;
                    break;
                case "pageup":
                    shortcut.key = "PageUp";
                    shortcut.which = 33;
                    break;
                case "pagedown":
                    shortcut.key = "PageDown";
                    shortcut.which = 34;
                    break;
                case "backspace":
                    shortcut.key = "Backspace";
                    shortcut.which = 8;
                    break;
                case "colon":
                    shortcut.key = ":";
                    shortcut.which = 186;
                    break;
                case "semicolon":
                    shortcut.key = ";";
                    shortcut.which = 187;
                    break;
                case "pause":
                    shortcut.key = "Pause";
                    shortcut.which = 19;
                    break;
                case "scrolllock":
                    shortcut.key = "ScrollLock";
                    shortcut.which = 145;
                    break;
                case "tab":
                    shortcut.key = "Tab";
                    shortcut.which = 9;
                    break;
                case "plus":
                    shortcut.key = "+";
                    shortcut.which = 187;
                    break;
                case "minus":
                    shortcut.key = "-";
                    shortcut.which = 189;
                    break;
            }
        }
        return shortcut;
    };
    var UtilKeyboardEvent = /** @class */ (function () {
        function UtilKeyboardEvent() {
        }
        UtilKeyboardEvent.isActivateKey = function (e) {
            return e.key === "Space" || e.key === "Enter" || e.which === 32 || e.which === 13;
        };
        UtilKeyboardEvent.isArrowUpKey = function (e) {
            return e.key === "ArrowUp" || e.which === 38;
        };
        UtilKeyboardEvent.isArrowDownKey = function (e) {
            return e.key === "ArrowDown" || e.which === 40;
        };
        UtilKeyboardEvent.isArrowLeftKey = function (e) {
            return e.key === "ArrowLeft" || e.which === 37;
        };
        UtilKeyboardEvent.isArrowRightKey = function (e) {
            return e.key === "ArrowRight" || e.which === 39;
        };
        UtilKeyboardEvent.isCancelKey = function (e) {
            return e.key === "Esc" || e.which === 27;
        };
        UtilKeyboardEvent.isFocusKey = function (e) {
            return e.key === "Tab" || e.which === 9;
        };
        UtilKeyboardEvent.isUndoKey = function (e) {
            return e.ctrlKey && (e.key === "z" || e.which === 90);
        };
        UtilKeyboardEvent.isRedoKey = function (e) {
            return e.ctrlKey && (e.key === "y" || e.which === 89);
        };
        UtilKeyboardEvent.isSaveKey = function (e) {
            return e.ctrlKey && !e.shiftKey && (e.key === "s" || e.which === 83);
        };
        UtilKeyboardEvent.isSaveAsKey = function (e) {
            return e.ctrlKey && e.shiftKey && (e.key === "S" || e.which === 83);
        };
        UtilKeyboardEvent.isDeleteKey = function (e) {
            return e.key === "Delete" || e.which === 46;
        };
        UtilKeyboardEvent.isSelectAllKey = function (e) {
            return e.ctrlKey && !e.shiftKey && (e.key === "a" || e.which === 65);
        };
        UtilKeyboardEvent.isOkKey = function (e) {
            return e.key === "Enter" || e.which === 13;
        };
        UtilKeyboardEvent.getFocusDirection = function (e) {
            return e.shiftKey !== true;
        };
        UtilKeyboardEvent.toShortcut = function (expressionOrShortcut) {
            if (!isString(expressionOrShortcut)) {
                return expressionOrShortcut;
            }
            else {
                var expression = expressionOrShortcut;
                var arrowIndex = expression.indexOf("->");
                var keyExpression = void 0;
                var event_1;
                if (0 <= arrowIndex) {
                    keyExpression = expression.substring(0, arrowIndex).trim().toLowerCase();
                    event_1 = expression.substring(arrowIndex + 2).trim();
                }
                else {
                    keyExpression = expression.trim().toLowerCase();
                }
                var alt = false;
                var ctrl = false;
                var shift = false;
                var key = "a";
                var length_1 = keyExpression.length;
                var i = 0;
                var j = 1;
                for (; j < length_1; ++j) {
                    var c = keyExpression.charAt(j);
                    if (c === "+") {
                        var part = keyExpression.substring(i, j);
                        switch (part) {
                            case "alt":
                                alt = true;
                                break;
                            case "ctrl":
                                ctrl = true;
                                break;
                            case "shift":
                                shift = true;
                                break;
                            default:
                                key = part;
                                break;
                        }
                        j += 1;
                        i = j;
                    }
                }
                if (i !== j) {
                    key = keyExpression.substring(i, j);
                }
                return setShortcutKeyAndWhich({
                    alt: alt,
                    ctrl: ctrl,
                    shift: shift,
                    key: key,
                    which: 0,
                    event: event_1
                });
            }
        };
        UtilKeyboardEvent.toString = function (shortcut) {
            var parts = [];
            if (shortcut.ctrl) {
                parts.push("Ctrl");
            }
            if (shortcut.shift) {
                parts.push("Shift");
            }
            if (shortcut.alt) {
                parts.push("Alt");
            }
            parts.push(shortcut.key.toUpperCase());
            return parts.join("+");
        };
        UtilKeyboardEvent.on = function (target, expressionOrShortcut, handler) {
            var shortcut = this.toShortcut(expressionOrShortcut);
            document.body.addEventListener("keydown", function (e) {
                if (e.altKey === shortcut.alt &&
                    e.ctrlKey === shortcut.ctrl &&
                    e.shiftKey === shortcut.shift &&
                    (e.key === shortcut.key || e.which === shortcut.which)) {
                    if (target.state.isActionable) {
                        if (shortcut.event != null) {
                            target.emit(shortcut.event);
                        }
                        else if (handler != null) {
                            handler(e);
                        }
                    }
                    e.preventDefault();
                }
            });
        };
        UtilKeyboardEvent.moveFocusVertically = function (e, target, picker) {
            if (target.state.isActionable) {
                var isBackward = UtilKeyboardEvent.isArrowUpKey(e);
                var isForward = UtilKeyboardEvent.isArrowDownKey(e);
                if (isBackward || isForward) {
                    return this.moveFocus(isForward, target, picker);
                }
            }
            return false;
        };
        UtilKeyboardEvent.moveFocusHorizontally = function (e, target, picker) {
            if (target.state.isActionable) {
                var isBackward = UtilKeyboardEvent.isArrowLeftKey(e);
                var isForward = UtilKeyboardEvent.isArrowRightKey(e);
                if (isBackward || isForward) {
                    return this.moveFocus(isForward, target, picker);
                }
            }
            return false;
        };
        UtilKeyboardEvent.moveFocus = function (direction, target, picker) {
            var _a;
            var layer = (_a = picker === null || picker === void 0 ? void 0 : picker.picked) !== null && _a !== void 0 ? _a : DApplications.getLayer(target);
            if (layer) {
                var focusController = layer.getFocusController();
                var focused = focusController.get();
                if (focused != null) {
                    var next = focusController.find(focused, false, focused.state.isFocusRoot || direction, direction, target);
                    if (next != null) {
                        focusController.focus(next);
                        return true;
                    }
                }
            }
            return false;
        };
        return UtilKeyboardEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilPointerEvent = /** @class */ (function () {
        function UtilPointerEvent() {
        }
        Object.defineProperty(UtilPointerEvent, "touchable", {
            get: function () {
                return "ontouchstart" in document;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "tap", {
            get: function () {
                return "pointertap";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "down", {
            get: function () {
                return "pointerdown";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "enter", {
            get: function () {
                return "pointerenter";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "leave", {
            get: function () {
                return "pointerleave";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "move", {
            get: function () {
                return "pointermove";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "out", {
            get: function () {
                return "pointerout";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "over", {
            get: function () {
                return "pointerover";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "up", {
            get: function () {
                return "pointerup";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "upoutside", {
            get: function () {
                return "pointerupoutside";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "cancel", {
            get: function () {
                return "pointercancel";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "righttap", {
            get: function () {
                return "rightclick";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "rightdown", {
            get: function () {
                return "rightdown";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "rightup", {
            get: function () {
                return "rightup";
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilPointerEvent, "rightupoutside", {
            get: function () {
                return "rightupoutside";
            },
            enumerable: false,
            configurable: true
        });
        UtilPointerEvent.toGlobal = function (e, interactionManager, result) {
            if ("touches" in e) {
                var touches = e.changedTouches;
                var touch = touches[touches.length - 1];
                if (touch != null) {
                    interactionManager.mapPositionToPoint(result, touch.clientX, touch.clientY);
                }
                else {
                    interactionManager.mapPositionToPoint(result, 0, 0);
                }
            }
            else {
                interactionManager.mapPositionToPoint(result, e.clientX, e.clientY);
            }
            return result;
        };
        UtilPointerEvent.onDblClick = function (target, onDblClick) {
            var _this = this;
            target.addEventListener("dblclick", function (e) { return onDblClick(e, false); });
            if (this.touchable) {
                var isDowned_1 = 0;
                var downX_1 = 0;
                var downY_1 = 0;
                var clickTime_1 = 0;
                target.addEventListener("touchstart", function (e) {
                    if (isDowned_1 !== 0 && isDowned_1 !== 2) {
                        isDowned_1 = 0;
                        return;
                    }
                    var touches = e.touches;
                    var touchesLength = touches.length;
                    if (touchesLength <= 0) {
                        isDowned_1 = 0;
                        return;
                    }
                    var touch = touches.item(touchesLength - 1);
                    if (touch == null) {
                        isDowned_1 = 0;
                        return;
                    }
                    isDowned_1 += 1;
                    downX_1 = touch.clientX;
                    downY_1 = touch.clientY;
                });
                target.addEventListener("touchend", function (e) {
                    if (isDowned_1 !== 1 && isDowned_1 !== 3) {
                        isDowned_1 = 0;
                        return;
                    }
                    var touches = e.changedTouches;
                    var touchesLength = touches.length;
                    if (touchesLength <= 0) {
                        isDowned_1 = 0;
                        return;
                    }
                    var touch = touches[touchesLength - 1];
                    if (touch == null) {
                        isDowned_1 = 0;
                        return;
                    }
                    var dx = downX_1 - touch.clientX;
                    var dy = downY_1 - touch.clientY;
                    if (_this.CLICK_DISTANCE_THRESHOLD <= Math.abs(dx) + Math.abs(dy)) {
                        isDowned_1 = 0;
                        return;
                    }
                    if (isDowned_1 === 1) {
                        clickTime_1 = e.timeStamp;
                        isDowned_1 = 2;
                    }
                    else {
                        var elapsedTime = e.timeStamp - clickTime_1;
                        if (elapsedTime < _this.DBLCLICK_INTERVAL_THRESHOLD) {
                            isDowned_1 = 0;
                            onDblClick(e, true);
                        }
                        else {
                            clickTime_1 = e.timeStamp;
                            isDowned_1 = 2;
                        }
                    }
                });
                target.addEventListener("touchcancel", function () {
                    isDowned_1 = 0;
                });
            }
        };
        UtilPointerEvent.contains = function (target, targetOrChild) {
            var current = targetOrChild;
            while (current != null && current !== target) {
                current = current.parent;
            }
            return current === target;
        };
        UtilPointerEvent.CLICK_DISTANCE_THRESHOLD = 10;
        UtilPointerEvent.DBLCLICK_INTERVAL_THRESHOLD = 333;
        UtilPointerEvent.LONG_CLICK_THRESHOLD = 750;
        return UtilPointerEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseAuto = /** @class */ (function () {
        function DBaseAuto() {
            this._isOn = false;
        }
        Object.defineProperty(DBaseAuto.prototype, "isOff", {
            get: function () {
                return !this._isOn;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBaseAuto.prototype, "isOn", {
            get: function () {
                return this._isOn;
            },
            enumerable: false,
            configurable: true
        });
        DBaseAuto.prototype.toCoordinate = function (def) {
            return this._isOn ? "auto" : def;
        };
        /**
         * Update the auto settings by the given size.
         *
         * @param size a size
         * @returns True if the given size is "auto".
         */
        DBaseAuto.prototype.from = function (size) {
            if (size === "auto" || size === "AUTO") {
                this._isOn = true;
                return true;
            }
            this._isOn = false;
            return false;
        };
        return DBaseAuto;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseAutoSet = /** @class */ (function () {
        function DBaseAutoSet() {
            this.width = new DBaseAuto();
            this.height = new DBaseAuto();
        }
        return DBaseAutoSet;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseSnippetContainer = /** @class */ (function () {
        function DBaseSnippetContainer(parent) {
            this._parent = parent;
            this._befores = [];
            this._afters = [];
            this._renderable = true;
        }
        Object.defineProperty(DBaseSnippetContainer.prototype, "renderable", {
            get: function () {
                return this._renderable;
            },
            set: function (renderable) {
                this._renderable = renderable;
            },
            enumerable: false,
            configurable: true
        });
        DBaseSnippetContainer.prototype.add = function (snippet, phase) {
            var list = phase ? this._befores : this._afters;
            list.push(snippet);
            if ("parent" in snippet) {
                snippet.parent = this._parent;
            }
        };
        DBaseSnippetContainer.prototype.addAt = function (snippet, phase, index) {
            var list = phase ? this._befores : this._afters;
            if (index === 0) {
                list.unshift(snippet);
            }
            else if (0 < index && index < list.length) {
                list.splice(index, 0, snippet);
            }
            else {
                list.push(snippet);
            }
            if ("parent" in snippet) {
                snippet.parent = this._parent;
            }
        };
        DBaseSnippetContainer.prototype.remove = function (snippet, phase) {
            var list = phase ? this._befores : this._afters;
            var index = list.indexOf(snippet);
            if (0 <= index) {
                list.splice(index, 1);
                if ("parent" in snippet) {
                    snippet.parent = null;
                }
            }
        };
        DBaseSnippetContainer.prototype.render = function (renderer, phase) {
            if (this._renderable) {
                var list = phase ? this._befores : this._afters;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var snippet = list[i];
                    snippet.updateTransform();
                    snippet.render(renderer);
                }
            }
        };
        return DBaseSnippetContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseReflowableContainer = /** @class */ (function () {
        function DBaseReflowableContainer() {
            this._list = [];
        }
        DBaseReflowableContainer.prototype.add = function (reflowable) {
            this._list.push(reflowable);
        };
        DBaseReflowableContainer.prototype.remove = function (reflowable) {
            var list = this._list;
            var index = list.indexOf(reflowable);
            if (0 <= index) {
                list.splice(index, 1);
            }
        };
        DBaseReflowableContainer.prototype.onReflow = function (base, width, height) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].onReflow(base, width, height);
            }
        };
        return DBaseReflowableContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toTheme = function (options) {
        var theme = options === null || options === void 0 ? void 0 : options.theme;
        if (theme) {
            if (isString(theme)) {
                return DThemes.getInstance().get(theme);
            }
            return theme;
        }
    };
    var toShortcuts = function (options) {
        if (options) {
            var shortcut = options.shortcut;
            var shortcuts = options.shortcuts;
            if (shortcuts != null || shortcut != null) {
                var result = [];
                if (shortcut != null) {
                    result.push(UtilKeyboardEvent.toShortcut(shortcut));
                }
                if (shortcuts != null) {
                    for (var i = 0, imax = shortcuts.length; i < imax; ++i) {
                        result.push(UtilKeyboardEvent.toShortcut(shortcuts[i]));
                    }
                }
                return result;
            }
        }
        return undefined;
    };
    /**
     * A base class for UI classes.
     * See {@link DBaseEvents} for event details.
     */
    var DBase = /** @class */ (function (_super) {
        __extends(DBase, _super);
        function DBase(options) {
            var _this = this;
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            _this = _super.call(this) || this;
            // Transform
            var transform = _this.transform;
            _this._position = new DBasePoint(transform.position, function (newX, newY, oldX, oldY) {
                _this.onMove(newX, newY, oldX, oldY);
            });
            _this._scale = new DBasePoint(transform.scale, function (newX, newY, oldX, oldY) {
                _this.onScale(newX, newY, oldX, oldY);
            });
            _this._skew = new DBasePoint(transform.skew, function (newX, newY, oldX, oldY) {
                _this.onSkew(newX, newY, oldX, oldY);
            });
            //
            _this._options = options;
            var scalarSet = (_this._scalarSet = {});
            _this._auto = new DBaseAutoSet();
            _this._isDirty = true;
            _this._hasDirty = false;
            _this._isHierarchyDirty = false;
            _this._shadow = null;
            _this.name = (_a = options === null || options === void 0 ? void 0 : options.name) !== null && _a !== void 0 ? _a : "";
            var theme = toTheme(options) || _this.getThemeDefault();
            _this._theme = theme;
            _this._snippet = new DBaseSnippetContainer(_this);
            _this._reflowable = new DBaseReflowableContainer();
            _this._clearType = toEnum((_b = options === null || options === void 0 ? void 0 : options.clear) !== null && _b !== void 0 ? _b : theme.getClearType(), DLayoutClearType);
            _this._padding = new DBasePadding(theme, options, function () {
                _this.toParentResized();
                _this.toHierarchyDirty();
                DApplications.update(_this);
            });
            var toDirtyAndUpdate = function () {
                _this.toDirty();
                DApplications.update(_this);
            };
            _this._background = new DBaseBackground(theme, options, toDirtyAndUpdate);
            _this._border = new DBaseBorder(theme, options, toDirtyAndUpdate);
            _this._outline = new DBaseOutline(theme, options, toDirtyAndUpdate);
            _this._corner = new DBaseCorner(theme, options, toDirtyAndUpdate);
            // X
            var position = transform.position;
            var x = (_c = options === null || options === void 0 ? void 0 : options.x) !== null && _c !== void 0 ? _c : theme.getX();
            if (isNumber(x)) {
                position.x = x;
            }
            else {
                position.x = 0;
                scalarSet.x = DScalarFunctions.position(x);
            }
            // Y
            var y = (_d = options === null || options === void 0 ? void 0 : options.y) !== null && _d !== void 0 ? _d : theme.getY();
            if (isNumber(y)) {
                position.y = y;
            }
            else {
                position.y = 0;
                scalarSet.y = DScalarFunctions.position(y);
            }
            // Width
            var width = (_e = options === null || options === void 0 ? void 0 : options.width) !== null && _e !== void 0 ? _e : theme.getWidth();
            if (!_this._auto.width.from(width)) {
                if (isNumber(width)) {
                    _this._width = width;
                }
                else {
                    _this._width = 100;
                    scalarSet.width = DScalarFunctions.size(width);
                }
            }
            else {
                _this._width = 100;
            }
            // Height
            var height = (_f = options === null || options === void 0 ? void 0 : options.height) !== null && _f !== void 0 ? _f : theme.getHeight();
            if (!_this._auto.height.from(height)) {
                if (isNumber(height)) {
                    _this._height = height;
                }
                else {
                    _this._height = 100;
                    scalarSet.height = DScalarFunctions.size(height);
                }
            }
            else {
                _this._height = 100;
            }
            // Visibility
            if (options != null) {
                var visible = options.visible;
                if (visible != null) {
                    _this.visible = visible;
                }
            }
            // Renderability
            if (options != null) {
                var renderable = options.renderable;
                if (renderable != null) {
                    _this.renderable = renderable;
                }
            }
            // State
            _this._state = new DBaseStateSetImplObservable(function (newState, oldState) {
                _this.onStateChange(newState, oldState);
            });
            // Interactive
            var interactive = toEnum((_g = options === null || options === void 0 ? void 0 : options.interactive) !== null && _g !== void 0 ? _g : theme.getInteractive(), DBaseInteractive);
            _this.interactive = !!(interactive & DBaseInteractive.SELF);
            _this.interactiveChildren = !!(interactive & DBaseInteractive.CHILDREN);
            // Events
            if (options != null) {
                var on = options.on;
                if (on != null) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            // Title
            _this._title = (_h = options === null || options === void 0 ? void 0 : options.title) !== null && _h !== void 0 ? _h : theme.getTitle();
            // Weight
            _this._weight = (_j = options === null || options === void 0 ? void 0 : options.weight) !== null && _j !== void 0 ? _j : theme.getWeight();
            // Reflowable
            _this.initReflowable();
            // Shadow
            _this._onShadowUpdateBound = function () {
                DApplications.update(_this);
            };
            var shadow;
            if (options != null) {
                shadow = options.shadow;
            }
            if (shadow === undefined) {
                shadow = theme.getShadow();
            }
            if (shadow) {
                if (isString(shadow)) {
                    switch (shadow) {
                        case "WEAK":
                            _this.shadow = theme.newShadowWeak();
                            break;
                        case "DEFAULT":
                            _this.shadow = theme.newShadow();
                            break;
                    }
                }
                else {
                    _this.shadow = shadow;
                }
            }
            // Event handlers
            _this.on(UtilPointerEvent.over, function (e) {
                _this.onOver(e);
            });
            _this.on(UtilPointerEvent.out, function (e) {
                _this.onOut(e);
            });
            _this.on(UtilPointerEvent.down, function (e) {
                _this.onDown(e);
            });
            _this.on(UtilPointerEvent.up, function (e) {
                _this.onUp(e);
            });
            // Children change detection
            _this.on("added", function () {
                _this.toParentResized();
                if (_this.isDirty() || _this.hasDirty()) {
                    _this.toParentHasDirty();
                }
                if (_this._isHierarchyDirty) {
                    _this.toParentHierarchyDirty();
                }
                var newParent = _this.parent;
                if (newParent instanceof DBase) {
                    _this.state.parent = newParent.state;
                }
                DApplications.update(_this);
            });
            _this.on("removed", function () {
                _this.blur(true);
                _this.state.parent = null;
                DApplications.update(_this);
            });
            // Shortcut
            var shortcuts = toShortcuts(options);
            _this._shortcuts = shortcuts;
            if (shortcuts != null) {
                var onShortcutBound = function (e) {
                    _this.onShortcut(e);
                };
                for (var i = 0, imax = shortcuts.length; i < imax; ++i) {
                    UtilKeyboardEvent.on(_this, shortcuts[i], onShortcutBound);
                }
            }
            // Other initialization
            _this.init(options);
            // State Override
            theme.newState(_this._state);
            if (options != null) {
                var state = options.state;
                if (state != null) {
                    var s = _this._state;
                    if (isString(state)) {
                        s.add(state);
                    }
                    else if (isArray(state)) {
                        s.addAll(state);
                    }
                    else {
                        // Values
                        var values = state.values;
                        if (values != null) {
                            if (isString(values)) {
                                s.add(values);
                            }
                            else {
                                s.addAll(values);
                            }
                        }
                        // Blinker
                        var blinkers = state.blinkers;
                        if (blinkers != null) {
                            var b = s.blinker;
                            for (var i = 0, imax = blinkers.length; i < imax; ++i) {
                                var blinker = blinkers[i];
                                b.add(blinker.state, blinker.interval);
                            }
                        }
                        // Ticker
                        var tickers = state.tickers;
                        if (tickers != null) {
                            var t = s.ticker;
                            for (var i = 0, imax = tickers.length; i < imax; ++i) {
                                var ticker = tickers[i];
                                t.add(ticker.state, ticker.interval);
                            }
                        }
                    }
                }
            }
            // Parent
            if (options != null) {
                var parent_1 = options.parent;
                if (parent_1 != null) {
                    parent_1.addChild(_this);
                }
            }
            // Children
            if (options != null) {
                var children = options.children;
                if (children != null) {
                    for (var i = 0, imax = children.length; i < imax; ++i) {
                        var child = children[i];
                        if (child != null) {
                            _this.addChild(child);
                        }
                    }
                }
            }
            // Cursor
            var cursor;
            if (options != null) {
                cursor = options.cursor;
                _this._cursor = cursor;
            }
            _this.cursor = _this.toCursor(cursor, _this._state);
            // Done
            _this.emit("init", _this);
            return _this;
        }
        DBase.prototype.toCursor = function (cursor, state) {
            if (cursor) {
                if (isFunction(cursor)) {
                    var result = cursor(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else if (cursor !== undefined) {
                    return cursor;
                }
            }
            return this.theme.getCursor(state);
        };
        Object.defineProperty(DBase.prototype, "snippet", {
            get: function () {
                return this._snippet;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "reflowable", {
            get: function () {
                return this._reflowable;
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.initReflowable = function () {
            new DBaseReflowableImpl(this);
        };
        DBase.prototype.onChildrenChange = function () {
            this.toHierarchyDirty();
            _super.prototype.onChildrenChange.call(this);
        };
        DBase.prototype.onShortcut = function (e) {
            this.emit("shortcut", e, this);
        };
        DBase.prototype.init = function (options) {
            // OTHER INITIALIZATIONS BEFORE `parent.addChild( this )`
        };
        Object.defineProperty(DBase.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.onMove = function (newX, newY, oldX, oldY) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentMove(newX, newY, oldX, oldY);
                }
            }
            DApplications.update(this);
            this.emit("move", newX, newY, oldX, oldY, this);
        };
        DBase.prototype.resize = function (width, height) {
            var oldWidth = this._width;
            var oldHeight = this._height;
            var newWidth = width != null ? width : oldWidth;
            var newHeight = height != null ? height : oldHeight;
            var isWidthChanged = oldWidth !== newWidth;
            var isHeightChanged = oldHeight !== newHeight;
            if (isWidthChanged) {
                this._width = newWidth;
            }
            if (isHeightChanged) {
                this._height = newHeight;
            }
            var isChanged = isWidthChanged || isHeightChanged;
            if (isChanged) {
                this.onResize(newWidth, newHeight, oldWidth, oldHeight);
            }
            if (isWidthChanged) {
                var scalarSet = this._scalarSet;
                if (scalarSet.x != null) {
                    var position = this._position;
                    var parent_2 = this.getParentOfSize();
                    if (parent_2) {
                        this._position.x = scalarSet.x(parent_2.width, newWidth, parent_2.padding.getLeft(), position.x);
                    }
                }
            }
            if (isHeightChanged) {
                var scalarSet = this._scalarSet;
                if (scalarSet.y != null) {
                    var position = this._position;
                    var parent_3 = this.getParentOfSize();
                    if (parent_3) {
                        this._position.y = scalarSet.y(parent_3.height, newHeight, parent_3.padding.getTop(), position.y);
                    }
                }
            }
            return isChanged;
        };
        DBase.prototype.getClearType = function () {
            return this._clearType;
        };
        DBase.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            this.toDirty();
            this.toHierarchyDirty();
            var padding = this._padding;
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(newWidth, newHeight, padding);
                }
            }
            DApplications.update(this);
            this.emit("resize", newWidth, newHeight, oldWidth, oldHeight, this);
        };
        DBase.prototype.onScale = function (newX, newY, oldX, oldY) {
            DApplications.update(this);
            this.emit("scale", newX, newY, oldX, oldY, this);
        };
        DBase.prototype.onSkew = function (newX, newY, oldX, oldY) {
            DApplications.update(this);
            this.emit("skew", newX, newY, oldX, oldY, this);
        };
        Object.defineProperty(DBase.prototype, "type", {
            get: function () {
                return this.getType();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "x", {
            // @ts-ignore
            get: function () {
                return this._position.x;
            },
            set: function (x) {
                this.setX(x);
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getX = function () {
            var scalarSet = this._scalarSet;
            if (scalarSet.x != null) {
                return scalarSet.x;
            }
            else {
                return this._position.x;
            }
        };
        DBase.prototype.setX = function (x) {
            var scalarSet = this._scalarSet;
            if (isNumber(x)) {
                var position = this._position;
                if (position.x !== x) {
                    scalarSet.x = undefined;
                    position.x = x;
                }
                else {
                    if (scalarSet.x !== undefined) {
                        scalarSet.x = undefined;
                        this.toParentResized();
                    }
                }
            }
            else {
                var scalar = DScalarFunctions.position(x);
                if (scalarSet.x !== scalar) {
                    scalarSet.x = scalar;
                    this.toParentResized();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "y", {
            // @ts-ignore
            get: function () {
                return this._position.y;
            },
            set: function (y) {
                this.setY(y);
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getY = function () {
            var scalarSet = this._scalarSet;
            if (scalarSet.y != null) {
                return scalarSet.y;
            }
            else {
                return this._position.y;
            }
        };
        DBase.prototype.setY = function (y) {
            var scalarSet = this._scalarSet;
            if (isNumber(y)) {
                var position = this._position;
                if (position.y !== y) {
                    scalarSet.y = undefined;
                    position.y = y;
                }
                else {
                    if (scalarSet.y !== undefined) {
                        scalarSet.y = undefined;
                        this.toParentResized();
                    }
                }
            }
            else {
                var scalar = DScalarFunctions.position(y);
                if (scalarSet.y !== scalar) {
                    scalarSet.y = scalar;
                    this.toParentResized();
                }
            }
        };
        Object.defineProperty(DBase.prototype, "width", {
            // @ts-ignore
            get: function () {
                return this._width;
            },
            set: function (width) {
                this.setWidth(width);
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getWidth = function () {
            return this._auto.width.toCoordinate(this._scalarSet.width || this._width);
        };
        DBase.prototype.setWidth = function (width) {
            var auto = this._auto.width;
            var isOn = auto.isOn;
            var isAuto = auto.from(width);
            if (auto.isOn !== isOn) {
                this.toHierarchyDirty();
                DApplications.update(this);
            }
            if (!isAuto) {
                var scalarSet = this._scalarSet;
                if (isNumber(width)) {
                    var oldWidth = this._width;
                    if (oldWidth !== width) {
                        scalarSet.width = undefined;
                        this._width = width;
                        var height = this._height;
                        this.onResize(width, height, oldWidth, height);
                        if (scalarSet.x != null) {
                            var position = this._position;
                            var parent_4 = this.getParentOfSize();
                            if (parent_4) {
                                position.x = scalarSet.x(parent_4.width, width, parent_4.padding.getLeft(), position.x);
                            }
                        }
                    }
                    else {
                        if (scalarSet.width !== undefined) {
                            scalarSet.width = undefined;
                            this.toParentResized();
                        }
                    }
                }
                else {
                    var scalar = DScalarFunctions.size(width);
                    if (scalarSet.width !== scalar) {
                        scalarSet.width = scalar;
                        this.toParentResized();
                    }
                }
            }
        };
        Object.defineProperty(DBase.prototype, "height", {
            // @ts-ignore
            get: function () {
                return this._height;
            },
            set: function (height) {
                this.setHeight(height);
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.getHeight = function () {
            return this._auto.height.toCoordinate(this._scalarSet.height || this._height);
        };
        DBase.prototype.setHeight = function (height) {
            var auto = this._auto.height;
            var isOn = auto.isOn;
            var isAuto = auto.from(height);
            if (auto.isOn !== isOn) {
                this.toHierarchyDirty();
                DApplications.update(this);
            }
            if (!isAuto) {
                var scalarSet = this._scalarSet;
                if (isNumber(height)) {
                    var oldHeight = this._height;
                    if (oldHeight !== height) {
                        scalarSet.height = undefined;
                        this._height = height;
                        var width = this._width;
                        this.onResize(width, height, width, oldHeight);
                        if (scalarSet.y != null) {
                            var position = this._position;
                            var parent_5 = this.getParentOfSize();
                            if (parent_5) {
                                position.y = scalarSet.y(parent_5.height, height, parent_5.padding.getTop(), position.y);
                            }
                        }
                    }
                    else {
                        if (scalarSet.height !== undefined) {
                            scalarSet.height = undefined;
                            this.toParentResized();
                        }
                    }
                }
                else {
                    var scalar = DScalarFunctions.size(height);
                    if (scalarSet.height !== scalar) {
                        scalarSet.height = scalar;
                        this.toParentResized();
                    }
                }
            }
        };
        Object.defineProperty(DBase.prototype, "position", {
            // @ts-ignore
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "scale", {
            // @ts-ignore
            get: function () {
                return this._scale;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "skew", {
            // @ts-ignore
            get: function () {
                return this._skew;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "corner", {
            get: function () {
                return this._corner;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "background", {
            get: function () {
                return this._background;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "border", {
            get: function () {
                return this._border;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "outline", {
            get: function () {
                return this._outline;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "unsafe", {
            get: function () {
                return this.transform;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "title", {
            get: function () {
                return this._title;
            },
            set: function (title) {
                if (this._title !== title) {
                    this._title = title;
                    if (this.state.isHovered) {
                        this.applyTitle();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.applyTitle = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.view.title = this._title;
            }
        };
        DBase.prototype.show = function () {
            if (!this.visible) {
                this.visible = true;
                this.toParentHierarchyDirty();
                DApplications.update(this);
            }
            return this;
        };
        DBase.prototype.isShown = function () {
            return this.visible;
        };
        DBase.prototype.hide = function () {
            if (this.visible) {
                this.visible = false;
                this.toParentHierarchyDirty();
                this.blur(true);
                DApplications.update(this);
            }
            return this;
        };
        DBase.prototype.isHidden = function () {
            return !this.visible;
        };
        DBase.prototype.toDirty = function () {
            if (!this._isDirty) {
                this._isDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toHasDirty = function () {
            if (!this._hasDirty) {
                this._hasDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toParentHasDirty = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.toHasDirty();
            }
        };
        DBase.prototype.toHierarchyDirty = function () {
            if (!this._isHierarchyDirty) {
                this._isHierarchyDirty = true;
                this.onHierarchyDirty();
                this.toParentHierarchyDirty();
                return true;
            }
            return false;
        };
        DBase.prototype.toParentHierarchyDirty = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.toHierarchyDirty();
            }
        };
        DBase.prototype.isHierarchyDirty = function () {
            return this._isHierarchyDirty;
        };
        DBase.prototype.onHierarchyDirty = function () {
            // DO NOTHING
        };
        DBase.prototype.isDirty = function () {
            return this._isDirty;
        };
        DBase.prototype.hasDirty = function () {
            return this._hasDirty;
        };
        DBase.prototype.setFocused = function (isFocused) {
            if (this.state.isFocused !== isFocused) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().set(this, isFocused);
                }
            }
            return this;
        };
        DBase.prototype.focus = function () {
            return this.setFocused(true);
        };
        DBase.prototype.blur = function (recursively) {
            if (recursively) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var focusController = layer.getFocusController();
                    var focused = focusController.get();
                    if (focused instanceof DBase) {
                        var current = focused;
                        while (current) {
                            if (current === this) {
                                focused.setFocused(false);
                                break;
                            }
                            current = current.parent;
                        }
                    }
                }
            }
            else {
                this.setFocused(false);
            }
            return this;
        };
        DBase.prototype.onStateChange = function (newState, oldState) {
            var _this = this;
            this.toDirty();
            DApplications.update(this);
            this.emit("statechange", newState, oldState, this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.state.onParentChange(newState, oldState);
                }
            }
            if (newState.isFocused) {
                if (!oldState.isFocused) {
                    this.onFocus();
                }
                if (newState.inDisabled && !oldState.inDisabled) {
                    setTimeout(function () {
                        _this.blur();
                    }, 0);
                }
            }
            else if (oldState.isFocused) {
                this.onBlur();
            }
            this.cursor = this.toCursor(this._cursor, newState);
        };
        DBase.prototype.onChildFocus = function (focused) {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocus(focused);
            }
        };
        DBase.prototype.onFocus = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocus(this);
            }
        };
        DBase.prototype.onChildBlur = function (blured) {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildBlur(blured);
            }
        };
        DBase.prototype.onBlur = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildBlur(this);
            }
        };
        Object.defineProperty(DBase.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "options", {
            get: function () {
                return this._options;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DBase.prototype, "theme", {
            get: function () {
                return this._theme;
            },
            set: function (theme) {
                var result = this._theme;
                if (result !== theme) {
                    this._theme = theme;
                    this._padding.setTheme(theme);
                    this._background.setTheme(theme);
                    this._border.setTheme(theme);
                    this._outline.setTheme(theme);
                    this._corner.setTheme(theme);
                    this.toDirty();
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.reflow = function () {
            var isDirty = this._isDirty;
            if (isDirty) {
                this.onReflow();
                this._isDirty = false;
            }
            var hasDirty = this._hasDirty;
            var isHierarchyDirty = this._isHierarchyDirty;
            if (hasDirty || isHierarchyDirty) {
                this._hasDirty = false;
                this._isHierarchyDirty = false;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                    }
                }
            }
            if (isDirty || hasDirty || isHierarchyDirty) {
                this.onRefit();
            }
        };
        DBase.prototype.onRefit = function () {
            var auto = this._auto;
            var isWidthAuto = auto.width.isOn;
            var isHeightAuto = auto.height.isOn;
            if (isWidthAuto && isHeightAuto) {
                var width = 0;
                var height = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible) {
                        if (this.hasRefitableWidth(child)) {
                            width = Math.max(width, child.x + child.width);
                        }
                        if (this.hasRefitableHeight(child)) {
                            height = Math.max(height, child.y + child.height);
                        }
                    }
                }
                var padding = this.padding;
                this.resize(width + padding.getRight(), height + padding.getBottom());
            }
            else if (isWidthAuto) {
                var width = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible && this.hasRefitableWidth(child)) {
                        width = Math.max(width, child.x + child.width);
                    }
                }
                this.resize(width + this.padding.getRight(), undefined);
            }
            else if (isHeightAuto) {
                var height = 0;
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible && this.hasRefitableHeight(child)) {
                        height = Math.max(height, child.y + child.height);
                    }
                }
                this.resize(undefined, height + this.padding.getBottom());
            }
        };
        DBase.prototype.isRefitable = function (target) {
            return target instanceof DBase;
        };
        DBase.prototype.hasRefitableHeight = function (target) {
            return (this.isRefitable(target) && !(target instanceof DBase && isFunction(target.getHeight())));
        };
        DBase.prototype.hasRefitableWidth = function (target) {
            return (this.isRefitable(target) && !(target instanceof DBase && isFunction(target.getWidth())));
        };
        DBase.prototype.onReflow = function () {
            this._reflowable.onReflow(this, this._width, this._height);
        };
        Object.defineProperty(DBase.prototype, "shadow", {
            get: function () {
                return this._shadow;
            },
            set: function (shadow) {
                var previous = this._shadow;
                if (previous !== shadow) {
                    var reflowable = this._reflowable;
                    var snippet = this._snippet;
                    var onShadowUpdateBound = this._onShadowUpdateBound;
                    if (previous != null) {
                        previous.off("update", onShadowUpdateBound);
                        reflowable.remove(previous);
                        snippet.remove(previous, true);
                    }
                    this._shadow = shadow;
                    if (shadow != null) {
                        shadow.on("update", onShadowUpdateBound);
                        reflowable.add(shadow);
                        snippet.addAt(shadow, true, 0);
                    }
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DBase.prototype.toParentResized = function () {
            var parent = this.getParentOfSize();
            if (parent) {
                this.onParentResize(parent.width, parent.height, parent.padding);
            }
        };
        DBase.prototype.getParentOfSize = function () {
            var parent = this.parent;
            if (parent instanceof DBase) {
                return parent;
            }
            else {
                return DApplications.getLayer(this);
            }
        };
        /**
         * Called when a parent resized.
         *
         * @param parentWidth a parent's local width
         * @param parentHeight a parent's local height
         */
        DBase.prototype.onParentResize = function (parentWidth, parentHeight, parentPadding) {
            var scalarSet = this._scalarSet;
            var position = this.transform.position;
            var x = position.x;
            var y = position.y;
            var width = this._width;
            var height = this._height;
            // Width & height
            var paddingWidth = parentPadding.getLeft() + parentPadding.getRight();
            var paddingHeight = parentPadding.getTop() + parentPadding.getBottom();
            var newWidth = scalarSet.width != null
                ? scalarSet.width(parentWidth, width, paddingWidth, width)
                : width;
            var newHeight = scalarSet.height != null
                ? scalarSet.height(parentHeight, height, paddingHeight, height)
                : height;
            this.resize(newWidth, newHeight);
            // X & Y
            var newX = scalarSet.x != null
                ? scalarSet.x(parentWidth, this._width, parentPadding.getLeft(), x)
                : x;
            var newY = scalarSet.y != null
                ? scalarSet.y(parentHeight, this._height, parentPadding.getTop(), y)
                : y;
            this.position.set(newX, newY);
        };
        /**
         * Called when a parent moved.
         *
         * @param newX a new parent's local x position
         * @param newY a new parent's local y position
         * @param oldX an old parent's local x position
         * @param oldY an old parent's local y position
         */
        DBase.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            // DO NOTHING
        };
        // Wheel
        DBase.prototype.onWheel = function (e, deltas, global) {
            this.emit("wheel", e, deltas, global, this);
            return false;
        };
        // Keydown
        DBase.prototype.onKeyDown = function (e) {
            this.emit("keydown", e, this);
            return false;
        };
        DBase.prototype.onKeyUp = function (e) {
            this.emit("keyup", e, this);
            return false;
        };
        // Down
        DBase.prototype.isEventTarget = function (e) {
            var target = e.target;
            if (target === this) {
                return true;
            }
            else if (target != null && !(target instanceof DBase && target.interactive)) {
                var parent_6 = target.parent;
                while (parent_6 != null && !(parent_6 instanceof DBase && parent_6.interactive)) {
                    parent_6 = parent_6.parent;
                }
                return parent_6 === this;
            }
            return false;
        };
        DBase.prototype.onDown = function (e) {
            if (this.isEventTarget(e)) {
                this.onDownThis(e);
            }
            this.emit("down", e, this);
        };
        DBase.prototype.onDownThis = function (e) {
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                var lastDownPoint = this._lastDownPoint || new pixi_js.Point();
                this._lastDownPoint = lastDownPoint;
                lastDownPoint.copyFrom(e.data.global);
            }
            else {
                this.focusOnClosest();
            }
        };
        DBase.prototype.onUp = function (e) {
            if (this.isEventTarget(e)) {
                this.onUpThis(e);
            }
            this.emit("up", e, this);
        };
        DBase.prototype.onUpThis = function (e) {
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                var lastDownPoint = this._lastDownPoint;
                if (lastDownPoint) {
                    var global_1 = e.data.global;
                    var dx = Math.abs(global_1.x - lastDownPoint.x);
                    var dy = Math.abs(global_1.y - lastDownPoint.y);
                    var threshold = UtilPointerEvent.CLICK_DISTANCE_THRESHOLD;
                    if (dx < threshold && dy < threshold) {
                        this.focusOnClosest();
                    }
                }
            }
        };
        DBase.prototype.focusOnClosest = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var focusController = layer.getFocusController();
                focusController.focus(focusController.findParent(this));
            }
        };
        // Over
        DBase.prototype.onOver = function (e) {
            // Update the hover state
            this.state.isHovered = true;
            // Update the title
            if (e.target === this) {
                this.applyTitle();
            }
            // Event
            this.emit("over", e, this);
        };
        // Out
        DBase.prototype.onOut = function (e) {
            // Update the hover state
            this.state.isHovered = false;
            // Event
            this.emit("out", e, this);
        };
        // Double click
        DBase.prototype.onDblClick = function (e, interactionManager) {
            this.emit("dblclick", e, interactionManager, this);
            return false;
        };
        //
        DBase.prototype.render = function (renderer) {
            if (this.visible && 0 < this.worldAlpha && this.renderable) {
                var snippet = this._snippet;
                snippet.render(renderer, true);
                _super.prototype.render.call(this, renderer);
                snippet.render(renderer, false);
            }
        };
        //
        DBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DBase.prototype.getType = function () {
            return "DBase";
        };
        //
        DBase.prototype._calculateBounds = function () {
            var worldTransform = this.transform.worldTransform;
            var bounds = this._bounds;
            var work = DBase.WORK_CONTAINS_POINT;
            work.set(0, 0);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(this._width, this._height);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            _super.prototype._calculateBounds.call(this);
        };
        DBase.prototype.containsPoint = function (point) {
            return (this.containsGlobalPoint(point) ||
                this.containsLocalPoint(this.worldTransform.applyInverse(point, DBase.WORK_CONTAINS_POINT)));
        };
        DBase.prototype.containsGlobalPoint = function (point) {
            return false;
        };
        DBase.prototype.containsLocalPoint = function (point) {
            var x = point.x;
            var y = point.y;
            var w = this._width;
            var h = this._height;
            return 0 <= x && x <= w && 0 <= y && y <= h;
        };
        /**
         * Returns a clipping rect.
         *
         * @param result a clipping rect
         */
        DBase.prototype.getClippingRect = function (target, result) {
            result.x = 0;
            result.y = 0;
            result.width = this._width;
            result.height = this._height;
        };
        DBase.prototype.destroy = function () {
            // Layout
            var scalarSet = this._scalarSet;
            scalarSet.x = null;
            scalarSet.y = null;
            scalarSet.width = null;
            scalarSet.height = null;
            // Shadow
            var shadow = this._shadow;
            if (shadow) {
                this._shadow = null;
                shadow.destroy();
            }
            // Children
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            //
            _super.prototype.destroy.call(this);
        };
        DBase.WORK_CONTAINS_POINT = new pixi_js.Point();
        return DBase;
    }(pixi_js.Container));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOverflowMask = /** @class */ (function (_super) {
        __extends(DBaseOverflowMask, _super);
        function DBaseOverflowMask(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            return _this;
        }
        DBaseOverflowMask.prototype.render = function (renderer) {
            this.updateTransform();
            _super.prototype.render.call(this, renderer);
        };
        DBaseOverflowMask.prototype.onReflow = function (base, width, height) {
            var x = 0;
            var y = 0;
            var corner = base.corner;
            var cornerRadius = Math.max(0, corner.getRadius() - 0.5);
            var cornerMask = corner.getMask();
            var tl = cornerMask & DCornerMask.TOP_LEFT ? 0 : cornerRadius;
            var tr = cornerMask & DCornerMask.TOP_RIGHT ? 0 : cornerRadius;
            var bl = cornerMask & DCornerMask.BOTTOM_LEFT ? 0 : cornerRadius;
            var br = cornerMask & DCornerMask.BOTTOM_RIGHT ? 0 : cornerRadius;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.lineStyle(0, 0, 0, 0, false);
            if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
                this.drawRect(x, y, width, height);
            }
            else {
                this.moveTo(x + tl, y);
                if (0 < tr) {
                    this.arcTo(x + width, y, x + width, y + height, tr);
                }
                else {
                    this.lineTo(x + width, y);
                }
                if (0 < br) {
                    this.arcTo(x + width, y + height, x, y + height, br);
                }
                else {
                    this.lineTo(x + width, y + height);
                }
                if (0 < bl) {
                    this.arcTo(x, y + height, x, y, bl);
                }
                else {
                    this.lineTo(x, y + height);
                }
                if (0 < tl) {
                    this.arcTo(x, y, x + width, y, tl);
                }
                else {
                    this.lineTo(x, y);
                }
            }
            this.endFill();
        };
        return DBaseOverflowMask;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var CTRL = 1;
    var SHIFT = 2;
    var ALT = 4;
    var AND = 8;
    var OR = 16;
    var UtilGestureModifier = {
        NONE: 0,
        CTRL: CTRL,
        SHIFT: SHIFT,
        ALT: ALT,
        AND: AND,
        OR: OR,
        NOT_NONE: CTRL | SHIFT | ALT | OR
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureModifiers = /** @class */ (function () {
        function UtilGestureModifiers() {
        }
        UtilGestureModifiers.from = function (e) {
            var oe = "data" in e ? e.data.originalEvent : e;
            return ((oe.ctrlKey ? UtilGestureModifier.CTRL : UtilGestureModifier.NONE) |
                (oe.altKey ? UtilGestureModifier.ALT : UtilGestureModifier.NONE) |
                (oe.shiftKey ? UtilGestureModifier.SHIFT : UtilGestureModifier.NONE));
        };
        UtilGestureModifiers.match = function (e, modifier) {
            if (modifier & UtilGestureModifier.OR) {
                return !!(UtilGestureModifiers.from(e) & modifier);
            }
            else {
                return UtilGestureModifiers.from(e) === modifier;
            }
        };
        return UtilGestureModifiers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureMode = {
        OFF: 0,
        ON: 1,
        TOUCH: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureData = /** @class */ (function () {
        function UtilGestureData() {
            this.pointers = new Map();
            this.center = new pixi_js.Point();
            this.scale = 0;
            this.time = 0;
        }
        UtilGestureData.prototype.start = function (e) {
            var oe = e.data.originalEvent;
            if ("pointerId" in oe) {
                this.pointers.set(oe.pointerId, oe);
            }
            this.doUpdate(e);
        };
        UtilGestureData.prototype.isUpdatable = function (e) {
            var oe = e.data.originalEvent;
            if ("pointerId" in oe) {
                return this.pointers.has(oe.pointerId);
            }
            return true;
        };
        UtilGestureData.prototype.update = function (e) {
            var oe = e.data.originalEvent;
            if ("pointerId" in oe) {
                this.pointers.set(oe.pointerId, oe);
            }
            this.doUpdate(e);
        };
        UtilGestureData.prototype.end = function (e) {
            var result = true;
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                result = oe.touches.length <= 0;
            }
            else if ("pointerId" in oe) {
                var pointers = this.pointers;
                pointers.delete(oe.pointerId);
                result = pointers.size <= 0;
            }
            this.doUpdate(e);
            return result;
        };
        UtilGestureData.prototype.bind = function (e) {
            var interactionManager = this.interactionManager;
            if (interactionManager) {
                var onMove = this.onMove;
                if (onMove) {
                    interactionManager.on(UtilPointerEvent.move, onMove);
                }
                var onEnd = this.onEnd;
                if (onEnd) {
                    interactionManager.on(UtilPointerEvent.up, onEnd);
                    interactionManager.on(UtilPointerEvent.upoutside, onEnd);
                    interactionManager.on(UtilPointerEvent.cancel, onEnd);
                }
            }
        };
        UtilGestureData.prototype.unbind = function () {
            var interactionManager = this.interactionManager;
            if (interactionManager) {
                var onMove = this.onMove;
                if (onMove) {
                    interactionManager.off(UtilPointerEvent.move, onMove);
                }
                var onEnd = this.onEnd;
                if (onEnd) {
                    interactionManager.off(UtilPointerEvent.up, onEnd);
                    interactionManager.off(UtilPointerEvent.upoutside, onEnd);
                    interactionManager.off(UtilPointerEvent.cancel, onEnd);
                }
            }
        };
        UtilGestureData.prototype.doUpdate = function (e) {
            var interactionManager = this.interactionManager;
            var center = this.center;
            var oe = e.data.originalEvent;
            this.scale = 0;
            this.time = oe.timeStamp;
            if ("touches" in oe) {
                var touches = oe.touches;
                var touchesLength = touches.length;
                if (0 < touchesLength) {
                    // Update the center
                    var centerX = 0;
                    var centerY = 0;
                    for (var i = 0, imax = touches.length; i < imax; ++i) {
                        var touch = touches[i];
                        centerX += touch.clientX;
                        centerY += touch.clientY;
                    }
                    centerX /= touchesLength;
                    centerY /= touchesLength;
                    if (interactionManager) {
                        interactionManager.mapPositionToPoint(center, centerX, centerY);
                    }
                    else {
                        center.set(centerX, centerY);
                    }
                    if (1 < touchesLength) {
                        // Calculate the maximum distance from the center
                        var squareDistance = 0;
                        for (var i = 1, imax = touches.length; i < imax; ++i) {
                            var touch = touches[i];
                            var dx = touch.clientX - centerX;
                            var dy = touch.clientY - centerY;
                            squareDistance = Math.max(squareDistance, dx * dx + dy * dy);
                        }
                        this.scale = Math.sqrt(squareDistance);
                    }
                }
            }
            else if ("pointerId" in oe) {
                var pointers = this.pointers;
                var pointersSize = pointers.size;
                if (0 < pointersSize) {
                    // Update the center
                    var centerX_1 = 0;
                    var centerY_1 = 0;
                    pointers.forEach(function (pointer) {
                        centerX_1 += pointer.clientX;
                        centerY_1 += pointer.clientY;
                    });
                    centerX_1 /= pointersSize;
                    centerY_1 /= pointersSize;
                    if (interactionManager) {
                        interactionManager.mapPositionToPoint(center, centerX_1, centerY_1);
                    }
                    else {
                        center.set(centerX_1, centerY_1);
                    }
                    if (1 < pointersSize) {
                        // Calculate the maximum distance from the center
                        var squareDistance_1 = 0;
                        pointers.forEach(function (pointer) {
                            var dx = pointer.clientX - centerX_1;
                            var dy = pointer.clientY - centerY_1;
                            squareDistance_1 = Math.max(squareDistance_1, dx * dx + dy * dy);
                        });
                        this.scale = Math.sqrt(squareDistance_1);
                    }
                }
            }
            else {
                center.copyFrom(e.data.global);
            }
        };
        return UtilGestureData;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationTimings = /** @class */ (function () {
        function DAnimationTimings() {
        }
        DAnimationTimings.LINEAR = function (t) {
            return t;
        };
        DAnimationTimings.ELASTIC = function (t) {
            return t * (3 * (1 - t) * (1 - t) + t * (3 * (1 - t) + t));
        };
        DAnimationTimings.QUAD_IN_OUT = function (t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        };
        return DAnimationTimings;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationBase = /** @class */ (function (_super) {
        __extends(DAnimationBase, _super);
        function DAnimationBase(options) {
            var _this = this;
            var _a, _b, _c;
            _this = _super.call(this) || this;
            _this._id = null;
            _this._target = (_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : null;
            _this._startTime = 0;
            _this._duration = (_b = options === null || options === void 0 ? void 0 : options.duration) !== null && _b !== void 0 ? _b : 200;
            _this._durationInverse = 1 / Math.max(1, _this._duration);
            _this._reverse = false;
            _this._onTime = options === null || options === void 0 ? void 0 : options.onTime;
            _this._onTimeBaseBound = function () {
                _this.onTimeBase();
            };
            _this._onStart = options === null || options === void 0 ? void 0 : options.onStart;
            _this._onEnd = options === null || options === void 0 ? void 0 : options.onEnd;
            _this._timing = (_c = options === null || options === void 0 ? void 0 : options.timing) !== null && _c !== void 0 ? _c : DAnimationTimings.ELASTIC;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DAnimationBase.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DAnimationBase.prototype, "duration", {
            get: function () {
                return this._duration;
            },
            set: function (duration) {
                this._duration = duration;
                this._durationInverse = 1 / Math.max(1, duration);
            },
            enumerable: false,
            configurable: true
        });
        DAnimationBase.prototype.start = function (reverse) {
            if (reverse === void 0) { reverse = false; }
            this.stop();
            this._startTime = Date.now();
            this._reverse = reverse;
            this._id = window.setTimeout(this._onTimeBaseBound, 0);
            // onStart
            this.onStart(reverse);
            // onTime
            var duration = this._duration;
            var time = this.toTime(reverse ? duration : 0);
            this.onTime(time, reverse, 0);
        };
        DAnimationBase.prototype.onStart = function (isReverse) {
            var onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        };
        DAnimationBase.prototype.onTime = function (time, isReverse, elapsedTime) {
            var onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        };
        DAnimationBase.prototype.onEnd = function (isReverse) {
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        };
        DAnimationBase.prototype.isStarted = function () {
            return this._id != null;
        };
        DAnimationBase.prototype.isReverse = function () {
            return this._reverse;
        };
        DAnimationBase.prototype.onTimeBase = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                var elapsedTime = Date.now() - this._startTime;
                var duration = this._duration;
                var reverse = this._reverse;
                if (elapsedTime < duration) {
                    this._id = window.setTimeout(this._onTimeBaseBound, 0);
                    // OnTime
                    var time = this.toTime(reverse ? duration - elapsedTime : elapsedTime);
                    this.onTime(time, reverse, elapsedTime);
                }
                else {
                    // OnTime
                    var time = this.toTime(reverse ? 0 : duration);
                    this.onTime(time, reverse, elapsedTime);
                    // OnEnd
                    this.onEnd(reverse);
                }
            }
        };
        DAnimationBase.prototype.toTime = function (elapsedTime) {
            return this._timing(elapsedTime * this._durationInverse, this);
        };
        DAnimationBase.prototype.stop = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
            }
        };
        DAnimationBase.prototype.end = function () {
            var id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
                // OnTime
                var reverse = this._reverse;
                var elapsedTime = Date.now() - this._startTime;
                var duration = this._duration;
                var time = this.toTime(reverse ? 0 : duration);
                this.onTime(time, reverse, elapsedTime);
                // OnEnd
                this.onEnd(reverse);
            }
        };
        return DAnimationBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureEasingHistory = /** @class */ (function () {
        function UtilGestureEasingHistory(dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        }
        UtilGestureEasingHistory.prototype.set = function (dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        };
        return UtilGestureEasingHistory;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGestureEasing = /** @class */ (function () {
        function UtilGestureEasing(onMove, onEnd, options) {
            var _this = this;
            var _a;
            this._histories = [];
            this._historiesSorted = [];
            this._historyBegin = 0;
            this._historyEnd = -1;
            this._dx = 0;
            this._dy = 0;
            this._ds = 0;
            this._dt = 0;
            this._dtw = 0;
            this._t = 0;
            this._animation = new DAnimationBase({
                onTime: function (t) {
                    _this.onEase(t);
                },
                onEnd: function () {
                    _this.onEaseEnd();
                },
                timing: DAnimationTimings.LINEAR,
                duration: 333 * ((_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : 1)
            });
            this._onMove = onMove;
            this._onEnd = onEnd;
        }
        UtilGestureEasing.prototype.onStart = function () {
            // History
            var histories = this._histories;
            for (var i = histories.length, imax = UtilGestureEasing.HISTORY_CAPACITY; i < imax; ++i) {
                histories.push(new UtilGestureEasingHistory(0, 0, 1, 0));
            }
            this._historyBegin = 0;
            this._historyEnd = -1;
            // Stop animation
            this._animation.stop();
        };
        UtilGestureEasing.prototype.onMove = function (dx, dy, ds, dt) {
            var capacity = UtilGestureEasing.HISTORY_CAPACITY;
            var oldHistoryEnd = this._historyEnd;
            var newHistoryEnd = (oldHistoryEnd + 1) % capacity;
            this._historyEnd = newHistoryEnd;
            var oldHistoryBegin = this._historyBegin;
            if (newHistoryEnd < oldHistoryEnd ||
                (0 <= oldHistoryEnd && oldHistoryEnd < oldHistoryBegin)) {
                this._historyBegin = (oldHistoryBegin + 1) % capacity;
            }
            this._histories[newHistoryEnd].set(dx, dy, ds, dt);
        };
        UtilGestureEasing.prototype.updateHistoriesSorted = function (dt) {
            var unsorted = this._histories;
            var sorted = this._historiesSorted;
            var begin = this._historyBegin;
            var end = this._historyEnd;
            var length = unsorted.length;
            var threshold = 160;
            if (end < 0) {
                sorted.length = 0;
                return dt;
            }
            else if (end < begin) {
                var total = dt;
                sorted.length = 0;
                for (var i = end; 0 <= i; --i) {
                    var history_1 = unsorted[i];
                    if (total + history_1.dt < threshold) {
                        total += history_1.dt;
                        sorted.push(history_1);
                    }
                    else {
                        return total;
                    }
                }
                for (var i = length - 1; begin <= i; --i) {
                    var history_2 = unsorted[i];
                    if (total + history_2.dt < threshold) {
                        total += history_2.dt;
                        sorted.push(history_2);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
            else {
                var total = dt;
                sorted.length = 0;
                for (var i = end; begin <= i; --i) {
                    var history_3 = unsorted[i];
                    if (total + history_3.dt < threshold) {
                        total += history_3.dt;
                        sorted.push(history_3);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
        };
        UtilGestureEasing.prototype.onEnd = function (ldt) {
            this.updateHistoriesSorted(ldt);
            var sorted = this._historiesSorted;
            var sortedLength = sorted.length;
            if (sortedLength <= 0) {
                return this.onEaseEnd();
            }
            var dx = 0;
            var dy = 0;
            var ds = 0;
            var dt = 0;
            for (var i = 0; i < sortedLength; ++i) {
                var history_4 = sorted[i];
                dx += history_4.dx;
                dy += history_4.dy;
                ds += history_4.ds;
                dt += history_4.dt;
            }
            if (dt <= 0) {
                return this.onEaseEnd();
            }
            var w = 1 / sortedLength;
            dx *= w;
            dy *= w;
            ds *= w;
            dt *= w;
            this._dx = dx;
            this._dy = dy;
            this._ds = ds;
            this._dt = dt;
            // Start animation
            var animation = this._animation;
            var d = animation.duration;
            this._t = -ldt / d;
            this._dtw = d / dt;
            animation.start();
        };
        UtilGestureEasing.prototype.onEase = function (t) {
            var ot = this._t;
            this._t = t;
            // Note: Integral of (1-x) is x (1 - 0.5 x) + c.
            var w = (1 - 0.5 * (t + ot)) * (t - ot) * this._dtw;
            this._onMove(this._dx * w, this._dy * w, 1 + (this._ds - 1) * w, t);
        };
        UtilGestureEasing.prototype.onEaseEnd = function () {
            this._onEnd();
        };
        UtilGestureEasing.prototype.stop = function () {
            this._animation.stop();
        };
        UtilGestureEasing.HISTORY_CAPACITY = 5;
        return UtilGestureEasing;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilGesture = /** @class */ (function () {
        function UtilGesture(options) {
            var _a, _b, _c;
            var on = options.on;
            if (on) {
                this._onStart = on.start;
                this._onMove = on.move;
                this._onEnd = on.end;
            }
            this._modifier = (_a = options === null || options === void 0 ? void 0 : options.modifier) !== null && _a !== void 0 ? _a : UtilGestureModifier.NONE;
            var checker = options.checker;
            var defaultChecker = UtilGestureModifiers.match;
            this._checkerStart = (_b = checker === null || checker === void 0 ? void 0 : checker.start) !== null && _b !== void 0 ? _b : defaultChecker;
            this._checkerMove = (_c = checker === null || checker === void 0 ? void 0 : checker.move) !== null && _c !== void 0 ? _c : defaultChecker;
            this._easing = options.easing;
            this._touch = !!options.touch;
            this._unused = [];
            this._used = new Map();
            var bind = options.bind;
            if (bind != null) {
                this.bind(bind);
            }
        }
        UtilGesture.prototype.newData = function (target) {
            var used = this._used;
            var result = used.get(target);
            if (result != null) {
                return result;
            }
            var poped = this._unused.pop();
            if (poped != null) {
                used.set(target, poped);
                return poped;
            }
            var created = new UtilGestureData();
            created.easing = this.newEasing(created);
            created.onMove = this.newOnMove(created);
            created.onEnd = this.newOnEnd(created);
            used.set(target, created);
            return created;
        };
        UtilGesture.prototype.newEasing = function (data) {
            var _this = this;
            var easing = this._easing;
            if (easing == null || easing !== false) {
                var onEasingMoveBound = function (dx, dy, ds, time) {
                    _this.onEasingMove(dx, dy, ds, time, data);
                };
                var onEasingEndBound = function () {
                    _this.onEasingEnd(data);
                };
                return new UtilGestureEasing(onEasingMoveBound, onEasingEndBound, this.toEasingOptions(easing));
            }
            return undefined;
        };
        UtilGesture.prototype.toEasingOptions = function (options) {
            return options == null || options === true ? undefined : options;
        };
        UtilGesture.prototype.deleteData = function (data) {
            var target = data.target;
            if (target) {
                if (this._used.delete(target)) {
                    data.target = undefined;
                    data.pointers.clear();
                    this._unused.push(data);
                }
            }
        };
        UtilGesture.prototype.bind = function (target) {
            var _this = this;
            target.on(UtilPointerEvent.down, function (e) {
                _this.onDown(target, e);
            });
            return this;
        };
        UtilGesture.prototype.isTouch = function (e) {
            var oe = e.data.originalEvent;
            if ("touches" in oe) {
                return true;
            }
            else if ("pointerId" in oe) {
                return oe.pointerType !== "mouse";
            }
            else {
                return false;
            }
        };
        UtilGesture.prototype.onDown = function (target, e) {
            var _a;
            if (this._touch && !this.isTouch(e)) {
                return;
            }
            if (!this._checkerStart(e, this._modifier, target)) {
                return;
            }
            var layer = DApplications.getLayer(target);
            if (layer == null) {
                return;
            }
            e.stopPropagation();
            if (target.state.isGesturing) {
                (_a = this._used.get(target)) === null || _a === void 0 ? void 0 : _a.start(e);
            }
            else {
                // User-defined handler
                var onStart = this._onStart;
                if (onStart != null) {
                    onStart(target);
                }
                var data = this.newData(target);
                data.target = target;
                target.state.isGesturing = true;
                // Interaction manager
                var interactionManager = layer.renderer.plugins.interaction;
                data.interactionManager = interactionManager;
                // Update the center
                data.start(e);
                // Easing util
                var easing = data.easing;
                if (easing) {
                    easing.onStart();
                }
                // Event handler
                data.bind(e);
            }
        };
        UtilGesture.prototype.newOnMove = function (data) {
            var _this = this;
            return function (e) {
                _this.onMove(e, data);
            };
        };
        UtilGesture.prototype.newOnEnd = function (data) {
            var _this = this;
            return function (e) {
                _this.onEnd(e, data);
            };
        };
        UtilGesture.prototype.onMove = function (e, data) {
            var target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            if (!data.isUpdatable(e) || !this._checkerMove(e, this._modifier, target)) {
                return;
            }
            // Update the center
            var center = data.center;
            var oldCenterX = center.x;
            var oldCenterY = center.y;
            var oldScale = data.scale;
            var oldTime = data.time;
            data.update(e);
            var newCenterX = center.x;
            var newCenterY = center.y;
            var newScale = data.scale;
            var newTime = data.time;
            // Calculate the position
            var dx = newCenterX - oldCenterX;
            var dy = newCenterY - oldCenterY;
            var dt = newTime - oldTime;
            var epsilon = 0.00001;
            var ds = epsilon < oldScale && epsilon < newScale ? newScale / oldScale : 1;
            // Easing
            var easing = data.easing;
            if (easing) {
                easing.onMove(dx, dy, ds, dt);
            }
            // Call the user-defined handler
            var onMove = this._onMove;
            if (onMove != null) {
                if (dx !== 0 || dy !== 0 || ds !== 1) {
                    onMove(target, dx, dy, newCenterX, newCenterY, ds);
                }
            }
        };
        UtilGesture.prototype.onEnd = function (e, data) {
            var target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            if (!data.end(e)) {
                return;
            }
            // State
            target.state.isGesturing = false;
            // Remove event handlers
            var interactionManager = data.interactionManager;
            data.interactionManager = undefined;
            if (interactionManager) {
                var onMoveBound = data.onMove;
                if (onMoveBound) {
                    interactionManager.off(UtilPointerEvent.move, onMoveBound);
                }
                var onEndBound = data.onEnd;
                if (onEndBound) {
                    interactionManager.off(UtilPointerEvent.up, onEndBound);
                    interactionManager.off(UtilPointerEvent.cancel, onEndBound);
                }
            }
            // Call the user-defined handler
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(target);
            }
            // Start the Easing
            var easing = data.easing;
            if (easing) {
                easing.onEnd(e.data.originalEvent.timeStamp - data.time);
            }
            else {
                this.deleteData(data);
            }
        };
        UtilGesture.prototype.onEasingMove = function (dx, dy, ds, time, data) {
            var target = data.target;
            if (target == null) {
                return;
            }
            var onMove = this._onMove;
            if (onMove == null) {
                return;
            }
            if (dx === 0 && dy === 0 && ds === 1) {
                return;
            }
            var center = data.center;
            var x = center.x + dx;
            var y = center.y + dy;
            center.set(x, y);
            onMove(data.target, dx, dy, x, y, ds);
        };
        UtilGesture.prototype.onEasingEnd = function (data) {
            this.deleteData(data);
        };
        UtilGesture.prototype.stop = function (target) {
            var _a;
            var data = this._used.get(target);
            if (data == null) {
                return;
            }
            (_a = data.easing) === null || _a === void 0 ? void 0 : _a.stop();
            this.deleteData(data);
        };
        return UtilGesture;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewGestureImpl = /** @class */ (function () {
        function DViewGestureImpl(parent, toTarget, stopper, constraint, theme, options) {
            var _this = this;
            var _a, _b;
            this._parent = parent;
            this._stopper = stopper;
            this._constraint = constraint;
            var mode = toEnum((_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : theme.getGestureMode(), UtilGestureMode);
            var modifier = toEnum((_b = options === null || options === void 0 ? void 0 : options.modifier) !== null && _b !== void 0 ? _b : theme.getGestureModifier(), UtilGestureModifier);
            if (mode === UtilGestureMode.ON || mode === UtilGestureMode.TOUCH) {
                this._gestureUtil = new UtilGesture({
                    touch: mode === UtilGestureMode.TOUCH,
                    modifier: modifier,
                    checker: options && options.checker,
                    easing: {
                        duration: options === null || options === void 0 ? void 0 : options.duration
                    },
                    on: {
                        start: function () {
                            _this._stopper.stop();
                        },
                        move: function (target, dx, dy, x, y, ds) {
                            _this.onGestureMove(toTarget(parent), dx, dy, x, y, ds);
                        }
                    }
                });
            }
        }
        DViewGestureImpl.prototype.onGestureMove = function (target, dx, dy, x, y, ds) {
            if (target) {
                // Scale
                var stopper = this._stopper;
                var oldScale = target.scale;
                var oldScaleX = oldScale.x;
                var oldScaleY = oldScale.y;
                var newScaleX = stopper.toNormalizedScale(oldScaleX * ds);
                var newScaleY = stopper.toNormalizedScale(oldScaleY * ds);
                var scaleRatioX = newScaleX / oldScaleX;
                var scaleRatioY = newScaleY / oldScaleY;
                var scaleRatio = ds < 1 ? Math.max(scaleRatioX, scaleRatioY) : Math.min(scaleRatioX, scaleRatioY);
                newScaleX = scaleRatio * oldScaleX;
                newScaleY = scaleRatio * oldScaleY;
                // Position
                var cx = x - dx;
                var cy = y - dy;
                var position = target.position;
                var newX = (position.x - cx) * scaleRatio + x;
                var newY = (position.y - cy) * scaleRatio + y;
                // Update
                this._constraint(target, newX, newY, newScaleX, newScaleY);
            }
        };
        DViewGestureImpl.prototype.stop = function () {
            var _a;
            (_a = this._gestureUtil) === null || _a === void 0 ? void 0 : _a.stop(this._parent);
        };
        DViewGestureImpl.prototype.onDown = function (e) {
            var _a;
            (_a = this._gestureUtil) === null || _a === void 0 ? void 0 : _a.onDown(this._parent, e);
        };
        return DViewGestureImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewTransformImpl = /** @class */ (function () {
        function DViewTransformImpl(parent, toTarget, stopper, constraint, duration) {
            var _this = this;
            this._parent = parent;
            this._toTarget = toTarget;
            this._constraint = constraint;
            this._newScaleX = 1;
            this._newScaleY = 1;
            this._newX = 0;
            this._newY = 0;
            this._oldScaleX = 1;
            this._oldScaleY = 1;
            this._oldX = 0;
            this._oldY = 0;
            this._animation = new DAnimationBase({
                onTime: function (time) {
                    _this.onTime(time);
                },
                duration: duration
            });
            this._stopper = stopper;
            this._duration = duration;
        }
        DViewTransformImpl.prototype.onTime = function (time) {
            var w0 = 1 - time;
            var w1 = time;
            var scaleX = this._oldScaleX * w0 + this._newScaleX * w1;
            var scaleY = this._oldScaleY * w0 + this._newScaleY * w1;
            var x = this._oldX * w0 + this._newX * w1;
            var y = this._oldY * w0 + this._newY * w1;
            var target = this._toTarget(this._parent);
            if (target != null) {
                this._constraint(target, x, y, scaleX, scaleY);
            }
        };
        DViewTransformImpl.prototype.start = function (target, x, y, scaleX, scaleY, duration, stop) {
            if (stop !== false) {
                this._stopper.stop();
            }
            if (duration == null) {
                duration = this._duration;
            }
            if (duration <= 0) {
                this._constraint(target, x, y, scaleX, scaleY);
            }
            else {
                var position = target.position;
                var scale = target.scale;
                this._oldX = position.x;
                this._oldY = position.y;
                this._oldScaleX = scale.x;
                this._oldScaleY = scale.y;
                this._newX = x;
                this._newY = y;
                this._newScaleX = scaleX;
                this._newScaleY = scaleY;
                this._animation.duration = duration;
                this._animation.start();
            }
        };
        DViewTransformImpl.prototype.stop = function () {
            this._animation.stop();
        };
        return DViewTransformImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DViewImpl = /** @class */ (function () {
        function DViewImpl(parent, toTarget, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
            this._parent = parent;
            this._toTarget = toTarget;
            this._constraint = (options && options.constraint) || DViewImpl.CONSTRAINT;
            this._workRect = new pixi_js.Rectangle();
            // Theme
            var theme = this.toTheme(options) || this.getThemeDefault();
            // Zoom
            var zoom = options === null || options === void 0 ? void 0 : options.zoom;
            this._zoomPoint = new pixi_js.Point();
            this._zoomMin = (_a = zoom === null || zoom === void 0 ? void 0 : zoom.min) !== null && _a !== void 0 ? _a : theme.getZoomMin();
            this._zoomMax = (_b = zoom === null || zoom === void 0 ? void 0 : zoom.max) !== null && _b !== void 0 ? _b : theme.getZoomMax();
            this._zoomKeepRatio = (_c = zoom === null || zoom === void 0 ? void 0 : zoom.keepRatio) !== null && _c !== void 0 ? _c : theme.getZoomKeepRatio();
            // Zoom: Wheel
            var wheelZoom = zoom === null || zoom === void 0 ? void 0 : zoom.wheel;
            this._isWheelZoomEnabled = (_d = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.enable) !== null && _d !== void 0 ? _d : theme.isWheelZoomEnabled();
            this._wheelZoomSpeed = (_e = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.speed) !== null && _e !== void 0 ? _e : theme.getWheelZoomSpeed();
            this._wheelZoomModifier = toEnum((_f = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.modifier) !== null && _f !== void 0 ? _f : theme.getWheelZoomModifier(), UtilGestureModifier);
            this._wheelZoomChecker = (_g = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.checker) !== null && _g !== void 0 ? _g : UtilGestureModifiers.match;
            // Zoom: Dbl click
            var dblClickZoom = zoom === null || zoom === void 0 ? void 0 : zoom.dblclick;
            this._isDblClickZoomEnabled = (_h = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.enable) !== null && _h !== void 0 ? _h : theme.isDblClickZoomEnabled();
            this._dblClickZoomSpeed = (_j = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.amount) !== null && _j !== void 0 ? _j : theme.getDblClickZoomSpeed();
            this._dblClickZoomModifier = toEnum((_k = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.modifier) !== null && _k !== void 0 ? _k : theme.getDblClickZoomModifier(), UtilGestureModifier);
            this._dblClickZoomChecker = (_l = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.checker) !== null && _l !== void 0 ? _l : UtilGestureModifiers.match;
            this._dblclickZoomDuration = (_m = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.duration) !== null && _m !== void 0 ? _m : theme.getDblClickZoomDuration();
            // Translation: Wheel
            var wheelTranslation = (_o = options === null || options === void 0 ? void 0 : options.translation) === null || _o === void 0 ? void 0 : _o.wheel;
            this._isWheelTranslationEnabled =
                (_p = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.enable) !== null && _p !== void 0 ? _p : theme.isWheelTranslationEnabled();
            this._wheelTranslationSpeed = (_q = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.speed) !== null && _q !== void 0 ? _q : theme.getWheelTranslationSpeed();
            this._wheelTranslationModifier = toEnum((_r = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.modifier) !== null && _r !== void 0 ? _r : theme.getWheelTranslationModifier(), UtilGestureModifier);
            this._wheelTranslationChecker = (_s = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.checker) !== null && _s !== void 0 ? _s : UtilGestureModifiers.match;
            // Gesture
            this._gesture = new DViewGestureImpl(parent, toTarget, this, this._constraint, theme, options === null || options === void 0 ? void 0 : options.gesture);
            // Transform
            this._transform = new DViewTransformImpl(parent, toTarget, this, this._constraint, this._dblclickZoomDuration);
        }
        Object.defineProperty(DViewImpl.prototype, "gesture", {
            get: function () {
                return this._gesture;
            },
            enumerable: false,
            configurable: true
        });
        DViewImpl.prototype.stop = function () {
            this._gesture.stop();
            this._transform.stop();
        };
        DViewImpl.prototype.reset = function (duration, stop) {
            var parent = this._parent;
            var target = this._toTarget(parent);
            if (target) {
                var targetRect = target.getLocalBounds(this._workRect);
                var newTargetX = (parent.width - targetRect.width) * 0.5 - targetRect.x;
                var newTargetY = (parent.height - targetRect.height) * 0.5 - targetRect.y;
                this._transform.start(target, newTargetX, newTargetY, 1, 1, duration, stop);
            }
        };
        DViewImpl.prototype.fit = function (duration, stop) {
            var parent = this._parent;
            var target = this._toTarget(parent);
            if (target) {
                var padding = parent.padding;
                var width = parent.width;
                var height = parent.height;
                var targetRect = target.getLocalBounds(this._workRect);
                var targetX = targetRect.x;
                var targetY = targetRect.y;
                var targetWidth = targetRect.width;
                var targetHeight = targetRect.height;
                var newTargetScaleX = (width - padding.getLeft() - padding.getRight()) / targetWidth;
                var newTargetScaleY = (height - padding.getTop() - padding.getBottom()) / targetHeight;
                if (this._zoomKeepRatio) {
                    var newTargetScale = this.toNormalizedScale(Math.min(newTargetScaleX, newTargetScaleY));
                    newTargetScaleX = newTargetScale;
                    newTargetScaleY = newTargetScale;
                }
                else {
                    newTargetScaleX = this.toNormalizedScale(newTargetScaleX);
                    newTargetScaleY = this.toNormalizedScale(newTargetScaleY);
                }
                var newTargetWidth = targetWidth * newTargetScaleX;
                var newTargetHeight = targetHeight * newTargetScaleY;
                var newTargetX = (width - newTargetWidth) * 0.5 - targetX * newTargetScaleX;
                var newTargetY = (height - newTargetHeight) * 0.5 - targetY * newTargetScaleY;
                this._transform.start(target, newTargetX, newTargetY, newTargetScaleX, newTargetScaleY, duration, stop);
            }
        };
        DViewImpl.prototype.zoomIn = function (duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var factor = this._dblClickZoomSpeed;
                var targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        };
        DViewImpl.prototype.zoomOut = function (duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var factor = 1 / this._dblClickZoomSpeed;
                var targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        };
        DViewImpl.prototype.zoomAt = function (x, y, scaleX, scaleY, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                // Scale
                var oldScaleX = target.scale.x;
                var oldScaleY = target.scale.y;
                var newScaleX = this.toNormalizedScale(scaleX);
                var newScaleY = this.toNormalizedScale(scaleY);
                var scaleRatioX = newScaleX / oldScaleX;
                var scaleRatioY = newScaleY / oldScaleY;
                // Position
                var newX = (target.position.x - x) * scaleRatioX + x;
                var newY = (target.position.y - y) * scaleRatioY + y;
                // Start
                this._transform.start(target, newX, newY, newScaleX, newScaleY, duration, stop);
            }
        };
        DViewImpl.prototype.zoomAtGlobal = function (x, y, scaleX, scaleY, duration, stop) {
            var local = this._zoomPoint;
            local.set(x, y);
            this.toLocal(local, local);
            this.zoomAt(local.x, local.y, scaleX, scaleY, duration, stop);
        };
        DViewImpl.prototype.zoom = function (scaleX, scaleY, duration, stop) {
            var parent = this._parent;
            this.zoomAt(parent.width * 0.5, parent.height * 0.5, scaleX, scaleY, duration, stop);
        };
        Object.defineProperty(DViewImpl.prototype, "scale", {
            get: function () {
                var target = this._toTarget(this._parent);
                if (target) {
                    return target.scale;
                }
                return new pixi_js.Point(1, 1);
            },
            set: function (scale) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var newScaleX = this.toNormalizedScale(scale.x);
                    var newScaleY = this.toNormalizedScale(scale.y);
                    var targetPosition = target.position;
                    this._constraint(target, targetPosition.x, targetPosition.y, newScaleX, newScaleY);
                }
            },
            enumerable: false,
            configurable: true
        });
        DViewImpl.prototype.moveTo = function (x, y, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                var targetScale = target.scale;
                this._transform.start(target, x, y, targetScale.x, targetScale.y, duration, stop);
            }
        };
        Object.defineProperty(DViewImpl.prototype, "position", {
            get: function () {
                var target = this._toTarget(this._parent);
                if (target) {
                    return target.position;
                }
                return new pixi_js.Point(0, 0);
            },
            set: function (position) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var targetScale = target.scale;
                    this._constraint(target, position.x, position.y, targetScale.x, targetScale.y);
                }
            },
            enumerable: false,
            configurable: true
        });
        DViewImpl.prototype.transform = function (x, y, scaleX, scaleY, duration, stop) {
            var target = this._toTarget(this._parent);
            if (target) {
                this._transform.start(target, x, y, scaleX, scaleY, duration, stop);
            }
        };
        DViewImpl.prototype.toLocal = function (global, local, skipUpdate) {
            return this._parent.toLocal(global, undefined, local, skipUpdate);
        };
        DViewImpl.prototype.toGlobal = function (local, global, skipUpdate) {
            return this._parent.toGlobal(local, global, skipUpdate);
        };
        DViewImpl.prototype.toNormalizedScale = function (scale) {
            return Math.min(this._zoomMax, Math.max(this._zoomMin, scale));
        };
        DViewImpl.prototype.onWheel = function (e, deltas, global) {
            if (this._isWheelZoomEnabled &&
                this._wheelZoomChecker(e, this._wheelZoomModifier, this._parent)) {
                if (deltas.deltaY !== 0) {
                    var target = this._toTarget(this._parent);
                    if (target) {
                        var speed = deltas.lowest * this._wheelZoomSpeed;
                        var factor = 1 + deltas.deltaY * speed;
                        var targetScale = target.scale;
                        this.zoomAtGlobal(global.x, global.y, targetScale.x * factor, targetScale.y * factor, 0);
                        return true;
                    }
                }
            }
            if (this._isWheelTranslationEnabled &&
                this._wheelTranslationChecker(e, this._wheelTranslationModifier, this._parent)) {
                var target = this._toTarget(this._parent);
                if (target) {
                    this.stop();
                    var speed = deltas.lowest * this._wheelTranslationSpeed;
                    var targetPosition = target.position;
                    var newX = targetPosition.x - deltas.deltaX * speed;
                    var newY = targetPosition.y + deltas.deltaY * speed;
                    var targetScale = target.scale;
                    this._constraint(target, newX, newY, targetScale.x, targetScale.y);
                    return true;
                }
            }
            return false;
        };
        DViewImpl.prototype.onDown = function (e) {
            this._gesture.onDown(e);
        };
        DViewImpl.prototype.onDblClick = function (e, interactionManager) {
            if (this._isDblClickZoomEnabled &&
                this._dblClickZoomChecker(e, this._dblClickZoomModifier, this._parent)) {
                var target = this._toTarget(this._parent);
                if (target) {
                    var global_1 = this._zoomPoint;
                    UtilPointerEvent.toGlobal(e, interactionManager, global_1);
                    var factor = this._dblClickZoomSpeed;
                    var targetScale = target.scale;
                    this.zoomAtGlobal(global_1.x, global_1.y, targetScale.x * factor, targetScale.y * factor, this._dblclickZoomDuration);
                    return true;
                }
            }
            return false;
        };
        DViewImpl.prototype.toTheme = function (options) {
            if (options && options.theme) {
                var theme = options.theme;
                if (isString(theme)) {
                    return DThemes.getInstance().get(theme);
                }
                else {
                    return theme;
                }
            }
            return null;
        };
        DViewImpl.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DViewImpl.prototype.getType = function () {
            return "DView";
        };
        DViewImpl.CONSTRAINT = function (target, x, y, scaleX, scaleY) {
            target.scale.set(scaleX, scaleY);
            target.position.set(x, y);
        };
        return DViewImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A canvas container.
     */
    var DCanvasContainer = /** @class */ (function (_super) {
        __extends(DCanvasContainer, _super);
        function DCanvasContainer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCanvasContainer.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            this._canvas = null;
            var theme = this.theme;
            this._view = new DViewImpl(this, function () { return _this._canvas; }, options === null || options === void 0 ? void 0 : options.view);
            // Canvas
            var canvas = options === null || options === void 0 ? void 0 : options.canvas;
            if (canvas) {
                this.canvas = canvas;
            }
            // Overflow mask
            var mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : theme.isOverflowMaskEnabled();
            if (mask) {
                this.mask = this.getOverflowMask();
            }
        };
        DCanvasContainer.prototype.getType = function () {
            return "DCanvasContainer";
        };
        DCanvasContainer.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.updateContentSize(newWidth, newHeight, oldWidth, oldHeight);
        };
        Object.defineProperty(DCanvasContainer.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            set: function (canvas) {
                var previous = this._canvas;
                if (previous != null) {
                    this._canvas = null;
                    this.removeChild(previous);
                    this.emit("unset", previous, this);
                    previous.destroy();
                }
                this._canvas = canvas;
                if (canvas != null) {
                    this.addChild(canvas);
                    this._view.reset(0);
                    this.emit("set", canvas, this);
                }
                else {
                    DApplications.update(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DCanvasContainer.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this._reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        DCanvasContainer.prototype.updateContentSize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var canvas = this._canvas;
            if (canvas != null) {
                var canvasX = canvas.x + (newWidth - oldWidth) * 0.5;
                var canvasY = canvas.y + (newHeight - oldHeight) * 0.5;
                canvas.position.set(canvasX, canvasY);
            }
        };
        Object.defineProperty(DCanvasContainer.prototype, "view", {
            get: function () {
                return this._view;
            },
            enumerable: false,
            configurable: true
        });
        DCanvasContainer.prototype.onWheel = function (e, deltas, global) {
            var vresult = this._view.onWheel(e, deltas, global);
            var sresult = _super.prototype.onWheel.call(this, e, deltas, global);
            return vresult || sresult;
        };
        DCanvasContainer.prototype.onDblClick = function (e, interactionManager, skipView) {
            if (skipView !== true) {
                var vresult = this._view.onDblClick(e, interactionManager);
                var sresult = _super.prototype.onDblClick.call(this, e, interactionManager);
                return vresult || sresult;
            }
            else {
                return _super.prototype.onDblClick.call(this, e, interactionManager);
            }
        };
        DCanvasContainer.prototype.onDown = function (e, skipView) {
            if (skipView !== true) {
                this._view.onDown(e);
            }
            _super.prototype.onDown.call(this, e);
        };
        DCanvasContainer.prototype.destroy = function () {
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            _super.prototype.destroy.call(this);
        };
        return DCanvasContainer;
    }(DBase));

    /**
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DDiagram} controller open type.
     */
    var DDiagramBaseControllerOpenType = {
        DIAGRAM: 0,
        PAGE: 1,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataMapperImpl = /** @class */ (function () {
        function EShapeDataMapperImpl(source) {
            this._sources = this.newSources(source);
        }
        EShapeDataMapperImpl.prototype.map = function (value, destinations, initial) {
            var sources = this._sources;
            if (sources == null) {
                return false;
            }
            var valueId = value.id;
            var target = valueId.toLowerCase();
            var targetLength = target.length;
            if (targetLength !== valueId.length) {
                return false;
            }
            var first = sources[0];
            var firstLength = first.length;
            if (firstLength !== 0 && target.indexOf(first) !== 0) {
                return false;
            }
            var spans = EShapeDataMapperImpl.SPANS;
            spans[0] = 0;
            spans[1] = firstLength;
            var sourcesLength = sources.length;
            for (var i = 1; i < sourcesLength; ++i) {
                var ispan = i << 1;
                var source = sources[i];
                var sourceLength = source.length;
                if (sourceLength === 0) {
                    spans[ispan] = targetLength;
                    spans[ispan + 1] = targetLength;
                }
                else {
                    var index = target.indexOf(source, spans[ispan - 1]);
                    if (index < 0) {
                        return false;
                    }
                    spans[ispan] = index;
                    spans[ispan + 1] = index + sourceLength;
                }
            }
            // Update the ID
            if (destinations != null) {
                var destinationsLength = destinations.length;
                var id = "";
                for (var i = 0, imax = sourcesLength; i < imax; ++i) {
                    var id0 = i < destinationsLength ? destinations[i] : sources[i];
                    var ispan = i << 1;
                    var s0 = spans[ispan + 1];
                    var s1 = spans[ispan + 2];
                    var id1 = valueId.substring(s0, i + 1 < imax ? s1 : targetLength);
                    id += id0 + id1;
                }
                value.id = id;
            }
            // Update the initial value
            if (0 < initial.length) {
                value.initial = initial;
            }
            return true;
        };
        EShapeDataMapperImpl.prototype.newSources = function (source) {
            if (source == null) {
                return null;
            }
            var trimmed = source.trim();
            if (trimmed.length <= 0) {
                return null;
            }
            return trimmed.toLowerCase().split(EShapeDataMapperImpl.WILDCARD);
        };
        EShapeDataMapperImpl.split = function (target) {
            if (target == null) {
                return null;
            }
            var trimmed = target.trim();
            if (trimmed.length <= 0) {
                return null;
            }
            return trimmed.split(this.WILDCARD);
        };
        EShapeDataMapperImpl.WILDCARD = "*";
        EShapeDataMapperImpl.SPANS = [];
        return EShapeDataMapperImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerDeserialization = /** @class */ (function () {
        function EShapeResourceManagerDeserialization(serialized, pieces, pieceData, mode, depth) {
            this.resources = serialized.resources;
            this.data = serialized.data || serialized.tags || serialized.resources;
            this.pieces = pieces;
            this.pieceData = pieceData;
            this.mode = mode;
            this.depth = depth;
            this._actions = new Map();
            this._fills = new Map();
            this._strokes = new Map();
            this._data = new Map();
            this._dataValues = new Map();
            this._dataMapping = new Map();
            this._dataMappers = new Map();
            this._dataDestinations = new Map();
            this._dataSystem = new Map();
            this._ranges = new Map();
            this._aligns = new Map();
            this._margins = new Map();
            this._texts = new Map();
            this._textOutlines = new Map();
            this._capabilities = new Map();
            this._extensions = new Map();
        }
        EShapeResourceManagerDeserialization.prototype.getAction = function (id) {
            return this._actions.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setAction = function (id, action) {
            this._actions.set(id, action);
        };
        EShapeResourceManagerDeserialization.prototype.getFill = function (id) {
            return this._fills.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setFill = function (id, fill) {
            this._fills.set(id, fill);
        };
        EShapeResourceManagerDeserialization.prototype.getStroke = function (id) {
            return this._strokes.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setStroke = function (id, stroke) {
            this._strokes.set(id, stroke);
        };
        EShapeResourceManagerDeserialization.prototype.getData = function (id) {
            return this._data.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setData = function (id, data) {
            this._data.set(id, data);
        };
        EShapeResourceManagerDeserialization.prototype.getDataValue = function (id) {
            return this._dataValues.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setDataValue = function (id, dataValue) {
            this._dataValues.set(id, dataValue);
        };
        EShapeResourceManagerDeserialization.prototype.getDataMapping = function (id) {
            return this._dataMapping.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setDataMapping = function (id, dataMapping) {
            this._dataMapping.set(id, dataMapping);
        };
        EShapeResourceManagerDeserialization.prototype.getDataMapper = function (source) {
            var dataMappers = this._dataMappers;
            var result = dataMappers.get(source);
            if (result === undefined) {
                result = new EShapeDataMapperImpl(source);
                dataMappers.set(source, result);
            }
            return result;
        };
        EShapeResourceManagerDeserialization.prototype.getDataDestination = function (destination) {
            var dataDestinations = this._dataDestinations;
            var result = dataDestinations.get(destination);
            if (result === undefined) {
                result = EShapeDataMapperImpl.split(destination);
                dataDestinations.set(destination, result);
            }
            return result;
        };
        EShapeResourceManagerDeserialization.prototype.getDataSystem = function (id) {
            return this._dataSystem.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setDataSystem = function (id, dataSystem) {
            this._dataSystem.set(id, dataSystem);
        };
        EShapeResourceManagerDeserialization.prototype.getRange = function (id) {
            return this._ranges.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setRange = function (id, range) {
            this._ranges.set(id, range);
        };
        EShapeResourceManagerDeserialization.prototype.getAlign = function (id) {
            return this._aligns.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setAlign = function (id, align) {
            this._aligns.set(id, align);
        };
        EShapeResourceManagerDeserialization.prototype.getMargin = function (id) {
            return this._margins.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setMargin = function (id, margin) {
            this._margins.set(id, margin);
        };
        EShapeResourceManagerDeserialization.prototype.getText = function (id) {
            return this._texts.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setText = function (id, text) {
            this._texts.set(id, text);
        };
        EShapeResourceManagerDeserialization.prototype.getTextOutline = function (id) {
            return this._textOutlines.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setTextOutline = function (id, textOutline) {
            this._textOutlines.set(id, textOutline);
        };
        EShapeResourceManagerDeserialization.prototype.getCapability = function (id) {
            return this._capabilities.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setCapability = function (id, capability) {
            this._capabilities.set(id, capability);
        };
        EShapeResourceManagerDeserialization.prototype.getExtension = function (id) {
            return this._extensions.get(id);
        };
        EShapeResourceManagerDeserialization.prototype.setExtension = function (id, extension) {
            this._extensions.set(id, extension);
        };
        return EShapeResourceManagerDeserialization;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerDeserializationMode = {
        VIEWER: 0,
        EDITOR_DATA_MAPPED: 1,
        EDITOR: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCapabilities = /** @class */ (function () {
        function EShapeCapabilities() {
        }
        EShapeCapabilities.get = function (type) {
            var capability = this.mappings[type];
            if (capability != null) {
                return capability;
            }
            return EShapeCapability.PRIMITIVE;
        };
        EShapeCapabilities.contains = function (shape, target) {
            if (shape != null) {
                var capability = this.get(shape.type);
                var shapeCapability = shape.getCapability();
                if (shapeCapability != null) {
                    capability &= ~shapeCapability.removed;
                    capability |= shapeCapability.added;
                    capability &= ~shapeCapability.locked;
                }
                return (capability & target) === target;
            }
            return false;
        };
        EShapeCapabilities.set = function (type, capability) {
            this.mappings[type] = capability;
        };
        EShapeCapabilities.mappings = {};
        return EShapeCapabilities;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEditor = /** @class */ (function () {
        function EShapeEditor() {
            this.localTransform = new pixi_js.Matrix();
            this.internalTransform = new pixi_js.Matrix();
            this.internalTransformParentInverse = new pixi_js.Matrix();
            this.rotation = 0;
            this.size = new pixi_js.Point();
        }
        return EShapeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSizeNormalized = function (size) {
        var THRESHOLD = 0.001;
        if (Math.abs(size) < THRESHOLD) {
            return size < 0 ? -THRESHOLD : +THRESHOLD;
        }
        return size;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTransforms = /** @class */ (function () {
        function EShapeTransforms() {
        }
        EShapeTransforms.prepare = function (shape) {
            var editor = shape.editor || new EShapeEditor();
            shape.editor = editor;
            // Transform
            shape.updateTransform();
            var parent = shape.parent;
            if (parent instanceof EShapeBase) {
                parent.transform.internalTransform
                    .copyTo(editor.internalTransformParentInverse)
                    .invert();
            }
            else {
                editor.internalTransformParentInverse.identity();
            }
            shape.transform.internalTransform.copyTo(editor.internalTransform);
            // Rotation
            editor.rotation = shape.transform.rotation;
            // Size
            editor.size.copyFrom(shape.size);
            //
            shape.disallowOnTransformChange();
        };
        EShapeTransforms.finalize = function (shape) {
            shape.allowOnTransformChange(true);
        };
        EShapeTransforms.apply = function (shape, transform, capability) {
            var editor = shape.editor;
            if (editor != null) {
                var newLocalTransform = editor.localTransform;
                editor.internalTransformParentInverse
                    .copyTo(newLocalTransform)
                    .append(transform)
                    .append(editor.internalTransform);
                this.applyLocal(shape, newLocalTransform, capability, editor.size);
            }
        };
        EShapeTransforms.applyLocal = function (shape, localTransform, capability, size) {
            shape.disallowUploadedUpdate();
            // Reconstruct the position, the rotation and the size
            var a = localTransform.a;
            var b = localTransform.b;
            var c = localTransform.c;
            var d = localTransform.d;
            var tx = localTransform.tx;
            var ty = localTransform.ty;
            // Transform
            var transform = shape.transform;
            // Capability
            var cposition = !!(capability & EShapeCapability.POSITION);
            var crotation = !!(capability & EShapeCapability.ROTATION);
            var cskew = !!(capability & EShapeCapability.SKEW);
            var cwidth = !!(capability & EShapeCapability.WIDTH);
            var cheight = !!(capability & EShapeCapability.HEIGHT);
            // Rotation and skew
            if (crotation || cskew) {
                // Rotation
                var rx = Math.atan2(-c, d); // rotation - skewX
                var ry = Math.atan2(+b, a); // rotation + skewY
                if (crotation) {
                    transform.rotation = (rx + ry) * 0.5; // Here, assumes `skewX` === `skewY`
                }
                // Skew
                if (cskew) {
                    var skew = (ry - rx) * 0.5;
                    transform.skew.set(skew, skew);
                }
            }
            // Position
            if (cposition) {
                // Assumes the pivot is invariant.
                // tx = position.x - (a * px + c * py)
                // ty = position.y - (b * px + d * py)
                //
                // Thus,
                // position.x = tx + (a * px + c * py)
                // position.y = ty + (b * px + d * py)
                var pivot = transform.pivot;
                var px = pivot.x;
                var py = pivot.y;
                transform.position.set(tx + (a * px + c * py), ty + (b * px + d * py));
            }
            // Scale
            if (size != null && (cwidth || cheight)) {
                var w = toSizeNormalized(size.x * Math.sqrt(a * a + b * b));
                var h = toSizeNormalized(size.y * Math.sqrt(c * c + d * d));
                var s = shape.size;
                if (cwidth && cheight) {
                    s.set(w, h);
                }
                else if (cwidth) {
                    s.x = w;
                }
                else {
                    s.y = h;
                }
            }
            //
            shape.allowUploadedUpdate();
        };
        return EShapeTransforms;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeLayout = /** @class */ (function () {
        function EShapeGroupSizeLayout(shape, bx, by) {
            this.shape = shape;
            // Base group size
            this.base = new pixi_js.Point(bx, by);
            // Base shape size
            var size = shape.size;
            this.shapeBase = new pixi_js.Point(size.x, size.y);
            // Transform
            this.transform = new pixi_js.Matrix();
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
            this.capable =
                EShapeCapabilities.contains(shape, EShapeCapability.POSITION) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.WIDTH) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.HEIGHT) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.ROTATION) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.SKEW);
        }
        EShapeGroupSizeLayout.prototype.isCompatible = function (shape) {
            return this.shape === shape;
        };
        EShapeGroupSizeLayout.prototype.reset = function (shape, baseX, baseY) {
            this.base.set(baseX, baseY);
            // Base shape size
            var size = shape.size;
            this.shapeBase.copyFrom(size);
            // Transform
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
        };
        EShapeGroupSizeLayout.prototype.update = function (shape, baseX, baseY, pivotX, pivotY) {
            if (!this.capable) {
                return;
            }
            var sx = baseX / this.base.x;
            var sy = baseY / this.base.y;
            var childBase = this.shapeBase;
            var transform = EShapeGroupSizeLayout.WORK_TRANSFORM;
            transform
                .identity()
                .append(this.transform)
                .translate(-pivotX, -pivotY)
                .scale(sx, sy)
                .translate(+pivotX, +pivotY);
            shape.disallowOnTransformChange();
            EShapeTransforms.applyLocal(shape, transform, EShapeCapability.ALL, childBase);
            shape.allowOnTransformChange(false);
        };
        EShapeGroupSizeLayout.WORK_TRANSFORM = new pixi_js.Matrix();
        return EShapeGroupSizeLayout;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeEditor = /** @class */ (function () {
        function EShapeGroupSizeEditor(parent, x, y, isFittable) {
            this._workRectForCalcRect = new pixi_js.Rectangle();
            this._workRectForFit = new pixi_js.Rectangle();
            this._parent = parent;
            this._layouts = [];
            this._size = new pixi_js.Point(x, y);
            this._isFittable = isFittable;
        }
        EShapeGroupSizeEditor.prototype.init = function () {
            return this;
        };
        Object.defineProperty(EShapeGroupSizeEditor.prototype, "x", {
            get: function () {
                return this._size.x;
            },
            set: function (x) {
                var size = this._size;
                if (size.x !== x) {
                    var ox = size.x;
                    size.x = x;
                    this.onChange(ox, size.y);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeEditor.prototype, "y", {
            get: function () {
                return this._size.y;
            },
            set: function (y) {
                var size = this._size;
                if (size.y !== y) {
                    var oy = size.y;
                    size.y = y;
                    this.onChange(size.x, oy);
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupSizeEditor.prototype.set = function (x, y) {
            var isChanged = false;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.clone = function () {
            var size = this._size;
            return new EShapeGroupSizeEditor(this._parent, size.x, size.y, this._isFittable);
        };
        EShapeGroupSizeEditor.prototype.copy = function () {
            // DO NOTHING
        };
        EShapeGroupSizeEditor.prototype.copyFrom = function (point) {
            var x = point.x;
            var y = point.y;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.copyTo = function (point) {
            return this._size.copyTo(point);
        };
        EShapeGroupSizeEditor.prototype.equals = function (point) {
            return this._size.equals(point);
        };
        EShapeGroupSizeEditor.prototype.fit = function () {
            if (this._isFittable) {
                this.doFit();
            }
            return this;
        };
        EShapeGroupSizeEditor.prototype.doFit = function () {
            var parent = this._parent;
            parent.disallowOnTransformChange();
            // Calculate the rect
            var rect = this.calcRect(this._workRectForFit);
            // Set size
            var size = this._size;
            size.set(rect.width, rect.height);
            // Position & Pivot
            // rx := rect.x
            // ry := rect.y
            //
            // | a c tx | | 1 0 +rx | | 1 0 -rx |   | a c tx + (a * rx + c * ry) | | 1 0 -rx |
            // | b d ty | | 0 1 +ry | | 0 1 -ry | = | b d ty + (b * rx + d * ry) | | 0 1 -ry |
            // | 0 0 1  | | 0 0  1  | | 0 0  1  |   | 0 0 1                      | | 0 0  1  |
            //
            // tx -> tx + (a * rx + c * ry) = poxition.x - (a * pivot.x + c * pivot.y)
            // ty -> ty + (b * rx + d * ry) = poxition.y - (b * pivot.x + d * pivot.y)
            // position.x -> position.x + (a * rx + c * ry) - (a * pivot.x + c * pivot.y)
            // position.y -> position.y + (b * rx + d * ry) - (b * pivot.x + d * pivot.y)
            // pivot.x -> 0
            // pivot.y -> 0
            //
            // a -> a', b -> b', c -> c', tx -> tx', ty -> ty'
            //
            // | a' c' tx' | | 1 0 -rx |   | a' c' tx' - (a' * rx + c' * ry) |
            // | b' d' ty' | | 0 1 -ry | = | b' d' ty' - (b' * rx + d' * ry) |
            // | 0  0  1   | | 0 0  1  |   | 0  0  1                         |
            //
            // tx' -> tx' - (a' * rx + c' * ry) = poxition.x - (a' * pivot.x + c' * pivot.y)
            // ty' -> ty' - (b' * rx + d' * ry) = poxition.y - (b' * pivot.x + d' * pivot.y)
            // pivot.x -> pivot.x + rx
            // pivot.y -> pivot.y + ry
            parent.updateTransform();
            var transform = parent.transform;
            var x = rect.x + rect.width * 0.5;
            var y = rect.y + rect.height * 0.5;
            var position = transform.position;
            var localTransform = transform.localTransform;
            var a = localTransform.a;
            var b = localTransform.b;
            var c = localTransform.c;
            var d = localTransform.d;
            var pivot = transform.pivot;
            position.set(position.x + (a * x + c * y) - (a * pivot.x + c * pivot.y), position.y + (b * x + d * y) - (b * pivot.x + d * pivot.y));
            pivot.set(x, y);
            // Reset the data
            this.reset(parent.children, this._layouts, size);
            //
            parent.allowOnTransformChange(true);
        };
        EShapeGroupSizeEditor.prototype.reset = function (children, layouts, size) {
            for (var i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                var child = children[i];
                var layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.reset(child, size.x, size.y);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            if (children.length < layouts.length) {
                layouts.length = children.length;
            }
        };
        EShapeGroupSizeEditor.prototype.calcRect = function (result) {
            var parent = this._parent;
            var children = parent.children;
            if (children.length <= 0) {
                result.x = 0;
                result.y = 0;
                result.width = 0;
                result.height = 0;
            }
            else {
                var workRect = this._workRectForCalcRect;
                children[0].getBoundsLocal(false, result);
                for (var i = 1, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    child.getBoundsLocal(false, workRect);
                    result.enlarge(workRect);
                }
            }
            return result;
        };
        EShapeGroupSizeEditor.prototype.onChange = function (ox, oy) {
            var parent = this._parent;
            var size = this._size;
            var pivot = parent.transform.pivot;
            this.onChange_(parent.children, this._layouts, size.x, size.y, pivot.x, pivot.y, ox, oy);
            parent.onSizeChange();
        };
        EShapeGroupSizeEditor.prototype.onChange_ = function (children, layouts, sx, sy, px, py, ox, oy) {
            for (var i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                var child = children[i];
                var layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.update(child, sx, sy, px, py);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            for (var i = layouts.length, imax = children.length; i < imax; ++i) {
                var child = children[i];
                var layout = this.newLayout(child, ox, oy);
                layout.update(child, sx, sy, px, py);
                layouts.push(layout);
            }
            if (layouts.length !== children.length) {
                layouts.length = children.length;
            }
        };
        EShapeGroupSizeEditor.prototype.newLayout = function (shape, ox, oy) {
            return shape.layout || new EShapeGroupSizeLayout(shape, ox, oy);
        };
        return EShapeGroupSizeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeViewer = /** @class */ (function () {
        function EShapeGroupSizeViewer(parent, x, y, bx, by) {
            this._parent = parent;
            this._x = x;
            this._y = y;
            this._base = new pixi_js.Point(bx, by);
        }
        Object.defineProperty(EShapeGroupSizeViewer.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                if (this._x !== x) {
                    this._x = x;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeViewer.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                if (this._y !== y) {
                    this._y = y;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeViewer.prototype, "base", {
            get: function () {
                return this._base;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupSizeViewer.prototype.init = function () {
            this._base.copyFrom(this);
            this.onChange();
            return this;
        };
        EShapeGroupSizeViewer.prototype.clone = function () {
            var base = this._base;
            return new EShapeGroupSizeViewer(this._parent, this._x, this._y, base.x, base.y);
        };
        EShapeGroupSizeViewer.prototype.set = function (x, y) {
            var isChanged = false;
            if (x != null && this._x !== x) {
                this._x = x;
                isChanged = true;
            }
            if (y != null && this._y !== y) {
                this._y = y;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        };
        EShapeGroupSizeViewer.prototype.copyFrom = function (p) {
            if (p instanceof EShapeGroupSizeViewer) {
                this._base.copyFrom(p.base);
            }
            if (this._x !== p.x || this._y !== p.y) {
                this._x = p.x;
                this._y = p.y;
                this.onChange();
            }
            return this;
        };
        EShapeGroupSizeViewer.prototype.copyTo = function (p) {
            if (p instanceof EShapeGroupSizeViewer) {
                this._base.copyTo(p.base);
            }
            p.set(this._x, this._y);
            return p;
        };
        EShapeGroupSizeViewer.prototype.equals = function (p) {
            return p.x === this._x && p.y === this._y;
        };
        EShapeGroupSizeViewer.prototype.fit = function () {
            return this;
        };
        EShapeGroupSizeViewer.prototype.onChange = function () {
            var base = this._base;
            this._parent.transform.scale.set(this._x / base.x, this._y / base.y);
        };
        return EShapeGroupSizeViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupFillViewer = /** @class */ (function () {
        function EShapeGroupFillViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupFillViewer.prototype, "enable", {
            get: function () {
                return true;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupFillViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupFillViewer.prototype.set = function (enable, color, alpha) {
            // DO NOTHING
        };
        EShapeGroupFillViewer.prototype.clone = function () {
            return new EShapeGroupFillViewer();
        };
        EShapeGroupFillViewer.prototype.toObject = function () {
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        };
        EShapeGroupFillViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupFillViewer.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupFillViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupStrokeViewer = /** @class */ (function () {
        function EShapeGroupStrokeViewer() {
            // DO NOTHING
        }
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "enable", {
            get: function () {
                return false;
            },
            set: function (enable) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "color", {
            get: function () {
                return 0xffffff;
            },
            set: function (color) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "alpha", {
            get: function () {
                return 1.0;
            },
            set: function (alpha) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "width", {
            get: function () {
                return 1.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "align", {
            get: function () {
                return 0.0;
            },
            set: function (width) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "side", {
            get: function () {
                return EShapeStrokeSide.NONE;
            },
            set: function (side) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeViewer.prototype, "style", {
            get: function () {
                return EShapeStrokeStyle.NONE;
            },
            set: function (style) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupStrokeViewer.prototype.copy = function (target) {
            // DO NOTHING
        };
        EShapeGroupStrokeViewer.prototype.set = function (enable, color, alpha, width, align, side, style) {
            // DO NOTHING
        };
        EShapeGroupStrokeViewer.prototype.clone = function () {
            return new EShapeGroupStrokeViewer();
        };
        EShapeGroupStrokeViewer.prototype.toObject = function () {
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE,
                style: EShapeStrokeStyle.NONE
            };
        };
        EShapeGroupStrokeViewer.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupStrokeViewer.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupStrokeViewer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupViewer = /** @class */ (function (_super) {
        __extends(EShapeGroupViewer, _super);
        function EShapeGroupViewer(mode, depth, type) {
            var _this = _super.call(this, type) || this;
            _this._mode = mode;
            _this._depth = depth;
            var data = _this.newData();
            _this.data = data;
            _this.tag = data;
            _this.size = _this.newGroupSize(mode, depth);
            _this.fill = _this.newGroupFill();
            _this.stroke = _this.newGroupStroke();
            _this.text = _this.newGroupText();
            return _this;
        }
        Object.defineProperty(EShapeGroupViewer.prototype, "mode", {
            get: function () {
                return this._mode;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "depth", {
            get: function () {
                return this._depth;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupViewer.prototype.newGroupSize = function (mode, depth) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        };
        EShapeGroupViewer.prototype.isGroupSizeFittable = function () {
            return true;
        };
        EShapeGroupViewer.prototype.newData = function () {
            return new EShapeDataImpl();
        };
        EShapeGroupViewer.prototype.newGroupFill = function () {
            return new EShapeGroupFillViewer();
        };
        EShapeGroupViewer.prototype.newGroupStroke = function () {
            return new EShapeGroupStrokeViewer();
        };
        EShapeGroupViewer.prototype.newGroupText = function () {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.TEXT_COLOR, EShapeDefaults.TEXT_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        };
        EShapeGroupViewer.prototype.getBoundsSize = function () {
            var size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                return size.base;
            }
            else {
                return size;
            }
        };
        EShapeGroupViewer.prototype.onChildTransformChange = function () {
            _super.prototype.onChildTransformChange.call(this);
            this.size.fit();
        };
        Object.defineProperty(EShapeGroupViewer.prototype, "corner", {
            get: function () {
                return EShapeCorner.NONE;
            },
            set: function (corner) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "gradient", {
            get: function () {
                return undefined;
            },
            set: function (gradient) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "radius", {
            get: function () {
                return 0;
            },
            set: function (radius) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "image", {
            get: function () {
                return undefined;
            },
            set: function (image) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupViewer.prototype, "points", {
            get: function () {
                return undefined;
            },
            set: function (points) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupViewer.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            return false;
        };
        return EShapeGroupViewer;
    }(EShapeBase));

    var EShapeEmbedded = /** @class */ (function (_super) {
        __extends(EShapeEmbedded, _super);
        function EShapeEmbedded(name, mode, depth, type) {
            if (type === void 0) { type = EShapeType.EMBEDDED; }
            var _this = _super.call(this, mode, depth, type) || this;
            _this._name = name;
            _this._depth = depth;
            return _this;
        }
        Object.defineProperty(EShapeEmbedded.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: false,
            configurable: true
        });
        EShapeEmbedded.prototype.isGroupSizeFittable = function () {
            return false;
        };
        EShapeEmbedded.prototype.newGroupSize = function (mode, depth) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER && depth <= 0) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        };
        EShapeEmbedded.prototype.clone = function () {
            var result = this.newClone().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            return result;
        };
        EShapeEmbedded.prototype.newClone = function () {
            var constructor = this.constructor;
            return new constructor(this._name, this._mode, this._depth, this.type);
        };
        EShapeEmbedded.prototype.serializeChildren = function (manager) {
            return [];
        };
        EShapeEmbedded.prototype.serializeImage = function (manager) {
            return -1;
        };
        EShapeEmbedded.prototype.serializeGradient = function (manager) {
            return -1;
        };
        EShapeEmbedded.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = manager.addPiece(this._name);
            return result;
        };
        EShapeEmbedded.prototype.addUuid = function (manager) {
            this.uuid = manager.addUuid(this.uuid);
        };
        EShapeEmbedded.prototype.updateUuid = function (manager) {
            this.uuid = manager.updateUuid(this.uuid);
        };
        return EShapeEmbedded;
    }(EShapeGroupViewer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeUuidMappingImpl = /** @class */ (function () {
        function EShapeUuidMappingImpl(shapes) {
            this._shapes = shapes;
        }
        EShapeUuidMappingImpl.prototype.find = function (uuid) {
            return this.getUuidToShape().get(uuid);
        };
        EShapeUuidMappingImpl.prototype.getUuidToShape = function () {
            var result = this._uuidToShape;
            if (result == null) {
                result = this.newUuidToShape();
                this._uuidToShape = result;
            }
            return result;
        };
        EShapeUuidMappingImpl.prototype.newUuidToShape = function () {
            var result = new Map();
            this.fillUuidToShape(this._shapes, result);
            return result;
        };
        EShapeUuidMappingImpl.prototype.fillUuidToShape = function (shapes, result) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                result.set(shape.uuid, shape);
                if (!(shape instanceof EShapeEmbedded)) {
                    var children = shape.children;
                    if (0 < children.length) {
                        this.fillUuidToShape(children, result);
                    }
                }
            }
        };
        return EShapeUuidMappingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserialize = function (item, manager) {
        var deserializer = EShapeDeserializers[item[0]] || EShapeDeserializers[EShapeType.NULL];
        if (deserializer != null) {
            var result = deserializer(item, manager);
            if (result != null) {
                return result;
            }
        }
        throw new Error("Missing shape deserializers");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeAll = function (serializeds, manager) {
        var shapes = [];
        for (var i = 0, imax = serializeds.length; i < imax; ++i) {
            shapes.push(deserialize(serializeds[i], manager));
        }
        if (0 < shapes.length) {
            return Promise.all(shapes).then(function (resolved) {
                callOnDeserialized(serializeds, resolved, new EShapeUuidMappingImpl(resolved), manager);
                return resolved;
            });
        }
        return null;
    };
    var callOnDeserialized = function (serializeds, shapes, mapping, manager) {
        for (var i = 0, imax = serializeds.length; i < imax; ++i) {
            var serialized = serializeds[i];
            var shape = shapes[i];
            var onDeserialized = EShapeOnDeserializeds[serialized[0]];
            if (onDeserialized) {
                onDeserialized(serialized, shape, mapping, manager);
            }
            callOnDeserialized(serialized[20], shape.children, mapping, manager);
        }
    };

    var EShapeEmbeddedDatum = /** @class */ (function () {
        function EShapeEmbeddedDatum(name, width, height, layer) {
            this.name = name;
            this.width = width;
            this.height = height;
            this.layer = layer;
        }
        return EShapeEmbeddedDatum;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAcceptorImpl = /** @class */ (function () {
        function EShapeAcceptorImpl() {
            this._edges = new Map();
        }
        EShapeAcceptorImpl.prototype.add = function (id, type, x, y, nx, ny) {
            this._edges.set(id, {
                type: type,
                x: x,
                y: y,
                normal: this.toNormal(x, y, nx, ny)
            });
            return true;
        };
        EShapeAcceptorImpl.prototype.toNormal = function (x, y, nx, ny) {
            if (nx != null && ny != null) {
                return {
                    x: nx,
                    y: ny
                };
            }
            else {
                var d = x * x + y * y;
                if (0.00001 < d) {
                    var m = 1 / Math.sqrt(d);
                    return {
                        x: x * m,
                        y: y * m
                    };
                }
                else {
                    return {
                        x: 0,
                        y: 0
                    };
                }
            }
        };
        EShapeAcceptorImpl.prototype.remove = function (id) {
            var edges = this._edges;
            var result = edges.get(id);
            if (result != null) {
                edges.delete(id);
                return result;
            }
            return null;
        };
        EShapeAcceptorImpl.prototype.size = function () {
            return this._edges.size;
        };
        EShapeAcceptorImpl.prototype.get = function (shape, id) {
            return this._edges.get(id) || null;
        };
        EShapeAcceptorImpl.prototype.each = function (shape, iteratee) {
            this._edges.forEach(iteratee);
            return this;
        };
        EShapeAcceptorImpl.prototype.contains = function (id) {
            return this._edges.has(id);
        };
        EShapeAcceptorImpl.prototype.clear = function () {
            var edges = this._edges;
            if (0 < edges.size) {
                edges.clear();
                return true;
            }
            return false;
        };
        return EShapeAcceptorImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAcceptorType = {
        TAIL: 1,
        HEAD: 2,
        ALL: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeAcceptors = /** @class */ (function () {
        function EShapeAcceptors() {
        }
        EShapeAcceptors.set = function (type, acceptor) {
            var typeToAcceptor = this._typeToAcceptor;
            if (typeToAcceptor == null) {
                typeToAcceptor = new Map();
                this._typeToAcceptor = typeToAcceptor;
            }
            typeToAcceptor.set(type, acceptor);
        };
        EShapeAcceptors.get = function (type) {
            var _a;
            return ((_a = this._typeToAcceptor) === null || _a === void 0 ? void 0 : _a.get(type)) || this.getDefault();
        };
        EShapeAcceptors.getDefault = function () {
            var result = this._default;
            if (result == null) {
                result = this.newDefault();
                this._default = result;
            }
            return result;
        };
        EShapeAcceptors.newDefault = function () {
            var result = new EShapeAcceptorImpl();
            var s = 1 / Math.sqrt(2);
            result.add("TOP", EShapeAcceptorType.ALL, 0, -0.5, 0, -1);
            result.add("LEFT", EShapeAcceptorType.ALL, -0.5, 0, -1, 0);
            result.add("RIGHT", EShapeAcceptorType.ALL, 0.5, 0, 1, 0);
            result.add("BOTTOM", EShapeAcceptorType.ALL, 0, 0.5, 0, 1);
            result.add("CENTER", EShapeAcceptorType.ALL, 0, 0, 0, 0);
            result.add("TOP_LEFT", EShapeAcceptorType.ALL, -0.5, -0.5, -s, -s);
            result.add("TOP_RIGHT", EShapeAcceptorType.ALL, 0.5, -0.5, s, -s);
            result.add("BOTTOM_LEFT", EShapeAcceptorType.ALL, -0.5, 0.5, -s, s);
            result.add("BOTTOM_RIGHT", EShapeAcceptorType.ALL, 0.5, 0.5, s, s);
            return result;
        };
        return EShapeAcceptors;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorEdgeAcceptorImpl = /** @class */ (function () {
        function EShapeConnectorEdgeAcceptorImpl(parent) {
            this._parent = parent;
            this._shape = null;
            this._edge = null;
        }
        Object.defineProperty(EShapeConnectorEdgeAcceptorImpl.prototype, "shape", {
            get: function () {
                return this._shape;
            },
            set: function (shape) {
                this.set(shape);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeAcceptorImpl.prototype, "edge", {
            get: function () {
                return this._edge;
            },
            set: function (edge) {
                this.set(undefined, edge);
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorEdgeAcceptorImpl.prototype.copy = function (source) {
            return this.set(source.shape, source.edge);
        };
        EShapeConnectorEdgeAcceptorImpl.prototype.set = function (shape, edge) {
            var isChanged = false;
            if (shape !== undefined && this._shape !== shape) {
                this._shape = shape;
                isChanged = true;
            }
            if (edge !== undefined && this._edge !== edge) {
                this._edge = edge;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.onAcceptorChange();
            }
            return this;
        };
        return EShapeConnectorEdgeAcceptorImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorEdgeImpl = /** @class */ (function () {
        function EShapeConnectorEdgeImpl(parent, onChange) {
            var _this = this;
            this._parent = parent;
            this._onChange = onChange;
            this._acceptor = new EShapeConnectorEdgeAcceptorImpl(this);
            this._local = new pixi_js.ObservablePoint(function () {
                _this.onLocalChange();
            }, undefined);
            this._localIdRequired = 0;
            this._localId = 0;
            this._normal = new pixi_js.ObservablePoint(function () {
                _this.onNormalChange();
            }, undefined);
            this._normalIdRequired = 0;
            this._normalId = 0;
            this._margin = 0;
            this._lockCount = 0;
            this._isAcceptorChanged = false;
            this._isLocalChanged = false;
            this._isNormalChanged = false;
            this._isOtherChanged = false;
        }
        EShapeConnectorEdgeImpl.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isAcceptorChanged = false;
                this._isLocalChanged = false;
                this._isNormalChanged = false;
                this._isOtherChanged = false;
            }
        };
        EShapeConnectorEdgeImpl.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                var isChanged = false;
                if (this._isLocalChanged) {
                    this._localIdRequired += 1;
                    this._localId = this._localIdRequired;
                    isChanged = true;
                }
                if (this._isNormalChanged) {
                    this._normalIdRequired += 1;
                    this._normalId = this._normalIdRequired;
                    isChanged = true;
                }
                if (this._isOtherChanged) {
                    isChanged = true;
                }
                if (this._isAcceptorChanged) {
                    if (!this._isLocalChanged) {
                        this._localIdRequired += 1;
                    }
                    if (!this._isNormalChanged) {
                        this._normalIdRequired += 1;
                    }
                    if (this.doFit()) {
                        isChanged = false;
                    }
                }
                if (isChanged) {
                    this._onChange();
                }
            }
        };
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "acceptor", {
            get: function () {
                return this._acceptor;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "local", {
            get: function () {
                return this._local;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "localId", {
            get: function () {
                return this._localId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "normal", {
            get: function () {
                return this._normal;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "normalId", {
            get: function () {
                return this._normalId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeImpl.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            set: function (margin) {
                if (this._margin !== margin) {
                    this._margin = margin;
                    this.onOtherChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorEdgeImpl.prototype.set = function (shape, edge, margin, x, y, nx, ny) {
            this.lock();
            this._acceptor.set(shape, edge);
            var local = this._local;
            if (x != null && y != null) {
                local.set(x, y);
            }
            else if (x != null) {
                local.x = x;
            }
            else if (y != null) {
                local.y = y;
            }
            var normal = this._normal;
            if (nx != null && ny != null) {
                normal.set(nx, ny);
            }
            else if (nx != null) {
                normal.x = nx;
            }
            else if (ny != null) {
                normal.y = ny;
            }
            if (margin != null) {
                this.margin = margin;
            }
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeImpl.prototype.copy = function (source) {
            this.lock();
            this._acceptor.copy(source.acceptor);
            this._local.copyFrom(source.local);
            this._normal.copyFrom(source.normal);
            this.margin = source.margin;
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeImpl.prototype.serialize = function (manager) {
            var acceptor = this._acceptor;
            var shape = acceptor.shape;
            var shapeUuid = shape ? shape.uuid : null;
            var edge = acceptor.edge;
            var edgeId = edge != null ? manager.addResource(edge) : -1;
            var local = this._local;
            var normal = this._normal;
            return manager.addResource("[".concat(shapeUuid, ",").concat(edgeId, ",").concat(local.x, ",").concat(local.y, ",").concat(this._margin, ",").concat(normal.x, ",").concat(normal.y, "]"));
        };
        EShapeConnectorEdgeImpl.prototype.deserialize = function (resourceId, mapping, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                var shape = null;
                var shapeUuid = parsed[0];
                if (shapeUuid != null) {
                    shape = mapping.find(shapeUuid) || null;
                }
                this.lock();
                var acceptor = this._acceptor;
                acceptor.shape = shape;
                var edgeId = parsed[1];
                acceptor.edge = 0 <= edgeId && edgeId < resources.length ? resources[edgeId] : null;
                this._local.set(parsed[2], parsed[3]);
                var normalX = parsed[5];
                var normalY = parsed[6];
                var normal = this._normal;
                if (normalX != null && normalY != null) {
                    normal.set(normalX, normalY);
                }
                else {
                    normal.set(1, 0);
                }
                this.margin = parsed[4] || 0;
                this.unlock();
                if (shape) {
                    shape.connector.add(this);
                }
            }
        };
        EShapeConnectorEdgeImpl.prototype.fit = function (forcibly) {
            if (forcibly) {
                this._localIdRequired += 1;
                this._normalIdRequired += 1;
            }
            this.doFit();
            return this;
        };
        EShapeConnectorEdgeImpl.prototype.doFit = function () {
            var localIdRequired = this._localIdRequired;
            var isLocalDirty = this._localId !== localIdRequired;
            var normalIdRequired = this._normalIdRequired;
            var isNormalDirty = this._normalId !== normalIdRequired;
            if (isLocalDirty || isNormalDirty) {
                this._localId = localIdRequired;
                this._normalId = normalIdRequired;
                var acceptor = this._acceptor;
                var acceptorShape = acceptor.shape;
                var acceptorEdge = acceptor.edge;
                if (acceptorShape != null && acceptorEdge != null) {
                    var edge = EShapeAcceptors.get(acceptorShape.type).get(acceptorShape, acceptorEdge);
                    if (edge) {
                        var transform = this.toAcceptorTransform(acceptorShape);
                        var a = transform.a;
                        var b = transform.b;
                        var c = transform.c;
                        var d = transform.d;
                        var tx = transform.tx;
                        var ty = transform.ty;
                        this.lock();
                        if (isLocalDirty) {
                            var size = acceptorShape.size;
                            var pivot = acceptorShape.transform.pivot;
                            var lx = pivot.x + size.x * edge.x;
                            var ly = pivot.y + size.y * edge.y;
                            this._local.set(a * lx + c * ly + tx, b * lx + d * ly + ty);
                        }
                        if (isNormalDirty) {
                            var edgeNormal = edge.normal;
                            var nx = edgeNormal.x;
                            var ny = edgeNormal.y;
                            var x = a * nx + c * ny;
                            var y = b * nx + d * ny;
                            var l = x * x + y * y;
                            var normal = this._normal;
                            if (0.000001 < l) {
                                var f = 1 / Math.sqrt(l);
                                normal.set(x * f, y * f);
                            }
                            else {
                                normal.set(nx, ny);
                            }
                        }
                        var result = this._isLocalChanged || this._isNormalChanged;
                        this.unlock();
                        return result;
                    }
                }
            }
            return false;
        };
        EShapeConnectorEdgeImpl.prototype.toAcceptorTransform = function (shape) {
            var _a;
            shape.updateTransform();
            var parent = this._parent;
            var parentParent = parent.parent;
            if (parentParent) {
                parent.updateTransform();
                return ((_a = EShapeConnectorEdgeImpl.WORK_MATRIX) !== null && _a !== void 0 ? _a : (EShapeConnectorEdgeImpl.WORK_MATRIX = new pixi_js.Matrix()))
                    .copyFrom(parentParent.transform.worldTransform)
                    .invert()
                    .append(shape.transform.worldTransform);
            }
            else {
                return shape.transform.worldTransform;
            }
        };
        EShapeConnectorEdgeImpl.prototype.onAcceptorChange = function () {
            if (0 < this._lockCount) {
                this._isLocalChanged = false;
                this._isNormalChanged = false;
                this._isAcceptorChanged = true;
                return;
            }
            this.fit(true);
        };
        EShapeConnectorEdgeImpl.prototype.onLocalChange = function () {
            if (0 < this._lockCount) {
                this._isLocalChanged = true;
                return;
            }
            this._localIdRequired += 1;
            this._localId = this._localIdRequired;
            this._onChange();
        };
        EShapeConnectorEdgeImpl.prototype.onNormalChange = function () {
            if (0 < this._lockCount) {
                this._isNormalChanged = true;
                return;
            }
            this._normalIdRequired += 1;
            this._normalId = this._normalIdRequired;
            this._onChange();
        };
        EShapeConnectorEdgeImpl.prototype.onOtherChange = function () {
            if (0 < this._lockCount) {
                this._isOtherChanged = true;
                return;
            }
            this._onChange();
        };
        EShapeConnectorEdgeImpl.prototype.attach = function () {
            var shape = this._acceptor.shape;
            if (shape) {
                shape.connector.add(this);
            }
            return this;
        };
        EShapeConnectorEdgeImpl.prototype.detach = function () {
            var shape = this._acceptor.shape;
            if (shape) {
                shape.connector.remove(this);
            }
            return this;
        };
        return EShapeConnectorEdgeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorEdgeContainerImpl = /** @class */ (function () {
        function EShapeConnectorEdgeContainerImpl(parent, onChange) {
            var _this = this;
            this._parent = parent;
            this._lockCount = 0;
            this._isChanged = false;
            this._onChange = onChange;
            var onChangeBound = function () {
                _this.onChange();
            };
            this._tail = new EShapeConnectorEdgeImpl(parent, onChangeBound);
            this._head = new EShapeConnectorEdgeImpl(parent, onChangeBound);
        }
        EShapeConnectorEdgeContainerImpl.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isChanged = false;
            }
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isChanged) {
                    this._onChange();
                }
            }
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.onChange = function () {
            if (0 < this._lockCount) {
                this._isChanged = true;
                return;
            }
            this._onChange();
        };
        Object.defineProperty(EShapeConnectorEdgeContainerImpl.prototype, "tail", {
            get: function () {
                return this._tail;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorEdgeContainerImpl.prototype, "head", {
            get: function () {
                return this._head;
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorEdgeContainerImpl.prototype.copy = function (source) {
            this.lock();
            this._tail.copy(source.tail);
            this._head.copy(source.head);
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.fit = function (forcibly) {
            this.lock();
            this._tail.fit(forcibly);
            this._head.fit(forcibly);
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.serialize = function (manager) {
            var tailId = this._tail.serialize(manager);
            var headId = this._head.serialize(manager);
            return manager.addResource("[".concat(tailId, ",").concat(headId, "]"));
        };
        EShapeConnectorEdgeContainerImpl.prototype.deserialize = function (resourceId, mapping, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.lock();
                this._tail.deserialize(parsed[0], mapping, manager);
                this._head.deserialize(parsed[1], mapping, manager);
                this.unlock();
            }
        };
        EShapeConnectorEdgeContainerImpl.prototype.attach = function () {
            this.lock();
            var tail = this._tail;
            var head = this._head;
            tail.attach();
            head.attach();
            tail.fit(true);
            head.fit(true);
            this.unlock();
            return this;
        };
        EShapeConnectorEdgeContainerImpl.prototype.detach = function () {
            this.lock();
            this._tail.detach();
            this._head.detach();
            this.unlock();
            return this;
        };
        return EShapeConnectorEdgeContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toIndexOf = function (array, value) {
        var i0 = 0;
        var i1 = array.length - 1;
        while (i0 <= i1) {
            var i2 = i0 + ((i1 - i0) >> 1);
            var v2 = array[i2];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return -1;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toPointsBoundary = function (values, result) {
        var valuesLength = values.length;
        if (2 <= valuesLength) {
            var xmin = values[0];
            var ymin = values[1];
            var xmax = xmin;
            var ymax = ymin;
            for (var i = 2, imax = values.length; i < imax; i += 2) {
                var x = values[i];
                var y = values[i + 1];
                xmin = Math.min(xmin, x);
                ymin = Math.min(ymin, y);
                xmax = Math.max(xmax, x);
                ymax = Math.max(ymax, y);
            }
            result[0] = xmin;
            result[1] = ymin;
            result[2] = xmax;
            result[3] = ymax;
        }
        else {
            result[0] = 0;
            result[1] = 0;
            result[2] = 0;
            result[3] = 0;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerBase = /** @class */ (function () {
        function EShapePointsMarkerBase(parent) {
            var _this = this;
            this._parent = parent;
            this._lockCount = 0;
            this._isTypeChanged = false;
            this._isSizeChanged = false;
            this._isFillChanged = false;
            this._type = EShapePointsMarkerType.NONE;
            this._size = new pixi_js.ObservablePoint(function () {
                _this.onSizeChange();
            }, undefined, EShapeDefaults.SIZE_X * 0.15, EShapeDefaults.SIZE_Y * 0.15);
            this._fill = this.newFill();
            this._transformId = 0;
        }
        EShapePointsMarkerBase.prototype.newFill = function () {
            return new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, 1);
        };
        EShapePointsMarkerBase.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        };
        EShapePointsMarkerBase.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isTypeChanged) {
                    this.onTypeChange();
                }
                else if (this._isSizeChanged) {
                    this.onSizeChange();
                }
                else if (this._isFillChanged) {
                    this.onFillChange();
                }
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        };
        Object.defineProperty(EShapePointsMarkerBase.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (type) {
                if (this._type !== type) {
                    this._type = type;
                    this.onTypeChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerBase.prototype.onTypeChange = function () {
            if (0 < this._lockCount) {
                this._isTypeChanged = true;
                return;
            }
            this._parent.onTypeChange();
        };
        Object.defineProperty(EShapePointsMarkerBase.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerBase.prototype.onSizeChange = function () {
            if (0 < this._lockCount) {
                this._isSizeChanged = true;
                return;
            }
            this._parent.onSizeChange();
        };
        Object.defineProperty(EShapePointsMarkerBase.prototype, "transform", {
            get: function () {
                return this.updateTransform();
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerBase.prototype.updateTransform = function () {
            var result = this._transform;
            if (result == null) {
                result = new pixi_js.Matrix();
                this._transform = result;
            }
            var parentParent = this._parent.parent;
            var id = parentParent.id;
            if (this._transformId !== id) {
                this._transformId = id;
                var formatted = parentParent.formatted;
                if (2 <= formatted.length) {
                    this.toTransform(formatted.values, result);
                }
                else {
                    result.identity();
                }
            }
            return result;
        };
        EShapePointsMarkerBase.prototype.toTransformMatrix = function (x0, y0, x1, y1, result) {
            var dx = x0 - x1;
            var dy = y0 - y1;
            var n = dx * dx + dy * dy;
            if (0.00001 < n) {
                var f = 1 / Math.sqrt(n);
                var nx = dx * f;
                var ny = dy * f;
                result.set(ny, -nx, -nx, -ny, x0, y0);
            }
            else {
                result.set(1, 0, 0, 1, x0, y0);
            }
            return result;
        };
        Object.defineProperty(EShapePointsMarkerBase.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerBase.prototype.onFillChange = function () {
            if (0 < this._lockCount) {
                this._isFillChanged = true;
                return;
            }
            this._parent.onFillChange();
        };
        EShapePointsMarkerBase.prototype.updateUploaded = function () {
            this.onFillChange();
        };
        EShapePointsMarkerBase.prototype.copy = function (source) {
            var size = source.size;
            this.set(source.type, size.x, size.y);
            return this;
        };
        EShapePointsMarkerBase.prototype.set = function (type, sizeX, sizeY) {
            this.lock();
            if (type != null) {
                this.type = type;
            }
            this.size.set(sizeX, sizeY);
            this.unlock();
            return this;
        };
        EShapePointsMarkerBase.prototype.serialize = function (manager) {
            var size = this._size;
            var fillId = this._fill.serialize(manager);
            return manager.addResource("[".concat(this._type, ",").concat(size.x, ",").concat(size.y, ",").concat(fillId, "]"));
        };
        EShapePointsMarkerBase.prototype.deserialize = function (resourceId, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.lock();
                this.type = parsed[0];
                this._size.set(parsed[1], parsed[2]);
                this._fill.deserialize(parsed[3], manager);
                this.unlock();
            }
        };
        return EShapePointsMarkerBase;
    }());

    var EShapePointsMarkerHead = /** @class */ (function (_super) {
        __extends(EShapePointsMarkerHead, _super);
        function EShapePointsMarkerHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapePointsMarkerHead.prototype.toTransform = function (values, result) {
            var valuesLength = values.length;
            if (4 <= valuesLength) {
                return this.toTransformMatrix(values[valuesLength - 2], values[valuesLength - 1], values[valuesLength - 4], values[valuesLength - 3], result);
            }
            else {
                result.identity();
            }
            return result;
        };
        return EShapePointsMarkerHead;
    }(EShapePointsMarkerBase));

    var EShapePointsMarkerTail = /** @class */ (function (_super) {
        __extends(EShapePointsMarkerTail, _super);
        function EShapePointsMarkerTail() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapePointsMarkerTail.prototype.toTransform = function (values, result) {
            var valuesLength = values.length;
            if (4 <= valuesLength) {
                return this.toTransformMatrix(values[0], values[1], values[2], values[3], result);
            }
            else {
                result.identity();
            }
            return result;
        };
        return EShapePointsMarkerTail;
    }(EShapePointsMarkerBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsMarkerContainerImpl = /** @class */ (function () {
        function EShapePointsMarkerContainerImpl(parent) {
            this._parent = parent;
            this._lockCount = 0;
            this._isTypeChanged = false;
            this._isSizeChanged = false;
            this._isFillChanged = false;
            this._head = new EShapePointsMarkerHead(this);
            this._tail = new EShapePointsMarkerTail(this);
        }
        EShapePointsMarkerContainerImpl.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        };
        EShapePointsMarkerContainerImpl.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isTypeChanged) {
                    this.onTypeChange();
                }
                else if (this._isSizeChanged) {
                    this.onSizeChange();
                }
                else if (this._isFillChanged) {
                    this.onFillChange();
                }
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        };
        Object.defineProperty(EShapePointsMarkerContainerImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerContainerImpl.prototype, "head", {
            get: function () {
                return this._head;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapePointsMarkerContainerImpl.prototype, "tail", {
            get: function () {
                return this._tail;
            },
            enumerable: false,
            configurable: true
        });
        EShapePointsMarkerContainerImpl.prototype.onTypeChange = function () {
            if (0 < this._lockCount) {
                this._isTypeChanged = true;
                return;
            }
            this._parent.onMarkerTypeChange();
        };
        EShapePointsMarkerContainerImpl.prototype.onSizeChange = function () {
            if (0 < this._lockCount) {
                this._isSizeChanged = true;
                return;
            }
            this._parent.onMarkerSizeChange();
        };
        EShapePointsMarkerContainerImpl.prototype.onFillChange = function () {
            if (0 < this._lockCount) {
                this._isFillChanged = true;
                return;
            }
            this._parent.onMarkerFillChange();
        };
        EShapePointsMarkerContainerImpl.prototype.copy = function (source) {
            this.lock();
            this._head.copy(source.head);
            this._tail.copy(source.tail);
            this.unlock();
            return this;
        };
        EShapePointsMarkerContainerImpl.prototype.serialize = function (manager) {
            var headId = this._head.serialize(manager);
            var tailId = this._tail.serialize(manager);
            return manager.addResource("[".concat(headId, ",").concat(tailId, "]"));
        };
        EShapePointsMarkerContainerImpl.prototype.deserialize = function (resourceId, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.lock();
                this._head.deserialize(parsed[0], manager);
                this._tail.deserialize(parsed[1], manager);
                this.unlock();
            }
        };
        return EShapePointsMarkerContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var PID = Math.PI * 2;
    var PIH = Math.PI * 0.5;
    var vdot = function (x0, y0, x1, y1) {
        return x0 * x1 + y0 * y1;
    };
    var vlen = function (x0, y0) {
        return Math.sqrt(vdot(x0, y0, x0, y0));
    };
    var vcross = function (x0, y0, x1, y1) {
        return x0 * y1 - y0 * x1;
    };
    var pnew = function () {
        return {
            center: [0, 0],
            axis1: [0, 0],
            axis2: [0, 0],
            angle: [0, 0, 0]
        };
    };
    var pset = function (cx, cy, a1x, a1y, a2x, a2y, angle1, angle2, angle3, result) {
        var c = result.center;
        c[0] = cx;
        c[1] = cy;
        var a1 = result.axis1;
        a1[0] = a1x;
        a1[1] = a1y;
        var a2 = result.axis2;
        a2[0] = a2x;
        a2[1] = a2y;
        var a = result.angle;
        a[0] = angle1;
        a[1] = angle2;
        a[2] = angle3;
        return result;
    };
    var pcopy = function (source, result) {
        var c = source.center;
        var a1 = source.axis1;
        var a2 = source.axis2;
        var a = source.angle;
        return pset(c[0], c[1], a1[0], a1[1], a2[0], a2[1], a[0], a[1], a[2], result);
    };
    var acopy = function (source, result) {
        var sourceLength = source.length;
        for (var i = 0; i < sourceLength; ++i) {
            result[i] = source[i];
        }
        if (result.length !== sourceLength) {
            result.length = sourceLength;
        }
        return result;
    };
    /**
     * An utility class for spline curves based on the work of Cem Yuksel.
     * Pleaase refer to the paper `A class of C2 interpolating splines`.
     * http://www.cemyuksel.com/research/interpolating_splines/
     */
    var UtilCurve = /** @class */ (function () {
        function UtilCurve() {
        }
        UtilCurve.set = function (center1, angle10, angle11, axis11, axis12, center2, angle20, angle21, axis21, axis22, nsegment, isAdaptive, isEdge, result, resultIndex) {
            var a = Math.max(Math.abs(angle10 - angle11), Math.abs(angle20 - angle21));
            var n = isAdaptive ? Math.max(1, Math.round(nsegment * (a / PIH))) : nsegment;
            var imax = isEdge ? n + 1 : n;
            for (var i = 0; i < imax; ++i) {
                var t = i / n;
                var w0 = 1 - t;
                var w1 = t;
                var t1 = w0 * angle10 + w1 * angle11;
                var c1 = Math.cos(t1);
                var s1 = Math.sin(t1);
                var x1 = center1[0] + c1 * axis11[0] + s1 * axis12[0];
                var y1 = center1[1] + c1 * axis11[1] + s1 * axis12[1];
                var t2 = w0 * angle20 + w1 * angle21;
                var c2 = Math.cos(t2);
                var s2 = Math.sin(t2);
                var x2 = center2[0] + c2 * axis21[0] + s2 * axis22[0];
                var y2 = center2[1] + c2 * axis21[1] + s2 * axis22[1];
                var t3 = PIH * t;
                var c3 = Math.cos(t3);
                var s3 = Math.sin(t3);
                var cc3 = c3 * c3;
                var ss3 = s3 * s3;
                var x3 = cc3 * x1 + ss3 * x2;
                var y3 = cc3 * y1 + ss3 * y2;
                result[++resultIndex] = x3;
                result[++resultIndex] = y3;
            }
            return resultIndex;
        };
        /**
         * Calculate an interpolated points of the given control points.
         *
         * @param length A number of control points.
         * @param values An array of control points.
         * @param toParameter An interpolation method.
         * @param isClosed True if the line is closed.
         * @param nsegment The number of segments per 90 degree if isAdaptive is true.
         * If isAdaptive is false, the number of segments is fixed to the given number
         * regardless of arc angles.
         * @param isAdaptive True to adjust the number of segments adaptively.
         * @returns An interpolated points of the given control points.
         */
        UtilCurve.interpolate = function (length, values, segments, toParameter, isClosed, nsegment, isAdaptive, result) {
            var rvalues = result.values;
            var rsegments = result.segments;
            if (length <= 2) {
                acopy(values, rvalues);
                acopy(segments, rsegments);
                return result;
            }
            var c0 = this.WORK_P0 || pnew();
            var c1 = this.WORK_P1 || pnew();
            var c2 = this.WORK_P2 || pnew();
            this.WORK_P0 = c0;
            this.WORK_P1 = c1;
            this.WORK_P2 = c2;
            var rvaluesCount = -1;
            var rsegmentCount = -1;
            if (isClosed) {
                toParameter(0, length, values, c0);
                pcopy(c0, c1);
                for (var i = 1; i < length; ++i) {
                    toParameter(i, length, values, c2);
                    if (0 <= toIndexOf(segments, i)) {
                        var index = (i - 1) << 1;
                        rvalues[++rvaluesCount] = values[index + 0];
                        rvalues[++rvaluesCount] = values[index + 1];
                        rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                    }
                    else {
                        rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c2.center, c2.angle[0], c2.angle[1], c2.axis1, c2.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                    }
                    var c3 = c1;
                    c1 = c2;
                    c2 = c3;
                }
                if (0 <= toIndexOf(segments, 0)) {
                    var index = (length - 1) << 1;
                    rvalues[++rvaluesCount] = values[index + 0];
                    rvalues[++rvaluesCount] = values[index + 1];
                    rsegments.unshift(0);
                    rsegmentCount += 1;
                }
                else {
                    rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                }
            }
            else {
                toParameter(1, length, values, c0);
                if (0 <= toIndexOf(segments, 1)) {
                    rvalues[++rvaluesCount] = values[0];
                    rvalues[++rvaluesCount] = values[1];
                    rsegments[++rsegmentCount] = 1;
                }
                else {
                    rvaluesCount = this.set(c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                }
                pcopy(c0, c1);
                for (var i = 2, imax = length - 1; i < imax; ++i) {
                    toParameter(i, length, values, c2);
                    if (0 <= toIndexOf(segments, i)) {
                        var index = (i - 1) << 1;
                        rvalues[++rvaluesCount] = values[index + 0];
                        rvalues[++rvaluesCount] = values[index + 1];
                        rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                    }
                    else {
                        rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c2.center, c2.angle[0], c2.angle[1], c2.axis1, c2.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                    }
                    var c3 = c1;
                    c1 = c2;
                    c2 = c3;
                }
                if (0 <= toIndexOf(segments, length - 1)) {
                    var index = (length - 2) << 1;
                    rvalues[++rvaluesCount] = values[index + 0];
                    rvalues[++rvaluesCount] = values[index + 1];
                    rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                }
                else {
                    rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, nsegment, isAdaptive, true, rvalues, rvaluesCount);
                }
            }
            rvaluesCount += 1;
            if (rvalues.length !== rvaluesCount) {
                rvalues.length = rvaluesCount;
            }
            rsegmentCount += 1;
            if (rsegments.length !== rsegmentCount) {
                rsegments.length = rsegmentCount;
            }
            return result;
        };
        UtilCurve.toCircle = function (index, length, values, result) {
            var index0 = 0 < index ? index - 1 : length - 1;
            var index1 = index;
            var index2 = index < length - 1 ? index + 1 : 0;
            var i0 = index0 << 1;
            var i1 = index1 << 1;
            var i2 = index2 << 1;
            var x0 = values[i0 + 0];
            var y0 = values[i0 + 1];
            var x1 = values[i1 + 0];
            var y1 = values[i1 + 1];
            var x2 = values[i2 + 0];
            var y2 = values[i2 + 1];
            var d01x = x1 - x0;
            var d01y = y1 - y0;
            var d12x = x2 - x1;
            var d12y = y2 - y1;
            var m1x = x0 + d01x * 0.5;
            var m1y = y0 + d01y * 0.5;
            var m2x = x1 + d12x * 0.5;
            var m2y = y1 + d12y * 0.5;
            var n1x = -d01y;
            var n1y = +d01x;
            var n2x = -d12y;
            var n2y = +d12x;
            var det = vcross(n1x, n1y, n2x, n2y);
            var threshold = 0.001;
            if (Math.abs(det) < threshold) {
                if (0 <= vdot(d01x, d01y, d12x, d12y) || length <= 2) {
                    var a = 0.01;
                    var s_1 = Math.sin(a);
                    var l1 = vlen(d01x, d01y);
                    var l2 = vlen(d12x, d12y);
                    return pset(x1, y1, 0, 0, d12x / s_1, d12y / s_1, (-a * l1) / l2, 0, a, result);
                }
                else {
                    det = threshold;
                }
            }
            var s = (n2y * (m2x - m1x) + n2x * (m1y - m2y)) / det;
            var cx = m1x + s * n1x;
            var cy = m1y + s * n1y;
            var a1x = x1 - cx;
            var a1y = y1 - cy;
            var a2x = -a1y;
            var a2y = +a1x;
            var dc2x = x2 - cx;
            var dc2y = y2 - cy;
            var a2 = Math.atan2(vdot(a2x, a2y, dc2x, dc2y), vdot(a1x, a1y, dc2x, dc2y));
            var dc0x = x0 - cx;
            var dc0y = y0 - cy;
            var a1 = Math.atan2(vdot(a2x, a2y, dc0x, dc0y), vdot(a1x, a1y, dc0x, dc0y));
            if (0 < a1 * a2) {
                if (Math.abs(a1) < Math.abs(a2)) {
                    if (0 < a2) {
                        a2 -= PID;
                    }
                    else {
                        a2 += PID;
                    }
                }
                if (Math.abs(a2) < Math.abs(a1)) {
                    if (0 < a1) {
                        a1 -= PID;
                    }
                    else {
                        a1 += PID;
                    }
                }
            }
            return pset(cx, cy, a1x, a1y, a2x, a2y, a1, 0, a2, result);
        };
        UtilCurve.toEllipse = function (index, length, values, result) {
            var index0 = 0 < index ? index - 1 : length - 1;
            var index1 = index;
            var index2 = index < length - 1 ? index + 1 : 0;
            var i0 = index0 << 1;
            var i1 = index1 << 1;
            var i2 = index2 << 1;
            var x0 = values[i0 + 0];
            var y0 = values[i0 + 1];
            var x1 = values[i1 + 0];
            var y1 = values[i1 + 1];
            var x2 = values[i2 + 0];
            var y2 = values[i2 + 1];
            var d10x = x0 - x1;
            var d10y = y0 - y1;
            var d12x = x2 - x1;
            var d12y = y2 - y1;
            if (length <= 2) {
                var a_1 = 0.01;
                var s = Math.sin(a_1);
                return pset(x1, y1, 0, 0, d12x / s, d12y / s, -a_1, 0, a_1, result);
            }
            var l0 = vlen(d10x, d10y);
            var l2 = vlen(d12x, d12y);
            var cos = vdot(d10x, d10y, d12x, d12y) / (l0 * l2);
            var amax = Math.acos(cos);
            var acurrent = amax * 0.5;
            var adelta = amax * 0.25;
            var a = 0;
            var b = 0;
            var c = 0;
            var d = 0;
            var lmax = Math.max(l0, l2);
            var lmin = Math.min(l0, l2);
            for (var i = 0; i < 16; ++i) {
                var a0 = acurrent * 0.5;
                var a1 = amax - a0;
                a = lmax * Math.sin(a0);
                b = lmax * Math.cos(a0);
                c = lmin * Math.sin(a1);
                d = lmin * Math.cos(a1);
                var v = (1 - d / b) * (1 - d / b) + (c * c) / (a * a);
                if (1 < v) {
                    acurrent += adelta;
                }
                else {
                    acurrent -= adelta;
                }
                adelta *= 0.5;
            }
            var beta = Math.asin(Math.min(c / a, 1));
            if (l0 < l2) {
                var e3x = d12x / l2;
                var e3y = d12y / l2;
                var n3x = void 0, n3y = void 0;
                if (0 < vcross(d10x, d10y, d12x, d12y)) {
                    n3x = +e3y;
                    n3y = -e3x;
                }
                else {
                    n3x = -e3y;
                    n3y = +e3x;
                }
                var we = -(b * b) / l2;
                var wn = -(b * a) / l2;
                var a1x = we * e3x + wn * n3x;
                var a1y = we * e3y + wn * n3y;
                var cx = x1 - a1x;
                var cy = y1 - a1y;
                var a2x = x2 - cx;
                var a2y = y2 - cy;
                return pset(cx, cy, a1x, a1y, a2x, a2y, -beta, 0, PIH, result);
            }
            else {
                var e0x = d10x / l0;
                var e0y = d10y / l0;
                var n3x = void 0, n3y = void 0;
                if (vcross(d10x, d10y, d12x, d12y) < 0) {
                    n3x = +e0y;
                    n3y = -e0x;
                }
                else {
                    n3x = -e0y;
                    n3y = +e0x;
                }
                var we = -(b * b) / l0;
                var wn = -(b * a) / l0;
                var a1x = we * e0x + wn * n3x;
                var a1y = we * e0y + wn * n3y;
                var cx = x1 - a1x;
                var cy = y1 - a1y;
                var a2x = x0 - cx;
                var a2y = y0 - cy;
                return pset(cx, cy, a1x, a1y, -a2x, -a2y, -PIH, 0, beta, result);
            }
        };
        UtilCurve.toHybrid = function (index, length, values, result) {
            var circle = UtilCurve.toCircle(index, length, values, result);
            var a0 = circle.angle[0];
            var a2 = circle.angle[2];
            var amin = Math.min(a0, a2);
            var amax = Math.max(a0, a2);
            if (amin < -PIH || PIH < amax) {
                return UtilCurve.toEllipse(index, length, values, result);
            }
            return circle;
        };
        return UtilCurve;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var eShapePointsFormatterCurve = function (length, values, segments, style, result) {
        UtilCurve.interpolate(length, values, segments, UtilCurve.toHybrid, !!(style & EShapePointsStyle.CLOSED), EShapeDefaults.CURVE_SEGMENT_COUNT, true, result);
        result.length = result.values.length >> 1;
        result.style = style;
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapePointsFormatters = /** @class */ (function () {
        function EShapePointsFormatters() {
        }
        EShapePointsFormatters.set = function (id, datum) {
            if (this.data == null) {
                this.data = this.newData();
            }
            this.data.set(id, datum);
        };
        EShapePointsFormatters.get = function (index) {
            if (this.data == null) {
                this.data = this.newData();
            }
            return this.data.get(index);
        };
        EShapePointsFormatters.each = function (iteratee) {
            if (this.data == null) {
                this.data = this.newData();
            }
            this.data.forEach(function (datum, id) {
                iteratee(id, datum);
            });
        };
        EShapePointsFormatters.find = function (style) {
            return this.get((style & EShapePointsStyle.FORMATTER_MASK) >> EShapePointsStyle.FORMATTER_SHIFT);
        };
        EShapePointsFormatters.newData = function () {
            var result = new Map();
            result.set(EShapePointsStyle.FORMATTER_CURVE, {
                label: "Curve",
                formatter: eShapePointsFormatterCurve
            });
            return result;
        };
        return EShapePointsFormatters;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLinePoints = /** @class */ (function () {
        function EShapeLinePoints(parent) {
            this._parent = parent;
            this._valuesBaseLength = 0;
            this._values = [];
            this._segments = [];
            var parentSize = parent.size;
            var parentSizeX = parentSize.x;
            var parentSizeY = parentSize.y;
            this._parentSizeBase = new pixi_js.Point(parentSizeX, parentSizeY);
            this._parentSizeFitted = new pixi_js.Point(parentSizeX, parentSizeY);
            this._id = 0;
            this._style = EShapePointsStyle.NONE;
            this._formattedId = -1;
        }
        Object.defineProperty(EShapeLinePoints.prototype, "length", {
            get: function () {
                return this._values.length >> 1;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLinePoints.prototype.toFitted = function (x, y) {
            this._valuesBase = undefined;
            this._parentSizeFitted.set(x, y);
            this._parentSizeBase.set(x, y);
        };
        EShapeLinePoints.prototype.onSizeChange = function () {
            this.fit();
        };
        EShapeLinePoints.prototype.fit = function () {
            var parent = this._parent;
            var psizef = this._parentSizeFitted;
            var psize = parent.size;
            var psizeX = psize.x;
            var psizeY = psize.y;
            var threshold = 0.00001;
            if (Math.abs(psizeX - psizef.x) <= threshold && Math.abs(psizeY - psizef.y) <= threshold) {
                return;
            }
            psizef.set(psizeX, psizeY);
            var psizeBase = this._parentSizeBase;
            var isValidX = threshold < Math.abs(psizeBase.x);
            var isValidY = threshold < Math.abs(psizeBase.y);
            if (!isValidX && !isValidY) {
                return;
            }
            var scaleX = isValidX ? psizeX / psizeBase.x : 1;
            var scaleY = isValidY ? psizeY / psizeBase.y : 1;
            // Values
            var values = this._values;
            var valuesBase = this._valuesBase;
            if (valuesBase == null) {
                valuesBase = [];
                this._valuesBase = valuesBase;
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    var x = values[i];
                    var y = values[i + 1];
                    values[i] = x * scaleX;
                    values[i + 1] = y * scaleY;
                    valuesBase.push(x, y);
                }
            }
            else {
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    values[i] = valuesBase[i] * scaleX;
                    values[i + 1] = valuesBase[i + 1] * scaleY;
                }
            }
            // Invalidate
            this._id += 1;
            if (this._formatter || this._style & EShapePointsStyle.FORMATTER_MASK) {
                var uploaded = parent.uploaded;
                if (uploaded && !uploaded.isCompatible(parent)) {
                    parent.uploaded = undefined;
                    parent.toDirty();
                }
            }
        };
        Object.defineProperty(EShapeLinePoints.prototype, "id", {
            get: function () {
                this.fit();
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "values", {
            get: function () {
                this.fit();
                return this._values;
            },
            set: function (values) {
                this.set(values, undefined, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            /**
             * Must be sorted in ascending order.
             */
            set: function (segments) {
                this.set(undefined, segments, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "style", {
            get: function () {
                return this._style;
            },
            set: function (style) {
                this.set(undefined, undefined, style);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "marker", {
            get: function () {
                var result = this._marker;
                if (result == null) {
                    result = this.newMarker();
                    this._marker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLinePoints.prototype.getMarker = function () {
            return this._marker;
        };
        EShapeLinePoints.prototype.newMarker = function () {
            return new EShapePointsMarkerContainerImpl(this);
        };
        EShapeLinePoints.prototype.onMarkerTypeChange = function () {
            var parent = this._parent;
            parent.uploaded = undefined;
            parent.toDirty();
        };
        EShapeLinePoints.prototype.onMarkerSizeChange = function () {
            this._parent.updateUploaded();
        };
        EShapeLinePoints.prototype.onMarkerFillChange = function () {
            this._parent.updateUploaded();
        };
        Object.defineProperty(EShapeLinePoints.prototype, "formatter", {
            get: function () {
                return this._formatter || null;
            },
            set: function (formatter) {
                if (this._formatter !== formatter) {
                    this._formattedId = -1;
                    this._formatter = formatter;
                    this.toDirty(true);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLinePoints.prototype, "formatted", {
            get: function () {
                var _a, _b;
                this.fit();
                var id = this._id;
                var result = this._formatted;
                if (this._formattedId !== id) {
                    this._formattedId = id;
                    var style = this._style;
                    var formatter = (_a = this._formatter) !== null && _a !== void 0 ? _a : (_b = EShapePointsFormatters.find(style)) === null || _b === void 0 ? void 0 : _b.formatter;
                    if (formatter != null) {
                        if (result == null) {
                            result = {
                                length: 0,
                                values: [],
                                segments: [],
                                boundary: [0, 0, 0, 0],
                                style: EShapePointsStyle.NONE
                            };
                        }
                        var values = this._values;
                        var segments = this._segments;
                        var length_1 = values.length >> 1;
                        formatter(length_1, values, segments, style, result);
                        toPointsBoundary(result.values, result.boundary);
                    }
                    else {
                        result = undefined;
                    }
                    this._formatted = result;
                }
                return result || this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLinePoints.prototype.toScaled = function (values, valuesBase, boundary, boundaryBase) {
            var size = this._parentSizeFitted;
            var sizeBase = this._parentSizeBase;
            var threshold = 0.00001;
            var hasSizeBaseX = threshold < Math.abs(sizeBase.x);
            var hasSizeBaseY = threshold < Math.abs(sizeBase.y);
            if (hasSizeBaseX || hasSizeBaseY) {
                var scaleX = hasSizeBaseX ? size.x / sizeBase.x : 1;
                var scaleY = hasSizeBaseY ? size.y / sizeBase.y : 1;
                for (var i = 0, imax = valuesBase.length; i < imax; i += 2) {
                    values[i] = valuesBase[i] * scaleX;
                    values[i + 1] = valuesBase[i + 1] * scaleY;
                }
                for (var i = 0, imax = boundaryBase.length; i < imax; i += 2) {
                    boundary[i] = boundaryBase[i] * scaleX;
                    boundary[i + 1] = boundaryBase[i + 1] * scaleY;
                }
            }
        };
        EShapeLinePoints.prototype.copy = function (source) {
            this.set(source.values, source.segments, source.style);
            var marker = source.getMarker();
            if (marker) {
                this.marker.copy(marker);
            }
            return this;
        };
        EShapeLinePoints.prototype.set = function (newValues, newSegments, newStyle) {
            var isDirty = false;
            var isUpdated = false;
            // Formatter
            var style = this._style;
            var styleFormatter = style & EShapePointsStyle.FORMATTER_MASK;
            var formatter = this._formatter;
            // Values
            if (newValues != null) {
                var values = this._values;
                var valuesBaseLength = this._valuesBaseLength;
                var newValuesLength = newValues.length;
                var iupdate = Math.min(newValuesLength, valuesBaseLength);
                var parentSize = this._parent.size;
                this.toFitted(parentSize.x, parentSize.y);
                if (values !== newValues) {
                    for (var i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (var i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesBaseLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            isDirty = true;
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                }
                else {
                    if (valuesBaseLength !== newValuesLength) {
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            isDirty = true;
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                }
            }
            // Segments
            if (newSegments != null) {
                var segments = this._segments;
                if (segments !== newSegments) {
                    var newSegmentsLength = newSegments.length;
                    var iupdate = Math.min(segments.length, newSegmentsLength);
                    for (var i = 0; i < iupdate; ++i) {
                        segments[i] = newSegments[i];
                    }
                    for (var i = iupdate; i < newSegmentsLength; ++i) {
                        segments.push(newSegments[i]);
                    }
                    if (segments.length !== newSegmentsLength) {
                        segments.length = newSegmentsLength;
                    }
                }
                if (formatter != null || styleFormatter) {
                    isDirty = true;
                }
                else {
                    isUpdated = true;
                }
            }
            // Style
            if (newStyle != null) {
                if (style !== newStyle) {
                    var newStyleFormatter = newStyle & EShapePointsStyle.FORMATTER_MASK;
                    if (styleFormatter !== newStyleFormatter) {
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            var styleClosed = style & EShapePointsStyle.CLOSED;
                            var newStyleClosed = newStyle & EShapePointsStyle.CLOSED;
                            if (styleClosed !== newStyleClosed) {
                                isDirty = true;
                            }
                            else {
                                isUpdated = true;
                            }
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                    this._style = newStyle;
                }
            }
            //
            if (isUpdated || isDirty) {
                this.toDirty(isDirty);
            }
            return this;
        };
        EShapeLinePoints.prototype.toDirty = function (revalidate) {
            if (revalidate) {
                this._id += 1;
                var parent_1 = this._parent;
                var uploaded = parent_1.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent_1)) {
                        parent_1.updateUploaded();
                    }
                    else {
                        parent_1.uploaded = undefined;
                        parent_1.toDirty();
                    }
                }
                else {
                    parent_1.updateUploaded();
                }
            }
            else {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLinePoints.prototype.clone = function (parent) {
            return new EShapeLinePoints(parent).copy(this);
        };
        EShapeLinePoints.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeLinePoints.prototype.serialize = function (manager) {
            var values = JSON.stringify(this._values);
            var segments = JSON.stringify(this._segments);
            var style = this._style;
            var markerId = -1;
            var marker = this._marker;
            if (marker) {
                markerId = marker.serialize(manager);
            }
            return manager.addResource("[".concat(values, ",").concat(segments, ",").concat(style, ",").concat(markerId, "]"));
        };
        EShapeLinePoints.prototype.deserialize = function (resourceId, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.set(parsed[0], parsed[1], parsed[2]);
                var markerId = parsed[3];
                if (markerId != null && 0 <= markerId) {
                    this.marker.deserialize(markerId, manager);
                }
            }
        };
        EShapeLinePoints.prototype.calcHitPointAbs = function (x, y, ax, ay, threshold, toRange, tester, result) {
            var formatted = this.formatted;
            var length = formatted.length;
            if (2 <= length) {
                var values = formatted.values;
                var segments = formatted.segments;
                var style = formatted.style;
                var istart = 0;
                var iend = length;
                if (toRange) {
                    var work = EShapeLinePoints.WORK_RANGE;
                    toRange(x, y, threshold, values, work);
                    istart = work[0];
                    iend = work[1];
                }
                for (var i = istart, imax = Math.min(iend, length - 1); i < imax; ++i) {
                    if (toIndexOf(segments, i + 1) < 0) {
                        var iv = i << 1;
                        var p0x = values[iv + 0];
                        var p0y = values[iv + 1];
                        var p1x = values[iv + 2];
                        var p1y = values[iv + 3];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
                if (2 < length && length <= iend && style & EShapePointsStyle.CLOSED) {
                    if (toIndexOf(segments, 0) < 0) {
                        var i = length - 1;
                        var iv = i << 1;
                        var p0x = values[iv + 0];
                        var p0y = values[iv + 1];
                        var p1x = values[0];
                        var p1y = values[1];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        EShapeLinePoints.WORK_RANGE = [0, 0];
        return EShapeLinePoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorBodyImpl = /** @class */ (function () {
        function EShapeConnectorBodyImpl(parent, onChange) {
            this._parent = parent;
            this._id = 0;
            this._values = [];
            this._lockCount = 0;
            this._isChanged = false;
            this._onChange = onChange;
        }
        EShapeConnectorBodyImpl.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isChanged = false;
            }
        };
        EShapeConnectorBodyImpl.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isChanged) {
                    this.onChange();
                }
                this._isChanged = false;
            }
        };
        Object.defineProperty(EShapeConnectorBodyImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorBodyImpl.prototype, "values", {
            get: function () {
                return this._values;
            },
            set: function (newValues) {
                this.set(newValues);
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorBodyImpl.prototype.set = function (newValues) {
            if (newValues != null) {
                this._id += 1;
                if (this._values !== newValues) {
                    var length_1 = newValues.length;
                    var values = this._values;
                    for (var i = 0; i < length_1; ++i) {
                        values[i] = newValues[i];
                    }
                    values.length = length_1;
                }
                this.onChange();
            }
            return this;
        };
        EShapeConnectorBodyImpl.prototype.copy = function (source) {
            return this.set(source.values);
        };
        EShapeConnectorBodyImpl.prototype.serialize = function (manager) {
            return manager.addResource(JSON.stringify(this._values));
        };
        EShapeConnectorBodyImpl.prototype.deserialize = function (resourceId, mapping, manager) {
            var resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.set(parsed);
            }
        };
        EShapeConnectorBodyImpl.prototype.onChange = function () {
            if (0 < this._lockCount) {
                this._isChanged = true;
                return;
            }
            this._onChange();
        };
        return EShapeConnectorBodyImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorLine = /** @class */ (function (_super) {
        __extends(EShapeConnectorLine, _super);
        function EShapeConnectorLine(type) {
            if (type === void 0) { type = EShapeType.CONNECTOR_LINE; }
            var _this = _super.call(this, type) || this;
            _this._tailLocalId = 0;
            _this._tailNormalId = 0;
            _this._tailMargin = 0;
            _this._headLocalId = 0;
            _this._headNormalId = 0;
            _this._headMargin = 0;
            _this._bodyId = 0;
            _this._lockCount = 0;
            _this._isChanged = false;
            var sx = EShapeDefaults.SIZE_X;
            var sy = EShapeDefaults.SIZE_Y;
            var hx = sx * 0.5;
            var hy = sy * 0.5;
            _this._points = new EShapeLinePoints(_this).set([-hx, -hy, +hx, +hy]);
            var onChangeBound = function () {
                _this.onChange();
            };
            _this._edge = new EShapeConnectorEdgeContainerImpl(_this, onChangeBound);
            _this._body = new EShapeConnectorBodyImpl(_this, onChangeBound);
            return _this;
        }
        EShapeConnectorLine.prototype.lock = function () {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isChanged = false;
            }
        };
        EShapeConnectorLine.prototype.unlock = function () {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isChanged) {
                    this.onChange();
                }
                this._isChanged = false;
            }
        };
        Object.defineProperty(EShapeConnectorLine.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorLine.prototype, "edge", {
            get: function () {
                return this._edge;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorLine.prototype, "body", {
            get: function () {
                return this._body;
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorLine.prototype.onAttach = function () {
            _super.prototype.onAttach.call(this);
            this._edge.attach();
        };
        EShapeConnectorLine.prototype.onDetach = function () {
            this._edge.detach();
            _super.prototype.onDetach.call(this);
        };
        EShapeConnectorLine.prototype.onChange = function () {
            var _a;
            if (0 < this._lockCount) {
                this._isChanged = true;
                return;
            }
            var edge = this._edge;
            var tail = edge.tail;
            var tailLocalId = tail.localId;
            var tailNormalId = tail.normalId;
            var tailMargin = tail.margin;
            var head = edge.head;
            var headLocalId = head.localId;
            var headNormalId = head.normalId;
            var headMargin = head.margin;
            var body = this._body;
            var bodyId = body.id;
            if (this._tailLocalId !== tailLocalId ||
                this._tailNormalId !== tailNormalId ||
                this._tailMargin !== tailMargin ||
                this._headLocalId !== headLocalId ||
                this._headNormalId !== headNormalId ||
                this._headMargin !== headMargin ||
                this._bodyId !== bodyId) {
                this._tailLocalId = tailLocalId;
                this._tailNormalId = tailNormalId;
                this._tailMargin = tailMargin;
                this._headLocalId = headLocalId;
                this._headNormalId = headNormalId;
                this._headMargin = headMargin;
                this._bodyId !== bodyId;
                var transform = this.transform;
                var transformPosition = transform.position;
                var px = transformPosition.x;
                var py = transformPosition.y;
                var points = this._points;
                var values = points.values;
                // Fill points
                this.fillPoints(tail, tailMargin, head, headMargin, body, px, py, values);
                // Center & size
                var boundary = ((_a = EShapeConnectorLine.WORK_BOUNDARY) !== null && _a !== void 0 ? _a : (EShapeConnectorLine.WORK_BOUNDARY = [0, 0, 0, 0]));
                toPointsBoundary(values, boundary);
                var cx = (boundary[2] + boundary[0]) * 0.5;
                var cy = (boundary[3] + boundary[1]) * 0.5;
                var sx = boundary[2] - boundary[0];
                var sy = boundary[3] - boundary[1];
                // Adjust values
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    values[i + 0] -= cx;
                    values[i + 1] -= cy;
                }
                this.disallowUploadedUpdate();
                transformPosition.set(px + cx, py + cy);
                transform.scale.set(1, 1);
                transform.rotation = 0;
                transform.skew.set(0, 0);
                points.toFitted(sx, sy);
                this.size.set(sx, sy);
                points.set(values);
                this.allowUploadedUpdate();
            }
        };
        EShapeConnectorLine.prototype.fillPoints = function (tail, tailMargin, head, headMargin, body, px, py, values) {
            // Tail
            var threshold = 0.000001;
            var tailLocal = tail.local;
            var tailLocalX = tailLocal.x;
            var tailLocalY = tailLocal.y;
            var x0 = tailLocalX - px;
            var y0 = tailLocalY - py;
            // Head
            var headLocal = head.local;
            var headLocalX = headLocal.x;
            var headLocalY = headLocal.y;
            var x1 = headLocalX - px;
            var y1 = headLocalY - py;
            // Body
            var bodyValues = body.values;
            var bodyValuesLength = bodyValues.length;
            // Tail points
            values[0] = x0;
            values[1] = y0;
            // Body points
            if (0 < bodyValuesLength) {
                var cx = (x1 + x0) * 0.5;
                var cy = (y1 + y0) * 0.5;
                var dx = x1 - x0;
                var dy = y1 - y0;
                var a = Math.atan2(dy, dx);
                var c = Math.cos(a);
                var s = Math.sin(a);
                var l = Math.sqrt(dx * dx + dy * dy);
                for (var i = 0; i < bodyValuesLength; i += 2) {
                    var x = bodyValues[i + 0];
                    var y = bodyValues[i + 1];
                    values[i + 2] = cx + (c * x - s * y) * l;
                    values[i + 3] = cy + (c * y + s * x) * l;
                }
            }
            // Head points
            values[2 + bodyValuesLength] = x1;
            values[3 + bodyValuesLength] = y1;
            // Tail margin
            if (tailMargin !== 0) {
                var dx = values[2] - x0;
                var dy = values[3] - y0;
                var d = dx * dx + dy * dy;
                if (threshold < d) {
                    var f = tailMargin / Math.sqrt(dx * dx + dy * dy);
                    values[0] = x0 + dx * f;
                    values[1] = y0 + dy * f;
                }
            }
            // Head margin
            if (headMargin !== 0) {
                var dx = values[0 + bodyValuesLength] - x1;
                var dy = values[1 + bodyValuesLength] - y1;
                var d = dx * dx + dy * dy;
                if (threshold < d) {
                    var f = headMargin / Math.sqrt(dx * dx + dy * dy);
                    values[2 + bodyValuesLength] = x1 + dx * f;
                    values[3 + bodyValuesLength] = y1 + dy * f;
                }
            }
            // Remove the rest
            values.length = bodyValuesLength + 4;
        };
        EShapeConnectorLine.prototype.copy = function (source, part) {
            if (part === void 0) { part = EShapeCopyPart.ALL; }
            _super.prototype.copy.call(this, source, part);
            if (source instanceof EShapeConnectorLine) {
                this._edge.copy(source.edge);
                this._body.copy(source.body);
            }
            return this;
        };
        EShapeConnectorLine.prototype.clone = function () {
            var constructor = this.constructor;
            return new constructor(this.type).copy(this);
        };
        EShapeConnectorLine.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            var edgeId = this._edge.serialize(manager);
            var bodyId = this._body.serialize(manager);
            var pointsId = this._points.serialize(manager);
            result[15] = manager.addResource("[".concat(edgeId, ",").concat(pointsId, ",").concat(bodyId, "]"));
            return result;
        };
        return EShapeConnectorLine;
    }(EShapeLineBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectors = /** @class */ (function () {
        function EShapeConnectors() {
        }
        EShapeConnectors.isConnector = function (target) {
            return target instanceof EShapeConnectorLine;
        };
        EShapeConnectors.newMapping = function (sources, destinations, result) {
            var _a;
            if (result == null) {
                result = (_a = EShapeConnectors._MAPPING) !== null && _a !== void 0 ? _a : (EShapeConnectors._MAPPING = new Map());
                result.clear();
            }
            for (var i = 0, imax = sources.length; i < imax; ++i) {
                var fromChild = sources[i];
                var toChild = destinations[i];
                result.set(fromChild, toChild);
                this.newMapping(fromChild.children, toChild.children, result);
            }
            return result;
        };
        EShapeConnectors.moveAll = function (rootSources, rootDestinations, sources, destinations, mapping) {
            for (var i = 0, imax = sources.length; i < imax; ++i) {
                var source = sources[i];
                var destination = destinations[i];
                if (this.isConnector(source)) {
                    if (this.isConnector(destination)) {
                        var sourceEdge = source.edge;
                        var destEdge = destination.edge;
                        var sourceHead = sourceEdge.head;
                        var sourceHeadShape = sourceHead.acceptor.shape;
                        if (sourceHeadShape) {
                            if (mapping == null) {
                                mapping = this.newMapping(rootSources, rootDestinations);
                            }
                            var destHeadShape = mapping.get(sourceHeadShape);
                            if (destHeadShape) {
                                var destHead = destEdge.head;
                                destHead.detach();
                                destHead.set(destHeadShape);
                                destHead.attach();
                                destHeadShape.connector.remove(sourceHead);
                            }
                        }
                        var sourceTail = sourceEdge.tail;
                        var sourceTailShape = sourceTail.acceptor.shape;
                        if (sourceTailShape) {
                            if (mapping == null) {
                                mapping = this.newMapping(rootSources, rootDestinations);
                            }
                            var destTailShape = mapping.get(sourceTailShape);
                            if (destTailShape) {
                                var destTail = destEdge.tail;
                                destTail.detach();
                                destTail.set(destTailShape);
                                destTail.attach();
                                destTailShape.connector.remove(sourceTail);
                            }
                        }
                    }
                }
                mapping = this.moveAll(rootSources, rootDestinations, source.children, destination.children, mapping);
            }
            return mapping;
        };
        EShapeConnectors.move = function (from, to) {
            var fromChildren = from.children;
            var toChildren = to.children;
            this.moveAll(fromChildren, toChildren, fromChildren, toChildren);
        };
        return EShapeConnectors;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItem = /** @class */ (function () {
        function DynamicAtlasItem(id, width, height, strokeWidth, baseTexture) {
            this.id = id;
            this.ref = 0;
            var resolution = baseTexture.resolution;
            this.frame = new pixi_js.Rectangle(0, 0, width * resolution, height * resolution);
            this.texture = new pixi_js.Texture(baseTexture, new pixi_js.Rectangle(0, 0, 1, 1));
            this.width = width;
            this.height = height;
            this.strokeWidth = strokeWidth;
        }
        DynamicAtlasItem.prototype.applyFrame = function () {
            var resolutionInverse = 1 / this.texture.baseTexture.resolution;
            this.texture.frame.x = this.frame.x * resolutionInverse;
            this.texture.frame.y = this.frame.y * resolutionInverse;
            this.texture.frame.width = this.width;
            this.texture.frame.height = this.height;
            this.texture.updateUvs();
            this.texture.emit("update", this);
        };
        DynamicAtlasItem.prototype.destroy = function () {
            this.texture.destroy();
        };
        return DynamicAtlasItem;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemEmpty = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemEmpty, _super);
        function DynamicAtlasItemEmpty() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DynamicAtlasItemEmpty.prototype.render = function (context) {
            // DO NOTHING
        };
        return DynamicAtlasItemEmpty;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemWhite = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemWhite, _super);
        function DynamicAtlasItemWhite() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DynamicAtlasItemWhite.prototype.render = function (context) {
            var frame = this.frame;
            context.save();
            context.fillStyle = "#ffffff";
            context.fillRect(frame.x - 1, frame.y - 1, frame.width + 2, frame.height + 2);
            context.restore();
        };
        return DynamicAtlasItemWhite;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var MAXIMUM_TEXTURE_SIZE = 4096;
    var DynamicAtlas = /** @class */ (function () {
        function DynamicAtlas(resolution) {
            var canvas = (this._canvas = document.createElement("canvas"));
            canvas.width = canvas.height = 256;
            var baseTexture = (this._baseTexture = pixi_js.BaseTexture.from(canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution: resolution
            }));
            this._idToDatum = {};
            this._sortedData = [];
            this._predefined = {
                empty: new DynamicAtlasItemEmpty("empty", 10, 10, 0, baseTexture),
                white: new DynamicAtlasItemWhite("white", 10, 10, 0, baseTexture)
            };
            this._isDirty = true;
        }
        DynamicAtlas.prototype.updateFrames = function (width, data) {
            var padding = 4;
            var x = padding;
            var y = padding;
            var maxRowHeight = 0;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                if (width < x + datum.frame.width + padding) {
                    x = padding;
                    y += maxRowHeight + padding;
                    maxRowHeight = 0;
                }
                datum.frame.x = x | 0;
                datum.frame.y = y | 0;
                x += datum.frame.width + padding;
                maxRowHeight = Math.max(maxRowHeight, datum.frame.height);
            }
            var minHeight = y + maxRowHeight + padding;
            var result = 256;
            while (result < minHeight) {
                result <<= 1;
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result);
        };
        DynamicAtlas.prototype.renderFrames = function (width, height, data) {
            var canvas = this._canvas;
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext("2d");
            if (context != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    var datum = data[i];
                    datum.render(context);
                }
            }
        };
        DynamicAtlas.prototype.applyFrames = function (data) {
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                datum.applyFrame();
            }
        };
        DynamicAtlas.prototype.calcCanvasWidth = function (data) {
            var result = 128;
            for (var i = data.length - 1; 0 <= i; --i) {
                var datum = data[i];
                var size = Math.max(datum.frame.width, datum.frame.height);
                while (result < size) {
                    result <<= 1;
                }
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result << 1);
        };
        DynamicAtlas.prototype.cleanup = function (data) {
            data.sort(DynamicAtlas.ITEM_COMPARATOR);
            for (var i = data.length - 1; 0 <= i; --i) {
                var datum = data[i];
                if (0 < datum.ref) {
                    data.length = i + 1;
                    return;
                }
            }
            data.length = 0;
        };
        DynamicAtlas.prototype.begin = function () {
            var data = this._sortedData;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                datum.ref = 0;
            }
            this._isDirty = false;
        };
        DynamicAtlas.prototype.end = function () {
            var idToDatum = this._idToDatum;
            var data = this._sortedData;
            for (var i = 0, imax = data.length; i < imax; ++i) {
                var datum = data[i];
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[datum.id];
                    this._isDirty = true;
                }
            }
        };
        DynamicAtlas.prototype.repack = function (forcibly) {
            if (forcibly === true || this._isDirty) {
                this._isDirty = false;
                var data = this._sortedData;
                this.cleanup(data);
                var canvasWidth = this.calcCanvasWidth(data);
                var canvasHeight = this.updateFrames(canvasWidth, data);
                this.renderFrames(canvasWidth, canvasHeight, data);
                this._baseTexture.setRealSize(canvasWidth, canvasHeight);
                this.applyFrames(data);
            }
        };
        DynamicAtlas.prototype.get = function (id) {
            var idToDatum = this._idToDatum;
            var datum = idToDatum[id];
            if (datum != null) {
                datum.ref += 1;
                return datum;
            }
            else {
                var predefined = this._predefined[id];
                if (predefined != null) {
                    this.set(id, predefined);
                    return predefined;
                }
            }
            return null;
        };
        DynamicAtlas.prototype.set = function (id, item) {
            var result = this._idToDatum[id];
            item.ref += 1;
            this._idToDatum[id] = item;
            this._sortedData.push(item);
            this._isDirty = true;
            return result;
        };
        DynamicAtlas.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DynamicAtlas.prototype.getDefaultTexture = function () {
            return this.get("white").texture;
        };
        DynamicAtlas.prototype.getBaseTexture = function () {
            return this._baseTexture;
        };
        DynamicAtlas.prototype.release = function (id) {
            var idToDatum = this._idToDatum;
            var datum = idToDatum[id];
            if (datum != null) {
                datum.ref -= 1;
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[id];
                    this._isDirty = true;
                }
            }
        };
        DynamicAtlas.ITEM_COMPARATOR = function (a, b) {
            if (a.ref <= 0) {
                if (b.ref <= 0) {
                    return 0;
                }
                else {
                    return +1;
                }
            }
            else {
                if (b.ref <= 0) {
                    return -1;
                }
            }
            if (a.frame.height < b.frame.height) {
                return -1;
            }
            else if (b.frame.height < a.frame.height) {
                return +1;
            }
            else {
                return a.frame.width - b.frame.width;
            }
        };
        return DynamicAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemFontAtlas = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemFontAtlas, _super);
        function DynamicAtlasItemFontAtlas(atlas, baseTexture) {
            var _this = _super.call(this, atlas.id, atlas.width / baseTexture.resolution, atlas.height / baseTexture.resolution, 0, baseTexture) || this;
            _this.canvas = atlas.canvas;
            return _this;
        }
        DynamicAtlasItemFontAtlas.prototype.render = function (context) {
            var canvas = this.canvas;
            if (canvas != null) {
                var frame = this.frame;
                context.drawImage(canvas, frame.x, frame.y, frame.width, frame.height);
            }
        };
        return DynamicAtlasItemFontAtlas;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ASCII_CHARACTERS = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasCharacterOrigin = /** @class */ (function () {
        function DynamicFontAtlasCharacterOrigin(x, y) {
            this.x = x;
            this.y = y;
        }
        return DynamicFontAtlasCharacterOrigin;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasCharacter = /** @class */ (function () {
        function DynamicFontAtlasCharacter(character, advance, width, height, type) {
            this.ref = 1;
            this.life = 10;
            this.character = character;
            this.x = 0;
            this.y = 0;
            this.width = width;
            this.height = height;
            this.advance = advance;
            this.origin = new DynamicFontAtlasCharacterOrigin(0, 0);
            this.type = type;
        }
        return DynamicFontAtlasCharacter;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var RESERVED = 1;
    var NON_BREAKING = 2;
    var SPACE = 4;
    var SPACE_R = SPACE | RESERVED;
    var SPACE_NB = SPACE | NON_BREAKING;
    var SPACE_RNB = SPACE | RESERVED | NON_BREAKING;
    var LETTER = 8;
    var LETTER_R = LETTER | RESERVED;
    var LETTER_NB = LETTER | NON_BREAKING;
    var LETTER_RNB = LETTER | RESERVED | NON_BREAKING;
    var DynamicFontAtlasCharacterType = {
        RESERVED: RESERVED,
        NON_BREAKING: NON_BREAKING,
        SPACE: SPACE,
        SPACE_R: SPACE_R,
        SPACE_NB: SPACE_NB,
        SPACE_RNB: SPACE_RNB,
        LETTER: LETTER,
        LETTER_R: LETTER_R,
        LETTER_NB: LETTER_NB,
        LETTER_RNB: LETTER_RNB
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER$2 = "\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nvarying mediump vec2 vTextureCoord;\nvoid main(void) {\n\tgl_Position = vec4(aVertexPosition, 0.0, 1.0);\n\tvTextureCoord = aTextureCoord;\n}\n";
    var FRAGMENT_SHADER$2 = "\nprecision mediump float;\n\nvarying mediump vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec2 uSize;\n\nfloat calcDistance( float x, float y, float dx, float dy ) {\n\tfloat xd = x + dx;\n\tfloat yd = y + dy;\n\tfloat u = xd / uSize.x;\n\tfloat v = yd / uSize.y;\n\tfloat ul = (xd - 1.0) / uSize.x;\n\tfloat vt = (yd - 1.0) / uSize.y;\n\n\tfloat m = texture2D(uSampler, vec2(u , v )).a;\n\tfloat l = texture2D(uSampler, vec2(ul, v )).a;\n\tfloat t = texture2D(uSampler, vec2(u , vt)).a;\n\tfloat ddx = -(0.5 - m) / (l - m);\n\tfloat ddy = -(0.5 - m) / (t - m);\n\tbool bl = min(l,m) < 0.5 && 0.5 <= max(l,m);\n\tbool bt = min(t,m) < 0.5 && 0.5 <= max(t,m);\n\treturn (\n\t\tbl ?\n\t\t(bt ?\n\t\t\tlength(vec2(dx + ddx * 0.5, dy + ddy * 0.5)) :\n\t\t\tlength(vec2(dx + ddx, dy))\n\t\t) :\n\t\t(bt ?\n\t\t\tlength(vec2(dx, dy + ddy)) :\n\t\t\t100.0\n\t\t)\n\t);\n}\n\nfloat calcDistancesY( float x, float y, float dx ) {\n\tfloat d = 100.0;\n\tfor( float dy=-6.0; dy<6.5; dy++ ) {\n\t\td = min( d, calcDistance( x, y, dx, dy ) );\n\t}\n\treturn d;\n}\n\nfloat calcDistances( float x, float y ) {\n\tfloat d = 100.0;\n\tfor( float dx=-6.0; dx<6.5; dx++ ) {\n\t\td = min( d, calcDistancesY( x, y, dx ) );\n\t}\n\treturn d;\n}\n\nvoid main(void) {\n\tfloat t = texture2D(uSampler, vTextureCoord).a;\n\tfloat x = vTextureCoord.x * uSize.x;\n\tfloat y = vTextureCoord.y * uSize.y;\n\tfloat d = min( 6.0, calcDistances( x, y ) ) / 12.0;\n\td = clamp( mix( 0.5 - d, 0.5 + d, step( 0.5, t ) ), 0.0, 1.0 );\n\tgl_FragColor = vec4(1.0, 1.0, 1.0, d);\n}\n";
    var DynamicSDFFontGenerator = /** @class */ (function () {
        function DynamicSDFFontGenerator() {
            var _this = this;
            this._gl = null;
            this._texture = null;
            this._shaderProgram = null;
            this._vertexPositionAttribute = NaN;
            this._textureCoordAttribute = NaN;
            this._samplerUniform = NaN;
            this._sizeUniform = NaN;
            this._vb = null;
            this._uvb = null;
            var canvas = (this._canvas = document.createElement("canvas"));
            canvas.width = 64;
            canvas.height = 64;
            this._onLostBound = function (e) {
                e.preventDefault();
            };
            this._onRestoreBound = function () {
                _this.restore();
            };
            this._onUnloadBound = function () {
                _this.destroy();
            };
            canvas.addEventListener("webglcontextlost", this._onLostBound, false);
            canvas.addEventListener("webglcontextrestored", this._onRestoreBound, false);
            window.addEventListener("unload", this._onUnloadBound, false);
        }
        DynamicSDFFontGenerator.prototype.init = function () {
            var canvas = this._canvas;
            if (canvas != null && (this._gl == null || this._gl.isContextLost())) {
                var config = {
                    alpha: true,
                    antialias: false,
                    depth: false,
                    stencil: false,
                    premultipliedAlpha: false
                };
                var gl = canvas.getContext("webgl", config) ||
                    canvas.getContext("experimental-webgl", config);
                this._gl = gl;
                if (gl != null) {
                    gl.clearColor(1.0, 1.0, 1.0, 0.0);
                    this.makeVertexBuffer();
                    this.makeUvBuffer();
                    this.makeShaders();
                    this._texture = null;
                }
            }
            return this;
        };
        DynamicSDFFontGenerator.prototype.restore = function () {
            this.init();
        };
        DynamicSDFFontGenerator.prototype.getCanvas = function () {
            return this._canvas;
        };
        DynamicSDFFontGenerator.prototype.getShader = function (gl, code, type) {
            var shader = type
                ? gl.createShader(gl.FRAGMENT_SHADER)
                : gl.createShader(gl.VERTEX_SHADER);
            if (shader != null) {
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console &&
                        console.error("Failed to compile the shader: ".concat(gl.getShaderInfoLog(shader)));
                    return null;
                }
            }
            return shader;
        };
        DynamicSDFFontGenerator.prototype.makeShaders = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var vertexShader = this.getShader(gl, VERTEX_SHADER$2, false);
                if (vertexShader != null) {
                    var fragmentShader = this.getShader(gl, FRAGMENT_SHADER$2, true);
                    if (fragmentShader != null) {
                        var shaderProgram = (this._shaderProgram = gl.createProgram());
                        if (shaderProgram != null) {
                            gl.attachShader(shaderProgram, vertexShader);
                            gl.attachShader(shaderProgram, fragmentShader);
                            gl.linkProgram(shaderProgram);
                            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                                console &&
                                    console.error("Failed to link the program: ".concat(gl.getError()));
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                return null;
                            }
                            else {
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                gl.useProgram(shaderProgram);
                                this._vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
                                this._textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
                                this._samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
                                this._sizeUniform = gl.getUniformLocation(shaderProgram, "uSize");
                                gl.useProgram(null);
                                return shaderProgram;
                            }
                        }
                        else {
                            gl.deleteShader(vertexShader);
                            gl.deleteShader(fragmentShader);
                        }
                    }
                    else {
                        gl.deleteShader(vertexShader);
                    }
                }
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyShaders = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var shaderProgram = this._shaderProgram;
                if (shaderProgram != null) {
                    this._shaderProgram = null;
                    gl.useProgram(null);
                    gl.deleteProgram(shaderProgram);
                }
            }
        };
        DynamicSDFFontGenerator.prototype.updateTexture = function (source) {
            var gl = this._gl;
            var canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                var width = source.width;
                var height = source.height;
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, width, height);
                }
                var texture = this._texture;
                if (texture == null) {
                    texture = this._texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                return texture;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyTexture = function () {
            var gl = this._gl;
            var texture = this._texture;
            if (gl != null && gl.isContextLost() !== true && texture != null) {
                this._texture = null;
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.deleteTexture(texture);
            }
        };
        DynamicSDFFontGenerator.prototype.makeVertexBuffer = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var vb = (this._vb = gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                var vertices = [-1.0, +1.0, +1.0, +1.0, -1.0, -1.0, +1.0, -1.0];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                return vb;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyVertexBuffer = function () {
            var gl = this._gl;
            var vb = this._vb;
            if (gl != null && gl.isContextLost() !== true && vb != null) {
                this._vb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(vb);
            }
        };
        DynamicSDFFontGenerator.prototype.makeUvBuffer = function () {
            var gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                var uvb = (this._uvb = gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                var uvs = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
                return uvb;
            }
            return null;
        };
        DynamicSDFFontGenerator.prototype.destroyUvBuffer = function () {
            var gl = this._gl;
            var uvb = this._uvb;
            if (gl != null && gl.isContextLost() !== true && uvb != null) {
                this._uvb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(uvb);
            }
        };
        DynamicSDFFontGenerator.prototype.render = function () {
            var gl = this._gl;
            var canvas = this._canvas;
            var shaderProgram = this._shaderProgram;
            var vb = this._vb;
            var uvb = this._uvb;
            var texture = this._texture;
            if (gl != null &&
                gl.isContextLost() !== true &&
                canvas != null &&
                shaderProgram != null &&
                vb != null &&
                uvb != null &&
                texture != null) {
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(shaderProgram);
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                var vertexPositionAttribute = this._vertexPositionAttribute;
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.vertexAttribPointer(vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                var textureCoordAttribute = this._textureCoordAttribute;
                gl.enableVertexAttribArray(textureCoordAttribute);
                gl.vertexAttribPointer(textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(this._samplerUniform, 0);
                gl.uniform2f(this._sizeUniform, canvas.width, canvas.height);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.useProgram(null);
            }
        };
        DynamicSDFFontGenerator.prototype.read = function (copyCanvas) {
            var gl = this._gl;
            var canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                var width = canvas.width;
                var height = canvas.height;
                copyCanvas.width = width;
                copyCanvas.height = height;
                var copyContext = copyCanvas.getContext("2d");
                if (copyContext != null) {
                    copyContext.drawImage(canvas, 0, 0);
                }
            }
        };
        DynamicSDFFontGenerator.prototype.destroy = function () {
            this.destroyVertexBuffer();
            this.destroyUvBuffer();
            this.destroyShaders();
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
                canvas.removeEventListener("webglcontextlost", this._onLostBound, false);
                canvas.removeEventListener("webglcontextrestored", this._onRestoreBound, false);
                window.removeEventListener("unload", this._onUnloadBound, false);
            }
            var gl = this._gl;
            if (gl != null) {
                this._gl = null;
                var WebGLLoseContext = gl.getExtension("WEBGL_lose_context");
                if (WebGLLoseContext != null) {
                    WebGLLoseContext.loseContext();
                }
            }
        };
        DynamicSDFFontGenerator.getInstance = function () {
            if (DynamicSDFFontGenerator._INSTANCE == null) {
                DynamicSDFFontGenerator._INSTANCE = new DynamicSDFFontGenerator();
            }
            return DynamicSDFFontGenerator._INSTANCE;
        };
        DynamicSDFFontGenerator._INSTANCE = null;
        return DynamicSDFFontGenerator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicSDFFontAtlas = /** @class */ (function () {
        function DynamicSDFFontAtlas(fontFamily) {
            this._id = "font-atlas:".concat(fontFamily);
            this._generator = DynamicSDFFontGenerator.getInstance().init();
            this._canvas = document.createElement("canvas");
            this._font = {
                family: DynamicSDFFontAtlas.toFontFamily(fontFamily),
                size: 32,
                italic: false
            };
            this._characters = {};
            this._length = 0;
            this._width = 1;
            this._height = 1;
            this._isDirty = true;
        }
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "font", {
            get: function () {
                return this._font;
            },
            set: function (font) {
                this._font.family = font.family;
                this._font.size = font.size;
                this._font.italic = font.italic;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "generator", {
            get: function () {
                return this._generator;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "characters", {
            get: function () {
                return this._characters;
            },
            enumerable: false,
            configurable: true
        });
        DynamicSDFFontAtlas.prototype.begin = function () {
            this._length = 0;
            var characters = this._characters;
            for (var id in characters) {
                characters[id].ref = 0;
            }
        };
        DynamicSDFFontAtlas.prototype.end = function () {
            var characters = this._characters;
            for (var id in characters) {
                var data = characters[id];
                if (data.ref <= 0) {
                    data.life -= 1;
                    if (data.life <= 0) {
                        delete characters[id];
                        this._isDirty = true;
                    }
                }
            }
        };
        DynamicSDFFontAtlas.prototype.addAscii = function () {
            this.addChar(" ", " ", DynamicFontAtlasCharacterType.SPACE_R);
            this.addChar("\t", "    ", DynamicFontAtlasCharacterType.SPACE_R);
            this.addChar("...", "...", DynamicFontAtlasCharacterType.LETTER_RNB);
            for (var i = 0, imax = ASCII_CHARACTERS.length; i < imax; ++i) {
                var char = ASCII_CHARACTERS[i];
                this.addChar(char, char, DynamicFontAtlasCharacterType.LETTER_RNB);
            }
        };
        DynamicSDFFontAtlas.prototype.addChar = function (id, character, type) {
            var characters = this._characters;
            if (!this.isIgnored(character)) {
                var data = characters[id];
                if (data != null) {
                    if (data.ref <= 0) {
                        this._length += 1;
                    }
                    data.ref += 1;
                }
                else {
                    characters[id] = new DynamicFontAtlasCharacter(character, 0, 1, 1, type);
                    this._length += 1;
                    this._isDirty = true;
                }
            }
        };
        DynamicSDFFontAtlas.prototype.isIgnored = function (character) {
            switch (character) {
                case "\n": // Line feed
                    return true;
                case "\r": // Carriage return
                    return true;
                case "\v": // Vertical tab
                    return true;
                case "\f": // Form feed
                    return true;
                case "\u0085": // Next line
                    return true;
            }
            return false;
        };
        DynamicSDFFontAtlas.prototype.add = function (characters, type) {
            if (type === void 0) { type = DynamicFontAtlasCharacterType.LETTER; }
            var iterator = UtilCharacterIterator.from(characters);
            while (iterator.hasNext()) {
                var character = iterator.next();
                this.addChar(character, character, type);
            }
        };
        DynamicSDFFontAtlas.prototype.get = function (id) {
            return this._characters[id];
        };
        DynamicSDFFontAtlas.prototype.update = function () {
            if (this._isDirty) {
                var canvas = this._canvas;
                var generator = this._generator;
                if (canvas != null && generator != null) {
                    var context = canvas.getContext("2d");
                    if (context != null) {
                        this._isDirty = false;
                        var font = this._font;
                        var characters = this._characters;
                        var characterSize = font.size + 14;
                        var width = DynamicSDFFontAtlas.toPowerOf2(Math.ceil(Math.sqrt(this._length)) * characterSize);
                        this._width = width;
                        var fontStyle = (font.italic ? "italic " : "") + (font.size + "px ") + font.family;
                        context.font = fontStyle;
                        context.textAlign = "left";
                        context.textBaseline = "middle";
                        context.lineWidth = 0;
                        context.lineCap = "round";
                        context.lineJoin = "miter";
                        context.miterLimit = 0;
                        context.fillStyle = "#FFFFFF";
                        var offsetX = 7;
                        var offsetY = characterSize >> 1;
                        var x = 0;
                        var y = 0;
                        for (var id in characters) {
                            var data = characters[id];
                            var advance = context.measureText(data.character).width;
                            var characterWidth = Math.ceil(offsetX + advance + offsetX);
                            var characterHeight = characterSize;
                            if (width <= x + characterWidth) {
                                x = 0;
                                y += characterSize;
                            }
                            data.x = x;
                            data.y = y;
                            data.width = characterWidth;
                            data.height = characterHeight;
                            data.advance = advance;
                            data.origin.x = x + offsetX;
                            data.origin.y = y + offsetY;
                            x += characterWidth;
                        }
                        var height = (this._height = y + characterSize);
                        // Make a input canvas
                        // Here, we need to reset the context because
                        // context settings will be lost when we set the width/height.
                        canvas.width = width;
                        canvas.height = height;
                        context.font = fontStyle;
                        context.textAlign = "left";
                        context.textBaseline = "middle";
                        context.lineWidth = 0;
                        context.lineCap = "round";
                        context.lineJoin = "miter";
                        context.miterLimit = 4;
                        context.fillStyle = "#FFFFFF";
                        context.clearRect(0, 0, width, height);
                        for (var id in characters) {
                            var data = characters[id];
                            context.fillText(data.character, data.origin.x, data.origin.y);
                        }
                        // Convert to SDF font texture
                        generator.updateTexture(canvas);
                        generator.render();
                        generator.read(canvas);
                        return true;
                    }
                }
            }
            return false;
        };
        Object.defineProperty(DynamicSDFFontAtlas.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: false,
            configurable: true
        });
        DynamicSDFFontAtlas.prototype.toJson = function () {
            return {
                width: this._width,
                height: this._height,
                font: this._font,
                characters: this._characters
            };
        };
        DynamicSDFFontAtlas.prototype.toString = function () {
            return JSON.stringify(this.toJson());
        };
        DynamicSDFFontAtlas.prototype.destroy = function () {
            var generator = this._generator;
            if (generator != null) {
                this._generator = null;
            }
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            var characters = this._characters;
            for (var id in characters) {
                delete characters[id];
            }
        };
        DynamicSDFFontAtlas.toFontFamily = function (fontFamily) {
            return fontFamily === "auto" ? DynamicSDFFontAtlas.getAutoFontFamily() : fontFamily;
        };
        DynamicSDFFontAtlas.toPowerOf2 = function (size) {
            var result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        };
        DynamicSDFFontAtlas.getAutoFontFamily = function () {
            if (DynamicSDFFontAtlas.FONT_FAMILY_AUTO == null) {
                DynamicSDFFontAtlas.FONT_FAMILY_AUTO = DThemes.getInstance()
                    .get("DBase")
                    .getFontFamilly();
            }
            return DynamicSDFFontAtlas.FONT_FAMILY_AUTO;
        };
        DynamicSDFFontAtlas.FONT_FAMILY_AUTO = null;
        return DynamicSDFFontAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicSDFFontAtlases = /** @class */ (function () {
        function DynamicSDFFontAtlases() {
            this._atlases = {};
        }
        DynamicSDFFontAtlases.prototype.begin = function () {
            var atlases = this._atlases;
            for (var family in atlases) {
                var atlas = atlases[family];
                atlas.begin();
            }
        };
        DynamicSDFFontAtlases.prototype.end = function () {
            var atlases = this._atlases;
            for (var family in atlases) {
                var atlas = atlases[family];
                if (0 < atlas.length) {
                    atlas.addAscii();
                }
                atlas.end();
                if (atlas.length <= 0) {
                    atlas.destroy();
                    delete atlases[family];
                }
            }
        };
        DynamicSDFFontAtlases.prototype.add = function (family, targets) {
            var atlas = this._atlases[family];
            if (atlas != null) {
                atlas.add(targets);
            }
            else {
                var newAtlas = new DynamicSDFFontAtlas(family);
                newAtlas.add(targets);
                this._atlases[family] = newAtlas;
            }
        };
        DynamicSDFFontAtlases.prototype.get = function (family) {
            var atlas = this._atlases[family];
            if (atlas != null) {
                return atlas;
            }
            return null;
        };
        DynamicSDFFontAtlases.prototype.update = function (baseAtlas) {
            var atlases = this._atlases;
            var baseTexture = baseAtlas.getBaseTexture();
            for (var family in atlases) {
                var atlas = atlases[family];
                if (atlas.update()) {
                    var atlasId = atlas.id;
                    var item = baseAtlas.get(atlasId);
                    if (item != null) {
                        var width = atlas.width;
                        var height = atlas.height;
                        var resolution = baseTexture.resolution;
                        item.frame.width = width;
                        item.frame.height = height;
                        item.width = width / resolution;
                        item.height = height / resolution;
                        baseAtlas.toDirty();
                    }
                    else {
                        baseAtlas.set(atlasId, new DynamicAtlasItemFontAtlas(atlas, baseTexture));
                    }
                }
            }
        };
        DynamicSDFFontAtlases.prototype.destroy = function () {
            var atlases = this._atlases;
            for (var family in atlases) {
                var atlas = atlases[family];
                atlas.destroy();
            }
            this._atlases = {};
        };
        return DynamicSDFFontAtlases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemImage = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemImage, _super);
        function DynamicAtlasItemImage(image, baseTexture) {
            var _this = _super.call(this, image.src, image.width / baseTexture.resolution, image.height / baseTexture.resolution, 0, baseTexture) || this;
            _this.image = image;
            return _this;
        }
        DynamicAtlasItemImage.prototype.render = function (context) {
            var frame = this.frame;
            var x = frame.x;
            var y = frame.y;
            var w = frame.width;
            var h = frame.height;
            var image = this.image;
            context.drawImage(image, x, y, w, h);
            context.drawImage(image, 0, 0, 1, h, x - 1, y - 1, 1, h + 2);
            context.drawImage(image, 0, 0, w, 1, x, y - 1, w, 1);
            context.drawImage(image, w - 1, 0, 1, h, x + w, y - 1, 1, h + 2);
            context.drawImage(image, 0, h - 1, w, 1, x, y + h, w, 1);
        };
        return DynamicAtlasItemImage;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBufferUnit = /** @class */ (function () {
        function EShapeBufferUnit(texture, indexOffset) {
            this.texture = texture;
            this.indexOffset = indexOffset;
        }
        return EShapeBufferUnit;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBufferUnitBuilder = /** @class */ (function () {
        function EShapeBufferUnitBuilder() {
            this.index = 0;
            this.baseTexture = null;
            this.units = [];
        }
        EShapeBufferUnitBuilder.prototype.begin = function () {
            this.index = 0;
            this.baseTexture = null;
        };
        EShapeBufferUnitBuilder.prototype.push = function (texture, indexOffset) {
            if (this.index < this.units.length) {
                var unit = this.units[this.index];
                unit.texture = texture;
                unit.indexOffset = indexOffset;
            }
            else {
                this.units.push(new EShapeBufferUnit(texture, indexOffset));
            }
            this.index += 1;
        };
        EShapeBufferUnitBuilder.prototype.end = function () {
            if (this.units.length !== this.index) {
                this.units.length = this.index;
            }
        };
        EShapeBufferUnitBuilder.prototype.destroy = function () {
            this.units.length = 0;
        };
        return EShapeBufferUnitBuilder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeBuffer = /** @class */ (function () {
        function EShapeBuffer(ntriangles, renderer) {
            var nindices = ntriangles * 3;
            var nvertices = nindices;
            this.vertices = new Float32Array(nvertices * 2);
            this._vertexCapacity = nvertices;
            this._vertexCount = 0;
            this._vertexBuffer = null;
            this.clippings = new Float32Array(nvertices * 3);
            this._clippingBuffer = null;
            this.steps = new Float32Array(nvertices * 6);
            this._stepBuffer = null;
            this.colorFills = new Float32Array(nvertices * 4);
            this._colorFillBuffer = null;
            this.colorStrokes = new Float32Array(nvertices * 4);
            this._colorStrokeBuffer = null;
            this.uvs = new Float32Array(nvertices * 2);
            this._uvBuffer = null;
            var isIndicesShort = nvertices <= 65535;
            this.indices = isIndicesShort ? new Uint16Array(nindices) : new Uint32Array(nindices);
            this._indexCapacity = ntriangles;
            this._indexCount = 0;
            this.indexCountRequested = 0;
            this._indexBuffer = null;
            this._renderer = renderer;
            this._builder = new EShapeBufferUnitBuilder();
            this._geometry = null;
        }
        EShapeBuffer.prototype.updateVertices = function () {
            var vertexBuffer = this._vertexBuffer;
            if (vertexBuffer) {
                vertexBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateClippings = function () {
            var clippingBuffer = this._clippingBuffer;
            if (clippingBuffer) {
                clippingBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateSteps = function () {
            var stepBuffer = this._stepBuffer;
            if (stepBuffer) {
                stepBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateColorFills = function () {
            var colorFillBuffer = this._colorFillBuffer;
            if (colorFillBuffer) {
                colorFillBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateColorStrokes = function () {
            var colorStrokeBuffer = this._colorStrokeBuffer;
            if (colorStrokeBuffer) {
                colorStrokeBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateUvs = function () {
            var uvBuffer = this._uvBuffer;
            if (uvBuffer) {
                uvBuffer.update();
            }
        };
        EShapeBuffer.prototype.updateIndices = function () {
            var indexBuffer = this._indexBuffer;
            if (indexBuffer) {
                indexBuffer.update();
            }
        };
        EShapeBuffer.prototype.getGeometry = function () {
            var result = this._geometry;
            if (result == null) {
                this._vertexBuffer = new pixi_js.Buffer(this.vertices, false, false);
                this._clippingBuffer = new pixi_js.Buffer(this.clippings, false, false);
                this._stepBuffer = new pixi_js.Buffer(this.steps, false, false);
                this._colorFillBuffer = new pixi_js.Buffer(this.colorFills, false, false);
                this._colorStrokeBuffer = new pixi_js.Buffer(this.colorStrokes, false, false);
                this._uvBuffer = new pixi_js.Buffer(this.uvs, false, false);
                this._indexBuffer = new pixi_js.Buffer(this.indices, false, true);
                this._geometry = result = new pixi_js.Geometry()
                    .addIndex(this._indexBuffer)
                    .addAttribute("aPosition", this._vertexBuffer, 2)
                    .addAttribute("aClipping", this._clippingBuffer, 3)
                    .addAttribute("aStep", this._stepBuffer, 2)
                    .addAttribute("aAntialias", this._stepBuffer, 4)
                    .addAttribute("aColorFill", this._colorFillBuffer, 4)
                    .addAttribute("aColorStroke", this._colorStrokeBuffer, 4)
                    .addAttribute("aUv", this._uvBuffer, 2);
            }
            return result;
        };
        EShapeBuffer.prototype.upload = function () {
            this._renderer.geometry.bind(this.getGeometry());
        };
        EShapeBuffer.prototype.render = function (shader) {
            var renderer = this._renderer;
            renderer.geometry.bind(this.getGeometry());
            var units = this._builder.units;
            var unitCount = units.length;
            if (0 < unitCount) {
                var type = pixi_js.DRAW_MODES.TRIANGLES;
                var unit0 = null;
                var unit1 = units[0];
                var ioffset0 = 0;
                var ioffset1 = unit1.indexOffset * 3;
                var vcount = 0;
                var texture = pixi_js.Texture.WHITE;
                for (var i = 0, imax = unitCount - 1; i < imax; ++i) {
                    unit0 = unit1;
                    unit1 = units[i + 1];
                    ioffset0 = ioffset1;
                    ioffset1 = unit1.indexOffset * 3;
                    vcount = ioffset1 - ioffset0;
                    texture = unit0.texture || pixi_js.Texture.WHITE;
                    if (0 < vcount && texture.valid) {
                        shader.uniforms.sampler = renderer.texture.bind(texture);
                        renderer.geometry.draw(type, vcount, ioffset0);
                    }
                }
                vcount = this._indexCount * 3 - ioffset1;
                texture = unit1.texture || pixi_js.Texture.WHITE;
                if (0 < vcount && texture.valid) {
                    shader.uniforms.sampler = renderer.texture.bind(texture);
                    renderer.geometry.draw(type, vcount, ioffset1);
                }
            }
        };
        EShapeBuffer.prototype.isCompatible = function (shape, uploaded, vindex, iindex) {
            return (uploaded.getBuffer() === this &&
                uploaded.getVertexOffset() === vindex &&
                uploaded.getIndexOffset() === iindex &&
                uploaded.isCompatible(shape));
        };
        EShapeBuffer.prototype.update = function (iterator, antialiasWeight, noMoreThanOne) {
            var builder = this._builder;
            builder.begin();
            var vindex = 0;
            var iindex = 0;
            var shape = iterator.get();
            for (; shape != null; shape = iterator.next()) {
                var uploaded = shape.uploaded;
                if (uploaded == null || !this.isCompatible(shape, uploaded, vindex, iindex)) {
                    break;
                }
                uploaded.update(shape);
                uploaded.buildUnit(builder);
                vindex += uploaded.getVertexCount();
                iindex += uploaded.getIndexCount();
                if (noMoreThanOne) {
                    iterator.next();
                    builder.end();
                    this._vertexCount = vindex;
                    this._indexCount = iindex;
                    return 0 < builder.units.length;
                }
            }
            for (; shape != null; shape = iterator.next()) {
                var creater = EShapeUploadeds[shape.type] || EShapeUploadeds[EShapeType.GROUP];
                if (creater == null) {
                    break;
                }
                var uploaded = creater(this, shape, vindex, iindex, antialiasWeight);
                if (uploaded == null) {
                    break;
                }
                uploaded.buildUnit(builder);
                vindex += uploaded.getVertexCount();
                iindex += uploaded.getIndexCount();
                if (noMoreThanOne) {
                    iterator.next();
                    break;
                }
            }
            builder.end();
            this._vertexCount = vindex;
            this._indexCount = iindex;
            return 0 < builder.units.length;
        };
        EShapeBuffer.prototype.check = function (vindex, ioffset, vcount, icount) {
            this.indexCountRequested = icount;
            return vindex + vcount <= this._vertexCapacity && ioffset + icount <= this._indexCapacity;
        };
        EShapeBuffer.prototype.destroy = function () {
            var geometry = this._geometry;
            if (geometry) {
                geometry.destroy();
            }
            this._builder.destroy();
        };
        return EShapeBuffer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DUMMY_SHAPES = [];
    var EShapeRendererIteratorDatum = /** @class */ (function () {
        function EShapeRendererIteratorDatum() {
            this.index = 0;
            this.shapes = DUMMY_SHAPES;
            this.current = null;
        }
        return EShapeRendererIteratorDatum;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRendererIterator = /** @class */ (function () {
        function EShapeRendererIterator() {
            this._index = -1;
            this._datum = new EShapeRendererIteratorDatum();
            this._data = [this._datum];
            this._current = null;
        }
        EShapeRendererIterator.prototype.reset = function (shape, shapes) {
            this._index = 0;
            var datum = this._data[0];
            datum.index = -1;
            datum.shapes = shapes;
            datum.current = null;
            this._datum = datum;
            if (shape != null) {
                this._current = shape;
                return shape;
            }
            return this.next();
        };
        EShapeRendererIterator.prototype.get = function () {
            return this._current;
        };
        EShapeRendererIterator.prototype.next = function () {
            while (true) {
                var datum = this._datum;
                var shapeIndex = (datum.index += 1);
                var shapes = datum.shapes;
                var shape = shapeIndex < shapes.length
                    ? (datum.current = shapes[shapeIndex])
                    : (datum.current = null);
                if (shape != null) {
                    var children = shape.children;
                    if (0 < children.length) {
                        var dataIndex = (this._index += 1);
                        var data = this._data;
                        if (dataIndex < data.length) {
                            var newDatum = data[dataIndex];
                            newDatum.index = -1;
                            newDatum.shapes = children;
                            newDatum.current = null;
                            this._datum = newDatum;
                        }
                        else {
                            var newDatum = new EShapeRendererIteratorDatum();
                            data.push(newDatum);
                            newDatum.index = -1;
                            newDatum.shapes = children;
                            newDatum.current = null;
                            this._datum = newDatum;
                        }
                    }
                    else {
                        this._current = shape;
                        return shape;
                    }
                }
                else {
                    var dataIndex = (this._index -= 1);
                    var data = this._data;
                    if (0 <= dataIndex) {
                        var newDatum = data[dataIndex];
                        this._datum = newDatum;
                        return (this._current = newDatum.current);
                    }
                    else {
                        return (this._current = null);
                    }
                }
            }
        };
        return EShapeRendererIterator;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER$1 = "\nattribute vec2 aPosition;\nattribute vec3 aClipping;\nattribute vec2 aStep;\nattribute vec4 aAntialias;\nattribute vec4 aColorFill;\nattribute vec4 aColorStroke;\nattribute vec2 aUv;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mediump float shapeScale;\nuniform mediump float pixelScale;\nuniform mediump float antialiasWeight;\n\nvarying mediump vec3 vClipping;\nvarying mediump vec2 vStep;\nvarying mediump vec4 vAntialias;\nvarying mediump vec4 vColorFill;\nvarying mediump vec4 vColorStroke;\nvarying mediump vec2 vUv;\n\nvec2 toInverse( in vec2 v ) {\n\treturn vec2( -v.y, v.x );\n}\n\nvec2 toTransformedPosition( in vec2 v ) {\n\treturn (projectionMatrix * translationMatrix * vec3(v, 1.0)).xy;\n}\n\nvec4 toAntialias01( in vec4 antialias ) {\n\t// Taylor series of 1 / ( 1 - a ) = 1 + a + a^2 + ....\n\treturn 1.0 + min( vec4( 1.0 ), antialias * pixelScale );\n}\n\nvec4 toAntialias2( in vec4 antialias, in float strokeWidth ) {\n\tfloat x = min( 0.4, 0.4 / 12.0 * antialias.x * pixelScale * antialiasWeight );\n\tfloat w = clamp( strokeWidth / antialias.y, 0.0, 1.0 ) * 0.4;\n\tfloat p = w * antialias.z + antialias.w;\n\tfloat y = 0.5 - p;\n\tfloat z = 0.5 - p - w;\n\treturn vec4( y, z, y - max( 0.01, y - x ), z - max( 0.01, z - x ) );\n}\n\nvec2 toPosition3456( in float type, in vec2 p, in vec2 pprev, in vec2 pnext, in float strokeWidth, out float shift ) {\n\tvec2 d0 = p - pprev;\n\tvec2 d1 = pnext - p;\n\tfloat l0 = dot( d0, d0 );\n\tfloat l1 = dot( d1, d1 );\n\tvec2 nd0 = normalize( toInverse( d0 ) );\n\tvec2 nd1 = normalize( toInverse( d1 ) );\n\tvec2 nd2 = 0.00001 < l1 ? nd1 : vec2(0.0, 0.0);\n\tvec2 n0 = 0.00001 < l0 ? nd0 : nd2;\n\tvec2 n1 = 0.00001 < l1 ? nd1 : n0;\n\tvec2 n0i = toInverse( n0 );\n\tvec2 n1i = toInverse( n1 );\n\tfloat direction = sign( 4.5 - type );\n\n\t// Offset\n\tfloat cross = dot( n0i, n1 );\n\tfloat crossInverse = ( 0.00001 < abs( cross ) ? 1.0 / cross : 0.0 );\n\tfloat b = dot(n1 - n0, n0) * crossInverse;\n\tfloat offsetSize = direction * strokeWidth * 0.5;\n\tvec2 offset = n1 + n1i * b;\n\n\t// Miter\n\tvec2 pmiter = p + offsetSize * offset;\n\tfloat miterAngle0 = dot( n0i, pmiter - pprev );\n\tfloat miterAngle1 = dot( n1i, pmiter - pnext );\n\tfloat miterLength = dot( offset, offset );\n\tfloat miterSide = direction * cross;\n\n\t// Bevel\n\tvec2 n = ( type == 4.0 || type == 6.0 ? n1 : n0 );\n\tvec2 pbevel = p + offsetSize * n;\n\n\t//\n\tvec2 presult = (\n\t\t0.0 <= miterSide ?\n\t\t( miterAngle0 < 0.0 && 0.0 <= miterAngle1 ? pmiter : pbevel ) :\n\t\t( miterLength < 6.0 ? pmiter : pbevel )\n\t);\n\tvec2 ni = ( type == 4.0 || type == 6.0 ? n1i : n0i );\n\tshift = dot( ni, p - presult );\n\treturn toTransformedPosition( presult );\n}\n\nvec2 toStep3456( in float type ) {\n\treturn ( type < 4.5 ? vec2( 1.0, 0.0 ) : vec2( 0.0, 1.0 ) );\n}\n\nvec4 toAntialias3456( in float strokeWidth ) {\n\tfloat a = antialiasWeight / max( 0.0001, strokeWidth );\n\treturn toAntialias01( vec4( a, a, a, a ) );\n}\n\nfloat toDotAndDashScale( in float scale, in float strokeWidthScale ) {\n\treturn (\n\t\tscale == 4.0 || scale == 5.0 || scale == 6.0 || scale == 7.0 ?\n\t\tstrokeWidthScale : 1.0\n\t);\n}\n\nvec4 toColorStroke3456( in float shift, in float scale ) {\n\tfloat x = aColorFill.x + shift;\n\tfloat y = scale * aColorFill.y;\n\tfloat z = scale * aColorFill.z;\n\tfloat w = aColorFill.w;\n\treturn vec4( x, y, z, w );\n}\n\nfloat toStrokeWidthScale( in float scale ) {\n\treturn (\n\t\tscale == 3.0 || scale == 7.0 ?\n\t\tshapeScale : (\n\t\t\tscale == 1.0 || scale == 5.0 ?\n\t\t\tmin( 1.0, shapeScale ) : (\n\t\t\t\tscale == 2.0 || scale == 6.0 ?\n\t\t\t\tmax( 1.0, shapeScale ) : 1.0\n\t\t\t)\n\t\t)\n\t);\n}\n\nvec2 toStep01(in vec2 size, in vec2 weight, in vec2 strokeWidth) {\n\treturn weight / max(vec2(0.00001), vec2(1.0) - strokeWidth / size);\n}\n\nvec4 toAntialias01b(in vec2 size, in vec2 strokeWidth) {\n\treturn antialiasWeight / max(vec4(0.00001), vec4(size - strokeWidth, size));\n}\n\nvoid main(void) {\n\tvec2 p012 = toTransformedPosition( aPosition );\n\n\tfloat type = aClipping.z;\n\tfloat strokeWidthScale = toStrokeWidthScale( aStep.y );\n\tfloat strokeWidth = strokeWidthScale * aStep.x;\n\n\t// type === 0 or 1\n\tvec2 size01 = aAntialias.xy;\n\tvec2 weight01 = abs(aAntialias.zw - sign(aAntialias.zw));\n\tvec2 strokeWidth01 = step(vec2(0.0), aAntialias.zw) * strokeWidth;\n\tvec2 step01 = toStep01( size01, weight01, strokeWidth01 );\n\tvec4 a01 = toAntialias01( toAntialias01b( size01, strokeWidth01 ) );\n\n\t// type === 2\n\tvec4 a2 = toAntialias2( aAntialias, strokeWidth );\n\n\t// type === 3, 4, 5 or 6\n\tfloat shift3456 = 0.0;\n\tvec2 p3456 = toPosition3456( type, aPosition, aAntialias.xy, aAntialias.zw, strokeWidth, shift3456 );\n\tvec2 step3456 = toStep3456( type );\n\tvec4 a3456 = toAntialias3456( strokeWidth );\n\tvec4 colorStroke3456 = toColorStroke3456( shift3456, toDotAndDashScale( aStep.y, strokeWidthScale ) );\n\n\t//\n\tgl_Position = vec4( ( 2.5 < type ? p3456 : p012 ), 0.0, 1.0 );\n\tvAntialias = ( 1.5 < type ? ( 2.5 < type ? a3456 : a2 ) : a01 );\n\tvClipping = aClipping;\n\tvStep = ( 2.5 < type ? step3456 : step01 );\n\tvColorFill = ( 2.5 < type ? aColorStroke : aColorFill );\n\tvColorStroke = ( 2.5 < type ? colorStroke3456 : aColorStroke );\n\tvUv = aUv;\n}";
    var FRAGMENT_SHADER$1 = "\nvarying mediump vec3 vClipping;\nvarying mediump vec2 vStep;\nvarying mediump vec4 vAntialias;\nvarying mediump vec4 vColorFill;\nvarying mediump vec4 vColorStroke;\nvarying mediump vec2 vUv;\n\nuniform sampler2D sampler;\nuniform mediump float pixelScale;\n\nvoid main(void) {\n\tvec4 texture = texture2D(sampler, vUv);\n\tfloat type = vClipping.z;\n\tvec2 v0 = vStep;\n\tvec2 v1 = vClipping.xy;\n\tvec2 v2 = v0 * vAntialias.xy;\n\tvec2 v3 = v1 * vAntialias.zw;\n\tvec2 d01 = ( v0.x < v0.y ? vec2( v0.y, v2.y ) : vec2( v0.x, v2.x ) );\n\tvec2 d02 = ( v1.x < v1.y ? vec2( v1.y, v3.y ) : vec2( v1.x, v3.x ) );\n\tvec4 d0 = vec4( d01.x, d02.x, d01.y, d02.y );\n\tvec4 d1 = vec4( dot( v0, v0 ), dot( v1, v1 ), dot( v2, v2 ), dot( v3, v3 ) );\n\tvec4 d = ( type == 1.0 ? d1 : d0 );\n\tvec2 s = smoothstep( 1.0 - (d.zw - d.xy), vec2( 1.0 ), d.xy );\n\tvec4 color01 = texture * (vColorStroke * (s.x - s.y) + vColorFill * (1.0 - s.x));\n\n\tfloat l = vColorStroke.x;\n\tfloat lp0 = vColorStroke.y;\n\tfloat lp1 = vColorStroke.z;\n\tfloat lt = vColorStroke.w;\n\tfloat ld = 0.5 * pixelScale;\n\tfloat lm = mod( l, lp0 + lp1 );\n\tfloat ls0 = ( 0.0 < lp1 ? smoothstep( 0.0, ld, lm ) - smoothstep( lp0, lp0 + ld, lm ) : 1.0 );\n\tfloat ls1 = ( 0.0 <= lt ? smoothstep( 0.0, ld, l ) - smoothstep( lt - ld, lt, l ) : 1.0 );\n\tvec4 color3456 = color01 * ls0 * ls1;\n\n\tvec2 a0 = vAntialias.xy;\n\tvec2 a1 = vAntialias.zw;\n\tvec2 a2 = vec2( texture.a );\n\tvec2 a = smoothstep( a0 - a1, a0 + a1, a2 );\n\tvec4 color2 = a.x * vColorFill + ( a.y - a.x ) * vColorStroke;\n\tgl_FragColor = ( type == 2.0 ? color2 : (2.5 < type ? color3456 : color01) );\n}";
    var EShapeRenderer = /** @class */ (function (_super) {
        __extends(EShapeRenderer, _super);
        function EShapeRenderer(renderer) {
            var _this = _super.call(this, renderer) || this;
            EShapeRenderer.SHADER =
                EShapeRenderer.SHADER || pixi_js.Shader.from(VERTEX_SHADER$1, FRAGMENT_SHADER$1);
            _this._shader = EShapeRenderer.SHADER;
            _this._iterator = new EShapeRendererIterator();
            _this._bufferSizeMax = _this.getBufferSizeMax(renderer);
            return _this;
        }
        EShapeRenderer.prototype.getBufferSizeMax = function (renderer) {
            var context = renderer.context;
            var extensions = context.extensions;
            if (1 < context.webGLVersion || !!extensions.uint32ElementIndex) {
                return 1431655765; // 2^32 / 3
            }
            return 21845; // 2^16 / 3
        };
        EShapeRenderer.prototype.updateAtlas = function (shape, atlas, fontAtlases, defaultTexture, baseTexture) {
            // Texture
            // Do not access the shape.image.src here.
            // It slows down the rendering speed significantly.
            var imageSrc = shape.imageSrc;
            if (imageSrc != null) {
                var textureItem = atlas.get(imageSrc);
                if (textureItem != null) {
                    shape.texture = textureItem.texture;
                }
                else {
                    var image = shape.image;
                    if (image != null) {
                        var newTextureItem = new DynamicAtlasItemImage(image, baseTexture);
                        shape.texture = newTextureItem.texture;
                        atlas.set(newTextureItem.id, newTextureItem);
                    }
                    else {
                        shape.texture = defaultTexture;
                    }
                }
            }
            else {
                shape.texture = defaultTexture;
            }
            // Font texture atlas
            var text = shape.text;
            var textValue = text.value;
            if (0 < textValue.length) {
                fontAtlases.add(text.family, textValue);
            }
        };
        EShapeRenderer.prototype.updateAtlases = function (shapes, atlas, fontAtlases, defaultTexture, baseTexture) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                this.updateAtlas(shape, atlas, fontAtlases, defaultTexture, baseTexture);
                var children = shape.children;
                for (var j = 0, jmax = children.length; j < jmax; ++j) {
                    var child = children[j];
                    this.updateAtlas(child, atlas, fontAtlases, defaultTexture, baseTexture);
                    this.updateAtlases(child.children, atlas, fontAtlases, defaultTexture, baseTexture);
                }
            }
        };
        EShapeRenderer.prototype.updateFontAtlas = function (shape, atlas, fontAtlases, defaultTexture) {
            var text = shape.text;
            var fontAtlas = fontAtlases.get(text.family);
            if (fontAtlas != null) {
                var textureItem = atlas.get(fontAtlas.id);
                if (textureItem != null) {
                    text.atlas = fontAtlas;
                    text.texture = textureItem.texture;
                }
                else {
                    text.atlas = undefined;
                    text.texture = defaultTexture;
                }
            }
            else {
                text.atlas = undefined;
                text.texture = defaultTexture;
            }
        };
        EShapeRenderer.prototype.updateFontAtlases = function (shapes, atlas, fontAtlases, defaultTexture) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                this.updateFontAtlas(shape, atlas, fontAtlases, defaultTexture);
                var children = shape.children;
                for (var j = 0, jmax = children.length; j < jmax; ++j) {
                    var child = children[j];
                    this.updateFontAtlas(child, atlas, fontAtlases, defaultTexture);
                    this.updateFontAtlases(child.children, atlas, fontAtlases, defaultTexture);
                }
            }
        };
        EShapeRenderer.prototype.render_ = function (container, shape, shapes, isDirty) {
            var renderer = this.renderer;
            var shader = this._shader;
            if (shader != null && (shape != null || 0 < shapes.length)) {
                var resolution = renderer.resolution;
                var buffers = container.getBuffers();
                var antialiasWeight = container.getAntialiasWeight(resolution);
                // Update textures
                if (isDirty) {
                    // Atlases
                    var atlas = container.getAtlas(resolution);
                    var fontAtlases = container.getFontAtlases();
                    atlas.begin();
                    fontAtlases.begin();
                    var defaultTexture = atlas.getDefaultTexture();
                    var baseTexture = atlas.getBaseTexture();
                    this.updateAtlases(shapes, atlas, fontAtlases, defaultTexture, baseTexture);
                    fontAtlases.end();
                    fontAtlases.update(atlas);
                    this.updateFontAtlases(shapes, atlas, fontAtlases, defaultTexture);
                    atlas.end();
                    atlas.repack();
                    // Update buffers
                    this.updateBuffers(shape, shapes, buffers, renderer, antialiasWeight);
                }
                // Render buffers
                shader.uniforms.shapeScale = container.toShapeScale();
                shader.uniforms.pixelScale = container.toPixelScale(resolution);
                shader.uniforms.antialiasWeight = antialiasWeight;
                shader.uniforms.translationMatrix = container.worldTransform.toArray(true);
                renderer.shader.bind(shader, false);
                renderer.state.setBlendMode(pixi_js.utils.correctBlendMode(pixi_js.BLEND_MODES.NORMAL, true));
                var buffersLength = buffers.length;
                if (1 < buffersLength) {
                    for (var i = 0; i < buffersLength; ++i) {
                        buffers[i].upload();
                    }
                }
                for (var i = 0; i < buffersLength; ++i) {
                    buffers[i].render(shader);
                }
            }
        };
        EShapeRenderer.prototype.updateBuffers = function (shape, shapes, buffers, renderer, antialiasWeight) {
            var iterator = this._iterator;
            iterator.reset(shape, shapes);
            var ib = 0;
            var bufferSize = 0;
            var bufferSizeBase = 5000;
            var bufferSizeMax = this._bufferSizeMax;
            while (iterator.get() != null) {
                var buffer = null;
                var noMoreThanOne = false;
                if (0 < bufferSize) {
                    buffer = new EShapeBuffer(bufferSize, renderer);
                    buffers.splice(ib, 0, buffer);
                    noMoreThanOne = true;
                }
                else if (ib < buffers.length) {
                    buffer = buffers[ib];
                    noMoreThanOne = false;
                }
                else {
                    buffer = new EShapeBuffer(bufferSizeBase, renderer);
                    buffers.push(buffer);
                    noMoreThanOne = false;
                }
                if (buffer.update(iterator, antialiasWeight, noMoreThanOne)) {
                    bufferSize = 0;
                    ib += 1;
                }
                else {
                    bufferSize = buffer.indexCountRequested;
                    if (bufferSize <= bufferSizeMax) {
                        bufferSize = Math.ceil(bufferSize / bufferSizeBase) * bufferSizeBase;
                        bufferSize = Math.min(bufferSize, bufferSizeMax);
                    }
                    else {
                        // No way to render
                        break;
                    }
                }
            }
            if (ib < buffers.length) {
                for (var jb = ib, ibmax = buffers.length; jb < ibmax; ++jb) {
                    buffers[jb].destroy();
                }
                buffers.length = ib;
            }
        };
        EShapeRenderer.SHADER = null;
        return EShapeRenderer;
    }(pixi_js.ObjectRenderer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeContainer = /** @class */ (function (_super) {
        __extends(EShapeContainer, _super);
        function EShapeContainer() {
            var _this = _super.call(this) || this;
            _this._shapeRenderer = null;
            _this.children = [];
            _this._shape = null;
            _this._childrenId = 0;
            _this._childrenIdRendered = -1;
            _this._atlas = null;
            _this._fontAtlases = new DynamicSDFFontAtlases();
            _this._pixelScale = 1;
            _this._pixelScaleId = NaN;
            _this._shapeScale = 1;
            _this._shapeScaleId = NaN;
            _this._work = new pixi_js.Point();
            _this._buffers = [];
            return _this;
        }
        EShapeContainer.prototype.calculateBounds = function () {
            this._bounds.clear();
        };
        EShapeContainer.prototype.onChildTransformChange = function () {
            // DO NOTHING
        };
        EShapeContainer.prototype.toDirty = function () {
            return (this._childrenId += 1);
        };
        EShapeContainer.prototype.isDirty = function () {
            return this._childrenIdRendered < this._childrenId;
        };
        EShapeContainer.prototype.render = function (renderer) {
            if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
                return;
            }
            var childrenId = this._childrenId;
            var childrenIdRendered = this._childrenIdRendered;
            this._childrenIdRendered = childrenId;
            var isChildrenDirty = childrenIdRendered < childrenId;
            var shapeRenderer = this._shapeRenderer;
            if (shapeRenderer == null) {
                shapeRenderer = this._shapeRenderer = new EShapeRenderer(renderer);
            }
            renderer.batch.setObjectRenderer(shapeRenderer);
            var mask = this.mask;
            var shape = this._shape;
            var shapes = this.children;
            if (mask) {
                renderer.mask.push(this, mask);
                shapeRenderer.render_(this, shape, shapes, isChildrenDirty);
                renderer.mask.pop(this);
            }
            else {
                shapeRenderer.render_(this, shape, shapes, isChildrenDirty);
            }
        };
        EShapeContainer.prototype.containsPoint = function (point) {
            return false;
        };
        EShapeContainer.prototype.getFontAtlases = function () {
            return this._fontAtlases;
        };
        EShapeContainer.prototype.getAtlas = function (resolution) {
            var atlas = this._atlas;
            if (atlas == null) {
                atlas = new DynamicAtlas(resolution);
                this._atlas = atlas;
            }
            return atlas;
        };
        EShapeContainer.prototype.getBuffers = function () {
            return this._buffers;
        };
        EShapeContainer.prototype.toShapeScale = function () {
            this.updateTransform();
            var transform = this.transform;
            var worldID = transform._worldID;
            if (worldID !== this._shapeScaleId) {
                this._shapeScaleId = worldID;
                var worldTransform = transform.worldTransform;
                var a = worldTransform.a;
                var b = worldTransform.b;
                this._shapeScale = 1 / Math.sqrt(a * a + b * b);
            }
            return this._shapeScale;
        };
        EShapeContainer.prototype.getShapeScale = function () {
            return this._shapeScale;
        };
        EShapeContainer.prototype.toPixelScale = function (resolution) {
            var shapeScale = this.toShapeScale();
            var shapeScaleId = this._shapeScaleId;
            if (this._pixelScaleId !== shapeScaleId) {
                this._pixelScaleId = shapeScaleId;
                this._pixelScale = (1 / resolution) * shapeScale;
            }
            return this._pixelScale;
        };
        EShapeContainer.prototype.getPixelScale = function () {
            return this._pixelScale;
        };
        EShapeContainer.prototype.getAntialiasWeight = function (resolution) {
            return 1.25 / resolution;
        };
        EShapeContainer.prototype.hitTest = function (global, onHit) {
            var local = this._work;
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                if (child.visible) {
                    child.toLocal(global, undefined, local);
                    var result = child.contains(local.x, local.y);
                    if (result != null) {
                        if (onHit == null || onHit(result)) {
                            return result;
                        }
                    }
                }
            }
            return null;
        };
        EShapeContainer.prototype.hitTestBBox = function (global, onHit) {
            var local = this._work;
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                var child = children[i];
                if (child.visible) {
                    child.toLocal(global, undefined, local);
                    if (child.containsBBox(local.x, local.y)) {
                        if (onHit == null || onHit(child)) {
                            return child;
                        }
                    }
                }
            }
            return null;
        };
        EShapeContainer.prototype.destroy = function () {
            // Buffer
            var buffers = this._buffers;
            if (buffers != null) {
                for (var i = 0, imax = buffers.length; i < imax; ++i) {
                    buffers[i].destroy();
                }
            }
            this._buffers.length = 0;
            // Shapes
            var children = this.children;
            for (var i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            //
            _super.prototype.destroy.call(this);
        };
        return EShapeContainer;
    }(pixi_js.DisplayObject));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEmbeddedLayer = /** @class */ (function (_super) {
        __extends(EShapeEmbeddedLayer, _super);
        function EShapeEmbeddedLayer(name, mode, depth, type) {
            if (type === void 0) { type = EShapeType.EMBEDDED_LAYER; }
            var _this = _super.call(this, mode, depth, type) || this;
            _this._name = name;
            return _this;
        }
        Object.defineProperty(EShapeEmbeddedLayer.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: false,
            configurable: true
        });
        EShapeEmbeddedLayer.prototype.newGroupFill = function () {
            return new EShapeFillImpl(this, false, 0xffffff, 1);
        };
        EShapeEmbeddedLayer.prototype.isGroupSizeFittable = function () {
            return false;
        };
        EShapeEmbeddedLayer.prototype.newGroupSize = function (mode, depth) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
        };
        EShapeEmbeddedLayer.prototype.clone = function () {
            var result = this.newClone().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            var size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                var base = size.base;
                result.size.set(base.x, base.y).init().set(size.x, size.y);
            }
            else {
                result.size.init();
            }
            return result;
        };
        EShapeEmbeddedLayer.prototype.newClone = function () {
            var constructor = this.constructor;
            return new constructor(this._name, this._mode, this._depth, this.type);
        };
        EShapeEmbeddedLayer.prototype.serializeChildren = function (manager) {
            return [];
        };
        EShapeEmbeddedLayer.prototype.serializeImage = function (manager) {
            return -1;
        };
        EShapeEmbeddedLayer.prototype.serializeGradient = function (manager) {
            return -1;
        };
        return EShapeEmbeddedLayer;
    }(EShapeGroupViewer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayers = /** @class */ (function () {
        function DDiagramLayers() {
        }
        DDiagramLayers.toLayers = function (shape, indices) {
            var result = [];
            var layer = this.toLayer(shape);
            if (layer) {
                var container = layer.parent;
                if (container) {
                    var children = container.children;
                    var childrenLength = children.length;
                    for (var i = 0, imax = indices.length; i < imax; ++i) {
                        var index = indices[i];
                        if (0 <= index && index < childrenLength) {
                            result.push(children[index]);
                        }
                    }
                }
            }
            return result;
        };
        DDiagramLayers.toLayer = function (shape) {
            var parent = shape.parent;
            while (parent != null) {
                if (parent instanceof EShapeContainer) {
                    return parent;
                }
                if (parent instanceof EShapeEmbeddedLayer) {
                    return parent;
                }
                parent = parent.parent;
            }
            return null;
        };
        DDiagramLayers.show = function (target) {
            if (!target.visible) {
                target.visible = true;
                return true;
            }
            return false;
        };
        DDiagramLayers.showAll = function (targets) {
            var isChanged = false;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var layer = targets[i];
                if (!layer.visible) {
                    layer.visible = true;
                    isChanged = true;
                }
            }
            return isChanged;
        };
        DDiagramLayers.hide = function (target) {
            if (target.visible) {
                target.visible = false;
                return true;
            }
            return false;
        };
        DDiagramLayers.hideAll = function (targets) {
            var isChanged = false;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var layer = targets[i];
                if (layer.visible) {
                    layer.visible = false;
                    isChanged = true;
                }
            }
            return isChanged;
        };
        DDiagramLayers.bringToFront = function (target) {
            var parent = target.parent;
            if (parent) {
                return this.doBringToFront(target, parent.children, 0);
            }
            return false;
        };
        DDiagramLayers.bringAllToFront = function (targets) {
            var targetsLength = targets.length;
            if (0 < targetsLength) {
                var parent_1 = targets[0].parent;
                if (parent_1) {
                    var isChanged = false;
                    var layers = parent_1.children;
                    for (var i = 0; i < targetsLength; ++i) {
                        var layer = targets[targetsLength - 1 - i];
                        if (this.doBringToFront(layer, layers, i)) {
                            isChanged = true;
                        }
                    }
                    return isChanged;
                }
            }
            return false;
        };
        DDiagramLayers.doBringToFront = function (target, layers, offset) {
            var layersLength = layers.length;
            var ito = layersLength - 1 - offset;
            for (var i = ito; 0 <= i; --i) {
                var child = layers[i];
                if (child === target) {
                    if (i !== ito) {
                        for (var j = i + 1; j <= ito; ++j) {
                            layers[j - 1] = layers[j];
                        }
                        layers[ito] = child;
                        return true;
                    }
                    return false;
                }
            }
            return false;
        };
        return DDiagramLayers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DRAG = 1;
    var PINCH = 2;
    var EShapeActionValueGestureOperationType = {
        NONE: 0,
        DRAG: DRAG,
        PINCH: PINCH,
        ALL: DRAG | PINCH
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var InteractionEvent$3 = pixi_js.interaction.InteractionEvent;
    var EShapeActionRuntimeGestureLayer = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeGestureLayer, _super);
        function EShapeActionRuntimeGestureLayer(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this._layers = new Map();
            _this._operationType = value.operationType;
            _this._scaleMin = value.scaleMin;
            _this._scaleMax = value.scaleMax;
            return _this;
        }
        EShapeActionRuntimeGestureLayer.prototype.initialize = function (shape, runtime) {
            _super.prototype.initialize.call(this, shape, runtime);
            var layers = this._layers;
            var layer = layers.get(shape);
            if (layer == null) {
                var newLayer = DDiagramLayers.toLayer(shape);
                if (newLayer != null) {
                    this._layers.set(shape, newLayer);
                }
            }
        };
        EShapeActionRuntimeGestureLayer.prototype.onDown = function (shape, runtime, e) {
            _super.prototype.onDown.call(this, shape, runtime, e);
            if (e instanceof InteractionEvent$3) {
                var layer = this._layers.get(shape);
                var time = e.data.originalEvent.timeStamp;
                if (layer && this.condition(shape, time, EShapeActionEnvironment)) {
                    this.getGestureUtil().onDown(layer, e);
                }
            }
        };
        EShapeActionRuntimeGestureLayer.prototype.getGestureUtil = function () {
            var _a;
            return ((_a = EShapeActionRuntimeGestureLayer.GESTURE_UTIL) !== null && _a !== void 0 ? _a : (EShapeActionRuntimeGestureLayer.GESTURE_UTIL = this.newGestureUtil()));
        };
        EShapeActionRuntimeGestureLayer.prototype.newGestureUtil = function () {
            var _this = this;
            var work = new pixi_js.Point();
            return new UtilGesture({
                on: {
                    move: function (target, dx, dy, x, y, ds) {
                        _this.onGestureMove(target, dx, dy, x, y, ds, work);
                    }
                }
            });
        };
        EShapeActionRuntimeGestureLayer.prototype.onGestureMove = function (layer, dx, dy, x, y, ds, work) {
            var parent = layer.parent;
            if (parent) {
                var transform = layer.transform;
                var gestureType = this._operationType;
                var isChanged = false;
                // Scale
                var scaleRatio = 1;
                if (gestureType & EShapeActionValueGestureOperationType.PINCH) {
                    var scale = transform.scale;
                    var oldScale = scale.y;
                    var newScale = Math.min(this._scaleMax, Math.max(this._scaleMin, oldScale * ds));
                    scaleRatio = newScale / oldScale;
                    scale.set(newScale, newScale);
                    isChanged = true;
                }
                // Position
                if (gestureType & EShapeActionValueGestureOperationType.DRAG) {
                    parent.toLocal(work.set(x, y), undefined, work);
                    var lx = work.x;
                    var ly = work.y;
                    var cx = x - dx;
                    var cy = y - dy;
                    parent.toLocal(work.set(cx, cy), undefined, work);
                    var lcx = work.x;
                    var lcy = work.y;
                    var position = transform.position;
                    var newX = (position.x - lcx) * scaleRatio + lx;
                    var newY = (position.y - lcy) * scaleRatio + ly;
                    position.set(newX, newY);
                    isChanged = true;
                }
                // Update
                if (isChanged) {
                    DApplications.update(layer);
                }
            }
        };
        EShapeActionRuntimeGestureLayer.prototype.toSize = function (layer, result) {
            if ("size" in layer) {
                result.copyFrom(layer.size);
            }
            else {
                result.set(layer.width, layer.height);
            }
            return result;
        };
        return EShapeActionRuntimeGestureLayer;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var InteractionEvent$2 = pixi_js.interaction.InteractionEvent;
    var EShapeActionRuntimeGestureShape = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeGestureShape, _super);
        function EShapeActionRuntimeGestureShape(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this._operationType = value.operationType;
            _this._scaleMin = value.scaleMin;
            _this._scaleMax = value.scaleMax;
            return _this;
        }
        EShapeActionRuntimeGestureShape.prototype.onDown = function (shape, runtime, e) {
            _super.prototype.onDown.call(this, shape, runtime, e);
            if (e instanceof InteractionEvent$2) {
                if (this.condition(shape, e.data.originalEvent.timeStamp, EShapeActionEnvironment)) {
                    this.getGestureUtil().onDown(shape, e);
                }
            }
        };
        EShapeActionRuntimeGestureShape.prototype.getGestureUtil = function () {
            var _a;
            return ((_a = EShapeActionRuntimeGestureShape.GESTURE_UTIL) !== null && _a !== void 0 ? _a : (EShapeActionRuntimeGestureShape.GESTURE_UTIL = this.newGestureUtil()));
        };
        EShapeActionRuntimeGestureShape.prototype.newGestureUtil = function () {
            var _this = this;
            var work = new pixi_js.Point();
            return new UtilGesture({
                on: {
                    move: function (target, dx, dy, x, y, ds) {
                        _this.onGestureMove(target, dx, dy, x, y, ds, work);
                    }
                }
            });
        };
        EShapeActionRuntimeGestureShape.prototype.onGestureMove = function (target, dx, dy, x, y, ds, work) {
            var parent = target.parent;
            if (parent) {
                var transform = target.transform;
                var gestureType = this._operationType;
                var isChanged = false;
                // Scale
                var scaleRatio = 1;
                if (gestureType & EShapeActionValueGestureOperationType.PINCH) {
                    var scale = transform.scale;
                    var oldScale = scale.y;
                    var newScale = Math.min(this._scaleMax, Math.max(this._scaleMin, oldScale * ds));
                    scaleRatio = newScale / oldScale;
                    scale.set(newScale, newScale);
                    isChanged = true;
                }
                // Position
                if (gestureType & EShapeActionValueGestureOperationType.DRAG) {
                    parent.toLocal(work.set(x, y), undefined, work);
                    var lx = work.x;
                    var ly = work.y;
                    var cx = x - dx;
                    var cy = y - dy;
                    parent.toLocal(work.set(cx, cy), undefined, work);
                    var lcx = work.x;
                    var lcy = work.y;
                    var position = transform.position;
                    var newX = (position.x - lcx) * scaleRatio + lx;
                    var newY = (position.y - lcy) * scaleRatio + ly;
                    position.set(newX, newY);
                    isChanged = true;
                }
                // Update
                if (isChanged) {
                    DApplications.update(target);
                }
            }
        };
        return EShapeActionRuntimeGestureShape;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueGestureType = {
        SHAPE: 0,
        LAYER: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscType = {
        INPUT_TEXT: 0,
        INPUT_INTEGER: 1,
        INPUT_REAL: 2,
        EMIT_EVENT: 3,
        WRITE_BOTH: 4,
        WRITE_LOCAL: 5,
        WRITE_REMOTE: 6,
        HTML_ELEMENT: 7,
        HTML_ELEMENT_WITHOUT_POINTER_EVENTS: 8,
        /** @deprecated in favor of {@link EShapeActionValueShowHideType}'s LAYER */
        SHOW_HIDE_LAYER: 9,
        /** @deprecated in favor of {@link EShapeActionValueType}'s GESTURE */
        GESTURE_LAYER: 10,
        /** @deprecated in favor of {@link EShapeActionValueType}'s GESTURE */
        GESTURE: 11,
        EXECUTE: 12
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueGesture = /** @class */ (function (_super) {
        __extends(EShapeActionValueGesture, _super);
        function EShapeActionValueGesture(condition, subtype, operationType, scaleMin, scaleMax) {
            if (condition === void 0) { condition = ""; }
            if (scaleMin === void 0) { scaleMin = 0.05; }
            if (scaleMax === void 0) { scaleMax = 20; }
            var _this = _super.call(this, EShapeActionValueType.GESTURE, condition, subtype) || this;
            _this.operationType = operationType;
            _this.scaleMin = scaleMin;
            _this.scaleMax = scaleMax;
            return _this;
        }
        EShapeActionValueGesture.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueGestureType.SHAPE:
                    return new EShapeActionRuntimeGestureShape(this);
                case EShapeActionValueGestureType.LAYER:
                    return new EShapeActionRuntimeGestureLayer(this);
            }
        };
        EShapeActionValueGesture.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.operationType, ",").concat(this.scaleMin, ",").concat(this.scaleMax, "]"));
        };
        EShapeActionValueGesture.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var subtype = this.toSubType(serialized);
            var operationType = serialized[3];
            var scaleMin = serialized[4];
            var scaleMax = serialized[5];
            return new EShapeActionValueGesture(condition, subtype, operationType, scaleMin, scaleMax);
        };
        EShapeActionValueGesture.toSubType = function (serialized) {
            if (serialized[0] === EShapeActionValueType.MISC) {
                switch (serialized[2]) {
                    case EShapeActionValueMiscType.GESTURE:
                        return EShapeActionValueGestureType.SHAPE;
                    case EShapeActionValueMiscType.GESTURE_LAYER:
                        return EShapeActionValueGestureType.LAYER;
                }
            }
            else {
                return serialized[2];
            }
        };
        return EShapeActionValueGesture;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLayerState = {
        INVISIBLE: "INVISIBLE",
        INTERACTIVE: "INTERACTIVE",
        DRAGGABLE: "DRAGGABLE",
        PINCHABLE: "PINCHABLE"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeEmbeddedLayerName = function (target, manager) {
        if (isString(target)) {
            return target;
        }
        else {
            var resources = manager.resources;
            if (0 <= target && target <= resources.length) {
                return resources[target];
            }
            return "";
        }
    };
    var deserializeEmbeddedLayer = function (serialized, manager, width, height, creator) {
        var _a, _b, _c;
        var name = deserializeEmbeddedLayerName(serialized[0], manager);
        var result = creator
            ? creator(name, manager)
            : new EShapeEmbeddedLayer(name, manager.mode, manager.depth);
        var visibility = serialized[1];
        var visible = visibility == null || !!(visibility & 0x2);
        if (!visible) {
            result.visible = false;
            result.state.add(EShapeLayerState.INVISIBLE);
        }
        var positionX = -0.5 * width + (serialized[2] || 0);
        var positionY = -0.5 * height + (serialized[3] || 0);
        result.transform.position.set(positionX, positionY);
        var sizeX = (_a = serialized[4]) !== null && _a !== void 0 ? _a : width;
        var sizeY = (_b = serialized[5]) !== null && _b !== void 0 ? _b : height;
        result.size.set(sizeX, sizeY);
        result.size.init();
        var fillId = serialized[6];
        if (fillId != null) {
            result.fill.deserialize(fillId, manager);
        }
        if (manager.mode === EShapeResourceManagerDeserializationMode.VIEWER) {
            var state = (_c = serialized[7]) !== null && _c !== void 0 ? _c : 1;
            var isInteractive = state & 0x1;
            var isDraggable = state & 0x2;
            var isPinchable = state & 0x4;
            if (isDraggable || isPinchable) {
                var gestureType = (isDraggable
                    ? EShapeActionValueGestureOperationType.DRAG
                    : EShapeActionValueGestureOperationType.NONE) |
                    (isPinchable
                        ? EShapeActionValueGestureOperationType.PINCH
                        : EShapeActionValueGestureOperationType.NONE);
                result.action.add(new EShapeActionValueGesture("", EShapeActionValueGestureType.LAYER, gestureType));
            }
            if (isInteractive || isDraggable || isPinchable) {
                result.interactive = true;
            }
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEmbeddedLayerContainer = /** @class */ (function () {
        function EShapeEmbeddedLayerContainer(width, height) {
            this.children = [];
            this._width = width;
            this._height = height;
        }
        EShapeEmbeddedLayerContainer.prototype.hasConnectors = function (shapes) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                if (shape instanceof EShapeConnectorLine) {
                    return true;
                }
                var children = shape.children;
                if (0 < children.length) {
                    if (this.hasConnectors(children)) {
                        return true;
                    }
                }
            }
            return false;
        };
        EShapeEmbeddedLayerContainer.prototype.newHasConnectors = function () {
            var result = new Map();
            var layers = this.children;
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                var layer = layers[i];
                result.set(layer, this.hasConnectors(layer.children));
            }
            return result;
        };
        EShapeEmbeddedLayerContainer.prototype.copyTo = function (destination) {
            var _a;
            var hasConnectors = ((_a = this._hasConnectors) !== null && _a !== void 0 ? _a : (this._hasConnectors = this.newHasConnectors()));
            var layers = this.children;
            var children = destination.children;
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                var layer = layers[i];
                var clone = layer.clone();
                clone.parent = destination;
                children.push(clone);
                if (hasConnectors.get(layer)) {
                    EShapeConnectors.move(layer, clone);
                }
            }
            destination.onChildTransformChange();
            destination.toDirty();
            destination.onAttach();
        };
        EShapeEmbeddedLayerContainer.prototype.deserialize = function (serializedLayers, manager) {
            var serializedLayersLength = serializedLayers.length;
            if (0 < serializedLayersLength) {
                var width = this._width;
                var height = this._height;
                for (var i = 0; i < serializedLayersLength; ++i) {
                    this.children.push(deserializeEmbeddedLayer(serializedLayers[i], manager, width, height));
                }
            }
        };
        return EShapeEmbeddedLayerContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagrams = /** @class */ (function () {
        function DDiagrams() {
        }
        DDiagrams.toSimple = function (serialized) {
            return {
                version: serialized.version,
                id: serialized.id,
                name: serialized.name,
                thumbnail: serialized.thumbnail,
                data: JSON.stringify({
                    width: serialized.width,
                    height: serialized.height,
                    background: serialized.background,
                    tile: serialized.tile,
                    resources: serialized.resources,
                    data: serialized.data || serialized.tags,
                    pieces: serialized.pieces,
                    layers: serialized.layers,
                    items: serialized.items,
                    snap: serialized.snap
                })
            };
        };
        DDiagrams.toSerialized = function (target) {
            if (!("items" in target)) {
                var data = JSON.parse(target.data);
                var result = {
                    version: target.version,
                    id: target.id,
                    name: target.name,
                    width: data.width,
                    height: data.height,
                    background: data.background,
                    tile: data.tile,
                    resources: data.resources,
                    data: data.data || data.tags,
                    pieces: data.pieces,
                    layers: data.layers,
                    items: data.items,
                    snap: data.snap,
                    thumbnail: target.thumbnail
                };
                if (result.data == null) {
                    var tags = target.tags;
                    if (tags != null) {
                        result.data = JSON.parse(tags);
                    }
                }
                if (result.pieces == null) {
                    var pieces = target.pieces;
                    if (pieces != null) {
                        result.pieces = JSON.parse(pieces);
                    }
                }
                return result;
            }
            return target;
        };
        DDiagrams.newLayer = function (serialized, container, manager) {
            // Layers
            container.deserialize(serialized.layers, manager);
            // Items
            var serializedItems = serialized.items;
            var shapePromises = deserializeAll(serializedItems, manager);
            if (shapePromises != null) {
                return shapePromises.then(function (shapes) {
                    var layers = container.children;
                    for (var i = 0, imax = shapes.length; i < imax; ++i) {
                        var serializedItem = serializedItems[i];
                        var shape = shapes[i];
                        var layer = layers[serializedItem[16]];
                        if (layer != null) {
                            shape.parent = layer;
                            shape.uploaded = undefined;
                            layer.children.push(shape);
                        }
                    }
                    for (var i = 0, imax = layers.length; i < imax; ++i) {
                        var layer = layers[i];
                        layer.onChildTransformChange();
                        layer.toDirty();
                        var children = layer.children;
                        for (var j = 0, jmax = children.length; j < jmax; ++j) {
                            children[j].onAttach();
                        }
                    }
                    return shapes;
                });
            }
            else {
                return Promise.resolve([]);
            }
        };
        DDiagrams.toPieceData = function (controller, pieces, mode) {
            var pieceToDatum = new Map();
            var pieceToPromise = new Map();
            var onFulfilled = function () {
                return pieceToDatum;
            };
            return this.toPieceData_(controller, pieces, pieceToDatum, pieceToPromise, mode, 0).then(onFulfilled, onFulfilled);
        };
        DDiagrams.toPieceData_ = function (controller, pieces, pieceToDatum, pieceToPromise, mode, depth) {
            var _this = this;
            var promises = [];
            if (pieces && 0 < pieces.length && controller) {
                var _loop_1 = function (i, imax) {
                    var piece = pieces[i];
                    var promise = pieceToPromise.get(piece);
                    if (promise != null) {
                        promises.push(promise);
                    }
                    else {
                        var newPromise = controller.piece.getByName(piece).then(function (found) {
                            return _this.toPieceData__(controller, piece, found, mode, depth + 1, pieceToDatum, pieceToPromise);
                        }, function () {
                            return null;
                        });
                        pieceToPromise.set(piece, newPromise);
                        promises.push(newPromise);
                    }
                };
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    _loop_1(i, imax);
                }
            }
            return Promise.all(promises);
        };
        DDiagrams.toPieceData__ = function (controller, name, serializedOrSimple, mode, depth, pieceToDatum, pieceToPromise) {
            var _this = this;
            var serialized = this.toSerialized(serializedOrSimple);
            var width = serialized.width;
            var height = serialized.height;
            var container = new EShapeEmbeddedLayerContainer(width, height);
            pieceToDatum.set(name, new EShapeEmbeddedDatum(name, width, height, container));
            var pieces = serialized.pieces;
            return this.toPieceData_(controller, pieces, pieceToDatum, pieceToPromise, mode, depth).then(function () {
                return _this.newLayer(serialized, container, new EShapeResourceManagerDeserialization(serialized, pieces, pieceToDatum, mode, depth));
            });
        };
        return DDiagrams;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionOpenOpeners = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActions = /** @class */ (function () {
        function EShapeActions() {
        }
        EShapeActions.isContainer = function (target) {
            return target instanceof DCanvasContainer;
        };
        EShapeActions.isEmbedded = function (target) {
            return target instanceof EShapeEmbedded;
        };
        EShapeActions.toContainer = function (shape) {
            var current = shape;
            while (current != null) {
                if (this.isContainer(current)) {
                    return current;
                }
                current = current.parent;
            }
            return null;
        };
        EShapeActions.open = function (shape, type, target, inNewWindow) {
            var opener = EShapeActionOpenOpeners[type];
            if (opener != null) {
                opener(target, inNewWindow, shape);
            }
            else {
                switch (type) {
                    case DDiagramBaseControllerOpenType.DIAGRAM:
                        var container_1 = this.toContainer(shape);
                        if (container_1) {
                            var controller = container_1.controller;
                            if (controller) {
                                controller.getByName(target).then(function (found) {
                                    container_1.set(DDiagrams.toSerialized(found));
                                });
                            }
                        }
                        break;
                    case DDiagramBaseControllerOpenType.PAGE:
                        if (inNewWindow) {
                            window.open(target);
                        }
                        else {
                            window.location.href = target;
                        }
                        break;
                }
            }
        };
        EShapeActions.writeLocal = function (shape, id, value, time, state) {
            var _a;
            if (state === void 0) { state = EShapeDataValueState.FOUND; }
            var current = shape;
            while (current != null) {
                if (this.isContainer(current)) {
                    if (current.data.private.set(id, value, time, state)) {
                        DApplications.update(current);
                        return true;
                    }
                    else if (current.data.protected.set(id, value, time, state)) {
                        DApplications.update(current);
                        return true;
                    }
                    else {
                        if (current.data.set(id, value, time, state)) {
                            DApplications.update(current);
                            return true;
                        }
                    }
                    return false;
                }
                else if (this.isEmbedded(current)) {
                    if ((_a = current.data.getPrivate()) === null || _a === void 0 ? void 0 : _a.set(id, value, time, state)) {
                        DApplications.update(current);
                        return true;
                    }
                }
                current = current.parent;
            }
            return false;
        };
        EShapeActions.writeRemote = function (shape, id, value) {
            var container = this.toContainer(shape);
            if (container) {
                return container.data.remote.set(id, value);
            }
            return false;
        };
        EShapeActions.emit = function (shape, name, value, time) {
            var container = EShapeActions.toContainer(shape);
            if (time === undefined) {
                shape.emit(name, shape);
                if (container) {
                    container.shape.emit(name, shape);
                }
            }
            else {
                shape.emit(name, value, time, shape);
                if (container) {
                    container.shape.emit(name, value, time, shape);
                }
            }
        };
        return EShapeActions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeEmitEvent, _super);
        function EShapeActionRuntimeEmitEvent(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.name = EShapeActionExpressions.ofStringOrNull(value.name);
            return _this;
        }
        EShapeActionRuntimeEmitEvent.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var name_1 = this.name(shape, time, EShapeActionEnvironment);
                if (name_1 != null) {
                    EShapeActions.emit(shape, name_1);
                }
            }
        };
        return EShapeActionRuntimeEmitEvent;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionValueEmitEvent, _super);
        function EShapeActionValueEmitEvent(condition, name) {
            var _this = _super.call(this, EShapeActionValueType.EMIT_EVENT, condition) || this;
            _this.name = name;
            return _this;
        }
        EShapeActionValueEmitEvent.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueEmitEvent &&
                this.name === value.name);
        };
        EShapeActionValueEmitEvent.prototype.toRuntime = function () {
            return new EShapeActionRuntimeEmitEvent(this);
        };
        EShapeActionValueEmitEvent.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var nameId = manager.addResource(this.name);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(nameId, "]"));
        };
        EShapeActionValueEmitEvent.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueEmitEvent(condition, name);
        };
        return EShapeActionValueEmitEvent;
    }(EShapeActionValueBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscEmitEvent, _super);
        function EShapeActionRuntimeMiscEmitEvent(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            return _this;
        }
        EShapeActionRuntimeMiscEmitEvent.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var target = this.target(shape, time, EShapeActionEnvironment);
                if (target != null) {
                    EShapeActions.emit(shape, target);
                }
            }
        };
        return EShapeActionRuntimeMiscEmitEvent;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DHtmlElementState = {
        NO_POINTER_EVENTS: "NO_POINTER_EVENTS"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHtmlElementClipperExImpl = /** @class */ (function () {
        function UtilHtmlElementClipperExImpl(container) {
            var SVG_XMLNS = "http://www.w3.org/2000/svg";
            var element = document.createElementNS(SVG_XMLNS, "svg");
            element.setAttribute("style", "position: absolute;");
            element.setAttribute("width", "0px");
            element.setAttribute("height", "0px");
            var defs = document.createElementNS(SVG_XMLNS, "defs");
            var clipPath = document.createElementNS(SVG_XMLNS, "clipPath");
            var clipPathId = "clipper_ex_".concat(Math.random().toString(32).substring(2));
            clipPath.setAttribute("id", clipPathId);
            clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
            var path = document.createElementNS(SVG_XMLNS, "path");
            this._path = path;
            this._pathD = "";
            path.setAttribute("clip-rule", "evenodd");
            clipPath.appendChild(path);
            defs.appendChild(clipPath);
            element.appendChild(defs);
            this._id = clipPathId;
            container.appendChild(element);
        }
        Object.defineProperty(UtilHtmlElementClipperExImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        UtilHtmlElementClipperExImpl.prototype.update = function (elementRect, elementMatrix, clipperExRects) {
            var d = this.toD(elementRect, elementMatrix, clipperExRects);
            if (this._pathD != d) {
                this._path.setAttribute("d", d);
                this._pathD = d;
            }
        };
        UtilHtmlElementClipperExImpl.prototype.toD = function (elementRect, elementMatrix, clipperExRects) {
            var _a, _b;
            if (elementRect == null) {
                return "";
            }
            var w = elementRect.width;
            var h = elementRect.height;
            var threshold = 0.0001;
            if (w < threshold || h < threshold) {
                return "";
            }
            var clipperExRectsSize = clipperExRects.size;
            if (clipperExRectsSize <= 0) {
                return "M0,0 h1 v1 h-1z";
            }
            var matrix = ((_a = UtilHtmlElementClipperExImpl.WORK_MATRIX) !== null && _a !== void 0 ? _a : (UtilHtmlElementClipperExImpl.WORK_MATRIX = new pixi_js.Matrix()));
            if (elementMatrix != null) {
                matrix.copyFrom(elementMatrix);
                matrix.invert();
            }
            else {
                matrix.identity();
            }
            matrix.translate(-elementRect.x, -elementRect.y);
            matrix.scale(1 / w, 1 / h);
            var xmin = -1;
            var xmax = +2;
            var ymin = -1;
            var ymax = +2;
            var result = "";
            var a = matrix.a;
            var b = matrix.b;
            var c = matrix.c;
            var d = matrix.d;
            var tx = matrix.tx;
            var ty = matrix.ty;
            var rects = ((_b = UtilHtmlElementClipperExImpl.WORK_RECTS) !== null && _b !== void 0 ? _b : (UtilHtmlElementClipperExImpl.WORK_RECTS = []));
            var rectsLength = this.toRects(clipperExRects, rects);
            var precision = 5;
            for (var i = 0; i < rectsLength; i += 4) {
                var x0 = rects[i + 0];
                var y0 = rects[i + 1];
                var x1 = rects[i + 2];
                var y1 = rects[i + 3];
                var x2 = a * x0 + c * y0 + tx;
                var y2 = b * x0 + d * y0 + ty;
                var x3 = a * x1 + c * y0 + tx;
                var y3 = b * x1 + d * y0 + ty;
                var x4 = a * x1 + c * y1 + tx;
                var y4 = b * x1 + d * y1 + ty;
                var x5 = a * x0 + c * y1 + tx;
                var y5 = b * x0 + d * y1 + ty;
                xmin = Math.min(xmin, x2, x3, x4, x5);
                xmax = Math.max(xmax, x2, x3, x4, x5);
                ymin = Math.min(ymin, y2, y3, y4, y5);
                ymax = Math.max(ymax, y2, y3, y4, y5);
                var x2s = x2.toFixed(precision);
                var y2s = y2.toFixed(precision);
                var x3s = x3.toFixed(precision);
                var y3s = y3.toFixed(precision);
                var x4s = x4.toFixed(precision);
                var y4s = y4.toFixed(precision);
                var x5s = x5.toFixed(precision);
                var y5s = y5.toFixed(precision);
                result += " M".concat(x2s, ",").concat(y2s, " L").concat(x3s, ",").concat(y3s, " L").concat(x4s, ",").concat(y4s, " L").concat(x5s, ",").concat(y5s, "Z");
            }
            return "M".concat(xmin, ",").concat(ymin, " L").concat(xmax, ",").concat(ymin, " L").concat(xmax, ",").concat(ymax, " L").concat(xmin, ",").concat(ymax, "Z") + result;
        };
        UtilHtmlElementClipperExImpl.prototype.toRects = function (clipperExRects, result) {
            var data = clipperExRects.data;
            var size = clipperExRects.size;
            // Copy all rectangles
            var imax = size << 2;
            for (var i = 0; i < imax; i += 4) {
                var x0 = data[i + 0];
                var y0 = data[i + 1];
                var x1 = data[i + 2];
                var y1 = data[i + 3];
                if (x0 < x1) {
                    result[i + 0] = x0;
                    result[i + 2] = x1;
                }
                else {
                    result[i + 0] = x1;
                    result[i + 2] = x0;
                }
                if (y0 < y1) {
                    result[i + 1] = y0;
                    result[i + 3] = y1;
                }
                else {
                    result[i + 1] = y1;
                    result[i + 3] = y0;
                }
            }
            // Subdivide all rectangles if they have intersections
            for (var i = 4; i < imax; i += 4) {
                var x0 = result[i + 0];
                var y0 = result[i + 1];
                var x1 = result[i + 2];
                var y1 = result[i + 3];
                for (var j = 0; j < i; j += 4) {
                    var x2 = result[j + 0];
                    var y2 = result[j + 1];
                    var x3 = result[j + 2];
                    var y3 = result[j + 3];
                    // Check if there are intersections along the X axis.
                    // Here, ix represents which edges of the i-th rectangle are in the j-th rectangle as follows:
                    //
                    // * 0: No edge is in the j-th rectangle,
                    // * 1: The left edge is in the j-th rectangle,
                    // * 2: The right edge is in the j-th rectangle, and
                    // * 3: Both edges are in the j-th rectangle.
                    //
                    // The same spplies to the variable jx.
                    var ix = 0;
                    var jx = 0;
                    if (x0 <= x2) {
                        if (x1 <= x3) {
                            if (x1 <= x2) {
                                // x0--x1
                                //         x2--x3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                // x0----x1
                                //    x2----x3
                                ix = 2;
                                jx = 1;
                            }
                        }
                        else {
                            // x0--------x1
                            //    x2--x3
                            jx = 3;
                        }
                    }
                    else {
                        if (x1 <= x3) {
                            //    x0--x1
                            // x2--------x3
                            ix = 3;
                        }
                        else {
                            if (x3 <= x0) {
                                //         x0--x1
                                // x2--x3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                //    x0----x1
                                // x2----x3
                                ix = 1;
                                jx = 2;
                            }
                        }
                    }
                    // Check if there are intersections along the Y axis.
                    //
                    // * 0: No edge is in a rectangle,
                    // * 1: The bottom edge is in a rectangle,
                    // * 2: The top edge is in a rectangle, and
                    // * 3: Both edges are in a rectangle.
                    var iy = 0;
                    var jy = 0;
                    if (y0 <= y2) {
                        if (y1 <= y3) {
                            if (y1 <= y2) {
                                // y0--y1
                                //         y2--y3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                // y0----y1
                                //    y2----y3
                                iy = 2;
                                jy = 1;
                            }
                        }
                        else {
                            // y0--------y1
                            //    y2--y3
                            jy = 3;
                        }
                    }
                    else {
                        if (y1 <= y3) {
                            //    y0--y1
                            // y2--------y3
                            iy = 3;
                        }
                        else {
                            if (y3 <= y0) {
                                //         y0--y1
                                // y2--y3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                //    y0----y1
                                // y2----y3
                                iy = 1;
                                jy = 2;
                            }
                        }
                    }
                    // Count number of i-th rectangle vertices in j-th rectangle.
                    var ic = 0;
                    if (ix === 0 || iy === 0) {
                        ic = 0;
                    }
                    else if (ix === 1 || ix === 2) {
                        if (iy === 3) {
                            ic = 2;
                        }
                        else {
                            ic = 1;
                        }
                    }
                    else {
                        if (iy === 3) {
                            ic = 4;
                        }
                        else {
                            ic = 2;
                        }
                    }
                    // If all the vertices of the i-th rectangle are in j-th rectangle, remove the i-th rectangle.
                    if (ic === 4) {
                        if (i + 4 < imax) {
                            result[i + 0] = result[imax + 0];
                            result[i + 1] = result[imax + 1];
                            result[i + 2] = result[imax + 2];
                            result[i + 3] = result[imax + 3];
                        }
                        i -= 4;
                        imax -= 4;
                        break;
                    }
                    // Count number of j-th rectangle vertices in i-th rectangle.
                    var jc = 0;
                    if (jx === 0 || jy === 0) {
                        jc = 0;
                    }
                    else if (jx === 1 || jx === 2) {
                        if (jy === 3) {
                            jc = 2;
                        }
                        else {
                            jc = 1;
                        }
                    }
                    else {
                        if (jy === 3) {
                            jc = 4;
                        }
                        else {
                            jc = 2;
                        }
                    }
                    // If all the vertices of the j-th rectangle are in the i-th rectangle, remove the j-th rectangle.
                    if (jc === 4) {
                        for (var k = j + 4; k < imax; k += 4) {
                            result[k - 4] = result[k + 0];
                            result[k - 3] = result[k + 1];
                            result[k - 2] = result[k + 2];
                            result[k - 1] = result[k + 3];
                        }
                        i -= 4;
                        imax -= 4;
                        j -= 4;
                        continue;
                    }
                    // Other cases
                    if (ic === 0) {
                        if (jc === 0) {
                            for (var k = imax - 4; j < k; k -= 4) {
                                result[k + 4] = result[k + 0];
                                result[k + 5] = result[k + 1];
                                result[k + 6] = result[k + 2];
                                result[k + 7] = result[k + 3];
                            }
                            if (jx === 0) {
                                //      +-----+      y1
                                // +----|     |----+ y3
                                // | i  |  j  |    |
                                // +----|     |----+ y2
                                //      +-----+      y0
                                // x0   x2    x3   x1
                                result[j + 3] = y0;
                                result[j + 4] = x2;
                                result[j + 5] = y1;
                                result[j + 6] = x3;
                                result[j + 7] = y3;
                            }
                            else {
                                //      +-----+      y1
                                // +----|     |----+ y3
                                // | j  |  i  |    |
                                // +----|     |----+ y2
                                //      +-----+      y0
                                // x2   x0    x1   x3
                                result[j + 2] = x0;
                                result[j + 4] = x1;
                                result[j + 5] = y2;
                                result[j + 6] = x3;
                                result[j + 7] = y3;
                            }
                            i += 4;
                            imax += 4;
                            j += 4;
                        }
                        else if (jc === 2) {
                            if (jx === 1) {
                                // +---------+
                                // |         |-----+
                                // |    i    |  j  |
                                // |         |-----+
                                // +---------+
                                result[j + 0] = x1;
                            }
                            else if (jx === 2) {
                                //       +---------+
                                // +-----|         |
                                // |  j  |    i    |
                                // +-----|         |
                                //       +---------+
                                result[j + 2] = x0;
                            }
                            else if (jy === 1) {
                                //   +-----+
                                //   |  j  |
                                // +---------+
                                // |         |
                                // |    i    |
                                // |         |
                                // +---------+
                                result[j + 1] = y1;
                            }
                            else if (jy === 2) {
                                // +---------+
                                // |         |
                                // |    i    |
                                // |         |
                                // +---------+
                                //   |  j  |
                                //   +-----+
                                result[j + 3] = y0;
                            }
                        }
                    }
                    else if (ic === 1) {
                        for (var k = imax - 4; j < k; k -= 4) {
                            result[k + 4] = result[k + 0];
                            result[k + 5] = result[k + 1];
                            result[k + 6] = result[k + 2];
                            result[k + 7] = result[k + 3];
                        }
                        if (jx === 1) {
                            if (jy === 1) {
                                //         +---------+
                                //         |         |
                                //         |    j    |
                                // +---------+       |
                                // |         |-------+
                                // |    i    |
                                // |         |
                                // +---------+
                                result[j + 0] = x1;
                                result[j + 4] = x2;
                                result[j + 5] = y1;
                                result[j + 6] = x1;
                                result[j + 7] = y3;
                            }
                            else {
                                // +---------+
                                // |         |
                                // |    i    |
                                // |       +---------+
                                // +-------|         |
                                //         |    j    |
                                //         |         |
                                //         +---------+
                                result[j + 0] = x1;
                                result[j + 4] = x2;
                                result[j + 5] = y2;
                                result[j + 6] = x1;
                                result[j + 7] = y0;
                            }
                        }
                        else {
                            if (jy === 1) {
                                // +---------+
                                // |         |
                                // |    j    |
                                // |         |-------+
                                // +---------+       |
                                //         |    i    |
                                //         |         |
                                //         +---------+
                                result[j + 2] = x0;
                                result[j + 4] = x0;
                                result[j + 5] = y1;
                                result[j + 6] = x3;
                                result[j + 7] = y3;
                            }
                            else {
                                //         +---------+
                                //         |         |
                                //         |    i    |
                                // +---------+       |
                                // |         |-------+
                                // |    j    |
                                // |         |
                                // +---------+
                                result[j + 2] = x0;
                                result[j + 4] = x0;
                                result[j + 5] = y2;
                                result[j + 6] = x3;
                                result[j + 7] = y0;
                            }
                        }
                        i += 4;
                        imax += 4;
                        j += 4;
                    }
                    else if (ic === 2) {
                        if (ix === 1) {
                            // +---------+
                            // |         |-----+
                            // |    j    |  i  |
                            // |         |-----+
                            // +---------+
                            result[i + 0] = x3;
                            x0 = x3;
                        }
                        else if (ix === 2) {
                            //       +---------+
                            // +-----|         |
                            // |  i  |    j    |
                            // +-----|         |
                            //       +---------+
                            result[i + 2] = x2;
                            x1 = x2;
                        }
                        else if (iy === 1) {
                            //   +-----+
                            //   |  i  |
                            // +---------+
                            // |         |
                            // |    j    |
                            // |         |
                            // +---------+
                            result[i + 1] = y3;
                            y0 = y3;
                        }
                        else if (iy === 2) {
                            // +---------+
                            // |         |
                            // |    j    |
                            // |         |
                            // +---------+
                            //   |  i  |
                            //   +-----+
                            result[i + 3] = y2;
                            y1 = y2;
                        }
                    }
                }
            }
            return imax;
        };
        return UtilHtmlElementClipperExImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHtmlElementClipperExRectsImpl = /** @class */ (function () {
        function UtilHtmlElementClipperExRectsImpl() {
            this._data = [];
            this._size = 0;
            this._index = 0;
            this._isDirty = true;
        }
        Object.defineProperty(UtilHtmlElementClipperExRectsImpl.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilHtmlElementClipperExRectsImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        UtilHtmlElementClipperExRectsImpl.prototype.isDirty = function () {
            return this._isDirty;
        };
        UtilHtmlElementClipperExRectsImpl.prototype.toClean = function () {
            this._isDirty = false;
        };
        UtilHtmlElementClipperExRectsImpl.prototype.begin = function () {
            this._index = 0;
            return this;
        };
        UtilHtmlElementClipperExRectsImpl.prototype.end = function () {
            var index = this._index;
            this._size = index;
            var data = this._data;
            var newDataLength = index << 2;
            if (data.length !== newDataLength) {
                data.length = newDataLength;
                this._isDirty = true;
            }
            return this;
        };
        UtilHtmlElementClipperExRectsImpl.prototype.add = function (x0, y0, x1, y1) {
            var index = this._index << 2;
            this._index += 1;
            var data = this._data;
            if (index < data.length) {
                if (data[index + 0] !== x0 ||
                    data[index + 1] !== y0 ||
                    data[index + 2] !== x1 ||
                    data[index + 3] !== y1) {
                    data[index + 0] = x0;
                    data[index + 1] = y0;
                    data[index + 2] = x1;
                    data[index + 3] = y1;
                    this._isDirty = true;
                }
            }
            else {
                data.push(x0, y0, x1, y1);
                this._isDirty = true;
            }
            return this;
        };
        return UtilHtmlElementClipperExRectsImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DHtmlElement} option when to show a HTML element
     */
    var UtilHtmlElementWhen = {
        /**
         * Shows a HTML element when clicked.
         */
        CLICKED: 0,
        /**
         * Shows a HTML element when double clicked.
         */
        DOUBLE_CLICKED: 1,
        /**
         * Shows a HTML element when focused.
         * And also shows when clicked if focused.
         */
        FOCUSED: 2,
        /**
         * Always shows a HTML element.
         */
        ALWAYS: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHtmlElement = /** @class */ (function () {
        function UtilHtmlElement(target, operation, theme, options) {
            var _this = this;
            this._target = target;
            this._operation = operation;
            var data = this.toData(theme, options);
            this._data = data;
            this._isElementShown = false;
            this._onElementFocusBound = function (e) {
                _this.onElementFocus(e);
            };
            this._onBeforeFocusBound = function (e) {
                _this.onBeforeFocus(e);
            };
            this._onAfterFocusBound = function (e) {
                _this.onAfterFocus(e);
            };
            this._isStarted = false;
            this._wasStarted = false;
            this._doSelectBound = function () {
                _this.doSelect();
            };
            this._isStartRequested = this._data.when === UtilHtmlElementWhen.ALWAYS;
            this._onPostRenderBound = function () {
                _this.updateElement(_this._rendererBound);
            };
        }
        UtilHtmlElement.prototype.toData = function (theme, options) {
            var _a, _b;
            return {
                element: this.toElementData(theme, options === null || options === void 0 ? void 0 : options.element),
                clipper: this.toClipperData(theme, options === null || options === void 0 ? void 0 : options.clipper),
                before: this.toBeforeData(theme, options === null || options === void 0 ? void 0 : options.before),
                after: this.toAfterData(theme, options === null || options === void 0 ? void 0 : options.after),
                when: toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : theme.getWhen(), UtilHtmlElementWhen),
                select: (_b = options === null || options === void 0 ? void 0 : options.select) !== null && _b !== void 0 ? _b : theme.getSelect()
            };
        };
        UtilHtmlElement.prototype.toElementData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getElementCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newElementStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newElementStyler = function (theme) {
            return function (target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx) {
                return theme.setElementStyle(target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
            };
        };
        UtilHtmlElement.prototype.toClipperData = function (theme, options) {
            var _a, _b, _c;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getClipperCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newClipperStyler(theme),
                extended: (_c = options === null || options === void 0 ? void 0 : options.extended) !== null && _c !== void 0 ? _c : theme.isClipperExEnabled()
            };
        };
        UtilHtmlElement.prototype.newClipperStyler = function (theme) {
            return function (target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx) {
                return theme.setClipperStyle(target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
            };
        };
        UtilHtmlElement.prototype.toBeforeData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getBeforeCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newBeforeStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newBeforeStyler = function (theme) {
            return function (target) {
                theme.setBeforeStyle(target);
            };
        };
        UtilHtmlElement.prototype.toAfterData = function (theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getAfterCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newAfterStyler(theme)
            };
        };
        UtilHtmlElement.prototype.newAfterStyler = function (theme) {
            return function (target) {
                theme.setAfterStyle(target);
            };
        };
        Object.defineProperty(UtilHtmlElement.prototype, "element", {
            get: function () {
                var _a;
                return (_a = this._element) !== null && _a !== void 0 ? _a : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilHtmlElement.prototype, "when", {
            get: function () {
                return this._data.when;
            },
            enumerable: false,
            configurable: true
        });
        UtilHtmlElement.prototype.onDowning = function (e) {
            this._wasStarted = this._isStarted;
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                    this.start();
                    break;
                case UtilHtmlElementWhen.FOCUSED:
                    if (this._target.state.isFocused) {
                        this.start();
                    }
                    break;
            }
        };
        UtilHtmlElement.prototype.onDown = function (e) {
            if (!this._wasStarted && this._isStarted) {
                if ("data" in e) {
                    e.data.originalEvent.preventDefault();
                }
                else {
                    e.preventDefault();
                }
            }
        };
        UtilHtmlElement.prototype.onDblClick = function (e, interactionManager) {
            switch (this.when) {
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                    this.start();
                    break;
            }
        };
        UtilHtmlElement.prototype.onFocus = function () {
            var _a;
            switch (this.when) {
                case UtilHtmlElementWhen.FOCUSED:
                    this.start();
                    break;
                default:
                    (_a = this._element) === null || _a === void 0 ? void 0 : _a.focus();
                    break;
            }
        };
        UtilHtmlElement.prototype.onBlur = function () {
            var _a;
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                case UtilHtmlElementWhen.FOCUSED:
                    this.onEndByBlur();
                    this.cancel();
                    break;
                default:
                    (_a = this._element) === null || _a === void 0 ? void 0 : _a.blur();
                    break;
            }
        };
        UtilHtmlElement.prototype.isStartable = function () {
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                case UtilHtmlElementWhen.FOCUSED:
                    return this._target.state.isActionable;
                default:
                    return true;
            }
        };
        UtilHtmlElement.prototype.start = function () {
            if (!this._isStarted && this.isStartable()) {
                this._isStarted = true;
                if (this._target.worldVisible) {
                    this.doStart();
                }
                else {
                    this._isStartRequested = true;
                }
                DApplications.update(this._target);
            }
        };
        UtilHtmlElement.prototype.isShown = function () {
            return this._isElementShown;
        };
        UtilHtmlElement.prototype.onRender = function (renderer) {
            if (this._isStartRequested ||
                (!this._isElementShown && this.when === UtilHtmlElementWhen.ALWAYS)) {
                this._isStartRequested = false;
                this.doStart(renderer);
            }
            if (this._isStarted) {
                this._isStarted = false;
            }
        };
        UtilHtmlElement.prototype.getElementRect = function (resolution) {
            var point = this._point || new pixi_js.Point(0, 0);
            this._point = point;
            var result = this._elementRectResult || new pixi_js.Rectangle();
            this._elementRectResult = result;
            return this._operation.getElementRect(resolution, point, result);
        };
        UtilHtmlElement.prototype.getElementMatrix = function () {
            return this._operation.getElementMatrix();
        };
        UtilHtmlElement.prototype.getClipperRect = function (resolution) {
            var point = this._point || new pixi_js.Point(0, 0);
            this._point = point;
            var result = this._clipperRectResult || new pixi_js.Rectangle();
            this._clipperRectResult = result;
            return this._operation.getClipperRect(resolution, point, result);
        };
        UtilHtmlElement.prototype.fillClipperExRects = function (resolution, result) {
            var operation = this._operation;
            if (operation.getClipperExRects) {
                operation.getClipperExRects(result);
            }
            return result.isDirty();
        };
        UtilHtmlElement.prototype.doStart = function (renderer) {
            var _a, _b;
            if (!this._isElementShown) {
                this._isElementShown = true;
                var rendererBound = this._rendererBound;
                if (rendererBound != null) {
                    this._rendererBound = undefined;
                    rendererBound.off("postrender", this._onPostRenderBound);
                }
                var target = this._target;
                if (renderer == null) {
                    renderer = (_a = DApplications.getLayer(target)) === null || _a === void 0 ? void 0 : _a.renderer;
                }
                if (renderer) {
                    this._rendererBound = renderer;
                    renderer.on("postrender", this._onPostRenderBound);
                }
                this.onStart();
                var clipper = this.getClipper();
                if (clipper) {
                    var before = this.getBefore(clipper);
                    var element = this.getElement(clipper);
                    var after = this.getAfter(clipper);
                    var clipperEx = this.getClipperEx(clipper);
                    if (element) {
                        var resolution = (_b = renderer === null || renderer === void 0 ? void 0 : renderer.resolution) !== null && _b !== void 0 ? _b : DApplications.getResolution(target);
                        var elementRect = this.getElementRect(resolution);
                        var elementMatrix = this.getElementMatrix();
                        var clipperRect = this.toClipperRectAdjusted(elementRect, elementMatrix, this.getClipperRect(resolution));
                        var state = target.state;
                        var padding = this._operation.getPadding();
                        var options = this._data;
                        options.clipper.styler(clipper, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        options.element.styler(element, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        if (before) {
                            options.before.styler(before);
                        }
                        if (after) {
                            options.after.styler(after);
                        }
                        this.onElementAttached(element, before, after);
                        if (clipperEx) {
                            var clipperExRects = this.getClipperExRects();
                            if (clipperExRects) {
                                if (this.fillClipperExRects(resolution, clipperExRects)) {
                                    clipperEx.update(elementRect, elementMatrix, clipperExRects);
                                    clipperExRects.toClean();
                                }
                            }
                        }
                        // Show HTML elements
                        clipper.style.display = "";
                        if (state.isFocused) {
                            this.toElementFocused(element);
                        }
                        clipper.scrollTop = 0;
                        clipper.scrollLeft = 0;
                        // Select the element if required.
                        // Note that a selecting without the setTimeout causes a key stroke drop on Microsoft Edge.
                        if (this._data.select) {
                            setTimeout(this._doSelectBound, 0);
                        }
                    }
                }
            }
        };
        UtilHtmlElement.prototype.toElementFocused = function (element) {
            element.focus({
                preventScroll: true
            });
        };
        UtilHtmlElement.prototype.onStart = function () {
            this._operation.onStart();
        };
        UtilHtmlElement.prototype.doSelect = function () {
            var element = this._element;
            if (element) {
                if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                    // The following does not work on mobile devices.
                    // I think selecting texts on a tap is annoying.
                    // Therefore, I leave this untouched.
                    element.select();
                }
            }
        };
        UtilHtmlElement.prototype.cancel = function () {
            var _a;
            if (this._isElementShown) {
                this._isElementShown = false;
                var rendererBound = this._rendererBound;
                if (rendererBound != null) {
                    this._rendererBound = undefined;
                    rendererBound.off("postrender", this._onPostRenderBound);
                }
                this.onCancel();
                var target = this._target;
                var layer = DApplications.getLayer(target);
                if (layer) {
                    var view = layer.view;
                    switch (this.when) {
                        case UtilHtmlElementWhen.CLICKED:
                        case UtilHtmlElementWhen.DOUBLE_CLICKED:
                        case UtilHtmlElementWhen.FOCUSED:
                            if (document.activeElement === this._element) {
                                view.focus();
                            }
                            break;
                    }
                    var state = target.state;
                    var interactionManager = layer.renderer.plugins.interaction;
                    if (this._operation.containsPoint(interactionManager.mouse.global) &&
                        !state.isHovered) {
                        state.isHovered = true;
                        view.style.cursor = (_a = target.cursor) !== null && _a !== void 0 ? _a : "";
                    }
                    layer.update();
                }
                var element = this._element;
                if (element != null) {
                    this.onElementDetached(element, this._before, this._after);
                }
                var clipper = this._clipper;
                if (clipper != null) {
                    clipper.style.display = "none";
                }
            }
        };
        UtilHtmlElement.prototype.onCancel = function () {
            this._operation.onCancel();
        };
        UtilHtmlElement.prototype.onElementAttached = function (element, before, after) {
            before === null || before === void 0 ? void 0 : before.addEventListener("focus", this._onBeforeFocusBound);
            after === null || after === void 0 ? void 0 : after.addEventListener("focus", this._onAfterFocusBound);
            element.addEventListener("focus", this._onElementFocusBound, true);
        };
        UtilHtmlElement.prototype.onElementDetached = function (element, before, after) {
            before === null || before === void 0 ? void 0 : before.removeEventListener("focus", this._onBeforeFocusBound);
            after === null || after === void 0 ? void 0 : after.removeEventListener("focus", this._onAfterFocusBound);
            element.removeEventListener("focus", this._onElementFocusBound, true);
        };
        UtilHtmlElement.prototype.getClipper = function () {
            var result = this._clipper;
            if (result == null) {
                var layer = DApplications.getLayer(this._target);
                result = layer ? this._data.clipper.creator(layer.getElementContainer()) : null;
                this._clipper = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getClipperEx = function (clipper) {
            var result = this._clipperEx;
            if (result === undefined) {
                var clipperExRects = this.getClipperExRects();
                if (clipperExRects != null) {
                    result = new UtilHtmlElementClipperExImpl(clipper);
                }
                else {
                    result = null;
                }
                this._clipperEx = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getClipperExRects = function () {
            var result = this._clipperExRects;
            if (result === undefined) {
                if (this._data.clipper.extended) {
                    result = new UtilHtmlElementClipperExRectsImpl();
                }
                else {
                    result = null;
                }
                this._clipperExRects = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getElement = function (clipper) {
            var result = this._element;
            if (result == null) {
                result = this._data.element.creator(clipper);
                this._element = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getBefore = function (clipper) {
            var result = this._before;
            if (result == null) {
                result = this._data.before.creator(clipper);
                this._before = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.getAfter = function (clipper) {
            var result = this._after;
            if (result == null) {
                result = this._data.after.creator(clipper);
                this._after = result;
            }
            return result;
        };
        UtilHtmlElement.prototype.onBeforeFocus = function (e) {
            var target = this._target;
            var layer = DApplications.getLayer(target);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.find(target, false, false, false);
                layer.view.focus();
                focusController.focus(focusable);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        };
        UtilHtmlElement.prototype.onAfterFocus = function (e) {
            var target = this._target;
            var layer = DApplications.getLayer(target);
            if (layer) {
                var focusController = layer.getFocusController();
                var focusable = focusController.find(target, false, false, true);
                layer.view.focus();
                focusController.focus(focusable);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        };
        UtilHtmlElement.prototype.onElementFocus = function (e) {
            if (this.when === UtilHtmlElementWhen.ALWAYS) {
                var target = this._target;
                if (!target.state.isFocused) {
                    target.focus();
                }
            }
        };
        UtilHtmlElement.prototype.onEndByBlur = function () {
            this.onEnd();
        };
        UtilHtmlElement.prototype.onEnd = function () {
            this._operation.onEnd();
        };
        UtilHtmlElement.prototype.end = function () {
            this.onEnd();
            this.cancel();
        };
        UtilHtmlElement.prototype.select = function () {
            if (this._isElementShown && this._data.select) {
                this.doSelect();
            }
            return this;
        };
        UtilHtmlElement.prototype.toClipperRectAdjusted = function (elementRect, elementMatrix, clipperRect) {
            if (clipperRect && elementRect && elementMatrix == null) {
                var ex0 = elementRect.x;
                var ey0 = elementRect.y;
                var ex1 = ex0 + elementRect.width;
                var ey1 = ey0 + elementRect.height;
                var cx0 = clipperRect.x;
                var cy0 = clipperRect.y;
                var cx1 = cx0 + clipperRect.width;
                var cy1 = cy0 + clipperRect.height;
                var ncx0 = Math.min(Math.max(cx0, ex0), cx1);
                var ncx1 = Math.min(Math.max(cx0, ex1), cx1);
                var ncy0 = Math.min(Math.max(cy0, ey0), cy1);
                var ncy1 = Math.min(Math.max(cy0, ey1), cy1);
                clipperRect.x = ncx0;
                clipperRect.y = ncy0;
                clipperRect.width = ncx1 - ncx0;
                clipperRect.height = ncy1 - ncy0;
            }
            return clipperRect;
        };
        UtilHtmlElement.prototype.updateElement = function (renderer) {
            if (this._isElementShown) {
                var target = this._target;
                if (target.worldVisible) {
                    var element = this._element;
                    var clipper = this._clipper;
                    var clipperEx = this._clipperEx;
                    if (element && clipper) {
                        var resolution = renderer.resolution;
                        var elementRect = this.getElementRect(resolution);
                        var elementMatrix = this.getElementMatrix();
                        var clipperRect = this.toClipperRectAdjusted(elementRect, elementMatrix, this.getClipperRect(resolution));
                        var state = target.state;
                        var padding = this._operation.getPadding();
                        var options = this._data;
                        options.clipper.styler(clipper, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        options.element.styler(element, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        if (clipperEx) {
                            var clipperExRects = this.getClipperExRects();
                            if (clipperExRects) {
                                if (this.fillClipperExRects(resolution, clipperExRects)) {
                                    clipperEx.update(elementRect, elementMatrix, clipperExRects);
                                    clipperExRects.toClean();
                                }
                            }
                        }
                    }
                }
                else {
                    switch (this.when) {
                        case UtilHtmlElementWhen.ALWAYS:
                            var clipper = this._clipper;
                            if (clipper) {
                                clipper.style.display = "none";
                            }
                            break;
                        default:
                            this.cancel();
                            break;
                    }
                }
            }
        };
        UtilHtmlElement.getClipperRect = function (parent, target, resolution, point, result) {
            var isFirst = true;
            var x0 = 0;
            var y0 = 0;
            var x1 = 0;
            var y1 = 0;
            var current = parent;
            while (current instanceof DBase) {
                current.getClippingRect(target, result);
                point.set(result.x, result.y);
                current.toGlobal(point, point, false);
                var cx0 = ((point.x * resolution) | 0) / resolution;
                var cy0 = ((point.y * resolution) | 0) / resolution;
                point.set(result.x + result.width, result.y + result.height);
                current.toGlobal(point, point, true);
                var cx1 = point.x;
                var cy1 = point.y;
                var dx0 = Math.min(cx0, cx1);
                var dy0 = Math.min(cy0, cy1);
                var dx1 = Math.max(cx0, cx1);
                var dy1 = Math.max(cy0, cy1);
                if (isFirst) {
                    isFirst = false;
                    x0 = dx0;
                    y0 = dy0;
                    x1 = dx1;
                    y1 = dy1;
                }
                else {
                    x0 = Math.min(Math.max(x0, dx0), dx1);
                    y0 = Math.min(Math.max(y0, dy0), dy1);
                    x1 = Math.min(Math.max(x1, dx0), dx1);
                    y1 = Math.min(Math.max(y1, dy0), dy1);
                }
                current = current.parent;
            }
            if (isFirst) {
                return null;
            }
            result.x = x0;
            result.y = y0;
            result.width = x1 - x0;
            result.height = y1 - y0;
            return result;
        };
        return UtilHtmlElement;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRuntimeImpl = /** @class */ (function () {
        function EShapeRuntimeImpl(shape) {
            var transform = shape.transform;
            var position = transform.position;
            this.x = position.x;
            this.y = position.y;
            var size = shape.size;
            this.sizeX = size.x;
            this.sizeY = size.y;
            this.rotation = transform.rotation;
            this.actions = [];
            this.fill = shape.fill.toObject();
            this.stroke = shape.stroke.toObject();
            this.text = shape.text.toObject();
            this.cursor = shape.cursor;
            this.reset = EShapeRuntimeReset.NONE;
            this.written = EShapeRuntimeReset.NONE;
            this.effect = NaN;
            this.isStateChanged = false;
            this.interactive = false;
        }
        EShapeRuntimeImpl.prototype.initialize = function (shape) {
            shape.disallowUploadedUpdate();
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].initialize(shape, this);
            }
            shape.allowUploadedUpdate();
        };
        EShapeRuntimeImpl.prototype.isActionable = function () {
            return 0 < this.actions.length;
        };
        EShapeRuntimeImpl.prototype.onResize = function (shape) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onResize(shape, this);
            }
        };
        EShapeRuntimeImpl.prototype.onClick = function (shape, e) {
            // State
            var state = shape.state;
            if (state.isActionable) {
                state.isClicked = true;
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onClick(shape, this, e);
            }
        };
        EShapeRuntimeImpl.prototype.onDblClick = function (shape, e, interactionManager) {
            // State
            var state = shape.state;
            if (state.isActionable) {
                state.isDblClicked = true;
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onDblClick(shape, this, e, interactionManager);
            }
            // Done
            return false;
        };
        EShapeRuntimeImpl.prototype.onOver = function (shape, e) {
            var state = shape.state;
            if (!state.isHovered) {
                // State
                state.isHovered = true;
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onOver(shape, this, e);
                }
            }
        };
        EShapeRuntimeImpl.prototype.onOut = function (shape, e) {
            var state = shape.state;
            if (state.isHovered) {
                // State
                shape.state.isHovered = false;
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onOut(shape, this, e);
                }
            }
        };
        EShapeRuntimeImpl.prototype.onDown = function (shape, e) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onDowning(shape, this, e);
            }
            var state = shape.state;
            if (!state.isDown) {
                if (state.isPressed) {
                    // State
                    state.addAll(EShapeState.DOWN, DBaseState.PRESSED);
                    // Focus
                    var layer = DApplications.getLayer(shape);
                    if (layer) {
                        // Focus
                        var focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        var action = actions[i];
                        action.onDown(shape, this, e);
                        action.onPressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isDown = false;
                    // Focus
                    var layer = DApplications.getLayer(shape);
                    if (layer) {
                        var focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onDown(shape, this, e);
                    }
                }
            }
        };
        EShapeRuntimeImpl.prototype.onUp = function (shape, e) {
            var state = shape.state;
            if (!state.isUp) {
                if (state.isPressed) {
                    // State
                    state.set(EShapeState.UP, DBaseState.PRESSED);
                    // Actions
                    var actions = this.actions;
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        var action = actions[i];
                        action.onUp(shape, this, e);
                        action.onUnpressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isUp = true;
                    // Actions
                    var actions = this.actions;
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onUp(shape, this, e);
                    }
                }
            }
        };
        EShapeRuntimeImpl.prototype.onUpOutside = function (shape, e) {
            var state = shape.state;
            if (state.isPressed) {
                // State
                state.set(EShapeState.UP_OUTSIDE, DBaseState.PRESSED);
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    var action = actions[i];
                    action.onUpOutside(shape, this, e);
                    action.onUnpressed(shape, this, e);
                }
            }
            else {
                // State
                state.isUpOutside = true;
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onUpOutside(shape, this, e);
                }
            }
        };
        EShapeRuntimeImpl.prototype.onMove = function (shape, e) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onMove(shape, this, e);
            }
        };
        EShapeRuntimeImpl.prototype.onKeyDown = function (shape, e) {
            // State
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onDown(shape, e);
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onKeyDown(shape, this, e);
            }
            // Done
            return false;
        };
        EShapeRuntimeImpl.prototype.onKeyUp = function (shape, e) {
            // State
            if (UtilKeyboardEvent.isActivateKey(e)) {
                var state = shape.state;
                if (state.isPressed) {
                    var wasUp = state.isUp;
                    this.onUp(shape, e);
                    if (!wasUp && state.isUp) {
                        this.onClick(shape, e);
                    }
                }
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onKeyUp(shape, this, e);
            }
            // Done
            return false;
        };
        EShapeRuntimeImpl.prototype.onStateChange = function (shape, newState, oldState) {
            this.isStateChanged = true;
            DApplications.update(shape);
            if (newState.isFocused) {
                if (!oldState.isFocused) {
                    this.onFocus(shape);
                }
            }
            else if (oldState.isFocused) {
                this.onBlur(shape);
            }
        };
        EShapeRuntimeImpl.prototype.onFocus = function (shape) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onFocus(shape, this);
            }
        };
        EShapeRuntimeImpl.prototype.onBlur = function (shape) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onBlur(shape, this);
            }
        };
        EShapeRuntimeImpl.prototype.onRightClick = function (shape, e) {
            // State
            var state = shape.state;
            if (state.isActionable) {
                state.isRightClicked = true;
            }
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRightClick(shape, this, e);
            }
        };
        EShapeRuntimeImpl.prototype.onRightDown = function (shape, e) {
            // Actions
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRightDowning(shape, this, e);
            }
            var state = shape.state;
            if (!state.isRightDown) {
                if (state.isRightPressed) {
                    // State
                    state.addAll(EShapeState.RIGHT_DOWN, EShapeState.RIGHT_PRESSED);
                    // Focus
                    var layer = DApplications.getLayer(shape);
                    if (layer) {
                        // Focus
                        var focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        var action = actions[i];
                        action.onRightDown(shape, this, e);
                        action.onRightPressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isRightDown = false;
                    // Focus
                    var layer = DApplications.getLayer(shape);
                    if (layer) {
                        var focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onRightDown(shape, this, e);
                    }
                }
            }
        };
        EShapeRuntimeImpl.prototype.onRightUp = function (shape, e) {
            var state = shape.state;
            if (!state.isRightUp) {
                if (state.isRightPressed) {
                    // State
                    state.set(EShapeState.RIGHT_UP, EShapeState.RIGHT_PRESSED);
                    // Actions
                    var actions = this.actions;
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        var action = actions[i];
                        action.onRightUp(shape, this, e);
                        action.onRightUnpressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isRightUp = true;
                    // Actions
                    var actions = this.actions;
                    for (var i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onRightUp(shape, this, e);
                    }
                }
            }
        };
        EShapeRuntimeImpl.prototype.onRightUpOutside = function (shape, e) {
            var state = shape.state;
            if (state.isRightPressed) {
                // State
                state.set(EShapeState.RIGHT_UP_OUTSIDE, EShapeState.RIGHT_PRESSED);
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    var action = actions[i];
                    action.onRightUpOutside(shape, this, e);
                    action.onRightUnpressed(shape, this, e);
                }
            }
            else {
                // State
                state.isRightUpOutside = true;
                // Actions
                var actions = this.actions;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onRightUpOutside(shape, this, e);
                }
            }
        };
        EShapeRuntimeImpl.prototype.update = function (shape, time) {
            var data = shape.data;
            var isEffectTimeUp = this.effect <= time;
            if (data.isChanged || this.isStateChanged || isEffectTimeUp) {
                this.isStateChanged = false;
                data.isChanged = false;
                if (isEffectTimeUp) {
                    this.effect = NaN;
                }
                shape.disallowUploadedUpdate();
                this.onUpdate(shape, time);
                shape.allowUploadedUpdate();
                var wasStateChanged = this.isStateChanged;
                shape.state.removeAll(EShapeRuntimeImpl.TRANSIENT_STATES);
                this.isStateChanged = wasStateChanged;
            }
        };
        EShapeRuntimeImpl.prototype.onRender = function (shape, time, renderer) {
            var actions = this.actions;
            for (var i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRender(shape, this, time, renderer);
            }
            this.update(shape, time);
        };
        EShapeRuntimeImpl.prototype.onUpdate = function (shape, time) {
            var actions = this.actions;
            if (0 < actions.length) {
                this.written = EShapeRuntimeReset.NONE;
                for (var i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].execute(shape, this, time);
                }
                this.doReset(shape);
            }
        };
        EShapeRuntimeImpl.prototype.doReset = function (shape) {
            var target = ~this.written & this.reset;
            if (target !== EShapeRuntimeReset.NONE) {
                if (target & EShapeRuntimeReset.POSITION_X) {
                    shape.transform.position.x = this.x;
                }
                if (target & EShapeRuntimeReset.POSITION_Y) {
                    shape.transform.position.y = this.y;
                }
                if (target & EShapeRuntimeReset.VISIBILITY) {
                    shape.visible = true;
                }
                if (target & EShapeRuntimeReset.COLOR_FILL) {
                    var fill = this.fill;
                    shape.fill.set(undefined, fill.color, fill.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_STROKE) {
                    var stroke = this.stroke;
                    shape.stroke.set(undefined, stroke.color, stroke.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT) {
                    var text = this.text;
                    shape.text.set(undefined, text.color, text.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                    var outline = this.text.outline;
                    shape.text.outline.set(undefined, outline.color, outline.alpha);
                }
                if (target & EShapeRuntimeReset.HEIGHT) {
                    shape.size.y = this.sizeY;
                }
                if (target & EShapeRuntimeReset.WIDTH) {
                    shape.size.x = this.sizeX;
                }
                if (target & EShapeRuntimeReset.ROTATION) {
                    shape.transform.rotation = this.rotation;
                }
                if (target & EShapeRuntimeReset.TEXT) {
                    shape.text.value = this.text.value;
                }
                if (target & EShapeRuntimeReset.CURSOR) {
                    shape.cursor = this.cursor;
                }
            }
        };
        EShapeRuntimeImpl.TRANSIENT_STATES = [
            EShapeState.CLICKED,
            EShapeState.DBL_CLICKED,
            EShapeState.DOWN,
            EShapeState.UP,
            EShapeState.UP_OUTSIDE,
            EShapeState.RIGHT_CLICKED,
            EShapeState.RIGHT_DOWN,
            EShapeState.RIGHT_UP,
            EShapeState.RIGHT_UP_OUTSIDE,
            EShapeState.ACTIVATED,
            EShapeState.DEACTIVATED
        ];
        return EShapeRuntimeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangle = /** @class */ (function (_super) {
        __extends(EShapeRectangle, _super);
        function EShapeRectangle(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE; }
            return _super.call(this, type) || this;
        }
        EShapeRectangle.prototype.clone = function () {
            return new EShapeRectangle(this.type).copy(this);
        };
        EShapeRectangle.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestRectangle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeRectangle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectanglePivoted = /** @class */ (function (_super) {
        __extends(EShapeRectanglePivoted, _super);
        function EShapeRectanglePivoted(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE_PIVOTED; }
            return _super.call(this, type) || this;
        }
        EShapeRectanglePivoted.prototype.toHitTestData = function (x, y) {
            var result = _super.prototype.toHitTestData.call(this, x, y);
            result.x -= result.width;
            result.y -= result.height;
            return result;
        };
        return EShapeRectanglePivoted;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayer = /** @class */ (function (_super) {
        __extends(DDiagramLayer, _super);
        function DDiagramLayer(name) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.interactive = false;
            _this.reference = 0;
            var shape = _this.newShape();
            shape.parent = _this;
            _this._shape = shape;
            _this.interactives = [];
            return _this;
        }
        Object.defineProperty(DDiagramLayer.prototype, "width", {
            get: function () {
                return this._shape.size.x;
            },
            set: function (width) {
                this._shape.size.x = width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramLayer.prototype, "height", {
            get: function () {
                return this._shape.size.y;
            },
            set: function (height) {
                this._shape.size.y = height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramLayer.prototype, "background", {
            get: function () {
                return this._shape.fill;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramLayer.prototype, "state", {
            get: function () {
                return this._shape.state;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramLayer.prototype.newShape = function () {
            var result = new EShapeRectanglePivoted();
            result.fill.set(false, 0xffffff, 1);
            result.stroke.set(false);
            result.state.add(EShapeLayerState.INTERACTIVE);
            return result;
        };
        DDiagramLayer.prototype.initialize = function (actionables) {
            var interactives = this.interactives;
            var shape = this._shape;
            var isInteractive = shape.state.is(EShapeLayerState.INTERACTIVE);
            var isDraggable = shape.state.is(EShapeLayerState.DRAGGABLE);
            var isPinchable = shape.state.is(EShapeLayerState.PINCHABLE);
            if (isDraggable || isPinchable) {
                var runtime = new EShapeRuntimeImpl(shape);
                shape.runtime = runtime;
                var gestureType = (isDraggable
                    ? EShapeActionValueGestureOperationType.DRAG
                    : EShapeActionValueGestureOperationType.NONE) |
                    (isPinchable
                        ? EShapeActionValueGestureOperationType.PINCH
                        : EShapeActionValueGestureOperationType.NONE);
                runtime.actions.push(new EShapeActionValueGesture("", EShapeActionValueGestureType.LAYER, gestureType).toRuntime());
                actionables.push(shape);
                runtime.initialize(shape);
            }
            if (isInteractive || isDraggable || isPinchable) {
                shape.interactive = true;
                interactives.push(shape);
            }
            this.doInitialize(this.children, interactives);
        };
        DDiagramLayer.prototype.doInitialize = function (shapes, interactives) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                var runtime = shape.runtime;
                if (runtime) {
                    // Interactives
                    if (shape.interactive || runtime.interactive) {
                        interactives.push(shape);
                    }
                    else {
                        var cursor = shape.cursor;
                        if (cursor != null && 0 < cursor.length) {
                            interactives.push(shape);
                        }
                    }
                }
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    this.doInitialize(children, interactives);
                }
            }
        };
        DDiagramLayer.prototype.update = function (time) {
            this.doUpdate(this.children, time);
        };
        DDiagramLayer.prototype.doUpdate = function (shapes, time) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                shape.update(time);
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    this.doUpdate(children, time);
                }
            }
        };
        DDiagramLayer.prototype.hitTestInteractives = function (global) {
            var local = this._work;
            var interactives = this.interactives;
            for (var i = interactives.length - 1; 0 <= i; --i) {
                var interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local.x, local.y) != null) {
                        return interactive;
                    }
                }
            }
            return null;
        };
        DDiagramLayer.prototype.addUuid = function (manager) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
        };
        DDiagramLayer.prototype.updateUuid = function (manager) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
        };
        DDiagramLayer.prototype.destroy = function () {
            if (!this._destroyed) {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    children[i].destroy();
                }
                children.length = 0;
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramLayer.prototype.serialize = function (layer, manager, items) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var shape_1 = children[i];
                var item = shape_1.serialize(manager);
                item[16] = layer;
                items.push(item);
            }
            var shape = this._shape;
            var nameId = manager.addResource(this.name || "");
            var visible = (this.visible ? 1 : 0) | (shape.state.is(EShapeLayerState.INVISIBLE) ? 0 : 2);
            var position = this.position;
            var size = shape.size;
            var fill = shape.fill.serialize(manager);
            var isInteractive = shape.state.is(EShapeLayerState.INTERACTIVE) ? 1 : 0;
            var isDraggable = shape.state.is(EShapeLayerState.DRAGGABLE) ? 2 : 0;
            var isPinchable = shape.state.is(EShapeLayerState.PINCHABLE) ? 4 : 0;
            return [
                nameId,
                visible,
                position.x,
                position.y,
                size.x,
                size.y,
                fill,
                isInteractive | isDraggable | isPinchable
            ];
        };
        DDiagramLayer.deserialize = function (serialized, manager, width, height) {
            var _a, _b, _c;
            var result = new DDiagramLayer(this.deserializeName(serialized[0], manager));
            var shape = result._shape;
            var visibility = serialized[1];
            if (visibility != null) {
                var isEditorMode = manager.mode !== EShapeResourceManagerDeserializationMode.VIEWER;
                if (isEditorMode && !(visibility & 0x1)) {
                    result.visible = false;
                }
                if (!(visibility & 0x2)) {
                    shape.state.add(EShapeLayerState.INVISIBLE);
                    if (!isEditorMode) {
                        result.visible = false;
                    }
                }
            }
            var positionX = serialized[2];
            var positionY = serialized[3];
            result.position.set(positionX, positionY);
            var sizeX = (_a = serialized[4]) !== null && _a !== void 0 ? _a : width;
            var sizeY = (_b = serialized[5]) !== null && _b !== void 0 ? _b : height;
            shape.size.set(sizeX, sizeY);
            var fillId = serialized[6];
            if (fillId != null) {
                shape.fill.deserialize(fillId, manager);
            }
            var state = (_c = serialized[7]) !== null && _c !== void 0 ? _c : 1;
            shape.state.set(EShapeLayerState.INTERACTIVE, !!(state & 0x1));
            shape.state.set(EShapeLayerState.DRAGGABLE, !!(state & 0x2));
            shape.state.set(EShapeLayerState.PINCHABLE, !!(state & 0x4));
            return result;
        };
        DDiagramLayer.deserializeName = function (target, manager) {
            if (isString(target)) {
                return target;
            }
            else {
                var resources = manager.resources;
                if (0 <= target && target <= resources.length) {
                    return resources[target];
                }
                return "";
            }
        };
        return DDiagramLayer;
    }(EShapeContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var _isShapeClipperExLoaded = false;
    var loadShapeClipperEx = function () {
        _isShapeClipperExLoaded = true;
    };
    var isShapeClipperExLoaded = function () {
        return _isShapeClipperExLoaded;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscHtmlElementBase = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscHtmlElementBase, _super);
        function EShapeActionRuntimeMiscHtmlElementBase(value) {
            var _this = _super.call(this) || this;
            _this.condition = EShapeActionExpressions.ofString(value.condition);
            _this.utils = new Map();
            return _this;
        }
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getUtil = function (shape, runtime) {
            var utils = this.utils;
            var result = utils.get(shape);
            if (result == null) {
                result = this.newUtil(shape, runtime);
                utils.set(shape, result);
            }
            return result;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.newUtil = function (shape, runtime) {
            return new UtilHtmlElement(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DHtmlElement"), this.newUtilOptions(shape, runtime));
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.newOperation = function (shape, runtime) {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(shape, runtime, resolution, work, result);
                },
                getElementMatrix: function () {
                    return _this.getElementMatrix(shape, runtime);
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperToRect(shape, runtime, resolution, work, result);
                },
                getClipperExRects: function (result) {
                    _this.getClipperExRects(shape, result);
                },
                getPadding: function () {
                    return _this.getPadding(shape, runtime);
                },
                containsPoint: function (point) {
                    return _this.containsPoint(shape, runtime, point);
                },
                onStart: function () {
                    // DO NOTHING
                },
                onCancel: function () {
                    // DO NOTHING
                },
                onEnd: function () {
                    // DO NOTHING
                }
            };
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.newUtilOptions = function (shape, runtime) {
            return {
                element: {
                    creator: this.newElementCreator(shape, runtime)
                },
                when: this.toWhen(shape, runtime),
                clipper: {
                    extended: isShapeClipperExLoaded()
                }
            };
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.toWhen = function (shape, runtime) {
            var value = this.condition(shape, Date.now(), EShapeActionEnvironment);
            if (value != null && value in UtilHtmlElementWhen) {
                return UtilHtmlElementWhen[value];
            }
            return undefined;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.containsPoint = function (shape, runtime, point) {
            var _a;
            if (shape.visible) {
                var local = ((_a = EShapeActionRuntimeMiscHtmlElementBase.WORK) !== null && _a !== void 0 ? _a : (EShapeActionRuntimeMiscHtmlElementBase.WORK = new pixi_js.Point()));
                shape.toLocal(point, undefined, local);
                return shape.contains(local.x, local.y) != null;
            }
            return false;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getPadding = function (shape, runtime) {
            return null;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getElementRect = function (shape, runtime, resolution, point, result) {
            var pivot = shape.transform.pivot;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            result.x = -0.5 * sizeX + pivot.x;
            result.y = -0.5 * sizeY + pivot.y;
            result.width = sizeX;
            result.height = sizeY;
            return result;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getElementMatrix = function (shape, runtime) {
            shape.updateTransform();
            return shape.transform.worldTransform;
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getClipperToRect = function (shape, runtime, resolution, point, result) {
            var container = EShapeActions.toContainer(shape);
            return UtilHtmlElement.getClipperRect(container, shape, resolution, point, result);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.getClipperExRects = function (shape, result) {
            result.begin();
            var target = shape.root.parent;
            if (target instanceof DDiagramLayer) {
                var layerContainer = target.parent;
                if (layerContainer != null) {
                    var layers = layerContainer.children;
                    var index = layers.indexOf(target);
                    if (0 <= index) {
                        for (var i = index + 1, imax = layers.length; i < imax; ++i) {
                            var layer = layers[i];
                            if (layer.visible) {
                                var w = layer.width;
                                var h = layer.height;
                                var t = layer.transform.worldTransform;
                                var a = t.a;
                                var b = t.b;
                                var c = t.c;
                                var d = t.d;
                                var tx = t.tx;
                                var ty = t.ty;
                                result.add(tx, ty, a * w + c * h + tx, b * w + d * h + ty);
                            }
                        }
                    }
                }
            }
            result.end();
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onRender = function (shape, runtime, time, renderer) {
            this.getUtil(shape, runtime).onRender(renderer);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onFocus = function (shape, runtime) {
            this.getUtil(shape, runtime).onFocus();
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onBlur = function (shape, runtime) {
            this.getUtil(shape, runtime).onBlur();
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onDowning = function (shape, runtime, e) {
            this.getUtil(shape, runtime).onDowning(e);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onDown = function (shape, runtime, e) {
            this.getUtil(shape, runtime).onDown(e);
        };
        EShapeActionRuntimeMiscHtmlElementBase.prototype.onDblClick = function (shape, runtime, e, interactionManager) {
            this.getUtil(shape, runtime).onDblClick(e, interactionManager);
        };
        return EShapeActionRuntimeMiscHtmlElementBase;
    }(EShapeActionRuntimeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscHtmlElement = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscHtmlElement, _super);
        function EShapeActionRuntimeMiscHtmlElement(value) {
            var _this = _super.call(this, value) || this;
            _this.elementCreator = EShapeActionExpressions.ofElementOrNull(value.value);
            _this.noPointerEvent =
                value.subtype === EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS;
            return _this;
        }
        EShapeActionRuntimeMiscHtmlElement.prototype.newUtil = function (shape, runtime) {
            if (this.noPointerEvent) {
                shape.state.add(DHtmlElementState.NO_POINTER_EVENTS);
            }
            return _super.prototype.newUtil.call(this, shape, runtime);
        };
        EShapeActionRuntimeMiscHtmlElement.prototype.newElementCreator = function (shape, runtime) {
            var elementCreator = this.elementCreator;
            if (elementCreator) {
                return function (container) {
                    return elementCreator(shape, Date.now(), EShapeActionEnvironment, container);
                };
            }
            return undefined;
        };
        return EShapeActionRuntimeMiscHtmlElement;
    }(EShapeActionRuntimeMiscHtmlElementBase));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInput = /** @class */ (function (_super) {
        __extends(UtilInput, _super);
        function UtilInput(target, operation, theme, options) {
            var _this = this;
            var _a, _b, _c, _d, _e, _f;
            _this = _super.call(this, target, operation, theme, options) || this;
            _this._operation = operation;
            _this._onInputKeyDownBound = function (e) {
                _this.onInputKeyDown(e);
            };
            _this._onInputChangeBound = function () {
                _this.onInputChange();
            };
            _this._onInputInputBound = function (e) {
                _this.onInputInput(e);
            };
            _this._description = (_a = options === null || options === void 0 ? void 0 : options.description) !== null && _a !== void 0 ? _a : "";
            var editing = options === null || options === void 0 ? void 0 : options.editing;
            _this._editingFormatter =
                (_d = (_b = editing === null || editing === void 0 ? void 0 : editing.formatter) !== null && _b !== void 0 ? _b : (_c = options === null || options === void 0 ? void 0 : options.text) === null || _c === void 0 ? void 0 : _c.formatter) !== null && _d !== void 0 ? _d : theme.getEditingFormatter();
            _this._editingUnformatter = (_e = editing === null || editing === void 0 ? void 0 : editing.unformatter) !== null && _e !== void 0 ? _e : theme.getEditingUnformatter();
            _this._editingValidator = (_f = editing === null || editing === void 0 ? void 0 : editing.validator) !== null && _f !== void 0 ? _f : theme.getEditingValidator();
            return _this;
        }
        UtilInput.prototype.onEnd = function () {
            _super.prototype.onEnd.call(this);
            this.onInputChange();
        };
        UtilInput.prototype.onElementAttached = function (element, before, after) {
            element.value = this.fromValue(this._operation.getValue());
            element.addEventListener("change", this._onInputChangeBound);
            element.addEventListener("input", this._onInputInputBound);
            _super.prototype.onElementAttached.call(this, element, before, after);
        };
        UtilInput.prototype.onElementDetached = function (element, before, after) {
            _super.prototype.onElementDetached.call(this, element, before, after);
            element.removeEventListener("change", this._onInputChangeBound);
            element.removeEventListener("input", this._onInputInputBound);
        };
        UtilInput.prototype.onInputKeyDown = function (e) {
            if (UtilKeyboardEvent.isOkKey(e)) {
                this.end();
                this._operation.onEnter();
            }
            else if (UtilKeyboardEvent.isCancelKey(e)) {
                this.cancel();
            }
        };
        UtilInput.prototype.toElementFocused = function (element) {
            _super.prototype.toElementFocused.call(this, element);
            element.scrollTop = 0;
            element.scrollLeft = 0;
        };
        UtilInput.prototype.onInputChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element != null) {
                    var operation = this._operation;
                    var newValue = this.toValue(element.value);
                    var oldValue = operation.getValue();
                    if (oldValue !== newValue) {
                        operation.onValueChange(newValue, oldValue);
                    }
                }
            }
        };
        UtilInput.prototype.toValue = function (valueAsString) {
            return this._editingUnformatter(valueAsString, this);
        };
        UtilInput.prototype.fromValue = function (value) {
            if (value !== undefined) {
                return this._editingFormatter(value, this);
            }
            return "";
        };
        UtilInput.prototype.onInputInput = function (e) {
            var target = e.target;
            if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
                this._operation.onValueInput(this.toValue(target.value));
            }
        };
        UtilInput.prototype.validate = function () {
            var value = this._operation.getValue();
            if (value !== undefined) {
                var result = this._editingValidator(value, this);
                if (this._editingValidationResult !== result) {
                    this._editingValidationResult = result;
                    var state = this._target.state;
                    state.isInvalid = result != null;
                    if (state.isHovered) {
                        this._operation.applyTitle();
                    }
                }
                return result;
            }
            return null;
        };
        UtilInput.prototype.applyTitle = function () {
            var editingValidationResult = this._editingValidationResult;
            if (isString(editingValidationResult)) {
                var layer = DApplications.getLayer(this._target);
                if (layer) {
                    layer.view.title = editingValidationResult;
                }
                return true;
            }
            return false;
        };
        return UtilInput;
    }(UtilHtmlElement));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputInput = /** @class */ (function (_super) {
        __extends(UtilInputInput, _super);
        function UtilInputInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UtilInputInput.prototype.onElementAttached = function (element, before, after) {
            element.addEventListener("keydown", this._onInputKeyDownBound);
            _super.prototype.onElementAttached.call(this, element, before, after);
        };
        UtilInputInput.prototype.onElementDetached = function (element, before, after) {
            element.removeEventListener("keydown", this._onInputKeyDownBound);
            _super.prototype.onElementDetached.call(this, element, before, after);
        };
        return UtilInputInput;
    }(UtilInput));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputNumber = /** @class */ (function (_super) {
        __extends(UtilInputNumber, _super);
        function UtilInputNumber(target, operation, theme, options) {
            var _this = this;
            var _a, _b, _c;
            _this = _super.call(this, target, operation, theme, options) || this;
            _this._step = (_a = options === null || options === void 0 ? void 0 : options.step) !== null && _a !== void 0 ? _a : theme.getStep();
            _this._min = (_b = options === null || options === void 0 ? void 0 : options.min) !== null && _b !== void 0 ? _b : theme.getMin();
            _this._max = (_c = options === null || options === void 0 ? void 0 : options.max) !== null && _c !== void 0 ? _c : theme.getMax();
            return _this;
        }
        Object.defineProperty(UtilInputNumber.prototype, "step", {
            get: function () {
                return this._step;
            },
            set: function (step) {
                if (this._step !== step) {
                    this._step = step;
                    this.onStepChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilInputNumber.prototype, "min", {
            get: function () {
                return this._min;
            },
            set: function (min) {
                if (this._min !== min) {
                    this._min = min;
                    this.onMinChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilInputNumber.prototype, "max", {
            get: function () {
                return this._max;
            },
            set: function (max) {
                if (this._max !== max) {
                    this._max = max;
                    this.onMaxChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        UtilInputNumber.prototype.toValue = function (valueAsString) {
            var result = _super.prototype.toValue.call(this, valueAsString);
            if (result === result /* NaN Check */) {
                var min = this._min;
                if (min != null && result < min) {
                    return min;
                }
                var max = this._max;
                if (max != null && max < result) {
                    return max;
                }
                return result;
            }
            return 0;
        };
        UtilInputNumber.prototype.fromValue = function (value) {
            if (value !== undefined) {
                return this._editingFormatter(value, this);
            }
            return "0";
        };
        UtilInputNumber.prototype.onStepChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element) {
                    this.updateStep(element);
                }
            }
        };
        UtilInputNumber.prototype.onMinChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element) {
                    this.updateMin(element);
                }
            }
        };
        UtilInputNumber.prototype.onMaxChange = function () {
            if (this.isShown()) {
                var element = this.element;
                if (element) {
                    this.updateMax(element);
                }
            }
        };
        UtilInputNumber.prototype.updateStep = function (input) {
            var step = this.step;
            if (step != null) {
                input.step = "".concat(step);
            }
            else {
                input.step = "any";
            }
        };
        UtilInputNumber.prototype.updateMin = function (input) {
            var min = this.min;
            if (min != null) {
                input.min = "".concat(min);
            }
            else {
                input.removeAttribute("min");
            }
        };
        UtilInputNumber.prototype.updateMax = function (input) {
            var max = this.max;
            if (max != null) {
                input.max = "".concat(max);
            }
            else {
                input.removeAttribute("max");
            }
        };
        UtilInputNumber.prototype.onElementAttached = function (element, before, after) {
            element.type = "number";
            _super.prototype.onElementAttached.call(this, element, before, after);
            this.updateStep(element);
            this.updateMin(element);
            this.updateMax(element);
        };
        return UtilInputNumber;
    }(UtilInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOnInputAction = {
        EMIT_EVENT: 0,
        WRITE_BOTH: 1,
        WRITE_LOCAL: 2,
        WRITE_REMOTE: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOnInputActions = /** @class */ (function () {
        function EShapeActionValueOnInputActions() {
        }
        EShapeActionValueOnInputActions.execute = function (shape, action, target, value, time) {
            switch (action) {
                case EShapeActionValueOnInputAction.EMIT_EVENT:
                    shape.emit(target, shape, value);
                    EShapeActions.emit(shape, target, value, time);
                    break;
                case EShapeActionValueOnInputAction.WRITE_LOCAL:
                    EShapeActions.writeLocal(shape, target, value, time);
                    break;
                case EShapeActionValueOnInputAction.WRITE_REMOTE:
                    EShapeActions.writeRemote(shape, target, value);
                    break;
                case EShapeActionValueOnInputAction.WRITE_BOTH:
                    EShapeActions.writeLocal(shape, target, value, time);
                    EShapeActions.writeRemote(shape, target, value);
                    break;
            }
        };
        return EShapeActionValueOnInputActions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInput = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInput, _super);
        function EShapeActionRuntimeMiscInput(value) {
            var _this = _super.call(this, value) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.onInputAction = value.onInputAction;
            return _this;
        }
        EShapeActionRuntimeMiscInput.prototype.newOperation = function (shape, runtime) {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(shape, runtime, resolution, work, result);
                },
                getElementMatrix: function () {
                    return _this.getElementMatrix(shape, runtime);
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperToRect(shape, runtime, resolution, work, result);
                },
                getClipperExRects: function (result) {
                    _this.getClipperExRects(shape, result);
                },
                getPadding: function () {
                    return _this.getPadding(shape, runtime);
                },
                containsPoint: function (point) {
                    return _this.containsPoint(shape, runtime, point);
                },
                onStart: function () {
                    shape.text.enable = false;
                },
                onCancel: function () {
                    shape.text.enable = true;
                },
                onEnd: function () {
                    // DO NOTHING
                },
                getValue: function () {
                    return _this.getUtil(shape, runtime).toValue(shape.text.value);
                },
                onValueInput: function (newValue) {
                    // DO NOTHING
                },
                onValueChange: function (newValue, oldValue) {
                    _this.onValueChange(shape, runtime, newValue, oldValue);
                },
                onEnter: function () {
                    // DO NOTHING
                },
                applyTitle: function () {
                    // DO NOTHING
                }
            };
        };
        EShapeActionRuntimeMiscInput.prototype.newElementCreator = function (shape, runtime) {
            return undefined;
        };
        EShapeActionRuntimeMiscInput.prototype.getPadding = function (shape, runtime) {
            return shape.text.padding;
        };
        EShapeActionRuntimeMiscInput.prototype.onValueChange = function (shape, runtime, newValue, oldValue) {
            shape.text.value = this.getUtil(shape, runtime).fromValue(newValue);
            var now = Date.now();
            var target = this.target(shape, now, EShapeActionEnvironment);
            if (target != null) {
                EShapeActionValueOnInputActions.execute(shape, this.onInputAction, target, newValue, now);
            }
        };
        return EShapeActionRuntimeMiscInput;
    }(EShapeActionRuntimeMiscHtmlElementBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputInput = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputInput, _super);
        function EShapeActionRuntimeMiscInputInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EShapeActionRuntimeMiscInputInput;
    }(EShapeActionRuntimeMiscInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputNumber = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputNumber, _super);
        function EShapeActionRuntimeMiscInputNumber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EShapeActionRuntimeMiscInputNumber;
    }(EShapeActionRuntimeMiscInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputInteger = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputInteger, _super);
        function EShapeActionRuntimeMiscInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscInputInteger.prototype.newUtil = function (shape, runtime) {
            return new UtilInputNumber(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputInteger"), this.newUtilOptions(shape, runtime));
        };
        return EShapeActionRuntimeMiscInputInteger;
    }(EShapeActionRuntimeMiscInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputReal = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputReal, _super);
        function EShapeActionRuntimeMiscInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscInputReal.prototype.newUtil = function (shape, runtime) {
            return new UtilInputNumber(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputReal"), this.newUtilOptions(shape, runtime));
        };
        return EShapeActionRuntimeMiscInputReal;
    }(EShapeActionRuntimeMiscInputNumber));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputText = /** @class */ (function (_super) {
        __extends(UtilInputText, _super);
        function UtilInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UtilInputText.prototype.onElementAttached = function (element, before, after) {
            element.type = "text";
            _super.prototype.onElementAttached.call(this, element, before, after);
        };
        return UtilInputText;
    }(UtilInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscInputText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscInputText, _super);
        function EShapeActionRuntimeMiscInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscInputText.prototype.newUtil = function (shape, runtime) {
            return new UtilInputText(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputText"), this.newUtilOptions(shape, runtime));
        };
        return EShapeActionRuntimeMiscInputText;
    }(EShapeActionRuntimeMiscInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWrite = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWrite, _super);
        function EShapeActionRuntimeMiscWrite(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.value = EShapeActionExpressions.ofUnknown(value.value);
            return _this;
        }
        EShapeActionRuntimeMiscWrite.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var target = this.target(shape, time, EShapeActionEnvironment);
                if (target != null) {
                    this.write(shape, target, this.value(shape, time, EShapeActionEnvironment), time);
                }
            }
        };
        return EShapeActionRuntimeMiscWrite;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWriteBoth = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWriteBoth, _super);
        function EShapeActionRuntimeMiscWriteBoth() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscWriteBoth.prototype.write = function (shape, target, value, time) {
            EShapeActions.writeLocal(shape, target, value, time);
            EShapeActions.writeRemote(shape, target, value);
        };
        return EShapeActionRuntimeMiscWriteBoth;
    }(EShapeActionRuntimeMiscWrite));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWriteLocal = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWriteLocal, _super);
        function EShapeActionRuntimeMiscWriteLocal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscWriteLocal.prototype.write = function (shape, target, value, time) {
            EShapeActions.writeLocal(shape, target, value, time);
        };
        return EShapeActionRuntimeMiscWriteLocal;
    }(EShapeActionRuntimeMiscWrite));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscWriteRemote = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscWriteRemote, _super);
        function EShapeActionRuntimeMiscWriteRemote() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EShapeActionRuntimeMiscWriteRemote.prototype.write = function (shape, target, value, time) {
            EShapeActions.writeRemote(shape, target, value);
        };
        return EShapeActionRuntimeMiscWriteRemote;
    }(EShapeActionRuntimeMiscWrite));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMisc = /** @class */ (function (_super) {
        __extends(EShapeActionValueMisc, _super);
        function EShapeActionValueMisc(subtype, condition, target, onInputAction, value) {
            var _this = _super.call(this, EShapeActionValueType.MISC, condition, subtype) || this;
            _this.target = target;
            _this.onInputAction = onInputAction;
            _this.value = value;
            return _this;
        }
        EShapeActionValueMisc.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueMiscType.INPUT_TEXT:
                    return new EShapeActionRuntimeMiscInputText(this);
                case EShapeActionValueMiscType.INPUT_INTEGER:
                    return new EShapeActionRuntimeMiscInputInteger(this);
                case EShapeActionValueMiscType.INPUT_REAL:
                    return new EShapeActionRuntimeMiscInputReal(this);
                case EShapeActionValueMiscType.EMIT_EVENT:
                    return new EShapeActionRuntimeMiscEmitEvent(this);
                case EShapeActionValueMiscType.WRITE_BOTH:
                    return new EShapeActionRuntimeMiscWriteBoth(this);
                case EShapeActionValueMiscType.WRITE_LOCAL:
                    return new EShapeActionRuntimeMiscWriteLocal(this);
                case EShapeActionValueMiscType.WRITE_REMOTE:
                    return new EShapeActionRuntimeMiscWriteRemote(this);
                case EShapeActionValueMiscType.HTML_ELEMENT:
                case EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                    return new EShapeActionRuntimeMiscHtmlElement(this);
            }
        };
        EShapeActionValueMisc.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var valueId = manager.addResource(this.value);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",").concat(this.onInputAction, ",").concat(valueId, "]"));
        };
        EShapeActionValueMisc.deserialize = function (serialized, manager) {
            var resources = manager.resources;
            var condition = EShapeActionValues.toResource(1, serialized, resources);
            var target = EShapeActionValues.toResource(3, serialized, resources);
            var value = EShapeActionValues.toResource(5, serialized, resources);
            return new EShapeActionValueMisc(serialized[2], condition, target, serialized[4], value);
        };
        return EShapeActionValueMisc;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeMiscExecute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeMiscExecute, _super);
        function EShapeActionRuntimeMiscExecute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofUnknown(value.target);
            return _this;
        }
        EShapeActionRuntimeMiscExecute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                this.target(shape, time, EShapeActionEnvironment);
            }
        };
        return EShapeActionRuntimeMiscExecute;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscExecute = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscExecute, _super);
        function EShapeActionValueMiscExecute(condition, target) {
            var _this = _super.call(this, EShapeActionValueType.MISC, condition, EShapeActionValueMiscType.EXECUTE) || this;
            _this.target = target;
            return _this;
        }
        EShapeActionValueMiscExecute.prototype.toRuntime = function () {
            return new EShapeActionRuntimeMiscExecute(this);
        };
        EShapeActionValueMiscExecute.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, "]"));
        };
        EShapeActionValueMiscExecute.deserialize = function (serialized, manager) {
            var resources = manager.resources;
            var condition = EShapeActionValues.toResource(1, serialized, resources);
            var target = EShapeActionValues.toResource(3, serialized, resources);
            return new EShapeActionValueMiscExecute(condition, target);
        };
        return EShapeActionValueMiscExecute;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpen = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpen, _super);
        function EShapeActionRuntimeOpen(value, subtype) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.subtype = subtype;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.inNewWindow = value.inNewWindow;
            return _this;
        }
        EShapeActionRuntimeOpen.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var target = this.target(shape, time, EShapeActionEnvironment);
                if (target != null) {
                    EShapeActions.open(shape, this.subtype, target, this.inNewWindow);
                }
            }
        };
        return EShapeActionRuntimeOpen;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenType = {
        /** @deprecated in favor of {@link DIAGRAM} */
        DIAGRAM_LEGACY: 0,
        /** @deprecated in favor of {@link PAGE} */
        PAGE_LEGACY: 1,
        /** @deprecated in favor of {@link PAGE} */
        PAGE_INPLACE_LEGACY: 2,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_TEXT: 3,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_INTEGER: 4,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_REAL: 5,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_BOOLEAN: 6,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_DATE: 7,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_TIME: 8,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_DATETIME: 9,
        DIAGRAM: 10,
        PAGE: 11,
        DIALOG: 12,
        EXTENSION: DDiagramBaseControllerOpenType.EXTENSION
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpen = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpen, _super);
        function EShapeActionValueOpen(subtype, condition, target, inNewWindow) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, subtype) || this;
            _this.target = target;
            _this.inNewWindow = inNewWindow;
            return _this;
        }
        EShapeActionValueOpen.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpen &&
                this.target === value.target &&
                this.inNewWindow === value.inNewWindow);
        };
        EShapeActionValueOpen.prototype.toRuntime = function () {
            switch (this.subtype) {
                case EShapeActionValueOpenType.DIAGRAM:
                    return new EShapeActionRuntimeOpen(this, DDiagramBaseControllerOpenType.DIAGRAM);
                case EShapeActionValueOpenType.PAGE:
                    return new EShapeActionRuntimeOpen(this, DDiagramBaseControllerOpenType.PAGE);
            }
        };
        EShapeActionValueOpen.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var inNewWindow = this.inNewWindow ? 1 : 0;
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",").concat(inNewWindow, "]"));
        };
        EShapeActionValueOpen.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var target = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueOpen(this.toSubType(serialized), condition, target, this.inNewWindow(serialized));
        };
        EShapeActionValueOpen.toSubType = function (serialized) {
            if (serialized.length === 6) {
                switch (serialized[2]) {
                    case EShapeActionValueOpenType.DIAGRAM_LEGACY:
                        return EShapeActionValueOpenType.DIAGRAM;
                    case EShapeActionValueOpenType.PAGE_LEGACY:
                        return EShapeActionValueOpenType.PAGE;
                    case EShapeActionValueOpenType.PAGE_INPLACE_LEGACY:
                        return EShapeActionValueOpenType.PAGE;
                }
            }
            else {
                return serialized[2];
            }
        };
        EShapeActionValueOpen.inNewWindow = function (serialized) {
            if (serialized.length === 6) {
                switch (serialized[2]) {
                    case EShapeActionValueOpenType.DIAGRAM_LEGACY:
                        return false;
                    case EShapeActionValueOpenType.PAGE_LEGACY:
                        return true;
                    case EShapeActionValueOpenType.PAGE_INPLACE_LEGACY:
                        return false;
                }
            }
            else {
                return !!serialized[4];
            }
        };
        return EShapeActionValueOpen;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilAttachAlign = {
        TOP: 0,
        TOP_LEFT: 1,
        TOP_CENTER: 2,
        TOP_RIGHT: 3,
        LEFT: 4,
        LEFT_TOP: 5,
        LEFT_MIDDLE: 6,
        LEFT_BOTTOM: 7,
        RIGHT: 8,
        RIGHT_TOP: 9,
        RIGHT_MIDDLE: 10,
        RIGHT_BOTTOM: 11,
        BOTTOM: 12,
        BOTTOM_LEFT: 13,
        BOTTOM_CENTER: 14,
        BOTTOM_RIGHT: 15,
        OVER: 16
    };
    var UtilAttach = /** @class */ (function () {
        function UtilAttach() {
        }
        UtilAttach.attach = function (target, bounds, offsetX, offsetY, clippingWidth, clippingHeight, align) {
            var width = target.width;
            var height = target.height;
            var x = 0;
            switch (align) {
                case UtilAttachAlign.LEFT:
                case UtilAttachAlign.LEFT_TOP:
                case UtilAttachAlign.LEFT_MIDDLE:
                case UtilAttachAlign.LEFT_BOTTOM:
                    x = bounds.left - width - offsetX;
                    if (x < offsetX) {
                        x = bounds.right + offsetX;
                        if (clippingWidth - offsetX < x + width) {
                            x = offsetX;
                        }
                    }
                    break;
                case UtilAttachAlign.RIGHT:
                case UtilAttachAlign.RIGHT_TOP:
                case UtilAttachAlign.RIGHT_MIDDLE:
                case UtilAttachAlign.RIGHT_BOTTOM:
                    x = bounds.right + offsetX;
                    if (clippingWidth - offsetX < x + width) {
                        x = bounds.left - width - offsetX;
                        if (x < offsetX) {
                            x = clippingWidth - width - offsetX;
                        }
                    }
                    break;
                case UtilAttachAlign.TOP:
                case UtilAttachAlign.TOP_LEFT:
                case UtilAttachAlign.BOTTOM:
                case UtilAttachAlign.BOTTOM_LEFT:
                    x = this.adjust(bounds.left, width, offsetX, clippingWidth);
                    break;
                case UtilAttachAlign.TOP_RIGHT:
                case UtilAttachAlign.BOTTOM_RIGHT:
                    x = this.adjust(bounds.right - width, width, offsetX, clippingWidth);
                    break;
                case UtilAttachAlign.TOP_CENTER:
                case UtilAttachAlign.BOTTOM_CENTER:
                case UtilAttachAlign.OVER:
                    x = this.adjust((bounds.left + bounds.right - width) * 0.5, width, offsetX, clippingWidth);
                    break;
            }
            var y = 0;
            switch (align) {
                case UtilAttachAlign.LEFT:
                case UtilAttachAlign.LEFT_TOP:
                case UtilAttachAlign.RIGHT:
                case UtilAttachAlign.RIGHT_TOP:
                    y = this.adjust(bounds.top, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.LEFT_MIDDLE:
                case UtilAttachAlign.RIGHT_MIDDLE:
                case UtilAttachAlign.OVER:
                    y = this.adjust((bounds.top + bounds.bottom - height) * 0.5, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.LEFT_BOTTOM:
                case UtilAttachAlign.RIGHT_BOTTOM:
                    y = this.adjust(bounds.bottom, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.TOP:
                case UtilAttachAlign.TOP_LEFT:
                case UtilAttachAlign.TOP_RIGHT:
                case UtilAttachAlign.TOP_CENTER:
                    y = bounds.top - height - offsetY;
                    if (y < offsetY) {
                        y = bounds.bottom + offsetY;
                        if (clippingHeight < y + height) {
                            y = offsetY;
                        }
                    }
                    break;
                case UtilAttachAlign.BOTTOM:
                case UtilAttachAlign.BOTTOM_LEFT:
                case UtilAttachAlign.BOTTOM_RIGHT:
                case UtilAttachAlign.BOTTOM_CENTER:
                    y = bounds.bottom + offsetY;
                    if (clippingHeight - offsetY < y + height) {
                        y = bounds.top - height - offsetY;
                        if (y < offsetY) {
                            y = clippingHeight - height - offsetY;
                        }
                    }
                    break;
            }
            target.position.set(x, y);
        };
        UtilAttach.adjust = function (position, size, offset, clippingSize) {
            if (position < offset) {
                if (clippingSize - offset < position + size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return offset;
                }
            }
            else if (clippingSize - offset < position + size) {
                if (clippingSize < size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return clippingSize - size - offset;
                }
            }
            return position;
        };
        return UtilAttach;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogCloseOn = {
        NONE: 0,
        ESC: 1,
        CLICK_OUTSIDE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogGestureMode = {
        DIRTY: 0,
        CLEAN: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogGestureImpl = /** @class */ (function () {
        function DDialogGestureImpl(parent, options) {
            var _a;
            this._parent = parent;
            this._options = options;
            if (options.enable) {
                this._util = this.newUtil();
            }
            this._mode = toEnum((_a = options.mode) !== null && _a !== void 0 ? _a : DDialogGestureMode.DIRTY, DDialogGestureMode);
            this._isEnabled = true;
            this._isDirty = false;
        }
        Object.defineProperty(DDialogGestureImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogGestureImpl.prototype, "mode", {
            get: function () {
                return this._mode;
            },
            set: function (mode) {
                this._mode = mode;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogGestureImpl.prototype, "constraint", {
            get: function () {
                var _a, _b;
                var result = this._constraint;
                if (result == null) {
                    result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.constraint) !== null && _b !== void 0 ? _b : this.newConstraint();
                    this._constraint = result;
                }
                return result;
            },
            set: function (constraint) {
                this._constraint = constraint;
            },
            enumerable: false,
            configurable: true
        });
        DDialogGestureImpl.prototype.newConstraint = function () {
            var _this = this;
            return function (target, layer, x, y) {
                _this.toConstrained(target, layer, x, y);
            };
        };
        DDialogGestureImpl.prototype.isDirty = function () {
            return this._isDirty;
        };
        DDialogGestureImpl.prototype.isClean = function () {
            return !this._isDirty;
        };
        DDialogGestureImpl.prototype.toClean = function () {
            if (this._isDirty) {
                this._isDirty = false;
            }
        };
        DDialogGestureImpl.prototype.newUtil = function () {
            var _this = this;
            var p = new pixi_js.Point();
            var parent = this._parent;
            var position = parent.position;
            return new UtilGesture({
                bind: parent,
                checker: {
                    start: function (e) {
                        // Are children clicked?
                        if (e.target !== parent) {
                            return false;
                        }
                        // Is clicked outside?
                        p.copyFrom(e.data.global);
                        parent.toLocal(p, undefined, p, true);
                        var x = p.x;
                        var y = p.y;
                        if (x < 0 || y < 0 || parent.width < x || parent.height < y) {
                            return false;
                        }
                        // Ok
                        return true;
                    }
                },
                on: {
                    start: function () {
                        p.copyFrom(position);
                    },
                    move: function (target, dx, dy) {
                        p.set(p.x + dx, p.y + dy);
                        if (!_this._isDirty) {
                            _this._isDirty = true;
                            parent.setX(position.x);
                            parent.setY(position.y);
                        }
                        var layer = parent.layer;
                        if (layer != null) {
                            _this.constraint(parent, layer, p.x, p.y);
                        }
                    }
                }
            });
        };
        DDialogGestureImpl.prototype.toConstrained = function (target, layer, x, y) {
            var _a;
            var position = target.position;
            if (layer) {
                var bounds = target.getBounds(false, ((_a = DDialogGestureImpl.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DDialogGestureImpl.WORK_BOUNDS = new pixi_js.Rectangle())));
                var obx = bounds.x + x - position.x;
                var oby = bounds.y + y - position.y;
                var nbx = Math.min(Math.max(0, obx), layer.width - bounds.width);
                var nby = Math.min(Math.max(0, oby), layer.height - bounds.height);
                position.set(x + nbx - obx, y + nby - oby);
            }
            else {
                position.set(x, y);
            }
        };
        return DDialogGestureImpl;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DDialog} mode options.
     */
    var DDialogMode = {
        MODAL: 0,
        MODELESS: 1,
        MENU: 2
    };

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogState = {
        MODAL: "MODAL",
        MODELESS: "MODELESS",
        MENU: "MENU"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilClickOutside = /** @class */ (function () {
        function UtilClickOutside() {
        }
        UtilClickOutside.apply = function (target, onClick) {
            var _this = this;
            target.on(UtilPointerEvent.down, function (e) {
                if (e.target === target) {
                    var point = _this.point;
                    point.copyFrom(e.data.global);
                    target.toLocal(point, undefined, point, true);
                    var x = point.x;
                    var y = point.y;
                    if (x < 0 || y < 0 || target.width < x || target.height < y) {
                        // If dialogs / menus are being rendered on the overlay layer, closing them before
                        // the default pointerdown event handler causes the base layer to lose its focus.
                        // Therefore, onClick needed to be delayed.
                        setTimeout(function () {
                            onClick(e);
                        }, 0);
                    }
                }
            });
        };
        UtilClickOutside.point = new pixi_js.Point();
        return UtilClickOutside;
    }());

    var UtilOverlay = /** @class */ (function () {
        function UtilOverlay(options) {
            this._layer = null;
            this._application = (options === null || options === void 0 ? void 0 : options.parent) == null ? DApplications.last() : null;
        }
        Object.defineProperty(UtilOverlay.prototype, "picked", {
            get: function () {
                return this._layer;
            },
            enumerable: false,
            configurable: true
        });
        UtilOverlay.prototype.pick = function (target) {
            var layer = this._layer;
            if (layer == null) {
                layer = DApplications.getLayerOverlay(target);
                if (!layer) {
                    var application = this._application;
                    if (application) {
                        layer = application.getLayerOverlay();
                    }
                    else {
                        layer = DApplications.last().getLayerOverlay();
                    }
                }
                this._layer = layer;
            }
            return layer;
        };
        return UtilOverlay;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog class.
     *
     * If multiple application instances are there, better to set the constructor
     * option `parent` to an `application.stage` so that the dialog picks a right
     * application. By default, the dialog assumes the last created application is
     * the one it belongs to at the time when it is created.
     */
    var DDialog = /** @class */ (function (_super) {
        __extends(DDialog, _super);
        function DDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialog.prototype.init = function (options) {
            var _this = this;
            var _a, _b;
            _super.prototype.init.call(this, options);
            this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            this._layer = null;
            // Mode
            var theme = this.theme;
            var mode = toEnum((_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : theme.getMode(), DDialogMode);
            this._mode = mode;
            // Sticky
            this._sticky = (_b = options === null || options === void 0 ? void 0 : options.sticky) !== null && _b !== void 0 ? _b : theme.isSticky(mode);
            // Close On
            var closeOn = this.toCloseOn(mode, theme, options);
            this._closeOn = closeOn;
            // Align
            this._align = this.toAlign(mode, theme, options);
            // Overlay
            this._overlay = new UtilOverlay();
            // Gesture
            this._gesture = new DDialogGestureImpl(this, this.toGestureOptions(mode, theme, options));
            // Visibility
            this.visible = false;
            // State
            switch (mode) {
                case DDialogMode.MODAL:
                    this.state.addAll(DBaseState.FOCUS_ROOT, DDialogState.MODAL);
                    break;
                case DDialogMode.MODELESS:
                    this.state.add(DDialogState.MODELESS);
                    break;
                case DDialogMode.MENU:
                    this.state.addAll(DBaseState.FOCUS_ROOT, DDialogState.MENU);
                    break;
            }
            // Outside-click handling
            if (closeOn & DDialogCloseOn.CLICK_OUTSIDE) {
                UtilClickOutside.apply(this, function () {
                    _this.onCloseOn();
                });
            }
        };
        DDialog.prototype.toCloseOn = function (mode, theme, options) {
            var closeOn = options === null || options === void 0 ? void 0 : options.closeOn;
            if (closeOn == null) {
                return theme.closeOn(mode);
            }
            else if (isArray(closeOn)) {
                var result = DDialogCloseOn.NONE;
                for (var i = 0, imax = closeOn.length; i < imax; ++i) {
                    result |= DDialogCloseOn[closeOn[i]];
                }
                return result;
            }
            else if (isString(closeOn)) {
                return DDialogCloseOn[closeOn];
            }
            return closeOn;
        };
        DDialog.prototype.toAlign = function (mode, theme, options) {
            var align = options === null || options === void 0 ? void 0 : options.align;
            if (align === null) {
                return null;
            }
            else if (align === undefined) {
                return theme.getAlign(mode);
            }
            else {
                return toEnum(align, UtilAttachAlign);
            }
        };
        Object.defineProperty(DDialog.prototype, "mode", {
            get: function () {
                return this._mode;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialog.prototype, "align", {
            get: function () {
                return this._align;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialog.prototype, "algin", {
            set: function (align) {
                this._align = align;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialog.prototype, "gesture", {
            get: function () {
                return this._gesture;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialog.prototype, "layer", {
            get: function () {
                return this._layer;
            },
            enumerable: false,
            configurable: true
        });
        DDialog.prototype.toGestureOptions = function (mode, theme, options) {
            var gesture = options === null || options === void 0 ? void 0 : options.gesture;
            if (gesture === true) {
                return {
                    enable: true,
                    mode: theme.getGestureMode(mode)
                };
            }
            else if (gesture === false) {
                return {
                    enable: false,
                    mode: theme.getGestureMode(mode)
                };
            }
            else if (gesture != null) {
                if (gesture.enable === undefined) {
                    gesture.enable = theme.isGestureEnabled(mode);
                }
                if (gesture.mode === undefined) {
                    gesture.mode = theme.getGestureMode(mode);
                }
                return gesture;
            }
            return {
                enable: theme.isGestureEnabled(mode),
                mode: theme.getGestureMode(mode)
            };
        };
        DDialog.prototype.onParentResize = function (parentWidth, parentHeight, parentPadding) {
            if (this.isOpened()) {
                var layer = this._layer;
                if (layer != null) {
                    var gesture = this._gesture;
                    if (gesture.isDirty()) {
                        var position = this.position;
                        gesture.constraint(this, layer, position.x, position.y);
                    }
                }
            }
            _super.prototype.onParentResize.call(this, parentWidth, parentHeight, parentPadding);
        };
        DDialog.prototype.getAnimation = function () {
            var _this = this;
            var _a, _b;
            var result = this._animation;
            if (result === undefined) {
                result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.animation) !== null && _b !== void 0 ? _b : this.theme.newAnimation(this._mode);
                if (result) {
                    result.target = this;
                    result.on("end", function (isReverse) {
                        _this.onAnimationEnd(isReverse);
                    });
                }
                this._animation = result;
            }
            return result;
        };
        DDialog.prototype.onAnimationEnd = function (isReverse) {
            if (isReverse) {
                if (this._mode === DDialogMode.MODELESS) {
                    this.hide();
                }
                else {
                    var parent_1 = this.parent;
                    if (parent_1) {
                        parent_1.removeChild(this);
                    }
                }
            }
            else {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    var focusController = layer.getFocusController();
                    this._focused = focusController.get();
                    focusController.focus(this.findFirstFocusable(focusController) || this);
                }
            }
        };
        DDialog.prototype.findFirstFocusable = function (focusController) {
            return focusController.find(this, false, true, true);
        };
        /**
         * Opens a dialog.
         *
         * @param opener An opener of a dialog.
         * The dialog position is determined based on a position and a size of the opener.
         * If the opener is undefined, the dialog is placed at the center of the screen.
         *
         * @returns a value of this dialog
         */
        DDialog.prototype.open = function (opener) {
            var _this = this;
            var result = this._promise;
            if (result == null) {
                result = new Promise(function (resolve, reject) {
                    _this._resolve = resolve;
                    _this._reject = reject;
                });
                this._promise = result;
                this._opener = opener;
                // Attach to a layer
                var layer = null;
                switch (this._mode) {
                    case DDialogMode.MODAL:
                    case DDialogMode.MENU:
                        layer = this._overlay.pick(this);
                        layer.stage.addChild(this);
                        break;
                    case DDialogMode.MODELESS:
                        layer = DApplications.getLayer(this);
                        this.show();
                        break;
                }
                this._layer = layer;
                // Position & size
                var gesture = this._gesture;
                if (gesture.mode === DDialogGestureMode.CLEAN) {
                    gesture.toClean();
                }
                if (layer != null) {
                    if (gesture.isClean()) {
                        var renderer = layer.renderer;
                        var onPrerenderBound = this._onPrerenderBound;
                        if (this._sticky) {
                            renderer.on("prerender", onPrerenderBound);
                        }
                        else {
                            renderer.once("prerender", onPrerenderBound);
                        }
                    }
                    else {
                        var position = this.position;
                        gesture.constraint(this, layer, position.x, position.y);
                    }
                }
                // Done
                this.onOpen();
            }
            return result;
        };
        DDialog.prototype.onPrerender = function () {
            var _a;
            var layer = this._layer;
            if (layer == null) {
                return;
            }
            var align = this._align;
            var opener = this._opener;
            if (align != null && opener != null) {
                var mode = this._mode;
                var bounds = opener.getBounds(false, ((_a = DDialog.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DDialog.WORK_BOUNDS = new pixi_js.Rectangle())));
                var theme = this.theme;
                UtilAttach.attach(this, bounds, theme.getOffsetX(mode), theme.getOffsetY(mode), layer.width, layer.height, align);
            }
            else {
                this.position.set((layer.width - this.width) * 0.5, (layer.height - this.height) * 0.5);
            }
        };
        DDialog.prototype.onOpen = function () {
            this.emit("open", this);
            // Animation
            var animation = this.getAnimation();
            if (animation) {
                animation.start();
            }
            else if (this._mode === DDialogMode.MENU) {
                this.visible = true;
                this.onAnimationEnd(false);
            }
        };
        DDialog.prototype.isOpened = function () {
            return this._promise != null;
        };
        DDialog.prototype.close = function () {
            this.doReject();
        };
        DDialog.prototype.doResolve = function (value) {
            var resolve = this._resolve;
            if (resolve) {
                this._promise = undefined;
                this._resolve = undefined;
                this._reject = undefined;
                this.onClose();
                resolve(value);
            }
        };
        DDialog.prototype.doReject = function (reason) {
            var reject = this._reject;
            if (reject) {
                this._promise = undefined;
                this._resolve = undefined;
                this._reject = undefined;
                this.onClose();
                reject(reason);
            }
        };
        DDialog.prototype.onClose = function () {
            // Focus
            var layer = this._layer;
            var focused = this._focused;
            if (focused != null) {
                this._focused = null;
                if (layer) {
                    var focusedLayer = DApplications.getLayer(focused);
                    if (focusedLayer != null && layer !== focusedLayer) {
                        focusedLayer.view.focus();
                    }
                    layer.getFocusController().focus(focused);
                }
                else {
                    this.blur(true);
                }
            }
            else {
                this.blur(true);
            }
            // Remove the prerender event handler and forget the layer
            if (layer) {
                layer.renderer.off("prerender", this._onPrerenderBound);
                this._layer = null;
            }
            // Forget the opener
            this._opener = null;
            // Animation
            var animation = this.getAnimation();
            if (animation) {
                animation.start(true);
            }
            else {
                this.visible = false;
                this.onAnimationEnd(true);
            }
            this.emit("close", this);
        };
        DDialog.prototype.onKeyDown = function (e) {
            if (this._closeOn & DDialogCloseOn.ESC) {
                if (UtilKeyboardEvent.isCancelKey(e)) {
                    this.onCloseOn();
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDialog.prototype.onCloseOn = function () {
            this.close();
        };
        DDialog.prototype.containsGlobalPoint = function (point) {
            switch (this._mode) {
                case DDialogMode.MODAL:
                case DDialogMode.MENU:
                    return true;
                case DDialogMode.MODELESS:
                    return _super.prototype.containsGlobalPoint.call(this, point);
            }
        };
        DDialog.prototype.getType = function () {
            return "DDialog";
        };
        return DDialog;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutDirection = {
        VERTICAL: 0,
        HORIZONTAL: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutSpace = /** @class */ (function (_super) {
        __extends(DLayoutSpace, _super);
        function DLayoutSpace(options) {
            var _this = _super.call(this, options) || this;
            _this.visible = false;
            return _this;
        }
        DLayoutSpace.prototype.getType = function () {
            return "DLayoutSpace";
        };
        return DLayoutSpace;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isVisible = function (child) {
        return child instanceof DBase && (child.visible || child instanceof DLayoutSpace);
    };
    var toMultiplicity = function (theme, options) {
        if (options) {
            var row = options.row;
            if (row != null) {
                return row;
            }
            var column = options.column;
            if (column != null) {
                return column;
            }
        }
        return theme.getMultiplicity();
    };
    var toMargin = function (theme, options) {
        var _a, _b;
        var margin = options === null || options === void 0 ? void 0 : options.margin;
        if (margin != null) {
            if (isNumber(margin)) {
                return {
                    horizontal: margin,
                    vertical: margin
                };
            }
            else {
                var themeMargin = theme.getMargin();
                return {
                    horizontal: (_a = margin.horizontal) !== null && _a !== void 0 ? _a : themeMargin,
                    vertical: (_b = margin.vertical) !== null && _b !== void 0 ? _b : themeMargin
                };
            }
        }
        else {
            var themeMargin = theme.getMargin();
            return {
                horizontal: themeMargin,
                vertical: themeMargin
            };
        }
    };
    var toDirection = function (theme, options) {
        var direction = options === null || options === void 0 ? void 0 : options.direction;
        if (direction != null) {
            if (isString(direction)) {
                return DLayoutDirection[direction];
            }
            else {
                return direction;
            }
        }
        return theme.getDirection();
    };
    var toCornerAdjust = function (theme, options) {
        var corner = options === null || options === void 0 ? void 0 : options.corner;
        if (corner != null && !isNumber(corner)) {
            var adjust = corner.adjust;
            if (adjust != null) {
                return adjust;
            }
        }
        return theme.getCornerAdjust();
    };
    var toReverse = function (theme, options) {
        var _a;
        return (_a = options === null || options === void 0 ? void 0 : options.reverse) !== null && _a !== void 0 ? _a : theme.getReverse();
    };
    var DLayout = /** @class */ (function (_super) {
        __extends(DLayout, _super);
        function DLayout() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayout.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._margin = toMargin(theme, options);
            this._direction = toDirection(theme, options);
            this._cornerAdjust = toCornerAdjust(theme, options);
            this._multiplicity = toMultiplicity(theme, options);
            this._reverse = toReverse(theme, options);
        };
        Object.defineProperty(DLayout.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLayout.prototype, "multiplicity", {
            get: function () {
                return this._multiplicity;
            },
            enumerable: false,
            configurable: true
        });
        DLayout.prototype.getWeightTotal = function () {
            var children = this.children;
            var result = 0;
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            for (var i = 0, imax = children.length; i < imax;) {
                var weight = -1;
                var j = 0;
                for (; j < multiplicity && i + j < imax; ++j) {
                    var child = children[reverse ? imax - 1 - (i + j) : i + j];
                    if (isVisible(child)) {
                        var clearType = child.getClearType();
                        if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                            break;
                        }
                        else {
                            weight = Math.max(weight, child.weight);
                            if (clearType && DLayoutClearType.AFTER) {
                                j += 1;
                                break;
                            }
                        }
                    }
                    else {
                        i += 1;
                        j -= 1;
                    }
                }
                i += j;
                if (0 <= weight) {
                    result += weight;
                }
            }
            return result;
        };
        DLayout.prototype.getSpaceLeft = function (baseSize, margin) {
            var children = this.children;
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            if (this._direction === DLayoutDirection.VERTICAL) {
                var result = baseSize;
                var marginNext = 0;
                for (var i = 0, imax = children.length; i < imax;) {
                    var height = 0;
                    var weight = -1;
                    var j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        var child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            var clearType = child.getClearType();
                            if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    height = Math.max(height, child.height + marginNext);
                                }
                                else {
                                    height = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= height;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
            else {
                var result = baseSize;
                var marginNext = 0;
                for (var i = 0, imax = children.length; i < imax;) {
                    var width = 0;
                    var weight = -1;
                    var j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        var child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            var clearType = child.getClearType();
                            if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    width = Math.max(width, child.width + marginNext);
                                }
                                else {
                                    width = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= width;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
        };
        DLayout.prototype.calcSpaceLeft = function (isOn, size, padding, margin) {
            return isOn ? 0 : this.getSpaceLeft(size - padding, margin);
        };
        DLayout.prototype.onRefit = function () {
            var children = this.children;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            var paddingRight = padding.getRight();
            var margin = this._margin;
            var marginVertical = margin.vertical;
            var marginHorizontal = margin.horizontal;
            var weightTotal = this.getWeightTotal();
            var multiplicity = this._multiplicity;
            var reverse = this._reverse;
            var auto = this._auto;
            var cornerAdjustWork = null;
            if (this._cornerAdjust) {
                var requiredSize = 4 + (children.length << 1);
                if (DLayout.CORNER_ADJUST_WORK == null ||
                    DLayout.CORNER_ADJUST_WORK.length < requiredSize) {
                    DLayout.CORNER_ADJUST_WORK = new Float32Array(requiredSize);
                }
                cornerAdjustWork = DLayout.CORNER_ADJUST_WORK;
                cornerAdjustWork[0] = -2;
                cornerAdjustWork[1] = -2;
                cornerAdjustWork[requiredSize - 2] = -3;
                cornerAdjustWork[requiredSize - 1] = -3;
            }
            if (this._direction === DLayoutDirection.VERTICAL) {
                var irow = 0;
                var y = paddingTop - marginVertical;
                if (0 < weightTotal) {
                    var weightTotalInverse = 1 / weightTotal;
                    var spaceLeft = this.calcSpaceLeft(auto.height.isOn, this.height, paddingTop + paddingBottom, marginVertical);
                    for (var i = 0, imax = children.length; i < imax;) {
                        var x = paddingLeft - marginHorizontal;
                        var height = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                var icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                var ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
                else {
                    for (var i = 0, imax = children.length; i < imax;) {
                        var x = paddingLeft - marginHorizontal;
                        var height = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = 0;
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                var icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                var ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
            }
            else {
                var icolumn = 0;
                var x = paddingLeft - marginHorizontal;
                if (0 < weightTotal) {
                    var weightTotalInverse = 1 / weightTotal;
                    var spaceLeft = this.calcSpaceLeft(auto.width.isOn, this.width, paddingLeft + paddingRight, marginHorizontal);
                    for (var i = 0, imax = children.length; i < imax;) {
                        var y = paddingTop - marginVertical;
                        var width = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                var irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                var nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
                else {
                    for (var i = 0, imax = children.length; i < imax;) {
                        var y = paddingTop - marginVertical;
                        var width = 0;
                        var j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            var child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                var clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    var weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = 0;
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            var k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    var k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (var i = 0, imax = children.length; i < imax; ++i) {
                            var child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                var i1 = 2 + (i << 1);
                                var icolumn1 = cornerAdjustWork[i1 + 0];
                                var irow1 = cornerAdjustWork[i1 + 1];
                                var clearType = child.getClearType();
                                var irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    var i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                var irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    var i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                var nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
            }
            _super.prototype.onRefit.call(this);
        };
        DLayout.prototype.hasClearTypeBefore = function (children, index) {
            return this.hasClearType(children, index, DLayoutClearType.BEFORE);
        };
        DLayout.prototype.hasClearTypeAfter = function (children, index) {
            return this.hasClearType(children, index, DLayoutClearType.AFTER);
        };
        DLayout.prototype.hasClearType = function (children, index, clearType) {
            if (2 <= index) {
                var i = (index - 2) >> 1;
                if (0 <= i && i < children.length) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        return !!(child.getClearType() & clearType);
                    }
                }
            }
            return false;
        };
        DLayout.prototype.findColumnIndexPrevious = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i] !== icolumn) {
                    return i;
                }
            }
            return 0;
        };
        DLayout.prototype.findColumnIndexNext = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    for (var j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j] !== icolumn2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        };
        DLayout.prototype.countRow = function (istart, icolumn, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    return cornerAdjustWork[i - 2 + 1] + 1;
                }
            }
            return 0;
        };
        DLayout.prototype.findRowIndexPrevious = function (istart, irow, cornerAdjustWork) {
            for (var i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i + 1] !== irow) {
                    return i;
                }
            }
            return 0;
        };
        DLayout.prototype.findRowIndexNext = function (istart, irow, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    for (var j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j + 1] !== irow2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        };
        DLayout.prototype.countColumn = function (istart, irow, cornerAdjustWork) {
            for (var i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                var irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    return cornerAdjustWork[i - 2 + 0] + 1;
                }
            }
            return 0;
        };
        DLayout.prototype.toCornerMaskColumn = function (i0, i1, i2, n) {
            var result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & ~result;
        };
        DLayout.prototype.toCornerMaskRow = function (i0, i1, i2, n) {
            var result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & ~result;
        };
        DLayout.prototype.addSpace = function (options) {
            return this.addChild(new DLayoutSpace(options));
        };
        DLayout.prototype.getType = function () {
            return "DLayout";
        };
        DLayout.CORNER_ADJUST_WORK = null;
        return DLayout;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutVertical = /** @class */ (function (_super) {
        __extends(DLayoutVertical, _super);
        function DLayoutVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayoutVertical.prototype.getType = function () {
            return "DLayoutVertical";
        };
        return DLayoutVertical;
    }(DLayout));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredContent = /** @class */ (function (_super) {
        __extends(DDialogLayeredContent, _super);
        function DDialogLayeredContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogLayeredContent.prototype.getType = function () {
            return "DDialogLayeredContent";
        };
        return DDialogLayeredContent;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DButtonBase} option when to activate a button.
     */
    var DButtonBaseWhen = {
        /** Activates when clicked */
        CLICKED: 0,
        /** Activates when double clicked */
        DOUBLE_CLICKED: 1
    };

    var DImageBaseThemeWrapperSecondary = /** @class */ (function () {
        function DImageBaseThemeWrapperSecondary(theme) {
            this._theme = theme;
        }
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignHorizontal = function () {
            return this._theme.getSecondaryImageAlignHorizontal();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignVertical = function () {
            return this._theme.getSecondaryImageAlignVertical();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageAlignWith = function () {
            return this._theme.getSecondaryImageAlignWith();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageMarginHorizontal = function () {
            return this._theme.getSecondaryImageMarginHorizontal();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageMarginVertial = function () {
            return this._theme.getSecondaryImageMarginVertial();
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageTintColor = function (state) {
            return this._theme.getSecondaryImageTintColor(state);
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageTintAlpha = function (state) {
            return this._theme.getSecondaryImageTintAlpha(state);
        };
        DImageBaseThemeWrapperSecondary.prototype.getImageSource = function (state) {
            return this._theme.getSecondaryImageSource(state);
        };
        return DImageBaseThemeWrapperSecondary;
    }());

    var DImageBaseThemeWrapperTertiary = /** @class */ (function () {
        function DImageBaseThemeWrapperTertiary(theme) {
            this._theme = theme;
        }
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignHorizontal = function () {
            return this._theme.getTertiaryImageAlignHorizontal();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignVertical = function () {
            return this._theme.getTertiaryImageAlignVertical();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageAlignWith = function () {
            return this._theme.getTertiaryImageAlignWith();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageMarginHorizontal = function () {
            return this._theme.getTertiaryImageMarginHorizontal();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageMarginVertial = function () {
            return this._theme.getTertiaryImageMarginVertial();
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageTintColor = function (state) {
            return this._theme.getTertiaryImageTintColor(state);
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageTintAlpha = function (state) {
            return this._theme.getTertiaryImageTintAlpha(state);
        };
        DImageBaseThemeWrapperTertiary.prototype.getImageSource = function (state) {
            return this._theme.getTertiaryImageSource(state);
        };
        return DImageBaseThemeWrapperTertiary;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignHorizontal = {
        LEFT: 0,
        CENTER: 1,
        RIGHT: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignVertical = {
        TOP: 0,
        MIDDLE: 1,
        BOTTOM: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAlignWith = {
        TEXT: 0,
        PADDING: 1,
        BORDER: 2
    };

    var toImageAlign = function (theme, options) {
        var _a, _b, _c;
        var align = options === null || options === void 0 ? void 0 : options.align;
        return {
            with: toEnum((_a = align === null || align === void 0 ? void 0 : align.with) !== null && _a !== void 0 ? _a : theme.getImageAlignWith(), DAlignWith),
            vertical: toEnum((_b = align === null || align === void 0 ? void 0 : align.vertical) !== null && _b !== void 0 ? _b : theme.getImageAlignVertical(), DAlignVertical),
            horizontal: toEnum((_c = align === null || align === void 0 ? void 0 : align.horizontal) !== null && _c !== void 0 ? _c : theme.getImageAlignHorizontal(), DAlignHorizontal)
        };
    };
    var toImageMargin = function (theme, options) {
        var _a, _b;
        var margin = options === null || options === void 0 ? void 0 : options.margin;
        return {
            vertical: (_a = margin === null || margin === void 0 ? void 0 : margin.vertical) !== null && _a !== void 0 ? _a : theme.getImageMarginVertial(),
            horizontal: (_b = margin === null || margin === void 0 ? void 0 : margin.horizontal) !== null && _b !== void 0 ? _b : theme.getImageMarginHorizontal()
        };
    };
    var DImagePiece = /** @class */ (function () {
        function DImagePiece(parent, theme, textAlign, options) {
            var _this = this;
            this._parent = parent;
            this._theme = theme;
            this._textAlign = textAlign;
            this._image = null;
            this._align = toImageAlign(theme, options);
            this._margin = toImageMargin(theme, options);
            this._tint = options === null || options === void 0 ? void 0 : options.tint;
            this._bound = new pixi_js.Rectangle();
            this._source = options === null || options === void 0 ? void 0 : options.source;
            this._computed = null;
            this._onUpdateBound = function () {
                _this.onUpdate();
            };
        }
        Object.defineProperty(DImagePiece.prototype, "image", {
            get: function () {
                return this._image;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "align", {
            get: function () {
                return this._align;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "bound", {
            get: function () {
                return this._bound;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePiece.prototype, "source", {
            get: function () {
                return this._source;
            },
            set: function (source) {
                if (this._source !== source) {
                    this._source = source;
                    this.onUpdate();
                }
            },
            enumerable: false,
            configurable: true
        });
        DImagePiece.prototype.computeSource = function () {
            var source = this._source;
            if (source !== undefined) {
                if (isFunction(source)) {
                    var result = source(this._parent.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return source;
                }
            }
            return this._theme.getImageSource(this._parent.state);
        };
        DImagePiece.prototype.onStateChange = function (newState, oldState) {
            this.updateTint();
        };
        DImagePiece.prototype.updateBound = function () {
            var bound = this._bound;
            var image = this._image;
            if (image != null) {
                image.updateTransform();
                image.getLocalBounds(bound);
                var bl = bound.left;
                var bt = bound.top;
                var br = bound.right;
                var bb = bound.bottom;
                var localTransform = image.localTransform;
                var a = localTransform.a;
                var b = localTransform.b;
                var c = localTransform.c;
                var d = localTransform.d;
                var x0 = a * bl + c * bt;
                var y0 = b * bl + d * bt;
                var x1 = a * br + c * bt;
                var y1 = b * br + d * bt;
                var x2 = a * br + c * bb;
                var y2 = b * br + d * bb;
                var x3 = a * bl + c * bb;
                var y3 = b * bl + d * bb;
                var xmin = Math.min(x0, x1, x2, x3);
                var xmax = Math.max(x0, x1, x2, x3);
                var ymin = Math.min(y0, y1, y2, y3);
                var ymax = Math.max(y0, y1, y2, y3);
                bound.x = xmin + localTransform.tx;
                bound.y = ymin + localTransform.ty;
                bound.width = xmax - xmin;
                bound.height = ymax - ymin;
            }
            else {
                bound.x = 0;
                bound.y = 0;
                bound.width = 0;
                bound.height = 0;
            }
        };
        DImagePiece.prototype.isTintAware = function (target) {
            return target != null && "tint" in target;
        };
        DImagePiece.prototype.toTintColor = function (theme, state) {
            var tint = this._tint;
            if (tint) {
                var color = tint.color;
                if (color !== undefined) {
                    if (isFunction(color)) {
                        var result = color(state);
                        if (result !== undefined) {
                            return result;
                        }
                    }
                    else {
                        return color;
                    }
                }
            }
            return theme.getImageTintColor(state);
        };
        DImagePiece.prototype.toTintAlpha = function (theme, state) {
            var tint = this._tint;
            if (tint) {
                var alpha = tint.alpha;
                if (alpha !== undefined) {
                    if (isFunction(alpha)) {
                        var result = alpha(state);
                        if (result !== undefined) {
                            return result;
                        }
                    }
                    else {
                        return alpha;
                    }
                }
            }
            return theme.getImageTintAlpha(state);
        };
        /**
         * Updates the tint.
         *
         * @returns True if the tint is changed.
         */
        DImagePiece.prototype.updateTint = function () {
            var image = this._image;
            if (image) {
                if (this.isTintAware(image)) {
                    var theme = this._theme;
                    var state = this._parent.state;
                    var color = this.toTintColor(theme, state);
                    if (color != null) {
                        var result = false;
                        if (image.tint !== color) {
                            image.tint = color;
                            result = true;
                        }
                        var alpha = this.toTintAlpha(theme, state);
                        if (image.alpha !== alpha) {
                            image.alpha = alpha;
                            result = true;
                        }
                        return result;
                    }
                }
            }
            return false;
        };
        /**
         * Updates the computed source.
         *
         * @returns True if the computed source is changed
         */
        DImagePiece.prototype.updateSource = function () {
            var newComputed = this.computeSource();
            var oldComputed = this._computed;
            if (newComputed !== oldComputed) {
                this._computed = newComputed;
                var parent_1 = this._parent;
                var oldImage = this._image;
                var onUpdateBound = this._onUpdateBound;
                if (newComputed instanceof pixi_js.Texture) {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", onUpdateBound);
                        if (oldImage instanceof pixi_js.Sprite) {
                            oldImage.texture = newComputed;
                            newComputed.on("update", onUpdateBound);
                        }
                    }
                    else {
                        if (oldImage != null) {
                            parent_1.removeChild(oldImage);
                        }
                        var newImage = new pixi_js.Sprite(newComputed);
                        var overflowMask = parent_1.getOverflowMask();
                        if (overflowMask) {
                            newImage.mask = overflowMask;
                        }
                        newComputed.on("update", onUpdateBound);
                        parent_1.addChild(newImage);
                        this._image = newImage;
                    }
                }
                else {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", onUpdateBound);
                        if (oldImage != null) {
                            parent_1.removeChild(oldImage);
                            oldImage.destroy();
                        }
                    }
                    else if (oldImage != null) {
                        parent_1.removeChild(oldImage);
                    }
                    if (newComputed != null) {
                        var overflowMask = parent_1.getOverflowMask();
                        if (overflowMask) {
                            newComputed.mask = overflowMask;
                        }
                        parent_1.addChild(newComputed);
                    }
                    this._image = newComputed;
                }
                return true;
            }
            return false;
        };
        DImagePiece.prototype.isRefitable = function (target) {
            return target != null && target === this._image;
        };
        DImagePiece.prototype.destroy = function () {
            var image = this._image;
            if (image) {
                this._image = null;
                var computed = this._computed;
                if (computed instanceof pixi_js.Texture) {
                    computed.off("update", this._onUpdateBound, this);
                    image.destroy();
                }
            }
        };
        DImagePiece.prototype.onUpdate = function () {
            this._parent.toDirty();
            DApplications.update(this._parent);
        };
        return DImagePiece;
    }());

    var DImagePieceLayouterPart = /** @class */ (function () {
        function DImagePieceLayouterPart() {
            this._pieces = [];
            this._size = 0;
            this._margin = 0;
        }
        DImagePieceLayouterPart.prototype.clear = function () {
            this._pieces.length = 0;
            this._size = 0;
            this._margin = 0;
            this._text = undefined;
        };
        DImagePieceLayouterPart.prototype.add = function (image, size, margin) {
            var pieces = this._pieces;
            pieces.push(image);
            this._size += margin + size;
            this._margin = margin;
        };
        DImagePieceLayouterPart.prototype.set = function (text) {
            this._text = text;
        };
        Object.defineProperty(DImagePieceLayouterPart.prototype, "size", {
            get: function () {
                return this._size - (this._text === null ? this._margin : 0);
            },
            enumerable: false,
            configurable: true
        });
        return DImagePieceLayouterPart;
    }());

    var DImagePieceLayouterPartBottom = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartBottom, _super);
        function DImagePieceLayouterPartBottom() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartBottom.prototype.execute = function (pbottom, height) {
            var pieces = this._pieces;
            var y = height - pbottom;
            if (this._text !== undefined) {
                var margin = 0;
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    y -= margin + piece.bound.height;
                    piece.image.y = y;
                    margin = piece.margin.horizontal;
                }
            }
            else {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    y -= piece.margin.horizontal + piece.bound.height;
                    piece.image.y = y;
                }
            }
        };
        return DImagePieceLayouterPartBottom;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartCenter = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartCenter, _super);
        function DImagePieceLayouterPartCenter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartCenter.prototype.add = function (image, size, margin) {
            var pieces = this._pieces;
            pieces.push(image);
            this._size = Math.max(this.size, size);
        };
        DImagePieceLayouterPartCenter.prototype.execute = function (pleft, pright, width) {
            var c = pleft + (width - pleft - pright) * 0.5;
            var pieces = this._pieces;
            for (var i = 0, imax = pieces.length; i < imax; ++i) {
                var piece = pieces[i];
                piece.image.x = c - piece.bound.width * 0.5;
            }
        };
        return DImagePieceLayouterPartCenter;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartLeft = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartLeft, _super);
        function DImagePieceLayouterPartLeft() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartLeft.prototype.execute = function (pleft) {
            var pieces = this._pieces;
            var x = pleft;
            if (this._text !== undefined) {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    piece.image.x = x;
                    x += piece.bound.width + piece.margin.horizontal;
                }
            }
            else {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    x += piece.margin.horizontal;
                    piece.image.x = x;
                    x += piece.bound.width;
                }
            }
        };
        return DImagePieceLayouterPartLeft;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartMiddle = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartMiddle, _super);
        function DImagePieceLayouterPartMiddle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartMiddle.prototype.add = function (image, size, margin) {
            var pieces = this._pieces;
            pieces.push(image);
            this._size = Math.max(this.size, size);
        };
        DImagePieceLayouterPartMiddle.prototype.execute = function (ptop, pbottom, height) {
            var c = ptop + (height - ptop - pbottom) * 0.5;
            var pieces = this._pieces;
            for (var i = 0, imax = pieces.length; i < imax; ++i) {
                var piece = pieces[i];
                piece.image.y = c - piece.bound.height * 0.5;
            }
        };
        return DImagePieceLayouterPartMiddle;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartRight = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartRight, _super);
        function DImagePieceLayouterPartRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartRight.prototype.execute = function (pright, width) {
            var pieces = this._pieces;
            var x = width - pright;
            if (this._text !== undefined) {
                var margin = 0;
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    x -= margin + piece.bound.width;
                    piece.image.x = x;
                    margin = piece.margin.horizontal;
                }
            }
            else {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    x -= piece.margin.horizontal + piece.bound.width;
                    piece.image.x = x;
                }
            }
        };
        return DImagePieceLayouterPartRight;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartTop = /** @class */ (function (_super) {
        __extends(DImagePieceLayouterPartTop, _super);
        function DImagePieceLayouterPartTop() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImagePieceLayouterPartTop.prototype.execute = function (ptop) {
            var pieces = this._pieces;
            var y = ptop;
            if (this._text !== undefined) {
                var margin = 0;
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    piece.image.y = margin + y;
                    y += piece.bound.height;
                    margin = piece.margin.vertical;
                }
            }
            else {
                for (var i = 0, imax = pieces.length; i < imax; ++i) {
                    var piece = pieces[i];
                    y += piece.margin.vertical;
                    piece.image.y = y;
                    y += piece.bound.height;
                }
            }
        };
        return DImagePieceLayouterPartTop;
    }(DImagePieceLayouterPart));

    var DImagePieceLayouterPartContainer = /** @class */ (function () {
        function DImagePieceLayouterPartContainer() {
            this.left = new DImagePieceLayouterPartLeft();
            this.center = new DImagePieceLayouterPartCenter();
            this.right = new DImagePieceLayouterPartRight();
            this.top = new DImagePieceLayouterPartTop();
            this.middle = new DImagePieceLayouterPartMiddle();
            this.bottom = new DImagePieceLayouterPartBottom();
        }
        DImagePieceLayouterPartContainer.prototype.clear = function () {
            this.left.clear();
            this.center.clear();
            this.right.clear();
            this.top.clear();
            this.middle.clear();
            this.bottom.clear();
            this.text = undefined;
        };
        DImagePieceLayouterPartContainer.prototype.add = function (image) {
            var imageImage = image.image;
            if (imageImage != null) {
                var imageBound = image.bound;
                var imageBoundWidth = imageBound.width;
                var imageBoundHeight = imageBound.height;
                var imageMargin = image.margin;
                var imageMarginHorizontal = imageMargin.horizontal;
                var imageMarginVertical = imageMargin.vertical;
                var imageAlign = image.align;
                switch (imageAlign.horizontal) {
                    case DAlignHorizontal.LEFT:
                        this.left.add(image, imageBoundWidth, imageMarginHorizontal);
                        break;
                    case DAlignHorizontal.CENTER:
                        this.center.add(image, imageBoundWidth, imageMarginHorizontal);
                        break;
                    case DAlignHorizontal.RIGHT:
                        this.right.add(image, imageBoundWidth, imageMarginHorizontal);
                        break;
                }
                switch (imageAlign.vertical) {
                    case DAlignVertical.TOP:
                        this.top.add(image, imageBoundHeight, imageMarginVertical);
                        break;
                    case DAlignVertical.MIDDLE:
                        this.middle.add(image, imageBoundHeight, imageMarginVertical);
                        break;
                    case DAlignVertical.BOTTOM:
                        this.bottom.add(image, imageBoundHeight, imageMarginVertical);
                        break;
                }
            }
        };
        DImagePieceLayouterPartContainer.prototype.set = function (text) {
            this.left.set(text);
            this.center.set(text);
            this.right.set(text);
            this.top.set(text);
            this.middle.set(text);
            this.bottom.set(text);
            this.text = text;
        };
        Object.defineProperty(DImagePieceLayouterPartContainer.prototype, "width", {
            get: function () {
                var text = this.text;
                var left = this.left;
                var leftSize = left.size;
                var center = this.center;
                var centerSize = center.size;
                var right = this.right;
                var rightSize = right.size;
                if (text !== undefined) {
                    if (text !== null) {
                        return Math.max(leftSize + text.width + rightSize, centerSize);
                    }
                    else {
                        return Math.max(leftSize + rightSize, centerSize);
                    }
                }
                else {
                    return Math.max(leftSize, rightSize, centerSize);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceLayouterPartContainer.prototype, "height", {
            get: function () {
                var text = this.text;
                var top = this.top;
                var topSize = top.size;
                var middle = this.middle;
                var middleSize = middle.size;
                var bottom = this.bottom;
                var bottomSize = bottom.size;
                if (text !== undefined) {
                    if (text !== null) {
                        return Math.max(topSize + text.height + bottomSize, middleSize);
                    }
                    else {
                        return Math.max(topSize + bottomSize, middleSize);
                    }
                }
                else {
                    return Math.max(topSize, bottomSize, middleSize);
                }
            },
            enumerable: false,
            configurable: true
        });
        DImagePieceLayouterPartContainer.prototype.execute = function (pleft, ptop, pright, pbottom, textAlign, width, height) {
            var left = this.left;
            var center = this.center;
            var right = this.right;
            var top = this.top;
            var middle = this.middle;
            var bottom = this.bottom;
            var text = this.text;
            if (text !== undefined) {
                var leftSize = left.size;
                var rightSize = right.size;
                var topSize = top.size;
                var bottomSize = bottom.size;
                var textX = 0;
                var textWidth = 0;
                var textHeight = 0;
                if (text != null) {
                    textWidth = text.width;
                    textHeight = text.height;
                }
                switch (textAlign.horizontal) {
                    case DAlignHorizontal.LEFT:
                        textX = pleft + leftSize;
                        break;
                    case DAlignHorizontal.CENTER:
                        textX =
                            pleft +
                                (width - pleft - pright - (leftSize + textWidth + rightSize)) * 0.5 +
                                leftSize;
                        break;
                    case DAlignHorizontal.RIGHT:
                        textX = width - pright - rightSize - textWidth;
                        break;
                }
                var textY = 0;
                switch (textAlign.vertical) {
                    case DAlignVertical.TOP:
                        textY = ptop + topSize;
                        break;
                    case DAlignVertical.MIDDLE:
                        textY =
                            ptop +
                                (height - ptop - pbottom - (topSize + textHeight + bottomSize)) * 0.5 +
                                topSize;
                        break;
                    case DAlignVertical.BOTTOM:
                        textY = height - pbottom - bottomSize - textHeight;
                        break;
                }
                if (text != null) {
                    text.position.set(textX, textY);
                    text.setClippingDelta(leftSize + rightSize, topSize + bottomSize);
                }
                left.execute(textX - leftSize);
                center.execute(0, 0, textX * 2 + textWidth);
                right.execute(0, textX + textWidth + rightSize);
                top.execute(textY - topSize);
                middle.execute(0, 0, textY * 2 + textHeight);
                bottom.execute(0, textY + textHeight + bottomSize);
            }
            else {
                left.execute(pleft);
                center.execute(pleft, pright, width);
                right.execute(pright, width);
                top.execute(ptop);
                middle.execute(ptop, pbottom, height);
                bottom.execute(pbottom, height);
            }
        };
        return DImagePieceLayouterPartContainer;
    }());

    var DImagePieceLayouter = /** @class */ (function () {
        function DImagePieceLayouter() {
            this.text = new DImagePieceLayouterPartContainer();
            this.padding = new DImagePieceLayouterPartContainer();
            this.border = new DImagePieceLayouterPartContainer();
        }
        DImagePieceLayouter.prototype.clear = function () {
            this.text.clear();
            this.padding.clear();
            this.border.clear();
        };
        DImagePieceLayouter.prototype.add = function (image) {
            var imageImage = image.image;
            if (imageImage) {
                switch (image.align.with) {
                    case DAlignWith.TEXT:
                        this.text.add(image);
                        break;
                    case DAlignWith.PADDING:
                        this.padding.add(image);
                        break;
                    case DAlignWith.BORDER:
                        this.border.add(image);
                        break;
                }
            }
        };
        DImagePieceLayouter.prototype.set = function (text) {
            this.text.set(text);
        };
        DImagePieceLayouter.prototype.execute = function (padding, textAlign, width, height) {
            var pleft = padding.getLeft();
            var ptop = padding.getTop();
            var pright = padding.getRight();
            var pbottom = padding.getBottom();
            if (width == null) {
                width = pleft + this.width + pright;
            }
            if (height == null) {
                height = ptop + this.height + pbottom;
            }
            this.border.execute(0, 0, 0, 0, textAlign, width, height);
            this.padding.execute(pleft, ptop, pright, pbottom, textAlign, width, height);
            this.text.execute(pleft, ptop, pright, pbottom, textAlign, width, height);
        };
        Object.defineProperty(DImagePieceLayouter.prototype, "width", {
            get: function () {
                return Math.max(this.border.width, this.padding.width, this.text.width);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DImagePieceLayouter.prototype, "height", {
            get: function () {
                return Math.max(this.border.height, this.padding.height, this.text.height);
            },
            enumerable: false,
            configurable: true
        });
        return DImagePieceLayouter;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBaseOverflowMaskSimple = /** @class */ (function (_super) {
        __extends(DBaseOverflowMaskSimple, _super);
        function DBaseOverflowMaskSimple(parent) {
            var _this = _super.call(this) || this;
            _this.parent = parent;
            return _this;
        }
        DBaseOverflowMaskSimple.prototype.render = function (renderer) {
            this.updateTransform();
            _super.prototype.render.call(this, renderer);
        };
        DBaseOverflowMaskSimple.prototype.onReflow = function (base, width, height) {
            this.clear();
            this.beginFill(0xffffff, 1);
            this.drawRect(0, 0, width, height);
            this.endFill();
        };
        return DBaseOverflowMaskSimple;
    }(pixi_js.Graphics));

    var DDynamicTextMeasureResultCharacter = /** @class */ (function () {
        function DDynamicTextMeasureResultCharacter(x, y, character, wrappable) {
            this.x = x;
            this.y = y;
            this.character = character;
            this.wrappable = wrappable;
        }
        DDynamicTextMeasureResultCharacter.prototype.set = function (x, y, character, isWrappable) {
            this.x = x;
            this.y = y;
            this.character = character;
            this.wrappable = isWrappable;
        };
        return DDynamicTextMeasureResultCharacter;
    }());

    var DDynamicTextMeasureResult = /** @class */ (function () {
        function DDynamicTextMeasureResult() {
            this.count = 0;
            this.countPerLine = 0;
            this.width = 0;
            this.height = 0;
            this.characters = [];
            this.scale = 1;
            this.scaled = false;
            this.clipped = false;
            this.x = 0;
            this.y = 0;
        }
        DDynamicTextMeasureResult.prototype.start = function (lineHeight, fontHeight) {
            this.count = 0;
            this.countPerLine = 0;
            this.width = 0;
            this.height = 0;
            this.scale = 1;
            this.scaled = false;
            this.clipped = false;
            this.x = 0;
            this.y = 0.5 * (lineHeight - fontHeight);
        };
        DDynamicTextMeasureResult.prototype.isPushable = function (width, character) {
            var x = this.x + character.advance;
            if (width < x) {
                if (character.type & DynamicFontAtlasCharacterType.SPACE) {
                    return true;
                }
                else {
                    return false;
                }
            }
            return true;
        };
        DDynamicTextMeasureResult.prototype.isPushableAtNewLine = function (height, lineHeight, fontHeight) {
            return this.y + 1.5 * lineHeight + 0.5 * fontHeight <= height;
        };
        DDynamicTextMeasureResult.prototype.push = function (character, isWrappable) {
            var x = this.x;
            this.x += character.advance;
            var y = this.y;
            var count = this.count;
            var characters = this.characters;
            if (count < characters.length) {
                characters[count].set(x, y, character, isWrappable);
            }
            else {
                characters.push(new DDynamicTextMeasureResultCharacter(x, y, character, isWrappable));
            }
            this.count += 1;
            this.countPerLine += 1;
        };
        DDynamicTextMeasureResult.prototype.newLine = function (lineHeight) {
            this.width = Math.max(this.width, this.x);
            this.x = 0;
            this.y += lineHeight;
            this.countPerLine = 0;
        };
        DDynamicTextMeasureResult.prototype.wordWrap = function (lineHeight) {
            var countPerLine = this.countPerLine;
            var characters = this.characters;
            if (0 < countPerLine) {
                var count = this.count;
                for (var i = count - 1, imin = count - countPerLine; imin < i; --i) {
                    var character = characters[i];
                    if (character.wrappable) {
                        var x = character.character.advance;
                        var y = character.y + lineHeight;
                        character.x = 0;
                        character.y = y;
                        for (var j = i + 1; j < count; ++j) {
                            character = characters[j];
                            character.x = x;
                            character.y = y;
                            x += character.character.advance;
                        }
                        this.x = x;
                        this.y = y;
                        this.countPerLine = count - i;
                        return true;
                    }
                }
                var last = characters[count - 1];
                last.x = 0;
                last.y = last.y + lineHeight;
                this.x = last.character.advance;
                this.y = last.y;
                this.countPerLine = 1;
                return false;
            }
            return false;
        };
        DDynamicTextMeasureResult.prototype.pop = function () {
            var countPerLine = this.countPerLine;
            var characters = this.characters;
            if (0 < countPerLine) {
                var character = characters[this.count - 1];
                this.x -= character.character.advance;
                this.count -= 1;
                this.countPerLine -= 1;
                return true;
            }
            return false;
        };
        DDynamicTextMeasureResult.prototype.fit = function (width, height) {
            var w = this.width;
            var h = this.height;
            if (1e-4 < w && width < w) {
                if (1e-4 < h && height < h) {
                    this.scale = Math.min(width / w, height / h);
                    this.scaled = true;
                }
                else {
                    this.scale = width / w;
                    this.scaled = true;
                }
            }
            else if (1e-4 < h && height < h) {
                this.scale = height / h;
                this.scaled = true;
            }
        };
        DDynamicTextMeasureResult.prototype.end = function (lineHeight, fontHeight) {
            this.newLine(lineHeight);
            this.y -= 0.5 * (lineHeight - fontHeight);
            this.height = this.y;
        };
        return DDynamicTextMeasureResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextStyleWordWrap = {
        NONE: 0,
        NORMAL: 1,
        BREAK_ALL: 2
    };

    var NEW_LINE = "\n";
    var DDynamicTextMeasure = /** @class */ (function () {
        function DDynamicTextMeasure() {
        }
        DDynamicTextMeasure.measure = function (text, atlas, modifier) {
            var result = DDynamicTextMeasure.RESULT || new DDynamicTextMeasureResult();
            DDynamicTextMeasure.RESULT = result;
            if (atlas != null) {
                var itr = UtilCharacterIterator.from(text);
                var fh = atlas.font.height;
                var lh = modifier.lineHeight;
                var cf = modifier.fitting;
                var cc = !cf && modifier.clipping;
                var cw = modifier.width;
                var ch = modifier.height;
                var cp = !cf && modifier.wordWrap;
                result.start(lh, fh);
                switch (cp) {
                    case DDynamicTextStyleWordWrap.BREAK_ALL:
                        if (cc) {
                            this.measure1(itr, cw, ch, fh, lh, atlas, result);
                        }
                        else {
                            this.measure2(itr, cw, lh, atlas, result);
                        }
                        break;
                    case DDynamicTextStyleWordWrap.NORMAL:
                        var lb = this.newLineBreaker(text);
                        if (lb) {
                            if (cc) {
                                this.measure1a(lb, itr, cw, ch, fh, lh, atlas, result);
                            }
                            else {
                                this.measure2a(lb, itr, cw, lh, atlas, result);
                            }
                        }
                        else {
                            if (cc) {
                                this.measure1b(itr, cw, ch, fh, lh, atlas, result);
                            }
                            else {
                                this.measure2b(itr, cw, lh, atlas, result);
                            }
                        }
                        break;
                    default:
                        if (cc) {
                            this.measure3(itr, cw, lh, atlas, result);
                        }
                        else {
                            this.measure4(itr, lh, atlas, result);
                        }
                        break;
                }
                result.end(lh, fh);
                if (cf) {
                    result.fit(cw, ch);
                }
            }
            else {
                result.start(0, 0);
                result.end(0, 0);
            }
            return result;
        };
        DDynamicTextMeasure.measure1a = function (lineBreaker, iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            var lineBreak = lineBreaker.next();
            while (iterator.hasNext()) {
                var characterPosition = iterator.position;
                var character = iterator.next();
                if (character === NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    lineBreak = this.advance(characterPosition, lineBreak, lineBreaker);
                    var isWrappable = this.isWrappable1(characterPosition, lineBreak);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                            result.push(a, isWrappable);
                            result.wordWrap(lineHeight);
                        }
                        else {
                            this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                        }
                    }
                }
            }
        };
        DDynamicTextMeasure.measure1b = function (iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    var isWrappable = this.isWrappable2(result, a);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                            result.push(a, isWrappable);
                            result.wordWrap(lineHeight);
                        }
                        else {
                            this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                        }
                    }
                }
            }
        };
        DDynamicTextMeasure.measure1 = function (iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, true);
                    }
                    else {
                        if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                            result.newLine(lineHeight);
                            result.push(a, true);
                        }
                        else {
                            this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                        }
                    }
                }
            }
        };
        DDynamicTextMeasure.measure2a = function (lineBreaker, iterator, clippingWidth, lineHeight, atlas, result) {
            var lineBreak = lineBreaker.next();
            while (iterator.hasNext()) {
                var characterPosition = iterator.position;
                var character = iterator.next();
                if (character === NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    lineBreak = this.advance(characterPosition, lineBreak, lineBreaker);
                    var isWrappable = this.isWrappable1(characterPosition, lineBreak);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        result.push(a, isWrappable);
                        result.wordWrap(lineHeight);
                    }
                }
            }
        };
        DDynamicTextMeasure.measure2b = function (iterator, clippingWidth, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    var isWrappable = this.isWrappable2(result, a);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        result.push(a, isWrappable);
                        result.wordWrap(lineHeight);
                    }
                }
            }
        };
        DDynamicTextMeasure.measure2 = function (iterator, clippingWidth, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, false);
                    }
                    else {
                        result.newLine(lineHeight);
                        result.push(a, false);
                    }
                }
            }
        };
        DDynamicTextMeasure.measure3 = function (iterator, clippingWidth, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, false);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, false);
                    }
                }
            }
        };
        DDynamicTextMeasure.measure4 = function (iterator, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                var character = iterator.next();
                if (character === NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    var a = atlas.get(character);
                    if (a == null)
                        continue;
                    result.push(a, false);
                }
            }
        };
        DDynamicTextMeasure.measure5 = function (iterator, clippingWidth, lineHeight, atlas, result, close) {
            result.clipped = true;
            var dots = atlas.get("...");
            if (dots != null) {
                while (!result.isPushable(clippingWidth, dots)) {
                    if (!result.pop()) {
                        break;
                    }
                }
                if (result.isPushable(clippingWidth, dots)) {
                    result.push(dots, false);
                }
            }
            if (close) {
                iterator.close();
            }
            else {
                while (iterator.hasNext()) {
                    if (iterator.next() === NEW_LINE) {
                        result.newLine(lineHeight);
                        break;
                    }
                }
            }
        };
        DDynamicTextMeasure.isWrappable2 = function (result, character) {
            if (result.countPerLine <= 0) {
                return false;
            }
            var last = result.characters[result.count - 1];
            var lastType = last.character.type;
            var type = character.type;
            if (lastType & DynamicFontAtlasCharacterType.SPACE) {
                if (type & DynamicFontAtlasCharacterType.SPACE) {
                    return false;
                }
                else {
                    if (lastType & DynamicFontAtlasCharacterType.NON_BREAKING) {
                        return false;
                    }
                    else {
                        return true;
                    }
                }
            }
            else {
                if (type & DynamicFontAtlasCharacterType.SPACE) {
                    return false;
                }
                else {
                    if (lastType & DynamicFontAtlasCharacterType.NON_BREAKING) {
                        if (type & DynamicFontAtlasCharacterType.NON_BREAKING) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        return true;
                    }
                }
            }
        };
        DDynamicTextMeasure.advance = function (position, lineBreak, lineBreaker) {
            if (lineBreak.done) {
                return lineBreak;
            }
            if (position <= lineBreak.value.end) {
                return lineBreak;
            }
            lineBreak = lineBreaker.next();
            return lineBreak;
        };
        DDynamicTextMeasure.isWrappable1 = function (position, lineBreak) {
            if (lineBreak.done) {
                return false;
            }
            var value = lineBreak.value;
            return value.start === position || value.end === position;
        };
        DDynamicTextMeasure.newLineBreaker = function (target) {
            if ("css-line-break" in window) {
                var cssLineBreak = window["css-line-break"];
                return cssLineBreak.LineBreaker(target, {
                    lineBreak: "strict",
                    wordBreak: "normal"
                });
            }
            return null;
        };
        DDynamicTextMeasure.RESULT = null;
        return DDynamicTextMeasure;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextGeometry = /** @class */ (function (_super) {
        __extends(DDynamicTextGeometry, _super);
        function DDynamicTextGeometry() {
            var _this = _super.call(this, new Float32Array(64), new Float32Array(64), new Uint16Array(48)) || this;
            _this.width = 0;
            _this.height = 0;
            _this.scale = 1;
            _this.scaled = false;
            _this.clipped = false;
            return _this;
        }
        DDynamicTextGeometry.prototype.update = function (text, atlas, modifier) {
            var vertexBuffer = this.getBuffer("aVertexPosition");
            var uvBuffer = this.getBuffer("aTextureCoord");
            var indexBuffer = this.getIndex();
            var result = DDynamicTextMeasure.measure(text, atlas, modifier);
            var requiredTextSize = Math.ceil(result.count / 8) << 3;
            var requiredVertexSize = requiredTextSize << 3;
            if (vertexBuffer.data.length < requiredVertexSize) {
                vertexBuffer.data = new Float32Array(requiredVertexSize);
                uvBuffer.data = new Float32Array(requiredVertexSize);
            }
            var requiredIndexSize = requiredTextSize * 6;
            if (indexBuffer.data.length < requiredIndexSize) {
                indexBuffer.data = new Uint16Array(requiredIndexSize);
            }
            var vertices = vertexBuffer.data;
            var uvs = uvBuffer.data;
            var indices = indexBuffer.data;
            if (atlas != null) {
                var count = result.count;
                var characters = result.characters;
                var scale = result.scale;
                for (var i = 0; i < count; ++i) {
                    var character = characters[i];
                    var cx = character.x;
                    var cy = character.y;
                    var cc = character.character;
                    var w = atlas.width;
                    var h = atlas.height;
                    this.writeCharacter(vertices, uvs, indices, i, cx, cy, scale, cc, w, h);
                }
                for (var i = count, imax = vertices.length >> 3; i < imax; ++i) {
                    this.writeCharacterEmpty(vertices, uvs, indices, i);
                }
                this.width = result.width * scale;
                this.height = result.height * scale;
                this.scale = scale;
                this.scaled = result.scaled;
                this.clipped = result.clipped;
            }
            else {
                for (var i = 0, imax = vertices.length >> 3; i < imax; ++i) {
                    this.writeCharacterEmpty(vertices, uvs, indices, i);
                }
                this.width = 0;
                this.height = 0;
                this.scale = 1;
                this.scaled = false;
                this.clipped = false;
            }
            vertexBuffer.update();
            uvBuffer.update();
            indexBuffer.update();
        };
        DDynamicTextGeometry.prototype.writeCharacter = function (vertices, uvs, indices, index, x, y, scale, character, width, height) {
            var cx = character.x;
            var cy = character.y;
            var cw = character.width;
            var ch = character.height;
            var cox = character.origin.x;
            var x0 = (x + (cx - cox)) * scale;
            var y0 = y * scale;
            var x1 = x0 + cw * scale;
            var y1 = y0 + ch * scale;
            var iv = index << 3;
            vertices[iv + 0] = x0;
            vertices[iv + 1] = y0;
            vertices[iv + 2] = x1;
            vertices[iv + 3] = y0;
            vertices[iv + 4] = x1;
            vertices[iv + 5] = y1;
            vertices[iv + 6] = x0;
            vertices[iv + 7] = y1;
            var u0 = cx / width;
            var v0 = cy / height;
            var u1 = (cx + cw) / width;
            var v1 = (cy + ch) / height;
            uvs[iv + 0] = u0;
            uvs[iv + 1] = v0;
            uvs[iv + 2] = u1;
            uvs[iv + 3] = v0;
            uvs[iv + 4] = u1;
            uvs[iv + 5] = v1;
            uvs[iv + 6] = u0;
            uvs[iv + 7] = v1;
            var ii = index * 6;
            var vo = index << 2;
            indices[ii + 0] = vo + 0;
            indices[ii + 1] = vo + 1;
            indices[ii + 2] = vo + 3;
            indices[ii + 3] = vo + 1;
            indices[ii + 4] = vo + 2;
            indices[ii + 5] = vo + 3;
        };
        DDynamicTextGeometry.prototype.writeCharacterEmpty = function (vertices, uvs, indices, index) {
            var iv = index << 3;
            vertices[iv + 0] = 0;
            vertices[iv + 1] = 0;
            vertices[iv + 2] = 0;
            vertices[iv + 3] = 0;
            vertices[iv + 4] = 0;
            vertices[iv + 5] = 0;
            vertices[iv + 6] = 0;
            vertices[iv + 7] = 0;
            uvs[iv + 0] = 0;
            uvs[iv + 1] = 0;
            uvs[iv + 2] = 0;
            uvs[iv + 3] = 0;
            uvs[iv + 4] = 0;
            uvs[iv + 5] = 0;
            uvs[iv + 6] = 0;
            uvs[iv + 7] = 0;
            var ii = index * 6;
            var vo = index << 2;
            indices[ii + 0] = vo + 0;
            indices[ii + 1] = vo + 1;
            indices[ii + 2] = vo + 3;
            indices[ii + 3] = vo + 1;
            indices[ii + 4] = vo + 2;
            indices[ii + 5] = vo + 3;
        };
        return DDynamicTextGeometry;
    }(pixi_js.MeshGeometry));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicTextStyle = /** @class */ (function () {
        function DDynamicTextStyle(options, onChange) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            this._id = 0;
            this._idApproved = -1;
            var defaultOptions = this.getDefaultOptions();
            if (options) {
                this._align = (_a = options.align) !== null && _a !== void 0 ? _a : defaultOptions.align;
                this._fontFamily = (_b = options.fontFamily) !== null && _b !== void 0 ? _b : defaultOptions.fontFamily;
                this._fontSize = (_c = options.fontSize) !== null && _c !== void 0 ? _c : defaultOptions.fontSize;
                this._fontStyle = (_d = options.fontStyle) !== null && _d !== void 0 ? _d : defaultOptions.fontStyle;
                this._fontVariant = (_e = options.fontVariant) !== null && _e !== void 0 ? _e : defaultOptions.fontVariant;
                this._fontWeight = (_f = options.fontWeight) !== null && _f !== void 0 ? _f : defaultOptions.fontWeight;
                this._fill = (_g = options.fill) !== null && _g !== void 0 ? _g : defaultOptions.fill;
                this._clipping = (_h = options.clipping) !== null && _h !== void 0 ? _h : defaultOptions.clipping;
                this._fitting = (_j = options.fitting) !== null && _j !== void 0 ? _j : defaultOptions.fitting;
                this._wordWrap = toEnum((_k = options.wordWrap) !== null && _k !== void 0 ? _k : defaultOptions.wordWrap, DDynamicTextStyleWordWrap);
                this._lineHeight = (_l = options.lineHeight) !== null && _l !== void 0 ? _l : defaultOptions.lineHeight;
            }
            else {
                this._align = defaultOptions.align;
                this._fontFamily = defaultOptions.fontFamily;
                this._fontSize = defaultOptions.fontSize;
                this._fontStyle = defaultOptions.fontStyle;
                this._fontVariant = defaultOptions.fontVariant;
                this._fontWeight = defaultOptions.fontWeight;
                this._fill = defaultOptions.fill;
                this._clipping = defaultOptions.clipping;
                this._fitting = defaultOptions.fitting;
                this._wordWrap = toEnum(defaultOptions.wordWrap, DDynamicTextStyleWordWrap);
                this._lineHeight = defaultOptions.lineHeight;
            }
            this._fontSizeFitted = this._fontSize;
            this._lineHeightFitted = this._lineHeight;
            this._isFontFitted = false;
            this._fontIdFontSize = this._fontSize;
            this._fontIdId = -1;
            this._fontId = "";
            this._fontIdApproved = "";
            this._fillApproved = 0x000000;
            this._onChange = onChange;
        }
        DDynamicTextStyle.prototype.getDefaultOptions = function () {
            var result = DDynamicTextStyle.DEFAULT_OPTIONS;
            if (result == null) {
                result = this.newDefaultOptions();
                DDynamicTextStyle.DEFAULT_OPTIONS = result;
            }
            return result;
        };
        DDynamicTextStyle.prototype.newDefaultOptions = function () {
            var theme = DThemes.getInstance().get("DBase");
            return {
                align: "left",
                fontFamily: theme.getFontFamilly(),
                fontSize: theme.getFontSize(),
                fontStyle: "normal",
                fontVariant: "normal",
                fontWeight: "normal",
                fill: theme.getColor(new DBaseStateSetImpl()),
                clipping: true,
                fitting: false,
                wordWrap: DDynamicTextStyleWordWrap.NONE,
                lineHeight: theme.getLineHeight()
            };
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "idApproved", {
            get: function () {
                return this._idApproved;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontId", {
            get: function () {
                this.update();
                return this._fontId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontIdFontSize", {
            get: function () {
                this.update();
                return this._fontSizeFitted;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontIdApproved", {
            get: function () {
                return this._fontIdApproved;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            set: function (fill) {
                if (this._fill !== fill) {
                    this._fill = fill;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.onChange = function () {
            this._id += 1;
            this._onChange();
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "fillApproved", {
            get: function () {
                return this._fillApproved;
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.approve = function () {
            this.update();
            this._idApproved = this._id;
            this._fontIdApproved = this._fontId;
            this._fillApproved = this._fill;
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "fontFamily", {
            get: function () {
                return this._fontFamily;
            },
            set: function (fontFamily) {
                if (this._fontFamily !== fontFamily) {
                    this._fontFamily = fontFamily;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontSize", {
            get: function () {
                return this._fontSize;
            },
            set: function (fontSize) {
                if (this._fontSize !== fontSize) {
                    this._fontSize = fontSize;
                    this._fontSizeFitted = fontSize;
                    this._lineHeightFitted = this._lineHeight;
                    this._isFontFitted = false;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontSizeFitted", {
            get: function () {
                return this._fontSizeFitted;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "isFontFitted", {
            get: function () {
                return this._isFontFitted;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontStyle", {
            get: function () {
                return this._fontStyle;
            },
            set: function (fontStyle) {
                if (this._fontStyle !== fontStyle) {
                    this._fontStyle = fontStyle;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontVariant", {
            get: function () {
                return this._fontVariant;
            },
            set: function (fontVariant) {
                if (this._fontVariant !== fontVariant) {
                    this._fontVariant = fontVariant;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fontWeight", {
            get: function () {
                return this._fontWeight;
            },
            set: function (fontWeight) {
                if (this._fontWeight !== fontWeight) {
                    this._fontWeight = fontWeight;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.update = function () {
            if (this._fontIdId !== this._id) {
                this._fontIdId = this._id;
                var fontIdFontSize = this._fitting ? this._fontSizeFitted : this._fontSize;
                this._fontIdFontSize = fontIdFontSize;
                this._fontId = this.toFontId(fontIdFontSize);
            }
        };
        DDynamicTextStyle.prototype.toFontId = function (fontSize) {
            return "".concat(this._fontStyle, " ").concat(this._fontVariant, " ").concat(this._fontWeight, " ").concat(fontSize, "px ").concat(this._fontFamily);
        };
        Object.defineProperty(DDynamicTextStyle.prototype, "clipping", {
            get: function () {
                return this._clipping;
            },
            set: function (clipping) {
                if (this._clipping !== clipping) {
                    this._clipping = clipping;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "fitting", {
            get: function () {
                return this._fitting;
            },
            set: function (fitting) {
                if (this._fitting !== fitting) {
                    this._fitting = fitting;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "wordWrap", {
            get: function () {
                return this._wordWrap;
            },
            set: function (wordWrap) {
                if (this._wordWrap !== wordWrap) {
                    this._wordWrap = wordWrap;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "lineHeight", {
            get: function () {
                return this._lineHeight;
            },
            set: function (lineHeight) {
                if (this._lineHeight !== lineHeight) {
                    this._lineHeight = lineHeight;
                    this._fontSizeFitted = this._fontSize;
                    this._lineHeightFitted = lineHeight;
                    this._isFontFitted = false;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicTextStyle.prototype, "lineHeightFitted", {
            get: function () {
                return this._lineHeightFitted;
            },
            set: function (lineHeightFitted) {
                if (this._lineHeightFitted !== lineHeightFitted) {
                    this._lineHeightFitted = lineHeightFitted;
                    this.onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDynamicTextStyle.prototype.fit = function (fontSize, lineHeight) {
            var isChanged = false;
            if (fontSize < this._fontSizeFitted) {
                this._fontSizeFitted = fontSize;
                isChanged = true;
            }
            if (this._lineHeightFitted !== lineHeight) {
                this._lineHeightFitted = lineHeight;
                isChanged = true;
            }
            if (this._isFontFitted !== true) {
                this._isFontFitted = true;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return isChanged;
        };
        DDynamicTextStyle.prototype.unfit = function () {
            var isChanged = false;
            if (this._isFontFitted !== false) {
                this._isFontFitted = false;
                isChanged = true;
            }
            if (this._fontSizeFitted !== this._fontSize) {
                this._fontSizeFitted = this._fontSize;
                isChanged = true;
            }
            if (this._lineHeightFitted !== this._lineHeight) {
                this._lineHeightFitted = this._lineHeight;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return isChanged;
        };
        return DDynamicTextStyle;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilFont = /** @class */ (function () {
        function UtilFont() {
        }
        UtilFont.measure = function (font) {
            var results = this._results;
            if (results == null) {
                results = new Map();
                this._results = results;
            }
            var result = results.get(font);
            if (result != null) {
                return result;
            }
            this.setup(font);
            var blockRect = this._block.getBoundingClientRect();
            var blockRectTop = blockRect.top;
            var spanRect = this._span.getBoundingClientRect();
            var ascent = blockRectTop - spanRect.top;
            var descent = spanRect.bottom - blockRectTop;
            result = {
                ascent: ascent,
                descent: descent
            };
            results.set(font, result);
            return result;
        };
        UtilFont.toSize = function (font) {
            this.setup(font);
            return parseFloat(window.getComputedStyle(this._span).fontSize);
        };
        UtilFont.setup = function (font) {
            var span = this._span;
            if (span == null) {
                span = document.createElement("span");
                span.innerText = "|q";
                span.style.border = "none";
                span.style.margin = "0px";
                this._span = span;
            }
            var block = this._block;
            if (block == null) {
                block = document.createElement("div");
                block.style.display = "inline-block";
                block.style.width = "0px";
                block.style.height = "0px";
                block.style.border = "none";
                block.style.margin = "0px";
                block.style.verticalAlign = "baseline";
                this._block = block;
            }
            var div = this._div;
            if (div == null) {
                div = document.createElement("div");
                div.style.position = "absolute";
                div.style.padding = "0px";
                div.style.margin = "0px";
                div.style.visibility = "hidden";
                div.appendChild(span);
                div.appendChild(block);
                document.body.appendChild(div);
                this._div = div;
            }
            span.style.font = font;
        };
        return UtilFont;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDynamicText = /** @class */ (function (_super) {
        __extends(DDynamicText, _super);
        function DDynamicText(text, options) {
            var _this = _super.call(this, new DDynamicTextGeometry(), new pixi_js.MeshMaterial(pixi_js.Texture.EMPTY)) || this;
            _this._style = new DDynamicTextStyle(options, function () {
                _this._isDirty = true;
                _this._isGeometryDirty = true;
                _this._atlas = null;
                _this.update_();
            });
            _this._text = text;
            _this._textApproved = "";
            _this._isDirty = true;
            _this._isGeometryDirty = true;
            _this._atlas = null;
            _this._atlasRevisionUpdated = 0;
            _this._width = 0;
            _this._height = 0;
            _this._modifier = {
                clipping: false,
                fitting: false,
                wordWrap: DDynamicTextStyleWordWrap.NONE,
                width: 0,
                height: 0,
                lineHeight: 0,
                delta: {
                    width: 0,
                    height: 0
                }
            };
            _this.update_();
            return _this;
        }
        DDynamicText.prototype.update_ = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var style = this._style;
                if (this._isDirty) {
                    this._isDirty = false;
                    var text = this._text;
                    var textApproved = this._textApproved;
                    this._textApproved = text;
                    var fontId = style.fontId;
                    var fontIdApproved = style.fontIdApproved;
                    var fontIdFontSize = style.fontIdFontSize;
                    var fill = style.fill;
                    var fillApproved = style.fillApproved;
                    style.approve();
                    var atlases = layer.getDynamicFontAtlases();
                    if (text !== textApproved || fontId !== fontIdApproved || fill !== fillApproved) {
                        atlases.add(fontId, fontIdFontSize, fill, text);
                        atlases.remove(fontIdApproved, fillApproved, textApproved);
                    }
                }
            }
        };
        Object.defineProperty(DDynamicText.prototype, "text", {
            get: function () {
                return this._text;
            },
            set: function (text) {
                if (this._text !== text) {
                    this._text = text;
                    if (!this._style.unfit()) {
                        this._isDirty = true;
                        this._isGeometryDirty = true;
                        this.update_();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "width", {
            // @ts-ignore
            get: function () {
                this.update();
                return Math.abs(this.scale.x) * this.geometry.width;
            },
            set: function (width) {
                this.update();
                var geometryWidth = this.geometry.width;
                if (+1e-4 < geometryWidth) {
                    var newScale = width / geometryWidth;
                    this.scale.x = 0 <= this.scale.x ? +newScale : -newScale;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "height", {
            // @ts-ignore
            get: function () {
                this.update();
                return Math.abs(this.scale.y) * this.geometry.height;
            },
            set: function (height) {
                this.update();
                var geometryHeight = this.geometry.height;
                if (+1e-4 < geometryHeight) {
                    var newScale = height / geometryHeight;
                    this.scale.y = 0 <= this.scale.y ? +newScale : -newScale;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "clipped", {
            get: function () {
                return this.geometry.clipped;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDynamicText.prototype, "style", {
            get: function () {
                return this._style;
            },
            enumerable: false,
            configurable: true
        });
        DDynamicText.prototype.update = function () {
            var _this = this;
            this.update_();
            var style = this._style;
            var atlas = this._atlas;
            if (atlas == null) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    atlas = layer.getDynamicFontAtlases().get(style.fontId, style.fill);
                    if (atlas != null) {
                        this._atlasRevisionUpdated = atlas.getRevisionUpdate();
                        this._atlas = atlas;
                        this.texture = atlas.texture;
                        this._isGeometryDirty = true;
                    }
                }
            }
            else {
                var revisionUpdate = atlas.getRevisionUpdate();
                if (revisionUpdate !== this._atlasRevisionUpdated) {
                    this._atlasRevisionUpdated = revisionUpdate;
                    this._isGeometryDirty = true;
                }
            }
            var modifier = this._modifier;
            if (this.updateClipping(style, modifier)) {
                this._isGeometryDirty = true;
            }
            if (this._isGeometryDirty) {
                this._isGeometryDirty = false;
                var geometry = this.geometry;
                geometry.update(this._text, atlas, modifier);
                if (modifier.fitting && !style.isFontFitted && geometry.scaled) {
                    var oldScale = geometry.scale;
                    var oldFontSize = style.fontSize;
                    var newFontId = style.toFontId(Math.ceil(oldFontSize * oldScale * 1000) / 1000);
                    var newFontSize = UtilFont.toSize(newFontId);
                    var newScale = newFontSize / oldFontSize;
                    var newLineHeight = style.lineHeight * newScale;
                    if (style.fit(newFontSize, newLineHeight)) {
                        setTimeout(function () {
                            DApplications.update(_this);
                        }, 0);
                    }
                }
            }
        };
        DDynamicText.prototype.updateClipping = function (style, modifier) {
            var isChanged = false;
            var styleClipping = style.clipping;
            if (modifier.clipping !== styleClipping) {
                modifier.clipping = styleClipping;
                isChanged = true;
            }
            var styleFitting = style.fitting;
            if (modifier.fitting !== styleFitting) {
                modifier.fitting = styleFitting;
                isChanged = true;
            }
            var styleWordWrap = style.wordWrap;
            if (modifier.wordWrap !== styleWordWrap) {
                modifier.wordWrap = styleWordWrap;
                isChanged = true;
            }
            var styleLineHeight = styleFitting ? style.lineHeightFitted : style.lineHeight;
            if (modifier.lineHeight !== styleLineHeight) {
                modifier.lineHeight = styleLineHeight;
                isChanged = true;
            }
            if (styleClipping || styleFitting || styleWordWrap) {
                var parent_1 = this.parent;
                if (parent_1 instanceof DBase) {
                    var width = parent_1.width -
                        parent_1.padding.getLeft() -
                        parent_1.padding.getRight() -
                        modifier.delta.width;
                    if (modifier.width !== width) {
                        modifier.width = width;
                        isChanged = true;
                    }
                    var height = parent_1.height -
                        parent_1.padding.getTop() -
                        parent_1.padding.getBottom() -
                        modifier.delta.height;
                    if (modifier.height !== height) {
                        modifier.height = height;
                        isChanged = true;
                    }
                }
            }
            return isChanged;
        };
        DDynamicText.prototype.setClippingDelta = function (width, height) {
            var delta = this._modifier.delta;
            delta.width = width;
            delta.height = height;
        };
        DDynamicText.prototype._calculateBounds = function () {
            this.update();
            _super.prototype._calculateBounds.call(this);
        };
        DDynamicText.prototype._render = function (renderer) {
            this.update();
            _super.prototype._render.call(this, renderer);
        };
        return DDynamicText;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toTextStyle = function (theme, options, state) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var style = (_a = options === null || options === void 0 ? void 0 : options.text) === null || _a === void 0 ? void 0 : _a.style;
        if (style != null) {
            var fill = (_b = style.fill) !== null && _b !== void 0 ? _b : theme.getColor(state);
            var fontSize = (_c = style.fontSize) !== null && _c !== void 0 ? _c : theme.getFontSize();
            var fontFamily = (_d = style.fontFamily) !== null && _d !== void 0 ? _d : theme.getFontFamilly();
            var fontWeight = (_e = style.fontWeight) !== null && _e !== void 0 ? _e : theme.getFontWeight();
            var fontStyle = (_f = style.fontStyle) !== null && _f !== void 0 ? _f : theme.getFontStyle();
            var fontVariant = (_g = style.fontVariant) !== null && _g !== void 0 ? _g : theme.getFontVariant();
            var clipping = (_h = style.clipping) !== null && _h !== void 0 ? _h : theme.getTextStyleClipping();
            var fitting = (_j = style.fitting) !== null && _j !== void 0 ? _j : theme.getTextStyleFitting();
            var wordWrap = (_k = style.wordWrap) !== null && _k !== void 0 ? _k : theme.getTextStyleWordWrap();
            var lineHeight = (_l = style.lineHeight) !== null && _l !== void 0 ? _l : theme.getLineHeight();
            return {
                fill: fill,
                fontSize: fontSize,
                fontFamily: fontFamily,
                fontWeight: fontWeight,
                fontStyle: fontStyle,
                fontVariant: fontVariant,
                clipping: clipping,
                fitting: fitting,
                wordWrap: wordWrap,
                lineHeight: lineHeight
            };
        }
        return {
            fill: theme.getColor(state),
            fontSize: theme.getFontSize(),
            fontFamily: theme.getFontFamilly(),
            fontWeight: theme.getFontWeight(),
            fontStyle: theme.getFontStyle(),
            fontVariant: theme.getFontVariant(),
            clipping: theme.getTextStyleClipping(),
            fitting: theme.getTextStyleFitting(),
            wordWrap: theme.getTextStyleWordWrap(),
            lineHeight: theme.getLineHeight()
        };
    };
    var toTextAlign = function (theme, options) {
        var _a, _b, _c;
        var align = (_a = options === null || options === void 0 ? void 0 : options.text) === null || _a === void 0 ? void 0 : _a.align;
        return {
            vertical: toEnum((_b = align === null || align === void 0 ? void 0 : align.vertical) !== null && _b !== void 0 ? _b : theme.getTextAlignVertical(), DAlignVertical),
            horizontal: toEnum((_c = align === null || align === void 0 ? void 0 : align.horizontal) !== null && _c !== void 0 ? _c : theme.getTextAlignHorizontal(), DAlignHorizontal)
        };
    };
    /**
     * A base class for UI classes with a text support.
     * See {@link DTextBaseEvents} for event defaults.
     */
    var DTextBase = /** @class */ (function (_super) {
        __extends(DTextBase, _super);
        function DTextBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTextBase.prototype.init = function (options) {
            var _a, _b, _c, _d;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._textValue = (_b = (_a = options === null || options === void 0 ? void 0 : options.text) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : theme.newTextValue();
            this._textValueComputed = this.computeTextValue();
            var text = options === null || options === void 0 ? void 0 : options.text;
            this._textColor = text === null || text === void 0 ? void 0 : text.color;
            this._textAlpha = text === null || text === void 0 ? void 0 : text.alpha;
            this._textStyle = toTextStyle(theme, options, this.state);
            this._textAlign = toTextAlign(theme, options);
            this._textFormatter = (_c = text === null || text === void 0 ? void 0 : text.formatter) !== null && _c !== void 0 ? _c : theme.getTextFormatter();
            this._isTextVisible = true;
            this._isOverflowMaskEnabled = (_d = options === null || options === void 0 ? void 0 : options.mask) !== null && _d !== void 0 ? _d : theme.isOverflowMaskEnabled();
            this.onTextChange();
            this.createOrUpdateText();
        };
        Object.defineProperty(DTextBase.prototype, "text", {
            get: function () {
                return this._textValue;
            },
            set: function (text) {
                if (this._textValue !== text) {
                    this._textValue = text;
                    this.updateTextValue();
                }
            },
            enumerable: false,
            configurable: true
        });
        DTextBase.prototype.onTextChange = function () {
            // DO NOTHING
        };
        DTextBase.prototype.computeTextValue = function () {
            var textValue = this._textValue;
            if (textValue !== undefined) {
                if (isFunction(textValue)) {
                    var result = textValue(this.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return textValue;
                }
            }
            return this.theme.getTextValue(this.state);
        };
        DTextBase.prototype.createOrUpdateText = function () {
            var textValueComputed = this._textValueComputed;
            if (textValueComputed !== undefined) {
                var formatted = this._textFormatter(textValueComputed, this);
                var text = this._text;
                if (text == null) {
                    if (0 < formatted.length) {
                        var newText = this.createText(formatted);
                        newText.visible = this._isTextVisible;
                        this._text = newText;
                        this.addChild(newText);
                        this.updateTextPosition(newText);
                        var overflowMask = this.getOverflowMask();
                        if (overflowMask) {
                            newText.mask = overflowMask;
                        }
                        this.toDirty();
                        DApplications.update(this);
                    }
                }
                else {
                    text.text = formatted;
                    this.toDirty();
                    DApplications.update(this);
                }
            }
        };
        DTextBase.prototype.createText = function (formatted) {
            return new DDynamicText(formatted, this._textStyle);
        };
        DTextBase.prototype.getOverflowMask = function () {
            if (this._isOverflowMaskEnabled) {
                if (this._overflowMask == null) {
                    this._overflowMask = new DBaseOverflowMaskSimple(this);
                    this._reflowable.add(this._overflowMask);
                    this.toDirty();
                }
                return this._overflowMask;
            }
            return null;
        };
        DTextBase.prototype.updateTextPosition = function (text) {
            var align = this._textAlign;
            var padding = this._padding;
            var auto = this._auto;
            var textX = 0;
            var pleft = padding.getLeft();
            var alignHorizontal = align.horizontal;
            if (auto.width.isOn || alignHorizontal === DAlignHorizontal.LEFT) {
                textX = pleft;
            }
            else {
                var width = this.width;
                var textWidth = text.width;
                var pright = padding.getRight();
                if (alignHorizontal === DAlignHorizontal.CENTER) {
                    textX = pleft + (width - pleft - pright - textWidth) * 0.5;
                }
                else {
                    textX = width - textWidth - pright;
                }
            }
            var textY = 0;
            var ptop = padding.getTop();
            var alignVertical = align.vertical;
            if (auto.height.isOn || alignVertical === DAlignVertical.TOP) {
                textY = ptop;
            }
            else {
                var height = this.height;
                var textHeight = text.height;
                var pbottom = padding.getBottom();
                if (alignVertical === DAlignVertical.MIDDLE) {
                    textY = ptop + (height - ptop - pbottom - textHeight) * 0.5;
                }
                else {
                    textY = height - textHeight - pbottom;
                }
            }
            text.position.set(textX, textY);
        };
        DTextBase.prototype.getTextColor = function (theme, state) {
            var color = this._textColor;
            if (color !== undefined) {
                if (isFunction(color)) {
                    var result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return theme.getColor(state);
        };
        DTextBase.prototype.getTextAlpha = function (theme, state) {
            var alpha = this._textAlpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    var result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return theme.getAlpha(state);
        };
        DTextBase.prototype.updateTextColor = function (text) {
            var theme = this.theme;
            var state = this.state;
            text.style.fill = this.getTextColor(theme, state);
            text.alpha = this.getTextAlpha(theme, state);
        };
        DTextBase.prototype.updateTextValue = function () {
            var newTextValueComputed = this.computeTextValue();
            if (this._textValueComputed !== newTextValueComputed) {
                this._textValueComputed = newTextValueComputed;
                this.onTextChange();
                this.createOrUpdateText();
            }
        };
        DTextBase.prototype.updateText = function () {
            var text = this._text;
            if (text) {
                this.updateTextValue();
                this.updateTextPosition(text);
                this.updateTextColor(text);
            }
        };
        DTextBase.prototype.showText = function () {
            var text = this._text;
            if (text) {
                text.visible = true;
            }
            this._isTextVisible = true;
        };
        DTextBase.prototype.hideText = function () {
            var text = this._text;
            if (text) {
                text.visible = false;
            }
            this._isTextVisible = false;
        };
        DTextBase.prototype.onReflow = function () {
            _super.prototype.onReflow.call(this);
            this.updateText();
        };
        DTextBase.prototype.isRefitable = function (target) {
            return _super.prototype.isRefitable.call(this, target) || (target != null && target === this._text);
        };
        DTextBase.prototype.applyTitle = function () {
            var text = this._text;
            if (this._title.length <= 0 && text && "clipped" in text && text.clipped) {
                var layer = DApplications.getLayer(this);
                if (layer) {
                    layer.view.title = text.text;
                }
            }
            else {
                _super.prototype.applyTitle.call(this);
            }
        };
        DTextBase.prototype.getType = function () {
            return "DTextBase";
        };
        DTextBase.prototype.destroy = function () {
            // Text
            var text = this._text;
            if (text) {
                this._text = null;
                text.destroy();
            }
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DTextBase;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hasSecondaryImageSource = function (theme) {
        return !!theme.getSecondaryImageSource;
    };
    var hasTertiaryImageSource = function (theme) {
        return !!theme.getTertiaryImageSource;
    };
    /**
     * A base class for UI classes with an image support.
     * See {@link DImageBaseEvents} for event details.
     */
    var DImageBase = /** @class */ (function (_super) {
        __extends(DImageBase, _super);
        function DImageBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImageBase.prototype.init = function (options) {
            this._images = this.newImages(this.theme, options);
            _super.prototype.init.call(this, options);
        };
        DImageBase.prototype.newImages = function (theme, options) {
            var images = [];
            images.push(this.newImage(theme, this.toImageOptions(theme, options === null || options === void 0 ? void 0 : options.image)));
            if (hasSecondaryImageSource(theme)) {
                images.push(this.newImage(new DImageBaseThemeWrapperSecondary(theme)));
            }
            if (hasTertiaryImageSource(theme)) {
                images.push(this.newImage(new DImageBaseThemeWrapperTertiary(theme)));
            }
            return images;
        };
        DImageBase.prototype.toImageOptions = function (theme, options) {
            return options;
        };
        DImageBase.prototype.newImage = function (theme, options) {
            return new DImagePiece(this, theme, this._textAlign, options);
        };
        Object.defineProperty(DImageBase.prototype, "image", {
            get: function () {
                return this._images[0].source;
            },
            set: function (imageSource) {
                var image = this._images[0];
                image.source = imageSource;
                image.updateSource();
            },
            enumerable: false,
            configurable: true
        });
        DImageBase.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            var images = this._images;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                images[i].onStateChange(newState, oldState);
            }
        };
        DImageBase.prototype.updateText = function () {
            this.updateTextValue();
            this.updateTextAndImage();
        };
        DImageBase.prototype.updateTextAndImage = function () {
            var _a;
            var images = this._images;
            var layouter = ((_a = DImageBase.LAYOUTER) !== null && _a !== void 0 ? _a : (DImageBase.LAYOUTER = new DImagePieceLayouter()));
            for (var i = 0, imax = images.length; i < imax; ++i) {
                var image = images[i];
                image.updateSource();
                image.updateTint();
                image.updateBound();
                layouter.add(image);
            }
            var text = this._text;
            if (text != null) {
                this.updateTextColor(text);
                layouter.set(text);
            }
            else {
                layouter.set(null);
            }
            var auto = this._auto;
            layouter.execute(this._padding, this._textAlign, auto.width.isOn ? null : this.width, auto.height.isOn ? null : this.height);
            layouter.clear();
        };
        DImageBase.prototype.isRefitable = function (target) {
            if (_super.prototype.isRefitable.call(this, target)) {
                return true;
            }
            var images = this._images;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                if (images[i].isRefitable(target)) {
                    return true;
                }
            }
            return false;
        };
        DImageBase.prototype.getType = function () {
            return "DImageBase";
        };
        DImageBase.prototype.destroy = function () {
            var images = this._images;
            for (var i = 0, imax = images.length; i < imax; ++i) {
                images[i].destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DImageBase;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class for button classes.
     * See {@link DButtonBaseEvents} for event details.
     */
    var DButtonBase = /** @class */ (function (_super) {
        __extends(DButtonBase, _super);
        function DButtonBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonBase.prototype.init = function (options) {
            var _this = this;
            var _a, _b;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._isToggle = (_a = options === null || options === void 0 ? void 0 : options.toggle) !== null && _a !== void 0 ? _a : theme.isToggle();
            this._when = toEnum((_b = options === null || options === void 0 ? void 0 : options.when) !== null && _b !== void 0 ? _b : theme.getWhen(), DButtonBaseWhen);
            // Event handlers
            this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
            this.initOnPress();
            // Group
            var group = options === null || options === void 0 ? void 0 : options.group;
            if (group) {
                group.add(this);
            }
        };
        DButtonBase.prototype.onShortcut = function (e) {
            if (this.state.isActionable) {
                this.activate(e);
            }
            _super.prototype.onShortcut.call(this, e);
        };
        Object.defineProperty(DButtonBase.prototype, "isToggle", {
            get: function () {
                return !!this._isToggle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonBase.prototype, "isGrouped", {
            get: function () {
                return !!this._isGrouped;
            },
            set: function (isGrouped) {
                this._isGrouped = isGrouped;
            },
            enumerable: false,
            configurable: true
        });
        DButtonBase.prototype.initOnPress = function () {
            var _this = this;
            var interactionManager = null;
            var onUp = function () {
                _this.state.isPressed = false;
                if (interactionManager != null) {
                    interactionManager.off(UtilPointerEvent.up, onUp);
                    interactionManager.off(UtilPointerEvent.upoutside, onUp);
                    interactionManager.off(UtilPointerEvent.cancel, onUp);
                    interactionManager = null;
                }
            };
            this.on(UtilPointerEvent.down, function () {
                if (_this.state.isActionable) {
                    _this.state.isPressed = true;
                    var layer = DApplications.getLayer(_this);
                    if (layer) {
                        interactionManager = layer.renderer.plugins.interaction;
                        interactionManager.on(UtilPointerEvent.up, onUp);
                        interactionManager.on(UtilPointerEvent.upoutside, onUp);
                        interactionManager.on(UtilPointerEvent.cancel, onUp);
                    }
                }
            });
        };
        DButtonBase.prototype.getType = function () {
            return "DButton";
        };
        DButtonBase.prototype.onClick = function (e) {
            if (this._when === DButtonBaseWhen.CLICKED && this.state.isActionable) {
                this.activate(e);
            }
        };
        DButtonBase.prototype.onDblClick = function (e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED && this.state.isActionable) {
                this.activate(e);
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DButtonBase.prototype.activate = function (e) {
            if (this._isToggle) {
                if (this._isGrouped) {
                    if (!this.state.isActive) {
                        this.onToggleStart(e);
                        this.onToggleEnd(e);
                    }
                }
                else {
                    this.onToggleStart(e);
                    this.onToggleEnd(e);
                }
            }
            else {
                this.onActivate(e);
            }
        };
        DButtonBase.prototype.onActivate = function (e) {
            this.emit("active", this);
        };
        DButtonBase.prototype.onInactivate = function (e) {
            this.emit("inactive", this);
        };
        DButtonBase.prototype.toggle = function () {
            if (this.state.isActionable) {
                if (this._isToggle) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
            }
        };
        DButtonBase.prototype.onToggleStart = function (e) {
            this.state.isActive = !this.state.isActive;
        };
        DButtonBase.prototype.onToggleEnd = function (e) {
            if (this.state.isActive) {
                this.onActivate(e);
            }
            else {
                this.onInactivate(e);
            }
        };
        DButtonBase.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                if (this._isToggle) {
                    this.onToggleStart(e);
                }
                else {
                    this.state.isPressed = true;
                }
            }
        };
        DButtonBase.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this._isToggle) {
                    this.onToggleEnd(e);
                }
                else {
                    if (this.state.isPressed) {
                        this.onActivate(e);
                    }
                    this.state.isPressed = false;
                }
            }
        };
        DButtonBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DButtonBase.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DButtonBase.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (newState.isPressed) {
                if (!oldState.isPressed) {
                    this.onPress();
                }
            }
            else if (oldState.isPressed) {
                this.onUnpress();
            }
        };
        DButtonBase.prototype.onPress = function () {
            this.emit("press", this);
        };
        DButtonBase.prototype.onUnpress = function () {
            this.emit("unpress", this);
        };
        DButtonBase.prototype.destroy = function () {
            var _a, _b;
            (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.group) === null || _b === void 0 ? void 0 : _b.remove(this);
            _super.prototype.destroy.call(this);
        };
        return DButtonBase;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A button class.
     */
    var DButton = /** @class */ (function (_super) {
        __extends(DButton, _super);
        function DButton() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButton.prototype.getType = function () {
            return "DButton";
        };
        return DButton;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonPrimary = /** @class */ (function (_super) {
        __extends(DButtonPrimary, _super);
        function DButtonPrimary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonPrimary.prototype.getType = function () {
            return "DButtonPrimary";
        };
        return DButtonPrimary;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLayoutHorizontal = /** @class */ (function (_super) {
        __extends(DLayoutHorizontal, _super);
        function DLayoutHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DLayoutHorizontal.prototype.getType = function () {
            return "DLayoutHorizontal";
        };
        return DLayoutHorizontal;
    }(DLayout));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredFooter = /** @class */ (function (_super) {
        __extends(DDialogLayeredFooter, _super);
        function DDialogLayeredFooter(parent, options) {
            var _this = _super.call(this, options) || this;
            _this._parent = parent;
            var buttonOk = _this.buttonOk;
            var buttonCancel = _this.buttonCancel;
            if (buttonOk != null || buttonCancel != null) {
                _this.addChild(_this.newButtonSpace());
                if (buttonCancel) {
                    _this.addChild(buttonCancel);
                }
                if (buttonOk) {
                    _this.addChild(buttonOk);
                }
                _this.addChild(_this.newButtonSpace());
            }
            return _this;
        }
        Object.defineProperty(DDialogLayeredFooter.prototype, "buttonCancel", {
            get: function () {
                var result = this._buttonCancel;
                if (result === undefined) {
                    result = this.newButtonCancel();
                    this._buttonCancel = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredFooter.prototype.newButtonCancel = function () {
            var _this = this;
            var _a, _b;
            var cancel = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.cancel;
            if (cancel === undefined) {
                cancel = this.theme.getButtonCancel();
            }
            if (cancel != null) {
                return new DButtonPrimary({
                    text: {
                        value: cancel
                    },
                    on: {
                        active: function () {
                            _this._parent.cancel();
                        }
                    }
                });
            }
            return null;
        };
        Object.defineProperty(DDialogLayeredFooter.prototype, "buttonOk", {
            get: function () {
                var result = this._buttonOk;
                if (result === undefined) {
                    result = this.newButtonOk();
                    this._buttonOk = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredFooter.prototype.newButtonOk = function () {
            var _this = this;
            var _a, _b;
            var ok = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.ok;
            if (ok === undefined) {
                ok = this.theme.getButtonOk();
            }
            if (ok != null) {
                if (this.buttonCancel != null) {
                    return new DButton({
                        text: {
                            value: ok
                        },
                        on: {
                            active: function () {
                                _this._parent.ok();
                            }
                        }
                    });
                }
                else {
                    return new DButtonPrimary({
                        text: {
                            value: ok
                        },
                        on: {
                            active: function () {
                                _this._parent.ok();
                            }
                        }
                    });
                }
            }
            return null;
        };
        DDialogLayeredFooter.prototype.newButtonSpace = function () {
            return new DLayoutSpace({
                weight: 1
            });
        };
        DDialogLayeredFooter.prototype.getType = function () {
            return "DDialogLayeredFooter";
        };
        return DDialogLayeredFooter;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonAmbient = /** @class */ (function (_super) {
        __extends(DButtonAmbient, _super);
        function DButtonAmbient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonAmbient.prototype.getType = function () {
            return "DButtonAmbient";
        };
        return DButtonAmbient;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredHeaderButtonClose = /** @class */ (function (_super) {
        __extends(DDialogLayeredHeaderButtonClose, _super);
        function DDialogLayeredHeaderButtonClose() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogLayeredHeaderButtonClose.prototype.getType = function () {
            return "DDialogLayeredHeaderButtonClose";
        };
        return DDialogLayeredHeaderButtonClose;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredHeaderSeparator = /** @class */ (function (_super) {
        __extends(DDialogLayeredHeaderSeparator, _super);
        function DDialogLayeredHeaderSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogLayeredHeaderSeparator.prototype.getType = function () {
            return "DDialogLayeredHeaderSeparator";
        };
        return DDialogLayeredHeaderSeparator;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogLayeredHeader = /** @class */ (function (_super) {
        __extends(DDialogLayeredHeader, _super);
        function DDialogLayeredHeader(parent, options) {
            var _this = _super.call(this, options) || this;
            _this._parent = parent;
            var separator = _this.separator;
            if (separator) {
                _this.addChild(separator);
            }
            var buttonClose = _this.buttonClose;
            if (buttonClose) {
                _this.addChild(buttonClose);
                buttonClose.on("active", function () {
                    _this._parent.cancel();
                });
            }
            return _this;
        }
        Object.defineProperty(DDialogLayeredHeader.prototype, "buttonClose", {
            get: function () {
                var result = this._buttonClose;
                if (result === undefined) {
                    result = this.newButtonClose();
                    this._buttonClose = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredHeader.prototype.newButtonClose = function () {
            var _a, _b;
            if (((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.close) !== false) {
                return new DDialogLayeredHeaderButtonClose();
            }
            return null;
        };
        Object.defineProperty(DDialogLayeredHeader.prototype, "separator", {
            get: function () {
                var result = this._separator;
                if (result === undefined) {
                    result = this.newSeparator();
                    this._separator = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayeredHeader.prototype.newSeparator = function () {
            var _a;
            if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.separator) !== false) {
                return new DDialogLayeredHeaderSeparator();
            }
            return null;
        };
        DDialogLayeredHeader.prototype.getType = function () {
            return "DDialogLayeredHeader";
        };
        return DDialogLayeredHeader;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog with a header, a content and a footer.
     */
    var DDialogLayered = /** @class */ (function (_super) {
        __extends(DDialogLayered, _super);
        function DDialogLayered() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogLayered.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.addChild(this.layout);
        };
        Object.defineProperty(DDialogLayered.prototype, "layout", {
            get: function () {
                var result = this._layout;
                if (result == null) {
                    result = this.newLayout();
                    this._layout = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayered.prototype.newLayout = function () {
            return new DLayoutVertical(this.toLayoutOptions(this.theme, this._options));
        };
        DDialogLayered.prototype.toLayoutOptions = function (theme, options) {
            var _a, _b;
            var result = (_b = (_a = options === null || options === void 0 ? void 0 : options.layout) !== null && _a !== void 0 ? _a : theme.getLayout()) !== null && _b !== void 0 ? _b : this.newLayoutOptions(theme, options);
            if (result.children === undefined) {
                result.children = this.newLayoutChildren(theme, options);
            }
            return result;
        };
        DDialogLayered.prototype.newLayoutOptions = function (theme, options) {
            return {
                width: "padding",
                height: "auto",
                margin: 0
            };
        };
        DDialogLayered.prototype.newLayoutChildren = function (theme, options) {
            return [this.header, this.content, this.footer];
        };
        Object.defineProperty(DDialogLayered.prototype, "header", {
            get: function () {
                var result = this._header;
                if (result === undefined) {
                    result = this.newHeader();
                    this._header = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayered.prototype.newHeader = function () {
            var options = this.toHeaderOptions(this.theme, this._options);
            if (options !== null) {
                return new DDialogLayeredHeader(this, options);
            }
            return null;
        };
        DDialogLayered.prototype.toHeaderOptions = function (theme, options) {
            if (options) {
                var result = options.header;
                if (result !== undefined) {
                    return result;
                }
            }
            return theme.getHeader();
        };
        Object.defineProperty(DDialogLayered.prototype, "content", {
            get: function () {
                var result = this._content;
                if (result == null) {
                    result = this.newContent();
                    this._content = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayered.prototype.newContent = function () {
            return new DDialogLayeredContent(this.toContentOptions(this.theme, this._options));
        };
        DDialogLayered.prototype.toContentOptions = function (theme, options) {
            var _a, _b;
            var result = (_b = (_a = options === null || options === void 0 ? void 0 : options.content) !== null && _a !== void 0 ? _a : theme.getContent()) !== null && _b !== void 0 ? _b : {};
            if (result.children === undefined) {
                result.children = this.newContentChildren(theme, options);
            }
            return result;
        };
        DDialogLayered.prototype.newContentChildren = function (theme, options) {
            return [];
        };
        Object.defineProperty(DDialogLayered.prototype, "footer", {
            get: function () {
                var result = this._footer;
                if (result === undefined) {
                    result = this.newFooter();
                    this._footer = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogLayered.prototype.newFooter = function () {
            var options = this.toFooterOptions(this.theme, this._options);
            if (options !== null) {
                return new DDialogLayeredFooter(this, options);
            }
            return null;
        };
        DDialogLayered.prototype.toFooterOptions = function (theme, options) {
            if (options) {
                var result = options.footer;
                if (result !== undefined) {
                    return result;
                }
            }
            return theme.getFooter();
        };
        DDialogLayered.prototype.findFirstFocusable = function (focusController) {
            return focusController.find(this.content, false, true, true);
        };
        DDialogLayered.prototype.ok = function () {
            this.onOk(this.getResolvedValue());
        };
        DDialogLayered.prototype.onOk = function (value) {
            this.doResolve(value);
            this.emit("ok", value, this);
        };
        DDialogLayered.prototype.cancel = function () {
            this.onCancel(this.getRejectReason());
        };
        DDialogLayered.prototype.onCancel = function (reason) {
            this.doReject(reason);
            this.emit("cancel", reason, this);
        };
        DDialogLayered.prototype.getRejectReason = function () {
            return undefined;
        };
        DDialogLayered.prototype.getType = function () {
            return "DDialogLayered";
        };
        return DDialogLayered;
    }(DDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInput = /** @class */ (function (_super) {
        __extends(DDialogInput, _super);
        function DDialogInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInput.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.inputLayout);
            return result;
        };
        DDialogInput.prototype.toInputMargin = function (theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.input) === null || _a === void 0 ? void 0 : _a.margin) !== null && _b !== void 0 ? _b : theme.getInputMargin();
        };
        Object.defineProperty(DDialogInput.prototype, "inputLayout", {
            get: function () {
                var result = this._inputLayout;
                if (result == null) {
                    result = this.newInputLayout();
                    this._inputLayout = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogInput.prototype.newInputLayout = function () {
            var margin = this.toInputMargin(this.theme, this._options);
            return new DLayoutHorizontal({
                width: "padding",
                height: "auto",
                margin: 0,
                children: [
                    new DLayoutSpace({ width: margin }),
                    this.input,
                    new DLayoutSpace({ width: margin })
                ]
            });
        };
        Object.defineProperty(DDialogInput.prototype, "input", {
            get: function () {
                var result = this._input;
                if (result == null) {
                    var options = this._options;
                    result = this.newInput(options === null || options === void 0 ? void 0 : options.input);
                    this._input = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogInput.prototype, "value", {
            get: function () {
                return this.input.value;
            },
            set: function (value) {
                this.input.value = value;
            },
            enumerable: false,
            configurable: true
        });
        DDialogInput.prototype.getResolvedValue = function () {
            return this.input.value;
        };
        DDialogInput.prototype.getType = function () {
            return "DDialogInput";
        };
        return DDialogInput;
    }(DDialogLayered));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonGroup = /** @class */ (function (_super) {
        __extends(DButtonGroup, _super);
        function DButtonGroup(options) {
            var _this = _super.call(this) || this;
            _this._buttons = [];
            _this._active = null;
            _this._onActiveBound = function (button) {
                _this.active = button;
            };
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            // Done
            _this.emit("init", _this);
            return _this;
        }
        DButtonGroup.prototype.add = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            if (index < 0) {
                this._buttons.push(button);
                button.isGrouped = true;
                var isEnabled = this._isEnabled;
                if (isEnabled != null) {
                    button.state.isEnabled = isEnabled;
                }
                button.on("active", this._onActiveBound);
                if (button.state.isActive) {
                    this.active = button;
                }
            }
        };
        Object.defineProperty(DButtonGroup.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (newActive) {
                if ((newActive == null || newActive.isToggle) && this._active !== newActive) {
                    var oldActive = this._active;
                    this._active = null;
                    var buttons = this._buttons;
                    for (var i = 0, imax = buttons.length; i < imax; ++i) {
                        var button = buttons[i];
                        if (button !== newActive && button.isToggle && button.state.isActive) {
                            button.toggle();
                        }
                    }
                    this.emit("active", newActive, oldActive, this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonGroup.prototype.remove = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            if (0 <= index) {
                buttons.splice(index, 1);
                button.isGrouped = false;
                button.off("active", this._onActiveBound);
                if (this._active === button) {
                    this.active = null;
                }
            }
        };
        DButtonGroup.prototype.contains = function (button) {
            var buttons = this._buttons;
            var index = buttons.indexOf(button);
            return 0 <= index;
        };
        DButtonGroup.prototype.clear = function () {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].isGrouped = false;
            }
            buttons.length = 0;
            this.active = null;
        };
        DButtonGroup.prototype.size = function () {
            return this._buttons.length;
        };
        DButtonGroup.prototype.each = function (iteratee) {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                var button = buttons[i];
                if (iteratee(button) === false) {
                    break;
                }
            }
        };
        DButtonGroup.prototype.disable = function () {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].state.isDisabled = true;
            }
            this._isEnabled = false;
        };
        DButtonGroup.prototype.enable = function () {
            var buttons = this._buttons;
            for (var i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].state.isDisabled = false;
            }
            this._isEnabled = true;
        };
        DButtonGroup.prototype.destroy = function () {
            this.clear();
        };
        return DButtonGroup;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputBooleanButtonOff = /** @class */ (function (_super) {
        __extends(DInputBooleanButtonOff, _super);
        function DInputBooleanButtonOff() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputBooleanButtonOff.prototype.getType = function () {
            return "DInputBooleanButtonOff";
        };
        return DInputBooleanButtonOff;
    }(DButton));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputBooleanButtonOn = /** @class */ (function (_super) {
        __extends(DInputBooleanButtonOn, _super);
        function DInputBooleanButtonOn() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputBooleanButtonOn.prototype.getType = function () {
            return "DInputBooleanButtonOn";
        };
        return DInputBooleanButtonOn;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputBoolean = /** @class */ (function (_super) {
        __extends(DInputBoolean, _super);
        function DInputBoolean(options) {
            var _this = _super.call(this, options) || this;
            _this.addChild(_this.getButtonOff());
            _this.addChild(_this.getButtonOn());
            var value = options === null || options === void 0 ? void 0 : options.value;
            if (value != null) {
                _this.value = value;
            }
            _this.getButtonGroup().on("active", function () {
                var newValue = _this.value;
                _this.emit("change", newValue, !newValue, _this);
            });
            return _this;
        }
        DInputBoolean.prototype.getButtonGroup = function () {
            var result = this._buttonGroup;
            if (result == null) {
                result = this.newButtonGroup();
                this._buttonGroup = result;
            }
            return result;
        };
        DInputBoolean.prototype.newButtonGroup = function () {
            return new DButtonGroup();
        };
        DInputBoolean.prototype.getButtonOn = function () {
            var result = this._buttonOn;
            if (result == null) {
                result = this.newButtonOn();
                this._buttonOn = result;
            }
            return result;
        };
        DInputBoolean.prototype.newButtonOn = function () {
            return new DInputBooleanButtonOn({
                weight: 1,
                group: this.getButtonGroup()
            });
        };
        DInputBoolean.prototype.getButtonOff = function () {
            var result = this._buttonOff;
            if (result == null) {
                result = this.newButtonOff();
                this._buttonOff = result;
            }
            return result;
        };
        DInputBoolean.prototype.newButtonOff = function () {
            return new DInputBooleanButtonOff({
                weight: 1,
                group: this.getButtonGroup(),
                state: DBaseState.ACTIVE
            });
        };
        Object.defineProperty(DInputBoolean.prototype, "value", {
            get: function () {
                return this.getButtonOn().state.isActive;
            },
            set: function (value) {
                if (this.value !== value) {
                    if (value) {
                        this.getButtonOn().activate();
                    }
                    else {
                        this.getButtonOff().activate();
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DInputBoolean.prototype.getType = function () {
            return "DInputBoolean";
        };
        return DInputBoolean;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputBoolean = /** @class */ (function (_super) {
        __extends(DDialogInputBoolean, _super);
        function DDialogInputBoolean() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputBoolean.prototype.newInput = function (options) {
            return new DInputBoolean(this.toInputOptions(options));
        };
        DDialogInputBoolean.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputBoolean.prototype.getType = function () {
            return "DDialogInputBoolean";
        };
        return DDialogInputBoolean;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialog = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialog, _super);
        function EShapeActionRuntimeOpenDialog(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.onInputAction = value.onInputAction;
            _this.isOpened = false;
            _this.step = EShapeActionExpressions.ofNumberOrNull(value.step);
            _this.min = EShapeActionExpressions.ofNumberOrNull(value.min);
            _this.max = EShapeActionExpressions.ofNumberOrNull(value.max);
            return _this;
        }
        EShapeActionRuntimeOpenDialog.prototype.execute = function (shape, runtime, time) {
            var _this = this;
            if (!this.isOpened) {
                if (this.condition(shape, time, EShapeActionEnvironment)) {
                    var target_1 = this.target(shape, time, EShapeActionEnvironment);
                    if (target_1 != null) {
                        var initial_1 = this.initial(shape, time, EShapeActionEnvironment);
                        var step_1 = this.step(shape, time, EShapeActionEnvironment);
                        var min_1 = this.min(shape, time, EShapeActionEnvironment);
                        var max_1 = this.max(shape, time, EShapeActionEnvironment);
                        this.isOpened = true;
                        setTimeout(function () {
                            _this.open(shape, target_1, initial_1, step_1, min_1, max_1).then(function (value) {
                                _this.isOpened = false;
                                EShapeActionValueOnInputActions.execute(shape, _this.onInputAction, target_1, value, time);
                            }, function () {
                                _this.isOpened = false;
                            });
                        }, 0);
                    }
                }
            }
        };
        return EShapeActionRuntimeOpenDialog;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogBoolean = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogBoolean, _super);
        function EShapeActionRuntimeOpenDialogBoolean(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofBooleanOrFalse(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogBoolean.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogBoolean.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputBoolean({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogBoolean.DIALOG = dialog;
            }
            else {
                var header = dialog.header;
                if (header) {
                    header.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open(shape);
        };
        return EShapeActionRuntimeOpenDialogBoolean;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DHtmlElement = /** @class */ (function (_super) {
        __extends(DHtmlElement, _super);
        function DHtmlElement() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DHtmlElement.prototype.getUtil = function () {
            var result = this._util;
            if (result == null) {
                result = this.newUtil();
                this._util = result;
            }
            return result;
        };
        DHtmlElement.prototype.newUtil = function () {
            return new UtilHtmlElement(this, this.newOperation(), this.theme, this._options);
        };
        DHtmlElement.prototype.newOperation = function () {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(resolution, work, result);
                },
                getElementMatrix: function () {
                    return null;
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperRect(resolution, work, result);
                },
                getPadding: function () {
                    return _this.padding;
                },
                containsPoint: function (point) {
                    return _this.containsPoint(point);
                },
                onStart: function () {
                    // DO NOTHING
                },
                onCancel: function () {
                    // DO NOTHING
                },
                onEnd: function () {
                    // DO NOTHING
                }
            };
        };
        Object.defineProperty(DHtmlElement.prototype, "element", {
            get: function () {
                return this.getUtil().element;
            },
            enumerable: false,
            configurable: true
        });
        DHtmlElement.prototype.onDownThis = function (e) {
            var util = this.getUtil();
            util.onDowning(e);
            _super.prototype.onDownThis.call(this, e);
            util.onDown(e);
        };
        DHtmlElement.prototype.onDblClick = function (e, interactionManager) {
            this.getUtil().onDblClick(e, interactionManager);
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DHtmlElement.prototype.onFocus = function () {
            _super.prototype.onFocus.call(this);
            this.getUtil().onFocus();
        };
        DHtmlElement.prototype.onBlur = function () {
            _super.prototype.onBlur.call(this);
            this.getUtil().onBlur();
        };
        DHtmlElement.prototype.start = function () {
            this.getUtil().start();
        };
        DHtmlElement.prototype.render = function (renderer) {
            this.getUtil().onRender(renderer);
            _super.prototype.render.call(this, renderer);
        };
        /**
         * Please note that this method does not update transforms.
         *
         * @param resolution
         */
        DHtmlElement.prototype.getElementRect = function (resolution, point, result) {
            point.set(0, 0);
            this.toGlobal(point, point, false);
            result.x = point.x;
            result.y = point.y;
            point.set(this.width, this.height);
            this.toGlobal(point, point, true);
            result.width = point.x - result.x;
            result.height = point.y - result.y;
            return result;
        };
        DHtmlElement.prototype.getClipperRect = function (resolution, point, result) {
            return UtilHtmlElement.getClipperRect(this.parent, this, resolution, point, result);
        };
        DHtmlElement.prototype.cancel = function () {
            this.getUtil().cancel();
        };
        DHtmlElement.prototype.end = function () {
            this.getUtil().end();
        };
        DHtmlElement.prototype.select = function () {
            this.getUtil().select();
            return this;
        };
        DHtmlElement.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        };
        DHtmlElement.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.start();
                }
                this.state.isPressed = false;
            }
        };
        DHtmlElement.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DHtmlElement.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DHtmlElement.prototype.getType = function () {
            return "DHtmlElement";
        };
        return DHtmlElement;
    }(DImageBase));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInput = /** @class */ (function (_super) {
        __extends(DInput, _super);
        function DInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInput.prototype.newOperation = function () {
            var _this = this;
            return {
                getElementRect: function (resolution, work, result) {
                    return _this.getElementRect(resolution, work, result);
                },
                getElementMatrix: function () {
                    return null;
                },
                getClipperRect: function (resolution, work, result) {
                    return _this.getClipperRect(resolution, work, result);
                },
                getPadding: function () {
                    return _this.padding;
                },
                containsPoint: function (point) {
                    return _this.containsPoint(point);
                },
                onStart: function () {
                    _this.hideText();
                },
                onCancel: function () {
                    _this.showText();
                },
                onEnd: function () {
                    // DO NOTHING
                },
                getValue: function () {
                    return _this._textValueComputed;
                },
                onValueInput: function (newValue) {
                    _this.onValueInput(newValue);
                },
                onValueChange: function (newValue, oldValue) {
                    _this.text = newValue;
                    _this.onValueChange(newValue, oldValue);
                },
                onEnter: function () {
                    _this.onEnter();
                },
                applyTitle: function () {
                    _this.applyTitle();
                }
            };
        };
        Object.defineProperty(DInput.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DInput.prototype.onTextChange = function () {
            _super.prototype.onTextChange.call(this);
            this.validate();
        };
        DInput.prototype.onValueChange = function (newValue, oldValue) {
            this.emit("change", newValue, oldValue, this);
        };
        DInput.prototype.onValueInput = function (newValue) {
            this.emit("input", newValue, this);
        };
        DInput.prototype.onEnter = function () {
            this.emit("enter", this);
        };
        DInput.prototype.validate = function () {
            return this.getUtil().validate();
        };
        DInput.prototype.applyTitle = function () {
            if (!this.getUtil().applyTitle()) {
                _super.prototype.applyTitle.call(this);
            }
        };
        DInput.prototype.getType = function () {
            return "DInput";
        };
        return DInput;
    }(DHtmlElement));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputInput = /** @class */ (function (_super) {
        __extends(DInputInput, _super);
        function DInputInput() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputInput.prototype.getType = function () {
            return "DInputInput";
        };
        return DInputInput;
    }(DInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputNumber = /** @class */ (function (_super) {
        __extends(DInputNumber, _super);
        function DInputNumber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputNumber.prototype.newUtil = function () {
            return new UtilInputNumber(this, this.newOperation(), this.theme, this._options);
        };
        Object.defineProperty(DInputNumber.prototype, "step", {
            get: function () {
                return this.getUtil().step;
            },
            set: function (step) {
                this.getUtil().step = step;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DInputNumber.prototype, "min", {
            get: function () {
                return this.getUtil().min;
            },
            set: function (min) {
                this.getUtil().min = min;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DInputNumber.prototype, "max", {
            get: function () {
                return this.getUtil().max;
            },
            set: function (max) {
                this.getUtil().max = max;
            },
            enumerable: false,
            configurable: true
        });
        return DInputNumber;
    }(DInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputInteger = /** @class */ (function (_super) {
        __extends(DInputInteger, _super);
        function DInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputInteger.prototype.getType = function () {
            return "DInputInteger";
        };
        return DInputInteger;
    }(DInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputInteger = /** @class */ (function (_super) {
        __extends(DDialogInputInteger, _super);
        function DDialogInputInteger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputInteger.prototype.newInput = function (options) {
            var _this = this;
            var result = new DInputInteger(this.toInputOptions(options));
            result.on("enter", function () {
                _this.ok();
            });
            return result;
        };
        DDialogInputInteger.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputInteger.prototype.getType = function () {
            return "DDialogInputInteger";
        };
        return DDialogInputInteger;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogInteger = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogInteger, _super);
        function EShapeActionRuntimeOpenDialogInteger(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofNumber(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogInteger.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogInteger.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputInteger({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    },
                    input: {
                        step: step,
                        min: min,
                        max: max,
                        text: {
                            value: initial
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogInteger.DIALOG = dialog;
            }
            else {
                var header = dialog.header;
                if (header) {
                    header.text = target;
                }
                var input = dialog.input;
                input.step = step;
                input.min = min;
                input.max = max;
                dialog.value = initial;
            }
            return dialog.open(shape);
        };
        return EShapeActionRuntimeOpenDialogInteger;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputReal = /** @class */ (function (_super) {
        __extends(DInputReal, _super);
        function DInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputReal.prototype.getType = function () {
            return "DInputReal";
        };
        return DInputReal;
    }(DInputNumber));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputReal = /** @class */ (function (_super) {
        __extends(DDialogInputReal, _super);
        function DDialogInputReal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputReal.prototype.newInput = function (options) {
            var _this = this;
            var result = new DInputReal(this.toInputOptions(options));
            result.on("enter", function () {
                _this.ok();
            });
            return result;
        };
        DDialogInputReal.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputReal.prototype.getType = function () {
            return "DDialogInputReal";
        };
        return DDialogInputReal;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogReal = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogReal, _super);
        function EShapeActionRuntimeOpenDialogReal(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofNumber(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogReal.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogReal.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputReal({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    },
                    input: {
                        step: step,
                        min: min,
                        max: max,
                        text: {
                            value: initial
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogReal.DIALOG = dialog;
            }
            else {
                var header = dialog.header;
                if (header) {
                    header.text = target;
                }
                var input = dialog.input;
                input.step = step;
                input.min = min;
                input.max = max;
                dialog.value = initial;
            }
            return dialog.open(shape);
        };
        return EShapeActionRuntimeOpenDialogReal;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputText = /** @class */ (function (_super) {
        __extends(DInputText, _super);
        function DInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputText.prototype.newUtil = function () {
            return new UtilInputText(this, this.newOperation(), this.theme, this._options);
        };
        DInputText.prototype.getType = function () {
            return "DInputText";
        };
        return DInputText;
    }(DInputInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogInputText = /** @class */ (function (_super) {
        __extends(DDialogInputText, _super);
        function DDialogInputText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogInputText.prototype.newInput = function (options) {
            var _this = this;
            var result = new DInputText(this.toInputOptions(options));
            result.on("enter", function () {
                _this.ok();
            });
            return result;
        };
        DDialogInputText.prototype.toInputOptions = function (options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        };
        DDialogInputText.prototype.getType = function () {
            return "DDialogInputText";
        };
        return DDialogInputText;
    }(DDialogInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogText = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogText, _super);
        function EShapeActionRuntimeOpenDialogText(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofString(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogText.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogText.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputText({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogText.DIALOG = dialog;
            }
            else {
                var header = dialog.header;
                if (header) {
                    header.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open(shape);
        };
        return EShapeActionRuntimeOpenDialogText;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogFittedContent = /** @class */ (function (_super) {
        __extends(DDialogFittedContent, _super);
        function DDialogFittedContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogFittedContent.prototype.getType = function () {
            return "DDialogFittedContent";
        };
        return DDialogFittedContent;
    }(DDialogLayeredContent));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog with a header, a content and a footer.
     * Unlike {@link DDialogLayered}, the width is determined by the content width.
     */
    var DDialogFitted = /** @class */ (function (_super) {
        __extends(DDialogFitted, _super);
        function DDialogFitted() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogFitted.prototype.newLayoutOptions = function (theme, options) {
            return {
                width: "auto",
                height: "auto",
                margin: 0
            };
        };
        DDialogFitted.prototype.newContent = function () {
            return new DDialogFittedContent(this.toContentOptions(this.theme, this._options));
        };
        DDialogFitted.prototype.getType = function () {
            return "DDialogFitted";
        };
        return DDialogFitted;
    }(DDialogLayered));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonBack = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonBack, _super);
        function DPickerDatetimeButtonBack() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonBack.prototype.getType = function () {
            return "DPickerDatetimeButtonBack";
        };
        return DPickerDatetimeButtonBack;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonDate = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonDate, _super);
        function DPickerDatetimeButtonDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonDate.prototype.getType = function () {
            return "DPickerDatetimeButtonDate";
        };
        return DPickerDatetimeButtonDate;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeButtonNext = /** @class */ (function (_super) {
        __extends(DPickerDatetimeButtonNext, _super);
        function DPickerDatetimeButtonNext() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeButtonNext.prototype.getType = function () {
            return "DPickerDatetimeButtonNext";
        };
        return DPickerDatetimeButtonNext;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DText = /** @class */ (function (_super) {
        __extends(DText, _super);
        function DText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DText.prototype.getType = function () {
            return "DText";
        };
        return DText;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeLabel = /** @class */ (function (_super) {
        __extends(DPickerDatetimeLabel, _super);
        function DPickerDatetimeLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeLabel.prototype.getType = function () {
            return "DPickerDatetimeLabel";
        };
        return DPickerDatetimeLabel;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeLabelDate = /** @class */ (function (_super) {
        __extends(DPickerDatetimeLabelDate, _super);
        function DPickerDatetimeLabelDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetimeLabelDate.prototype.getType = function () {
            return "DPickerDatetimeLabelDate";
        };
        return DPickerDatetimeLabelDate;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeSpace = /** @class */ (function (_super) {
        __extends(DPickerDatetimeSpace, _super);
        function DPickerDatetimeSpace(options) {
            var _this = _super.call(this, options) || this;
            _this.renderable = false;
            return _this;
        }
        DPickerDatetimeSpace.prototype.getType = function () {
            return "DPickerDatetimeSpace";
        };
        return DPickerDatetimeSpace;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DATE = 1;
    var HOURS = 2;
    var MINUTES = 4;
    var SECONDS = 8;
    var DPickerDatetimeMask = {
        NONE: 0,
        DATE: DATE,
        HOURS: HOURS,
        MINUTES: MINUTES,
        SECONDS: SECONDS,
        TIME: HOURS | MINUTES | SECONDS,
        ALL: DATE | HOURS | MINUTES | SECONDS
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeMasks = /** @class */ (function () {
        function DPickerDatetimeMasks() {
        }
        DPickerDatetimeMasks.from = function (themeOrThemeName, options) {
            var mask = options === null || options === void 0 ? void 0 : options.mask;
            if (mask == null) {
                if (isString(themeOrThemeName)) {
                    var theme = DThemes.getInstance().get(themeOrThemeName);
                    if (theme != null) {
                        return theme.getMask();
                    }
                }
                else if (themeOrThemeName != null) {
                    return themeOrThemeName.getMask();
                }
                return DPickerDatetimeMask.NONE;
            }
            else if (isString(mask)) {
                return DPickerDatetimeMask[mask];
            }
            else if (isNumber(mask)) {
                return mask;
            }
            var result = DPickerDatetimeMask.NONE;
            for (var i = 0, imax = mask.length; i < imax; ++i) {
                result |= DPickerDatetimeMask[mask[i]];
            }
            return result;
        };
        return DPickerDatetimeMasks;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBound = /** @class */ (function () {
        function DPickerTimeBound(options, onChange) {
            var _a, _b;
            this._date = (_a = options === null || options === void 0 ? void 0 : options.date) !== null && _a !== void 0 ? _a : null;
            this._inclusive = (_b = options === null || options === void 0 ? void 0 : options.inclusive) !== null && _b !== void 0 ? _b : false;
            this._onChange = onChange;
        }
        Object.defineProperty(DPickerTimeBound.prototype, "date", {
            get: function () {
                return this._date;
            },
            set: function (date) {
                if (this._date !== date) {
                    this._date = date;
                    this._onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerTimeBound.prototype, "inclusive", {
            get: function () {
                return this._inclusive;
            },
            set: function (inclusive) {
                if (this._inclusive !== inclusive) {
                    this._inclusive = inclusive;
                    this._onChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        return DPickerTimeBound;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundHours = /** @class */ (function () {
        function DPickerTimeBoundHours(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundHours.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.hour.min;
                    }
                }
                var lowerDateHours = lowerDate.getHours();
                if (lower.inclusive) {
                    return lowerDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (lowerDate.getMinutes() < constant.minute.max) {
                            return lowerDateHours;
                        }
                    }
                    return lowerDateHours + 1;
                }
            }
            return constant.hour.min;
        };
        DPickerTimeBoundHours.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.hour.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.hour.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.hour.max;
                    }
                }
                var upperDateHours = upperDate.getHours();
                if (upper.inclusive) {
                    return upperDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (constant.minute.min < upperDate.getMinutes()) {
                            return upperDateHours;
                        }
                    }
                    return upperDateHours - 1;
                }
            }
            return constant.hour.max;
        };
        return DPickerTimeBoundHours;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundMinutes = /** @class */ (function () {
        function DPickerTimeBoundMinutes(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundMinutes.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.minute.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.minute.min;
                    }
                }
                var lowerDateMinutes = lowerDate.getMinutes();
                if (lower.inclusive) {
                    return lowerDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateMinutes;
                        }
                    }
                    return lowerDateMinutes + 1;
                }
            }
            return constant.minute.min;
        };
        DPickerTimeBoundMinutes.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.minute.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.minute.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.minute.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.minute.max;
                    }
                }
                var upperDateMinutes = upperDate.getMinutes();
                if (upper.inclusive) {
                    return upperDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateMinutes;
                        }
                    }
                    return upperDateMinutes - 1;
                }
            }
            return constant.minute.max;
        };
        return DPickerTimeBoundMinutes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBoundSeconds = /** @class */ (function () {
        function DPickerTimeBoundSeconds(parent) {
            this._parent = parent;
        }
        DPickerTimeBoundSeconds.prototype.min = function (date) {
            var parent = this._parent;
            var lower = parent.lower;
            var lowerDate = lower.date;
            var constant = parent.constant;
            if (lowerDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (lowerDate.getMinutes() < date.getMinutes()) {
                        return constant.second.min;
                    }
                }
                return lowerDate.getSeconds() + (lower.inclusive ? 0 : 1);
            }
            return constant.second.min;
        };
        DPickerTimeBoundSeconds.prototype.max = function (date) {
            var parent = this._parent;
            var upper = parent.upper;
            var upperDate = upper.date;
            var constant = parent.constant;
            if (upperDate != null) {
                var mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.second.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.second.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (date.getMinutes() < upperDate.getMinutes()) {
                        return constant.second.max;
                    }
                }
                return upperDate.getSeconds() - (upper.inclusive ? 0 : 1);
            }
            return constant.second.max;
        };
        return DPickerTimeBoundSeconds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeBounds = /** @class */ (function () {
        function DPickerTimeBounds(options, onChange) {
            this.constant = this.newConstant();
            this.lower = new DPickerTimeBound(options && options.lower, onChange);
            this.upper = new DPickerTimeBound(options && options.upper, onChange);
            this.mask = DPickerDatetimeMask.ALL;
            this.hours = new DPickerTimeBoundHours(this);
            this.minutes = new DPickerTimeBoundMinutes(this);
            this.seconds = new DPickerTimeBoundSeconds(this);
        }
        DPickerTimeBounds.prototype.newConstant = function () {
            return {
                second: {
                    min: 0,
                    max: 59
                },
                minute: {
                    min: 0,
                    max: 59
                },
                hour: {
                    min: 0,
                    max: 23
                }
            };
        };
        DPickerTimeBounds.prototype.adjust = function (date) {
            var result = this.test(date);
            if (result < 0) {
                var lower = this.lower;
                var lowerDate = lower.date;
                if (lowerDate) {
                    date.setTime(lowerDate.getTime());
                    if (!lower.inclusive) {
                        var mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(lowerDate.getSeconds() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(lowerDate.getMinutes() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(lowerDate.getHours() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(lowerDate.getDate() + 1);
                        }
                    }
                    return true;
                }
            }
            else if (0 < result) {
                var upper = this.upper;
                var upperDate = upper.date;
                if (upperDate) {
                    date.setTime(upperDate.getTime());
                    if (!upper.inclusive) {
                        var mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(upperDate.getSeconds() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(upperDate.getMinutes() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(upperDate.getHours() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(upperDate.getDate() - 1);
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        DPickerTimeBounds.prototype.compare = function (a, b) {
            var mask = this.mask;
            if (mask & DPickerDatetimeMask.DATE) {
                var ay = a.getFullYear();
                var by = b.getFullYear();
                if (ay !== by) {
                    return ay < by ? -1 : +1;
                }
                var am = a.getMonth();
                var bm = b.getMonth();
                if (am !== bm) {
                    return am < bm ? -1 : +1;
                }
                var ad = a.getDate();
                var bd = b.getDate();
                if (ad !== bd) {
                    return ad < bd ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.HOURS) {
                var ah = a.getHours();
                var bh = b.getHours();
                if (ah !== bh) {
                    return ah < bh ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                var am = a.getMinutes();
                var bm = b.getMinutes();
                if (am !== bm) {
                    return am < bm ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                var ad = a.getSeconds();
                var bd = b.getSeconds();
                if (ad !== bd) {
                    return ad < bd ? -1 : +1;
                }
            }
            return 0;
        };
        DPickerTimeBounds.prototype.test = function (date) {
            // Lower bound
            var lower = this.lower;
            var lowerDate = lower.date;
            if (lowerDate != null) {
                var result = this.compare(lowerDate, date);
                if (lower.inclusive) {
                    return result <= 0 ? 0 : -1;
                }
                else {
                    return result < 0 ? 0 : -1;
                }
            }
            // Upper bound
            var upper = this.upper;
            var upperDate = upper.date;
            if (upperDate != null) {
                var result = this.compare(date, upperDate);
                if (upper.inclusive) {
                    return result <= 0 ? 0 : +1;
                }
                else {
                    return result < 0 ? 0 : +1;
                }
            }
            return 0;
        };
        DPickerTimeBounds.prototype.contains = function (date) {
            return this.test(date) === 0;
        };
        return DPickerTimeBounds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toBoundOptions = function (options, defaultDate, defaultInclusive) {
        if (options) {
            var date = options.date;
            var inclusive = options.inclusive;
            return {
                date: date !== undefined ? date : defaultDate,
                inclusive: inclusive !== undefined ? inclusive : defaultInclusive
            };
        }
        return {
            date: defaultDate,
            inclusive: defaultInclusive
        };
    };
    var toBoundsOptions = function (theme, options) {
        if (options) {
            return {
                lower: toBoundOptions(options.lower, theme.getLowerBound(), theme.isLowerBoundInclusive()),
                upper: toBoundOptions(options.upper, theme.getUpperBound(), theme.isUpperBoundInclusive())
            };
        }
        return {
            lower: {
                date: theme.getLowerBound(),
                inclusive: theme.isLowerBoundInclusive()
            },
            upper: {
                date: theme.getUpperBound(),
                inclusive: theme.isUpperBoundInclusive()
            }
        };
    };
    var DPickerTime = /** @class */ (function (_super) {
        __extends(DPickerTime, _super);
        function DPickerTime(options) {
            var _this = _super.call(this, options) || this;
            _this.onNewChange();
            return _this;
        }
        DPickerTime.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            this._dateCurrent = new Date();
            var dateCurrentTime = this._dateCurrent.getTime();
            this._dateNew = new Date(dateCurrentTime);
            this._dateBounds = new DPickerTimeBounds(toBoundsOptions(theme, options === null || options === void 0 ? void 0 : options.bounds), function () {
                _this.onNewChange();
            });
            var margin = (_a = options === null || options === void 0 ? void 0 : options.margin) !== null && _a !== void 0 ? _a : theme.getMargin();
            new DLayoutVertical({
                parent: this,
                x: "padding",
                y: "padding",
                width: "auto",
                height: "auto",
                margin: margin,
                children: this.newChildren(theme, options, margin)
            });
        };
        Object.defineProperty(DPickerTime.prototype, "current", {
            get: function () {
                return this._dateCurrent;
            },
            set: function (dateCurrent) {
                if (this._dateCurrent.getTime() !== dateCurrent.getTime()) {
                    this._dateCurrent = dateCurrent;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerTime.prototype, "new", {
            get: function () {
                return this._dateNew;
            },
            set: function (dateNew) {
                if (this._dateNew.getTime() !== dateNew.getTime()) {
                    this._dateNew = dateNew;
                    this.onNewChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerTime.prototype, "bounds", {
            get: function () {
                return this._dateBounds;
            },
            enumerable: false,
            configurable: true
        });
        DPickerTime.prototype.hasHours = function () {
            return this._inputHours != null;
        };
        DPickerTime.prototype.hasMinutes = function () {
            return this._inputMinutes != null;
        };
        DPickerTime.prototype.hasSeconds = function () {
            return this._inputSeconds != null;
        };
        DPickerTime.prototype.reset = function () {
            var currentTime = this._dateCurrent.getTime();
            this._dateNew.setTime(currentTime);
            this.onReset();
        };
        DPickerTime.prototype.onReset = function () {
            this.onNewChange();
        };
        DPickerTime.prototype.onNewChange = function () {
            var dateNew = this._dateNew;
            var dateBounds = this._dateBounds;
            dateBounds.adjust(this._dateNew);
            var inputHours = this._inputHours;
            if (inputHours) {
                var hours = dateBounds.hours;
                inputHours.value = dateNew.getHours();
                inputHours.min = hours.min(dateNew);
                inputHours.max = hours.max(dateNew);
            }
            var inputMinutes = this._inputMinutes;
            if (inputMinutes) {
                var minutes = dateBounds.minutes;
                inputMinutes.value = dateNew.getMinutes();
                inputMinutes.min = minutes.min(dateNew);
                inputMinutes.max = minutes.max(dateNew);
            }
            var inputSeconds = this._inputSeconds;
            if (inputSeconds) {
                var seconds = dateBounds.seconds;
                inputSeconds.value = dateNew.getSeconds();
                inputSeconds.min = seconds.min(dateNew);
                inputSeconds.max = seconds.max(dateNew);
            }
        };
        DPickerTime.prototype.newChildren = function (theme, options, margin) {
            var mask = DPickerDatetimeMasks.from(theme, options);
            this._dateBounds.mask = mask;
            this._inputHours =
                mask & DPickerDatetimeMask.HOURS ? this.newInputHours(theme, options) : null;
            this._inputMinutes =
                mask & DPickerDatetimeMask.MINUTES ? this.newInputMinutes(theme, options) : null;
            this._inputSeconds =
                mask & DPickerDatetimeMask.SECONDS ? this.newInputSeconds(theme, options) : null;
            return [
                this.newTimeLayout(this._inputHours, this._inputMinutes, this._inputSeconds, margin)
            ];
        };
        DPickerTime.prototype.newTimeLayout = function (hours, minutes, seconds, margin) {
            var children = this.newTimeLayoutChildren(hours, minutes, seconds);
            if (0 < children.length) {
                return new DLayoutHorizontal({
                    width: this.getTimeLayoutWidth(),
                    height: this.getTimeLayoutHeight(),
                    margin: margin,
                    children: children
                });
            }
            return null;
        };
        DPickerTime.prototype.getTimeLayoutWidth = function () {
            return "auto";
        };
        DPickerTime.prototype.getTimeLayoutHeight = function () {
            return "auto";
        };
        DPickerTime.prototype.newTimeLayoutChildren = function (hours, minutes, seconds) {
            var result = [];
            if (hours != null) {
                result.push(hours);
            }
            if (minutes != null) {
                if (0 < result.length) {
                    result.push(this.newMinuteSeparator());
                }
                result.push(minutes);
            }
            if (seconds != null) {
                if (0 < result.length) {
                    result.push(this.newSecondSeparator());
                }
                result.push(seconds);
            }
            return result;
        };
        DPickerTime.prototype.newMinuteSeparator = function () {
            return new DText({
                width: "auto",
                text: {
                    value: this.getMinuteSeparator()
                }
            });
        };
        DPickerTime.prototype.getMinuteSeparator = function () {
            return ":";
        };
        DPickerTime.prototype.newSecondSeparator = function () {
            return new DText({
                width: "auto",
                text: {
                    value: this.getSecondSeparator()
                }
            });
        };
        DPickerTime.prototype.getSecondSeparator = function () {
            return ":";
        };
        DPickerTime.prototype.adjustInputOptions = function (theme, options, max) {
            if (options.step == null) {
                options.step = 1;
            }
            if (options.min == null) {
                options.min = 0;
            }
            if (options.max == null) {
                options.max = max;
            }
            return options;
        };
        DPickerTime.prototype.newInputHours = function (theme, options) {
            var _this = this;
            var _a;
            var inputOptions = (_a = options === null || options === void 0 ? void 0 : options.hours) !== null && _a !== void 0 ? _a : theme.getHoursOptions();
            var max = this._dateBounds.constant.hour.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onHoursChange(value);
            });
            return input;
        };
        DPickerTime.prototype.onHoursChange = function (value) {
            var dateNew = this._dateNew;
            dateNew.setHours(value);
            this.onNewChange();
        };
        DPickerTime.prototype.newInputMinutes = function (theme, options) {
            var _this = this;
            var inputOptions = (options === null || options === void 0 ? void 0 : options.minutes) || theme.getMinutesOptions();
            var max = this._dateBounds.constant.minute.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onMinutesChange(value);
            });
            return input;
        };
        DPickerTime.prototype.onMinutesChange = function (value) {
            var dateNew = this._dateNew;
            dateNew.setMinutes(value);
            this.onNewChange();
        };
        DPickerTime.prototype.newInputSeconds = function (theme, options) {
            var _this = this;
            var inputOptions = (options === null || options === void 0 ? void 0 : options.seconds) || theme.getSecondsOptions();
            var max = this._dateBounds.constant.second.max;
            var input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", function (value) {
                _this.onSecondsChange(value);
            });
            return input;
        };
        DPickerTime.prototype.onSecondsChange = function (value) {
            this._dateNew.setSeconds(value);
        };
        DPickerTime.prototype.getType = function () {
            return "DPickerTime";
        };
        return DPickerTime;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetime = /** @class */ (function (_super) {
        __extends(DPickerDatetime, _super);
        function DPickerDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDatetime.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this._datePage = new Date(this._dateCurrent.getTime());
        };
        DPickerDatetime.prototype.newChildren = function (theme, options, margin) {
            var _a, _b;
            this._dateButtons = this.newDateButtons(theme, options);
            this._dateDecorator = (_b = (_a = options === null || options === void 0 ? void 0 : options.date) === null || _a === void 0 ? void 0 : _a.decorator) !== null && _b !== void 0 ? _b : theme.getDateDecorator();
            this._label = this.newLabel(theme, options);
            var result = _super.prototype.newChildren.call(this, theme, options, margin);
            result.unshift(new DLayoutHorizontal({
                width: "100%",
                height: "auto",
                children: [
                    this.newBackButton(theme, options),
                    this._label,
                    this.newNextButton(theme, options)
                ]
            }), new DLayoutHorizontal({
                width: "auto",
                height: "auto",
                margin: margin,
                children: this.newDateLabels(theme, options)
            }), new DLayoutVertical({
                width: "auto",
                height: "auto",
                margin: margin,
                column: 7,
                children: this._dateButtons
            }));
            return result;
        };
        Object.defineProperty(DPickerDatetime.prototype, "page", {
            get: function () {
                return this._datePage;
            },
            set: function (datePage) {
                if (this._datePage.getTime() !== datePage.getTime()) {
                    this._datePage = datePage;
                    this.onPageChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DPickerDatetime.prototype.onReset = function () {
            this._datePage.setTime(this._dateCurrent.getTime());
            _super.prototype.onReset.call(this);
        };
        DPickerDatetime.prototype.next = function () {
            var work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() + 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChange();
        };
        DPickerDatetime.prototype.back = function () {
            var work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() - 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChange();
        };
        DPickerDatetime.prototype.onNewChange = function () {
            this._dateBounds.adjust(this._datePage);
            _super.prototype.onNewChange.call(this);
            this.onPageChange();
        };
        DPickerDatetime.prototype.onPageChange = function () {
            var buttons = this._dateButtons;
            var bounds = this._dateBounds;
            var datePage = this._datePage;
            var dateNew = this._dateNew;
            var tmp = new Date(datePage.getTime());
            tmp.setDate(1);
            tmp.setHours(0, 0, 0, 0);
            // Spaces
            var theme = this.theme;
            var spaceCount = (tmp.getDay() - theme.getDayStart() + 7) % 7;
            for (var i = 0; i < spaceCount; ++i) {
                buttons[i].show();
            }
            for (var i = spaceCount; i < 7; ++i) {
                buttons[i].hide();
            }
            // Date buttons
            var dateDecorator = this._dateDecorator;
            tmp.setFullYear(tmp.getFullYear(), tmp.getMonth() + 1, 0);
            var dateCount = tmp.getDate();
            var dateNewDate = dateNew.getFullYear() === tmp.getFullYear() && dateNew.getMonth() === tmp.getMonth()
                ? dateNew.getDate()
                : 0;
            for (var i = 0; i < dateCount; ++i) {
                tmp.setDate(i + 1);
                var button = buttons[i + 7];
                button.state.isActive = dateNewDate === i + 1;
                button.state.isDisabled = !bounds.contains(tmp);
                button.show();
                dateDecorator(tmp, button);
            }
            for (var i = dateCount; i < 31; ++i) {
                var button = buttons[i + 7];
                button.state.isActive = false;
                button.hide();
            }
            // Label
            tmp.setTime(datePage.getTime());
            this._label.text = tmp;
        };
        DPickerDatetime.prototype.adjustInputOptions = function (theme, options, max) {
            if (options.weight == null) {
                options.weight = 1;
            }
            return _super.prototype.adjustInputOptions.call(this, theme, options, max);
        };
        DPickerDatetime.prototype.getTimeLayoutWidth = function () {
            return "100%";
        };
        DPickerDatetime.prototype.toLabelOptions = function (theme, options) {
            var result = (options && options.label) || {};
            if (result.weight === undefined) {
                result.weight = 1;
            }
            if (result.padding === undefined) {
                result.padding = 0;
            }
            var labelText = (result.text = result.text || {});
            var labelTextAlign = (labelText.align = labelText.align || {});
            if (labelTextAlign.horizontal === undefined) {
                labelTextAlign.horizontal = "CENTER";
            }
            if (labelText.formatter === undefined) {
                labelText.formatter = theme.getLabelFormatter();
            }
            return result;
        };
        DPickerDatetime.prototype.newLabel = function (theme, options) {
            return new DPickerDatetimeLabel(this.toLabelOptions(theme, options));
        };
        DPickerDatetime.prototype.newBackButton = function (theme, options) {
            var _this = this;
            var buttonOptions = options === null || options === void 0 ? void 0 : options.back;
            if (buttonOptions === undefined) {
                buttonOptions = theme.getBackButtonOptions();
            }
            if (buttonOptions != null) {
                var button = new DPickerDatetimeButtonBack(buttonOptions);
                button.on("active", function () {
                    _this.back();
                });
                return button;
            }
            return null;
        };
        DPickerDatetime.prototype.newNextButton = function (theme, options) {
            var _this = this;
            var buttonOptions = options === null || options === void 0 ? void 0 : options.next;
            if (buttonOptions === undefined) {
                buttonOptions = theme.getNextButtonOptions();
            }
            if (buttonOptions != null) {
                var button = new DPickerDatetimeButtonNext(buttonOptions);
                button.on("active", function () {
                    _this.next();
                });
                return button;
            }
            return null;
        };
        DPickerDatetime.prototype.newDateLabels = function (theme, options) {
            var dateLabels = theme.getDayLabels();
            var dayStart = theme.getDayStart();
            var result = [];
            for (var i = 0; i < 7; ++i) {
                var label = dateLabels[(dayStart + i) % 7];
                result.push(this.newDateLabel(theme, options, label));
            }
            return result;
        };
        DPickerDatetime.prototype.newDateLabel = function (theme, options, label) {
            return new DPickerDatetimeLabelDate({
                text: {
                    value: label
                }
            });
        };
        DPickerDatetime.prototype.newDateButtons = function (theme, options) {
            var result = [];
            for (var i = 0; i < 7; ++i) {
                result.push(this.newSpace(theme, options));
            }
            for (var i = 1; i <= 31; ++i) {
                result.push(this.newDateButton(theme, options, i));
            }
            return result;
        };
        DPickerDatetime.prototype.newSpace = function (theme, options) {
            return new DPickerDatetimeSpace();
        };
        DPickerDatetime.prototype.newDateButton = function (theme, options, date) {
            var _this = this;
            return new DPickerDatetimeButtonDate({
                text: {
                    value: String(date)
                },
                on: {
                    active: function () {
                        _this.onDateButtonClicked(date);
                    }
                }
            });
        };
        DPickerDatetime.prototype.onDateButtonClicked = function (date) {
            var dateNew = this._dateNew;
            if (dateNew.getDate() !== date) {
                var datePage = this._datePage;
                dateNew.setFullYear(datePage.getFullYear());
                dateNew.setMonth(datePage.getMonth());
                dateNew.setDate(date);
                this.onNewChange();
            }
        };
        DPickerDatetime.prototype.getType = function () {
            return "DPickerDatetime";
        };
        return DPickerDatetime;
    }(DPickerTime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDatetime = /** @class */ (function (_super) {
        __extends(DDialogDatetime, _super);
        function DDialogDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogDatetime.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        Object.defineProperty(DDialogDatetime.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            set: function (dateCurrent) {
                this.picker.current = dateCurrent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            set: function (value) {
                this.picker.new = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "page", {
            get: function () {
                return this.picker.new;
            },
            set: function (page) {
                this.picker.page = page;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDatetime.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerDatetime((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogDatetime.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogDatetime.prototype.getType = function () {
            return "DDialogDatetime";
        };
        return DDialogDatetime;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogDatetime = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogDatetime, _super);
        function EShapeActionRuntimeOpenDialogDatetime(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofUnknown(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogDatetime.prototype.open = function (shape, target, initial, step, min, max) {
            var dialog = EShapeActionRuntimeOpenDialogDatetime.DIALOG;
            if (dialog == null) {
                dialog = new DDialogDatetime();
                EShapeActionRuntimeOpenDialogDatetime.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open(shape).then(function (value) {
                return value.toISOString();
            });
        };
        EShapeActionRuntimeOpenDialogDatetime.prototype.toDate = function (value) {
            if (isString(value) || isNumber(value)) {
                return new Date(value);
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        };
        return EShapeActionRuntimeOpenDialogDatetime;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogTime = /** @class */ (function (_super) {
        __extends(DDialogTime, _super);
        function DDialogTime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogTime.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        Object.defineProperty(DDialogTime.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            set: function (dateCurrent) {
                this.picker.current = dateCurrent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogTime.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            set: function (dateNew) {
                this.picker.new = dateNew;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogTime.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerTime((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogTime.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogTime.prototype.getType = function () {
            return "DDialogTime";
        };
        return DDialogTime;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isNaN$1 = function (target) {
        return target !== target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogTime = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogTime, _super);
        function EShapeActionRuntimeOpenDialogTime(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofUnknown(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogTime.prototype.open = function (shape, target, initial, step, min, max) {
            var _this = this;
            var dialog = EShapeActionRuntimeOpenDialogTime.DIALOG;
            if (dialog == null) {
                dialog = new DDialogTime();
                EShapeActionRuntimeOpenDialogTime.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open(shape).then(function (value) {
                return _this.getFormatter().format(value.getTime(), 0);
            });
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toDate = function (value) {
            if (isNumber(value)) {
                return new Date(value);
            }
            else if (isString(value)) {
                var result = new Date();
                var pattern = this.getPattern();
                var matched = pattern.exec(value);
                if (matched != null) {
                    var hours = this.toHours(matched[1]);
                    if (hours != null) {
                        result.setHours(hours);
                    }
                    var minutes = this.toMinutes(matched[2]);
                    if (minutes != null) {
                        result.setMinutes(minutes);
                    }
                    var seconds = this.toSeconds(matched[3]);
                    if (seconds != null) {
                        result.setSeconds(seconds);
                    }
                    var milliseconds = this.toMilliseconds(matched[4]);
                    if (milliseconds != null) {
                        result.setMilliseconds(milliseconds);
                    }
                }
                return result;
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toHours = function (value) {
            return this.toNumber(value, 0, 23);
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toMinutes = function (value) {
            return this.toNumber(value, 0, 59);
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toSeconds = function (value) {
            return this.toNumber(value, 0, 59);
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toMilliseconds = function (value) {
            var result = this.toNumber(value, 0, 999);
            if (result != null) {
                var length_1 = value.length;
                if (length_1 === 1) {
                    return result * 100;
                }
                else if (length_1 === 2) {
                    return result * 10;
                }
                else {
                    return result;
                }
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.toNumber = function (value, min, max) {
            if (value != null) {
                var num = +value;
                if (!isNaN$1(num)) {
                    return Math.min(max, Math.max(min, num));
                }
            }
            return null;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.getPattern = function () {
            var result = EShapeActionRuntimeOpenDialogTime.PATTERN;
            if (result == null) {
                result = this.newPattern();
                EShapeActionRuntimeOpenDialogTime.PATTERN = result;
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.newPattern = function () {
            return /^\s*(?:(\d+)(?::(\d+)(?::(\d+))?)?)?(?:\.(\d+))?\s*$/;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.getFormatter = function () {
            var result = EShapeActionRuntimeOpenDialogTime.FORMATTER;
            if (result == null) {
                result = this.newFormatter();
                EShapeActionRuntimeOpenDialogTime.FORMATTER = result;
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogTime.prototype.newFormatter = function () {
            return NumberFormatters.create("%Hm");
        };
        return EShapeActionRuntimeOpenDialogTime;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDate = /** @class */ (function (_super) {
        __extends(DPickerDate, _super);
        function DPickerDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerDate.prototype.getType = function () {
            return "DPickerDate";
        };
        return DPickerDate;
    }(DPickerDatetime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogDate = /** @class */ (function (_super) {
        __extends(DDialogDate, _super);
        function DDialogDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogDate.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        Object.defineProperty(DDialogDate.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            set: function (dateCurrent) {
                this.picker.current = dateCurrent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            set: function (value) {
                this.picker.new = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "page", {
            get: function () {
                return this.picker.new;
            },
            set: function (page) {
                this.picker.page = page;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogDate.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerDate((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogDate.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogDate.prototype.getType = function () {
            return "DDialogDate";
        };
        return DDialogDate;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogDate = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogDate, _super);
        function EShapeActionRuntimeOpenDialogDate(value) {
            var _this = _super.call(this, value) || this;
            _this.initial = EShapeActionExpressions.ofUnknown(value.initial);
            return _this;
        }
        EShapeActionRuntimeOpenDialogDate.prototype.open = function (shape, target, initial, step, min, max) {
            var _this = this;
            var dialog = EShapeActionRuntimeOpenDialogDate.DIALOG;
            if (dialog == null) {
                dialog = new DDialogDate();
                EShapeActionRuntimeOpenDialogDate.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open(shape).then(function (value) {
                return _this.getFormatter().format(value.getTime(), 0);
            });
        };
        EShapeActionRuntimeOpenDialogDate.prototype.toDate = function (value) {
            if (isString(value) || isNumber(value)) {
                return new Date(value);
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        };
        EShapeActionRuntimeOpenDialogDate.prototype.getFormatter = function () {
            var result = EShapeActionRuntimeOpenDialogDate.FORMATTER;
            if (result == null) {
                result = this.newFormatter();
                EShapeActionRuntimeOpenDialogDate.FORMATTER = result;
            }
            return result;
        };
        EShapeActionRuntimeOpenDialogDate.prototype.newFormatter = function () {
            return NumberFormatters.create("%Y-%M-%D");
        };
        return EShapeActionRuntimeOpenDialogDate;
    }(EShapeActionRuntimeOpenDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenDialogType = {
        TEXT: 0,
        INTEGER: 1,
        REAL: 2,
        BOOLEAN: 3,
        DATE: 4,
        TIME: 5,
        DATETIME: 6,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenDialog = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpenDialog, _super);
        function EShapeActionValueOpenDialog(condition, target, onInputAction, initial, step, min, max, dialogType) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, EShapeActionValueOpenType.DIALOG) || this;
            _this.target = target;
            _this.onInputAction = onInputAction;
            _this.initial = initial;
            _this.step = step;
            _this.min = min;
            _this.max = max;
            _this.dialogType = dialogType;
            return _this;
        }
        EShapeActionValueOpenDialog.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpenDialog &&
                this.target === value.target &&
                this.dialogType === value.dialogType &&
                this.onInputAction === value.onInputAction &&
                this.initial === value.initial &&
                this.step === value.step &&
                this.min === value.min &&
                this.max === value.max);
        };
        EShapeActionValueOpenDialog.prototype.toRuntime = function () {
            switch (this.dialogType) {
                case EShapeActionValueOpenDialogType.TEXT:
                    return new EShapeActionRuntimeOpenDialogText(this);
                case EShapeActionValueOpenDialogType.INTEGER:
                    return new EShapeActionRuntimeOpenDialogInteger(this);
                case EShapeActionValueOpenDialogType.REAL:
                    return new EShapeActionRuntimeOpenDialogReal(this);
                case EShapeActionValueOpenDialogType.BOOLEAN:
                    return new EShapeActionRuntimeOpenDialogBoolean(this);
                case EShapeActionValueOpenDialogType.DATE:
                    return new EShapeActionRuntimeOpenDialogDate(this);
                case EShapeActionValueOpenDialogType.TIME:
                    return new EShapeActionRuntimeOpenDialogTime(this);
                case EShapeActionValueOpenDialogType.DATETIME:
                    return new EShapeActionRuntimeOpenDialogDatetime(this);
            }
        };
        EShapeActionValueOpenDialog.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var initialId = manager.addResource(this.initial);
            var stepId = manager.addResource(this.step);
            var minId = manager.addResource(this.min);
            var maxId = manager.addResource(this.max);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",").concat(this.onInputAction, ",").concat(initialId, ",").concat(this.dialogType, ",").concat(stepId, ",").concat(minId, ",").concat(maxId, "]"));
        };
        EShapeActionValueOpenDialog.deserialize = function (serialized, manager) {
            var resources = manager.resources;
            var condition = EShapeActionValues.toResource(1, serialized, resources);
            var target = EShapeActionValues.toResource(3, serialized, resources);
            var initial = EShapeActionValues.toResource(5, serialized, resources);
            var step = EShapeActionValues.toResource(7, serialized, resources);
            var min = EShapeActionValues.toResource(8, serialized, resources);
            var max = EShapeActionValues.toResource(9, serialized, resources);
            return new EShapeActionValueOpenDialog(condition, target, serialized[4], initial, step, min, max, this.toDialogType(serialized));
        };
        EShapeActionValueOpenDialog.toDialogType = function (serialized) {
            if (serialized[2] === EShapeActionValueOpenType.DIALOG) {
                return serialized[6];
            }
            else {
                switch (serialized[2]) {
                    case EShapeActionValueOpenType.DIALOG_TEXT:
                        return EShapeActionValueOpenDialogType.TEXT;
                    case EShapeActionValueOpenType.DIALOG_INTEGER:
                        return EShapeActionValueOpenDialogType.INTEGER;
                    case EShapeActionValueOpenType.DIALOG_REAL:
                        return EShapeActionValueOpenDialogType.REAL;
                    case EShapeActionValueOpenType.DIALOG_BOOLEAN:
                        return EShapeActionValueOpenDialogType.BOOLEAN;
                    case EShapeActionValueOpenType.DIALOG_DATE:
                        return EShapeActionValueOpenDialogType.DATE;
                    case EShapeActionValueOpenType.DIALOG_TIME:
                        return EShapeActionValueOpenDialogType.TIME;
                    case EShapeActionValueOpenType.DIALOG_DATETIME:
                        return EShapeActionValueOpenDialogType.DATETIME;
                }
            }
        };
        return EShapeActionValueOpenDialog;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionOpenDialogExtensions = /** @class */ (function () {
        function EShapeActionOpenDialogExtensions() {
        }
        EShapeActionOpenDialogExtensions.add = function (extension) {
            var _a, _b;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._data) !== null && _b !== void 0 ? _b : (this._data = [])).push(extension);
        };
        EShapeActionOpenDialogExtensions.get = function (type) {
            var typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        };
        EShapeActionOpenDialogExtensions.each = function (iteratee) {
            var data = this._data;
            if (data != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        };
        return EShapeActionOpenDialogExtensions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeOpenDialogExtension = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeOpenDialogExtension, _super);
        function EShapeActionRuntimeOpenDialogExtension(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            _this.argument = EShapeActionExpressions.ofUnknown(value.argument);
            var extension = EShapeActionOpenDialogExtensions.get(value.dialogType);
            if (extension) {
                _this.opener = extension.opener;
            }
            return _this;
        }
        EShapeActionRuntimeOpenDialogExtension.prototype.execute = function (shape, runtime, time) {
            var opener = this.opener;
            if (opener) {
                if (this.condition(shape, time, EShapeActionEnvironment)) {
                    var target_1 = this.target(shape, time, EShapeActionEnvironment);
                    if (target_1 != null) {
                        var argument_1 = this.argument(shape, time, EShapeActionEnvironment);
                        setTimeout(function () {
                            opener(target_1, argument_1, shape);
                        }, 0);
                    }
                }
            }
        };
        return EShapeActionRuntimeOpenDialogExtension;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenDialogExtension = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpenDialogExtension, _super);
        function EShapeActionValueOpenDialogExtension(condition, target, argument, dialogType) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, EShapeActionValueOpenType.DIALOG) || this;
            _this.target = target;
            _this.argument = argument;
            _this.dialogType = dialogType;
            return _this;
        }
        EShapeActionValueOpenDialogExtension.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpenDialogExtension &&
                this.target === value.target &&
                this.argument === value.argument &&
                this.dialogType === value.dialogType);
        };
        EShapeActionValueOpenDialogExtension.prototype.toRuntime = function () {
            return new EShapeActionRuntimeOpenDialogExtension(this);
        };
        EShapeActionValueOpenDialogExtension.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var argumentId = manager.addResource(this.argument);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",0,-1,").concat(this.dialogType, ",").concat(argumentId, "]"));
        };
        EShapeActionValueOpenDialogExtension.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var target = EShapeActionValues.toResource(3, serialized, manager.resources);
            var argument = EShapeActionValues.toResource(7, serialized, manager.resources);
            return new EShapeActionValueOpenDialogExtension(condition, target, argument, serialized[6]);
        };
        return EShapeActionValueOpenDialogExtension;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionOpenExtensions = /** @class */ (function () {
        function EShapeActionOpenExtensions() {
        }
        EShapeActionOpenExtensions.add = function (extension) {
            var _a, _b;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._data) !== null && _b !== void 0 ? _b : (this._data = [])).push(extension);
            EShapeActionOpenOpeners[extension.type] = extension.opener;
        };
        EShapeActionOpenExtensions.get = function (type) {
            var typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        };
        EShapeActionOpenExtensions.each = function (iteratee) {
            var data = this._data;
            if (data != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        };
        return EShapeActionOpenExtensions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpenExtension = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpenExtension, _super);
        function EShapeActionValueOpenExtension(subtype, condition, target, inNewWindow) {
            var _this = _super.call(this, EShapeActionValueType.OPEN, condition, subtype) || this;
            _this.target = target;
            _this.inNewWindow = inNewWindow;
            return _this;
        }
        EShapeActionValueOpenExtension.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpenExtension &&
                this.target === value.target &&
                this.inNewWindow === value.inNewWindow);
        };
        EShapeActionValueOpenExtension.prototype.toRuntime = function () {
            return new EShapeActionRuntimeOpen(this, this.subtype);
        };
        EShapeActionValueOpenExtension.prototype.toLabel = function () {
            var typeLabel = this.getTheme().toTypeLabel(this.type);
            var datum = EShapeActionOpenExtensions.get(this.subtype);
            return "".concat(typeLabel, ": ").concat(datum != null ? datum.label : "Unknown");
        };
        EShapeActionValueOpenExtension.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var targetId = manager.addResource(this.target);
            var inNewWindow = this.inNewWindow ? 1 : 0;
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(targetId, ",").concat(inNewWindow, "]"));
        };
        EShapeActionValueOpenExtension.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var target = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueOpenExtension(serialized[2], condition, target, !!serialized[4]);
        };
        return EShapeActionValueOpenExtension;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHideType = {
        /** @deprecated in favor of {@link SHAPE} */
        SHAPE_SHOW: 0,
        /** @deprecated in favor of {@link SHAPE} */
        SHAPE_HIDE: 1,
        SHAPE: 2,
        LAYER: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * @deprecated in favor of {@link EShapeActionRuntimeShowHideShape}.
     */
    var EShapeActionRuntimeShowHide = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeShowHide, _super);
        function EShapeActionRuntimeShowHide(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
            _this.visibility = value.subtype === EShapeActionValueShowHideType.SHAPE_SHOW;
            return _this;
        }
        EShapeActionRuntimeShowHide.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                shape.visible = this.visibility;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeShowHide;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * @deprecated in favor of {@link EShapeActionValueShowHideShape}.
     */
    var EShapeActionValueShowHide = /** @class */ (function (_super) {
        __extends(EShapeActionValueShowHide, _super);
        function EShapeActionValueShowHide(subtype, condition) {
            return _super.call(this, EShapeActionValueType.SHOW_HIDE, condition, subtype) || this;
        }
        EShapeActionValueShowHide.prototype.toRuntime = function () {
            return new EShapeActionRuntimeShowHide(this);
        };
        EShapeActionValueShowHide.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, "]"));
        };
        EShapeActionValueShowHide.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueShowHide(serialized[2], condition);
        };
        return EShapeActionValueShowHide;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeShowHideLayer = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeShowHideLayer, _super);
        function EShapeActionRuntimeShowHideLayer(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.NONE) || this;
            _this._data = new Map();
            _this._layers = value.layers;
            _this._bringToFront = value.bringToFront;
            return _this;
        }
        EShapeActionRuntimeShowHideLayer.prototype.initialize = function (shape, runtime) {
            _super.prototype.initialize.call(this, shape, runtime);
            var data = this._data.get(shape);
            if (data == null) {
                data = this.newData(shape);
                if (data != null) {
                    this._data.set(shape, data);
                }
            }
        };
        EShapeActionRuntimeShowHideLayer.prototype.execute = function (shape, runtime, time) {
            var data = this._data.get(shape);
            if (data) {
                var newCondition = this.condition(shape, time, EShapeActionEnvironment);
                if (data.condition !== newCondition) {
                    data.condition = newCondition;
                    var layers = data.layers;
                    if (newCondition) {
                        if (data.bringToFront) {
                            DDiagramLayers.bringAllToFront(layers);
                            DDiagramLayers.showAll(layers);
                        }
                        else {
                            DDiagramLayers.showAll(layers);
                        }
                    }
                    else {
                        DDiagramLayers.hideAll(layers);
                    }
                }
            }
        };
        EShapeActionRuntimeShowHideLayer.prototype.newData = function (shape) {
            var layers = DDiagramLayers.toLayers(shape, this._layers);
            if (0 < layers.length) {
                return {
                    layers: layers,
                    bringToFront: this._bringToFront,
                    condition: null
                };
            }
        };
        return EShapeActionRuntimeShowHideLayer;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHideLayer = /** @class */ (function (_super) {
        __extends(EShapeActionValueShowHideLayer, _super);
        function EShapeActionValueShowHideLayer(condition, layers, bringToFront) {
            var _this = _super.call(this, EShapeActionValueType.SHOW_HIDE, condition, EShapeActionValueShowHideType.LAYER) || this;
            _this.layers = layers;
            _this.bringToFront = bringToFront;
            return _this;
        }
        EShapeActionValueShowHideLayer.prototype.toRuntime = function () {
            return new EShapeActionRuntimeShowHideLayer(this);
        };
        EShapeActionValueShowHideLayer.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var layersId = this.serializeLayers(manager);
            var bringToFrontId = this.bringToFront ? 1 : 0;
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(layersId, ",").concat(bringToFrontId, "]"));
        };
        EShapeActionValueShowHideLayer.prototype.serializeLayers = function (manager) {
            var layers = this.layers;
            var result = "[";
            var delimiter = "";
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                result += delimiter + layers[i];
                delimiter = ",";
            }
            result += "]";
            return manager.addResource(result);
        };
        EShapeActionValueShowHideLayer.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var layers = this.deserializeLayers(serialized[3], manager);
            var bringToFront = !!serialized[4];
            return new EShapeActionValueShowHideLayer(condition, layers, bringToFront);
        };
        EShapeActionValueShowHideLayer.deserializeLayers = function (target, manager) {
            var resources = manager.resources;
            var resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                return JSON.parse(resources[target]);
            }
            return [];
        };
        return EShapeActionValueShowHideLayer;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeShowHideShape = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeShowHideShape, _super);
        function EShapeActionRuntimeShowHideShape(value) {
            return _super.call(this, value, EShapeRuntimeReset.VISIBILITY) || this;
        }
        EShapeActionRuntimeShowHideShape.prototype.initialize = function (shape, runtime) {
            _super.prototype.initialize.call(this, shape, runtime);
        };
        EShapeActionRuntimeShowHideShape.prototype.execute = function (shape, runtime, time) {
            shape.visible = this.condition(shape, time, EShapeActionEnvironment);
            runtime.written |= this.reset;
        };
        return EShapeActionRuntimeShowHideShape;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueShowHideShape = /** @class */ (function (_super) {
        __extends(EShapeActionValueShowHideShape, _super);
        function EShapeActionValueShowHideShape(condition) {
            return _super.call(this, EShapeActionValueType.SHOW_HIDE, condition, EShapeActionValueShowHideType.SHAPE) || this;
        }
        EShapeActionValueShowHideShape.prototype.toRuntime = function () {
            return new EShapeActionRuntimeShowHideShape(this);
        };
        EShapeActionValueShowHideShape.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, "]"));
        };
        EShapeActionValueShowHideShape.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueShowHideShape(condition);
        };
        return EShapeActionValueShowHideShape;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMove = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMove, _super);
        function EShapeActionRuntimeTransformMove(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.amount = EShapeActionExpressions.ofNumber(value.amount);
            return _this;
        }
        return EShapeActionRuntimeTransformMove;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveAbsoluteX = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveAbsoluteX, _super);
        function EShapeActionRuntimeTransformMoveAbsoluteX(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_X) || this;
        }
        EShapeActionRuntimeTransformMoveAbsoluteX.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                shape.transform.position.x = amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveAbsoluteX;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveAbsoluteY = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveAbsoluteY, _super);
        function EShapeActionRuntimeTransformMoveAbsoluteY(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_Y) || this;
        }
        EShapeActionRuntimeTransformMoveAbsoluteY.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                shape.transform.position.y = amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveAbsoluteY;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveForwardOrBackward = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveForwardOrBackward, _super);
        function EShapeActionRuntimeTransformMoveForwardOrBackward(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformMoveForwardOrBackward.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var transform = shape.transform;
                var position = transform.position;
                var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                var oldPositionX = writtenPositionX ? position.x : runtime.x;
                var oldPositionY = writtenPositionY ? position.y : runtime.y;
                shape.updateTransform();
                var localTransform = transform.localTransform;
                position.set(oldPositionX - localTransform.c * amount, oldPositionY - localTransform.d * amount);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveForwardOrBackward;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveLeftOrRight = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveLeftOrRight, _super);
        function EShapeActionRuntimeTransformMoveLeftOrRight(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformMoveLeftOrRight.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var transform = shape.transform;
                var position = transform.position;
                var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                var oldPositionX = writtenPositionX ? position.x : runtime.x;
                var oldPositionY = writtenPositionY ? position.y : runtime.y;
                shape.updateTransform();
                var localTransform = transform.localTransform;
                position.set(oldPositionX + localTransform.a * amount, oldPositionY + localTransform.b * amount);
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveLeftOrRight;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveRelativeX = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveRelativeX, _super);
        function EShapeActionRuntimeTransformMoveRelativeX(value) {
            return _super.call(this, value, EShapeRuntimeReset.POSITION_X) || this;
        }
        EShapeActionRuntimeTransformMoveRelativeX.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                var position = shape.transform.position;
                var oldPositionX = writtenPositionX ? position.x : runtime.x;
                position.x = oldPositionX + amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveRelativeX;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformMoveRelativeY = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformMoveRelativeY, _super);
        function EShapeActionRuntimeTransformMoveRelativeY(action) {
            return _super.call(this, action, EShapeRuntimeReset.POSITION_Y) || this;
        }
        EShapeActionRuntimeTransformMoveRelativeY.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                var position = shape.transform.position;
                var oldPositionY = writtenPositionY ? position.y : runtime.y;
                position.y = oldPositionY + amount;
                runtime.written |= this.reset;
            }
        };
        return EShapeActionRuntimeTransformMoveRelativeY;
    }(EShapeActionRuntimeTransformMove));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueOpetyped = /** @class */ (function (_super) {
        __extends(EShapeActionValueOpetyped, _super);
        function EShapeActionValueOpetyped(type, condition, subtype, opetype) {
            var _this = _super.call(this, type, condition, subtype) || this;
            _this.opetype = opetype;
            return _this;
        }
        EShapeActionValueOpetyped.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueOpetyped &&
                this.opetype === value.opetype);
        };
        return EShapeActionValueOpetyped;
    }(EShapeActionValueSubtyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformMoveType = {
        RELATIVE_X: 0,
        RELATIVE_Y: 1,
        ABSOLUTE_X: 2,
        ABSOLUTE_Y: 3,
        FORWARD_OR_BACKWARD: 4,
        LEFT_OR_RIGHT: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformType = {
        RESIZE: 0,
        MOVE: 1,
        ROTATE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformMove = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformMove, _super);
        function EShapeActionValueTransformMove(opetype, condition, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.MOVE, opetype) || this;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformMove.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueTransformMove &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformMove.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformMoveType.ABSOLUTE_X:
                    return new EShapeActionRuntimeTransformMoveAbsoluteX(this);
                case EShapeActionValueTransformMoveType.ABSOLUTE_Y:
                    return new EShapeActionRuntimeTransformMoveAbsoluteY(this);
                case EShapeActionValueTransformMoveType.FORWARD_OR_BACKWARD:
                    return new EShapeActionRuntimeTransformMoveForwardOrBackward(this);
                case EShapeActionValueTransformMoveType.LEFT_OR_RIGHT:
                    return new EShapeActionRuntimeTransformMoveLeftOrRight(this);
                case EShapeActionValueTransformMoveType.RELATIVE_X:
                    return new EShapeActionRuntimeTransformMoveRelativeX(this);
                case EShapeActionValueTransformMoveType.RELATIVE_Y:
                    return new EShapeActionRuntimeTransformMoveRelativeY(this);
            }
        };
        EShapeActionValueTransformMove.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var amountId = manager.addResource(this.amount);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.opetype, ",").concat(amountId, "]"));
        };
        EShapeActionValueTransformMove.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueTransformMove(serialized[3], condition, amount);
        };
        return EShapeActionValueTransformMove;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformResizeType = {
        RELATIVE_SIZE: 0,
        RELATIVE_HEIGHT: 1,
        RELATIVE_WIDTH: 2,
        ABSOLUTE_SIZE: 3,
        ABSOLUTE_HEIGHT: 4,
        ABSOLUTE_WIDTH: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResize = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResize, _super);
        function EShapeActionRuntimeTransformResize(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            switch (value.opetype) {
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    _this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    _this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    _this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    _this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    _this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    _this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                default:
                    _this.size = EShapeActionExpressions.ONE;
            }
            return _this;
        }
        EShapeActionRuntimeTransformResize.prototype.adjustPosition = function (shape, runtime, dsx, dsy, originX, originY) {
            var dx = (-0.5 + originX) * dsx;
            var dy = (-0.5 + originY) * dsy;
            shape.updateTransform();
            var transform = shape.transform;
            var position = transform.position;
            var localTransform = transform.localTransform;
            var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
            var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
            var oldPositionX = writtenPositionX ? position.x : runtime.x;
            var oldPositionY = writtenPositionY ? position.y : runtime.y;
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * localTransform.a + dy * localTransform.c, oldPositionY + dx * localTransform.b + dy * localTransform.d);
        };
        return EShapeActionRuntimeTransformResize;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeHeightAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeHeightAbsolute, _super);
        function EShapeActionRuntimeTransformResizeHeightAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.HEIGHT | EShapeRuntimeReset.POSITION) || this;
            _this.origin = value.originY;
            return _this;
        }
        EShapeActionRuntimeTransformResizeHeightAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeAbsolute = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.y = toSizeNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        };
        return EShapeActionRuntimeTransformResizeHeightAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeHeightRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeHeightRelative, _super);
        function EShapeActionRuntimeTransformResizeHeightRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.HEIGHT | EShapeRuntimeReset.POSITION) || this;
            _this.origin = value.originY;
            return _this;
        }
        EShapeActionRuntimeTransformResizeHeightRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeRelative = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.y = toSizeNormalized(oldSizeY * sizeRelative);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        };
        return EShapeActionRuntimeTransformResizeHeightRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeSizeAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeSizeAbsolute, _super);
        function EShapeActionRuntimeTransformResizeSizeAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.SIZE | EShapeRuntimeReset.POSITION) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            return _this;
        }
        EShapeActionRuntimeTransformResizeSizeAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeAbsolute = toSizeNormalized(this.size(shape, time, EShapeActionEnvironment));
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                var oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.set(sizeAbsolute, sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformResizeSizeAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeSizeRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeSizeRelative, _super);
        function EShapeActionRuntimeTransformResizeSizeRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.SIZE | EShapeRuntimeReset.POSITION) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            return _this;
        }
        EShapeActionRuntimeTransformResizeSizeRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeRelative = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                var oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                var oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.set(toSizeNormalized(oldSizeX * sizeRelative), toSizeNormalized(oldSizeY * sizeRelative));
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformResizeSizeRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeWidthAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeWidthAbsolute, _super);
        function EShapeActionRuntimeTransformResizeWidthAbsolute(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.WIDTH | EShapeRuntimeReset.POSITION) || this;
            _this.origin = value.originX;
            return _this;
        }
        EShapeActionRuntimeTransformResizeWidthAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeAbsolute = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                size.x = toSizeNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        };
        return EShapeActionRuntimeTransformResizeWidthAbsolute;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformResizeWidthRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformResizeWidthRelative, _super);
        function EShapeActionRuntimeTransformResizeWidthRelative(value) {
            var _this = _super.call(this, value, EShapeRuntimeReset.WIDTH | EShapeRuntimeReset.POSITION) || this;
            _this.origin = value.originX;
            return _this;
        }
        EShapeActionRuntimeTransformResizeWidthRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var sizeRelative = this.size(shape, time, EShapeActionEnvironment);
                var size = shape.size;
                var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                var oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                size.x = toSizeNormalized(oldSizeX * sizeRelative);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        };
        return EShapeActionRuntimeTransformResizeWidthRelative;
    }(EShapeActionRuntimeTransformResize));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformResize = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformResize, _super);
        function EShapeActionValueTransformResize(opetype, condition, originX, originY, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.RESIZE, opetype) || this;
            _this.originX = originX;
            _this.originY = originY;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformResize.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueTransformResize &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformResize.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeAbsolute(this);
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeRelative(this);
            }
        };
        EShapeActionValueTransformResize.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var amountId = manager.addResource(this.amount);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.opetype, ",").concat(this.originX, ",").concat(this.originY, ",").concat(amountId, "]"));
        };
        EShapeActionValueTransformResize.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformResize(serialized[3], condition, serialized[4], serialized[5], amount);
        };
        return EShapeActionValueTransformResize;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotate = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotate, _super);
        function EShapeActionRuntimeTransformRotate(value, reset) {
            var _this = _super.call(this, value, reset) || this;
            _this.originX = value.originX;
            _this.originY = value.originY;
            _this.amount = EShapeActionExpressions.ofNumber("(".concat(value.amount, ") * (Math.PI / 180)"));
            return _this;
        }
        EShapeActionRuntimeTransformRotate.prototype.adjustPosition = function (shape, runtime, oldRotation, newRotation, originX, originY) {
            var writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
            var writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
            var dx = (-0.5 + originX) * (writtenWidth ? shape.size.x : runtime.sizeX);
            var dy = (-0.5 + originY) * (writtenHeight ? shape.size.y : runtime.sizeY);
            var s = Math.sin(oldRotation) - Math.sin(newRotation);
            var c = Math.cos(oldRotation) - Math.cos(newRotation);
            var position = shape.transform.position;
            var writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
            var writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
            var oldPositionX = writtenPositionX ? position.x : runtime.x;
            var oldPositionY = writtenPositionY ? position.y : runtime.y;
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * c - dy * s, oldPositionY + dx * s + dy * c);
        };
        return EShapeActionRuntimeTransformRotate;
    }(EShapeActionRuntimeConditional));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotateAbsolute = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotateAbsolute, _super);
        function EShapeActionRuntimeTransformRotateAbsolute(value) {
            return _super.call(this, value, EShapeRuntimeReset.ROTATION | EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformRotateAbsolute.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var transform = shape.transform;
                var writtenRotation = !!(runtime.written & EShapeRuntimeReset.ROTATION);
                var oldRotation = writtenRotation ? transform.rotation : runtime.rotation;
                transform.rotation = amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, amount, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformRotateAbsolute;
    }(EShapeActionRuntimeTransformRotate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionRuntimeTransformRotateRelative = /** @class */ (function (_super) {
        __extends(EShapeActionRuntimeTransformRotateRelative, _super);
        function EShapeActionRuntimeTransformRotateRelative(value) {
            return _super.call(this, value, EShapeRuntimeReset.ROTATION | EShapeRuntimeReset.POSITION) || this;
        }
        EShapeActionRuntimeTransformRotateRelative.prototype.execute = function (shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                var amount = this.amount(shape, time, EShapeActionEnvironment);
                var transform = shape.transform;
                var writtenRotation = !!(runtime.written & EShapeRuntimeReset.ROTATION);
                var oldRotation = writtenRotation ? transform.rotation : runtime.rotation;
                transform.rotation = oldRotation + amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, transform.rotation, this.originX, this.originY);
            }
        };
        return EShapeActionRuntimeTransformRotateRelative;
    }(EShapeActionRuntimeTransformRotate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformRotateType = {
        RELATIVE: 0,
        ABSOLUTE: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueTransformRotate = /** @class */ (function (_super) {
        __extends(EShapeActionValueTransformRotate, _super);
        function EShapeActionValueTransformRotate(opetype, condition, originX, originY, amount) {
            var _this = _super.call(this, EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.ROTATE, opetype) || this;
            _this.originX = originX;
            _this.originY = originY;
            _this.amount = amount;
            return _this;
        }
        EShapeActionValueTransformRotate.prototype.isEquals = function (value) {
            return (_super.prototype.isEquals.call(this, value) &&
                value instanceof EShapeActionValueTransformRotate &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        };
        EShapeActionValueTransformRotate.prototype.toRuntime = function () {
            switch (this.opetype) {
                case EShapeActionValueTransformRotateType.ABSOLUTE:
                    return new EShapeActionRuntimeTransformRotateAbsolute(this);
                case EShapeActionValueTransformRotateType.RELATIVE:
                    return new EShapeActionRuntimeTransformRotateRelative(this);
            }
        };
        EShapeActionValueTransformRotate.prototype.serialize = function (manager) {
            var conditionId = manager.addResource(this.condition);
            var amountId = manager.addResource(this.amount);
            return manager.addResource("[".concat(this.type, ",").concat(conditionId, ",").concat(this.subtype, ",").concat(this.opetype, ",").concat(this.originX, ",").concat(this.originY, ",").concat(amountId, "]"));
        };
        EShapeActionValueTransformRotate.deserialize = function (serialized, manager) {
            var condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            var amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformRotate(serialized[3], condition, serialized[4], serialized[5], amount);
        };
        return EShapeActionValueTransformRotate;
    }(EShapeActionValueOpetyped));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeActionValue = function (serialized, manager) {
        switch (serialized[0]) {
            case EShapeActionValueType.SHOW_HIDE:
                switch (serialized[2]) {
                    case EShapeActionValueShowHideType.SHAPE_SHOW:
                    case EShapeActionValueShowHideType.SHAPE_HIDE:
                        return EShapeActionValueShowHide.deserialize(serialized, manager);
                    case EShapeActionValueShowHideType.SHAPE:
                        return EShapeActionValueShowHideShape.deserialize(serialized, manager);
                    case EShapeActionValueShowHideType.LAYER:
                        return EShapeActionValueShowHideLayer.deserialize(serialized, manager);
                }
                break;
            case EShapeActionValueType.BLINK:
                return EShapeActionValueBlink.deserialize(serialized, manager);
            case EShapeActionValueType.CHANGE_COLOR:
            case EShapeActionValueType.CHANGE_COLOR_LEGACY:
                switch (serialized[3]) {
                    case EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA:
                    case EShapeActionValueChangeColorTarget.COLOR:
                    case EShapeActionValueChangeColorTarget.ALPHA:
                        return EShapeActionValueChangeColor.deserialize(serialized, manager);
                    case EShapeActionValueChangeColorTarget.CODE:
                        return EShapeActionValueChangeColorCode.deserialize(serialized, manager);
                    case EShapeActionValueChangeColorTarget.BRIGHTNESS:
                        return EShapeActionValueChangeColorBrightness.deserialize(serialized, manager);
                }
                break;
            case EShapeActionValueType.CHANGE_TEXT:
                return EShapeActionValueChangeText.deserialize(serialized, manager);
            case EShapeActionValueType.CHANGE_CURSOR:
                return EShapeActionValueChangeCursor.deserialize(serialized, manager);
            case EShapeActionValueType.EMIT_EVENT:
                return EShapeActionValueEmitEvent.deserialize(serialized, manager);
            case EShapeActionValueType.OPEN:
                switch (serialized[2]) {
                    case EShapeActionValueOpenType.DIALOG_TEXT:
                    case EShapeActionValueOpenType.DIALOG_INTEGER:
                    case EShapeActionValueOpenType.DIALOG_REAL:
                    case EShapeActionValueOpenType.DIALOG_BOOLEAN:
                    case EShapeActionValueOpenType.DIALOG_DATE:
                    case EShapeActionValueOpenType.DIALOG_TIME:
                    case EShapeActionValueOpenType.DIALOG_DATETIME:
                    case EShapeActionValueOpenType.DIALOG:
                        if (EShapeActionValueOpenDialogType.EXTENSION <= serialized[6]) {
                            return EShapeActionValueOpenDialogExtension.deserialize(serialized, manager);
                        }
                        return EShapeActionValueOpenDialog.deserialize(serialized, manager);
                    case EShapeActionValueOpenType.DIAGRAM_LEGACY:
                    case EShapeActionValueOpenType.PAGE_LEGACY:
                    case EShapeActionValueOpenType.PAGE_INPLACE_LEGACY:
                    case EShapeActionValueOpenType.DIAGRAM:
                    case EShapeActionValueOpenType.PAGE:
                        return EShapeActionValueOpen.deserialize(serialized, manager);
                    default:
                        if (EShapeActionValueOpenType.EXTENSION <= serialized[2]) {
                            return EShapeActionValueOpenExtension.deserialize(serialized, manager);
                        }
                        break;
                }
                break;
            case EShapeActionValueType.TRANSFORM:
                switch (serialized[2]) {
                    case EShapeActionValueTransformType.MOVE:
                        return EShapeActionValueTransformMove.deserialize(serialized, manager);
                    case EShapeActionValueTransformType.RESIZE:
                        return EShapeActionValueTransformResize.deserialize(serialized, manager);
                    case EShapeActionValueTransformType.ROTATE:
                        return EShapeActionValueTransformRotate.deserialize(serialized, manager);
                }
                break;
            case EShapeActionValueType.GESTURE:
                return EShapeActionValueGesture.deserialize(serialized, manager);
            case EShapeActionValueType.MISC:
                switch (serialized[2]) {
                    case EShapeActionValueMiscType.GESTURE:
                        return EShapeActionValueGesture.deserialize(serialized, manager);
                    case EShapeActionValueMiscType.SHOW_HIDE_LAYER:
                        return EShapeActionValueShowHideLayer.deserialize(serialized, manager);
                    case EShapeActionValueMiscType.GESTURE_LAYER:
                        return EShapeActionValueGesture.deserialize(serialized, manager);
                    case EShapeActionValueMiscType.EXECUTE:
                        return EShapeActionValueMiscExecute.deserialize(serialized, manager);
                    default:
                        return EShapeActionValueMisc.deserialize(serialized, manager);
                }
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueDeserializers = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSerialized = function (resource) {
        try {
            var parsed = JSON.parse(resource);
            if (isArray(parsed) && 2 <= parsed.length) {
                return parsed;
            }
            return null;
        }
        catch (e) {
            return null;
        }
    };
    var deserializeActionValues = function (indices, manager, result) {
        var action = result.action;
        var resources = manager.resources;
        for (var i = 0, imax = indices.length; i < imax; ++i) {
            var index = indices[i];
            var saved = manager.getAction(index);
            if (saved != null) {
                action.add(saved);
            }
            else {
                var resource = resources[index];
                if (resource != null) {
                    var serialized = toSerialized(resource);
                    if (serialized != null && 0 < serialized.length) {
                        var type = serialized[0];
                        var deserializer = EShapeActionValueType.EXTENSION <= type
                            ? EShapeActionValueDeserializers[type]
                            : deserializeActionValue;
                        if (deserializer != null) {
                            var deserialized = deserializer(serialized, manager);
                            if (deserialized != null) {
                                manager.setAction(index, deserialized);
                                action.add(deserialized);
                            }
                        }
                    }
                }
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var parse = function (target) {
        try {
            return JSON.parse(target);
        }
        catch (e) {
            return null;
        }
    };
    var toGradientLike = function (target) {
        var parsed = parse(target);
        if (parsed == null || parsed.length < 7) {
            return undefined;
        }
        else {
            var direction = parsed[0];
            var points = [];
            for (var i = 1, imax = parsed.length; i < imax; i += 3) {
                points.push({
                    color: parsed[i + 0],
                    alpha: parsed[i + 1],
                    position: parsed[i + 2]
                });
            }
            return {
                points: points,
                direction: direction
            };
        }
    };
    var deserializeGradient = function (index, manager, result) {
        var resources = manager.resources;
        if (0 <= index && index < resources.length) {
            var serialized = resources[index];
            if (isString(serialized)) {
                result.gradient = toGradientLike(serialized);
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var imageElementCache = {};
    var toImageElement = function (dataUrl) {
        var cachedImageElement = imageElementCache[dataUrl];
        if (cachedImageElement != null) {
            if (cachedImageElement instanceof HTMLImageElement) {
                return Promise.resolve(cachedImageElement);
            }
            else {
                return cachedImageElement;
            }
        }
        else {
            var result = new Promise(function (resolve, reject) {
                var imageElement = document.createElement("img");
                imageElement.onload = function () {
                    imageElementCache[dataUrl] = imageElement;
                    resolve(imageElement);
                };
                imageElement.onabort = imageElement.onerror = function () {
                    reject();
                };
                imageElement.src = dataUrl;
            });
            imageElementCache[dataUrl] = result;
            return result;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeChildren = function (serializeds, manager, result) {
        if (0 < serializeds.length) {
            var deserializeds = [];
            for (var i = 0, imax = serializeds.length; i < imax; ++i) {
                deserializeds.push(deserialize(serializeds[i], manager));
            }
            return Promise.all(deserializeds).then(function (children) {
                result.children = children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].parent = result;
                }
                result.onChildTransformChange();
                result.toDirty();
                return result;
            });
        }
        return null;
    };
    var deserializeImage$1 = function (index, manager, result) {
        var resources = manager.resources;
        if (0 <= index && index < resources.length) {
            var imageSrc = resources[index];
            if (isString(imageSrc)) {
                return toImageElement(imageSrc).then(function (imageElement) {
                    result.image = imageElement;
                    return result;
                });
            }
        }
        return null;
    };
    var deserializeBase = function (item, manager, result) {
        var resources = manager.resources;
        result.id = resources[item[1]] || "";
        var transform = result.transform;
        transform.position.set(item[2], item[3]);
        transform.rotation = item[6];
        transform.skew.set(item[7], item[7]);
        transform.pivot.set(item[21], item[22]);
        result.size.set(toSizeNormalized(item[4]), toSizeNormalized(item[5]));
        result.fill.deserialize(item[8], manager);
        result.stroke.deserialize(item[9], manager);
        var item10 = item[10];
        result.cursor = 0 <= item10 ? resources[item10] : undefined;
        result.text.deserialize(item[11], manager);
        result.data.deserialize(item[12], manager);
        result.radius = item[13];
        result.corner = item[14];
        var item23 = item[23];
        result.interactive = !!(item23 & 1);
        var state = result.state;
        state.isFocusable = !(item23 & 2);
        state.isActive = !!(item23 & 4);
        var item24 = item[24];
        result.shortcut = 0 <= item24 ? resources[item24] : undefined;
        var item25 = item[25];
        result.title = 0 <= item25 ? resources[item25] : undefined;
        var item26 = item[26];
        result.uuid = item26 != null ? item26 : 0;
        var item27 = item[27];
        var item28 = item[28];
        var item29 = item[29];
        var hasItem27 = item27 != null && item27 !== EShapeCapability.NONE;
        var hasItem28 = item28 != null && item28 !== EShapeCapability.NONE;
        var hasItem29 = item29 != null && item29 !== EShapeCapability.NONE;
        if (hasItem27 || hasItem28 || hasItem29) {
            result.capability.set(item27, item28, item29);
        }
        var children = deserializeChildren(item[20], manager, result);
        deserializeActionValues(item[17], manager, result);
        deserializeGradient(item[19], manager, result);
        var image = deserializeImage$1(item[18], manager, result);
        if (children != null) {
            if (image != null) {
                return Promise.all([children, image]).then(function () {
                    return result;
                });
            }
            else {
                return children;
            }
        }
        else {
            if (image != null) {
                return image;
            }
            else {
                return result;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeBar = function (item, manager, shape) {
        shape = shape || new EShapeBar();
        var result = deserializeBase(item, manager, shape);
        shape.points.deserialize(item[15], manager);
        var style = shape.points.style;
        var mask = EShapePointsStyle.NON_SCALING_MASK |
            EShapePointsStyle.DOTTED_MASK |
            EShapePointsStyle.DASHED_MASK;
        var deprecated = style & mask;
        if (deprecated) {
            shape.points.style &= ~mask;
            shape.stroke.style |= deprecated;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeBar = function () {
        EShapeUploadeds[EShapeType.BAR] = createBarUploaded;
        EShapeDeserializers[EShapeType.BAR] = deserializeBar;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRuntimes = {};

    var RECTANGLE_ROUNDED_VERTEX_COUNT = 36;
    var RECTANGLE_ROUNDED_INDEX_COUNT = 24;
    var RECTANGLE_ROUNDED_WORLD_SIZE = [0, 0, 0];
    var RECTANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    var buildRectangleRoundedIndex = function (indices, voffset, ioffset) {
        // Top-left corner
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 2;
        // Top-right corner
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        // Bottom-left corner
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 10;
        // Bottom-right corner
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 15;
        indices[++ii] = voffset + 14;
        // Top edge
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 21;
        // Upper middle
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 23;
        indices[++ii] = voffset + 26;
        indices[++ii] = voffset + 23;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 26;
        // Lower middle
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 28;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 28;
        indices[++ii] = voffset + 26;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 32;
        indices[++ii] = voffset + 30;
        // Bottom edge
        indices[++ii] = voffset + 29;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 33;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 33;
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 31;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 31;
        indices[++ii] = voffset + 35;
        indices[++ii] = voffset + 34;
    };
    var buildRectangleRoundedVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        //  0   1       4   5
        // |---|       |---|
        // |2  |3      |6  |7
        // |---|       |---|
        //
        //
        //
        //
        //
        // |---|       |---|
        // |8  |9      |12 |13
        // |---|       |---|
        //  10  11      14  15
        //
        //
        //      16  17  18       <-- Top edge
        //     |---|---|
        //  19 |20 |21 |22  23   <-- Top
        // |---|---|---|---|
        // |       |       |
        // |24   25|26     |27   <-- Middle
        // |-------|-------|
        // |       |       |
        // |       |       |
        // |---|---|---|---|
        //  28 |29 |30 |31  32   <-- Bottom
        //     |---|---|
        //      33  34  35       <-- Bottom edge
        //
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var ax = Math.abs(sx);
        var ay = Math.abs(sy);
        var a = radius * Math.min(ax, ay);
        var rx = a / ax;
        var ry = a / ay;
        var work = RECTANGLE_ROUNDED_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x2 = work.x;
        var y2 = work.y;
        var dxh = x2 - x0;
        var dyh = y2 - y0;
        var dxhr = rx * dxh;
        var dyhr = rx * dyh;
        var x1 = x0 + dxhr;
        var y1 = y0 + dyhr;
        var x4 = x2 + dxh;
        var y4 = y2 + dyh;
        var x3 = x4 - dxhr;
        var y3 = y4 - dyhr;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var x11 = work.x;
        var y11 = work.y;
        var dxv = x11 - x2;
        var dyv = y11 - y2;
        var dxvr = ry * dxv;
        var dyvr = ry * dyv;
        var x7 = x2 + dxvr;
        var y7 = y2 + dyvr;
        var x5 = x7 - dxh;
        var y5 = y7 - dyh;
        var x6 = x5 + dxhr;
        var y6 = y5 + dyhr;
        var x9 = x7 + dxh;
        var y9 = y7 + dyh;
        var x8 = x9 - dxhr;
        var y8 = y9 - dyhr;
        var x10 = x11 - dxh;
        var y10 = y11 - dyh;
        var x12 = x11 + dxh;
        var y12 = y11 + dyh;
        var x20 = x11 + dxv;
        var y20 = y11 + dyv;
        var x15 = x20 - dxvr;
        var y15 = y20 - dyvr;
        var x13 = x15 - dxh;
        var y13 = y15 - dyh;
        var x14 = x13 + dxhr;
        var y14 = y13 + dyhr;
        var x17 = x15 + dxh;
        var y17 = y15 + dyh;
        var x16 = x17 - dxhr;
        var y16 = y17 - dyhr;
        var x18 = x20 - dxh;
        var y18 = y20 - dyh;
        var x19 = x18 + dxhr;
        var y19 = y18 + dyhr;
        var x22 = x20 + dxh;
        var y22 = y20 + dyh;
        var x21 = x22 - dxhr;
        var y21 = y22 - dyhr;
        // World size
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x2, y2);
        worldSize[2] = toLength(x0, y0, x10, y10);
        // Vertices
        var iv = voffset * 2 - 1;
        // Top-left corner
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        // Top-right corner
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
        // Bottom-left corner
        vertices[++iv] = x13;
        vertices[++iv] = y13;
        vertices[++iv] = x14;
        vertices[++iv] = y14;
        vertices[++iv] = x18;
        vertices[++iv] = y18;
        vertices[++iv] = x19;
        vertices[++iv] = y19;
        // Bottom-right corner
        vertices[++iv] = x16;
        vertices[++iv] = y16;
        vertices[++iv] = x17;
        vertices[++iv] = y17;
        vertices[++iv] = x21;
        vertices[++iv] = y21;
        vertices[++iv] = x22;
        vertices[++iv] = y22;
        // Top edge
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        // Top
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
        // Middle
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        // Bottom
        vertices[++iv] = x13;
        vertices[++iv] = y13;
        vertices[++iv] = x14;
        vertices[++iv] = y14;
        vertices[++iv] = x15;
        vertices[++iv] = y15;
        vertices[++iv] = x16;
        vertices[++iv] = y16;
        vertices[++iv] = x17;
        vertices[++iv] = y17;
        // Bottom edge
        vertices[++iv] = x19;
        vertices[++iv] = y19;
        vertices[++iv] = x20;
        vertices[++iv] = y20;
        vertices[++iv] = x21;
        vertices[++iv] = y21;
    };
    var buildRectangleRoundedClipping = function (clippings, voffset, corner, worldSize) {
        var ic = voffset * 3 - 1;
        var rxc = 1 - worldSize[0] / worldSize[1];
        var ryc = 1 - worldSize[0] / worldSize[2];
        // Top-left corner
        if (corner & EShapeCorner.TOP_LEFT) {
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
        }
        else {
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
        }
        // Top-right corner
        if (corner & EShapeCorner.TOP_RIGHT) {
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
        }
        else {
            clippings[++ic] = rxc;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
        }
        else {
            clippings[++ic] = 1;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
        }
        else {
            clippings[++ic] = rxc;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = ryc;
            clippings[++ic] = 0;
            clippings[++ic] = rxc;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
        }
        // Top edge
        clippings[++ic] = rxc;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        // Top
        clippings[++ic] = 1;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        // Middle
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        // Bottom
        clippings[++ic] = 1;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = ryc;
        clippings[++ic] = 0;
        // Bottom edge
        clippings[++ic] = rxc;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = rxc;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
    };
    var buildRectangleRoundedStep = function (steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var sc = worldSize[0];
        var sx = worldSize[1];
        var sy = worldSize[2];
        var rxc = Math.max(0, 1 - worldSize[0] / worldSize[1]);
        var ryc = Math.max(0, 1 - worldSize[0] / worldSize[2]);
        var wt;
        var zt;
        var bt;
        if (strokeSide & EShapeStrokeSide.TOP) {
            wt = +2;
            zt = +1;
            bt = +1 + ryc;
        }
        else {
            wt = -2;
            zt = -1;
            bt = -1 - ryc;
        }
        var wr;
        var zr;
        var br;
        if (strokeSide & EShapeStrokeSide.RIGHT) {
            wr = +2;
            zr = +1;
            br = +1 + rxc;
        }
        else {
            wr = -2;
            zr = -1;
            br = -1 - rxc;
        }
        var wb;
        var zb;
        var bb;
        if (strokeSide & EShapeStrokeSide.BOTTOM) {
            wb = +2;
            zb = +1;
            bb = +1 + ryc;
        }
        else {
            wb = -2;
            zb = -1;
            bb = -1 - ryc;
        }
        var wl;
        var zl;
        var bl;
        if (strokeSide & EShapeStrokeSide.LEFT) {
            wl = +2;
            zl = +1;
            bl = +1 + rxc;
        }
        else {
            wl = -2;
            zl = -1;
            bl = -1 - rxc;
        }
        // Top-left corner
        var is = voffset * 6 - 1;
        if (corner & EShapeCorner.TOP_LEFT) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wl;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zl;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wl;
            steps[++is] = zt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zl;
            steps[++is] = zt;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wl;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = bl;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wl;
            steps[++is] = bt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = bl;
            steps[++is] = bt;
        }
        // Top-right corner
        if (corner & EShapeCorner.TOP_RIGHT) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zr;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wr;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zr;
            steps[++is] = zt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wr;
            steps[++is] = zt;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = br;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wr;
            steps[++is] = wt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = br;
            steps[++is] = bt;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wr;
            steps[++is] = bt;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wl;
            steps[++is] = zb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zl;
            steps[++is] = zb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wl;
            steps[++is] = wb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zl;
            steps[++is] = wb;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wl;
            steps[++is] = bb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = bl;
            steps[++is] = bb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wl;
            steps[++is] = wb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = bl;
            steps[++is] = wb;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zr;
            steps[++is] = zb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wr;
            steps[++is] = zb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = zr;
            steps[++is] = wb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sc;
            steps[++is] = sc;
            steps[++is] = wr;
            steps[++is] = wb;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = br;
            steps[++is] = bb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wr;
            steps[++is] = bb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = br;
            steps[++is] = wb;
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = sx;
            steps[++is] = sy;
            steps[++is] = wr;
            steps[++is] = wb;
        }
        // Top edge
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = bl;
        steps[++is] = wt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zl;
        steps[++is] = wt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = br;
        steps[++is] = wt;
        // Top
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wl;
        steps[++is] = bt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = bl;
        steps[++is] = bt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zl;
        steps[++is] = bt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = br;
        steps[++is] = bt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wr;
        steps[++is] = bt;
        // Middle
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wl;
        steps[++is] = zt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zl;
        steps[++is] = zt;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zr;
        steps[++is] = zb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wr;
        steps[++is] = zb;
        // Bottom
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wl;
        steps[++is] = bb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = bl;
        steps[++is] = bb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zb;
        steps[++is] = bb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = br;
        steps[++is] = bb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = wr;
        steps[++is] = bb;
        // Bottom edge
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = bl;
        steps[++is] = wb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = zb;
        steps[++is] = wb;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = sx;
        steps[++is] = sy;
        steps[++is] = br;
        steps[++is] = wb;
    };
    var buildRectangleRoundedUv = function (uvs, voffset, textureUvs, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var x5 = 0.5 * (x3 + x2);
        var y5 = 0.5 * (y3 + y2);
        var ruvx = (0.5 * worldSize[0]) / worldSize[1];
        var ruvy = (0.5 * worldSize[0]) / worldSize[2];
        var d0x = ruvx * (x1 - x0);
        var d0y = ruvx * (y1 - y0);
        var d1x = ruvy * (x3 - x0);
        var d1y = ruvy * (y3 - y0);
        // UVs
        var iuv = voffset * 2 - 1;
        // Top-left corner
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = x0 + d0x;
        uvs[++iuv] = y0 + d0y;
        uvs[++iuv] = x0 + d1x;
        uvs[++iuv] = y0 + d1y;
        uvs[++iuv] = x0 + d0x + d1x;
        uvs[++iuv] = y0 + d0y + d1y;
        // Top-right corner
        uvs[++iuv] = x1 - d0x;
        uvs[++iuv] = y1 - d0y;
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = x1 - d0x + d1x;
        uvs[++iuv] = y1 - d0y + d1y;
        uvs[++iuv] = x1 + d1x;
        uvs[++iuv] = y1 + d1y;
        // Bottom-left corner
        uvs[++iuv] = x3 - d1x;
        uvs[++iuv] = y3 - d1y;
        uvs[++iuv] = x3 + d0x - d1x;
        uvs[++iuv] = y3 + d0y - d1y;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x3 + d0x;
        uvs[++iuv] = y3 + d0y;
        // Bottom-right corner
        uvs[++iuv] = x2 - d0x - d1x;
        uvs[++iuv] = y2 - d0y - d1y;
        uvs[++iuv] = x2 - d1x;
        uvs[++iuv] = y2 - d1y;
        uvs[++iuv] = x2 - d0x;
        uvs[++iuv] = y2 - d0y;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        // Top edge
        uvs[++iuv] = x0 + d0x;
        uvs[++iuv] = y0 + d0y;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x1 - d0x;
        uvs[++iuv] = y1 - d0y;
        // Top
        uvs[++iuv] = x0 + d1x;
        uvs[++iuv] = y0 + d1y;
        uvs[++iuv] = x0 + d1x + d0x;
        uvs[++iuv] = y0 + d1y + d0y;
        uvs[++iuv] = x4 + d1x;
        uvs[++iuv] = y4 + d1y;
        uvs[++iuv] = x1 + d1x - d0x;
        uvs[++iuv] = y1 + d1y - d0y;
        uvs[++iuv] = x1 + d1x;
        uvs[++iuv] = y1 + d1y;
        // Middle
        var x02 = 0.5 * (x0 + x2);
        var y02 = 0.5 * (y0 + y2);
        uvs[++iuv] = 0.5 * (x0 + x3);
        uvs[++iuv] = 0.5 * (y0 + y3);
        uvs[++iuv] = x02;
        uvs[++iuv] = y02;
        uvs[++iuv] = x02;
        uvs[++iuv] = y02;
        uvs[++iuv] = 0.5 * (x1 + x2);
        uvs[++iuv] = 0.5 * (y1 + y2);
        // Bottom
        uvs[++iuv] = x3 - d1x;
        uvs[++iuv] = y3 - d1y;
        uvs[++iuv] = x3 - d1x + d0x;
        uvs[++iuv] = y3 - d1y + d0y;
        uvs[++iuv] = x5 - d1x;
        uvs[++iuv] = y5 - d1y;
        uvs[++iuv] = x2 - d1x - d0x;
        uvs[++iuv] = y2 - d1y - d0y;
        uvs[++iuv] = x2 - d1x;
        uvs[++iuv] = y2 - d1y;
        // Bottom edge
        uvs[++iuv] = x3 + d0x;
        uvs[++iuv] = y3 + d0y;
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x2 - d0x;
        uvs[++iuv] = y2 - d0y;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderRectangleRounded = /** @class */ (function (_super) {
        __extends(BuilderRectangleRounded, _super);
        function BuilderRectangleRounded(vertexOffset, indexOffset, vertexCount, indexCount) {
            var _this = _super.call(this, vertexOffset, indexOffset, vertexCount, indexCount) || this;
            _this.radius = NaN;
            _this.corner = NaN;
            return _this;
        }
        BuilderRectangleRounded.prototype.init = function (buffer) {
            buffer.updateIndices();
            buildRectangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
        };
        BuilderRectangleRounded.prototype.update = function (buffer, shape) {
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
        };
        BuilderRectangleRounded.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var radius = shape.radius;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = corner !== this.corner;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                // Steps
                if (isVertexChanged || isCornerChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleRoundedStep(buffer.steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                }
                // Clippings
                if (isVertexChanged || isCornerChanged) {
                    buffer.updateClippings();
                    buildRectangleRoundedClipping(buffer.clippings, voffset, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                }
                // UVs
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleRoundedUv(buffer.uvs, voffset, toTextureUvs(texture), RECTANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        };
        return BuilderRectangleRounded;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectangleRoundedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = RECTANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderRectangleRounded(voffset, ioffset, vcount - tvcount, icount - ticount),
                new BuilderText(voffset + RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset + RECTANGLE_ROUNDED_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createButtonUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createRectangleRoundedUploaded(buffer, shape, voffset, ioffset, antialiasWeight);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestRectangleRounded_ = function (x, y, ax, ay, r, corner) {
        var bx0 = -ax + r;
        if (x <= bx0) {
            var by0 = -ay + r;
            if (y <= by0 && corner & EShapeCorner.TOP_LEFT) {
                // Top-left corner
                var dx = x - bx0;
                var dy = y - by0;
                return dx * dx + dy * dy <= r * r;
            }
            else {
                var by1 = +ay - r;
                if (by1 <= y && corner & EShapeCorner.BOTTOM_LEFT) {
                    // Bottom-left corner
                    var dx = x - bx0;
                    var dy = y - by1;
                    return dx * dx + dy * dy <= r * r;
                }
                else {
                    // Middle-left box
                    return -ax <= x;
                }
            }
        }
        else {
            var bx1 = +ax - r;
            if (bx1 <= x) {
                var by0 = -ay + r;
                if (y <= by0 && corner & EShapeCorner.TOP_RIGHT) {
                    // Top-right corner
                    var dx = x - bx1;
                    var dy = y - by0;
                    return dx * dx + dy * dy <= r * r;
                }
                else {
                    var by1 = +ay - r;
                    if (by1 <= y && corner & EShapeCorner.BOTTOM_RIGHT) {
                        // Bottom-right corner
                        var dx = x - bx1;
                        var dy = y - by1;
                        return dx * dx + dy * dy <= r * r;
                    }
                    else {
                        // Middle-right box
                        return x <= +ax;
                    }
                }
            }
            else {
                return -ay <= y && y <= +ay;
            }
        }
    };
    var hitTestRectangleRounded = function (shape, x, y, ax, ay, sw, ss) {
        var fill = shape.fill;
        if (fill.enable || 0 < sw) {
            var r = shape.radius * Math.min(ax, ay);
            var corner = shape.corner;
            if (hitTestRectangleRounded_(x, y, ax, ay, r, corner)) {
                if (fill.enable) {
                    return true;
                }
                else {
                    var s = sw * ss;
                    var wx = Math.max(0.0, ax - s);
                    var wy = Math.max(0.0, ay - s);
                    var wr = Math.max(0.0, r - s);
                    if (!hitTestRectangleRounded_(x, y, wx, wy, wr, corner)) {
                        var strokeSide = shape.stroke.side;
                        if (strokeSide === EShapeStrokeSide.ALL) {
                            return true;
                        }
                        else {
                            if (x <= -wx + wr) {
                                var hasLeftSide = !!(strokeSide & EShapeStrokeSide.LEFT);
                                if (y <= -wy + wr) {
                                    var hasTopSide = !!(strokeSide & EShapeStrokeSide.TOP);
                                    if (hasTopSide && hasLeftSide) {
                                        return true;
                                    }
                                    else if (hasTopSide) {
                                        return -wx <= y;
                                    }
                                    else if (hasLeftSide) {
                                        return x <= -wx;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else if (+wy - wr <= y) {
                                    var hasBottomSide = !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                    if (hasBottomSide && hasLeftSide) {
                                        return true;
                                    }
                                    else if (hasBottomSide) {
                                        return +wx <= y;
                                    }
                                    else if (hasLeftSide) {
                                        return x <= -wx;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else {
                                    return hasLeftSide;
                                }
                            }
                            else if (+wx - wr <= x) {
                                var hasRightSide = !!(strokeSide & EShapeStrokeSide.RIGHT);
                                if (y <= -wy + wr) {
                                    var hasTopSide = !!(strokeSide & EShapeStrokeSide.TOP);
                                    if (hasTopSide && hasRightSide) {
                                        return true;
                                    }
                                    else if (hasTopSide) {
                                        return -wx <= y;
                                    }
                                    else if (hasRightSide) {
                                        return +wx <= x;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else if (+wy - wr <= y) {
                                    var hasBottomSide = !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                    if (hasBottomSide && hasRightSide) {
                                        return true;
                                    }
                                    else if (hasBottomSide) {
                                        return +wx <= y;
                                    }
                                    else if (hasRightSide) {
                                        return +wx <= x;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else {
                                    return hasRightSide;
                                }
                            }
                            else {
                                if (y <= -wy + wr) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP);
                                }
                                else if (+wy - wr <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                }
                                else {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeRectangleRounded = /** @class */ (function (_super) {
        __extends(EShapeRectangleRounded, _super);
        function EShapeRectangleRounded(type) {
            if (type === void 0) { type = EShapeType.RECTANGLE_ROUNDED; }
            return _super.call(this, type) || this;
        }
        EShapeRectangleRounded.prototype.clone = function () {
            return new EShapeRectangleRounded(this.type).copy(this);
        };
        EShapeRectangleRounded.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestRectangleRounded(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeRectangleRounded;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeButton = /** @class */ (function (_super) {
        __extends(EShapeButton, _super);
        function EShapeButton(type) {
            if (type === void 0) { type = EShapeType.BUTTON; }
            var _this = _super.call(this, type) || this;
            _this._isToggle = false;
            _this._isGrouped = false;
            return _this;
        }
        Object.defineProperty(EShapeButton.prototype, "isToggle", {
            get: function () {
                return this._isToggle;
            },
            set: function (isToggle) {
                this._isToggle = isToggle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeButton.prototype, "isGrouped", {
            /**
             * All the sibling buttons whose `isGrouped` is true is considered to to be grouped.
             */
            get: function () {
                return this._isGrouped;
            },
            set: function (isGrouped) {
                this._isGrouped = isGrouped;
            },
            enumerable: false,
            configurable: true
        });
        EShapeButton.prototype.clone = function () {
            return new EShapeButton(this.type).copy(this);
        };
        EShapeButton.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            var isToggle = this._isToggle ? 1 : 0;
            var isGrouped = this._isGrouped ? 2 : 0;
            result[15] = manager.addResource("[".concat(isToggle | isGrouped, "]"));
            return result;
        };
        return EShapeButton;
    }(EShapeRectangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeButton = function (item, manager, shape) {
        shape = shape || new EShapeButton();
        var resources = manager.resources;
        var resourceId = item[15];
        if (0 <= resourceId && resourceId < resources.length) {
            var parsed = manager.getExtension(resourceId);
            if (parsed == null) {
                parsed = JSON.parse(resources[resourceId]);
                manager.setExtension(resourceId, parsed);
            }
            shape.isToggle = !!(parsed[0] & 1);
            shape.isGrouped = !!(parsed[0] & 2);
        }
        return deserializeBase(item, manager, shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeButtonRuntimeAction = /** @class */ (function (_super) {
        __extends(EShapeButtonRuntimeAction, _super);
        function EShapeButtonRuntimeAction(runtime) {
            var _this = _super.call(this, EShapeRuntimeReset.COLOR_FILL_AND_STROKE |
                EShapeRuntimeReset.COLOR_TEXT |
                EShapeRuntimeReset.COLOR_TEXT_OUTLINE |
                EShapeRuntimeReset.CURSOR) || this;
            var fill = runtime.fill;
            var fillColor = fill.color;
            var fillColorOnHovered = _this.toOnHovered(fillColor);
            var fillColorOnPressed = fillColorOnHovered * 2;
            _this._fillColor = fillColor;
            _this._fillColorDisabled = UtilRgb.toGrayscale(fillColor);
            _this._fillColorPressed = UtilRgb.darken(fillColor, fillColorOnPressed);
            _this._fillColorHovered = UtilRgb.darken(fillColor, fillColorOnHovered);
            var fillAlpha = fill.alpha;
            _this._fillAlpha = fillAlpha;
            _this._fillAlphaDisabled = fillAlpha * 0.5;
            var stroke = runtime.stroke;
            var strokeColor = stroke.color;
            var strokeColorOnHovered = _this.toOnHovered(strokeColor);
            var strokeColorOnPressed = strokeColorOnHovered * 2;
            _this._strokeColor = strokeColor;
            _this._strokeColorDisabled = UtilRgb.toGrayscale(strokeColor);
            _this._strokeColorPressed = UtilRgb.darken(strokeColor, strokeColorOnPressed);
            _this._strokeColorHovered = UtilRgb.darken(strokeColor, strokeColorOnHovered);
            var strokeAlpha = stroke.alpha;
            _this._strokeAlpha = strokeAlpha;
            _this._strokeAlphaDisabled = strokeAlpha * 0.5;
            var text = runtime.text;
            var textColor = text.color;
            _this._textColor = textColor;
            _this._textColorDisabled = UtilRgb.toGrayscale(textColor);
            var textAlpha = text.alpha;
            _this._textAlpha = textAlpha;
            _this._textAlphaDisabled = textAlpha * 0.5;
            var textOutline = text.outline;
            var textOutlineColor = textOutline.color;
            _this._textOutlineColor = textOutlineColor;
            _this._textOutlineColorDisabled = UtilRgb.toGrayscale(textOutlineColor);
            var textOutlineAlpha = textOutline.alpha;
            _this._textOutlineAlpha = textOutlineAlpha;
            _this._textOutlineAlphaDisabled = textOutlineAlpha * 0.5;
            return _this;
        }
        EShapeButtonRuntimeAction.prototype.toOnHovered = function (color) {
            var luma = UtilRgb.toLuma(color);
            if (128 <= luma) {
                var t = (luma - 128) / 127;
                return +0.15 * (1 - t) + t * 0.03;
            }
            else {
                var t = (127 - luma) / 127;
                return -0.15 * (1 - t) - t * 0.175;
            }
        };
        EShapeButtonRuntimeAction.prototype.execute = function (shape, runtime, time) {
            var state = shape.state;
            shape.fill.set(undefined, this.getFillColor(state), this.getFillAlpha(state));
            shape.stroke.set(undefined, this.getStrokeColor(state), this.getStrokeAlpha(state));
            shape.text.set(undefined, this.getTextColor(state), this.getTextAlpha(state));
            shape.text.outline.set(undefined, this.getTextOutlineColor(state), this.getTextOutlineAlpha(state));
            shape.cursor = this.getCursor(state);
            runtime.written |= this.reset;
        };
        EShapeButtonRuntimeAction.prototype.getFillColor = function (state) {
            if (state.inDisabled) {
                return this._fillColorDisabled;
            }
            else if (state.isPressed || state.isActive) {
                return this._fillColorPressed;
            }
            else if (state.isFocused || state.isHovered) {
                return this._fillColorHovered;
            }
            else {
                return this._fillColor;
            }
        };
        EShapeButtonRuntimeAction.prototype.getFillAlpha = function (state) {
            if (state.inDisabled) {
                return this._fillAlphaDisabled;
            }
            else {
                return this._fillAlpha;
            }
        };
        EShapeButtonRuntimeAction.prototype.getStrokeColor = function (state) {
            if (state.inDisabled) {
                return this._strokeColorDisabled;
            }
            else if (state.isPressed || state.isActive) {
                return this._strokeColorPressed;
            }
            else if (state.isFocused || state.isHovered) {
                return this._strokeColorHovered;
            }
            else {
                return this._strokeColor;
            }
        };
        EShapeButtonRuntimeAction.prototype.getStrokeAlpha = function (state) {
            if (state.inDisabled) {
                return this._strokeAlphaDisabled;
            }
            else {
                return this._strokeAlpha;
            }
        };
        EShapeButtonRuntimeAction.prototype.getTextColor = function (state) {
            if (state.inDisabled) {
                return this._textColorDisabled;
            }
            else {
                return this._textColor;
            }
        };
        EShapeButtonRuntimeAction.prototype.getTextAlpha = function (state) {
            if (state.inDisabled) {
                return this._textAlphaDisabled;
            }
            else {
                return this._textAlpha;
            }
        };
        EShapeButtonRuntimeAction.prototype.getTextOutlineColor = function (state) {
            if (state.inDisabled) {
                return this._textOutlineColorDisabled;
            }
            else {
                return this._textOutlineColor;
            }
        };
        EShapeButtonRuntimeAction.prototype.getTextOutlineAlpha = function (state) {
            if (state.inDisabled) {
                return this._textOutlineAlphaDisabled;
            }
            else {
                return this._textOutlineAlpha;
            }
        };
        EShapeButtonRuntimeAction.prototype.getCursor = function (state) {
            if (state.isActionable) {
                return "pointer";
            }
            return "";
        };
        return EShapeButtonRuntimeAction;
    }(EShapeActionRuntimeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeButtonRuntimeActionToggle = /** @class */ (function (_super) {
        __extends(EShapeButtonRuntimeActionToggle, _super);
        function EShapeButtonRuntimeActionToggle(runtime) {
            var _this = _super.call(this, EShapeRuntimeReset.COLOR_FILL_AND_STROKE |
                EShapeRuntimeReset.COLOR_TEXT |
                EShapeRuntimeReset.COLOR_TEXT_OUTLINE |
                EShapeRuntimeReset.CURSOR) || this;
            var fill = runtime.fill;
            var fillColorActive = fill.color;
            _this._fillColorActive = fillColorActive;
            var fillColorActiveOnHovered = _this.toOnHovered(fillColorActive);
            var fillColorActiveOnPressed = fillColorActiveOnHovered * 2;
            _this._fillColorActivePressed = UtilRgb.darken(fillColorActive, fillColorActiveOnPressed);
            _this._fillColorActiveHovered = UtilRgb.darken(fillColorActive, fillColorActiveOnHovered);
            var fillColor = 0xe7e5e7;
            _this._fillColor = fillColor;
            var fillColorOnHovered = _this.toOnHovered(fillColor);
            var fillColorOnPressed = fillColorOnHovered * 2;
            _this._fillColorPressed = UtilRgb.darken(fillColor, fillColorOnPressed);
            _this._fillColorHovered = UtilRgb.darken(fillColor, fillColorOnHovered);
            var fillAlpha = fill.alpha;
            _this._fillAlpha = fillAlpha;
            _this._fillAlphaDisabled = fillAlpha * 0.5;
            var stroke = runtime.stroke;
            var strokeColorActive = stroke.color;
            _this._strokeColorActive = strokeColorActive;
            var strokeColorActiveOnHovered = _this.toOnHovered(strokeColorActive);
            var strokeColorActiveOnPressed = strokeColorActiveOnHovered * 2;
            _this._strokeColorActivePressed = UtilRgb.darken(strokeColorActive, strokeColorActiveOnPressed);
            _this._strokeColorActiveHovered = UtilRgb.darken(strokeColorActive, strokeColorActiveOnHovered);
            var strokeColor = 0xe7e5e7;
            _this._strokeColor = strokeColor;
            var strokeColorOnHovered = _this.toOnHovered(strokeColor);
            var strokeColorOnPressed = strokeColorOnHovered * 2;
            _this._strokeColorPressed = UtilRgb.darken(strokeColor, strokeColorOnPressed);
            _this._strokeColorGrayscaleHovered = UtilRgb.darken(strokeColor, strokeColorOnHovered);
            var strokeAlpha = stroke.alpha;
            _this._strokeAlpha = strokeAlpha;
            _this._strokeAlphaDisabled = strokeAlpha * 0.5;
            var text = runtime.text;
            var textColor = text.color;
            _this._textColorActive = textColor;
            _this._textColorDisabled = UtilRgb.toGrayscale(textColor);
            _this._textColor = 0x4f4f4f;
            var textAlpha = text.alpha;
            _this._textAlpha = textAlpha;
            _this._textAlphaDisabled = textAlpha * 0.5;
            var textOutline = text.outline;
            var textOutlineColor = textOutline.color;
            _this._textOutlineColor = textOutlineColor;
            _this._textOutlineColorDisabled = UtilRgb.toGrayscale(textOutlineColor);
            var textOutlineAlpha = textOutline.alpha;
            _this._textOutlineAlpha = textOutlineAlpha;
            _this._textOutlineAlphaDisabled = textOutlineAlpha * 0.5;
            return _this;
        }
        EShapeButtonRuntimeActionToggle.prototype.toOnHovered = function (color) {
            var luma = UtilRgb.toLuma(color);
            if (128 <= luma) {
                var t = (luma - 128) / 127;
                return +0.15 * (1 - t) + t * 0.03;
            }
            else {
                var t = (127 - luma) / 127;
                return -0.15 * (1 - t) - t * 0.175;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.execute = function (shape, runtime, time) {
            var state = shape.state;
            shape.fill.set(undefined, this.getFillColor(state), this.getFillAlpha(state));
            shape.stroke.set(undefined, this.getStrokeColor(state), this.getStrokeAlpha(state));
            shape.text.set(undefined, this.getTextColor(state), this.getTextAlpha(state));
            shape.text.outline.set(undefined, this.getTextOutlineColor(state), this.getTextOutlineAlpha(state));
            shape.cursor = this.getCursor(state);
            runtime.written |= this.reset;
        };
        EShapeButtonRuntimeActionToggle.prototype.getFillColor = function (state) {
            if (state.inDisabled) {
                return this._fillColor;
            }
            else if (state.isActive) {
                if (state.isPressed) {
                    return this._fillColorActivePressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._fillColorActiveHovered;
                }
                else {
                    return this._fillColorActive;
                }
            }
            else {
                if (state.isPressed) {
                    return this._fillColorPressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._fillColorHovered;
                }
                else {
                    return this._fillColor;
                }
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getFillAlpha = function (state) {
            if (state.inDisabled) {
                return this._fillAlphaDisabled;
            }
            else {
                return this._fillAlpha;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getStrokeColor = function (state) {
            if (state.inDisabled) {
                return this._strokeColor;
            }
            else if (state.isActive) {
                if (state.isPressed) {
                    return this._strokeColorActivePressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._strokeColorActiveHovered;
                }
                else {
                    return this._strokeColorActive;
                }
            }
            else {
                if (state.isPressed) {
                    return this._strokeColorPressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._strokeColorGrayscaleHovered;
                }
                else {
                    return this._strokeColor;
                }
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getStrokeAlpha = function (state) {
            if (state.inDisabled) {
                return this._strokeAlphaDisabled;
            }
            else {
                return this._strokeAlpha;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getTextColor = function (state) {
            if (state.inDisabled) {
                return this._textColorDisabled;
            }
            else if (state.isActive) {
                return this._textColorActive;
            }
            else {
                return this._textColor;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getTextAlpha = function (state) {
            if (state.inDisabled) {
                return this._textAlphaDisabled;
            }
            else {
                return this._textAlpha;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getTextOutlineColor = function (state) {
            if (state.inDisabled) {
                return this._textOutlineColorDisabled;
            }
            else {
                return this._textOutlineColor;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getTextOutlineAlpha = function (state) {
            if (state.inDisabled) {
                return this._textOutlineAlphaDisabled;
            }
            else {
                return this._textOutlineAlpha;
            }
        };
        EShapeButtonRuntimeActionToggle.prototype.getCursor = function (state) {
            if (state.isActionable) {
                return "pointer";
            }
            return "";
        };
        return EShapeButtonRuntimeActionToggle;
    }(EShapeActionRuntimeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeButtonRuntime = /** @class */ (function (_super) {
        __extends(EShapeButtonRuntime, _super);
        function EShapeButtonRuntime(shape) {
            var _this = _super.call(this, shape) || this;
            if (shape instanceof EShapeButton) {
                _this._isToggle = shape.isToggle;
                _this._isGrouped = shape.isGrouped;
            }
            return _this;
        }
        EShapeButtonRuntime.prototype.isActionable = function () {
            return true;
        };
        EShapeButtonRuntime.prototype.initialize = function (shape) {
            this.actions.unshift(this._isToggle
                ? new EShapeButtonRuntimeActionToggle(this)
                : new EShapeButtonRuntimeAction(this));
            _super.prototype.initialize.call(this, shape);
        };
        EShapeButtonRuntime.prototype.onClick = function (shape, e) {
            var state = shape.state;
            var wasClicked = state.isClicked;
            state.lock();
            _super.prototype.onClick.call(this, shape, e);
            if (!wasClicked && state.isClicked) {
                if (this._isToggle) {
                    state.isActive = !state.isActive;
                }
                else {
                    if (!state.isActive) {
                        state.isActivated = true;
                    }
                }
            }
            state.unlock();
        };
        EShapeButtonRuntime.prototype.onStateChange = function (shape, newState, oldState) {
            _super.prototype.onStateChange.call(this, shape, newState, oldState);
            if (this._isToggle && this._isGrouped && newState.is(EShapeState.ACTIVATED)) {
                this.onActivated(shape);
            }
        };
        EShapeButtonRuntime.prototype.onActivated = function (shape) {
            // Deactivate other group buttons
            var parent = shape.parent;
            if (parent != null) {
                var children = parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child !== shape &&
                        child instanceof EShapeButton &&
                        child.isToggle &&
                        child.isGrouped) {
                        child.state.isActive = false;
                    }
                }
            }
        };
        return EShapeButtonRuntime;
    }(EShapeRuntimeImpl));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeButton = function () {
        EShapeUploadeds[EShapeType.BUTTON] = createButtonUploaded;
        EShapeDeserializers[EShapeType.BUTTON] = deserializeButton;
        EShapeRuntimes[EShapeType.BUTTON] = EShapeButtonRuntime;
        EShapeCapabilities.set(EShapeType.BUTTON, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    var CIRCLE_VERTEX_COUNT = 9;
    var CIRCLE_INDEX_COUNT = 8;
    var CIRCLE_WORLD_SIZE = [0, 0];
    var CIRCLE_WORK_POINT = new pixi_js.Point();
    var buildCircleClipping = function (clippings, voffset) {
        var ic = voffset * 3 - 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
    };
    var buildCircleIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 7;
    };
    var buildCircleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        //  0       1       2
        // |-------|-------|
        // |3      |4      |5
        // |-------|-------|
        // |6      |7      |8
        // |-------|-------|
        //
        var work = CIRCLE_WORK_POINT;
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        work.set(-sx + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(0 + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        var dx = x1 - x0;
        var dy = y1 - y0;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var x4 = work.x;
        var y4 = work.y;
        var x7 = x4 + (x4 - x1);
        var y7 = y4 + (y4 - y1);
        var x3 = x4 - dx;
        var y3 = y4 - dy;
        // Vertices
        var iv = voffset * 2 - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1 + dx;
        vertices[++iv] = y1 + dy;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x4 + dx;
        vertices[++iv] = y4 + dy;
        vertices[++iv] = x7 - dx;
        vertices[++iv] = y7 - dy;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x7 + dx;
        vertices[++iv] = y7 + dy;
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x3, y3);
    };
    var buildCircleStep = function (steps, clippings, voffset, strokeWidth, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var is = voffset * 6 - 1;
        var ic = voffset * 3;
        for (var i = 0; i < CIRCLE_VERTEX_COUNT; i += 1, ic += 3) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = worldSize[0];
            steps[++is] = worldSize[1];
            steps[++is] = 1 + clippings[ic];
            steps[++is] = 1 + clippings[ic + 1];
        }
    };
    var buildCircleUv = function (uvs, voffset, textureUvs) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        // UVs
        var iuv = voffset * 2 - 1;
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = 0.5 * (x0 + x1);
        uvs[++iuv] = 0.5 * (y0 + y1);
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = 0.5 * (x0 + x3);
        uvs[++iuv] = 0.5 * (y0 + y3);
        uvs[++iuv] = 0.5 * (x0 + x2);
        uvs[++iuv] = 0.5 * (y0 + y2);
        uvs[++iuv] = 0.5 * (x1 + x2);
        uvs[++iuv] = 0.5 * (y1 + y2);
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = 0.5 * (x3 + x2);
        uvs[++iuv] = 0.5 * (y3 + y2);
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderCircle = /** @class */ (function (_super) {
        __extends(BuilderCircle, _super);
        function BuilderCircle(vertexOffset, indexOffset) {
            return _super.call(this, vertexOffset, indexOffset, CIRCLE_VERTEX_COUNT, CIRCLE_INDEX_COUNT) || this;
        }
        BuilderCircle.prototype.init = function (buffer) {
            buffer.updateClippings();
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            buildCircleClipping(buffer.clippings, voffset);
            buildCircleIndex(buffer.indices, voffset, this.indexOffset);
        };
        BuilderCircle.prototype.update = function (buffer, shape) {
            this.updateVertexAndStep(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderCircle.prototype.updateVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                buildCircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, CIRCLE_WORLD_SIZE);
                buildCircleStep(buffer.steps, buffer.clippings, this.vertexOffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
            }
        };
        BuilderCircle.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var textureUvs = toTextureUvs(texture);
                buildCircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        };
        return BuilderCircle;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createCircleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = CIRCLE_VERTEX_COUNT + tvcount;
        var icount = CIRCLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderCircle(voffset, ioffset),
                new BuilderText(voffset + CIRCLE_VERTEX_COUNT, ioffset + CIRCLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeCircle = /** @class */ (function (_super) {
        __extends(EShapeCircle, _super);
        function EShapeCircle(type) {
            if (type === void 0) { type = EShapeType.CIRCLE; }
            return _super.call(this, type) || this;
        }
        EShapeCircle.prototype.clone = function () {
            return new EShapeCircle(this.type).copy(this);
        };
        EShapeCircle.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestCircle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeCircle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeCircle = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeCircle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeCircle = function () {
        EShapeUploadeds[EShapeType.CIRCLE] = createCircleUploaded;
        EShapeDeserializers[EShapeType.CIRCLE] = deserializeCircle;
    };

    var LINE_FMIN = 0.00001;
    var LINE_WORK_POINT = new pixi_js.Point();
    var toPointsCount = function (points) {
        if (points) {
            return points.formatted.length;
        }
        return 0;
    };
    var toLinePointCount = function (points) {
        return Math.ceil(toPointsCount(points) / 12) * 12;
    };
    var toLineVertexCount = function (pointCount, isClosed) {
        if (isClosed) {
            return pointCount * 4 + 2;
        }
        else {
            return pointCount * 4;
        }
    };
    var toLineIndexCount = function (pointCount, isClosed) {
        return toLineVertexCount(pointCount, isClosed) - 2;
    };
    var buildLineClipping = function (clippings, voffset, vcount, pointCount) {
        var ic = voffset * 3 - 1;
        var icmax = (voffset + vcount) * 3 - 1;
        for (var i = 0; i < pointCount; ++i) {
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 3;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 5;
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 4;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 6;
        }
        for (; ic < icmax;) {
            clippings[++ic] = 1;
            clippings[++ic] = 0;
            clippings[++ic] = 3;
            clippings[++ic] = 0;
            clippings[++ic] = 1;
            clippings[++ic] = 5;
        }
    };
    var buildLineIndex = function (indices, voffset, ioffset, icount) {
        var ii = ioffset * 3 - 1;
        var iimax = (ioffset + icount) * 3 - 1;
        var io = voffset;
        for (; ii < iimax;) {
            indices[++ii] = io + 0;
            indices[++ii] = io + 2;
            indices[++ii] = io + 1;
            indices[++ii] = io + 1;
            indices[++ii] = io + 2;
            indices[++ii] = io + 3;
            io += 2;
        }
    };
    var buildLineUv = function (uvs, colorFills, voffset, vcount, textureUvs, length) {
        var lengthInverse = 1 / Math.max(LINE_FMIN, length);
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var dx01 = x1 - x0;
        var dy01 = y1 - y0;
        var dx32 = x2 - x3;
        var dy32 = y2 - y3;
        var iuv = (voffset << 1) - 1;
        var iuvmax = ((voffset + vcount) << 1) - 1;
        var icf = (voffset << 2) - 8;
        for (; iuv < iuvmax;) {
            var r = colorFills[(icf += 8)] * lengthInverse;
            uvs[++iuv] = x0 + r * dx01;
            uvs[++iuv] = y0 + r * dy01;
            uvs[++iuv] = x3 + r * dx32;
            uvs[++iuv] = y3 + r * dy32;
        }
    };
    var TRANSFORMED_POINT_VALUES;
    var buildLineVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, pointCount, pointsClosed, pointValues, pointSegments, strokeWidth, strokeStyle, internalTransform) {
        var transformedPointValues = TRANSFORMED_POINT_VALUES;
        if (transformedPointValues == null) {
            transformedPointValues = [];
            TRANSFORMED_POINT_VALUES = transformedPointValues;
        }
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var tx = internalTransform.tx;
        var ty = internalTransform.ty;
        for (var i = 0; i < pointCount; ++i) {
            var iv = i << 1;
            var x = pointValues[iv];
            var y = pointValues[iv + 1];
            transformedPointValues[iv] = a * x + c * y + tx;
            transformedPointValues[iv + 1] = b * x + d * y + ty;
        }
        return buildTransformedLineVertexStepAndColorFill(vertices, steps, colorFills, voffset, vcount, pointCount, pointsClosed, transformedPointValues, pointSegments, strokeWidth, strokeStyle);
    };
    var fillTransformedLineVertexStepAndColorFill = function (iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, llo) {
        vertices[++iv] = px;
        vertices[++iv] = py;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = pprevx;
        steps[++is] = pprevy;
        steps[++is] = pnextx;
        steps[++is] = pnexty;
        colorFills[(icf += 1)] = llo;
        vertices[++iv] = px;
        vertices[++iv] = py;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = pprevx;
        steps[++is] = pprevy;
        steps[++is] = pnextx;
        steps[++is] = pnexty;
        colorFills[(icf += 4)] = llo;
    };
    var buildTransformedLineVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, lineVertexCount, lineIsClosed, lineVertices, lineSegments, strokeWidth, strokeStyle) {
        var lineSegmentsLength = lineSegments.length;
        if (0 < lineSegmentsLength) {
            if (lineIsClosed) {
                var lmax = 0;
                var lprev = 0;
                var ivoffset = voffset;
                var iseg = 0;
                var iprevseg = lineSegments[0];
                for (var i = 1; i < lineSegmentsLength; ++i) {
                    iseg = lineSegments[i];
                    if (2 <= iseg - iprevseg) {
                        lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, -1, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                        lmax = Math.max(lmax, lprev);
                        ivoffset += toLineVertexCount(iseg - iprevseg, false);
                    }
                    iprevseg = iseg;
                }
                // Last
                iseg = lineSegments[0] + lineVertexCount;
                if (2 <= iseg - iprevseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg - iprevseg, false);
                }
                else {
                    buildTransformedLineEmptyVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                }
                return lmax;
            }
            else {
                var lmax = 0;
                var lprev = 0;
                var ivoffset = voffset;
                // First
                var iseg = lineSegments[0];
                if (2 <= iseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, -1, lineVertices, 0, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg, false);
                }
                // Middle
                var iprevseg = iseg;
                for (var i = 1; i < lineSegmentsLength; ++i) {
                    iseg = lineSegments[i];
                    if (2 <= iseg - iprevseg) {
                        lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, -1, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                        lmax = Math.max(lmax, lprev);
                        ivoffset += toLineVertexCount(iseg - iprevseg, false);
                    }
                    iprevseg = iseg;
                }
                // Last
                iseg = lineVertexCount;
                if (2 <= iseg - iprevseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg - iprevseg, false);
                }
                else {
                    buildTransformedLineEmptyVertexStepAndColorFill(vertices, steps, colorFills, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                }
                return lmax;
            }
        }
        else {
            if (lineIsClosed) {
                return buildTransformedLineClosedSegmentVertexStepAndColorFill(vertices, steps, colorFills, voffset, vcount, lineVertices, 0, lineVertexCount, lineVertexCount, strokeWidth, strokeStyle);
            }
            else {
                return buildTransformedLineOpenSegmentVertexStepAndColorFill(vertices, steps, colorFills, voffset, vcount, lineVertices, 0, lineVertexCount, lineVertexCount, strokeWidth, strokeStyle, 0);
            }
        }
    };
    var buildTransformedLineEmptyVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle, length) {
        if (0 <= vcount) {
            var scaleInvariant = toScaleInvariant(strokeStyle);
            var iv = (voffset << 1) - 1;
            var is = voffset * 6 - 1;
            var icf = (voffset << 2) - 1;
            var ivmax = ((voffset + vcount) << 1) - 1;
            var ifirst = lineVertexFrom % lineVertexCount << 1;
            var px = lineVertices[ifirst];
            var py = lineVertices[ifirst + 1];
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = scaleInvariant;
                steps[++is] = -1;
                steps[++is] = 0;
                steps[++is] = +1;
                steps[++is] = 0;
                colorFills[++icf] = length;
                colorFills[++icf] = 0;
                colorFills[++icf] = 0;
                colorFills[++icf] = length;
            }
        }
        return 0;
    };
    var buildTransformedLineOpenSegmentVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle, length) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        // First segment
        var ifirst = lineVertexFrom % lineVertexCount << 1;
        var px = lineVertices[ifirst];
        var py = lineVertices[ifirst + 1];
        var isecond = (lineVertexFrom + 1) % lineVertexCount << 1;
        var pnextx = lineVertices[isecond];
        var pnexty = lineVertices[isecond + 1];
        var pprevx = px - (pnextx - px);
        var pprevy = py - (pnexty - py);
        var iv = (voffset << 1) - 1;
        var is = voffset * 6 - 1;
        var icf = (voffset << 2) - 1;
        var l = 0;
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, length);
        iv += 4;
        is += 12;
        icf += 8;
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
        iv += 4;
        is += 12;
        icf += 8;
        // Middle segments
        for (var i = lineVertexFrom + 1, imax = lineVertexTo - 1; i < imax; ++i) {
            pprevx = px;
            pprevy = py;
            px = pnextx;
            py = pnexty;
            var imiddle = (i + 1) % lineVertexCount << 1;
            pnextx = lineVertices[imiddle];
            pnexty = lineVertices[imiddle + 1];
            l += toLength(pprevx, pprevy, px, py);
            fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
            iv += 4;
            is += 12;
            icf += 8;
            fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
            iv += 4;
            is += 12;
            icf += 8;
        }
        // Last segment
        pprevx = px;
        pprevy = py;
        px = pnextx;
        py = pnexty;
        pnextx = px + (px - pprevx);
        pnexty = py + (py - pprevy);
        l += toLength(pprevx, pprevy, px, py);
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
        iv += 4;
        is += 12;
        icf += 8;
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
        iv += 4;
        is += 12;
        icf += 8;
        // Total length
        var dash = toDash(l, strokeWidth, strokeStyle, LINE_WORK_POINT);
        var dash0 = dash.x;
        var dash1 = dash.y;
        var icf0 = (voffset << 2) - 1;
        for (var i = icf0, imax = icf0 + 8; i < imax; i += 4) {
            colorFills[i + 2] = dash0;
            colorFills[i + 3] = dash1;
            colorFills[i + 4] = length;
        }
        for (var i = icf0 + 8; i < icf; i += 4) {
            colorFills[i + 2] = dash0;
            colorFills[i + 3] = dash1;
            colorFills[i + 4] = l;
        }
        // Fill the rest
        if (0 <= vcount) {
            var ivmax = ((voffset + vcount) << 1) - 1;
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = scaleInvariant;
                steps[++is] = pprevx;
                steps[++is] = pprevy;
                steps[++is] = pnextx;
                steps[++is] = pnexty;
                colorFills[++icf] = l;
                colorFills[++icf] = dash0;
                colorFills[++icf] = dash1;
                colorFills[++icf] = l;
            }
        }
        return l;
    };
    var buildTransformedLineClosedSegmentVertexStepAndColorFill = function (vertices, steps, colorFills, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var ilast = (lineVertexTo - 1) % lineVertexCount << 1;
        var pprevx = 0;
        var pprevy = 0;
        var px = lineVertices[ilast];
        var py = lineVertices[ilast + 1];
        var ifirst = lineVertexFrom % lineVertexCount << 1;
        var pnextx = lineVertices[ifirst];
        var pnexty = lineVertices[ifirst + 1];
        var l = 0;
        var iv = (voffset << 1) - 1;
        var is = voffset * 6 - 1;
        var icf = (voffset << 2) - 1;
        for (var i = lineVertexFrom; i < lineVertexTo; ++i) {
            pprevx = px;
            pprevy = py;
            px = pnextx;
            py = pnexty;
            var imiddle = (i + 1) % lineVertexCount << 1;
            pnextx = lineVertices[imiddle];
            pnexty = lineVertices[imiddle + 1];
            l += toLength(pprevx, pprevy, px, py);
            fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
            iv += 4;
            is += 12;
            icf += 8;
            fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
            iv += 4;
            is += 12;
            icf += 8;
        }
        // Last segment
        pprevx = px;
        pprevy = py;
        px = pnextx;
        py = pnexty;
        var isecond = (lineVertexFrom + 1) % lineVertexCount << 1;
        pnextx = lineVertices[isecond];
        pnexty = lineVertices[isecond + 1];
        l += toLength(pprevx, pprevy, px, py);
        fillTransformedLineVertexStepAndColorFill(iv, vertices, is, steps, icf, colorFills, px, py, strokeWidth, scaleInvariant, pprevx, pprevy, pnextx, pnexty, l);
        iv += 4;
        is += 12;
        icf += 8;
        // Total length
        var dash = toDash(l, strokeWidth, strokeStyle, LINE_WORK_POINT);
        var dash0 = dash.x;
        var dash1 = dash.y;
        for (var i = (voffset << 2) - 1; i < icf; i += 4) {
            colorFills[i + 2] = dash0;
            colorFills[i + 3] = dash1;
            colorFills[i + 4] = -1;
        }
        // Fill the rest
        if (0 <= vcount) {
            var ivmax = ((voffset + vcount) << 1) - 1;
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = strokeWidth;
                steps[++is] = scaleInvariant;
                steps[++is] = pprevx;
                steps[++is] = pprevy;
                steps[++is] = pnextx;
                steps[++is] = pnexty;
                colorFills[++icf] = l;
                colorFills[++icf] = dash0;
                colorFills[++icf] = dash1;
                colorFills[++icf] = -1;
            }
        }
        return l;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLine = /** @class */ (function (_super) {
        __extends(BuilderLine, _super);
        function BuilderLine(vertexOffset, indexOffset, vertexCount, indexCount) {
            var _this = _super.call(this, vertexOffset, indexOffset, vertexCount, indexCount) || this;
            _this.pointId = -1;
            _this.pointCount = 0;
            _this.pointsClosed = false;
            _this.length = 1;
            return _this;
        }
        BuilderLine.prototype.init = function (buffer) {
            buffer.updateIndices();
            buildLineIndex(buffer.indices, this.vertexOffset, this.indexOffset, this.indexCount);
        };
        BuilderLine.prototype.isCompatible = function (shape) {
            var vcount = toLineVertexCount(toLinePointCount(shape.points), true);
            return vcount === this.vertexCount;
        };
        BuilderLine.prototype.update = function (buffer, shape) {
            this.updateLineClipping(buffer, shape);
            this.updateLineVertexStepAndColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
            this.updateLineUv(buffer, shape);
        };
        BuilderLine.prototype.updateLineClipping = function (buffer, shape) {
            var points = shape.points;
            if (points) {
                var formatted = points.formatted;
                var pointCount = formatted.length;
                if (this.pointCount !== pointCount) {
                    this.pointCount = pointCount;
                    // Invalidate the pointId to update the vertices
                    this.pointId = -1;
                    buffer.updateClippings();
                    buildLineClipping(buffer.clippings, this.vertexOffset, this.vertexCount, pointCount);
                }
            }
        };
        BuilderLine.prototype.updateLineVertexStepAndColorFill = function (buffer, shape) {
            var points = shape.points;
            if (points) {
                var pointId = points.id;
                var formatted = points.formatted;
                var pointsClosed = !!(formatted.style & EShapePointsStyle.CLOSED);
                var isPointChanged = pointId !== this.pointId || pointsClosed !== this.pointsClosed;
                var stroke = shape.stroke;
                var strokeWidth = stroke.enable ? stroke.width : 0;
                var strokeStyle = stroke.style;
                var isStrokeWidthChanged = this.strokeWidth !== strokeWidth || this.strokeStyle !== strokeStyle;
                var transformLocalId = toTransformLocalId(shape);
                var isTransformChanged = this.transformLocalId !== transformLocalId;
                if (isPointChanged || isTransformChanged || isStrokeWidthChanged) {
                    this.pointId = pointId;
                    this.pointsClosed = pointsClosed;
                    this.strokeWidth = strokeWidth;
                    this.strokeStyle = strokeStyle;
                    this.transformLocalId = transformLocalId;
                    if (isPointChanged) {
                        // Invalidate the texture transform ID to update the UVs
                        this.textureTransformId = NaN;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    buffer.updateColorFills();
                    this.length = buildLineVertexStepAndColorFill(buffer.vertices, buffer.steps, buffer.colorFills, this.vertexOffset, this.vertexCount, this.pointCount, this.pointsClosed, formatted.values, formatted.segments, strokeWidth, strokeStyle, shape.transform.internalTransform);
                }
            }
        };
        BuilderLine.prototype.updateLineUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildLineUv(buffer.uvs, buffer.colorFills, this.vertexOffset, this.vertexCount, toTextureUvs(texture), this.length);
            }
        };
        return BuilderLine;
    }(BuilderBase));

    var TRIANGLE_VERTEX_COUNT = 7;
    var TRIANGLE_INDEX_COUNT = 3;
    var TRIANGLE_WORLD_SIZE = [0, 0, 0];
    var TRIANGLE_WORK_POINT = new pixi_js.Point();
    var buildTriangleClipping = function (clippings, voffset) {
        // Clippings
        var iv = voffset * 3 - 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
    };
    var buildTriangleIndex = function (indices, voffset, ioffset) {
        // Indices
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
    };
    var buildTriangleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var sz = Math.sqrt(sx * sx + 4 * sy * sy);
        var sw = (2 * sx * sy) / (sx + sz);
        var work = TRIANGLE_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var tx = work.x;
        var ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        var dx = tx - x0;
        var dy = ty - y0;
        var x1 = work.x + dx;
        var y1 = work.y + dy;
        var x2 = tx + (tx - work.x) + dx;
        var y2 = ty + (ty - work.y) + dy;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        var x3 = work.x;
        var y3 = work.y;
        // World size
        var xb = tx + dx;
        var yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x3, y3);
        worldSize[1] = toLength(x1, y1, xb, yb);
        worldSize[2] = toLength(x0, y0, tx, ty);
        // Vertices
        var iv = (voffset << 1) - 1;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
    };
    var buildTriangleStep = function (steps, clippings, voffset, vcount, strokeWidth, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var s = worldSize[0];
        var is = voffset * 6 - 1;
        var ic = voffset * 3;
        for (var i = 0; i < vcount; i += 1, ic += 3) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = 1 + clippings[ic];
            steps[++is] = 1 + clippings[ic + 1];
        }
    };
    var buildTriangleUv = function (uvs, textureUvs, voffset, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var c = 1 - (0.5 * worldSize[0]) / worldSize[2];
        var x5 = x4 + c * (x3 - x0);
        var y5 = y4 + c * (y3 - y0);
        var iuv = (voffset << 1) - 1;
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerBase = /** @class */ (function (_super) {
        __extends(BuilderMarkerBase, _super);
        function BuilderMarkerBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerBase.prototype.updateColorFill = function (buffer, shape) {
            var points = shape.points;
            if (points == null) {
                return;
            }
            var container = points.getMarker();
            if (container == null) {
                return;
            }
            var marker = this.toMarker(container);
            var fill = marker.fill;
            var isEnabled = shape.visible && fill.enable;
            var color = fill.color;
            var alpha = isEnabled ? fill.alpha : 0;
            if (color !== this.colorFill || alpha !== this.alphaFill) {
                this.colorFill = color;
                this.alphaFill = alpha;
                buffer.updateColorFills();
                buildColor(color, alpha, this.vertexOffset, this.vertexCount, buffer.colorFills);
            }
        };
        return BuilderMarkerBase;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerTriangle = /** @class */ (function (_super) {
        __extends(BuilderMarkerTriangle, _super);
        function BuilderMarkerTriangle(vertexOffset, indexOffset) {
            var _this = _super.call(this, vertexOffset, indexOffset, TRIANGLE_VERTEX_COUNT, TRIANGLE_INDEX_COUNT) || this;
            _this.pointId = -1;
            return _this;
        }
        BuilderMarkerTriangle.prototype.init = function (buffer) {
            buffer.updateClippings();
            buffer.updateIndices();
            buildTriangleClipping(buffer.clippings, this.vertexOffset);
            buildTriangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
        };
        BuilderMarkerTriangle.prototype.update = function (buffer, shape) {
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
        };
        BuilderMarkerTriangle.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var _a;
            var points = shape.points;
            if (points == null) {
                return;
            }
            var container = points.getMarker();
            if (container == null) {
                return;
            }
            var marker = this.toMarker(container);
            var size = marker.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            var pointId = points.id;
            var isPointChanged = pointId !== this.pointId;
            if (isVertexChanged || isTransformChanged || isTextureChanged || isPointChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                this.pointId = pointId;
                var voffset = this.vertexOffset;
                var internalTransform = ((_a = BuilderMarkerTriangle.WORK) !== null && _a !== void 0 ? _a : (BuilderMarkerTriangle.WORK = new pixi_js.Matrix()));
                internalTransform.copyFrom(marker.transform).prepend(shape.transform.internalTransform);
                buffer.updateVertices();
                buildTriangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildTriangleStep(buffer.steps, buffer.clippings, voffset, TRIANGLE_VERTEX_COUNT, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleUv(buffer.uvs, toTextureUvs(texture), voffset, TRIANGLE_WORLD_SIZE);
                }
            }
        };
        return BuilderMarkerTriangle;
    }(BuilderMarkerBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerTriangleHead = /** @class */ (function (_super) {
        __extends(BuilderMarkerTriangleHead, _super);
        function BuilderMarkerTriangleHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerTriangleHead.prototype.toMarker = function (container) {
            return container.head;
        };
        return BuilderMarkerTriangleHead;
    }(BuilderMarkerTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerTriangleTail = /** @class */ (function (_super) {
        __extends(BuilderMarkerTriangleTail, _super);
        function BuilderMarkerTriangleTail() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerTriangleTail.prototype.toMarker = function (container) {
            return container.tail;
        };
        return BuilderMarkerTriangleTail;
    }(BuilderMarkerTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerCircle = /** @class */ (function (_super) {
        __extends(BuilderMarkerCircle, _super);
        function BuilderMarkerCircle(vertexOffset, indexOffset) {
            var _this = _super.call(this, vertexOffset, indexOffset, CIRCLE_VERTEX_COUNT, CIRCLE_INDEX_COUNT) || this;
            _this.pointId = -1;
            return _this;
        }
        BuilderMarkerCircle.prototype.init = function (buffer) {
            buffer.updateClippings();
            buffer.updateIndices();
            var vertexOffset = this.vertexOffset;
            buildCircleClipping(buffer.clippings, vertexOffset);
            buildCircleIndex(buffer.indices, vertexOffset, this.indexOffset);
        };
        BuilderMarkerCircle.prototype.update = function (buffer, shape) {
            this.updateVertexAndStep(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderMarkerCircle.prototype.updateVertexAndStep = function (buffer, shape) {
            var _a;
            var points = shape.points;
            if (points == null) {
                return;
            }
            var container = points.getMarker();
            if (container == null) {
                return;
            }
            var marker = this.toMarker(container);
            var size = marker.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var pointId = points.id;
            var isPointChanged = pointId !== this.pointId;
            if (isSizeChanged || isTransformChanged || isStrokeChanged || isPointChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.pointId = pointId;
                // Buffer
                var internalTransform = ((_a = BuilderMarkerCircle.WORK) !== null && _a !== void 0 ? _a : (BuilderMarkerCircle.WORK = new pixi_js.Matrix()));
                internalTransform.copyFrom(marker.transform).prepend(shape.transform.internalTransform);
                buffer.updateVertices();
                buffer.updateSteps();
                buildCircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                buildCircleStep(buffer.steps, buffer.clippings, this.vertexOffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
            }
        };
        BuilderMarkerCircle.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var textureUvs = toTextureUvs(texture);
                buildCircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        };
        return BuilderMarkerCircle;
    }(BuilderMarkerBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerCircleHead = /** @class */ (function (_super) {
        __extends(BuilderMarkerCircleHead, _super);
        function BuilderMarkerCircleHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerCircleHead.prototype.toMarker = function (container) {
            return container.head;
        };
        return BuilderMarkerCircleHead;
    }(BuilderMarkerCircle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerCircleTail = /** @class */ (function (_super) {
        __extends(BuilderMarkerCircleTail, _super);
        function BuilderMarkerCircleTail() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerCircleTail.prototype.toMarker = function (container) {
            return container.tail;
        };
        return BuilderMarkerCircleTail;
    }(BuilderMarkerCircle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderNull = /** @class */ (function () {
        function BuilderNull(vertexOffset, indexOffset) {
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = 0;
            this.indexCount = 0;
            this.texture = null;
        }
        BuilderNull.prototype.init = function (buffer) {
            // DO NOTHING
        };
        BuilderNull.prototype.isCompatible = function (shape) {
            return true;
        };
        BuilderNull.prototype.update = function (buffer, shape) {
            this.texture = toTexture(shape);
        };
        BuilderNull.prototype.buildUnit = function (builder) {
            var texture = this.texture || pixi_js.Texture.WHITE;
            var baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                var indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        };
        return BuilderNull;
    }());

    var RECTANGLE_VERTEX_COUNT = 24;
    var RECTANGLE_INDEX_COUNT = 16;
    var RECTANGLE_WORLD_SIZE = [0, 0, 0, 0];
    var RECTANGLE_WORK_POINT = new pixi_js.Point();
    var buildRectangleClipping = function (clippings, voffset, worldSize) {
        var brxi = 1 - worldSize[0];
        var bryi = 1 - worldSize[1];
        var ic = voffset * 3 - 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = bryi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = bryi;
        clippings[++ic] = 0;
        // --------------------------------
        clippings[++ic] = 0;
        clippings[++ic] = bryi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = bryi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        // --------------------------------
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = brxi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = brxi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        // --------------------------------
        clippings[++ic] = brxi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = brxi;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
    };
    var buildRectangleIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
        // --------------------------------
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 11;
        // --------------------------------
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 15;
        // --------------------------------
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 23;
    };
    var buildRectangleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // b0              b1
        // |-------|-------|
        // |       |       |
        // |-------|-------|
        // |       |       |
        // |-------|-------|
        // b3              b2
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var work = RECTANGLE_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var b0x = work.x;
        var b0y = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        var b1x = work.x;
        var b1y = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        var b2x = work.x;
        var b2y = work.y;
        var b3x = b0x + (b2x - b1x);
        var b3y = b0y + (b2y - b1y);
        var ax = toLength(b0x, b0y, b1x, b1y) * 0.5;
        var ay = toLength(b1x, b1y, b2x, b2y) * 0.5;
        var brx = 1;
        var bry = 1;
        if (ax <= ay) {
            bry = ax / ay;
        }
        else {
            brx = ay / ax;
        }
        worldSize[0] = brx;
        worldSize[1] = bry;
        worldSize[2] = ax;
        worldSize[3] = ay;
        // 0      1  2      3
        // |------|--|------|
        // |      |  |      |
        // |------4--5------|
        // |      |  |      |
        // |------6--7------|
        // |      |  |      |
        // |------|--|------|
        // 8      9  10     11
        var d01x = brx * (b1x - b0x) * 0.5;
        var d01y = brx * (b1y - b0y) * 0.5;
        var d03x = bry * (b3x - b0x) * 0.5;
        var d03y = bry * (b3y - b0y) * 0.5;
        var iv = (voffset << 1) - 1;
        vertices[++iv] = b0x;
        vertices[++iv] = b0y;
        vertices[++iv] = b0x + d01x;
        vertices[++iv] = b0y + d01y;
        vertices[++iv] = b1x - d01x;
        vertices[++iv] = b1y - d01y;
        vertices[++iv] = b1x;
        vertices[++iv] = b1y;
        vertices[++iv] = b0x + d01x + d03x;
        vertices[++iv] = b0y + d01y + d03y;
        vertices[++iv] = b1x - d01x + d03x;
        vertices[++iv] = b1y - d01y + d03y;
        vertices[++iv] = b3x + d01x - d03x;
        vertices[++iv] = b3y + d01y - d03y;
        vertices[++iv] = b2x - d01x - d03x;
        vertices[++iv] = b2y - d01y - d03y;
        vertices[++iv] = b3x;
        vertices[++iv] = b3y;
        vertices[++iv] = b3x + d01x;
        vertices[++iv] = b3y + d01y;
        vertices[++iv] = b2x - d01x;
        vertices[++iv] = b2y - d01y;
        vertices[++iv] = b2x;
        vertices[++iv] = b2y;
        // 12               20
        // |------|--|------|
        // |      |  |      |
        // 13----16--18-----21
        // |      |  |      |
        // 14----17--19-----22
        // |      |  |      |
        // |------|--|------|
        // 15               23
        vertices[++iv] = b0x;
        vertices[++iv] = b0y;
        vertices[++iv] = b0x + d03x;
        vertices[++iv] = b0y + d03y;
        vertices[++iv] = b3x - d03x;
        vertices[++iv] = b3y - d03y;
        vertices[++iv] = b3x;
        vertices[++iv] = b3y;
        vertices[++iv] = b0x + d03x + d01x;
        vertices[++iv] = b0y + d03y + d01y;
        vertices[++iv] = b3x - d03x + d01x;
        vertices[++iv] = b3y - d03y + d01y;
        vertices[++iv] = b1x + d03x - d01x;
        vertices[++iv] = b1y + d03y - d01y;
        vertices[++iv] = b2x - d03x - d01x;
        vertices[++iv] = b2y - d03y - d01y;
        vertices[++iv] = b1x;
        vertices[++iv] = b1y;
        vertices[++iv] = b1x + d03x;
        vertices[++iv] = b1y + d03y;
        vertices[++iv] = b2x - d03x;
        vertices[++iv] = b2y - d03y;
        vertices[++iv] = b2x;
        vertices[++iv] = b2y;
    };
    var buildRectangleStep = function (voffset, steps, strokeWidth, strokeSide, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var brx = worldSize[0];
        var bry = worldSize[1];
        var brxi = Math.max(0, 1 - brx);
        var bryi = Math.max(0, 1 - bry);
        var sx = worldSize[2];
        var sy = worldSize[3];
        var wt;
        var bt;
        if (strokeSide & EShapeStrokeSide.TOP) {
            wt = +2;
            bt = +1 + bryi;
        }
        else {
            wt = -2;
            bt = -1 - bryi;
        }
        var wr;
        var br;
        if (strokeSide & EShapeStrokeSide.RIGHT) {
            wr = +2;
            br = +1 + brxi;
        }
        else {
            wr = -2;
            br = -1 - brxi;
        }
        var wb;
        var bb;
        if (strokeSide & EShapeStrokeSide.BOTTOM) {
            wb = +2;
            bb = +1 + bryi;
        }
        else {
            wb = -2;
            bb = -1 - bryi;
        }
        var wl;
        var bl;
        if (strokeSide & EShapeStrokeSide.LEFT) {
            wl = +2;
            bl = +1 + brxi;
        }
        else {
            wl = -2;
            bl = -1 - brxi;
        }
        // 0 1 2 3
        var is = (voffset - 1) * 6 - 1;
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, wt);
        // 4 5
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, bt);
        // 6 7
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, bb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, bb);
        // 8 9 10 11
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, wb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, wb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, wb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, wb);
        // ------------------------------
        // 12 13 14 15
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, bb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wl, wb);
        // 16 17
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, bl, bb);
        // 18 19
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, br, bb);
        // 20 21 22 23
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, wt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, bt);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, bb);
        fillRectangleStep(steps, (is += 6), strokeWidth, scaleInvariant, sx, sy, wr, wb);
    };
    var fillRectangleStep = function (steps, is, v0, v1, v2, v3, v4, v5) {
        steps[++is] = v0;
        steps[++is] = v1;
        steps[++is] = v2;
        steps[++is] = v3;
        steps[++is] = v4;
        steps[++is] = v5;
    };
    var buildRectangleUv = function (uvs, voffset, textureUvs, worldSize) {
        var x0 = textureUvs.x0;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var x1 = textureUvs.x1;
        var y2 = textureUvs.y2;
        var x2 = textureUvs.x2;
        var y3 = textureUvs.y3;
        var x3 = textureUvs.x3;
        var brx = worldSize[0];
        var bry = worldSize[1];
        var d01x = brx * (x1 - x0) * 0.5;
        var d01y = brx * (y1 - y0) * 0.5;
        var d03x = bry * (x3 - x0) * 0.5;
        var d03y = bry * (y3 - y0) * 0.5;
        // UVs
        var iuv = (voffset << 1) - 1;
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = x0 + d01x;
        uvs[++iuv] = y0 + d01y;
        uvs[++iuv] = x1 - d01x;
        uvs[++iuv] = y1 - d01y;
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = x0 + d01x + d03x;
        uvs[++iuv] = y0 + d01y + d03y;
        uvs[++iuv] = x1 - d01x + d03x;
        uvs[++iuv] = y1 - d01y + d03y;
        uvs[++iuv] = x3 + d01x - d03x;
        uvs[++iuv] = y3 + d01y - d03y;
        uvs[++iuv] = x2 - d01x - d03x;
        uvs[++iuv] = y2 - d01y - d03y;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x3 + d01x;
        uvs[++iuv] = y3 + d01y;
        uvs[++iuv] = x2 - d01x;
        uvs[++iuv] = y2 - d01y;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        // ------------------------------
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = x0 + d03x;
        uvs[++iuv] = y0 + d03y;
        uvs[++iuv] = x3 - d03x;
        uvs[++iuv] = y3 - d03y;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x0 + d03x + d01x;
        uvs[++iuv] = y0 + d03y + d01y;
        uvs[++iuv] = x3 - d03x + d01x;
        uvs[++iuv] = y3 - d03y + d01y;
        uvs[++iuv] = x1 + d03x - d01x;
        uvs[++iuv] = y1 + d03y - d01y;
        uvs[++iuv] = x2 - d03x - d01x;
        uvs[++iuv] = y2 - d03y - d01y;
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = x1 + d03x;
        uvs[++iuv] = y1 + d03y;
        uvs[++iuv] = x2 - d03x;
        uvs[++iuv] = y2 - d03y;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerRectangle = /** @class */ (function (_super) {
        __extends(BuilderMarkerRectangle, _super);
        function BuilderMarkerRectangle(vertexOffset, indexOffset) {
            var _this = _super.call(this, vertexOffset, indexOffset, RECTANGLE_VERTEX_COUNT, RECTANGLE_INDEX_COUNT) || this;
            _this.pointId = -1;
            return _this;
        }
        BuilderMarkerRectangle.prototype.init = function (buffer) {
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
        };
        BuilderMarkerRectangle.prototype.update = function (buffer, shape) {
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
        };
        BuilderMarkerRectangle.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var _a;
            var points = shape.points;
            if (points == null) {
                return;
            }
            var container = points.getMarker();
            if (container == null) {
                return;
            }
            var marker = this.toMarker(container);
            var size = marker.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            var pointId = points.id;
            var isPointChanged = pointId !== this.pointId;
            if (isVertexChanged || isTransformChanged || isTextureChanged || isPointChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                var voffset = this.vertexOffset;
                var internalTransform = ((_a = BuilderMarkerRectangle.WORK) !== null && _a !== void 0 ? _a : (BuilderMarkerRectangle.WORK = new pixi_js.Matrix()));
                internalTransform.copyFrom(marker.transform).prepend(shape.transform.internalTransform);
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // Clippings
                if (isVertexChanged) {
                    buffer.updateClippings();
                    buildRectangleClipping(buffer.clippings, voffset, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, toTextureUvs(texture), RECTANGLE_WORLD_SIZE);
                }
            }
        };
        return BuilderMarkerRectangle;
    }(BuilderMarkerBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerRectangleTail = /** @class */ (function (_super) {
        __extends(BuilderMarkerRectangleTail, _super);
        function BuilderMarkerRectangleTail() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerRectangleTail.prototype.toMarker = function (container) {
            return container.tail;
        };
        return BuilderMarkerRectangleTail;
    }(BuilderMarkerRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderMarkerRectangleHead = /** @class */ (function (_super) {
        __extends(BuilderMarkerRectangleHead, _super);
        function BuilderMarkerRectangleHead() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderMarkerRectangleHead.prototype.toMarker = function (container) {
            return container.head;
        };
        return BuilderMarkerRectangleHead;
    }(BuilderMarkerRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toMarkerVertexCount = function (type) {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return 0;
            case EShapePointsMarkerType.CIRCLE:
                return CIRCLE_VERTEX_COUNT;
            case EShapePointsMarkerType.TRIANGLE:
                return TRIANGLE_VERTEX_COUNT;
            case EShapePointsMarkerType.RECTANGLE:
                return RECTANGLE_VERTEX_COUNT;
        }
        return 0;
    };
    var toMarkerIndexCount = function (type) {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return 0;
            case EShapePointsMarkerType.CIRCLE:
                return CIRCLE_INDEX_COUNT;
            case EShapePointsMarkerType.TRIANGLE:
                return TRIANGLE_INDEX_COUNT;
            case EShapePointsMarkerType.RECTANGLE:
                return RECTANGLE_INDEX_COUNT;
        }
        return 0;
    };
    var toBuilderMarkerHead = function (type, vertexOffset, indexOffset) {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return new BuilderNull(vertexOffset, indexOffset);
            case EShapePointsMarkerType.CIRCLE:
                return new BuilderMarkerCircleHead(vertexOffset, indexOffset);
            case EShapePointsMarkerType.TRIANGLE:
                return new BuilderMarkerTriangleHead(vertexOffset, indexOffset);
            case EShapePointsMarkerType.RECTANGLE:
                return new BuilderMarkerRectangleHead(vertexOffset, indexOffset);
        }
        return new BuilderNull(vertexOffset, indexOffset);
    };
    var toBuilderMarkerTail = function (type, vertexOffset, indexOffset) {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return new BuilderNull(vertexOffset, indexOffset);
            case EShapePointsMarkerType.CIRCLE:
                return new BuilderMarkerCircleTail(vertexOffset, indexOffset);
            case EShapePointsMarkerType.TRIANGLE:
                return new BuilderMarkerTriangleTail(vertexOffset, indexOffset);
            case EShapePointsMarkerType.RECTANGLE:
                return new BuilderMarkerRectangleTail(vertexOffset, indexOffset);
        }
        return new BuilderNull(vertexOffset, indexOffset);
    };
    var createLineUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        // Line
        var points = shape.points;
        var pointCount = toLinePointCount(points);
        var lvcount = toLineVertexCount(pointCount, true);
        var licount = toLineIndexCount(pointCount, true);
        // Markers
        var mttype = EShapePointsMarkerType.NONE;
        var mhtype = EShapePointsMarkerType.NONE;
        if (points && points instanceof EShapeLinePoints) {
            var marker = points.getMarker();
            if (marker) {
                mttype = marker.tail.type;
                mhtype = marker.head.type;
            }
        }
        var mtvcount = toMarkerVertexCount(mttype);
        var mticount = toMarkerIndexCount(mttype);
        var mtvoffset = voffset + lvcount;
        var mtioffset = ioffset + licount;
        var mhvcount = toMarkerVertexCount(mhtype);
        var mhicount = toMarkerIndexCount(mhtype);
        var mhvoffset = mtvoffset + mtvcount;
        var mhioffset = mtioffset + mticount;
        // Text
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var tvoffset = mhvoffset + mhvcount;
        var tioffset = mhioffset + mhicount;
        // Uploaded
        var vcount = lvcount + mhvcount + mtvcount + tvcount;
        var icount = licount + mhicount + mticount + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderLine(voffset, ioffset, lvcount, licount),
                toBuilderMarkerTail(mttype, mtvoffset, mtioffset),
                toBuilderMarkerHead(mhtype, mhvoffset, mhioffset),
                new BuilderText(tvoffset, tioffset, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorElbowPointsFiller = /** @class */ (function () {
        function EShapeConnectorElbowPointsFiller(x, y, values) {
            this._threshold = 0.000001;
            this._x = x;
            this._y = y;
            this._z = 0;
            this._values = values;
            values[0] = x;
            values[1] = y;
            this.index = 0;
        }
        Object.defineProperty(EShapeConnectorElbowPointsFiller.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                if (this._z === 0 || this._threshold < Math.abs(this._x - x)) {
                    this._x = x;
                    var index = this.index;
                    var values = this._values;
                    if (this._z === 1) {
                        values[index + 0] = this._x;
                        values[index + 1] = this._y;
                    }
                    else {
                        values[index + 2] = this._x;
                        values[index + 3] = this._y;
                        this.index += 2;
                        this._z = 1;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeConnectorElbowPointsFiller.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                if (this._z === 0 || this._threshold < Math.abs(this._y - y)) {
                    this._y = y;
                    var index = this.index;
                    var values = this._values;
                    if (this._z === 2) {
                        values[index + 0] = this._x;
                        values[index + 1] = this._y;
                    }
                    else {
                        values[index + 2] = this._x;
                        values[index + 3] = this._y;
                        this.index += 2;
                        this._z = 2;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeConnectorElbowPointsFiller.prototype.toAxis = function (dx, dy, nx, ny) {
            var anx = Math.abs(nx);
            var any = Math.abs(ny);
            var threshold = this._threshold;
            if (anx < threshold && any < threshold) {
                if (Math.abs(dx) < Math.abs(dy)) {
                    if (0 <= dy) {
                        return 2;
                    }
                    else {
                        return 0;
                    }
                }
                else {
                    if (0 <= dx) {
                        return 1;
                    }
                    else {
                        return 3;
                    }
                }
            }
            var s = 0.2;
            if (0 <= nx) {
                if (0 <= ny) {
                    if (s < anx && s < any) {
                        if (dx < dy) {
                            return 2;
                        }
                        else {
                            return 1;
                        }
                    }
                    else if (s < anx) {
                        return 1;
                    }
                    else {
                        return 2;
                    }
                }
                else {
                    if (s < anx && s < any) {
                        if (dx < -dy) {
                            return 0;
                        }
                        else {
                            return 1;
                        }
                    }
                    else if (s < anx) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
            }
            else {
                if (0 <= ny) {
                    if (s < anx && s < any) {
                        if (-dx < dy) {
                            return 2;
                        }
                        else {
                            return 3;
                        }
                    }
                    else if (s < anx) {
                        return 3;
                    }
                    else {
                        return 2;
                    }
                }
                else {
                    if (s < anx && s < any) {
                        if (dy < dx) {
                            return 0;
                        }
                        else {
                            return 3;
                        }
                    }
                    else if (s < anx) {
                        return 3;
                    }
                    else {
                        return 0;
                    }
                }
            }
        };
        EShapeConnectorElbowPointsFiller.prototype.toTailAxis = function (x, y, nx, ny) {
            return this.toAxis(x - this.x, y - this.y, nx, ny);
        };
        EShapeConnectorElbowPointsFiller.prototype.tail = function (x, y, nx, ny, sxh, syh, margin) {
            switch (this.toTailAxis(x, y, nx, ny)) {
                case 0:
                    if (this.y - margin <= y) {
                        this.y -= Math.max(margin, syh);
                        this.x = x;
                    }
                    else {
                        this.y = y;
                    }
                    break;
                case 1:
                    if (x <= this.x + margin) {
                        this.x += Math.max(margin, sxh);
                        this.y = y;
                    }
                    else {
                        this.x = x;
                    }
                    break;
                case 2:
                    if (y <= this.y + margin) {
                        this.y += Math.max(margin, sxh);
                        this.x = x;
                    }
                    else {
                        this.y = y;
                    }
                    break;
                case 3:
                    if (this.x - margin <= x) {
                        this.x -= Math.max(margin, sxh);
                        this.y = y;
                    }
                    else {
                        this.x = x;
                    }
                    break;
            }
        };
        EShapeConnectorElbowPointsFiller.prototype.middle = function (x, y) {
            var dx = x - this._x;
            var dy = y - this._y;
            if (Math.abs(dx) < Math.abs(dy)) {
                this.y = y;
            }
            else {
                this.x = x;
            }
        };
        EShapeConnectorElbowPointsFiller.prototype.toHeadAxis = function (x, y, nx, ny) {
            return this.toAxis(this.x - x, this.y - y, nx, ny);
        };
        EShapeConnectorElbowPointsFiller.prototype.head = function (x, y, nx, ny, sxh, syh, margin) {
            switch (this.toHeadAxis(x, y, nx, ny)) {
                case 0:
                    if (y - margin <= this.y) {
                        this.y = y - Math.max(margin, syh);
                    }
                    this.x = x;
                    this.y = y;
                    break;
                case 1:
                    if (this.x <= x + margin) {
                        this.x = x + Math.max(margin, sxh);
                    }
                    this.y = y;
                    this.x = x;
                    break;
                case 2:
                    if (this.y <= y + margin) {
                        this.y = y + Math.max(margin, syh);
                    }
                    this.x = x;
                    this.y = y;
                    break;
                case 3:
                    if (x - margin <= this.x) {
                        this.x = x - Math.max(margin, sxh);
                    }
                    this.y = y;
                    this.x = x;
                    break;
            }
        };
        EShapeConnectorElbowPointsFiller.prototype.margin = function (tail, head) {
            var values = this._values;
            // Tail
            var index = this.index;
            if (tail !== 0 && 2 <= index) {
                var x0 = values[0];
                var y0 = values[1];
                var dx = values[2] - x0;
                var dy = values[3] - y0;
                var d = dx * dx + dy * dy;
                var threshold = this._threshold;
                if (threshold < d) {
                    var f = tail / Math.sqrt(dx * dx + dy * dy);
                    if (threshold < Math.abs(f - 1)) {
                        values[0] = x0 + dx * f;
                        values[1] = y0 + dy * f;
                    }
                    else {
                        this.index -= 2;
                    }
                }
            }
            // Head
            index = this.index;
            if (head !== 0 && 2 <= index) {
                var x1 = values[index + 0];
                var y1 = values[index + 1];
                var dx = values[index - 2] - x1;
                var dy = values[index - 1] - y1;
                var d = dx * dx + dy * dy;
                var threshold = this._threshold;
                if (threshold < d) {
                    var f = head / Math.sqrt(dx * dx + dy * dy);
                    if (threshold < Math.abs(f - 1)) {
                        values[index + 0] = x1 + dx * f;
                        values[index + 1] = y1 + dy * f;
                    }
                    else {
                        this.index -= 2;
                    }
                }
            }
            // Remote the rest
            values.length = this.index + 2;
        };
        return EShapeConnectorElbowPointsFiller;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorElbow = /** @class */ (function (_super) {
        __extends(EShapeConnectorElbow, _super);
        function EShapeConnectorElbow(type) {
            if (type === void 0) { type = EShapeType.CONNECTOR_ELBOW; }
            return _super.call(this, type) || this;
        }
        EShapeConnectorElbow.prototype.fillPoints = function (tail, tailMargin, head, headMargin, body, px, py, values) {
            // Tail
            var tailLocal = tail.local;
            var tailLocalX = tailLocal.x;
            var tailLocalY = tailLocal.y;
            var tailNormal = tail.normal;
            var tailNormalX = tailNormal.x;
            var tailNormalY = tailNormal.y;
            // Head
            var headLocal = head.local;
            var headLocalX = headLocal.x;
            var headLocalY = headLocal.y;
            var headNormal = head.normal;
            var headNormalX = headNormal.x;
            var headNormalY = headNormal.y;
            // Body
            var bodyValues = body.values;
            var bodyValuesLength = bodyValues.length;
            // Values
            var x0 = tailLocalX - px;
            var y0 = tailLocalY - py;
            var x1 = headLocalX - px;
            var y1 = headLocalY - py;
            var cx = (x1 + x0) * 0.5;
            var cy = (y1 + y0) * 0.5;
            var dx = x1 - x0;
            var dy = y1 - y0;
            var sxh = 0.5 * EShapeDefaults.SIZE_X;
            var syh = 0.5 * EShapeDefaults.SIZE_Y;
            var threshold = 0.000001;
            if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) {
                values[0] = x0;
                values[1] = y0;
                values[2] = x1;
                values[3] = y1;
                values.length = 4;
            }
            else {
                var filler = new EShapeConnectorElbowPointsFiller(x0, y0, values);
                if (0 < bodyValuesLength) {
                    var a = Math.atan2(dy, dx);
                    var l = Math.sqrt(dx * dx + dy * dy);
                    var c = Math.cos(a) * l;
                    var s = Math.sin(a) * l;
                    var x3 = bodyValues[0];
                    var y3 = bodyValues[1];
                    var x4 = cx + c * x3 - s * y3;
                    var y4 = cy + c * y3 + s * x3;
                    filler.tail(x4, y4, tailNormalX, tailNormalY, sxh, syh, tailMargin);
                    for (var i = 2; i < bodyValuesLength; i += 2) {
                        var x = bodyValues[i + 0];
                        var y = bodyValues[i + 1];
                        var x5 = cx + c * x - s * y;
                        var y5 = cy + c * y + s * x;
                        filler.middle(x5, y5);
                    }
                    filler.head(x1, y1, headNormalX, headNormalY, sxh, syh, headMargin);
                }
                else {
                    filler.tail(cx, cy, tailNormalX, tailNormalY, sxh, syh, tailMargin);
                    filler.head(x1, y1, headNormalX, headNormalY, sxh, syh, headMargin);
                }
                filler.margin(tailMargin, headMargin);
            }
        };
        return EShapeConnectorElbow;
    }(EShapeConnectorLine));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeConnectorElbow = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeConnectorElbow());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeConnectorBodies = /** @class */ (function () {
        function EShapeConnectorBodies() {
        }
        EShapeConnectorBodies.from = function (values, tailMargin, headMargin) {
            var result = [];
            var length = values.length;
            if (4 < length) {
                var threshold = 0.000001;
                var x0 = values[0];
                var y0 = values[1];
                if (tailMargin !== 0) {
                    var ex = x0 - values[2];
                    var ey = y0 - values[3];
                    var n = ex * ex + ey * ey;
                    if (threshold < n) {
                        var f = tailMargin / Math.sqrt(n);
                        x0 += ex * f;
                        y0 += ey * f;
                    }
                }
                var x1 = values[length - 2];
                var y1 = values[length - 1];
                if (headMargin !== 0) {
                    var ex = x1 - values[length - 4];
                    var ey = y1 - values[length - 3];
                    var n = ex * ex + ey * ey;
                    if (threshold < n) {
                        var f = headMargin / Math.sqrt(n);
                        x1 += ex * f;
                        y1 += ey * f;
                    }
                }
                var cx = (x1 + x0) * 0.5;
                var cy = (y1 + y0) * 0.5;
                var dx = x1 - x0;
                var dy = y1 - y0;
                var a = Math.atan2(dy, dx);
                var c = Math.cos(a);
                var s = Math.sin(a);
                var l = dx * dx + dy * dy;
                var m = threshold < l ? 1 / Math.sqrt(l) : 1;
                for (var i = 2, imax = length - 2; i < imax; i += 2) {
                    var x = values[i + 0] - cx;
                    var y = values[i + 1] - cy;
                    result.push((c * x + s * y) * m, (c * y - s * x) * m);
                }
            }
            return result;
        };
        return EShapeConnectorBodies;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeConnectorLine = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeConnectorLine());
    };
    var onDeserializedConnectorLine = function (item, shape, mapping, manager) {
        if (shape instanceof EShapeConnectorLine) {
            var resources = manager.resources;
            var resourceId = item[15];
            if (0 <= resourceId && resourceId < resources.length) {
                var parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                // Lock
                shape.lock();
                // Points
                var points = shape.points;
                points.deserialize(parsed[1], manager);
                // Edge
                var edge = shape.edge;
                edge.deserialize(parsed[0], mapping, manager);
                // Body
                var body = shape.body;
                var bodyId = parsed[2];
                if (bodyId != null) {
                    body.deserialize(bodyId, mapping, manager);
                }
                else {
                    // The following is for backward compatibility.
                    body.set(EShapeConnectorBodies.from(points.values, edge.tail.margin, edge.head.margin));
                }
                // Unlock
                shape.unlock();
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeConnectorElbow = function () {
        EShapeUploadeds[EShapeType.CONNECTOR_ELBOW] = createLineUploaded;
        EShapeDeserializers[EShapeType.CONNECTOR_ELBOW] = deserializeConnectorElbow;
        EShapeOnDeserializeds[EShapeType.CONNECTOR_ELBOW] = onDeserializedConnectorLine;
        EShapeCapabilities.set(EShapeType.CONNECTOR_ELBOW, EShapeCapability.CONNECTOR);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeConnectorLine = function () {
        EShapeUploadeds[EShapeType.CONNECTOR_LINE] = createLineUploaded;
        EShapeDeserializers[EShapeType.CONNECTOR_LINE] = deserializeConnectorLine;
        EShapeOnDeserializeds[EShapeType.CONNECTOR_LINE] = onDeserializedConnectorLine;
        EShapeCapabilities.set(EShapeType.CONNECTOR_LINE, EShapeCapability.CONNECTOR);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderRectanglePivoted = /** @class */ (function (_super) {
        __extends(BuilderRectanglePivoted, _super);
        function BuilderRectanglePivoted() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderRectanglePivoted.prototype.init = function (buffer) {
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
        };
        BuilderRectanglePivoted.prototype.update = function (buffer, shape) {
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
        };
        BuilderRectanglePivoted.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0.5 * sizeX, 0.5 * sizeY, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // Clippings
                if (isVertexChanged) {
                    buffer.updateClippings();
                    buildRectangleClipping(buffer.clippings, voffset, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, toTextureUvs(texture), RECTANGLE_WORLD_SIZE);
                }
            }
        };
        return BuilderRectanglePivoted;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectanglePivotedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = RECTANGLE_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderRectanglePivoted(voffset, ioffset, vcount - tvcount, icount - ticount),
                new BuilderText(voffset + RECTANGLE_VERTEX_COUNT, ioffset + RECTANGLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createGroupUploaded = function (buffer, shape, voffset, ioffset) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = tvcount;
        var icount = ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderText(voffset, ioffset, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var create = function (name, width, height, container, manager, item, shape) {
        var mode = manager.mode;
        var depth = manager.depth;
        shape = shape || new EShapeEmbedded(name, mode, depth);
        var result = deserializeBase(item, manager, shape);
        var shapeSize = shape.size;
        var sizeX = shapeSize.x;
        var sizeY = shapeSize.y;
        shape.size.set(width, height);
        container.copyTo(shape);
        shape.size.init();
        shape.size.set(sizeX, sizeY);
        if (mode === EShapeResourceManagerDeserializationMode.EDITOR) {
            if (0 < depth) {
                applyDataMappings(shape, manager);
            }
        }
        else {
            applyDataMappings(shape, manager);
        }
        return result;
    };
    var createMissing = function (name, manager, item, shape) {
        var mode = manager.mode;
        var depth = manager.depth;
        shape = shape || new EShapeEmbedded(name, mode, depth);
        var result = deserializeBase(item, manager, shape);
        var size = shape.size;
        var sizeX = size.x;
        var sizeY = size.y;
        var children = shape.children;
        var layer = new EShapeEmbeddedLayer("missing", mode, depth);
        var px = 0.5 * sizeX;
        var py = 0.5 * sizeX;
        layer.transform.position.set(-px, -py);
        layer.size.set(sizeX, sizeY);
        layer.size.init();
        layer.parent = shape;
        var rectangle = new EShapeRectangle();
        rectangle.stroke.color = 0xff0000;
        rectangle.transform.position.set(px, py);
        rectangle.size.copyFrom(shape.size);
        rectangle.attach(layer);
        children.push(layer);
        shape.onChildTransformChange();
        shape.toDirty();
        shape.onAttach();
        shape.size.init();
        if (mode === EShapeResourceManagerDeserializationMode.EDITOR) {
            if (0 < depth) {
                applyDataMappings(shape, manager);
            }
        }
        else {
            applyDataMappings(shape, manager);
        }
        return result;
    };
    var applyDataMappings = function (shape, manager) {
        var mapping = shape.data.getMapping();
        if (mapping != null) {
            var values = mapping.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                var source = value[0];
                var mapper = manager.getDataMapper(source);
                if (mapper != null) {
                    var children = shape.children;
                    var destination = manager.getDataDestination(value[1]);
                    var initial = value[2];
                    applyDataMapping(children, mapper, destination, initial);
                }
            }
        }
    };
    var applyDataMapping = function (targets, mapper, destination, initial) {
        for (var i = 0, imax = targets.length; i < imax; ++i) {
            var target = targets[i];
            var targetData = target.data;
            for (var j = 0, jmax = targetData.size(); j < jmax; ++j) {
                var targetDatum = targetData.get(j);
                if (targetDatum && targetDatum.scope !== EShapeDataValueScope.PRIVATE) {
                    mapper.map(targetDatum, destination, initial);
                }
            }
            // Children
            var children = target.children;
            if (0 < children.length) {
                applyDataMapping(children, mapper, destination, initial);
            }
        }
    };
    var deserializeEmbedded = function (item, manager, creator) {
        var pieces = manager.pieces;
        var pieceId = item[15];
        if (pieces && 0 <= pieceId && pieceId < pieces.length) {
            var pieceData = manager.pieceData;
            if (pieceData) {
                var piece = pieces[pieceId];
                var pieceDatum = pieceData.get(piece);
                var shape = creator && creator(piece, manager);
                if (pieceDatum) {
                    return create(piece, pieceDatum.width, pieceDatum.height, pieceDatum.layer, manager, item, shape);
                }
                else {
                    return createMissing(piece, manager, item, shape);
                }
            }
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeEmbedded = function () {
        EShapeUploadeds[EShapeType.EMBEDDED] = createGroupUploaded;
        EShapeDeserializers[EShapeType.EMBEDDED] = deserializeEmbedded;
        EShapeCapabilities.set(EShapeType.EMBEDDED, EShapeCapability.EMBEDDED);
        EShapeUploadeds[EShapeType.EMBEDDED_LAYER] = createRectanglePivotedUploaded;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupFillEditor = /** @class */ (function () {
        function EShapeGroupFillEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupFillEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.enable;
                }
                return true;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.enable = enable;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.color = color;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupFillEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].fill.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].fill.alpha = alpha;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupFillEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.copy(target);
            }
        };
        EShapeGroupFillEditor.prototype.set = function (enable, color, alpha) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.set(enable, color, alpha);
            }
        };
        EShapeGroupFillEditor.prototype.clone = function () {
            return new EShapeGroupFillEditor(this._parent);
        };
        EShapeGroupFillEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].fill.toObject();
            }
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        };
        EShapeGroupFillEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupFillEditor.prototype.deserialize = function (target, manager) {
            // DO NOTHING
        };
        return EShapeGroupFillEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupPoints = /** @class */ (function () {
        function EShapeGroupPoints(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupPoints.prototype, "length", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.length;
                    }
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "id", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.id;
                    }
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "values", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.values;
                    }
                }
                return [];
            },
            set: function (values) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.values = values;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "segments", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.segments;
                    }
                }
                return [];
            },
            set: function (segments) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.segments = segments;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "style", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.style;
                    }
                }
                return EShapePointsStyle.NONE;
            },
            set: function (style) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.style = style;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "marker", {
            get: function () {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        return points.marker;
                    }
                }
                return EShapePointsMarkerContainerImplNoop.getInstance();
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupPoints.prototype.getMarker = function () {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.getMarker();
                }
            }
            return undefined;
        };
        Object.defineProperty(EShapeGroupPoints.prototype, "formatter", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.formatter;
                    }
                }
                return null;
            },
            set: function (formatter) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var points = children[i].points;
                    if (points != null) {
                        points.formatter = formatter;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupPoints.prototype, "formatted", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    var points = children[children.length - 1].points;
                    if (points != null) {
                        return points.formatted;
                    }
                }
                return this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupPoints.prototype.onSizeChange = function () {
            // DO NOTHING
        };
        EShapeGroupPoints.prototype.copy = function (source) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    points.copy(source);
                }
            }
            return this;
        };
        EShapeGroupPoints.prototype.set = function (values, segments, style) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    points.set(values, segments, style);
                }
            }
            return this;
        };
        EShapeGroupPoints.prototype.clone = function (parent) {
            return new EShapeGroupPoints(parent);
        };
        EShapeGroupPoints.prototype.toPoints = function (transform) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.toPoints(transform);
                }
            }
            return [];
        };
        EShapeGroupPoints.prototype.serialize = function (manager) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var points = children[i].points;
                if (points != null) {
                    return points.serialize(manager);
                }
            }
            return -1;
        };
        return EShapeGroupPoints;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupStrokeEditor = /** @class */ (function () {
        function EShapeGroupStrokeEditor(parent) {
            this._parent = parent;
        }
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "enable", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.enable;
                }
                return false;
            },
            set: function (enable) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.enable = enable;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "color", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.color;
                }
                return 0xffffff;
            },
            set: function (color) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.color = color;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "alpha", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.alpha;
                }
                return 1.0;
            },
            set: function (alpha) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.alpha = alpha;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "width", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.width;
                }
                return 1.0;
            },
            set: function (width) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.width = width;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "align", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.align;
                }
                return 1.0;
            },
            set: function (align) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.align = align;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "side", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.side;
                }
                return 1.0;
            },
            set: function (side) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.side = side;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupStrokeEditor.prototype, "style", {
            get: function () {
                var children = this._parent.children;
                if (0 < children.length) {
                    return children[children.length - 1].stroke.style;
                }
                return EShapeStrokeStyle.NONE;
            },
            set: function (style) {
                var children = this._parent.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].stroke.style = style;
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupStrokeEditor.prototype.copy = function (target) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.copy(target);
            }
        };
        EShapeGroupStrokeEditor.prototype.set = function (enable, color, alpha, width, side) {
            var children = this._parent.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.set(enable, color, alpha, width, side);
            }
        };
        EShapeGroupStrokeEditor.prototype.clone = function () {
            return new EShapeGroupStrokeEditor(this._parent);
        };
        EShapeGroupStrokeEditor.prototype.toObject = function () {
            var children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.toObject();
            }
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE,
                style: EShapeStrokeStyle.NONE
            };
        };
        EShapeGroupStrokeEditor.prototype.serialize = function (manager) {
            return -1;
        };
        EShapeGroupStrokeEditor.prototype.deserialize = function (target, manager) {
            //
        };
        return EShapeGroupStrokeEditor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroup = /** @class */ (function (_super) {
        __extends(EShapeGroup, _super);
        function EShapeGroup(mode, type) {
            if (type === void 0) { type = EShapeType.GROUP; }
            var _this = _super.call(this, type) || this;
            _this._mode = mode;
            var data = new EShapeDataImpl();
            _this.data = data;
            _this.tag = data;
            _this.size = _this.newGroupSize(mode);
            _this.fill = _this.newGroupFill();
            _this.stroke = _this.newGroupStroke();
            _this.text = _this.newGroupText();
            _this._points = _this.newGroupPoints();
            return _this;
        }
        Object.defineProperty(EShapeGroup.prototype, "mode", {
            get: function () {
                return this._mode;
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroup.prototype.newGroupSize = function (mode) {
            var sizeX = EShapeDefaults.SIZE_X;
            var sizeY = EShapeDefaults.SIZE_Y;
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        };
        EShapeGroup.prototype.isGroupSizeFittable = function () {
            return true;
        };
        EShapeGroup.prototype.newGroupFill = function () {
            return new EShapeGroupFillEditor(this);
        };
        EShapeGroup.prototype.newGroupStroke = function () {
            return new EShapeGroupStrokeEditor(this);
        };
        EShapeGroup.prototype.newGroupText = function () {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.TEXT_COLOR, EShapeDefaults.TEXT_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        };
        EShapeGroup.prototype.newGroupPoints = function () {
            return new EShapeGroupPoints(this);
        };
        EShapeGroup.prototype.getBoundsSize = function () {
            var size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                return size.base;
            }
            else {
                return size;
            }
        };
        EShapeGroup.prototype.onChildTransformChange = function () {
            _super.prototype.onChildTransformChange.call(this);
            this.size.fit();
        };
        Object.defineProperty(EShapeGroup.prototype, "corner", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].corner;
                }
                return EShapeCorner.ALL;
            },
            set: function (corner) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].corner = corner;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "gradient", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var gradient = children[i].gradient;
                    if (gradient != null) {
                        return gradient;
                    }
                }
                return undefined;
            },
            set: function (gradient) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].gradient = gradient;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "radius", {
            get: function () {
                var children = this.children;
                if (0 < children.length) {
                    return children[children.length - 1].radius;
                }
                return 0.5;
            },
            set: function (radius) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].radius = radius;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "image", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var image = children[i].image;
                    if (image != null) {
                        return image;
                    }
                }
                return undefined;
            },
            set: function (image) {
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    children[i].image = image;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroup.prototype, "points", {
            get: function () {
                var children = this.children;
                for (var i = children.length - 1; 0 <= i; --i) {
                    var points = children[i].points;
                    if (points != null) {
                        return this._points;
                    }
                }
                return undefined;
            },
            set: function (points) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroup.prototype.clone = function () {
            var result = this.newClone().copy(this);
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            return result;
        };
        EShapeGroup.prototype.newClone = function () {
            var constructor = this.constructor;
            return new constructor(this._mode, this.type);
        };
        EShapeGroup.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            return false;
        };
        return EShapeGroup;
    }(EShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeGroup = function (item, manager, shape) {
        shape = shape || new EShapeGroup(manager.mode);
        var result = deserializeBase(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeGroup = function () {
        EShapeUploadeds[EShapeType.GROUP] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP] = deserializeGroup;
        EShapeCapabilities.set(EShapeType.GROUP, EShapeCapability.GROUP);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupSizeShadowed = /** @class */ (function () {
        function EShapeGroupSizeShadowed(parent, x, y) {
            this._parent = parent;
            this._size = new pixi_js.Point(x, y);
        }
        EShapeGroupSizeShadowed.prototype.init = function () {
            return this;
        };
        Object.defineProperty(EShapeGroupSizeShadowed.prototype, "x", {
            get: function () {
                return this._size.x;
            },
            set: function (x) {
                var size = this._size;
                if (size.x !== x) {
                    var ox = size.x;
                    size.x = x;
                    this.onChange(ox, size.y);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeGroupSizeShadowed.prototype, "y", {
            get: function () {
                return this._size.y;
            },
            set: function (y) {
                var size = this._size;
                if (size.y !== y) {
                    var oy = size.y;
                    size.y = y;
                    this.onChange(size.x, oy);
                }
            },
            enumerable: false,
            configurable: true
        });
        EShapeGroupSizeShadowed.prototype.set = function (x, y) {
            var isChanged = false;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeShadowed.prototype.clone = function () {
            var size = this._size;
            return new EShapeGroupSizeShadowed(this._parent, size.x, size.y);
        };
        EShapeGroupSizeShadowed.prototype.copy = function () {
            // DO NOTHING
        };
        EShapeGroupSizeShadowed.prototype.copyFrom = function (point) {
            var x = point.x;
            var y = point.y;
            var size = this._size;
            var ox = size.x;
            var oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        };
        EShapeGroupSizeShadowed.prototype.copyTo = function (point) {
            return this._size.copyTo(point);
        };
        EShapeGroupSizeShadowed.prototype.equals = function (point) {
            return this._size.equals(point);
        };
        EShapeGroupSizeShadowed.prototype.fit = function () {
            return this;
        };
        EShapeGroupSizeShadowed.prototype.onChange = function (ox, oy) {
            this._parent.onSizeChange();
        };
        return EShapeGroupSizeShadowed;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeGroupShadowed = /** @class */ (function (_super) {
        __extends(EShapeGroupShadowed, _super);
        function EShapeGroupShadowed(mode, type) {
            if (type === void 0) { type = EShapeType.GROUP_SHADOWED; }
            return _super.call(this, mode, type) || this;
        }
        EShapeGroupShadowed.prototype.newGroupSize = function (mode) {
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER) {
                return new EShapeGroupSizeShadowed(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            }
            else {
                return _super.prototype.newGroupSize.call(this, mode);
            }
        };
        return EShapeGroupShadowed;
    }(EShapeGroup));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeGroupShadowed = function (item, manager, shape) {
        shape = shape || new EShapeGroupShadowed(manager.mode);
        var result = deserializeBase(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeGroupShadowed = function () {
        EShapeUploadeds[EShapeType.GROUP_SHADOWED] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP_SHADOWED] = deserializeGroupShadowed;
        EShapeCapabilities.set(EShapeType.GROUP_SHADOWED, EShapeCapability.GROUP);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderRectangle = /** @class */ (function (_super) {
        __extends(BuilderRectangle, _super);
        function BuilderRectangle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderRectangle.prototype.init = function (buffer) {
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
        };
        BuilderRectangle.prototype.update = function (buffer, shape) {
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
        };
        BuilderRectangle.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // Clippings
                if (isVertexChanged) {
                    buffer.updateClippings();
                    buildRectangleClipping(buffer.clippings, voffset, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, toTextureUvs(texture), RECTANGLE_WORLD_SIZE);
                }
            }
        };
        return BuilderRectangle;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createRectangleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = RECTANGLE_VERTEX_COUNT + tvcount;
        var icount = RECTANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderRectangle(voffset, ioffset, vcount - tvcount, icount - ticount),
                new BuilderText(voffset + RECTANGLE_VERTEX_COUNT, ioffset + RECTANGLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImage = /** @class */ (function (_super) {
        __extends(EShapeImage, _super);
        function EShapeImage(image, type) {
            if (type === void 0) { type = EShapeType.IMAGE; }
            var _this = _super.call(this, type) || this;
            if (image != null) {
                _this.image = image;
                _this.size.set(image.width, image.height);
            }
            _this.fill.alpha = 1;
            return _this;
        }
        EShapeImage.prototype.clone = function () {
            return new EShapeImage(this.image, this.type).copy(this);
        };
        return EShapeImage;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeImage = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeImage());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeImage = function () {
        EShapeUploadeds[EShapeType.IMAGE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.IMAGE] = deserializeImage;
    };

    var IMAGE_SDF_VERTEX_COUNT = 9;
    var IMAGE_SDF_INDEX_COUNT = 8;
    var IMAGE_SDF_WORLD_SIZE = [0, 0];
    var IMAGE_SDF_WORK_POINT = new pixi_js.Point();
    var buildImageSdfClipping = function (clippings, voffset) {
        var ic = voffset * 3 - 1;
        var icmax = (voffset + IMAGE_SDF_VERTEX_COUNT) * 3 - 1;
        for (; ic < icmax;) {
            clippings[++ic] = 0;
            clippings[++ic] = 0;
            clippings[++ic] = 2;
        }
    };
    var buildImageSdfIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 7;
    };
    var buildImageSdfStep = function (steps, voffset, strokeAlign, strokeWidth, strokeStyle, textureWidth, textureHeight, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var scaleX = textureWidth / worldSize[0];
        var scaleY = textureHeight / worldSize[1];
        var scaleZ = (scaleX + scaleY) * 0.5;
        var strokeWidthMax = 12;
        var position = -1 + strokeAlign;
        var is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleZ;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleY;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleZ;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleX;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleZ;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleX;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleZ;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleY;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = scaleInvariant;
        steps[++is] = scaleY;
        steps[++is] = strokeWidthMax;
        steps[++is] = position;
        steps[++is] = 0;
    };
    var buildImageSdfVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        // 0       1       2
        // |-------|-------|
        // |       |       |
        // 3-------4-------5
        // |       |       |
        // |-------|-------|
        // 6       7       8
        //
        var work = IMAGE_SDF_WORK_POINT;
        var sx = sizeX * 0.5;
        var sy = sizeY * 0.5;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        var x2 = work.x;
        var y2 = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        var x8 = work.x;
        var y8 = work.y;
        var x6 = x0 + (x8 - x2);
        var y6 = y0 + (y8 - y2);
        // Vertices
        var iv = (voffset << 1) - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = (x0 + x2) * 0.5;
        vertices[++iv] = (y0 + y2) * 0.5;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = (x0 + x6) * 0.5;
        vertices[++iv] = (y0 + y6) * 0.5;
        vertices[++iv] = (x0 + x8) * 0.5;
        vertices[++iv] = (y0 + y8) * 0.5;
        vertices[++iv] = (x2 + x8) * 0.5;
        vertices[++iv] = (y2 + y8) * 0.5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = (x6 + x8) * 0.5;
        vertices[++iv] = (y6 + y8) * 0.5;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        worldSize[0] = toLength(x0, y0, x2, y2) * 0.5;
        worldSize[1] = toLength(x0, y0, x6, y6) * 0.5;
    };
    var buildImageSdfUv = function (uvs, voffset, textureUv) {
        var x0 = textureUv.x0;
        var y0 = textureUv.y0;
        var x1 = textureUv.x1;
        var y1 = textureUv.y1;
        var x2 = textureUv.x2;
        var y2 = textureUv.y2;
        var x3 = textureUv.x3;
        var y3 = textureUv.y3;
        var iv = (voffset << 1) - 1;
        uvs[++iv] = x0;
        uvs[++iv] = y0;
        uvs[++iv] = (x1 + x0) * 0.5;
        uvs[++iv] = (y1 + y0) * 0.5;
        uvs[++iv] = x1;
        uvs[++iv] = y1;
        uvs[++iv] = (x0 + x3) * 0.5;
        uvs[++iv] = (y0 + y3) * 0.5;
        uvs[++iv] = (x0 + x2) * 0.5;
        uvs[++iv] = (y0 + y2) * 0.5;
        uvs[++iv] = (x1 + x2) * 0.5;
        uvs[++iv] = (y1 + y2) * 0.5;
        uvs[++iv] = x3;
        uvs[++iv] = y3;
        uvs[++iv] = (x3 + x2) * 0.5;
        uvs[++iv] = (y3 + y2) * 0.5;
        uvs[++iv] = x2;
        uvs[++iv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderImageSdf = /** @class */ (function (_super) {
        __extends(BuilderImageSdf, _super);
        function BuilderImageSdf(vertexOffset, indexOffset) {
            var _this = _super.call(this, vertexOffset, indexOffset, IMAGE_SDF_VERTEX_COUNT, IMAGE_SDF_INDEX_COUNT) || this;
            _this.textureWidth = -1;
            _this.textureHeight = -1;
            return _this;
        }
        BuilderImageSdf.prototype.init = function (buffer) {
            var voffset = this.vertexOffset;
            buffer.updateClippings();
            buffer.updateIndices();
            buildImageSdfClipping(buffer.clippings, voffset);
            buildImageSdfIndex(buffer.indices, voffset, this.indexOffset);
        };
        BuilderImageSdf.prototype.update = function (buffer, shape) {
            this.updateVertexAndStep(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderImageSdf.prototype.updateVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureWidth = texture.width * texture.resolution;
            var textureHeight = texture.height * texture.resolution;
            var isTextureSizeChanged = this.textureWidth !== textureWidth || this.textureHeight !== textureHeight;
            if (isSizeChanged || isTransformChanged || isStrokeChanged || isTextureSizeChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.textureWidth = textureWidth;
                this.textureHeight = textureHeight;
                // Vertices
                buffer.updateVertices();
                buildImageSdfVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, shape.transform.internalTransform, IMAGE_SDF_WORLD_SIZE);
                // Steps
                buffer.updateSteps();
                buildImageSdfStep(buffer.steps, this.vertexOffset, strokeAlign, strokeWidth, strokeStyle, textureWidth, textureHeight, IMAGE_SDF_WORLD_SIZE);
            }
        };
        BuilderImageSdf.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildImageSdfUv(buffer.uvs, this.vertexOffset, toTextureUvs(texture));
            }
        };
        return BuilderImageSdf;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImageSdfUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = IMAGE_SDF_VERTEX_COUNT + tvcount;
        var icount = IMAGE_SDF_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderImageSdf(voffset, ioffset),
                new BuilderText(voffset + IMAGE_SDF_VERTEX_COUNT, ioffset + IMAGE_SDF_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeImageSdf = /** @class */ (function (_super) {
        __extends(EShapeImageSdf, _super);
        function EShapeImageSdf(image, type) {
            if (type === void 0) { type = EShapeType.IMAGE_SDF; }
            return _super.call(this, image, type) || this;
        }
        EShapeImageSdf.prototype.clone = function () {
            return new EShapeImageSdf(this.image, this.type).copy(this);
        };
        return EShapeImageSdf;
    }(EShapeImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeImageSdf = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeImageSdf());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeImageSdf = function () {
        EShapeUploadeds[EShapeType.IMAGE_SDF] = createImageSdfUploaded;
        EShapeDeserializers[EShapeType.IMAGE_SDF] = deserializeImageSdf;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLabel = /** @class */ (function () {
        function BuilderLabel(vertexOffset, indexOffset, vertexCount, indexCount) {
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = vertexCount;
            this.indexCount = indexCount;
            this.texture = null;
        }
        BuilderLabel.prototype.init = function (buffer) {
            // DO NOTHING
        };
        BuilderLabel.prototype.isCompatible = function (shape) {
            return true;
        };
        BuilderLabel.prototype.update = function (buffer, shape) {
            this.texture = toTexture(shape);
        };
        BuilderLabel.prototype.buildUnit = function (builder) {
            var texture = this.texture || pixi_js.Texture.WHITE;
            var baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                var indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        };
        return BuilderLabel;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLabelUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = tvcount;
        var icount = ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderLabel(voffset, ioffset, vcount - tvcount, icount - ticount),
                new BuilderText(voffset, ioffset, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLabel = /** @class */ (function (_super) {
        __extends(EShapeLabel, _super);
        function EShapeLabel(type) {
            if (type === void 0) { type = EShapeType.LABEL; }
            return _super.call(this, type) || this;
        }
        EShapeLabel.prototype.clone = function () {
            return new EShapeLabel(this.type).copy(this);
        };
        return EShapeLabel;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLabel = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLabel());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLabel = function () {
        EShapeUploadeds[EShapeType.LABEL] = createLabelUploaded;
        EShapeDeserializers[EShapeType.LABEL] = deserializeLabel;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLine = /** @class */ (function (_super) {
        __extends(EShapeLine, _super);
        function EShapeLine(type) {
            if (type === void 0) { type = EShapeType.LINE; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLinePoints(_this);
            return _this;
        }
        Object.defineProperty(EShapeLine.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLine.prototype.clone = function () {
            return new EShapeLine(this.type).copy(this);
        };
        EShapeLine.prototype.serialize = function (manager) {
            var result = _super.prototype.serialize.call(this, manager);
            result[15] = this._points.serialize(manager);
            return result;
        };
        return EShapeLine;
    }(EShapeLineBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLine = function (item, manager, shape) {
        shape = shape || new EShapeLine();
        var result = deserializeBase(item, manager, shape);
        shape.points.deserialize(item[15], manager);
        var style = shape.points.style;
        var mask = EShapePointsStyle.NON_SCALING_MASK |
            EShapePointsStyle.DOTTED_MASK |
            EShapePointsStyle.DASHED_MASK;
        var deprecated = style & mask;
        if (deprecated) {
            shape.points.style &= ~mask;
            shape.stroke.style |= deprecated;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLine = function () {
        EShapeUploadeds[EShapeType.LINE] = createLineUploaded;
        EShapeDeserializers[EShapeType.LINE] = deserializeLine;
    };

    var buildNullClipping = function (clippings, voffset, vcount) {
        for (var i = voffset * 3, imax = (voffset + vcount) * 3; i < imax; i += 3) {
            clippings[i + 0] = 0;
            clippings[i + 1] = 0;
            clippings[i + 2] = 0;
        }
    };
    var buildNullIndex = function (indices, voffset, ioffset, icount) {
        for (var ii = ioffset * 3, iimax = (ioffset + icount) * 3; ii < iimax; ii += 3) {
            indices[ii + 0] = voffset;
            indices[ii + 1] = voffset;
            indices[ii + 2] = voffset;
        }
    };
    var buildNullVertex = function (vertices, voffset, vcount) {
        for (var i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            vertices[i + 0] = 0;
            vertices[i + 1] = 0;
        }
    };
    var buildNullStep = function (steps, voffset, vcount) {
        for (var i = voffset * 6, imax = (voffset + vcount) * 6; i < imax; i += 6) {
            steps[i + 0] = 0;
            steps[i + 1] = 0;
            steps[i + 2] = 0;
            steps[i + 3] = 0;
            steps[i + 4] = 0;
            steps[i + 5] = 0;
        }
    };
    var buildNullUv = function (uvs, voffset, vcount) {
        for (var i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            uvs[i + 0] = 0;
            uvs[i + 1] = 0;
        }
    };

    var toLineOfAnyPointCount = function (pointCount) {
        return Math.ceil(pointCount / 12) * 12;
    };
    var buildLineOfAnyColor = function (voffset, vcountPerPoint, point, pointCount, colors, isEnabled, colorDef, alphaDef) {
        if (isEnabled) {
            if (point.isStaticColor()) {
                var color = point.getColor(0, colorDef);
                if (point.isStaticAlpha()) {
                    var alpha = point.getAlpha(0, alphaDef);
                    buildColor(color, alpha, voffset, vcountPerPoint * pointCount, colors);
                }
                else {
                    for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                        var alpha = point.getAlpha(i, alphaDef);
                        buildColor(color, alpha, iv, vcountPerPoint, colors);
                    }
                }
            }
            else {
                if (point.isStaticAlpha()) {
                    var alpha = point.getAlpha(0, alphaDef);
                    for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                        var color = point.getColor(i, colorDef);
                        buildColor(color, alpha, iv, vcountPerPoint, colors);
                    }
                }
                else {
                    for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                        var color = point.getColor(i, colorDef);
                        var alpha = point.getAlpha(i, alphaDef);
                        buildColor(color, alpha, iv, vcountPerPoint, colors);
                    }
                }
            }
        }
        else {
            if (point.isStaticColor()) {
                var color = point.getColor(0, colorDef);
                buildColor(color, 0, voffset, vcountPerPoint * pointCount, colors);
            }
            else {
                for (var i = 0, iv = voffset; i < pointCount; i += 1, iv += vcountPerPoint) {
                    var color = point.getColor(i, colorDef);
                    buildColor(color, 0, iv, vcountPerPoint, colors);
                }
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfAny = /** @class */ (function (_super) {
        __extends(BuilderLineOfAny, _super);
        function BuilderLineOfAny(vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved) {
            var _this = _super.call(this, vertexOffset, indexOffset, vertexCount, indexCount) || this;
            _this.pointId = -1;
            _this.pointCount = 0;
            _this.pointCountReserved = pointCountReserved;
            _this.pointSizeId = -1;
            _this.pointOffsetId = -1;
            _this.pointFillId = -1;
            _this.pointStrokeId = -1;
            return _this;
        }
        BuilderLineOfAny.prototype.isCompatible = function (shape) {
            var pointCount = toLineOfAnyPointCount(toPointsCount(shape.points));
            return pointCount === this.pointCountReserved;
        };
        BuilderLineOfAny.prototype.updateLineOfAnyColorFill = function (buffer, shape, points, vcountPerPoint) {
            var pointFill = points.fill;
            var pointFillId = pointFill.id;
            var isPointFillChanged = pointFillId !== this.pointFillId;
            var fill = shape.fill;
            var isFillEnabled = shape.visible && fill.enable;
            var colorFill = fill.color;
            var alphaFill = isFillEnabled ? fill.alpha : 0;
            var isFillChanged = colorFill !== this.colorFill || alphaFill !== this.alphaFill;
            if (isPointFillChanged || isFillChanged) {
                this.colorFill = colorFill;
                this.alphaFill = alphaFill;
                this.pointFillId = pointFillId;
                buffer.updateColorFills();
                buildLineOfAnyColor(this.vertexOffset, vcountPerPoint, pointFill, this.pointCountReserved, buffer.colorFills, isFillEnabled, colorFill, alphaFill);
            }
        };
        BuilderLineOfAny.prototype.updateLineOfAnyColorStroke = function (buffer, shape, points, vcountPerPoint) {
            var pointStroke = points.stroke;
            var pointStrokeId = pointStroke.id;
            var isPointStrokeChanged = pointStrokeId !== this.pointStrokeId;
            var stroke = shape.stroke;
            var isStrokeEnabled = shape.visible && stroke.enable;
            var colorStroke = stroke.color;
            var alphaStroke = isStrokeEnabled ? stroke.alpha : 0;
            var isStrokeChanged = colorStroke !== this.colorStroke || alphaStroke !== this.alphaStroke;
            if (isPointStrokeChanged || isStrokeChanged) {
                this.colorStroke = colorStroke;
                this.alphaStroke = alphaStroke;
                this.pointStrokeId = pointStrokeId;
                buffer.updateColorStrokes();
                buildLineOfAnyColor(this.vertexOffset, vcountPerPoint, pointStroke, this.pointCountReserved, buffer.colorStrokes, isStrokeEnabled, colorStroke, alphaStroke);
            }
        };
        return BuilderLineOfAny;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyClipping = function (clippings, voffset, vcountPerPoint, pointCount) {
        var iv = voffset + vcountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var icd = iv * 3;
            var ics = voffset * 3;
            for (var j = 0; j < vcountPerPoint; ++j) {
                clippings[icd + 0] = clippings[ics + 0];
                clippings[icd + 1] = clippings[ics + 1];
                clippings[icd + 2] = clippings[ics + 2];
                icd += 3;
                ics += 3;
            }
            iv += vcountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyIndex = function (indices, vcountPerPoint, ioffset, icountPerPoint, pointCount) {
        var idiv = vcountPerPoint;
        var ii = ioffset + icountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var iid = ii * 3;
            var iis = ioffset * 3;
            for (var j = 0; j < icountPerPoint; ++j) {
                indices[iid + 0] = indices[iis + 0] + idiv;
                indices[iid + 1] = indices[iis + 1] + idiv;
                indices[iid + 2] = indices[iis + 2] + idiv;
                iid += 3;
                iis += 3;
            }
            idiv += vcountPerPoint;
            ii += icountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyStep = function (steps, voffset, vcountPerPoint, pointCount) {
        var iss0 = voffset * 6;
        var isd = (voffset + vcountPerPoint) * 6;
        for (var i = 1; i < pointCount; ++i) {
            var iss = iss0;
            for (var j = 0; j < vcountPerPoint; ++j) {
                steps[isd + 0] = steps[iss + 0];
                steps[isd + 1] = steps[iss + 1];
                steps[isd + 2] = steps[iss + 2];
                steps[isd + 3] = steps[iss + 3];
                steps[isd + 4] = steps[iss + 4];
                steps[isd + 5] = steps[iss + 5];
                isd += 6;
                iss += 6;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyUvs = function (uvs, voffset, vcountPerPoint, pointCount) {
        var iv = voffset + vcountPerPoint;
        for (var i = 1; i < pointCount; ++i) {
            var iuvd = iv << 1;
            var iuvs = voffset << 1;
            for (var j = 0; j < vcountPerPoint; ++j) {
                uvs[iuvd] = uvs[iuvs];
                uvs[iuvd + 1] = uvs[iuvs + 1];
                iuvd += 2;
                iuvs += 2;
            }
            iv += vcountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var copyVertex = function (vertices, internalTransform, voffset, vcountPerPoint, pointCount, pointsValues, pointOffset) {
        var a = internalTransform.a;
        var b = internalTransform.b;
        var c = internalTransform.c;
        var d = internalTransform.d;
        var i = pointCount - 1;
        var iv = voffset + i * vcountPerPoint;
        if (pointOffset.isStaticX() && pointOffset.isStaticY()) {
            var ox = pointOffset.getX(0);
            var oy = pointOffset.getY(0);
            for (; 0 <= i; --i) {
                var ip = i << 1;
                var px = pointsValues[ip] + ox;
                var py = pointsValues[ip + 1] + oy;
                var dx = a * px + c * py;
                var dy = b * px + d * py;
                var ivd = iv << 1;
                var ivs = voffset << 1;
                for (var j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
        else {
            for (; 0 <= i; --i) {
                var ip = i << 1;
                var px = pointsValues[ip] + pointOffset.getX(i);
                var py = pointsValues[ip + 1] + pointOffset.getY(i);
                var dx = a * px + c * py;
                var dy = b * px + d * py;
                var ivd = iv << 1;
                var ivs = voffset << 1;
                for (var j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isStatic = function (value) {
        return isNumber(value) || value == null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toComputed = function (index, value, def) {
        if (isNumber(value)) {
            return value;
        }
        else if (isFunction(value)) {
            return value(index);
        }
        else if (value) {
            return value[index % value.length];
        }
        return def;
    };

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsFillImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsFillImpl(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this.set(color, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsFillImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                this.set(undefined, alpha);
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsFillImpl.prototype.set = function (color, alpha) {
            var isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsFillImpl.prototype.getColor = function (index, def) {
            return toComputed(index, this._color, def);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.getAlpha = function (index, def) {
            return toComputed(index, this._alpha, def);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.isStaticColor = function () {
            return isStatic(this._color);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.isStaticAlpha = function () {
            return isStatic(this._alpha);
        };
        EShapeLineOfAnyPointsFillImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsFillImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsPointImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsPointImpl(parent, defX, defY) {
            this._parent = parent;
            this._id = 0;
            this._x = null;
            this._y = null;
            this._defX = defX;
            this._defY = defY;
            this._limit = null;
            this._limitComputed = 0;
            this._limitId = -1;
            this._limitParentLength = 0;
        }
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (x) {
                this.set(x, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (y) {
                this.set(undefined, y);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsPointImpl.prototype, "limit", {
            get: function () {
                return this._limit;
            },
            set: function (limit) {
                this._limit = limit;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsPointImpl.prototype.set = function (x, y) {
            var isChanged = false;
            if (x !== undefined && this._x !== x) {
                isChanged = true;
                this._x = x;
            }
            if (y !== undefined && this._y !== y) {
                isChanged = true;
                this._y = y;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getX = function (index) {
            return toComputed(index, this._x, this._defX);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getY = function (index) {
            return toComputed(index, this._y, this._defY);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.getLimit = function () {
            var limit = this._limit;
            if (limit != null) {
                return limit;
            }
            this.updateLimitComputed();
            return this._limitComputed;
        };
        EShapeLineOfAnyPointsPointImpl.prototype.updateLimitComputed = function () {
            var limitId = this._id;
            var parent = this._parent;
            var limitParentLength = parent.length;
            if (this._limitId !== limitId || this._limitParentLength !== limitParentLength) {
                this._limitId = limitId;
                this._limitParentLength = limitParentLength;
                this._limitComputed = Math.max(this.calcLimit(this._x, limitParentLength, this._defX), this.calcLimit(this._y, limitParentLength, this._defY));
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.calcLimit = function (value, parentLenght, def) {
            if (isNumber(value)) {
                return Math.abs(value);
            }
            else if (isFunction(value)) {
                if (0 < parentLenght) {
                    var result = Math.abs(value(0));
                    for (var i = 1; i < parentLenght; ++i) {
                        result = Math.max(result, Math.abs(value(i)));
                    }
                    return result;
                }
                return 0;
            }
            else if (value != null) {
                var l = value.length;
                if (0 < l) {
                    var result = value[0];
                    for (var i = 1; i < l; ++i) {
                        result = Math.max(result, Math.abs(value[i]));
                    }
                    return result;
                }
                return 0;
            }
            else {
                return Math.abs(def);
            }
        };
        EShapeLineOfAnyPointsPointImpl.prototype.isStaticX = function () {
            return isStatic(this._x);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.isStaticY = function () {
            return isStatic(this._y);
        };
        EShapeLineOfAnyPointsPointImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsPointImpl;
    }());

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsStrokeImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsStrokeImpl(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                this.set(color, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsStrokeImpl.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                this.set(undefined, alpha);
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsStrokeImpl.prototype.set = function (color, alpha) {
            var isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.getColor = function (index, def) {
            return toComputed(index, this._color, def);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.getAlpha = function (index, def) {
            return toComputed(index, this._alpha, def);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.isStaticColor = function () {
            return isStatic(this._color);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.isStaticAlpha = function () {
            return isStatic(this._alpha);
        };
        EShapeLineOfAnyPointsStrokeImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        return EShapeLineOfAnyPointsStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfAnyPointsImpl = /** @class */ (function () {
        function EShapeLineOfAnyPointsImpl(parent) {
            this._parent = parent;
            this._values = [];
            this._valuesLength = 0;
            this._segments = [];
            this._size = new EShapeLineOfAnyPointsPointImpl(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            this._offset = new EShapeLineOfAnyPointsPointImpl(this, 0, 0);
            this._fill = new EShapeLineOfAnyPointsFillImpl(parent);
            this._stroke = new EShapeLineOfAnyPointsStrokeImpl(parent);
            this._id = 0;
        }
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "length", {
            get: function () {
                return this._values.length >> 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "values", {
            get: function () {
                return this._values;
            },
            set: function (values) {
                this.set(values, undefined, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "segments", {
            get: function () {
                return this._segments;
            },
            set: function (segments) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "style", {
            get: function () {
                return EShapePointsStyle.NONE;
            },
            set: function (style) {
                this.set(undefined, undefined, style);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "marker", {
            get: function () {
                var result = this._marker;
                if (result == null) {
                    result = EShapePointsMarkerContainerImplNoop.getInstance();
                    this._marker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsImpl.prototype.getMarker = function () {
            return undefined;
        };
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "offset", {
            get: function () {
                return this._offset;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "fill", {
            get: function () {
                return this._fill;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "stroke", {
            get: function () {
                return this._stroke;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "formatter", {
            get: function () {
                return null;
            },
            set: function (formatter) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(EShapeLineOfAnyPointsImpl.prototype, "formatted", {
            get: function () {
                return this;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfAnyPointsImpl.prototype.onSizeChange = function () {
            // DO NOTHING
        };
        EShapeLineOfAnyPointsImpl.prototype.copy = function (source) {
            return this.set(source.values, source.segments, source.style);
        };
        EShapeLineOfAnyPointsImpl.prototype.set = function (newValues, newSegments, newStyle) {
            var isDirty = false;
            var isUpdated = false;
            // Values
            if (newValues != null) {
                var values = this._values;
                var valuesLength = this._valuesLength;
                var newValuesLength = newValues.length;
                if (values !== newValues) {
                    var iupdate = Math.min(valuesLength, newValuesLength);
                    for (var i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (var i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
                else {
                    if (valuesLength !== newValuesLength) {
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
            }
            //
            if (isDirty) {
                this._id += 1;
                var parent_1 = this._parent;
                var uploaded = parent_1.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent_1)) {
                        parent_1.updateUploaded();
                    }
                    else {
                        parent_1.uploaded = undefined;
                        parent_1.toDirty();
                    }
                }
                else {
                    parent_1.updateUploaded();
                }
            }
            else if (isUpdated) {
                this._id += 1;
                this._parent.updateUploaded();
            }
            return this;
        };
        EShapeLineOfAnyPointsImpl.prototype.updateUploaded = function () {
            this._parent.updateUploaded();
        };
        EShapeLineOfAnyPointsImpl.prototype.clone = function (parent) {
            return new EShapeLineOfAnyPointsImpl(parent).copy(this);
        };
        EShapeLineOfAnyPointsImpl.prototype.toPoints = function (transform) {
            var result = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                var point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        };
        EShapeLineOfAnyPointsImpl.prototype.serialize = function (manager) {
            return manager.addResource("[]");
        };
        EShapeLineOfAnyPointsImpl.prototype.calcHitPointAbs = function (x, y, sw, ss, sa, threshold, toRange, tester, result) {
            var formatted = this.formatted;
            var pointCount = formatted.length;
            var pointValues = formatted.values;
            var size = this._size;
            var offset = this._offset;
            var istart = 0;
            var iend = pointCount;
            if (toRange) {
                var s = size.getLimit() * 0.5;
                var o = offset.getLimit();
                var work = EShapeLineOfAnyPointsImpl.WORK_RANGE;
                toRange(x, y, s, s, o, o, threshold, pointValues, work);
                istart = work[0];
                iend = work[1];
            }
            for (var i = istart, imax = Math.min(iend, pointCount); i < imax; ++i) {
                var iv = i << 1;
                var px = pointValues[iv];
                var py = pointValues[iv + 1];
                var sx = size.getX(i) * 0.5;
                var sy = size.getY(i) * 0.5;
                var ox = offset.getX(i);
                var oy = offset.getY(i);
                if (tester(x, y, sx, sy, ox, oy, px, py, sw, ss, sa, i, threshold, result)) {
                    return true;
                }
            }
            return false;
        };
        EShapeLineOfAnyPointsImpl.WORK_RANGE = [0, 0];
        return EShapeLineOfAnyPointsImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfCircles = /** @class */ (function (_super) {
        __extends(BuilderLineOfCircles, _super);
        function BuilderLineOfCircles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderLineOfCircles.prototype.init = function (buffer) {
            buffer.updateClippings();
            buffer.updateIndices();
            var clippings = buffer.clippings;
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildCircleClipping(clippings, voffset);
                copyClipping(clippings, voffset, CIRCLE_VERTEX_COUNT, pointCountReserved);
                buildCircleIndex(indices, voffset, ioffset);
                copyIndex(indices, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, pointCountReserved);
            }
        };
        BuilderLineOfCircles.prototype.update = function (buffer, shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexAndStep(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, CIRCLE_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, CIRCLE_VERTEX_COUNT);
                this.updateUv(buffer, shape);
            }
        };
        BuilderLineOfCircles.prototype.updateVertexAndStep = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            if (isPointChanged ||
                isPointSizeChanged ||
                isSizeChanged ||
                isTransformChanged ||
                isStrokeChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var clippings = buffer.clippings;
                var internalTransform = shape.transform.internalTransform;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    buildCircleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, CIRCLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    buildCircleStep(steps, clippings, voffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
                    copyStep(steps, voffset, CIRCLE_VERTEX_COUNT, pointCount);
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * CIRCLE_VERTEX_COUNT;
                        buildCircleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                        buildCircleStep(steps, clippings, iv, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * CIRCLE_VERTEX_COUNT;
                var vcountReserved = CIRCLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
            }
        };
        BuilderLineOfCircles.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var uvs = buffer.uvs;
                var voffset = this.vertexOffset;
                var textureUvs = toTextureUvs(texture);
                var pointCountReserved = this.pointCountReserved;
                if (0 < pointCountReserved) {
                    buildCircleUv(uvs, voffset, textureUvs);
                    copyUvs(uvs, voffset, CIRCLE_VERTEX_COUNT, pointCountReserved);
                }
            }
        };
        return BuilderLineOfCircles;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfAnyUploaded = function (buffer, shape, voffset, vcountPerPoint, ioffset, icountPerPoint, antialiasWeight, constructor) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var points = shape.points;
        var pointCount = toLineOfAnyPointCount(toPointsCount(points));
        var pvcount = pointCount * vcountPerPoint;
        var picount = pointCount * icountPerPoint;
        var vcount = pvcount + tvcount;
        var icount = picount + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new constructor(voffset, ioffset, pvcount, picount, pointCount),
                new BuilderText(voffset + pvcount, ioffset + picount, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfCirclesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, antialiasWeight, BuilderLineOfCircles);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfCircles = /** @class */ (function (_super) {
        __extends(EShapeLineOfCircles, _super);
        function EShapeLineOfCircles(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_CIRCLES; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfCircles.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfCircles.prototype.clone = function () {
            return new EShapeLineOfCircles(this.type).copy(this);
        };
        EShapeLineOfCircles.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfCircles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfCircles.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfCircles;
    }(EShapeCircle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfCircles = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfCircles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfCircles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_CIRCLES] = createLineOfCirclesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_CIRCLES] = deserializeLineOfCircles;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(BuilderLineOfRectangleRoundeds, _super);
        function BuilderLineOfRectangleRoundeds(vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved) {
            var _this = _super.call(this, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved) || this;
            _this.radius = NaN;
            _this.corner = NaN;
            return _this;
        }
        BuilderLineOfRectangleRoundeds.prototype.init = function (buffer) {
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleRoundedIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
        };
        BuilderLineOfRectangleRoundeds.prototype.update = function (buffer, shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexClippingStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, RECTANGLE_ROUNDED_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, RECTANGLE_ROUNDED_VERTEX_COUNT);
            }
        };
        BuilderLineOfRectangleRoundeds.prototype.updateVertexClippingStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var radius = shape.radius;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = corner !== this.corner;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged || isCornerChanged) {
                    buffer.updateClippings();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var clippings = buffer.clippings;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isVertexChanged || isTransformChanged) {
                        buildRectangleRoundedStep(steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // Clippings
                    if (isVertexChanged || isCornerChanged) {
                        buildRectangleRoundedClipping(clippings, voffset, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyClipping(clippings, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isVertexChanged || isTextureChanged) {
                        buildRectangleRoundedUv(uvs, voffset, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * RECTANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildRectangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                        // Steps
                        if (isVertexChanged || isTransformChanged) {
                            buildRectangleRoundedStep(steps, iv, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // Clippings
                        if (isVertexChanged || isCornerChanged) {
                            buildRectangleRoundedClipping(clippings, iv, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isVertexChanged || isTextureChanged) {
                            buildRectangleRoundedUv(uvs, iv, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * RECTANGLE_ROUNDED_VERTEX_COUNT;
                var vcountReserved = RECTANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullClipping(clippings, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return BuilderLineOfRectangleRoundeds;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfRectangleRoundedsUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, BuilderLineOfRectangleRoundeds);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangleRoundeds, _super);
        function EShapeLineOfRectangleRoundeds(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_RECTANGLE_ROUNDEDS; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfRectangleRoundeds.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfRectangleRoundeds.prototype.clone = function () {
            return new EShapeLineOfRectangleRoundeds(this.type).copy(this);
        };
        EShapeLineOfRectangleRoundeds.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, threshold, sw, ss, sa, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfRectangleRoundeds.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfRectangleRoundeds.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfRectangleRoundeds;
    }(EShapeRectangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfRectangleRoundeds = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfRectangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfRectangleRoundeds = function () {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = createLineOfRectangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = deserializeLineOfRectangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfRectangles = /** @class */ (function (_super) {
        __extends(BuilderLineOfRectangles, _super);
        function BuilderLineOfRectangles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderLineOfRectangles.prototype.init = function (buffer) {
            buffer.updateIndices();
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, pointCountReserved);
            }
        };
        BuilderLineOfRectangles.prototype.update = function (buffer, shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexClippingStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, RECTANGLE_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, RECTANGLE_VERTEX_COUNT);
            }
        };
        BuilderLineOfRectangles.prototype.updateVertexClippingStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeSide = stroke.side;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged) {
                    buffer.updateClippings();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var clippings = buffer.clippings;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isVertexChanged || isTransformChanged) {
                        buildRectangleStep(voffset, steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                    // Clippings
                    if (isVertexChanged) {
                        buildRectangleClipping(clippings, voffset, RECTANGLE_WORLD_SIZE);
                        copyClipping(clippings, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isVertexChanged || isTextureChanged) {
                        buildRectangleUv(uvs, voffset, textureUvs, RECTANGLE_WORLD_SIZE);
                        copyUvs(uvs, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * RECTANGLE_VERTEX_COUNT;
                        // Vertices
                        buildRectangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                        // Steps
                        if (isVertexChanged || isTransformChanged) {
                            buildRectangleStep(iv, steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                        }
                        // Clippings
                        if (isVertexChanged) {
                            buildRectangleClipping(clippings, iv, RECTANGLE_WORLD_SIZE);
                        }
                        // UVs
                        if (isVertexChanged || isTextureChanged) {
                            buildRectangleUv(uvs, iv, textureUvs, RECTANGLE_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * RECTANGLE_VERTEX_COUNT;
                var vcountReserved = RECTANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullClipping(clippings, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return BuilderLineOfRectangles;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfRectanglesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, antialiasWeight, BuilderLineOfRectangles);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfRectangles = /** @class */ (function (_super) {
        __extends(EShapeLineOfRectangles, _super);
        function EShapeLineOfRectangles(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_RECTANGLES; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfRectangles.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfRectangles.prototype.clone = function () {
            return new EShapeLineOfRectangles(this.type).copy(this);
        };
        EShapeLineOfRectangles.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfRectangles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfRectangles.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfRectangles;
    }(EShapeRectangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfRectangles = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfRectangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfRectangles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLES] = createLineOfRectanglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLES] = deserializeLineOfRectangles;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLES, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    var TRIANGLE_ROUNDED_VERTEX_COUNT = 22;
    var TRIANGLE_ROUNDED_INDEX_COUNT = 15;
    var TRIANGLE_ROUNDED_WORLD_SIZE = [
        0, 0, 0, 0, 0
    ];
    var TRIANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    var buildTriangleRoundedIndex = function (indices, voffset, ioffset) {
        // Top corner
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
        // Bottom-right corner
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 7;
        // Bottom-left corner
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 11;
        // Others
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 15;
        indices[++ii] = voffset + 16;
        //
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 19;
        //
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 13;
    };
    var buildTriangleRoundedVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) {
        // Calculate the transformed positions
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        var sz = Math.sqrt(sx * sx + 4 * sy * sy);
        var sw = (2 * sx * sy) / (sx + sz);
        var ry = (sw * radius) / (2 * sy);
        var rz = (0.5 * (sz - sw) * radius) / sz;
        var rx = (ry * sz) / (2 * sx);
        var work = TRIANGLE_ROUNDED_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var tx = work.x;
        var ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        var dx = tx - x1;
        var dy = ty - y1;
        var x4 = work.x + dx;
        var y4 = work.y + dy;
        var x7 = tx + (tx - work.x) + dx;
        var y7 = ty + (ty - work.y) + dy;
        var dx14 = x4 - x1;
        var dy14 = y4 - y1;
        var x2 = x1 + rz * dx14;
        var y2 = y1 + rz * dy14;
        var x3 = x4 - ry * dx14;
        var y3 = y4 - ry * dy14;
        var dx47r = rx * (x7 - x4);
        var dy47r = rx * (y7 - y4);
        var x5 = x4 + dx47r;
        var y5 = y4 + dy47r;
        var x6 = x7 - dx47r;
        var y6 = y7 - dy47r;
        var dx71 = x1 - x7;
        var dy71 = y1 - y7;
        var x8 = x7 + ry * dx71;
        var y8 = y7 + ry * dy71;
        var x9 = x1 - rz * dx71;
        var y9 = y1 - rz * dy71;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        var x10 = x1 + radius * (x0 - x1);
        var y10 = y1 + radius * (y0 - y1);
        var x11 = x4 + radius * (x0 - x4);
        var y11 = y4 + radius * (y0 - y4);
        var x12 = x7 + radius * (x0 - x7);
        var y12 = y7 + radius * (y0 - y7);
        // World size
        var xb = tx + dx;
        var yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x0, y0);
        worldSize[1] = rx;
        worldSize[2] = ry;
        worldSize[3] = rz;
        worldSize[4] = 1 - (0.5 * sw) / sy;
        // Vertices
        // Top corner
        var iv = voffset * 2 - 1;
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        // Bottom-right corner
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        // Bottom-left corner
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        // Others
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
    };
    var buildTriangleRoundedClipping = function (clippings, voffset, corner, radius) {
        // Top corner
        var iv = voffset * 3 - 1;
        var w = 1 - radius;
        if (corner & EShapeCorner.TOP) {
            clippings[++iv] = 0;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
        }
        else {
            clippings[++iv] = w;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = w;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            clippings[++iv] = 0;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
        }
        else {
            clippings[++iv] = w;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = w;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            clippings[++iv] = 0;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
        }
        else {
            clippings[++iv] = w;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = w;
            clippings[++iv] = 0;
            clippings[++iv] = 1;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
            clippings[++iv] = w;
            clippings[++iv] = 1;
            clippings[++iv] = 0;
        }
        // Others
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = w;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = w;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = w;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
        clippings[++iv] = 1;
        clippings[++iv] = 0;
        clippings[++iv] = 0;
    };
    var buildTriangleRoundedStep = function (steps, clippings, voffset, strokeWidth, strokeStyle, radius, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var s = worldSize[0];
        var sr = radius * s;
        var ic = voffset * 3;
        var is = voffset * 6 - 1;
        for (var i = 0; i < TRIANGLE_ROUNDED_VERTEX_COUNT; i += 1, ic += 3) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            if (0.5 < clippings[ic + 2]) {
                steps[++is] = sr;
                steps[++is] = sr;
                steps[++is] = 1 + clippings[ic];
                steps[++is] = 1 + clippings[ic + 1];
            }
            else {
                steps[++is] = s;
                steps[++is] = s;
                steps[++is] = 1 + clippings[ic];
                steps[++is] = 1 + clippings[ic + 1];
            }
        }
    };
    var buildTriangleRoundedUv = function (uvs, voffset, textureUvs, radius, worldSize) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        var x4 = 0.5 * (x0 + x1);
        var y4 = 0.5 * (y0 + y1);
        var c = worldSize[4];
        var x5 = x4 + c * (x3 - x0);
        var y5 = y4 + c * (y3 - y0);
        var rx = worldSize[1];
        var ry = worldSize[2];
        var rz = worldSize[3];
        var x6 = x4 + rz * (x3 - x4);
        var y6 = y4 + rz * (y3 - y4);
        var x7 = x4 + radius * (x5 - x4);
        var y7 = y4 + radius * (y5 - y4);
        var x8 = x4 + rz * (x2 - x4);
        var y8 = y4 + rz * (y2 - y4);
        var x9 = x2 + ry * (x4 - x2);
        var y9 = y2 + ry * (y4 - y2);
        var x10 = x2 + radius * (x5 - x2);
        var y10 = y2 + radius * (y5 - y2);
        var x11 = x2 + rx * (x3 - x2);
        var y11 = y2 + rx * (y3 - y2);
        var x12 = x3 + rx * (x2 - x3);
        var y12 = y3 + rx * (y2 - y3);
        var x13 = x3 + radius * (x5 - x3);
        var y13 = y3 + radius * (y5 - y3);
        var x14 = x3 + ry * (x4 - x3);
        var y14 = y3 + ry * (y4 - y3);
        // Uvs
        // Top corner
        var iuv = voffset * 2 - 1;
        uvs[++iuv] = x7;
        uvs[++iuv] = y7;
        uvs[++iuv] = x6;
        uvs[++iuv] = y6;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x8;
        uvs[++iuv] = y8;
        // Bottom-right corner
        uvs[++iuv] = x10;
        uvs[++iuv] = y10;
        uvs[++iuv] = x9;
        uvs[++iuv] = y9;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x11;
        uvs[++iuv] = y11;
        // Bottom-left corner
        uvs[++iuv] = x13;
        uvs[++iuv] = y13;
        uvs[++iuv] = x12;
        uvs[++iuv] = y12;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x14;
        uvs[++iuv] = y14;
        // Others
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x7;
        uvs[++iuv] = y7;
        uvs[++iuv] = x8;
        uvs[++iuv] = y8;
        uvs[++iuv] = x9;
        uvs[++iuv] = y9;
        uvs[++iuv] = x10;
        uvs[++iuv] = y10;
        uvs[++iuv] = x11;
        uvs[++iuv] = y11;
        uvs[++iuv] = x12;
        uvs[++iuv] = y12;
        uvs[++iuv] = x13;
        uvs[++iuv] = y13;
        uvs[++iuv] = x14;
        uvs[++iuv] = y14;
        uvs[++iuv] = x6;
        uvs[++iuv] = y6;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(BuilderLineOfTriangleRoundeds, _super);
        function BuilderLineOfTriangleRoundeds(vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved) {
            var _this = _super.call(this, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved) || this;
            _this.radius = NaN;
            _this.corner = NaN;
            return _this;
        }
        BuilderLineOfTriangleRoundeds.prototype.init = function (buffer) {
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleRoundedIndex(buffer.indices, voffset, ioffset);
                copyIndex(buffer.indices, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
        };
        BuilderLineOfTriangleRoundeds.prototype.update = function (buffer, shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexClippingStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, TRIANGLE_ROUNDED_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, TRIANGLE_ROUNDED_VERTEX_COUNT);
            }
        };
        BuilderLineOfTriangleRoundeds.prototype.updateVertexClippingStepAndUv = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var radius = shape.radius;
            var isRadiusChanged = radius !== this.radius;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = this.corner !== corner;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged ||
                isPointSizeChanged ||
                isSizeChanged ||
                isRadiusChanged ||
                isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isCornerChanged) {
                    buffer.updateClippings();
                }
                if (isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var clippings = buffer.clippings;
                var steps = buffer.steps;
                var uvs = buffer.uvs;
                var internalTransform = shape.transform.internalTransform;
                var textureUvs = toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildTriangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Clippings
                    if (isVertexChanged || isCornerChanged) {
                        buildTriangleRoundedClipping(clippings, voffset, corner, radius);
                        copyClipping(clippings, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // Steps
                    if (isVertexChanged || isTransformChanged || isCornerChanged) {
                        buildTriangleRoundedStep(steps, clippings, voffset, strokeWidth, strokeStyle, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isVertexChanged || isTextureChanged) {
                        buildTriangleRoundedUv(uvs, voffset, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * TRIANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildTriangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                        // Clippings
                        if (isVertexChanged || isCornerChanged) {
                            buildTriangleRoundedClipping(clippings, iv, corner, radius);
                        }
                        // Steps
                        if (isVertexChanged || isTransformChanged || isCornerChanged) {
                            buildTriangleRoundedStep(steps, clippings, iv, strokeWidth, strokeStyle, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isVertexChanged || isTextureChanged) {
                            buildTriangleRoundedUv(uvs, iv, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * TRIANGLE_ROUNDED_VERTEX_COUNT;
                var vcountReserved = TRIANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullClipping(clippings, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return BuilderLineOfTriangleRoundeds;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfTriangleRoundedsUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, BuilderLineOfTriangleRoundeds);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var containsCorner_ = function (shape, x, y, r, aw, sw, ss) {
        var fill = shape.fill;
        if (fill.enable) {
            if (x * x + y * y <= r * r) {
                return true;
            }
        }
        else {
            if (0 < sw) {
                var d = x * x + y * y;
                if (d <= r * r) {
                    var w = Math.max(0.0, r * (1 - (sw * ss) / aw));
                    if (w * w <= d) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    var containsCorner = function (shape, x, y, x0, y0, x1, y1, x2, y2, x3, y3, r12, r13, aw, radius, sw, ss) {
        var xl = x1 + r12 * (x2 - x1) - x0;
        var yl = y1 + r12 * (y2 - y1) - y0;
        var n = Math.sqrt(xl * xl + yl * yl);
        var threshold = 0.00001;
        if (threshold < n) {
            var ni = 1 / n;
            var nlx = xl * ni;
            var nly = yl * ni;
            var xr = x1 + r13 * (x3 - x1) - x0;
            var yr = y1 + r13 * (y3 - y1) - y0;
            var nrx = xr * ni;
            var nry = yr * ni;
            var det = nlx * nry - nrx * nly;
            if (threshold < Math.abs(det)) {
                var deti = 1 / det;
                var xc = x - x0;
                var yc = y - y0;
                var dx = (+nry * xc - nrx * yc) * deti;
                var dy = (-nly * xc + nlx * yc) * deti;
                if (containsCorner_(shape, dx, dy, n, aw * radius, sw, ss)) {
                    return true;
                }
            }
        }
        return false;
    };
    var hitTestTriangleRounded = function (shape, x, y, ax, ay, sw, ss) {
        var a = (2 * ay) / ax;
        if (hitTestTriangleFilled(x, y, a, -ay, +ay)) {
            var az = Math.sqrt(ax * ax + 4 * ay * ay);
            var aw = (2 * ax * ay) / (ax + az);
            var radius = shape.radius;
            var x0 = 0;
            var y0 = ay - aw;
            var x1 = 0;
            var y1 = -ay;
            var x4 = +ax;
            var y4 = +ay;
            var x7 = -x4;
            var y7 = +y4;
            var x10 = x1 + radius * (x0 - x1);
            var y10 = y1 + radius * (y0 - y1);
            var x11 = x4 + radius * (x0 - x4);
            var y11 = y4 + radius * (y0 - y4);
            var y12 = +y11;
            var x12 = -x11;
            var c0 = -a * x + y10 - y <= 0;
            var c1 = +a * x + y10 - y <= 0;
            var c2 = y <= y11;
            var corner = shape.corner;
            if (!c0 && !c1 && corner & EShapeCorner.TOP) {
                // Top corner
                var rz = (0.5 * (az - aw) * radius) / az;
                if (containsCorner(shape, x, y, x10, y10, x1, y1, x7, y7, x4, y4, rz, rz, aw, radius, sw, ss)) {
                    return true;
                }
            }
            else if (!c0 && !c2 && corner & EShapeCorner.BOTTOM_LEFT) {
                // Bottom-left corner
                var ry = (aw * radius) / (2 * ay);
                var rx = (ry * az) / (2 * ax);
                if (containsCorner(shape, x, y, x12, y12, x7, y7, x4, y4, x1, y1, rx, ry, aw, radius, sw, ss)) {
                    return true;
                }
            }
            else if (!c1 && !c2 && corner & EShapeCorner.BOTTOM_RIGHT) {
                // Bottom-right corner
                var ry = (aw * radius) / (2 * ay);
                var rx = (ry * az) / (2 * ax);
                if (containsCorner(shape, x, y, x11, y11, x4, y4, x1, y1, x7, y7, ry, rx, aw, radius, sw, ss)) {
                    return true;
                }
            }
            else {
                // Others
                var fill = shape.fill;
                if (fill.enable) {
                    return true;
                }
                else {
                    if (0 < sw) {
                        var s = sw * ss;
                        var cy = ay - aw;
                        var ay1 = cy + ((-ay - cy) * Math.max(0.0, aw - s)) / aw;
                        var ay2 = ay - s;
                        if (!hitTestTriangleFilled(x, y, a, ay1, ay2)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangleRounded = /** @class */ (function (_super) {
        __extends(EShapeTriangleRounded, _super);
        function EShapeTriangleRounded(type) {
            if (type === void 0) { type = EShapeType.TRIANGLE_ROUNDED; }
            return _super.call(this, type) || this;
        }
        EShapeTriangleRounded.prototype.clone = function () {
            return new EShapeTriangleRounded(this.type).copy(this);
        };
        EShapeTriangleRounded.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestTriangleRounded(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeTriangleRounded;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangleRoundeds, _super);
        function EShapeLineOfTriangleRoundeds(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_TRIANGLE_ROUNDEDS; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfTriangleRoundeds.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfTriangleRoundeds.prototype.clone = function () {
            return new EShapeLineOfTriangleRoundeds(this.type).copy(this);
        };
        EShapeLineOfTriangleRoundeds.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfTriangleRoundeds.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfTriangleRoundeds.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfTriangleRoundeds;
    }(EShapeTriangleRounded));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfTriangleRoundeds = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfTriangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfTriangleRoundeds = function () {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = createLineOfTriangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = deserializeLineOfTriangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_TRIANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderLineOfTriangles = /** @class */ (function (_super) {
        __extends(BuilderLineOfTriangles, _super);
        function BuilderLineOfTriangles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderLineOfTriangles.prototype.init = function (buffer) {
            buffer.updateClippings();
            buffer.updateIndices();
            var clippings = buffer.clippings;
            var indices = buffer.indices;
            var voffset = this.vertexOffset;
            var ioffset = this.indexOffset;
            var pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleClipping(clippings, voffset);
                copyClipping(clippings, voffset, TRIANGLE_VERTEX_COUNT, pointCountReserved);
                buildTriangleIndex(indices, voffset, ioffset);
                copyIndex(indices, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, pointCountReserved);
            }
        };
        BuilderLineOfTriangles.prototype.update = function (buffer, shape) {
            var points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                this.updateVertexStepAndUvs(buffer, shape, points);
                this.updateLineOfAnyColorFill(buffer, shape, points, TRIANGLE_VERTEX_COUNT);
                this.updateLineOfAnyColorStroke(buffer, shape, points, TRIANGLE_VERTEX_COUNT);
            }
        };
        BuilderLineOfTriangles.prototype.updateVertexStepAndUvs = function (buffer, shape, points) {
            var pointId = points.id;
            var pointOffset = points.offset;
            var pointOffsetId = pointOffset.id;
            var isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            var pointSize = points.size;
            var pointSizeId = pointSize.id;
            var isPointSizeChanged = pointSizeId !== this.pointSizeId;
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.pointId = pointId;
                var formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                var pointCount = this.pointCount;
                var pointsValues = formatted.values;
                var voffset = this.vertexOffset;
                var vertices = buffer.vertices;
                var steps = buffer.steps;
                var clippings = buffer.clippings;
                var uvs = buffer.uvs;
                var textureUvs = toTextureUvs(texture);
                var internalTransform = shape.transform.internalTransform;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    var pointSizeX = pointSize.getX(0);
                    var pointSizeY = pointSize.getY(0);
                    buildTriangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    if (isVertexChanged || isTransformChanged) {
                        buildTriangleStep(steps, clippings, voffset, TRIANGLE_VERTEX_COUNT, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                    if (isVertexChanged || isTextureChanged) {
                        buildTriangleUv(uvs, textureUvs, voffset, TRIANGLE_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (var i = 0; i < pointCount; ++i) {
                        var ip = i << 1;
                        var px = pointsValues[ip] + pointOffset.getX(i);
                        var py = pointsValues[ip + 1] + pointOffset.getY(i);
                        var pointSizeX = pointSize.getX(i);
                        var pointSizeY = pointSize.getY(i);
                        var iv = voffset + i * TRIANGLE_VERTEX_COUNT;
                        buildTriangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                        if (isVertexChanged || isTransformChanged) {
                            buildTriangleStep(steps, clippings, iv, TRIANGLE_VERTEX_COUNT, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                        }
                        if (isVertexChanged || isTextureChanged) {
                            buildTriangleUv(uvs, textureUvs, iv, TRIANGLE_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                var pointCountReserved = this.pointCountReserved;
                var voffsetReserved = voffset + pointCount * TRIANGLE_VERTEX_COUNT;
                var vcountReserved = TRIANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        };
        return BuilderLineOfTriangles;
    }(BuilderLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createLineOfTrianglesUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, antialiasWeight, BuilderLineOfTriangles);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeTriangle = /** @class */ (function (_super) {
        __extends(EShapeTriangle, _super);
        function EShapeTriangle(type) {
            if (type === void 0) { type = EShapeType.TRIANGLE; }
            return _super.call(this, type) || this;
        }
        EShapeTriangle.prototype.clone = function () {
            return new EShapeTriangle(this.type).copy(this);
        };
        EShapeTriangle.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestTriangle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeTriangle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeLineOfTriangles = /** @class */ (function (_super) {
        __extends(EShapeLineOfTriangles, _super);
        function EShapeLineOfTriangles(type) {
            if (type === void 0) { type = EShapeType.LINE_OF_TRIANGLES; }
            var _this = _super.call(this, type) || this;
            _this._points = new EShapeLineOfAnyPointsImpl(_this);
            _this._tester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
                return _this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
            return _this;
        }
        Object.defineProperty(EShapeLineOfTriangles.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        EShapeLineOfTriangles.prototype.clone = function () {
            return new EShapeLineOfTriangles(this.type).copy(this);
        };
        EShapeLineOfTriangles.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            var threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        };
        EShapeLineOfTriangles.prototype.containsPointAbs = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return _super.prototype.containsAbs.call(this, x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        };
        EShapeLineOfTriangles.prototype.calcHitPoint = function (x, y, toThreshold, toRange, tester, result) {
            var data = this.toHitTestData(x, y);
            var threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        };
        return EShapeLineOfTriangles;
    }(EShapeTriangle));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeLineOfTriangles = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeLineOfTriangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeLineOfTriangles = function () {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLES] = createLineOfTrianglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLES] = deserializeLineOfTriangles;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createNullUploaded = function (buffer, shape, voffset, ioffset) {
        return new EShapeUploadedImpl(buffer, voffset, ioffset, 0, 0, [
            new BuilderNull(voffset, ioffset)
        ]).init(shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeNull = /** @class */ (function (_super) {
        __extends(EShapeNull, _super);
        function EShapeNull(type) {
            if (type === void 0) { type = EShapeType.NULL; }
            return _super.call(this, type) || this;
        }
        EShapeNull.prototype.clone = function () {
            return new EShapeNull(this.type).copy(this);
        };
        return EShapeNull;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeNull = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeNull());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeNull = function () {
        EShapeUploadeds[EShapeType.NULL] = createNullUploaded;
        EShapeDeserializers[EShapeType.NULL] = deserializeNull;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectangle = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeRectangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectangle = function () {
        EShapeUploadeds[EShapeType.RECTANGLE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE] = deserializeRectangle;
        EShapeCapabilities.set(EShapeType.RECTANGLE, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectanglePivoted = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeRectanglePivoted());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectanglePivoted = function () {
        EShapeUploadeds[EShapeType.RECTANGLE_PIVOTED] = createRectanglePivotedUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE_PIVOTED] = deserializeRectanglePivoted;
        EShapeCapabilities.set(EShapeType.RECTANGLE_PIVOTED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeRectangleRounded = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeRectangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeRectangleRounded = function () {
        EShapeUploadeds[EShapeType.RECTANGLE_ROUNDED] = createRectangleRoundedUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE_ROUNDED] = deserializeRectangleRounded;
        EShapeCapabilities.set(EShapeType.RECTANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    var SEMICIRCLE_VERTEX_COUNT = 6;
    var SEMICIRCLE_INDEX_COUNT = 4;
    var SEMICIRCLE_WORLD_SIZE = [0, 0];
    var SEMICIRCLE_WORK_POINT = new pixi_js.Point();
    var buildSemicircleClipping = function (clippings, voffset) {
        var ic = voffset * 3 - 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
        clippings[++ic] = 1;
        clippings[++ic] = 0;
        clippings[++ic] = 1;
    };
    var buildSemicircleIndex = function (indices, voffset, ioffset) {
        var ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
    };
    var buildSemicircleVertex = function (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) {
        // Calculate the transformed positions
        //
        //  0       1       2
        // |-------|-------|
        // |3      |4      |5
        // |-------|-------|
        //
        var work = SEMICIRCLE_WORK_POINT;
        var s = strokeAlign * strokeWidth;
        var sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        var sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        work.set(-sx + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x0 = work.x;
        var y0 = work.y;
        work.set(0 + originX, -sy + originY);
        internalTransform.apply(work, work);
        var x1 = work.x;
        var y1 = work.y;
        var dx = x1 - x0;
        var dy = y1 - y0;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        var x4 = work.x;
        var y4 = work.y;
        var x3 = x4 - dx;
        var y3 = y4 - dy;
        // Vertices
        var iv = voffset * 2 - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1 + dx;
        vertices[++iv] = y1 + dy;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x4 + dx;
        vertices[++iv] = y4 + dy;
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x3, y3);
    };
    var buildSemicircleStep = function (steps, clippings, voffset, strokeWidth, strokeStyle, worldSize) {
        var scaleInvariant = toScaleInvariant(strokeStyle);
        var is = voffset * 6 - 1;
        var ic = voffset * 3;
        for (var i = 0; i < SEMICIRCLE_VERTEX_COUNT; i += 1, ic += 3) {
            steps[++is] = strokeWidth;
            steps[++is] = scaleInvariant;
            steps[++is] = worldSize[0];
            steps[++is] = worldSize[1];
            steps[++is] = 1 + clippings[ic];
            steps[++is] = 1 + clippings[ic + 1];
        }
    };
    var buildSemicircleUv = function (uvs, voffset, textureUvs) {
        var x0 = textureUvs.x0;
        var x1 = textureUvs.x1;
        var x2 = textureUvs.x2;
        var x3 = textureUvs.x3;
        var y0 = textureUvs.y0;
        var y1 = textureUvs.y1;
        var y2 = textureUvs.y2;
        var y3 = textureUvs.y3;
        // UVs
        var iuv = voffset * 2 - 1;
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = 0.5 * (x0 + x1);
        uvs[++iuv] = 0.5 * (y0 + y1);
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = 0.5 * (x0 + x3);
        uvs[++iuv] = 0.5 * (y0 + y3);
        uvs[++iuv] = 0.5 * (x0 + x2);
        uvs[++iuv] = 0.5 * (y0 + y2);
        uvs[++iuv] = 0.5 * (x1 + x2);
        uvs[++iuv] = 0.5 * (y1 + y2);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderSemicircle = /** @class */ (function (_super) {
        __extends(BuilderSemicircle, _super);
        function BuilderSemicircle(vertexOffset, indexOffset) {
            return _super.call(this, vertexOffset, indexOffset, SEMICIRCLE_VERTEX_COUNT, SEMICIRCLE_INDEX_COUNT) || this;
        }
        BuilderSemicircle.prototype.init = function (buffer) {
            buffer.updateClippings();
            buffer.updateIndices();
            var voffset = this.vertexOffset;
            buildSemicircleClipping(buffer.clippings, voffset);
            buildSemicircleIndex(buffer.indices, voffset, this.indexOffset);
        };
        BuilderSemicircle.prototype.update = function (buffer, shape) {
            this.updateVertexAndStep(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
            this.updateUv(buffer, shape);
        };
        BuilderSemicircle.prototype.updateVertexAndStep = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            if (isSizeChanged || isTransformChanged || isStrokeChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                buildSemicircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, SEMICIRCLE_WORLD_SIZE);
                buildSemicircleStep(buffer.steps, buffer.clippings, this.vertexOffset, strokeWidth, strokeStyle, SEMICIRCLE_WORLD_SIZE);
            }
        };
        BuilderSemicircle.prototype.updateUv = function (buffer, shape) {
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            if (texture !== this.texture || textureTransformId !== this.textureTransformId) {
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                var textureUvs = toTextureUvs(texture);
                buildSemicircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        };
        return BuilderSemicircle;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createSemicircleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = SEMICIRCLE_VERTEX_COUNT + tvcount;
        var icount = SEMICIRCLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderSemicircle(voffset, ioffset),
                new BuilderText(voffset + SEMICIRCLE_VERTEX_COUNT, ioffset + SEMICIRCLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var hitTestSemicircle = function (shape, x, y, ax, ay, sw, ss) {
        if (y <= 0) {
            return hitTestCircle(shape, x, y, ax, ay, sw, ss);
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A semicircle shape.
     *
     * @beta
     */
    var EShapeSemicircle = /** @class */ (function (_super) {
        __extends(EShapeSemicircle, _super);
        function EShapeSemicircle(type) {
            if (type === void 0) { type = EShapeType.SEMICIRCLE; }
            var _this = _super.call(this, type) || this;
            _this.stroke.side = EShapeStrokeSide.ALL & ~EShapeStrokeSide.BOTTOM;
            return _this;
        }
        EShapeSemicircle.prototype.clone = function () {
            return new EShapeSemicircle(this.type).copy(this);
        };
        EShapeSemicircle.prototype.containsAbs = function (x, y, ax, ay, sw, ss, sa) {
            if (_super.prototype.containsAbsBBox.call(this, x, y, ax, ay)) {
                return hitTestSemicircle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        };
        return EShapeSemicircle;
    }(EShapePrimitive));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeSemicircle = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeSemicircle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeSemicircle = function () {
        EShapeUploadeds[EShapeType.SEMICIRCLE] = createSemicircleUploaded;
        EShapeDeserializers[EShapeType.SEMICIRCLE] = deserializeSemicircle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderTriangle = /** @class */ (function (_super) {
        __extends(BuilderTriangle, _super);
        function BuilderTriangle() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BuilderTriangle.prototype.init = function (buffer) {
            buffer.updateClippings();
            buffer.updateIndices();
            buildTriangleClipping(buffer.clippings, this.vertexOffset);
            buildTriangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
        };
        BuilderTriangle.prototype.update = function (buffer, shape) {
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
        };
        BuilderTriangle.prototype.updateVertexStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, TRIANGLE_WORLD_SIZE);
                if (isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildTriangleStep(buffer.steps, buffer.clippings, voffset, TRIANGLE_VERTEX_COUNT, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleUv(buffer.uvs, toTextureUvs(texture), voffset, TRIANGLE_WORLD_SIZE);
                }
            }
        };
        return BuilderTriangle;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createTriangleUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = TRIANGLE_VERTEX_COUNT + tvcount;
        var icount = TRIANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderTriangle(voffset, ioffset, vcount - tvcount, icount - ticount),
                new BuilderText(voffset + TRIANGLE_VERTEX_COUNT, ioffset + TRIANGLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeTriangle = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeTriangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeTriangle = function () {
        EShapeUploadeds[EShapeType.TRIANGLE] = createTriangleUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE] = deserializeTriangle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var BuilderTriangleRounded = /** @class */ (function (_super) {
        __extends(BuilderTriangleRounded, _super);
        function BuilderTriangleRounded(vertexOffset, indexOffset, vertexCount, indexCount) {
            var _this = _super.call(this, vertexOffset, indexOffset, vertexCount, indexCount) || this;
            _this.radius = NaN;
            _this.corner = NaN;
            return _this;
        }
        BuilderTriangleRounded.prototype.init = function (buffer) {
            buffer.updateIndices();
            buildTriangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
        };
        BuilderTriangleRounded.prototype.update = function (buffer, shape) {
            this.updateVertexClippingStepAndUv(buffer, shape);
            this.updateColorFill(buffer, shape);
            this.updateColorStroke(buffer, shape);
        };
        BuilderTriangleRounded.prototype.updateVertexClippingStepAndUv = function (buffer, shape) {
            var size = shape.size;
            var sizeX = size.x;
            var sizeY = size.y;
            var isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            var radius = shape.radius;
            var isRadiusChanged = radius !== this.radius;
            var transformLocalId = toTransformLocalId(shape);
            var isTransformChanged = this.transformLocalId !== transformLocalId;
            var stroke = shape.stroke;
            var strokeAlign = stroke.align;
            var strokeWidth = stroke.enable ? stroke.width : 0;
            var strokeStyle = stroke.style;
            var isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            var corner = shape.corner;
            var isCornerChanged = corner !== this.corner;
            var texture = toTexture(shape);
            var textureTransformId = toTextureTransformId(texture);
            var isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            var isVertexChanged = isSizeChanged || isRadiusChanged || isStrokeChanged;
            if (isVertexChanged || isTransformChanged || isCornerChanged || isTextureChanged) {
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                var voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                if (isRadiusChanged || isCornerChanged) {
                    buffer.updateClippings();
                    buildTriangleRoundedClipping(buffer.clippings, voffset, corner, radius);
                }
                if (isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                    buildTriangleRoundedStep(buffer.steps, buffer.clippings, voffset, strokeWidth, strokeStyle, shape.radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
                if (isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleRoundedUv(buffer.uvs, voffset, toTextureUvs(texture), radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        };
        return BuilderTriangleRounded;
    }(BuilderBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createTriangleRoundedUploaded = function (buffer, shape, voffset, ioffset, antialiasWeight) {
        var tcount = toTextBufferCount(shape);
        var tvcount = tcount * TEXT_VERTEX_COUNT;
        var ticount = tcount * TEXT_INDEX_COUNT;
        var vcount = TRIANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        var icount = TRIANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderTriangleRounded(voffset, ioffset, vcount - tvcount, icount - ticount),
                new BuilderText(voffset + TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset + TRIANGLE_ROUNDED_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var deserializeTriangleRounded = function (item, manager, shape) {
        return deserializeBase(item, manager, shape || new EShapeTriangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeTriangleRounded = function () {
        EShapeUploadeds[EShapeType.TRIANGLE_ROUNDED] = createTriangleRoundedUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE_ROUNDED] = deserializeTriangleRounded;
        EShapeCapabilities.set(EShapeType.TRIANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadShapeAll = function () {
        loadShapeBar();
        loadShapeButton();
        loadShapeCircle();
        loadShapeConnectorElbow();
        loadShapeConnectorLine();
        loadShapeEmbedded();
        loadShapeGroupShadowed();
        loadShapeGroup();
        loadShapeImage();
        loadShapeImageSdf();
        loadShapeLabel();
        loadShapeLine();
        loadShapeNull();
        loadShapeRectanglePivoted();
        loadShapeRectangleRounded();
        loadShapeRectangle();
        loadShapeSemicircle();
        loadShapeTriangleRounded();
        loadShapeTriangle();
        loadShapeLineOfCircles();
        loadShapeLineOfRectangleRoundeds();
        loadShapeLineOfRectangles();
        loadShapeLineOfTriangleRoundeds();
        loadShapeLineOfTriangles();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DImage = /** @class */ (function (_super) {
        __extends(DImage, _super);
        function DImage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DImage.prototype.getType = function () {
            return "DImage";
        };
        return DImage;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemBase = /** @class */ (function (_super) {
        __extends(DMenuItemBase, _super);
        function DMenuItemBase(options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            _this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : null;
            return _this;
        }
        DMenuItemBase.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
        };
        DMenuItemBase.prototype.onClick = function (e) {
            if (this.state.isActionable) {
                this.activate(e);
            }
        };
        DMenuItemBase.prototype.activate = function (e) {
            this.onSelect(e);
        };
        Object.defineProperty(DMenuItemBase.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        DMenuItemBase.prototype.hasSelection = function (target) {
            return target && target.selection && target.selection.add;
        };
        DMenuItemBase.prototype.getSelection = function () {
            var parent = this.parent;
            while (parent) {
                if (this.hasSelection(parent)) {
                    return parent.selection;
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItemBase.prototype.onSelect = function (e) {
            this.emit("select", this._value, this);
            var selection = this.getSelection();
            if (selection) {
                selection.add(this);
            }
        };
        DMenuItemBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuItemBase.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.activate(e);
                return true;
            }
            return false;
        };
        DMenuItemBase.prototype.getType = function () {
            return "DMenuItemBase";
        };
        return DMenuItemBase;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItem = /** @class */ (function (_super) {
        __extends(DMenuItem, _super);
        function DMenuItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItem.prototype.getContext = function () {
            var parent = this.parent;
            while (parent) {
                if (parent.getContext) {
                    return parent.getContext();
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItem.prototype.getCloseable = function () {
            var parent = this.parent;
            while (parent) {
                if (parent.getCloseable) {
                    return parent.getCloseable();
                }
                parent = parent.parent;
            }
            return null;
        };
        DMenuItem.prototype.getType = function () {
            return "DMenuItem";
        };
        return DMenuItem;
    }(DMenuItemBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemText = /** @class */ (function (_super) {
        __extends(DMenuItemText, _super);
        function DMenuItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemText.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.initOnOver(options);
            this.initShortcuts(options);
        };
        DMenuItemText.prototype.initOnOver = function (options) {
            var _this = this;
            this.on(UtilPointerEvent.over, function () {
                var context = _this.getContext();
                if (context != null) {
                    var parent_1 = _this.parent;
                    if (parent_1 instanceof DBase) {
                        context.trim(_this.getCloseable());
                    }
                }
            });
        };
        DMenuItemText.prototype.initShortcuts = function (options) {
            var shortcuts = this._shortcuts;
            if (shortcuts != null && 0 < shortcuts.length) {
                var shortcut = shortcuts[0];
                var shortcutTextValue = UtilKeyboardEvent.toString(shortcut);
                this._shortcutText = this.createText(shortcutTextValue);
                this.snippet.add(this._shortcutText, true);
            }
            else {
                this._shortcutText = null;
            }
            this._shortcutMargin = this.theme.getShortcutTextMargin();
        };
        DMenuItemText.prototype.updateShortcutText = function () {
            var text = this._shortcutText;
            var margin = this._shortcutMargin;
            if (text != null && margin != null) {
                var auto = this._auto;
                var textX = 0;
                if (auto.width.isOn) {
                    textX = margin;
                }
                else {
                    textX = this.width - text.width - margin;
                }
                var textY = 0;
                var padding = this._padding;
                var ptop = padding.getTop();
                if (auto.height.isOn) {
                    textY = ptop;
                }
                else {
                    textY = ptop + (this.height - ptop - padding.getBottom() - text.height) * 0.5;
                }
                text.position.set(textX, textY);
            }
        };
        DMenuItemText.prototype.updateTextColor = function (text) {
            _super.prototype.updateTextColor.call(this, text);
            var shortcutText = this._shortcutText;
            if (shortcutText != null) {
                var theme = this.theme;
                var state = this.state;
                shortcutText.style.fill = theme.getShortcutColor(state);
                shortcutText.alpha = theme.getShortcutAlpha(state);
            }
        };
        DMenuItemText.prototype.updateText = function () {
            _super.prototype.updateText.call(this);
            this.updateShortcutText();
        };
        DMenuItemText.prototype.getType = function () {
            return "DMenuItemText";
        };
        DMenuItemText.prototype.onSelect = function (e) {
            _super.prototype.onSelect.call(this, e);
            var closeable = this.getCloseable();
            if (closeable != null) {
                closeable.emit("select", this.value, this, closeable);
            }
        };
        DMenuItemText.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.activate(e);
        };
        return DMenuItemText;
    }(DMenuItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemCheck = /** @class */ (function (_super) {
        __extends(DMenuItemCheck, _super);
        function DMenuItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemCheck.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            if (options === null || options === void 0 ? void 0 : options.check) {
                this.state.isActive = true;
            }
        };
        DMenuItemCheck.prototype.getType = function () {
            return "DMenuItemCheck";
        };
        DMenuItemCheck.prototype.onSelect = function (e) {
            this.state.isActive = !this.state.isActive;
            _super.prototype.onSelect.call(this, e);
        };
        return DMenuItemCheck;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemCheckIsCompatible = function (options) {
        return "check" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkMenuItemId = {
        OPEN_LINK: 0,
        OPEN_LINK_IN_NEW_WINDOW: 1,
        COPY_LINK_ADDRESS: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenus = /** @class */ (function () {
        function DMenus() {
        }
        DMenus.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenus.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenus.setMenuCreator = function (creator) {
            this.MENU_CREATOR = creator;
        };
        DMenus.newItemOf = function (creators, creatorDefault, options, sticky) {
            for (var i = 0, imax = creators.length; i < imax; ++i) {
                var created = creators[i](options, sticky);
                if (created != null) {
                    return created;
                }
            }
            if (creatorDefault) {
                return creatorDefault(options, sticky);
            }
            return null;
        };
        DMenus.newItem = function (options, sticky) {
            return this.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky);
        };
        DMenus.newItemsOf = function (creator, parent, items, sticky) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (item instanceof pixi_js.DisplayObject) {
                    parent.addChild(item);
                }
                else if (item != null) {
                    var created = creator.newItem(item, sticky);
                    if (created != null) {
                        parent.addChild(created);
                    }
                    else {
                        throw new Error("No matching menu item creator found: ".concat(JSON.stringify(item)));
                    }
                }
            }
        };
        DMenus.newItems = function (parent, items, sticky) {
            this.newItemsOf(this, parent, items, sticky);
        };
        DMenus.newMenu = function (options) {
            if (this.MENU_CREATOR != null) {
                return this.MENU_CREATOR(options);
            }
            else {
                throw new Error("Missing DMenu creator.");
            }
        };
        DMenus.CREATORS = [];
        DMenus.CREATOR_DEFAULT = null;
        return DMenus;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkMenu = /** @class */ (function () {
        function DLinkMenu(parent, options) {
            this._parent = parent;
            this._options = options;
            this._isEnabled = true;
        }
        Object.defineProperty(DLinkMenu.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                this._isEnabled = enable;
            },
            enumerable: false,
            configurable: true
        });
        DLinkMenu.prototype.open = function (target) {
            this.get().open(target);
        };
        DLinkMenu.prototype.get = function () {
            var _this = this;
            var result = this._menu;
            if (result == null) {
                result = this.toMenu(this._options);
                this._menu = result;
                result.on("select", function (value, item, menu) {
                    _this.onSelect(value, item, menu);
                });
            }
            return result;
        };
        DLinkMenu.prototype.toMenu = function (options) {
            if (options instanceof pixi_js.DisplayObject) {
                return options;
            }
            return this.newMenu(options);
        };
        DLinkMenu.prototype.newMenu = function (options) {
            return DMenus.newMenu(options);
        };
        DLinkMenu.prototype.onSelect = function (value, item, menu) {
            var parent = this._parent;
            switch (value) {
                case DLinkMenuItemId.OPEN_LINK:
                    parent.open(false);
                    break;
                case DLinkMenuItemId.OPEN_LINK_IN_NEW_WINDOW:
                    parent.open(true);
                    break;
                case DLinkMenuItemId.COPY_LINK_ADDRESS:
                    parent.copy();
                    break;
            }
        };
        return DLinkMenu;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinkTarget = {
        AUTO: 0,
        THIS_WINDOW: 1,
        NEW_WINDOW: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var getSelection = function (element) {
        var selection = document.getSelection();
        if (selection) {
            var range = document.createRange();
            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        return selection;
    };
    var toClipboardData = function (e) {
        return e.clipboardData || window.clipboardData;
    };
    var copyUsingDiv = function (text) {
        var div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        div.textContent = "Dummy";
        document.body.appendChild(div);
        var selection = getSelection(div);
        var result = false;
        if (selection) {
            var handler = function (e) {
                if (e.target === div) {
                    var clipboardData = toClipboardData(e);
                    clipboardData.setData("text/plain", text);
                    result = clipboardData.getData("text/plain") === text;
                    e.preventDefault();
                }
            };
            document.addEventListener("copy", handler);
            try {
                document.execCommand("copy");
            }
            finally {
                document.removeEventListener("copy", handler);
            }
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    var copyUsingSpan = function (text) {
        var div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        var span = document.createElement("span");
        span.innerText = text;
        var root = div.attachShadow ? div.attachShadow({ mode: "open" }) : div;
        root.appendChild(span);
        document.body.appendChild(div);
        var result = false;
        var selection = getSelection(div);
        if (selection) {
            result = document.execCommand("copy");
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    var copyUsingWindow = function (window, text) {
        if (typeof ClipboardEvent === "undefined") {
            var clipboardData = window.clipboardData;
            if (typeof clipboardData !== "undefined" && typeof clipboardData.setData !== "undefined") {
                clipboardData.setData("Text", text);
                return true;
            }
        }
        return false;
    };
    var UtilClipboard = /** @class */ (function (_super) {
        __extends(UtilClipboard, _super);
        function UtilClipboard() {
            var _this = _super.call(this) || this;
            var element = document.body;
            element.addEventListener("copy", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("copy", toClipboardData(e));
                }
            });
            element.addEventListener("cut", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("cut", toClipboardData(e));
                }
            });
            element.addEventListener("paste", function (e) {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    _this.emit("paste", toClipboardData(e));
                }
            });
            return _this;
        }
        UtilClipboard.copy = function (text) {
            var clipboard = navigator.clipboard;
            if (clipboard && clipboard.writeText) {
                clipboard.writeText(text);
            }
            else {
                if (!copyUsingWindow(window, text)) {
                    if (!copyUsingDiv(text)) {
                        if (navigator.userAgent.indexOf("Edge") < 0) {
                            copyUsingSpan(text);
                        }
                    }
                }
            }
        };
        return UtilClipboard;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var InteractionEvent$1 = pixi_js.interaction.InteractionEvent;
    var DLink = /** @class */ (function () {
        function DLink(options) {
            this._options = options;
            this._url = options === null || options === void 0 ? void 0 : options.url;
            this._target = this.toNormalizedTarget(options === null || options === void 0 ? void 0 : options.target);
            this._checker = options === null || options === void 0 ? void 0 : options.checker;
            this._isEnabled = true;
        }
        Object.defineProperty(DLink.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                this._isEnabled = enable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "url", {
            get: function () {
                return this._url;
            },
            set: function (url) {
                this._url = url;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = this.toNormalizedTarget(target);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "checker", {
            get: function () {
                return this._checker;
            },
            set: function (checker) {
                this._checker = checker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DLink.prototype, "menu", {
            get: function () {
                var result = this._menu;
                if (result == null) {
                    result = this.newMenu();
                    this._menu = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DLink.prototype.newMenu = function () {
            var options = this._options;
            if (options) {
                var menu = options.menu;
                if (menu) {
                    return new DLinkMenu(this, menu);
                }
            }
            var result = DLink.MENU;
            if (result == null) {
                result = new DLinkMenu(this, DThemes.getInstance().get("DLink").getMenuOptions());
                DLink.MENU = result;
            }
            return result;
        };
        DLink.prototype.toStringifiedUrl = function (target, onResolved) {
            var url = isFunction(target) ? target() : target;
            if (url != null) {
                if (isString(url)) {
                    onResolved(url);
                }
                else {
                    url.then(function (resolved) {
                        if (resolved != null) {
                            onResolved(resolved);
                        }
                    });
                }
            }
        };
        DLink.prototype.toNormalizedUrl = function (url) {
            var a = DLink.ANCHOR_ELEMENT || document.createElement("a");
            DLink.ANCHOR_ELEMENT = a;
            a.href = url;
            return a.href;
        };
        DLink.prototype.toNormalizedTarget = function (target) {
            return toEnum(target !== null && target !== void 0 ? target : DLinkTarget.AUTO, DLinkTarget);
        };
        /**
         * Copys the URL to the clipboard.
         */
        DLink.prototype.copy = function () {
            var _this = this;
            this.toStringifiedUrl(this._url, function (url) {
                UtilClipboard.copy(_this.toNormalizedUrl(url));
            });
        };
        DLink.prototype.open = function (x) {
            var _this = this;
            this.toStringifiedUrl(this._url, function (url) {
                var inNewWindow = x === true || x === false ? x : _this.inNewWindow(x);
                _this.check(url, inNewWindow, function () {
                    _this.exec(url, inNewWindow);
                });
            });
        };
        DLink.prototype.check = function (url, inNewWindow, onResolved) {
            var checker = this._checker;
            if (checker) {
                var checked = checker();
                if (checked === true) {
                    onResolved();
                }
                else if (checked === false) ;
                else {
                    checked.then(function (resolved) {
                        if (resolved) {
                            onResolved();
                        }
                    });
                }
            }
            else {
                onResolved();
            }
        };
        /**
         * Opens the given URL.
         *
         * @param url An URL to be opened
         * @param inNewWindow True to open in a new window.
         */
        DLink.prototype.exec = function (url, inNewWindow) {
            if (inNewWindow) {
                var a_1 = document.createElement("a");
                a_1.href = url;
                a_1.target = "_blank";
                a_1.style.display = "none";
                a_1.rel = "noopener noreferrer";
                document.body.appendChild(a_1);
                a_1.click();
                setTimeout(function () {
                    document.body.removeChild(a_1);
                }, 100);
            }
            else {
                window.location.href = url;
            }
        };
        /**
         * Returns true if the URL need to be opened in a new window.
         *
         * @param e An event object.
         */
        DLink.prototype.inNewWindow = function (e) {
            switch (this._target) {
                case DLinkTarget.NEW_WINDOW:
                    return true;
                case DLinkTarget.THIS_WINDOW:
                    return false;
                case DLinkTarget.AUTO:
                    if (e != null) {
                        var oe = e instanceof InteractionEvent$1 ? e.data.originalEvent : e;
                        return (oe.ctrlKey ||
                            oe.shiftKey ||
                            oe.altKey ||
                            oe.metaKey ||
                            ("button" in oe && oe.button !== 0));
                    }
                    return false;
            }
        };
        DLink.prototype.onClick = function (base, e) {
            if (this._target === DLinkTarget.AUTO) {
                var oe = e.data.originalEvent;
                if (("pointerType" in oe && oe.pointerType !== "mouse") || "touches" in oe) {
                    var menu = this.menu;
                    if (menu.enable) {
                        if (this._isEnabled && base.state.isActionable) {
                            menu.open(base);
                        }
                        return true;
                    }
                }
            }
            if (this._isEnabled) {
                return false;
            }
            return true;
        };
        return DLink;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DLinks = /** @class */ (function () {
        function DLinks() {
        }
        DLinks.toStateOptions = function (target, options) {
            if (options) {
                if (target === DLinkTarget.NEW_WINDOW || target === "NEW_WINDOW") {
                    var state = options.state;
                    if (state == null) {
                        options.state = DBaseState.NEW_WINDOW;
                    }
                    else if (isString(state)) {
                        if (state !== DBaseState.NEW_WINDOW) {
                            options.state = [state, DBaseState.NEW_WINDOW];
                        }
                    }
                    else if (isArray(state)) {
                        if (state.indexOf(DBaseState.NEW_WINDOW) < 0) {
                            state.push(DBaseState.NEW_WINDOW);
                        }
                    }
                    else {
                        var values = state.values;
                        if (values == null) {
                            state.values = DBaseState.NEW_WINDOW;
                        }
                        else if (isString(values)) {
                            if (values !== DBaseState.NEW_WINDOW) {
                                state.values = [values, DBaseState.NEW_WINDOW];
                            }
                        }
                        else {
                            if (values.indexOf(DBaseState.NEW_WINDOW) < 0) {
                                values.push(DBaseState.NEW_WINDOW);
                            }
                        }
                    }
                }
            }
            return options;
        };
        return DLinks;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemLink = /** @class */ (function (_super) {
        __extends(DMenuItemLink, _super);
        function DMenuItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemLink.prototype.toLinkOptions = function (options) {
            if (options) {
                return {
                    url: this.toUrl(options.url),
                    target: options.target,
                    checker: this.toChecker(options.checker),
                    menu: options.menu
                };
            }
            return undefined;
        };
        DMenuItemLink.prototype.toUrl = function (url) {
            var _this = this;
            if (isString(url) || url == null) {
                return url;
            }
            else {
                return function () {
                    return url(_this);
                };
            }
        };
        DMenuItemLink.prototype.toChecker = function (checker) {
            var _this = this;
            if (checker != null) {
                return function () {
                    return checker(_this);
                };
            }
            return undefined;
        };
        DMenuItemLink.prototype.init = function (options) {
            _super.prototype.init.call(this, DLinks.toStateOptions(options === null || options === void 0 ? void 0 : options.target, options));
        };
        Object.defineProperty(DMenuItemLink.prototype, "link", {
            get: function () {
                var result = this._link;
                if (result == null) {
                    result = new DLink(this.toLinkOptions(this._options));
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DMenuItemLink.prototype.onClick = function (e) {
            if (!this.link.onClick(this, e)) {
                _super.prototype.onClick.call(this, e);
            }
        };
        DMenuItemLink.prototype.getType = function () {
            return "DMenuItemLink";
        };
        DMenuItemLink.prototype.onSelect = function (e) {
            _super.prototype.onSelect.call(this, e);
            this.link.open(e);
        };
        DMenuItemLink.prototype.open = function (inNewWindow) {
            this.link.open(inNewWindow);
        };
        DMenuItemLink.prototype.onShortcut = function (e) {
            _super.prototype.onShortcut.call(this, e);
            this.activate(e);
        };
        return DMenuItemLink;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemLinkIsCompatible = function (options) {
        return "url" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenu = /** @class */ (function (_super) {
        __extends(DMenuItemMenu, _super);
        function DMenuItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemMenu.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            this.initHover(options);
        };
        DMenuItemMenu.prototype.initHover = function (options) {
            var _this = this;
            this.on(UtilPointerEvent.over, function () {
                if (_this.state.isActionable) {
                    _this.open();
                }
            });
        };
        DMenuItemMenu.prototype.toMenu = function (options) {
            var menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof pixi_js.DisplayObject) {
                return menu;
            }
            return this.newMenu(menu);
        };
        DMenuItemMenu.prototype.newMenu = function (options) {
            return DMenus.newMenu(options);
        };
        Object.defineProperty(DMenuItemMenu.prototype, "menu", {
            get: function () {
                var _this = this;
                var result = this._menu;
                if (result == null) {
                    result = this.toMenu(this._options);
                    result.on("select", function (value, item, menu) {
                        _this.onMenuSelect(value, item, menu);
                    });
                    this._menu = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DMenuItemMenu.prototype.getType = function () {
            return "DMenuItemMenu";
        };
        DMenuItemMenu.prototype.open = function () {
            var menu = this.menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
        };
        DMenuItemMenu.prototype.onOpen = function (menu) {
            var context = this.getContext();
            if (context != null) {
                menu.open(this, this.getCloseable(), context);
            }
        };
        DMenuItemMenu.prototype.close = function () {
            this.menu.close();
        };
        DMenuItemMenu.prototype.toggle = function () {
            var menu = this.menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
            else {
                menu.close();
            }
        };
        DMenuItemMenu.prototype.onSelect = function (e) {
            this.open();
            _super.prototype.onSelect.call(this, e);
        };
        DMenuItemMenu.prototype.onMenuSelect = function (value, item, menu) {
            var closeable = this.getCloseable();
            if (closeable != null) {
                closeable.emit("select", value, item, closeable);
            }
        };
        DMenuItemMenu.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                this.onKeyDownArrowRight(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuItemMenu.prototype.onKeyDownArrowRight = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onSelect(e);
                return true;
            }
            return false;
        };
        return DMenuItemMenu;
    }(DMenuItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenuIsCompatible = function (options) {
        return "menu" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemMenuToSubMenuOptions = function (options, sticky) {
        var menu = options.menu;
        if (!(menu instanceof pixi_js.DisplayObject)) {
            if (menu.sticky == null) {
                menu.sticky = sticky;
            }
            if (menu.align == null) {
                menu.align = UtilAttachAlign.RIGHT;
            }
        }
        return options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSeparatorReflowable = /** @class */ (function (_super) {
        __extends(DMenuItemSeparatorReflowable, _super);
        function DMenuItemSeparatorReflowable(base) {
            var _this = _super.call(this) || this;
            base.snippet.add(_this, true);
            base.reflowable.add(_this);
            return _this;
        }
        DMenuItemSeparatorReflowable.prototype.onReflow = function (base, width, height) {
            var state = base.state;
            var border = base.border;
            var borderWidth = border.getWidth(state);
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderAlign = border.getAlign(state);
                var padding = base.padding;
                var middle = height * 0.5;
                this.clear();
                this.lineStyle(borderWidth, borderColor, borderAlpha, borderAlign);
                this.moveTo(padding.getLeft(), middle);
                this.lineTo(width - padding.getRight(), middle);
                this.visible = true;
            }
            else {
                this.clear();
                this.visible = false;
            }
        };
        return DMenuItemSeparatorReflowable;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSeparatorIsCompatible = function (options) {
        return "separator" in options;
    };
    var DMenuItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuItemSeparator, _super);
        function DMenuItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemSeparator.prototype.initReflowable = function () {
            new DMenuItemSeparatorReflowable(this);
        };
        DMenuItemSeparator.prototype.getType = function () {
            return "DMenuItemSeparator";
        };
        return DMenuItemSeparator;
    }(DMenuItemBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSpace = /** @class */ (function (_super) {
        __extends(DMenuItemSpace, _super);
        function DMenuItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemSpace.prototype.getType = function () {
            return "DMenuItemSpace";
        };
        return DMenuItemSpace;
    }(DLayoutSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemSpaceIsCompatible = function (options) {
        return "space" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItem = function () {
        DMenus.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuItemCheck(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuItemLink(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options, sticky) {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuItemSeparator(options);
            }
            return null;
        });
        DMenus.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuItemSpace(options);
            }
            return null;
        });
        DMenus.setItemCreatorDefault(function (options) {
            return new DMenuItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableBody = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableBody, _super);
        function DMenuItemExpandableBody() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableBody.prototype.getType = function () {
            return "DMenuItemExpandableBody";
        };
        return DMenuItemExpandableBody;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableHeader = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableHeader, _super);
        function DMenuItemExpandableHeader() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableHeader.prototype.getSelection = function () {
            return null;
        };
        DMenuItemExpandableHeader.prototype.getType = function () {
            return "DMenuItemExpandableHeader";
        };
        return DMenuItemExpandableHeader;
    }(DMenuItemBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandables = /** @class */ (function () {
        function DMenuItemExpandables() {
        }
        DMenuItemExpandables.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuItemExpandables.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuItemExpandables.newItem = function (options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky));
        };
        DMenuItemExpandables.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuItemExpandables.CREATORS = [];
        DMenuItemExpandables.CREATOR_DEFAULT = null;
        return DMenuItemExpandables;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandable = /** @class */ (function (_super) {
        __extends(DMenuItemExpandable, _super);
        function DMenuItemExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandable.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            // Header
            var theme = this.theme;
            var header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", function () {
                _this.toggle();
            });
            this.addChild(header);
            // Body
            var body = this.toBody(theme, options);
            this._body = body;
            var sticky = (_a = options === null || options === void 0 ? void 0 : options.sticky) !== null && _a !== void 0 ? _a : false;
            this.newItems(body, sticky, theme, options);
            this.addChild(body);
            //
            if (this.state.isActive) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        };
        DMenuItemExpandable.prototype.newItems = function (body, sticky, theme, options) {
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items != null) {
                DMenuItemExpandables.newItems(body, items, sticky);
            }
        };
        DMenuItemExpandable.prototype.toHeader = function (theme, options) {
            if (options) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        };
        DMenuItemExpandable.prototype.newHeader = function (theme, options) {
            return new DMenuItemExpandableHeader(options);
        };
        DMenuItemExpandable.prototype.toBody = function (theme, options) {
            var body = options === null || options === void 0 ? void 0 : options.body;
            if (body) {
                if (body instanceof pixi_js.DisplayObject) {
                    return body;
                }
                else {
                    return this.newBody(theme, body);
                }
            }
            return this.newBody(theme);
        };
        DMenuItemExpandable.prototype.newBody = function (theme, options) {
            return new DMenuItemExpandableBody(options);
        };
        DMenuItemExpandable.prototype.open = function () {
            this.state.isActive = true;
        };
        DMenuItemExpandable.prototype.close = function () {
            this.state.isActive = false;
        };
        DMenuItemExpandable.prototype.toggle = function () {
            this.state.isActive = !this.state.isActive;
        };
        DMenuItemExpandable.prototype.onActivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        };
        DMenuItemExpandable.prototype.onDeactivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        };
        DMenuItemExpandable.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this.onActivated();
                }
            }
            else {
                if (oldState.isActive) {
                    this.onDeactivated();
                }
            }
        };
        DMenuItemExpandable.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                if (this.state.isActionable && !this.state.isActive) {
                    var header = this._header;
                    if (header instanceof DBase && header.state.isFocused) {
                        this.state.isActive = true;
                    }
                }
            }
            else if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                if (this.state.isActionable && this.state.isActive) {
                    // Move the focus
                    var header = this._header;
                    if (header instanceof DBase) {
                        header.focus();
                    }
                    else {
                        this.focus();
                    }
                    // Deactivate
                    this.state.isActive = false;
                    // Key handling
                    _super.prototype.onKeyDown.call(this, e);
                    return true;
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuItemExpandable.prototype.getType = function () {
            return "DMenuItemExpandable";
        };
        return DMenuItemExpandable;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableIsCompatible = function (options) {
        return "header" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemCheck = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemCheck, _super);
        function DMenuItemExpandableItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemCheck.prototype.getType = function () {
            return "DMenuItemExpandableItemCheck";
        };
        return DMenuItemExpandableItemCheck;
    }(DMenuItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemLink = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemLink, _super);
        function DMenuItemExpandableItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemLink.prototype.getType = function () {
            return "DMenuItemExpandableItemLink";
        };
        return DMenuItemExpandableItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemSeparator, _super);
        function DMenuItemExpandableItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemSeparator.prototype.getType = function () {
            return "DMenuItemExpandableItemSeparator";
        };
        return DMenuItemExpandableItemSeparator;
    }(DMenuItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemSpace = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemSpace, _super);
        function DMenuItemExpandableItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemSpace.prototype.getType = function () {
            return "DMenuItemExpandableItemSpace";
        };
        return DMenuItemExpandableItemSpace;
    }(DMenuItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemText = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemText, _super);
        function DMenuItemExpandableItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemText.prototype.getType = function () {
            return "DMenuItemExpandableItemText";
        };
        return DMenuItemExpandableItemText;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItemExpandable = function () {
        DMenus.addItemCreator(function (options) {
            if (DMenuItemExpandableIsCompatible(options)) {
                return new DMenuItemExpandable(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuItemExpandables.setItemCreatorDefault(function (options) {
            return new DMenuItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemCheck = /** @class */ (function (_super) {
        __extends(DMenuSidedItemCheck, _super);
        function DMenuSidedItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemCheck.prototype.getType = function () {
            return "DMenuSidedItemCheck";
        };
        return DMenuSidedItemCheck;
    }(DMenuItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemLink = /** @class */ (function (_super) {
        __extends(DMenuSidedItemLink, _super);
        function DMenuSidedItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemLink.prototype.getSelection = function () {
            return null;
        };
        DMenuSidedItemLink.prototype.getType = function () {
            return "DMenuSidedItemLink";
        };
        return DMenuSidedItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemMenu = /** @class */ (function (_super) {
        __extends(DMenuSidedItemMenu, _super);
        function DMenuSidedItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemMenu.prototype.initHover = function (options) {
            // DO NOTHING
        };
        DMenuSidedItemMenu.prototype.onMenuSelect = function (value, item, menu) {
            _super.prototype.onMenuSelect.call(this, value, item, menu);
            var selection = _super.prototype.getSelection.call(this);
            if (selection) {
                selection.add(item);
            }
        };
        DMenuSidedItemMenu.prototype.onOpen = function (menu) {
            menu.open(this, this);
        };
        DMenuSidedItemMenu.prototype.getSelection = function () {
            return null;
        };
        DMenuSidedItemMenu.prototype.getType = function () {
            return "DMenuSidedItemMenu";
        };
        return DMenuSidedItemMenu;
    }(DMenuItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuSidedItemSeparator, _super);
        function DMenuSidedItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemSeparator.prototype.getType = function () {
            return "DMenuSidedItemSeparator";
        };
        return DMenuSidedItemSeparator;
    }(DMenuItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemSpace = /** @class */ (function (_super) {
        __extends(DMenuSidedItemSpace, _super);
        function DMenuSidedItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemSpace.prototype.getType = function () {
            return "DMenuSidedItemSpace";
        };
        return DMenuSidedItemSpace;
    }(DMenuItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemText = /** @class */ (function (_super) {
        __extends(DMenuSidedItemText, _super);
        function DMenuSidedItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemText.prototype.getType = function () {
            return "DMenuSidedItemText";
        };
        return DMenuSidedItemText;
    }(DMenuItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSideds = /** @class */ (function () {
        function DMenuSideds() {
        }
        DMenuSideds.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuSideds.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuSideds.newItem = function (options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky));
        };
        DMenuSideds.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuSideds.CREATORS = [];
        DMenuSideds.CREATOR_DEFAULT = null;
        return DMenuSideds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuSidedItem = function () {
        DMenuSideds.setItemCreatorDefault(function (options) {
            return new DMenuSidedItemText(options);
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuSidedItemSpace(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuSidedItemSeparator(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options, sticky) {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuSidedItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuSidedItemLink(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuSidedItemCheck(options);
            }
            return null;
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandables = /** @class */ (function () {
        function DMenuSidedItemExpandables() {
        }
        DMenuSidedItemExpandables.addItemCreator = function (creator) {
            this.CREATORS.push(creator);
        };
        DMenuSidedItemExpandables.setItemCreatorDefault = function (creator) {
            this.CREATOR_DEFAULT = creator;
        };
        DMenuSidedItemExpandables.newItem = function (options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenuSideds.newItem(options, sticky));
        };
        DMenuSidedItemExpandables.newItems = function (parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        };
        DMenuSidedItemExpandables.CREATORS = [];
        DMenuSidedItemExpandables.CREATOR_DEFAULT = null;
        return DMenuSidedItemExpandables;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandable = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandable, _super);
        function DMenuSidedItemExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandable.prototype.newItems = function (body, sticky, theme, options) {
            if (options != null && options.items != null) {
                DMenuSidedItemExpandables.newItems(body, options.items, sticky);
            }
        };
        DMenuSidedItemExpandable.prototype.getType = function () {
            return "DMenuSidedItemExpandable";
        };
        return DMenuSidedItemExpandable;
    }(DMenuItemExpandable));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemCheck = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemCheck, _super);
        function DMenuSidedItemExpandableItemCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemCheck.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemCheck";
        };
        return DMenuSidedItemExpandableItemCheck;
    }(DMenuItemExpandableItemCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemLink = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemLink, _super);
        function DMenuSidedItemExpandableItemLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemLink.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemLink";
        };
        return DMenuSidedItemExpandableItemLink;
    }(DMenuItemLink));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuItemExpandableItemMenu = /** @class */ (function (_super) {
        __extends(DMenuItemExpandableItemMenu, _super);
        function DMenuItemExpandableItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuItemExpandableItemMenu.prototype.getType = function () {
            return "DMenuItemExpandableItemMenu";
        };
        return DMenuItemExpandableItemMenu;
    }(DMenuItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemMenu = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemMenu, _super);
        function DMenuSidedItemExpandableItemMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemMenu.prototype.onOpen = function (menu) {
            menu.open(this, this);
        };
        DMenuSidedItemExpandableItemMenu.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemMenu";
        };
        return DMenuSidedItemExpandableItemMenu;
    }(DMenuItemExpandableItemMenu));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemSeparator = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemSeparator, _super);
        function DMenuSidedItemExpandableItemSeparator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemSeparator.prototype.getType = function () {
            return "DMenuSidedItemSeparator";
        };
        return DMenuSidedItemExpandableItemSeparator;
    }(DMenuItemExpandableItemSeparator));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemSpace = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemSpace, _super);
        function DMenuSidedItemExpandableItemSpace() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemSpace.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemSpace";
        };
        return DMenuSidedItemExpandableItemSpace;
    }(DMenuItemExpandableItemSpace));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedItemExpandableItemText = /** @class */ (function (_super) {
        __extends(DMenuSidedItemExpandableItemText, _super);
        function DMenuSidedItemExpandableItemText() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedItemExpandableItemText.prototype.getType = function () {
            return "DMenuSidedItemExpandableItemText";
        };
        return DMenuSidedItemExpandableItemText;
    }(DMenuItemExpandableItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuSidedItemExpandable = function () {
        DMenuSideds.addItemCreator(function (options) {
            if (DMenuItemExpandableIsCompatible(options)) {
                return new DMenuSidedItemExpandable(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options, sticky) {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator(function (options) {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.setItemCreatorDefault(function (options) {
            return new DMenuSidedItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadMenuItemAll = function () {
        loadMenuItem();
        loadMenuItemExpandable();
        loadMenuSidedItem();
        loadMenuSidedItemExpandable();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var loadAll = function () {
        loadMenuItemAll();
        loadShapeAll();
    };

    var EShapeActionRuntimes = /** @class */ (function () {
        function EShapeActionRuntimes() {
        }
        EShapeActionRuntimes.add = function (type, runtime) {
            var typeToRuntimes = this._typeToRuntimes;
            if (typeToRuntimes == null) {
                typeToRuntimes = new Map();
                this._typeToRuntimes = typeToRuntimes;
            }
            var runtimes = typeToRuntimes.get(type);
            if (runtimes == null) {
                runtimes = [runtime];
                typeToRuntimes.set(type, runtimes);
            }
            else {
                runtimes.push(runtime);
            }
        };
        EShapeActionRuntimes.get = function (type) {
            var typeToRuntimes = this._typeToRuntimes;
            if (typeToRuntimes != null) {
                return typeToRuntimes.get(type);
            }
        };
        return EShapeActionRuntimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscEmitEvent = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscEmitEvent, _super);
        function EShapeActionValueMiscEmitEvent(condition, target) {
            return _super.call(this, EShapeActionValueMiscType.EMIT_EVENT, condition, target, EShapeActionValueOnInputAction.EMIT_EVENT, "") || this;
        }
        return EShapeActionValueMiscEmitEvent;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscHtmlElement = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscHtmlElement, _super);
        function EShapeActionValueMiscHtmlElement(subtype, when, initializer) {
            return _super.call(this, subtype, when, "", EShapeActionValueOnInputAction.EMIT_EVENT, initializer) || this;
        }
        return EShapeActionValueMiscHtmlElement;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscInput = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscInput, _super);
        function EShapeActionValueMiscInput(subtype, when, target, onInputAction) {
            return _super.call(this, subtype, when, target, onInputAction, "") || this;
        }
        return EShapeActionValueMiscInput;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeActionValueMiscWrite = /** @class */ (function (_super) {
        __extends(EShapeActionValueMiscWrite, _super);
        function EShapeActionValueMiscWrite(subtype, condition, target, value) {
            return _super.call(this, subtype, condition, target, EShapeActionValueOnInputAction.EMIT_EVENT, value) || this;
        }
        return EShapeActionValueMiscWrite;
    }(EShapeActionValueMisc));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImageSdf = function (dataUrl, convertToSdf) {
        if (convertToSdf) {
            return toImageElement(dataUrl).then(function (imageElement) {
                var generator = DynamicSDFFontGenerator.getInstance().init();
                generator.updateTexture(imageElement);
                generator.render();
                var canvas = document.createElement("canvas");
                generator.read(canvas);
                return createImageSdf(canvas.toDataURL(), false);
            });
        }
        else {
            return toImageElement(dataUrl).then(function (imageElement) {
                return new EShapeImageSdf(imageElement);
            });
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var createImage = function (dataUrl) {
        return toImageElement(dataUrl).then(function (imageElement) {
            return new EShapeImage(imageElement);
        });
    };

    var createLine = function (points, segments, strokeWidth, pointsStyle) {
        // Calculate the boundary
        var boundary = toPointsBoundary(points, [0, 0, 0, 0]);
        var cx = (boundary[2] + boundary[0]) * 0.5;
        var cy = (boundary[3] + boundary[1]) * 0.5;
        var sx = boundary[2] - boundary[0];
        var sy = boundary[3] - boundary[1];
        // Calculate values
        var values = [];
        for (var i = 0, imax = points.length; i < imax; i += 2) {
            values.push(points[i] - cx, points[i + 1] - cy);
        }
        // Create a line
        var result = new EShapeLine();
        result.stroke.set(true, undefined, undefined, strokeWidth);
        result.transform.position.set(cx, cy);
        result.size.set(sx, sy);
        result.points.set(values, segments, pointsStyle);
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeEmbeddeds = /** @class */ (function () {
        function EShapeEmbeddeds() {
        }
        EShapeEmbeddeds.from = function (serializedOrSimple, controller, mode) {
            var _this = this;
            var serialized = DDiagrams.toSerialized(serializedOrSimple);
            var pieces = serialized.pieces;
            return DDiagrams.toPieceData(controller, pieces, mode).then(function (pieceData) {
                return _this.from_(serialized, mode, pieces, pieceData);
            });
        };
        EShapeEmbeddeds.from_ = function (serialized, mode, pieces, pieceData) {
            var _this = this;
            var width = serialized.width;
            var height = serialized.height;
            var container = new EShapeEmbeddedLayerContainer(width, height);
            var manager = new EShapeResourceManagerDeserialization(serialized, pieces, pieceData, mode, 1);
            return DDiagrams.newLayer(serialized, container, manager).then(function () {
                return _this.create(serialized.name, width, height, container, mode, 0);
            });
        };
        EShapeEmbeddeds.create = function (name, width, height, container, mode, depth) {
            var shape = new EShapeEmbedded(name, mode, depth);
            shape.size.set(width, height);
            container.copyTo(shape);
            shape.size.init();
            return shape;
        };
        return EShapeEmbeddeds;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSvgUrl = function (svg) {
        return "data:image/svg+xml;base64,".concat(btoa(svg));
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toGradientImageUrl = function (gradient) {
        var direction = gradient.direction;
        var points = gradient.points;
        var stops = "";
        for (var i = 0, imax = points.length; i < imax; ++i) {
            var point = points[i];
            var color = UtilRgb.toCode(point.color);
            var alpha = point.alpha;
            var offset = point.position * 100;
            stops += "<stop offset=\"".concat(offset, "%\" stop-color=\"#").concat(color, "\" stop-opacity=\"").concat(alpha, "\" />");
        }
        var radian = (direction * Math.PI) / 180;
        var dx = 0.5 * Math.cos(radian);
        var dy = -0.5 * Math.sin(radian);
        var url = toSvgUrl(
        /* eslint-disable prettier/prettier */
        "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">" +
            "<defs>" +
            "<linearGradient id=\"o2glkm3aeu2oio\" x1=\"".concat(0.5 - dx, "\" x2=\"").concat(0.5 + dx, "\" y1=\"").concat(0.5 - dy, "\" y2=\"").concat(0.5 + dy, "\">") +
            stops +
            "</linearGradient>" +
            "</defs>" +
            "<rect x=\"0\" y=\"0\" width=\"32\" height=\"32\" stroke=\"none\" fill=\"url(#o2glkm3aeu2oio)\" />" +
            "</svg>"
        /* eslint-enable prettier/prettier */
        );
        return url;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSizeRounded = function (value) {
        return Math.round(value * 100) / 100;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toResized = function (shape, from, to, centerMode, isPerfect) {
        var cposition = EShapeCapabilities.contains(shape, EShapeCapability.POSITION);
        var cwidth = EShapeCapabilities.contains(shape, EShapeCapability.WIDTH);
        var cheight = EShapeCapabilities.contains(shape, EShapeCapability.HEIGHT);
        shape.disallowUploadedUpdate();
        var position = shape.transform.position;
        if (centerMode) {
            var dx = Math.abs(to.x - from.x);
            var dy = Math.abs(to.y - from.y);
            if (isPerfect) {
                var d = Math.max(dx, dy);
                var s = toSizeNormalized(d + d);
                var x = toSizeRounded(from.x);
                var y = toSizeRounded(from.y);
                var size = shape.size;
                if (cwidth && cheight) {
                    size.set(s, s);
                }
                else if (cwidth) {
                    size.x = s;
                }
                else if (cheight) {
                    size.y = s;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
            else {
                var w = toSizeNormalized(dx + dx);
                var h = toSizeNormalized(dy + dy);
                var x = toSizeRounded(from.x);
                var y = toSizeRounded(from.y);
                var size = shape.size;
                if (cwidth && cheight) {
                    size.set(w, h);
                }
                else if (cwidth) {
                    size.x = w;
                }
                else if (cheight) {
                    size.y = h;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
        }
        else {
            if (isPerfect) {
                var dx = to.x - from.x;
                var dy = to.y - from.y;
                var d = Math.max(Math.abs(dx), Math.abs(dy));
                var x2 = from.x + (dx < 0 ? -d : +d);
                var y2 = from.y + (dy < 0 ? -d : +d);
                var hd = d * 0.5;
                var s = toSizeNormalized(d);
                var x = toSizeRounded(Math.min(from.x, x2) + hd);
                var y = toSizeRounded(Math.min(from.y, y2) + hd);
                var size = shape.size;
                if (cwidth && cheight) {
                    size.set(s, s);
                }
                else if (cwidth) {
                    size.x = s;
                }
                else if (cheight) {
                    size.y = s;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
            else {
                var x0 = Math.min(from.x, to.x);
                var y0 = Math.min(from.y, to.y);
                var x1 = Math.max(from.x, to.x);
                var y1 = Math.max(from.y, to.y);
                var dx = x1 - x0;
                var dy = y1 - y0;
                var px = dx * 0.5;
                var py = dy * 0.5;
                var w = toSizeNormalized(dx);
                var h = toSizeNormalized(dy);
                var x = toSizeRounded(x0 + px);
                var y = toSizeRounded(y0 + py);
                var size = shape.size;
                if (cwidth && cheight) {
                    size.set(w, h);
                }
                else if (cwidth) {
                    size.x = w;
                }
                else if (cheight) {
                    size.y = h;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
        }
        shape.allowUploadedUpdate();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDataValueExtensions = /** @class */ (function () {
        function EShapeDataValueExtensions() {
        }
        EShapeDataValueExtensions.add = function (extension) {
            var _a, _b, _c;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._idToDatum) !== null && _b !== void 0 ? _b : (this._idToDatum = new Map())).set(extension.id, extension);
            ((_c = this._data) !== null && _c !== void 0 ? _c : (this._data = [])).push(extension);
        };
        EShapeDataValueExtensions.get = function (type) {
            var typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        };
        EShapeDataValueExtensions.getById = function (id) {
            var idToDatum = this._idToDatum;
            if (idToDatum != null) {
                return idToDatum.get(id);
            }
        };
        EShapeDataValueExtensions.each = function (iteratee) {
            var data = this._data;
            if (data != null) {
                for (var i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        };
        return EShapeDataValueExtensions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link EShape} search utility.
     */
    var EShapeSearch = /** @class */ (function () {
        function EShapeSearch() {
        }
        /**
         * Returns indices of the given shapes.
         *
         * @param shapes shapes
         * @return indices
         */
        EShapeSearch.toIndices = function (shapes) {
            var result = [];
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                result.push(shapes[i].index);
            }
            return result;
        };
        /**
         * Returns a depth of the given shape.
         *
         * @param shape a shape
         * @return a depth
         */
        EShapeSearch.toDepth = function (shape) {
            var result = 0;
            var parent = shape.parent;
            while (parent instanceof EShapeBase) {
                result += 1;
                parent = parent.parent;
            }
            return result;
        };
        /**
         * Returns a deepest shape on the path to the given shapes.
         *
         * @param shapeA a shape
         * @param shapeB a shape
         * @return a found shape
         */
        EShapeSearch.toSharedParent = function (shapeA, shapeB) {
            var depthA = this.toDepth(shapeA);
            var depthB = this.toDepth(shapeB);
            if (depthA < depthB) {
                var parent_1 = shapeA.parent;
                while (parent_1 instanceof EShapeBase) {
                    if (this.isParent(shapeB, parent_1)) {
                        return parent_1;
                    }
                    parent_1 = parent_1.parent;
                }
                return parent_1;
            }
            else {
                var parent_2 = shapeB.parent;
                while (parent_2 instanceof EShapeBase) {
                    if (this.isParent(shapeA, parent_2)) {
                        return parent_2;
                    }
                    parent_2 = parent_2.parent;
                }
                return parent_2;
            }
        };
        /**
         * Returns a shape on the path to the given shape whose parent is equals to the given parent.
         * If there is no such shape, returns a root shape on the path.
         *
         * @param shape a shape
         * @param parent a parent
         * @returns a found shape
         */
        EShapeSearch.toOfParent = function (shape, parent) {
            var shapeParent = shape.parent;
            while (shapeParent !== parent && shapeParent instanceof EShapeBase) {
                shape = shapeParent;
                shapeParent = shapeParent.parent;
            }
            return shape;
        };
        /**
         * Returns true if the given target is on the path to the given shape.
         *
         * @param shape a shape
         * @param target a check target
         * @return true if the given target is on the path to the given shape
         */
        EShapeSearch.isParent = function (shape, target) {
            var parent = shape.parent;
            while (parent instanceof EShapeBase) {
                if (parent === target) {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        };
        /**
         * Returns a selected shape on the path to the given shape.
         * If there are more than one selected shapes, returns a deepest selected shape.
         *
         * @param shape a shape
         * @return a found selected shape or null
         */
        EShapeSearch.toSelected = function (shape) {
            var target = shape;
            while (target instanceof EShapeBase) {
                if (target.selected) {
                    return target;
                }
                target = target.parent;
            }
            return null;
        };
        EShapeSearch.findChildById = function (shape, id, recursively) {
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child.id === id) {
                    return child;
                }
                if (recursively === true) {
                    var result = EShapeSearch.findChildById(child, id, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        EShapeSearch.findChildByType = function (shape, type, recursively) {
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child.type === type) {
                    return child;
                }
                if (recursively === true) {
                    var result = EShapeSearch.findChildByType(child, type, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        EShapeSearch.findChild = function (shape, matcher, recursively) {
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (matcher(child)) {
                    return child;
                }
                if (recursively === true) {
                    var result = EShapeSearch.findChild(child, matcher, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        EShapeSearch.findChildrenByType = function (shape, type, recursively, result) {
            result = result || [];
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child.type === type) {
                    result.push(child);
                }
                if (recursively === true) {
                    EShapeSearch.findChildrenByType(child, type, recursively, result);
                }
            }
            return result;
        };
        EShapeSearch.findChildren = function (shape, matcher, recursively, result) {
            result = result || [];
            var children = shape.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (matcher(child)) {
                    result.push(child);
                }
                if (recursively === true) {
                    EShapeSearch.findChildren(child, matcher, recursively, result);
                }
            }
            return result;
        };
        EShapeSearch.COMPARATOR_INDEX = function (a, b) {
            return a.index - b.index;
        };
        return EShapeSearch;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeDeleter = /** @class */ (function () {
        function EShapeDeleter() {
        }
        EShapeDeleter.delete = function (parent, shapes, generateListOfDetachedShapes) {
            var children = parent.children;
            var length = children.length;
            // Update indices
            for (var i = 0; i < length; ++i) {
                var child = children[i];
                if (child.selected) {
                    child.index = length + i;
                }
                else {
                    child.index = i;
                }
            }
            // Sort
            children.sort(EShapeSearch.COMPARATOR_INDEX);
            // Detach
            if (generateListOfDetachedShapes === true) {
                for (var i = length - 1; 0 <= i; --i) {
                    var child = children[i];
                    if (child.selected) {
                        child.index -= length;
                        child.parent = null;
                        child.selected = false;
                        child.uploaded = undefined;
                        child.onDetach();
                    }
                    else {
                        var size = children.length - (i + 1);
                        if (0 < size) {
                            var result = children.splice(i + 1, size);
                            if (shapes != null) {
                                shapes.length = 0;
                            }
                            parent.onChildTransformChange();
                            parent.toDirty();
                            return result;
                        }
                        else {
                            if (shapes != null) {
                                shapes.length = 0;
                            }
                            return null;
                        }
                    }
                }
                if (0 < children.length) {
                    var result = children.splice(0, children.length);
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    parent.onChildTransformChange();
                    parent.toDirty();
                    return result;
                }
                else {
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    return null;
                }
            }
            else {
                for (var i = length - 1; 0 <= i; --i) {
                    var child = children[i];
                    if (child.selected) {
                        child.parent = null;
                        child.selected = false;
                        child.uploaded = undefined;
                        child.onDetach();
                    }
                    else {
                        children.length = i + 1;
                        if (shapes != null) {
                            shapes.length = 0;
                        }
                        parent.onChildTransformChange();
                        parent.toDirty();
                        return null;
                    }
                }
                if (0 < children.length) {
                    children.length = 0;
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    parent.onChildTransformChange();
                    parent.toDirty();
                }
                else {
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                }
                return null;
            }
        };
        return EShapeDeleter;
    }());

    var EShapePointsStyles = /** @class */ (function () {
        function EShapePointsStyles() {
        }
        EShapePointsStyles.from = function (style) {
            if (isString(style)) {
                return EShapePointsStyle[style];
            }
            else if (isNumber(style)) {
                return style;
            }
            else if (style != null) {
                var result = EShapePointsStyle.NONE;
                for (var i = 0, imax = style.length; i < imax; ++i) {
                    result |= EShapePointsStyle[style[i]];
                }
                return result;
            }
            else {
                return EShapePointsStyle.NONE;
            }
        };
        return EShapePointsStyles;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EShapeResourceManagerSerialization = /** @class */ (function () {
        function EShapeResourceManagerSerialization() {
            this.resources = [];
            this.resourceToIndex = new Map();
            this.data = [];
            this.dataToIndex = new Map();
            this.pieces = [];
            this.pieceToIndex = new Map();
            this.uuids = new Set();
            this.uuidNext = 0;
        }
        EShapeResourceManagerSerialization.prototype.addResource = function (resource) {
            return this.add_(resource, this.resources, this.resourceToIndex);
        };
        EShapeResourceManagerSerialization.prototype.addData = function (data) {
            return this.add_(data, this.data, this.dataToIndex);
        };
        EShapeResourceManagerSerialization.prototype.addPiece = function (piece) {
            return this.add_(piece, this.pieces, this.pieceToIndex);
        };
        EShapeResourceManagerSerialization.prototype.addUuid = function (uuid) {
            if (uuid !== 0) {
                var uuids = this.uuids;
                if (uuids.has(uuid)) {
                    return 0;
                }
                else {
                    uuids.add(uuid);
                    return uuid;
                }
            }
            return 0;
        };
        EShapeResourceManagerSerialization.prototype.updateUuid = function (uuid) {
            var uuids = this.uuids;
            if (uuid !== 0) {
                return uuid;
            }
            else {
                var newUuid = this.newUuid();
                uuids.add(newUuid);
                return newUuid;
            }
        };
        EShapeResourceManagerSerialization.prototype.newUuid = function () {
            var uuids = this.uuids;
            var uuidNext = this.uuidNext;
            while (true) {
                uuidNext += 1;
                if (uuidNext !== 0 && !uuids.has(uuidNext)) {
                    this.uuidNext = uuidNext;
                    return uuidNext;
                }
            }
        };
        EShapeResourceManagerSerialization.prototype.add_ = function (target, array, map) {
            var result = map.get(target);
            if (result != null) {
                return result;
            }
            var index = array.length;
            array.push(target);
            map.set(target, index);
            return index;
        };
        return EShapeResourceManagerSerialization;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperGrid = /** @class */ (function (_super) {
        __extends(ESnapperGrid, _super);
        function ESnapperGrid(theme, options) {
            var _this = this;
            var _a, _b, _c;
            _this = _super.call(this) || this;
            _this._isVisibleDefault = (_a = options === null || options === void 0 ? void 0 : options.visible) !== null && _a !== void 0 ? _a : theme.isSnapGridVisible();
            _this._isVisible = _this._isVisibleDefault;
            _this._isEnabledDefault = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isSnapGridEnabled();
            _this._isEnabled = _this._isEnabledDefault;
            _this._sizeDefault = (_c = options === null || options === void 0 ? void 0 : options.size) !== null && _c !== void 0 ? _c : theme.getSnapGridSize();
            _this._size = _this._sizeDefault;
            return _this;
        }
        Object.defineProperty(ESnapperGrid.prototype, "visible", {
            get: function () {
                return this._isVisible;
            },
            set: function (visible) {
                if (this._isVisible !== visible) {
                    this._isVisible = visible;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperGrid.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                if (this._isEnabled !== enable) {
                    this._isEnabled = enable;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperGrid.prototype, "size", {
            get: function () {
                return this._size;
            },
            set: function (size) {
                if (this._size !== size) {
                    this._size = size;
                    this.emit("change", size, this);
                }
            },
            enumerable: false,
            configurable: true
        });
        ESnapperGrid.prototype.snap = function (value, result) {
            if (this._isEnabled) {
                var size = this._size;
                result.set(value, Math.round(value / size) * size);
            }
        };
        ESnapperGrid.prototype.reset = function () {
            this._isVisible = this._isVisibleDefault;
            this._isEnabled = this._isEnabledDefault;
            this._size = this._sizeDefault;
            this.emit("change", this);
        };
        ESnapperGrid.prototype.serialize = function () {
            return [this._isEnabled ? 1 : 0, this._isVisible ? 1 : 0, this._size];
        };
        ESnapperGrid.prototype.deserialize = function (serialized) {
            this.enable = !!serialized[0];
            if (2 in serialized) {
                this.visible = !!serialized[1];
                this.size = serialized[2];
            }
            else {
                this.visible = false;
                this.size = serialized[1];
            }
        };
        return ESnapperGrid;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperResultScale = /** @class */ (function () {
        function ESnapperResultScale() {
            this.distance = NaN;
            this.scale = new pixi_js.Point();
        }
        return ESnapperResultScale;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperResult = /** @class */ (function () {
        function ESnapperResult() {
            this.distance = NaN;
            this.result = 0;
            this.threshold = 10;
        }
        ESnapperResult.prototype.reset = function (value, scale) {
            this.distance = NaN;
            this.result = value;
            this.threshold = 0.0001 < scale ? 10 / scale : 10;
        };
        ESnapperResult.prototype.set = function (value, snapped) {
            var newDistance = Math.abs(snapped - value);
            if (newDistance <= this.threshold) {
                var oldDistance = this.distance;
                if (oldDistance !== oldDistance || newDistance < oldDistance) {
                    this.distance = newDistance;
                    this.result = snapped;
                }
            }
        };
        return ESnapperResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperTargetValueType = {
        HORIZONTAL: 0,
        VERTICAL: 1
    };
    var ESnapperTargetValue = /** @class */ (function () {
        function ESnapperTargetValue(type, position) {
            this.type = type;
            this.position = position;
        }
        ESnapperTargetValue.prototype.serialize = function () {
            return [this.type, this.position];
        };
        return ESnapperTargetValue;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var ESnapperTarget = /** @class */ (function (_super) {
        __extends(ESnapperTarget, _super);
        function ESnapperTarget(theme, options) {
            var _this = this;
            var _a, _b;
            _this = _super.call(this) || this;
            _this.values = [];
            _this._isVisibleDefault = (_a = options === null || options === void 0 ? void 0 : options.visible) !== null && _a !== void 0 ? _a : theme.isSnapTargetVisible();
            _this._isVisible = _this._isVisibleDefault;
            _this._isEnabledDefault = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isSnapTargetEnabled();
            _this._isEnabled = _this._isEnabledDefault;
            return _this;
        }
        Object.defineProperty(ESnapperTarget.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                if (this._isEnabled !== enable) {
                    this._isEnabled = enable;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperTarget.prototype, "visible", {
            get: function () {
                return this._isVisible;
            },
            set: function (visible) {
                if (this._isVisible !== visible) {
                    this._isVisible = visible;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ESnapperTarget.prototype, "size", {
            get: function () {
                return this.values.length;
            },
            enumerable: false,
            configurable: true
        });
        ESnapperTarget.prototype.add = function (target, index) {
            if (index != null) {
                this.values.splice(index, 0, target);
            }
            else {
                this.values.push(target);
            }
            this.emit("change", this);
        };
        ESnapperTarget.prototype.remove = function (index) {
            var values = this.values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1);
                this.emit("change", this);
            }
        };
        ESnapperTarget.prototype.replace = function (index, value) {
            var values = this.values;
            if (0 <= index && index < values.length) {
                var result = values[index];
                values[index] = value;
                this.emit("change", this);
                return result;
            }
            return null;
        };
        ESnapperTarget.prototype.swap = function (indexA, indexB) {
            if (indexA !== indexB) {
                var values = this.values;
                var valueA = values[indexA];
                values[indexA] = values[indexB];
                values[indexB] = valueA;
                this.emit("change", this);
            }
        };
        ESnapperTarget.prototype.snap = function (px, py, x, y) {
            if (this._isEnabled) {
                var values = this.values;
                for (var i = 0, imax = values.length; i < imax; ++i) {
                    var value = values[i];
                    if (value.type === ESnapperTargetValueType.VERTICAL) {
                        x.set(px, value.position);
                    }
                    else {
                        y.set(py, value.position);
                    }
                }
            }
        };
        ESnapperTarget.prototype.reset = function () {
            this._isEnabled = this._isEnabledDefault;
            this._isVisible = this._isVisibleDefault;
            this.values.length = 0;
            this.emit("change", this);
        };
        ESnapperTarget.prototype.serialize = function () {
            var targets = [];
            var values = this.values;
            for (var i = 0, imax = values.length; i < imax; ++i) {
                targets.push(values[i].serialize());
            }
            return [this._isEnabled ? 1 : 0, this._isVisible ? 1 : 0, targets];
        };
        ESnapperTarget.prototype.deserialize = function (serialized) {
            // Availability
            this._isEnabled = !!serialized[0];
            // Visibility
            this._isVisible = !!serialized[1];
            // Values
            var sources = serialized[2];
            var values = this.values;
            values.length = 0;
            for (var i = 0, imax = sources.length; i < imax; ++i) {
                var source = sources[i];
                values.push(new ESnapperTargetValue(source[0], source[1]));
            }
            this.emit("change", this);
        };
        return ESnapperTarget;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var EPSILON = 0.00001;
    var ESnapperModifierAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_CENTER: 2,
        TOP_RIGHT: 3,
        MIDDLE_LEFT: 4,
        MIDDLE_RIGHT: 5,
        BOTTOM_LEFT: 6,
        BOTTOM_CENTER: 7,
        BOTTOM_RIGHT: 8,
        ROTATION: 9
    };
    var ESnapper = /** @class */ (function (_super) {
        __extends(ESnapper, _super);
        function ESnapper(parent, theme, options) {
            var _this = this;
            var _a;
            _this = _super.call(this) || this;
            _this._points = [
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point(),
                new pixi_js.Point() // Center
            ];
            _this._normals = [new pixi_js.Point(), new pixi_js.Point()];
            _this._lengths = [1, 1];
            _this._workScale = new pixi_js.Point();
            _this._workSnapResultX = new ESnapperResult();
            _this._workSnapResultY = new ESnapperResult();
            _this._workScaleResult = {
                distance: 0,
                scale: new pixi_js.Point()
            };
            _this._workTranslate = new pixi_js.Point();
            _this._workSnapRectangle = new pixi_js.Rectangle();
            _this._workSnap = new pixi_js.Point();
            _this.grid = new ESnapperGrid(theme, options === null || options === void 0 ? void 0 : options.grid);
            _this.target = new ESnapperTarget(theme, options === null || options === void 0 ? void 0 : options.target);
            _this._parent = parent;
            _this._isEnabledDefault = (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : theme.isSnapEnabled();
            _this._isEnabled = _this._isEnabledDefault;
            return _this;
        }
        Object.defineProperty(ESnapper.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                if (this._isEnabled !== enable) {
                    this._isEnabled = enable;
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        ESnapper.prototype.prepare = function (modifier) {
            modifier.updateTransform();
            var localTransform = modifier.transform.localTransform;
            var sx = modifier.width;
            var sy = modifier.height;
            var points = this._points;
            points[0].set(0, 0);
            points[1].set(sx, 0);
            points[2].set(sx, sy);
            points[3].set(0, sy);
            points[4].set(sx * 0.5, sy * 0.5);
            localTransform.apply(points[0], points[0]);
            localTransform.apply(points[1], points[1]);
            localTransform.apply(points[2], points[2]);
            localTransform.apply(points[3], points[3]);
            localTransform.apply(points[4], points[4]);
        };
        ESnapper.prototype.prepareForTranslate = function (modifier) {
            if (this._isEnabled) {
                this.prepare(modifier);
            }
        };
        ESnapper.prototype.snap = function (point, result) {
            var px = point.x;
            var py = point.y;
            var canvas = this._parent.canvas;
            var x = this._workSnapResultX;
            var y = this._workSnapResultY;
            // Canvas
            if (canvas != null) {
                var scale = Math.max(canvas.scale.x, canvas.scale.y);
                x.reset(px, scale);
                y.reset(py, scale);
                x.set(px, 0);
                x.set(px, canvas.width);
                y.set(py, 0);
                y.set(py, canvas.height);
            }
            else {
                x.reset(px, 1);
                y.reset(py, 1);
            }
            // Target
            this.target.snap(px, py, x, y);
            // Grid
            this.grid.snap(px, x);
            this.grid.snap(py, y);
            //
            result.x = isNaN$1(x.distance) ? NaN : x.result;
            result.y = isNaN$1(y.distance) ? NaN : y.result;
            return result;
        };
        ESnapper.prototype.toSnapped = function (point, result) {
            var px = point.x;
            var py = point.y;
            if (this._isEnabled) {
                this.snap(point, result);
                var x = result.x;
                var y = result.y;
                result.set(isNaN$1(x) ? px : x, isNaN$1(y) ? py : y);
            }
            else {
                result.set(px, py);
            }
            return result;
        };
        ESnapper.prototype.toTranslationSnapped = function (delta, result) {
            var dx = delta.x;
            var dy = delta.y;
            var x = NaN;
            var y = NaN;
            if (this._isEnabled) {
                var workTranslate = this._workTranslate;
                var points = this._points;
                for (var i = 0, imax = points.length; i < imax; ++i) {
                    var point = points[i];
                    workTranslate.set(point.x + dx, point.y + dy);
                    this.snap(workTranslate, workTranslate);
                    // X
                    if (!isNaN$1(workTranslate.x)) {
                        var newDx = workTranslate.x - point.x;
                        if (isNaN$1(x) || Math.abs(newDx - dx) < Math.abs(x - dx)) {
                            x = newDx;
                        }
                    }
                    // Y
                    if (!isNaN$1(workTranslate.y)) {
                        var newDy = workTranslate.y - point.y;
                        if (isNaN$1(y) || Math.abs(newDy - dy) < Math.abs(y - dy)) {
                            y = newDy;
                        }
                    }
                }
            }
            result.x = isNaN$1(x) ? dx : x;
            result.y = isNaN$1(y) ? dy : y;
            return result;
        };
        ESnapper.prototype.prepareForRotate = function (modifier) {
            //
        };
        ESnapper.prototype.getGridSizeRotation = function () {
            return 5;
        };
        ESnapper.prototype.toRadian = function (value) {
            return (value / 180) * Math.PI;
        };
        ESnapper.prototype.toDegree = function (value) {
            return (value / Math.PI) * 180;
        };
        ESnapper.prototype.toRotationSnapped = function (baseRotation, deltaRotation) {
            if (this._isEnabled) {
                var gridSize = this.getGridSizeRotation();
                var newRotation = baseRotation + deltaRotation;
                var newRotationDegree = Math.round(this.toDegree(newRotation));
                var newRotationDegreeResidual = newRotationDegree % 90;
                if (Math.abs(newRotationDegreeResidual) <= gridSize) {
                    return this.toRadian(newRotationDegree - newRotationDegreeResidual) - baseRotation;
                }
                else {
                    if (90 - gridSize <= newRotationDegreeResidual) {
                        return (this.toRadian(newRotationDegree + (90 - newRotationDegreeResidual)) -
                            baseRotation);
                    }
                    else if (newRotationDegreeResidual <= -90 + gridSize) {
                        return (this.toRadian(newRotationDegree - (90 + newRotationDegreeResidual)) -
                            baseRotation);
                    }
                    else {
                        return deltaRotation;
                    }
                }
            }
            return deltaRotation;
        };
        ESnapper.prototype.calcNormalizedVector = function (p0, p1, result) {
            var dx = p1.x - p0.x;
            var dy = p1.y - p0.y;
            var l = Math.sqrt(dx * dx + dy * dy);
            if (EPSILON < l) {
                var d = 1 / l;
                result.x = dx * d;
                result.y = dy * d;
            }
            else {
                result.x = 1;
                result.y = 0;
            }
            return l;
        };
        ESnapper.prototype.prepareForScale = function (modifier, anchor) {
            if (this._isEnabled) {
                this.prepare(modifier);
                var points = this._points;
                var normals = this._normals;
                var lengths = this._lengths;
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[3], points[0], normals[1]);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[3], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[2], points[1], normals[1]);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[2], points[3], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[0], points[3], normals[1]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[0], points[3], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[3], points[2], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[1], points[2], normals[1]);
                        break;
                }
            }
        };
        ESnapper.prototype.setScaleSnappedResult = function (distance, length, move, axis, // true => x axis, false y axis
        result) {
            if (EPSILON < length) {
                if (isNaN$1(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    var newScale = 1 + move / length;
                    if (axis) {
                        result.scale.x = newScale;
                    }
                    else {
                        result.scale.y = newScale;
                    }
                }
            }
        };
        ESnapper.prototype.calcScaleSnapped1D = function (transform, point, normal, length, axis, result) {
            var work = this._workScale;
            transform.apply(point, work);
            var tx = work.x;
            var ty = work.y;
            this.snap(work, work);
            var x = work.x;
            var y = work.y;
            // X coordinate
            if (!isNaN$1(x)) {
                var nx = Math.abs(normal.x);
                if (EPSILON < nx) {
                    var dx = (x - tx) / normal.x;
                    var distance = Math.abs(dx);
                    var mx = (x - point.x) / normal.x;
                    this.setScaleSnappedResult(distance, length, mx, axis, result);
                }
            }
            // Y coordinate
            if (!isNaN$1(y)) {
                var ny = Math.abs(normal.y);
                if (EPSILON < ny) {
                    var dy = (y - ty) / normal.y;
                    var distance = Math.abs(dy);
                    var my = (y - point.y) / normal.y;
                    this.setScaleSnappedResult(distance, length, my, axis, result);
                }
            }
        };
        ESnapper.prototype.calcScaleSnappedX = function (transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, true, result);
        };
        ESnapper.prototype.calcScaleSnappedY = function (transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, false, result);
        };
        ESnapper.prototype.calcScaleSnapped2D = function (transform, point, normals, lengths, result) {
            var work = this._workScale;
            transform.apply(point, work);
            var tx = work.x;
            var ty = work.y;
            this.snap(work, work);
            var x = work.x;
            var y = work.y;
            if (isNaN$1(x)) {
                if (isNaN$1(y)) {
                    return;
                }
                else {
                    x = tx;
                }
            }
            else {
                if (isNaN$1(y)) {
                    y = ty;
                }
            }
            // (x, y) = (tx, ty) + normalA * a + normalB * b
            // dx = x - tx
            // dy = y - ty
            // V = ( a, b )^T
            // D = ( dx, dy )^T
            // A = | normalA.x normalB.x |
            //     | normalA.y normalB.y |
            // A V = D
            // det A = normalA.x * normalB.y - normalB.x * normalA.y
            // A^-1 = |  normalB.y -normalB.x | / det A
            //        | -normalA.y  normalA.x |
            var detA = normals[0].x * normals[1].y - normals[1].x * normals[0].y;
            if (EPSILON < Math.abs(detA)) {
                var dx = x - tx;
                var dy = y - ty;
                var distance = Math.abs(dx * dx + dy * dy);
                if (isNaN$1(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    var mdx = x - point.x;
                    var mdy = y - point.y;
                    var mx = (+normals[1].y * mdx - normals[1].x * mdy) / detA;
                    var my = (-normals[0].y * mdx + normals[0].x * mdy) / detA;
                    result.scale.set(1 + mx / lengths[0], 1 + my / lengths[1]);
                }
            }
        };
        ESnapper.prototype.calcScaleSnappedXY = function (transform, pointO, pointX, pointY, normals, lengths, result) {
            this.calcScaleSnapped2D(transform, pointO, normals, lengths, result);
            this.calcScaleSnappedX(transform, pointY, normals[0], lengths[0], result);
            this.calcScaleSnappedY(transform, pointX, normals[1], lengths[1], result);
        };
        ESnapper.prototype.toScaleSnapped = function (transform, anchor, keepRatio, scale) {
            if (this._isEnabled) {
                var points = this._points;
                var normals = this._normals;
                var lengths = this._lengths;
                var work = this._workScaleResult;
                work.distance = NaN;
                work.scale.set(scale.x, scale.y);
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        this.calcScaleSnappedXY(transform, points[0], points[1], points[3], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        this.calcScaleSnappedY(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[1], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        this.calcScaleSnappedXY(transform, points[1], points[0], points[2], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        this.calcScaleSnappedX(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        this.calcScaleSnappedX(transform, points[1], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[2], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        this.calcScaleSnappedXY(transform, points[3], points[2], points[0], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        this.calcScaleSnappedY(transform, points[2], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        this.calcScaleSnappedXY(transform, points[2], points[3], points[1], normals, lengths, work);
                        break;
                }
                if (!isNaN$1(work.distance)) {
                    scale.copyFrom(work.scale);
                    if (keepRatio) {
                        switch (anchor) {
                            case ESnapperModifierAnchor.TOP_LEFT:
                            case ESnapperModifierAnchor.TOP_RIGHT:
                            case ESnapperModifierAnchor.BOTTOM_LEFT:
                            case ESnapperModifierAnchor.BOTTOM_RIGHT:
                                scale.x = scale.y = Math.max(scale.x, scale.y);
                                break;
                            case ESnapperModifierAnchor.TOP_CENTER:
                            case ESnapperModifierAnchor.BOTTOM_CENTER:
                                scale.x = scale.y;
                                break;
                            case ESnapperModifierAnchor.MIDDLE_LEFT:
                            case ESnapperModifierAnchor.MIDDLE_RIGHT:
                                scale.y = scale.x;
                                break;
                            case ESnapperModifierAnchor.NONE:
                                break;
                        }
                    }
                    return true;
                }
            }
            return false;
        };
        ESnapper.prototype.reset = function () {
            this.enable = this._isEnabledDefault;
            this.target.reset();
            this.grid.reset();
        };
        ESnapper.prototype.serialize = function () {
            return [this._isEnabled ? 1 : 0, this.target.serialize(), this.grid.serialize()];
        };
        ESnapper.prototype.deserialize = function (serialized) {
            this.enable = !!serialized[0];
            this.target.deserialize(serialized[1]);
            this.grid.deserialize(serialized[2]);
        };
        return ESnapper;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicAtlasItemText = /** @class */ (function (_super) {
        __extends(DynamicAtlasItemText, _super);
        function DynamicAtlasItemText(id, text, baseTexture) {
            var _this = _super.call(this, id, text.width, text.height, 0, baseTexture) || this;
            _this._text = text;
            return _this;
        }
        DynamicAtlasItemText.prototype.render = function (context) {
            var frame = this.frame;
            context.drawImage(this._text.canvas, frame.x, frame.y, frame.width, frame.height);
        };
        return DynamicAtlasItemText;
    }(DynamicAtlasItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlasFont = /** @class */ (function () {
        function DynamicFontAtlasFont(fontId, size, color, padding) {
            this.id = fontId;
            this.size = size;
            this.color = pixi_js.utils.hex2string(color);
            this.height = size + padding * 2;
            var metrics = UtilFont.measure(fontId);
            this.ascent = metrics.ascent;
            this.descent = metrics.descent;
        }
        return DynamicFontAtlasFont;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DynamicFontAtlas = /** @class */ (function () {
        function DynamicFontAtlas(fontId, fontSize, fontColor, resolution) {
            this._id = fontId;
            this._canvas = document.createElement("canvas");
            this._context = null;
            var padding = this.toPadding(fontSize);
            this._padding = padding;
            this._font = new DynamicFontAtlasFont(fontId, fontSize, fontColor, padding);
            this._characters = {};
            this._length = 0;
            this._unrefCount = 0;
            this._width = 1;
            this._height = 1;
            this._revision = 0;
            this._revisionUpdated = 0;
            this._texture = pixi_js.Texture.from(this._canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution: resolution,
                scaleMode: pixi_js.SCALE_MODES.NEAREST
            });
            var characters = this._characters;
            this.add_(" ", " ", characters, DynamicFontAtlasCharacterType.SPACE_R);
            this.add_("\t", "    ", characters, DynamicFontAtlasCharacterType.SPACE_R);
            this.add_("...", "...", characters, DynamicFontAtlasCharacterType.LETTER_RNB);
            for (var i = 0, imax = ASCII_CHARACTERS.length; i < imax; ++i) {
                var char = ASCII_CHARACTERS[i];
                this.add_(char, char, characters, DynamicFontAtlasCharacterType.LETTER_RNB);
            }
        }
        DynamicFontAtlas.prototype.toPadding = function (fontSize) {
            return Math.max(3, Math.ceil(fontSize * 0.2));
        };
        Object.defineProperty(DynamicFontAtlas.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "font", {
            get: function () {
                return this._font;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "canvas", {
            get: function () {
                return this._canvas;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "characters", {
            get: function () {
                return this._characters;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicFontAtlas.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: false,
            configurable: true
        });
        DynamicFontAtlas.prototype.add_ = function (id, character, characters, type) {
            if (!this.isIgnored(character)) {
                var data = characters[id];
                if (data != null) {
                    if (!(data.type & DynamicFontAtlasCharacterType.RESERVED)) {
                        if (data.ref === 0) {
                            this._unrefCount -= 1;
                        }
                        data.ref += 1;
                    }
                }
                else {
                    var advance = this.getAdvance(character);
                    var padding = this._padding;
                    var width = Math.ceil(padding + advance + padding);
                    var height = this.font.height;
                    characters[id] = new DynamicFontAtlasCharacter(character, advance, width, height, type);
                    this._length += 1;
                    this._revision += 1;
                }
            }
        };
        DynamicFontAtlas.prototype.isIgnored = function (character) {
            switch (character) {
                case "\n": // Line feed
                    return true;
                case "\r": // Carriage return
                    return true;
                case "\v": // Vertical tab
                    return true;
                case "\f": // Form feed
                    return true;
                case "\u0085": // Next line
                    return true;
            }
            return false;
        };
        DynamicFontAtlas.prototype.remove_ = function (id, characters) {
            var data = characters[id];
            if (data != null) {
                if (!(data.type & DynamicFontAtlasCharacterType.RESERVED) && 0 < data.ref) {
                    data.ref -= 1;
                    if (data.ref === 0) {
                        this._unrefCount += 1;
                    }
                }
            }
        };
        DynamicFontAtlas.prototype.cleanup_ = function () {
            if (this._length >> 1 <= this._unrefCount) {
                var characters = this._characters;
                for (var character in characters) {
                    if (characters[character].ref <= 0) {
                        delete characters[character];
                    }
                }
                this._length -= this._unrefCount;
                this._revision += 1;
                this._unrefCount = 0;
            }
        };
        DynamicFontAtlas.prototype.add = function (targets, type) {
            if (type === void 0) { type = DynamicFontAtlasCharacterType.LETTER; }
            var characters = this._characters;
            var iterator = UtilCharacterIterator.from(targets);
            while (iterator.hasNext()) {
                var character = iterator.next();
                this.add_(character, character, characters, type);
            }
        };
        DynamicFontAtlas.prototype.remove = function (targets) {
            var characters = this._characters;
            var iterator = UtilCharacterIterator.from(targets);
            while (iterator.hasNext()) {
                this.remove_(iterator.next(), characters);
            }
        };
        DynamicFontAtlas.prototype.get = function (id) {
            return this._characters[id];
        };
        DynamicFontAtlas.prototype.getAdvance = function (target) {
            var context = this.getContext();
            if (context != null) {
                return context.measureText(target).width;
            }
            return 0;
        };
        DynamicFontAtlas.prototype.getContext = function () {
            var context = this._context;
            if (context == null) {
                var canvas = this._canvas;
                if (canvas != null) {
                    context = this._context = canvas.getContext("2d", { alpha: true });
                    if (context == null) {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
            var font = this._font;
            if (context.font !== font.id) {
                context.font = font.id;
                font.id = context.font;
                context.textAlign = "left";
                context.textBaseline = "alphabetic";
                context.lineWidth = 0;
                context.lineCap = "round";
                context.lineJoin = "miter";
                context.miterLimit = 0;
                context.fillStyle = font.color;
                context.strokeStyle = "#0000ff";
            }
            return context;
        };
        DynamicFontAtlas.prototype.update = function () {
            this.cleanup_();
            if (this._revisionUpdated < this._revision) {
                this._revisionUpdated = this._revision;
                var canvas = this._canvas;
                if (canvas != null) {
                    var font = this._font;
                    var fontHeight = font.height;
                    var characters = this._characters;
                    var width = (this._width = this.toPowerOf2(Math.ceil(Math.sqrt(this._length)) * fontHeight));
                    var offsetX = this._padding;
                    var offsetY = Math.round((fontHeight - (font.ascent + font.descent)) * 0.5 + font.ascent);
                    var x = 0;
                    var y = 0;
                    for (var key in characters) {
                        var character = characters[key];
                        if (width <= x + character.width) {
                            x = 0;
                            y += fontHeight;
                        }
                        character.x = x;
                        character.y = y;
                        character.origin.x = x + offsetX;
                        character.origin.y = y + offsetY;
                        x += character.width;
                    }
                    var height = (this._height = y + fontHeight);
                    // Make a input canvas
                    // Here, we need to reset the context because
                    // context settings will be lost when we set the width/height.
                    var baseTexture = this._texture.baseTexture;
                    var resolution = baseTexture.resolution;
                    var realWidth = Math.ceil(width * resolution);
                    var realHeight = Math.ceil(height * resolution);
                    canvas.width = realWidth;
                    canvas.height = realHeight;
                    var context = this.getContext();
                    if (context != null) {
                        context.save();
                        context.scale(resolution, resolution);
                        context.clearRect(0, 0, width, height);
                        for (var key in characters) {
                            var character = characters[key];
                            context.fillText(key, character.origin.x, character.origin.y);
                        }
                        context.restore();
                    }
                    baseTexture.setRealSize(realWidth, realHeight);
                    return true;
                }
            }
            return false;
        };
        DynamicFontAtlas.prototype.getRevision = function () {
            return this._revision;
        };
        DynamicFontAtlas.prototype.getRevisionUpdate = function () {
            return this._revisionUpdated;
        };
        Object.defineProperty(DynamicFontAtlas.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: false,
            configurable: true
        });
        DynamicFontAtlas.prototype.destroy = function () {
            var canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            var characters = this._characters;
            for (var character in characters) {
                delete characters[character];
            }
        };
        DynamicFontAtlas.prototype.toPowerOf2 = function (size) {
            var result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        };
        return DynamicFontAtlas;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var update = function (atlas) {
        atlas.update();
    };
    var updateAll = function (colorToAltas) {
        colorToAltas.forEach(update);
    };
    var destroy = function (atlas) {
        atlas.update();
    };
    var destroyAll = function (colorToAltas) {
        colorToAltas.forEach(destroy);
    };
    var DynamicFontAtlases = /** @class */ (function () {
        function DynamicFontAtlases(layer) {
            var _this = this;
            this._atlases = new Map();
            this._resolution = layer.renderer.resolution;
            layer.renderer.on("prerender", function () {
                _this.update();
            });
        }
        DynamicFontAtlases.prototype.add = function (fontId, fontSize, fontColor, targets) {
            var atlases = this._atlases;
            var colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                colorToAtlas = new Map();
                atlases.set(fontId, colorToAtlas);
            }
            var atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                atlas = new DynamicFontAtlas(fontId, fontSize, fontColor, this._resolution);
                colorToAtlas.set(fontColor, atlas);
            }
            atlas.add(targets);
        };
        DynamicFontAtlases.prototype.remove = function (fontId, fontColor, targets) {
            var colorToAtlas = this._atlases.get(fontId);
            if (colorToAtlas != null) {
                var atlas = colorToAtlas.get(fontColor);
                if (atlas != null) {
                    atlas.remove(targets);
                }
            }
        };
        DynamicFontAtlases.prototype.get = function (fontId, fontColor) {
            var atlases = this._atlases;
            var colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                return null;
            }
            var atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                return null;
            }
            return atlas;
        };
        DynamicFontAtlases.prototype.update = function () {
            this._atlases.forEach(updateAll);
        };
        DynamicFontAtlases.prototype.destroy = function () {
            var atlases = this._atlases;
            atlases.forEach(destroyAll);
            atlases.clear();
        };
        return DynamicFontAtlases;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isObject = function (target) {
        if (typeof target === "object" &&
            Object.prototype.toString.call(target) === "[object Object]") {
            var prototype = Object.getPrototypeOf(target);
            return prototype == null || prototype === Object.prototype;
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var Lazy = /** @class */ (function () {
        function Lazy(newInstance, options, base) {
            var _this = this;
            this.instance = null;
            this.newInstance = newInstance;
            this.options = options;
            if (base != null) {
                if (base.state.isActive) {
                    setTimeout(function () {
                        _this.get();
                    }, 0);
                }
                base.on("active", function () {
                    _this.get();
                });
            }
        }
        Lazy.prototype.get = function () {
            var result = this.instance;
            if (result == null) {
                result = new this.newInstance(this.options);
                this.instance = result;
            }
            return result;
        };
        return Lazy;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Returns a ceiling index of the given value.
     * The array must be sorted in an ascending order.
     *
     * @param array an array sorted in an ascending order
     * @param value a value to be searched
     * @returns a ceiling index of the given value
     */
    var toCeilingIndex = function (array, value, size, offset) {
        var i0 = 0;
        var i1 = Math.floor(array.length / size) - 1;
        while (i0 <= i1) {
            var i2 = i0 + ((i1 - i0) >> 1);
            var v2 = array[i2 * size + offset];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return Math.max(i0, i1);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toClonedArray = function (target) {
        var result = [];
        for (var i = 0, imax = target.length; i < imax; ++i) {
            result[i] = target[i];
        }
        return result;
    };
    var toClonedObject = function (target) {
        var result = {};
        for (var key in target) {
            if (Object.hasOwnProperty.call(target, key)) {
                result[key] = toCloned(target[key]);
            }
        }
        return result;
    };
    var toCloned = function (target) {
        if (isArray(target)) {
            return toClonedArray(target);
        }
        else if (isObject(target)) {
            return toClonedObject(target);
        }
        return target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLabel$1 = function (target) {
        if (target != null) {
            if (isString(target)) {
                return target;
            }
            else if (isNumber(target)) {
                return String(target);
            }
            else if ("name" in target) {
                return target.name;
            }
            else if ("label" in target) {
                return target.label;
            }
            else if ("id" in target) {
                return target.id;
            }
        }
        return "";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toMerged = function (one, other) {
        if (one != null) {
            var o = toCloned(one);
            if (other != null) {
                for (var key in other) {
                    if (Object.prototype.hasOwnProperty.call(other, key)) {
                        var otherValue = other[key];
                        if (isObject(otherValue)) {
                            if (Object.prototype.hasOwnProperty.call(o, key)) {
                                var oneValue = o[key];
                                if (isObject(oneValue)) {
                                    toMerged(oneValue, otherValue);
                                }
                            }
                            else {
                                o[key] = toCloned(otherValue);
                            }
                        }
                        else {
                            if (!Object.prototype.hasOwnProperty.call(o, key)) {
                                o[key] = otherValue;
                            }
                        }
                    }
                }
            }
            return o;
        }
        else if (other != null) {
            return toCloned(other);
        }
        else {
            return {};
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toString = function (value) {
        return value != null ? String(value) : "";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toSvgTexture = function (svg, resolution) {
        return pixi_js.Texture.from(toSvgUrl(svg), {
            resolution: resolution
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilSvgAtlasBuilder = /** @class */ (function () {
        function UtilSvgAtlasBuilder(width, ratio, margin) {
            this._width = width;
            this._ratio = ratio;
            this._margin = margin;
            this._frames = {};
            this._svg = "";
            this._nextX = 0;
            this._nextY = 0;
            this._height = 0;
        }
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "ratio", {
            get: function () {
                return this._ratio;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "margin", {
            get: function () {
                return this._margin;
            },
            enumerable: false,
            configurable: true
        });
        UtilSvgAtlasBuilder.prototype.add = function (name, width, height, path) {
            var frames = this._frames;
            if (!(name in frames)) {
                // Position
                var margin = this._margin;
                var x = this._nextX;
                var y = this._nextY;
                if (this._width <= x + width) {
                    x = 0;
                    y = this._nextY + this._height + margin;
                    this._height = height;
                    this._nextY = y;
                }
                else {
                    this._height = Math.max(this._height, height);
                }
                this._nextX = x + width + margin;
                // Frame
                frames[name] = new pixi_js.Rectangle(x, y, width, height);
                // Svg
                var ratio = this._ratio;
                this._svg += "<g transform=\"translate(".concat(x * ratio, ",").concat(y * ratio, ")\">").concat(path, "</g>");
                return true;
            }
            return false;
        };
        UtilSvgAtlasBuilder.prototype.has = function (name) {
            return name in this._frames;
        };
        Object.defineProperty(UtilSvgAtlasBuilder.prototype, "mappings", {
            get: function () {
                return this.build();
            },
            enumerable: false,
            configurable: true
        });
        UtilSvgAtlasBuilder.prototype.build = function (options) {
            var _a, _b, _c;
            var built = this._built;
            if (built == null || (options === null || options === void 0 ? void 0 : options.force)) {
                var resolution = (_b = (_a = options === null || options === void 0 ? void 0 : options.resolution) !== null && _a !== void 0 ? _a : window.devicePixelRatio) !== null && _b !== void 0 ? _b : 1;
                var width = this._width;
                var height = Math.pow(2, Math.ceil(Math.log(this._nextY + this._height) / Math.LN2));
                var realWidth = width * resolution;
                var realHeight = height * resolution;
                var ratio = this._ratio;
                var attrWidth = "width=\"".concat(realWidth, "\"");
                var attrHeight = "height=\"".concat(realHeight, "\"");
                var attrViewBox = "viewBox=\"0 0 ".concat(width * ratio, " ").concat(height * ratio, "\"");
                var attrXmlns = "xmlns=\"http://www.w3.org/2000/svg\"";
                var url = toSvgUrl("<svg ".concat(attrWidth, " ").concat(attrHeight, " ").concat(attrViewBox, " ").concat(attrXmlns, ">").concat(this._svg, "</svg>"));
                var scaleMode = (_c = options === null || options === void 0 ? void 0 : options.scaling) !== null && _c !== void 0 ? _c : pixi_js.SCALE_MODES.NEAREST;
                var baseTexture = pixi_js.BaseTexture.from(url, {
                    resolution: resolution,
                    scaleMode: scaleMode
                });
                var frames_1 = this._frames;
                built = this._built = {};
                for (var name_1 in frames_1) {
                    built[name_1] = new pixi_js.Texture(baseTexture, frames_1[name_1]);
                }
            }
            return built;
        };
        return UtilSvgAtlasBuilder;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilExtractor = /** @class */ (function () {
        function UtilExtractor() {
        }
        UtilExtractor.toTexture = function (target, resolution, clear, skipUpdateTransform) {
            var scale = target.transform.scale;
            var result = pixi_js.RenderTexture.create({
                width: target.width * scale.x,
                height: target.height * scale.y,
                scaleMode: pixi_js.SCALE_MODES.LINEAR,
                resolution: resolution
            });
            var matrix = new pixi_js.Matrix(undefined, undefined, undefined, undefined, -target.position.x, -target.position.y);
            var layer = DApplications.getLayer(target);
            if (layer) {
                layer.renderer.render(target, result, clear, matrix, skipUpdateTransform);
            }
            return result;
        };
        UtilExtractor.toPixels = function (renderTexture, renderer) {
            var resolution = renderTexture.resolution;
            var frame = renderTexture.frame;
            var width = Math.floor(frame.width * resolution);
            var height = Math.floor(frame.height * resolution);
            var pixels = new Uint8Array(4 * width * height);
            renderer.renderTexture.bind(renderTexture);
            var gl = renderer.gl;
            gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            return {
                width: width,
                height: height,
                array: pixels
            };
        };
        UtilExtractor.toCanvas = function (pixels, scale, ignorePremutipliedAlpha) {
            var width = pixels.width;
            var height = pixels.height;
            var array = pixels.array;
            var canvasRenderTarget = new pixi_js.utils.CanvasRenderTarget(width, height, 1);
            var imageData = canvasRenderTarget.context.getImageData(0, 0, width, height);
            if (ignorePremutipliedAlpha) {
                imageData.data.set(array);
            }
            else {
                pixi_js.Extract.arrayPostDivide(array, imageData.data);
            }
            canvasRenderTarget.context.putImageData(imageData, 0, 0);
            // Scale down
            if (scale != null && scale !== 1) {
                canvasRenderTarget.context.scale(scale, scale);
                canvasRenderTarget.context.drawImage(canvasRenderTarget.canvas, 0, 0);
                var scaledWidth = Math.floor(width * scale);
                var scaledHeight = Math.floor(height * scale);
                var scaledImageData = canvasRenderTarget.context.getImageData(0, 0, scaledWidth, scaledHeight);
                canvasRenderTarget.resize(scaledWidth, scaledHeight);
                canvasRenderTarget.context.putImageData(scaledImageData, 0, 0);
            }
            return canvasRenderTarget;
        };
        UtilExtractor.toBase64 = function (canvas, format, quality) {
            return canvas.toDataURL(format, quality);
        };
        return UtilExtractor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilFileDownloader = /** @class */ (function () {
        function UtilFileDownloader() {
        }
        /**
         * Downloads a file of the given name and URL.
         *
         * @param filename a file name
         * @param url a file URL
         */
        UtilFileDownloader.downloadUrl = function (filename, url) {
            var a = document.createElement("a");
            if ("download" in a) {
                a.href = url;
                a.setAttribute("download", filename);
                a.style.display = "none";
                document.body.appendChild(a);
                a.click();
                setTimeout(function () {
                    document.body.removeChild(a);
                }, 66);
            }
            else {
                if (!window.open(url)) {
                    location.href = url;
                }
            }
        };
        /**
         * Downloads a file of the given name with the given contents.
         *
         * @param filename a file name
         * @param contents file contents
         * @param insertBom false to stop the BOM insertion
         */
        UtilFileDownloader.download = function (filename, contents, insertBom) {
            var blob = new Blob(insertBom !== false ? ["\ufeff", contents] : [contents], {
                type: "text/plain"
            });
            var navigator = window.navigator;
            if ("msSaveBlob" in navigator) {
                // IE10 and 11
                navigator.msSaveBlob(blob, filename);
            }
            else {
                this.downloadUrl(filename, URL.createObjectURL(blob));
            }
        };
        return UtilFileDownloader;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toResolution = function (options) {
        var _a;
        var target = options.target;
        var resolution = options.resolution;
        if (resolution != null) {
            if (isNumber(resolution)) {
                return resolution;
            }
            else {
                var scale = target.transform.scale;
                var size = Math.max(target.width * scale.x, target.height * scale.y);
                return Math.min(1, resolution.size / size);
            }
        }
        else {
            return (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        }
    };
    var toScale = function (pixels, options) {
        var scale = options.scale;
        if (scale != null) {
            if (isNumber(scale)) {
                return scale;
            }
            else {
                var size = scale.size;
                return Math.min(1, size / pixels.width, size / pixels.height);
            }
        }
    };
    var toRenderer = function (options) {
        var renderer = options.renderer;
        if (renderer) {
            return renderer;
        }
        var application = options.application;
        if (application) {
            return application.getLayerBase().renderer;
        }
        var layer = options.layer || DApplications.getLayer(options.target);
        if (layer) {
            return layer.renderer;
        }
        throw new Error("No renderer / application / layer found.");
    };
    var UtilExtract = /** @class */ (function () {
        function UtilExtract() {
        }
        UtilExtract.texture = function (options) {
            var _a;
            var target = options.target;
            var resolution = toResolution(options);
            var skipUpdateTransform = (_a = options.transform) === null || _a === void 0 ? void 0 : _a.update;
            return UtilExtractor.toTexture(target, resolution, options.clear, skipUpdateTransform);
        };
        UtilExtract.pixels = function (options) {
            var renderer = toRenderer(options);
            var texture = this.texture(options);
            try {
                return UtilExtractor.toPixels(texture, renderer);
            }
            finally {
                if (texture) {
                    texture.destroy();
                }
            }
        };
        UtilExtract.canvas = function (options) {
            var _a, _b;
            var pixels = this.pixels(options);
            var ignorePremutipliedAlpha = (_b = (_a = options.alpha) === null || _a === void 0 ? void 0 : _a.premultiplied) === null || _b === void 0 ? void 0 : _b.ignore;
            var scale = toScale(pixels, options);
            return UtilExtractor.toCanvas(pixels, scale, ignorePremutipliedAlpha);
        };
        UtilExtract.base64 = function (options) {
            var canvas = this.canvas(options);
            try {
                return UtilExtractor.toBase64(canvas.canvas, options.format, options.quality);
            }
            finally {
                if (canvas) {
                    canvas.destroy();
                }
            }
        };
        UtilExtract.file = function (options) {
            UtilFileDownloader.downloadUrl(options.filename, this.base64(options));
        };
        return UtilExtract;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An output format.
     */
    var UtilFileAs = {
        TEXT: 0,
        DATA_URL: 1,
        BINARY_STRING: 2,
        ARRAY_BUTTER: 3,
        FILE: 4
    };
    /**
     * An utility class for opening files.
     */
    var UtilFileOpener = /** @class */ (function () {
        function UtilFileOpener(as, facade) {
            this._input = null;
            this._as = as;
            this._facade = facade;
        }
        UtilFileOpener.prototype.open = function () {
            var input = this.getOrCreateInput();
            if (input != null) {
                input.click();
            }
            else {
                this.onCancel();
            }
        };
        UtilFileOpener.prototype.getOrCreateInput = function () {
            var _this = this;
            if ("FileReader" in window && this._input == null) {
                var input_1 = document.createElement("input");
                this._input = input_1;
                input_1.setAttribute("type", "file");
                input_1.setAttribute("style", "display:none");
                input_1.addEventListener("change", function (e) {
                    _this.onInputChange(input_1);
                    input_1.value = "";
                    e.stopImmediatePropagation();
                    e.preventDefault();
                });
                document.body.appendChild(input_1);
            }
            return this._input;
        };
        UtilFileOpener.prototype.onInputChange = function (input) {
            var _this = this;
            var files = input.files;
            if (files != null && 0 < files.length) {
                var file_1 = files[0];
                if (this._as === UtilFileAs.FILE) {
                    this.onOpen(file_1, file_1);
                }
                else {
                    var fileReader = new FileReader();
                    fileReader.onload = function (e) {
                        if (e.target != null) {
                            var target = e.target;
                            _this.onOpen(target.result, file_1);
                        }
                    };
                    fileReader.onabort = function (e) {
                        _this.onAboart(e);
                    };
                    switch (this._as) {
                        case UtilFileAs.TEXT:
                            fileReader.readAsText(file_1);
                            break;
                        case UtilFileAs.DATA_URL:
                            fileReader.readAsDataURL(file_1);
                            break;
                        case UtilFileAs.BINARY_STRING:
                            fileReader.readAsBinaryString(file_1);
                            break;
                        case UtilFileAs.ARRAY_BUTTER:
                            fileReader.readAsArrayBuffer(file_1);
                            break;
                        default:
                            fileReader.readAsText(file_1);
                            break;
                    }
                }
            }
            else {
                this.onCancel();
            }
        };
        UtilFileOpener.prototype.onOpen = function (result, file) {
            var facade = this._facade;
            facade.emit("open", result, file, facade);
        };
        UtilFileOpener.prototype.onAboart = function (e) {
            var facade = this._facade;
            facade.emit("abort", e, facade);
        };
        UtilFileOpener.prototype.onCancel = function () {
            var facade = this._facade;
            facade.emit("cancel", facade);
        };
        return UtilFileOpener;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilHsv = /** @class */ (function () {
        function UtilHsv() {
        }
        /**
         * Returns HSV colors.
         * Ranges of components are:
         *
         * * H: [0, 360)
         * * S: [0, 255]
         * * V: [0, 255]
         *
         * @param color a rgb color
         * @return an array of hsv components
         */
        UtilHsv.fromRgb = function (color) {
            var r = (color & 0xff0000) >> 16;
            var g = (color & 0x00ff00) >> 8;
            var b = (color & 0x0000ff) | 0;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var length = max - min;
            var h = 0;
            if (0 < length) {
                if (r === max) {
                    h = (60 * (g - b)) / length;
                }
                else if (g === max) {
                    h = (60 * (b - r)) / length + 120;
                }
                else if (b === max) {
                    h = (60 * (r - g)) / length + 240;
                }
                if (h < 0) {
                    h += 360;
                }
            }
            var s = (length / max) * 255;
            var v = max;
            return [h, s, v];
        };
        UtilHsv.toRgb = function (h, s, v) {
            var max = v;
            var min = v - (s / 255) * v;
            var length = max - min;
            var r = 0;
            var g = 0;
            var b = 0;
            if (h <= 60) {
                r = max;
                g = (h / 60) * length + min;
                b = min;
            }
            else if (h <= 120) {
                r = ((120 - h) / 60) * length + min;
                g = max;
                b = min;
            }
            else if (h <= 180) {
                r = min;
                g = max;
                b = ((h - 120) / 60) * length + min;
            }
            else if (h <= 240) {
                r = min;
                g = ((240 - h) / 60) * length + min;
                b = max;
            }
            else if (h <= 300) {
                r = ((h - 240) / 60) * length + min;
                g = min;
                b = max;
            }
            else {
                r = max;
                g = min;
                b = ((360 - h) / 60) * length + min;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            return (r << 16) | (g << 8) | b;
        };
        return UtilHsv;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilInputTextArea = /** @class */ (function (_super) {
        __extends(UtilInputTextArea, _super);
        function UtilInputTextArea() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UtilInputTextArea.prototype.onElementAttached = function (element, before, after) {
            element.addEventListener("keydown", this._onInputKeyDownBound);
            _super.prototype.onElementAttached.call(this, element, before, after);
        };
        UtilInputTextArea.prototype.onElementDetached = function (element, before, after) {
            element.removeEventListener("keydown", this._onInputKeyDownBound);
            _super.prototype.onElementDetached.call(this, element, before, after);
        };
        UtilInputTextArea.prototype.onInputKeyDown = function (e) {
            if (UtilKeyboardEvent.isOkKey(e)) {
                this._operation.onEnter();
            }
        };
        return UtilInputTextArea;
    }(UtilInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilName = /** @class */ (function () {
        function UtilName() {
        }
        UtilName.create = function (type) {
            var mapping = this._mapping;
            if (type in mapping) {
                return "".concat(type, " ").concat(++mapping[type]);
            }
            else {
                mapping[type] = 1;
                return "".concat(type, " 1");
            }
        };
        UtilName._mapping = {};
        return UtilName;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilRgba = /** @class */ (function () {
        function UtilRgba() {
        }
        UtilRgba.toCode = function (color, alpha) {
            var r = (color >> 16) & 0xff;
            var g = (color >> 8) & 0xff;
            var b = color & 0xff;
            return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(alpha, ")");
        };
        return UtilRgba;
    }());

    var UtilStateBlinker = /** @class */ (function () {
        function UtilStateBlinker(state, delay, interval) {
            var _this = this;
            this._targets = new Set();
            this._state = state;
            this._delay = delay;
            this._interval = interval;
            this._timeout = null;
            this._updateBound = function () {
                _this.update();
            };
        }
        UtilStateBlinker.prototype.start = function () {
            if (this._timeout == null) {
                this._timeout = window.setTimeout(this._updateBound, this._delay);
            }
            return this;
        };
        UtilStateBlinker.prototype.stop = function () {
            var timeout = this._timeout;
            if (timeout != null) {
                this._timeout = null;
                clearTimeout(timeout);
            }
            return this;
        };
        UtilStateBlinker.prototype.add = function (target) {
            this._targets.add(target);
            target.state.set(this._state, this.isOn(Date.now()));
            return this;
        };
        UtilStateBlinker.prototype.remove = function (target) {
            if (this._targets.delete(target)) {
                target.state.remove(this._state);
                return true;
            }
            return false;
        };
        UtilStateBlinker.prototype.contains = function (target) {
            return this._targets.has(target);
        };
        UtilStateBlinker.prototype.clear = function () {
            this._targets.clear();
            return this;
        };
        UtilStateBlinker.prototype.isOn = function (time) {
            return Math.floor(time / this._interval) % 2 === 0;
        };
        UtilStateBlinker.prototype.update = function () {
            var now = Date.now();
            var isOn = this.isOn(now);
            var state = this._state;
            this._targets.forEach(function (target) {
                target.state.set(state, isOn);
            });
            var interval = this._interval;
            this._timeout = window.setTimeout(this._updateBound, interval - (now % interval));
            return this;
        };
        return UtilStateBlinker;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var UtilTransition = /** @class */ (function () {
        function UtilTransition(options) {
            var _a;
            this._duration = (_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : 300;
            this._current = null;
            this._lastUpdate = 0;
            this._updateId = null;
        }
        UtilTransition.prototype.show = function (next, forcibly) {
            var _this = this;
            var updateId = this._updateId;
            if (updateId != null) {
                clearTimeout(updateId);
            }
            var current = this._current;
            if (next !== current) {
                var duration = this._duration;
                var lastUpdate = this._lastUpdate;
                var now = Date.now();
                var remaining = lastUpdate + duration - now;
                if (forcibly === true || remaining <= 0) {
                    this.update(now, next);
                }
                else {
                    this._updateId = window.setTimeout(function () {
                        _this.update(Date.now(), next);
                    }, remaining);
                }
            }
        };
        UtilTransition.prototype.update = function (now, next) {
            var current = this._current;
            if (current !== next) {
                this._lastUpdate = now;
                if (current != null) {
                    current.hide();
                }
                this._current = next;
                if (next != null) {
                    next.show();
                }
            }
        };
        UtilTransition.prototype.hide = function () {
            this.show(null);
        };
        return UtilTransition;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /*!
     * jQuery Mousewheel 3.1.13
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * See also https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
     * and https://github.com/openlayers/openlayers/blob/v5.2.0/src/ol/interaction/MouseWheelZoom.js#L51
     */
    var UtilWheelEvent = /** @class */ (function () {
        function UtilWheelEvent() {
            this._lowest = null;
            this._timestamp = 0;
            this._lineHeight = null;
            this._pageHeight = null;
        }
        UtilWheelEvent.prototype.getNames = function () {
            var result = this._names;
            if (result == null) {
                if ("onwheel" in document || 9 <= document.documentMode) {
                    result = ["wheel"];
                }
                else {
                    result = ["mousewheel", "DOMMouseScroll", "MozMousePixelScroll"];
                }
                this._names = result;
            }
            return result;
        };
        UtilWheelEvent.prototype.on = function (target, handler, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var names = this.getNames();
            for (var i = names.length - 1; 0 <= i; --i) {
                var name_1 = names[i];
                target.addEventListener(name_1, handler, useCapture);
            }
        };
        UtilWheelEvent.prototype.off = function (target, handler, useCapture) {
            if (useCapture === void 0) { useCapture = false; }
            var names = this.getNames();
            for (var i = names.length - 1; 0 <= i; --i) {
                var name_2 = names[i];
                target.removeEventListener(name_2, handler, useCapture);
            }
        };
        UtilWheelEvent.prototype.getLineHeight = function () {
            if (this._lineHeight == null) {
                var theme = DThemes.getInstance().get("DBase");
                this._lineHeight = theme.getLineHeight();
            }
            return this._lineHeight;
        };
        UtilWheelEvent.prototype.getPageHeight = function () {
            if (this._pageHeight == null) {
                this._pageHeight = this.getLineHeight() * 12;
            }
            return this._pageHeight;
        };
        UtilWheelEvent.prototype.normalize = function (e) {
            var deltaX = 0;
            var deltaY = 0;
            // Old school scrollwheel delta
            if ("detail" in e) {
                deltaY = e.detail * -1;
            }
            if ("wheelDelta" in e) {
                deltaY = e.wheelDelta;
            }
            if ("wheelDeltaY" in e) {
                deltaY = e.wheelDeltaY;
            }
            if ("wheelDeltaX" in e) {
                deltaX = e.wheelDeltaX * -1;
            }
            // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
            if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
                deltaX = deltaY * -1;
                deltaY = 0;
            }
            // New school wheel delta (wheel event)
            if ("deltaY" in e) {
                deltaY = e.deltaY * -1;
            }
            if ("deltaX" in e) {
                deltaX = e.deltaX;
            }
            // No change actually happened, no reason to go any further
            if (deltaY === 0 && deltaX === 0) {
                return null;
            }
            // Store lowest absolute delta to normalize the delta values
            var delta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
            // Reset the this._lowest to better handle multiple device types
            // that give different a different lowestDelta
            // Ex: trackpad = 3 and mouse wheel = 120
            var now = Date.now();
            if (this._timestamp + 200 <= now) {
                this._lowest = null;
            }
            this._timestamp = now;
            //
            var shouldAdjust = e.type === "mousewheel" && delta % 120 === 0;
            if (!this._lowest || delta < this._lowest) {
                this._lowest = delta;
                // Adjust older deltas if necessary
                if (shouldAdjust) {
                    this._lowest /= 40;
                }
            }
            // Adjust older deltas if necessary
            if (shouldAdjust) {
                // Divide all the things by 40!
                delta /= 40;
                deltaX /= 40;
                deltaY /= 40;
            }
            // Get a whole, normalized value for the deltas
            var lowest = this._lowest;
            delta = Math.floor(delta / lowest);
            deltaX = Math[1 <= deltaX ? "floor" : "ceil"](deltaX / lowest);
            deltaY = Math[1 <= deltaY ? "floor" : "ceil"](deltaY / lowest);
            // Mode
            var mode = e.deltaMode || 0;
            if (mode !== 0) {
                var scale = mode === 1 ? this.getLineHeight() : this.getPageHeight();
                delta *= scale;
                deltaX *= scale;
                deltaY *= scale;
            }
            return {
                mode: mode,
                delta: delta,
                deltaX: deltaX,
                deltaY: deltaY,
                lowest: lowest
            };
        };
        UtilWheelEvent.getInstance = function () {
            if (this.INSTANCE == null) {
                this.INSTANCE = new UtilWheelEvent();
            }
            return this.INSTANCE;
        };
        return UtilWheelEvent;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationEmpty = /** @class */ (function (_super) {
        __extends(DAnimationEmpty, _super);
        function DAnimationEmpty(options) {
            var _this = this;
            var _a;
            _this = _super.call(this) || this;
            _this._target = (_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : null;
            _this._reverse = false;
            _this._isStarted = false;
            _this._onTime = options === null || options === void 0 ? void 0 : options.onTime;
            _this._onStart = options === null || options === void 0 ? void 0 : options.onStart;
            _this._onEnd = options === null || options === void 0 ? void 0 : options.onEnd;
            return _this;
        }
        Object.defineProperty(DAnimationEmpty.prototype, "target", {
            get: function () {
                return this._target;
            },
            set: function (target) {
                this._target = target;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DAnimationEmpty.prototype, "duration", {
            get: function () {
                return 0;
            },
            set: function (duration) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        DAnimationEmpty.prototype.start = function (reverse) {
            if (reverse === void 0) { reverse = false; }
            this.stop();
            this._isStarted = true;
            this._reverse = reverse;
            // onStart
            this.onStart(reverse);
            if (!this._isStarted) {
                return;
            }
            // onTime
            this.onTime(reverse ? 1 : 0, reverse, 0);
            if (!this._isStarted) {
                return;
            }
            this.onTime(reverse ? 0 : 1, reverse, 0);
            if (this._isStarted) {
                return;
            }
            // OnEnd
            this.onEnd(reverse);
        };
        DAnimationEmpty.prototype.onStart = function (isReverse) {
            var onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        };
        DAnimationEmpty.prototype.onTime = function (time, isReverse, elapsedTime) {
            var onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        };
        DAnimationEmpty.prototype.onEnd = function (isReverse) {
            var onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        };
        DAnimationEmpty.prototype.isStarted = function () {
            return this._isStarted;
        };
        DAnimationEmpty.prototype.isReverse = function () {
            return this._reverse;
        };
        DAnimationEmpty.prototype.stop = function () {
            this._isStarted = false;
        };
        DAnimationEmpty.prototype.end = function () {
            var isStarted = this._isStarted;
            if (isStarted) {
                this._isStarted = false;
                // OnTime
                var reverse = this._reverse;
                var time = reverse ? 0 : 1;
                this.onTime(time, reverse, 0);
                // OnEnd
                this.onEnd(reverse);
            }
        };
        return DAnimationEmpty;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DAnimationFadeIn = /** @class */ (function (_super) {
        __extends(DAnimationFadeIn, _super);
        function DAnimationFadeIn(options) {
            var _this = this;
            var _a, _b;
            _this = _super.call(this, options) || this;
            _this._storedX = 0;
            _this._storedY = 0;
            _this._storedAlpha = 0;
            _this._storedTime = 0;
            _this._storedTarget = null;
            _this._layer = null;
            // Shifts
            var shift = options === null || options === void 0 ? void 0 : options.shift;
            _this._shiftX = (_a = shift === null || shift === void 0 ? void 0 : shift.x) !== null && _a !== void 0 ? _a : 0;
            _this._shiftY = (_b = shift === null || shift === void 0 ? void 0 : shift.y) !== null && _b !== void 0 ? _b : 15;
            _this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            _this._onPostrenderBound = function () {
                _this.onPostrender();
            };
            return _this;
        }
        DAnimationFadeIn.prototype.stop = function () {
            this._storedTime = 0;
            this.removeEventListeners();
            _super.prototype.stop.call(this);
        };
        DAnimationFadeIn.prototype.addEventListeners = function (target) {
            var layer = DApplications.getLayer(target);
            if (layer) {
                this._layer = layer;
                var renderer = layer.renderer;
                renderer.on("prerender", this._onPrerenderBound);
                renderer.on("postrender", this._onPostrenderBound);
            }
        };
        DAnimationFadeIn.prototype.removeEventListeners = function () {
            var layer = this._layer;
            if (layer) {
                this._layer = null;
                var renderer = layer.renderer;
                renderer.off("prerender", this._onPrerenderBound);
                renderer.off("postrender", this._onPostrenderBound);
            }
        };
        DAnimationFadeIn.prototype.onStart = function (isReverse) {
            var target = (this._storedTarget = this._target);
            if (target != null) {
                this._storedTime = 0;
                this.removeEventListeners();
                this.addEventListeners(target);
                if (!isReverse) {
                    target.visible = true;
                }
                _super.prototype.onStart.call(this, isReverse);
            }
        };
        DAnimationFadeIn.prototype.onTime = function (time, isReverse, elapsedTime) {
            var target = this._storedTarget;
            if (target != null) {
                var layer = this._layer;
                if (layer) {
                    this._storedTime = time;
                    _super.prototype.onTime.call(this, time, isReverse, elapsedTime);
                    layer.update();
                }
                else {
                    this._storedTime = time;
                    _super.prototype.onTime.call(this, time, isReverse, elapsedTime);
                }
            }
        };
        DAnimationFadeIn.prototype.onEnd = function (isReverse) {
            var target = this._storedTarget;
            if (target != null) {
                this.removeEventListeners();
                if (isReverse) {
                    target.visible = false;
                }
                _super.prototype.onEnd.call(this, isReverse);
            }
        };
        DAnimationFadeIn.prototype.onPrerender = function () {
            var target = this._storedTarget;
            if (target != null) {
                var storedTime = this._storedTime;
                // Position
                var position = target.unsafe.position;
                this._storedX = position.x;
                this._storedY = position.y;
                position.set(position.x - this._shiftX * (1 - storedTime), position.y - this._shiftY * (1 - storedTime));
                // Alpha
                this._storedAlpha = target.alpha;
                target.alpha = storedTime;
            }
        };
        DAnimationFadeIn.prototype.onPostrender = function () {
            var target = this._storedTarget;
            if (target != null) {
                // Position
                var position = target.unsafe.position;
                position.set(this._storedX, this._storedY);
                // Alpha
                target.alpha = this._storedAlpha;
            }
        };
        return DAnimationFadeIn;
    }(DAnimationBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplicationPadding = /** @class */ (function () {
        function DApplicationPadding(padding) {
            var _a, _b, _c, _d;
            if (isNumber(padding)) {
                this.top = padding;
                this.right = padding;
                this.bottom = padding;
                this.left = padding;
            }
            else if (padding != null) {
                this.top = (_a = padding.top) !== null && _a !== void 0 ? _a : 6;
                this.right = (_b = padding.right) !== null && _b !== void 0 ? _b : 6;
                this.bottom = (_c = padding.bottom) !== null && _c !== void 0 ? _c : 6;
                this.left = (_d = padding.left) !== null && _d !== void 0 ? _d : 6;
            }
            else {
                this.top = 6;
                this.right = 6;
                this.bottom = 6;
                this.left = 6;
            }
        }
        DApplicationPadding.prototype.getTheme = function () {
            throw new Error("Not supported");
        };
        DApplicationPadding.prototype.setTheme = function (theme) {
            throw new Error("Not supported");
        };
        DApplicationPadding.prototype.getTop = function () {
            return this.left;
        };
        DApplicationPadding.prototype.getRight = function () {
            return this.right;
        };
        DApplicationPadding.prototype.getBottom = function () {
            return this.bottom;
        };
        DApplicationPadding.prototype.getLeft = function () {
            return this.left;
        };
        DApplicationPadding.prototype.set = function (top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
        };
        return DApplicationPadding;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * DApplicationLayer options
     */
    var DApplicationLayerOptions = /** @class */ (function () {
        function DApplicationLayerOptions(options) {
            var _a;
            // Root
            var root = options.root;
            this._root = root;
            // Overlay mode or not
            this._overlay = options.overlay;
            // Padding
            this._padding = new DApplicationPadding(options === null || options === void 0 ? void 0 : options.padding);
            // Width & height
            var width = 100;
            var height = 100;
            if (options) {
                if (options.width != null) {
                    width = options.width;
                    if (options.height != null) {
                        height = options.height;
                    }
                    else {
                        height = root.getBoundingClientRect().height;
                    }
                }
                else if (options.height != null) {
                    width = root.getBoundingClientRect().width;
                    height = options.height;
                }
                else {
                    var bbox = root.getBoundingClientRect();
                    width = bbox.width;
                    height = bbox.height;
                }
            }
            else {
                var bbox = root.getBoundingClientRect();
                width = bbox.width;
                height = bbox.height;
            }
            // Background color
            var background = options === null || options === void 0 ? void 0 : options.background;
            var backgroundColor = 0;
            var transparent = true;
            if (background != null) {
                var color = background.color;
                if (color != null) {
                    backgroundColor = color;
                    transparent = false;
                }
            }
            // Resolution
            var resolution = options.resolution;
            // Antialias
            var antialias = (_a = options === null || options === void 0 ? void 0 : options.antialias) !== null && _a !== void 0 ? _a : false;
            // Pixi
            this._pixi = {
                width: width,
                height: height,
                autoStart: false,
                backgroundColor: backgroundColor,
                transparent: transparent,
                resolution: resolution,
                antialias: antialias
            };
        }
        /**
         * Returns a root element.
         * `HTMLCanvasElement` and other DOM elements are created in this element.
         * The default root element is `document.body`.
         */
        DApplicationLayerOptions.prototype.getRootElement = function () {
            return this._root;
        };
        /**
         * Sets a root element and updates the canvas width and height
         * if `updateWidthAndHeight` is not false.
         *
         * @param root new root element
         * @param updateWidthAndHeight false to preserve the canvas width / height
         */
        DApplicationLayerOptions.prototype.setRootElement = function (root, updateWidthAndHeight) {
            if (this._root !== root) {
                this._root = root;
                if (updateWidthAndHeight !== false) {
                    var bbox = root.getBoundingClientRect();
                    var pixi = this._pixi;
                    pixi.width = bbox.width;
                    pixi.height = bbox.height;
                }
            }
            return this;
        };
        /**
         * Returns a canvas width.
         */
        DApplicationLayerOptions.prototype.getWidth = function () {
            return this._pixi.width;
        };
        /**
         * Sets a canvas width.
         *
         * @param width new canvas width
         */
        DApplicationLayerOptions.prototype.setWidth = function (width) {
            this._pixi.width = width;
            return this;
        };
        /**
         * Returns a canvas height.
         */
        DApplicationLayerOptions.prototype.getHeight = function () {
            return this._pixi.height;
        };
        /**
         * Sets a canvas height.
         *
         * @param height new canvas height
         */
        DApplicationLayerOptions.prototype.setHeight = function (height) {
            this._pixi.height = height;
            return this;
        };
        /**
         * Returns padding sizes.
         * The default padding size is 6.
         */
        DApplicationLayerOptions.prototype.getPadding = function () {
            return this._padding;
        };
        /**
         * Sets padding sizes.
         *
         * @param left new left padding
         * @param top new top padding
         * @param right new right padding
         * @param bottom new bottom padding
         */
        DApplicationLayerOptions.prototype.setPadding = function (left, top, right, bottom) {
            var padding = this._padding;
            padding.left = left;
            padding.top = top;
            padding.right = right;
            padding.bottom = bottom;
            return this;
        };
        /**
         * Returns a background color.
         */
        DApplicationLayerOptions.prototype.getBackgroundColor = function () {
            return this._pixi.backgroundColor;
        };
        /**
         * Sets a background color.
         *
         * @param color new background color
         */
        DApplicationLayerOptions.prototype.setBackgroundColor = function (color) {
            this._pixi.backgroundColor = color;
            return this;
        };
        /**
         * Returns an antialias setting.
         * The default antialias setting is false.
         */
        DApplicationLayerOptions.prototype.getAntialias = function () {
            return this._pixi.antialias;
        };
        /**
         * Sets an antialias setting.
         *
         * @param antialias new antialias setting
         */
        DApplicationLayerOptions.prototype.setAntialias = function (antialias) {
            this._pixi.antialias = antialias;
            return this;
        };
        /**
         * Returns true if a layer is supposed to be an overlay layer.
         */
        DApplicationLayerOptions.prototype.isOverlay = function () {
            return this._overlay;
        };
        DApplicationLayerOptions.prototype.getPixiApplicationOptions = function () {
            return this._pixi;
        };
        return DApplicationLayerOptions;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandBase = /** @class */ (function () {
        function DCommandBase() {
        }
        DCommandBase.prototype.isStorable = function () {
            return true;
        };
        DCommandBase.prototype.isClear = function () {
            return false;
        };
        DCommandBase.prototype.isClean = function () {
            return false;
        };
        DCommandBase.prototype.execute = function () {
            return true;
        };
        DCommandBase.prototype.merge = function (target) {
            return false;
        };
        DCommandBase.prototype.isMerged = function () {
            return false;
        };
        DCommandBase.prototype.redo = function () {
            return true;
        };
        DCommandBase.prototype.undo = function () {
            return true;
        };
        DCommandBase.prototype.destroy = function () {
            // DO NOTHING
        };
        return DCommandBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandClear = /** @class */ (function (_super) {
        __extends(DCommandClear, _super);
        function DCommandClear() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCommandClear.prototype.isStorable = function () {
            return false;
        };
        DCommandClear.prototype.isClear = function () {
            return true;
        };
        return DCommandClear;
    }(DCommandBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllerCommandImpl = /** @class */ (function (_super) {
        __extends(DControllerCommandImpl, _super);
        function DControllerCommandImpl() {
            var _this = _super.call(this) || this;
            _this._position = 0;
            _this._done = [];
            return _this;
        }
        DControllerCommandImpl.prototype.last = function () {
            var done = this._done;
            var doneLength = done.length;
            if (0 < doneLength) {
                return done[doneLength - 1];
            }
            else {
                return null;
            }
        };
        DControllerCommandImpl.prototype.push = function (command) {
            this.merge(command);
            this.execute(command);
        };
        DControllerCommandImpl.prototype.merge = function (command) {
            var done = this._done;
            var isClear = command.isClear();
            var isStorable = command.isStorable();
            if (isClear || isStorable) {
                var size = isClear ? done.length : this._position;
                if (0 < size) {
                    this.remove(size);
                    this._position = 0;
                    this.emit("change", this);
                }
                this.cleanup();
            }
            var doneLength = done.length;
            if (0 < doneLength) {
                command.merge(done[doneLength - 1]);
            }
        };
        DControllerCommandImpl.prototype.execute = function (command) {
            this.emit("executing", command, this);
            if (command.execute()) {
                return this.onSuccess(command);
            }
            else {
                return this.onFail(command);
            }
        };
        DControllerCommandImpl.prototype.onSuccess = function (command) {
            if (command.isStorable()) {
                if (!command.isMerged()) {
                    this._done.push(command);
                }
                if (!command.isClean()) {
                    this.emit("dirty", this);
                }
            }
            this.emit("change", this);
            this.emit("executed", command, this);
        };
        DControllerCommandImpl.prototype.onFail = function (command) {
            command.destroy();
            this.emit("change", this);
        };
        DControllerCommandImpl.prototype.cleanup = function () {
            var done = this._done;
            var size = done.length - 100;
            if (0 < size) {
                for (var i = 0; i < size; ++i) {
                    done[i].destroy();
                    done.shift();
                }
            }
        };
        DControllerCommandImpl.prototype.remove = function (size) {
            var done = this._done;
            if (0 < size) {
                var ifrom = Math.max(0, done.length - size);
                size = done.length - ifrom;
                if (0 < size) {
                    for (var i = ifrom, imax = done.length; i < imax; ++i) {
                        done[i].destroy();
                    }
                    done.splice(ifrom, done.length - ifrom);
                    return true;
                }
            }
            return false;
        };
        DControllerCommandImpl.prototype.size = function () {
            return this._done.length;
        };
        DControllerCommandImpl.prototype.clear = function () {
            this.push(new DCommandClear());
        };
        DControllerCommandImpl.prototype.redo = function () {
            if (this.isRedoable()) {
                this.doRedo();
            }
        };
        DControllerCommandImpl.prototype.doRedo = function () {
            var done = this._done;
            if (0 < this._position) {
                var current = done[done.length - this._position];
                this._position -= 1;
                this.emit("change", this);
                this.emit("redoing", current, this);
                var result = current.redo();
                if (result === true) {
                    this.onRedoSuccess(current);
                }
                else {
                    this.onRedoFail(current);
                }
            }
        };
        DControllerCommandImpl.prototype.onRedoSuccess = function (redoed) {
            if (!redoed.isClean()) {
                this.emit("dirty", this);
            }
            this.emit("change", this);
            this.emit("redoed", redoed, this);
        };
        DControllerCommandImpl.prototype.onRedoFail = function (command) {
            this.emit("change", this);
        };
        DControllerCommandImpl.prototype.isRedoable = function () {
            return 0 < this._position;
        };
        DControllerCommandImpl.prototype.undo = function () {
            if (this.isUndoable()) {
                this.doUndo();
            }
        };
        DControllerCommandImpl.prototype.doUndo = function () {
            var done = this._done;
            if (this._position < done.length) {
                var current = done[done.length - 1 - this._position];
                this._position += 1;
                this.emit("change", this);
                this.emit("undoing", current, this);
                var result = current.undo();
                if (result === true) {
                    this.onUndoSuccess(current);
                }
                else {
                    this.onUndoFail(current);
                }
            }
        };
        DControllerCommandImpl.prototype.onUndoSuccess = function (undoed) {
            if (!undoed.isClean()) {
                this.emit("dirty", this);
            }
            this.emit("change", this);
            this.emit("undoed", undoed, this);
        };
        DControllerCommandImpl.prototype.onUndoFail = function (command) {
            this.emit("change", this);
        };
        DControllerCommandImpl.prototype.isUndoable = function () {
            return this._position < this._done.length;
        };
        return DControllerCommandImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllerKeyboardImpl = /** @class */ (function (_super) {
        __extends(DControllerKeyboardImpl, _super);
        function DControllerKeyboardImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DControllerKeyboardImpl.prototype.init = function (element, stage, focusController) {
            var _this = this;
            element.addEventListener("keydown", function (e) {
                _this.emit("keydown", e);
                var focused = focusController.get();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (_this.hasOnKeyDown(current)) {
                            if (current.onKeyDown(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
                if (UtilKeyboardEvent.isFocusKey(e)) {
                    var direction = UtilKeyboardEvent.getFocusDirection(e);
                    var next = focused != null
                        ? focusController.find(focused, false, focused.state.isFocusRoot || direction, direction)
                        : focusController.find(stage, false, true, direction);
                    if (next != null) {
                        focusController.focus(next);
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                }
            });
            element.addEventListener("keyup", function (e) {
                _this.emit("keyup", e);
                var focused = focusController.get();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (_this.hasOnKeyUp(current)) {
                            if (current.onKeyUp(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DControllerKeyboardImpl.prototype.hasOnKeyDown = function (target) {
            return "onKeyDown" in target;
        };
        DControllerKeyboardImpl.prototype.hasOnKeyUp = function (target) {
            return "onKeyUp" in target;
        };
        return DControllerKeyboardImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllers = /** @class */ (function () {
        function DControllers() {
        }
        // Keyboard
        DControllers.getKeyboardController = function () {
            if (this.KEYBOARD == null) {
                this.KEYBOARD = new DControllerKeyboardImpl();
            }
            return this.KEYBOARD;
        };
        DControllers.setKeyboardController = function (instance) {
            var result = this.KEYBOARD;
            this.KEYBOARD = instance;
            return result;
        };
        // Command
        DControllers.getCommandController = function () {
            if (this.COMMAND == null) {
                this.COMMAND = new DControllerCommandImpl();
            }
            return this.COMMAND;
        };
        DControllers.setCommandController = function (instance) {
            var result = this.COMMAND;
            this.COMMAND = instance;
            return result;
        };
        // Document
        DControllers.getDocumentController = function () {
            if (this.DOCUMENT == null) {
                throw new Error("Not supported");
            }
            return this.DOCUMENT;
        };
        DControllers.setDocumentController = function (instance) {
            var result = this.DOCUMENT;
            this.DOCUMENT = instance;
            return result;
        };
        return DControllers;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isDblClickable = function (target) {
        return target != null && target.onDblClick != null;
    };
    var isWheelable = function (target) {
        return target != null && target.onWheel != null;
    };
    var DApplicationLayer = /** @class */ (function (_super) {
        __extends(DApplicationLayer, _super);
        function DApplicationLayer(application, options) {
            var _this = _super.call(this, options.getPixiApplicationOptions()) || this;
            _this._renderId = null;
            _this._dynamicFontAtlases = null;
            _this._options = options;
            _this._isLocked = false;
            _this._isVisible = true;
            _this._isOverlay = options.isOverlay();
            _this._padding = options.getPadding();
            _this._rootElement = options.getRootElement();
            _this._reflowLimit = 5;
            _this._elementContainer = _this.newElementContainer();
            _this.application = application;
            _this._renderBound = function () {
                if (_this._renderId != null) {
                    _this.render();
                }
            };
            _this.initStage();
            _this.initView();
            _this.initRootElement();
            _this.initFocusHandling();
            _this.initResizeHandling();
            _this.initWheelHandling();
            _this.initDoubleClickHandling();
            return _this;
        }
        DApplicationLayer.prototype.newElementContainer = function () {
            var result = document.createElement("div");
            result.setAttribute("style", "position: absolute; top: 0; left: 0; width: 0; height: 0;" +
                "margin: 0; padding: 0; outline: none;");
            return result;
        };
        DApplicationLayer.prototype.initStage = function () {
            var stage = this.stage;
            stage.layer = this;
            stage.application = this.application;
            stage.interactive = true;
        };
        DApplicationLayer.prototype.initView = function () {
            var view = this.view;
            var style = view.style;
            style.position = "absolute";
            style.top = "0";
            style.left = "0";
            style.width = "100%";
            style.height = "100%";
            style.display = "block";
            style.outline = "none";
            style.webkitTapHighlightColor = "rgba(255,255,255,0)";
            style.webkitUserSelect = "none";
            style.setProperty("-khtml-user-select", "none");
            style.setProperty("-moz-user-select", "none");
            style.setProperty("-ms-user-select", "none");
            style.userSelect = "none";
        };
        DApplicationLayer.prototype.initRootElement = function () {
            var _this = this;
            var view = this.view;
            var isOverlay = this._isOverlay;
            var rootElement = this._rootElement;
            var elementContainer = this._elementContainer;
            // Insert elements
            var insertionPosition = isOverlay ? 2 : 0;
            var children = rootElement.children;
            if (insertionPosition < children.length) {
                var child = children[insertionPosition];
                rootElement.insertBefore(view, child);
                rootElement.insertBefore(elementContainer, child);
            }
            else {
                rootElement.appendChild(view);
                rootElement.appendChild(elementContainer);
            }
            if (isOverlay) {
                var stage_1 = this.stage;
                var oldOnChildrenChange_1 = stage_1.onChildrenChange;
                stage_1.onChildrenChange = function () {
                    _this.onStageDirty();
                    oldOnChildrenChange_1.call(stage_1);
                };
            }
            // Init styles
            var rootElementStyle = rootElement.style;
            if (rootElement !== document.body) {
                var rootElementStylePosition = window.getComputedStyle(rootElement).position;
                if (rootElementStylePosition === "static") {
                    rootElementStyle.position = "relative";
                }
            }
            rootElementStyle.margin = "0";
            rootElementStyle.padding = "0";
            rootElementStyle.overflow = "hidden";
        };
        DApplicationLayer.prototype.initFocusHandling = function () {
            var view = this.view;
            var stage = this.stage;
            var focusController = this.getFocusController();
            view.setAttribute("tabindex", "0");
            DControllers.getKeyboardController().init(view, stage, focusController);
            var interactionManager = this.renderer.plugins.interaction;
            interactionManager.on(UtilPointerEvent.down, function (e) {
                if (e.target == null || e.target === stage) {
                    focusController.clear();
                }
            });
        };
        DApplicationLayer.prototype.initResizeHandling = function () {
            var _this = this;
            var onResizeBound = function () {
                _this.onResize();
            };
            window.addEventListener("resize", onResizeBound);
            window.addEventListener("orientationchange", onResizeBound);
        };
        DApplicationLayer.prototype.onResize = function () {
            var bbox = this._rootElement.getBoundingClientRect();
            var bboxWidth = bbox.width;
            var bboxHeight = bbox.height;
            this.renderer.resize(bboxWidth, bboxHeight);
            var padding = this._padding;
            var children = this.stage.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(bboxWidth, bboxHeight, padding);
                }
            }
            this.update();
        };
        DApplicationLayer.prototype.initWheelHandling = function () {
            var global = new pixi_js.Point();
            var util = UtilWheelEvent.getInstance();
            var interactionManager = this.renderer.plugins.interaction;
            util.on(this.view, function (e) {
                var wheelEvent = e;
                UtilPointerEvent.toGlobal(wheelEvent, interactionManager, global);
                var current = interactionManager.hitTest(global);
                var deltas = util.normalize(e);
                if (deltas != null) {
                    while (current != null) {
                        if (isWheelable(current)) {
                            if (current.onWheel(wheelEvent, deltas, global)) {
                                wheelEvent.preventDefault();
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DApplicationLayer.prototype.initDoubleClickHandling = function () {
            var focusController = this.getFocusController();
            var interactionManager = this.renderer.plugins.interaction;
            UtilPointerEvent.onDblClick(this.view, function (e) {
                var focused = focusController.get();
                if (focused != null) {
                    var current = focused;
                    while (current != null) {
                        if (isDblClickable(current)) {
                            if (current.onDblClick(e, interactionManager)) {
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        };
        DApplicationLayer.prototype.lock = function () {
            this._isLocked = true;
        };
        DApplicationLayer.prototype.unlock = function () {
            this._isLocked = false;
        };
        DApplicationLayer.prototype.update = function () {
            if (!this._isLocked && this._renderId == null) {
                this._renderId = requestAnimationFrame(this._renderBound);
            }
        };
        DApplicationLayer.prototype.onStageDirty = function () {
            // Update the visibility if this is a overlay layer.
            if (this._isOverlay) {
                if (0 < this.stage.children.length) {
                    // There are more than one children,
                    // therefore must be visible.
                    if (!this._isVisible) {
                        this._isVisible = true;
                        this.view.style.display = "block";
                    }
                }
                else {
                    // There is no child,
                    // therefore must not be visible.
                    if (this._isVisible) {
                        this._isVisible = false;
                        this.view.style.display = "none";
                    }
                }
            }
        };
        DApplicationLayer.prototype.render = function () {
            this.reflow();
            // Please note why the following line is here.
            //
            // Before this line, the update method does not enque a rendering task
            // because `this._renderId` is not null. As a result, this prevents
            // an unintentional rendering loop caused by the refit or the reflow.
            //
            // After this line, the update method enques a rendering task.
            // Namely, in the DisplayObject#render(Renderer) method, allowed to enque
            // a rendering task. For instance, please refer to the DDiagramShape#update().
            this._renderId = null;
            // Render
            _super.prototype.render.call(this);
        };
        Object.defineProperty(DApplicationLayer.prototype, "width", {
            get: function () {
                return this.screen.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DApplicationLayer.prototype, "height", {
            get: function () {
                return this.screen.height;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DApplicationLayer.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        DApplicationLayer.prototype.reflow = function () {
            var children = this.stage.children;
            for (var ilimit = 0, limit = this._reflowLimit; ilimit < limit; ++ilimit) {
                var isDirty = false;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                        isDirty =
                            isDirty || child.isDirty() || child.hasDirty() || child.isHierarchyDirty();
                    }
                }
                // If DBases are changed during the `reflow` process, need to reflow again.
                if (!isDirty) {
                    break;
                }
            }
        };
        DApplicationLayer.prototype.getFocusController = function () {
            return this.application.getFocusController();
        };
        DApplicationLayer.prototype.getRootElement = function () {
            return this._rootElement;
        };
        DApplicationLayer.prototype.getElementContainer = function () {
            return this._elementContainer;
        };
        DApplicationLayer.prototype.getDynamicFontAtlases = function () {
            if (this._dynamicFontAtlases == null) {
                this._dynamicFontAtlases = new DynamicFontAtlases(this);
            }
            return this._dynamicFontAtlases;
        };
        return DApplicationLayer;
    }(pixi_js.Application));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DControllerFocusImpl = /** @class */ (function (_super) {
        __extends(DControllerFocusImpl, _super);
        function DControllerFocusImpl() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._focused = null;
            return _this;
        }
        DControllerFocusImpl.prototype.focus = function (focusable) {
            var previous = this._focused;
            if (previous !== focusable) {
                if (previous != null) {
                    previous.state.isFocused = false;
                }
                this._focused = focusable;
                if (this.isFocusable(focusable)) {
                    focusable.state.isFocused = true;
                }
                this.emit("change", focusable, previous, this);
                return previous;
            }
            return null;
        };
        DControllerFocusImpl.prototype.blur = function (focusable) {
            if (focusable != null && this._focused === focusable) {
                this._focused = null;
                focusable.state.isFocused = false;
                this.emit("change", null, focusable, this);
                return focusable;
            }
            return null;
        };
        DControllerFocusImpl.prototype.clear = function () {
            return this.focus(null);
        };
        DControllerFocusImpl.prototype.set = function (focusable, isFocused) {
            if (isFocused) {
                return this.focus(focusable);
            }
            else {
                return this.blur(focusable);
            }
        };
        DControllerFocusImpl.prototype.get = function () {
            return this._focused;
        };
        DControllerFocusImpl.prototype.findParent = function (mightBeFocusable) {
            var current = mightBeFocusable;
            while (current != null) {
                if (this.isFocusable(current)) {
                    return current;
                }
                else {
                    current = current.parent;
                }
            }
            return null;
        };
        DControllerFocusImpl.prototype.find = function (target, includesTarget, includesTargetChildren, direction, root) {
            if (direction) {
                var result = this.findNext(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                if (this.isFocusRoot(target, root)) {
                    return null;
                }
                var parent_1 = target.parent;
                if (parent_1 != null) {
                    var children = parent_1.children;
                    var index = children.indexOf(target);
                    if (0 <= index) {
                        var childrenLength = children.length;
                        if (this.isFocusReverse(parent_1)) {
                            for (var i = index - 1; 0 <= i; --i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_1, root)) {
                                var found = this.find(parent_1, false, false, true, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = childrenLength - 1; index <= i; --i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                        else {
                            for (var i = index + 1; i < childrenLength; ++i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_1, root)) {
                                var found = this.find(parent_1, false, false, true, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = 0; i <= index; ++i) {
                                var found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                    }
                }
            }
            else {
                var result = this.findPrevious(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                var parent_2 = target.parent;
                if (parent_2 != null) {
                    var children = parent_2.children;
                    var index = children.indexOf(target);
                    if (0 <= index) {
                        var childrenLength = children.length;
                        if (this.isFocusReverse(parent_2)) {
                            for (var i = index + 1; i < childrenLength; ++i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_2, root)) {
                                var found = this.find(parent_2, true, false, false, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = 0; i <= index; ++i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                        else {
                            for (var i = index - 1; 0 <= i; --i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent_2, root)) {
                                var found = this.find(parent_2, true, false, false, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (var i = childrenLength - 1; index <= i; --i) {
                                var found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                    }
                }
            }
            return null;
        };
        DControllerFocusImpl.prototype.findNext = function (target, includesTarget, includesTargetChildren) {
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Target children
            if (includesTargetChildren && this.isFocusableContainer(target) && target.visible) {
                var children = target.children;
                var childrenLength = children.length;
                if (this.isFocusReverse(target)) {
                    for (var i = childrenLength - 1; 0 <= i; --i) {
                        var found = this.findNext(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
                else {
                    for (var i = 0; i < childrenLength; ++i) {
                        var found = this.findNext(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
            }
            // Found nothing
            return null;
        };
        DControllerFocusImpl.prototype.findPrevious = function (target, includesTarget, includesTargetChildren) {
            // Target children
            if (includesTargetChildren && this.isFocusableContainer(target) && target.visible) {
                var children = target.children;
                var childrenLength = children.length;
                if (this.isFocusReverse(target)) {
                    for (var i = 0; i < childrenLength; ++i) {
                        var found = this.findPrevious(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
                else {
                    for (var i = childrenLength - 1; 0 <= i; --i) {
                        var found = this.findPrevious(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
            }
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Found nothing
            return null;
        };
        DControllerFocusImpl.prototype.isFocusable = function (target) {
            return (target != null &&
                "state" in target &&
                target.state.inEnabled &&
                target.state.isFocusable &&
                target.visible);
        };
        DControllerFocusImpl.prototype.isFocusableContainer = function (target) {
            return target != null && "children" in target;
        };
        DControllerFocusImpl.prototype.isFocusRoot = function (target, root) {
            if (target === root) {
                return true;
            }
            return target != null && "state" in target && target.state.isFocusRoot && target.visible;
        };
        DControllerFocusImpl.prototype.isFocusReverse = function (target) {
            return target != null && "state" in target && target.state.isFocusReverse;
        };
        return DControllerFocusImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DApplication = /** @class */ (function () {
        function DApplication(options) {
            var _a, _b;
            DApplications.add(this);
            // Root
            var root = this.toRootElement(options);
            this._root = root;
            this.initFocusHandling(root);
            // Resolution
            var resolution = (_b = (_a = options === null || options === void 0 ? void 0 : options.resolution) !== null && _a !== void 0 ? _a : window.devicePixelRatio) !== null && _b !== void 0 ? _b : 1;
            this._resolution = resolution;
            // Remove the accessibility plugin
            delete pixi_js.Renderer.__plugins.accessibility;
            // Options
            this._options = options;
            // Base layer
            var base = this.newLayerBase(options);
            this._base = base;
            // Overlay layer
            this._isOverlayEnabled = !!(options === null || options === void 0 ? void 0 : options.overlay);
            if (!this._isOverlayEnabled) {
                this._overlay = base;
            }
        }
        Object.defineProperty(DApplication.prototype, "stage", {
            get: function () {
                return this._base.stage;
            },
            enumerable: false,
            configurable: true
        });
        DApplication.prototype.getRootElement = function () {
            return this._root;
        };
        DApplication.prototype.getResolution = function () {
            return this._resolution;
        };
        DApplication.prototype.toRootElement = function (options) {
            var root = options === null || options === void 0 ? void 0 : options.root;
            if (root != null) {
                if (isString(root)) {
                    var found = document.querySelector(root);
                    if (found) {
                        return found;
                    }
                }
                else {
                    return root;
                }
            }
            return document.body;
        };
        DApplication.prototype.toLayerBaseOptions = function (options) {
            var root = this._root;
            var resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root: root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: options.background,
                    resolution: resolution,
                    antialias: options.antialias,
                    overlay: false
                });
            }
            return new DApplicationLayerOptions({
                root: root,
                resolution: resolution,
                overlay: false
            });
        };
        DApplication.prototype.getFocusController = function () {
            if (this._focus == null) {
                this._focus = new DControllerFocusImpl();
            }
            return this._focus;
        };
        DApplication.prototype.initFocusHandling = function (root) {
            var _this = this;
            var hasFocus = false;
            var onFocus = function () {
                hasFocus = true;
            };
            var onBlured = function () {
                if (!hasFocus) {
                    _this.getFocusController().clear();
                }
            };
            var onBlur = function () {
                hasFocus = false;
                setTimeout(onBlured, 0);
            };
            root.addEventListener("focus", onFocus, true);
            root.addEventListener("blur", onBlur, true);
        };
        DApplication.prototype.newLayerBase = function (options) {
            return new DApplicationLayer(this, this.toLayerBaseOptions(options));
        };
        DApplication.prototype.getLayerBase = function () {
            return this._base;
        };
        DApplication.prototype.toLayerOverlayOptions = function (options) {
            var root = this._root;
            var resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root: root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: {
                        color: null
                    },
                    resolution: resolution,
                    antialias: options.antialias,
                    overlay: true
                });
            }
            return new DApplicationLayerOptions({
                root: root,
                resolution: resolution,
                overlay: true
            });
        };
        DApplication.prototype.newLayerOverlay = function (options) {
            return new DApplicationLayer(this, this.toLayerOverlayOptions(options));
        };
        DApplication.prototype.getLayerOverlay = function () {
            if (this._isOverlayEnabled) {
                if (this._overlay == null) {
                    this._overlay = this.newLayerOverlay(this._options);
                }
                return this._overlay;
            }
            else {
                return this._base;
            }
        };
        DApplication.prototype.update = function () {
            if (this._isOverlayEnabled) {
                var base = this._base;
                base.update();
                var overlay = this._overlay;
                if (overlay) {
                    overlay.update();
                }
            }
            else {
                return this._base.update();
            }
        };
        DApplication.prototype.render = function () {
            if (this._isOverlayEnabled) {
                var base = this._base;
                base.render();
                var overlay = this._overlay;
                if (overlay) {
                    overlay.render();
                }
            }
            else {
                return this._base.render();
            }
        };
        return DApplication;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBasePaddingAdjustable = /** @class */ (function () {
        function DBasePaddingAdjustable(target) {
            this._target = target;
            this._top = 0;
            this._right = 0;
            this._bottom = 0;
            this._left = 0;
            if (target instanceof DBasePadding) {
                this._callback = target.getCallback();
            }
        }
        DBasePaddingAdjustable.prototype.getTheme = function () {
            return this._target.getTheme();
        };
        DBasePaddingAdjustable.prototype.setTheme = function (theme) {
            this._target.setTheme(theme);
        };
        DBasePaddingAdjustable.prototype.getLeft = function () {
            return this._target.getLeft() + this._left;
        };
        DBasePaddingAdjustable.prototype.adjLeft = function (left) {
            if (this._left !== left) {
                this._left = left;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "left", {
            get: function () {
                return this._target.left;
            },
            set: function (left) {
                this._target.left = left;
            },
            enumerable: false,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getTop = function () {
            return this._target.getTop() + this._top;
        };
        DBasePaddingAdjustable.prototype.adjTop = function (top) {
            if (this._top !== top) {
                this._top = top;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "top", {
            get: function () {
                return this._target.top;
            },
            set: function (top) {
                this._target.top = top;
            },
            enumerable: false,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getRight = function () {
            return this._target.getRight() + this._right;
        };
        DBasePaddingAdjustable.prototype.adjRight = function (right) {
            if (this._right !== right) {
                this._right = right;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "right", {
            get: function () {
                return this._target.right;
            },
            set: function (right) {
                this._target.right = right;
            },
            enumerable: false,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.getBottom = function () {
            return this._target.getBottom() + this._bottom;
        };
        DBasePaddingAdjustable.prototype.adjBottom = function (bottom) {
            if (this._bottom !== bottom) {
                this._bottom = bottom;
                var callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        };
        Object.defineProperty(DBasePaddingAdjustable.prototype, "bottom", {
            get: function () {
                return this._target.bottom;
            },
            set: function (bottom) {
                this._target.bottom = bottom;
            },
            enumerable: false,
            configurable: true
        });
        DBasePaddingAdjustable.prototype.set = function (top, right, bottom, left) {
            var target = this._target;
            if (right == null) {
                target.set(top);
            }
            else if (bottom == null) {
                target.set(top, right);
            }
            else if (left == null) {
                target.set(top, right, bottom);
            }
            else {
                target.set(top, right, bottom, left);
            }
        };
        return DBasePaddingAdjustable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DBoard = /** @class */ (function (_super) {
        __extends(DBoard, _super);
        function DBoard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DBoard.prototype.getType = function () {
            return "DBoard";
        };
        return DBoard;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonCheck = /** @class */ (function (_super) {
        __extends(DButtonCheck, _super);
        function DButtonCheck() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonCheck.prototype.getType = function () {
            return "DButtonCheck";
        };
        return DButtonCheck;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonCheckRight = /** @class */ (function (_super) {
        __extends(DButtonCheckRight, _super);
        function DButtonCheckRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonCheckRight.prototype.getType = function () {
            return "DButtonCheckRight";
        };
        return DButtonCheckRight;
    }(DButtonCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DColorGradientPointObservable = /** @class */ (function () {
        function DColorGradientPointObservable(color, alpha, position, selected, callback) {
            this._color = color;
            this._alpha = alpha;
            this._position = position;
            this._callback = callback;
            this._selected = selected;
        }
        DColorGradientPointObservable.prototype.set = function (color, alpha, position, selected) {
            if (this._color !== color ||
                this._alpha !== alpha ||
                this._position !== position ||
                this._selected !== selected) {
                this._color = color;
                this._alpha = alpha;
                this._position = position;
                this._selected = selected;
                this._callback(this);
            }
        };
        Object.defineProperty(DColorGradientPointObservable.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (color) {
                if (this._color !== color) {
                    this._color = color;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientPointObservable.prototype, "alpha", {
            get: function () {
                return this._alpha;
            },
            set: function (alpha) {
                if (this._alpha !== alpha) {
                    this._alpha = alpha;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientPointObservable.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                if (this._position !== position) {
                    this._position = position;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientPointObservable.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (selected) {
                if (this._selected !== selected) {
                    this._selected = selected;
                    this._callback(this);
                }
            },
            enumerable: false,
            configurable: true
        });
        DColorGradientPointObservable.prototype.toObject = function () {
            return {
                color: this._color,
                alpha: this._alpha,
                position: this._position
            };
        };
        return DColorGradientPointObservable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var POINT_SORTER = function (a, b) {
        return a.position - b.position;
    };
    var DColorGradientObservable = /** @class */ (function (_super) {
        __extends(DColorGradientObservable, _super);
        function DColorGradientObservable() {
            var _this = _super.call(this) || this;
            var onChangeBound = function (target) {
                _this.onChange(target);
            };
            _this._onChangeBound = onChangeBound;
            var first = new DColorGradientPointObservable(0xffffff, 1, 0, false, onChangeBound);
            var second = new DColorGradientPointObservable(0x808080, 1, 1, true, onChangeBound);
            _this._points = [first, second];
            _this._direction = -90;
            _this._selected = second;
            _this._workColor = [0, 0, 0];
            return _this;
        }
        DColorGradientObservable.prototype.onChange = function (target) {
            var isSelectionChanged = target.selected && this._selected !== target;
            if (isSelectionChanged) {
                var selected = this._selected;
                if (selected != null) {
                    selected._selected = false;
                }
                this._selected = target;
            }
            this._points.sort(POINT_SORTER);
            if (isSelectionChanged) {
                this.emit("selectionchange", this._selected, this);
            }
            this.emit("change", this);
        };
        Object.defineProperty(DColorGradientObservable.prototype, "points", {
            get: function () {
                return this._points;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientObservable.prototype, "direction", {
            get: function () {
                return this._direction;
            },
            set: function (direction) {
                if (this._direction !== direction) {
                    this._direction = direction;
                    this.emit("directionchange", direction, this);
                    this.emit("change", this);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DColorGradientObservable.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            enumerable: false,
            configurable: true
        });
        DColorGradientObservable.prototype.size = function () {
            return this._points.length;
        };
        DColorGradientObservable.prototype.get = function (index) {
            var points = this._points;
            if (0 <= index && index < points.length) {
                return points[index];
            }
            return null;
        };
        DColorGradientObservable.prototype.addAt = function (position) {
            var points = this._points;
            var previous = null;
            for (var i = 0, imax = points.length; i < imax; ++i) {
                var point = points[i];
                if (position <= point.position) {
                    if (previous != null) {
                        var span = point.position - previous.position;
                        if (0.001 < span) {
                            var rgb0 = pixi_js.utils.hex2rgb(point.color, this._workColor);
                            var r0 = rgb0[0];
                            var g0 = rgb0[1];
                            var b0 = rgb0[2];
                            var rgb1 = pixi_js.utils.hex2rgb(previous.color, this._workColor);
                            var r1 = rgb1[0];
                            var g1 = rgb1[1];
                            var b1 = rgb1[2];
                            var ratio = (position - previous.position) / span;
                            var r = r0 * ratio + r1 * (1 - ratio);
                            var g = g0 * ratio + g1 * (1 - ratio);
                            var b = b0 * ratio + b1 * (1 - ratio);
                            var rgb = this._workColor;
                            rgb[0] = r;
                            rgb[1] = g;
                            rgb[2] = b;
                            var color = pixi_js.utils.rgb2hex(rgb);
                            var alpha = point.alpha * ratio + previous.alpha * (1 - ratio);
                            return this.add(color, alpha, position, true);
                        }
                    }
                    else {
                        return this.add(point.color, point.alpha, position, true);
                    }
                }
                previous = point;
            }
            if (previous != null) {
                return this.add(previous.color, previous.alpha, position, true);
            }
            else {
                return this.add(0xffffff, 1.0, position, true);
            }
        };
        DColorGradientObservable.prototype.add = function (color, alpha, position, selected) {
            var onChangeBound = this._onChangeBound;
            var result = new DColorGradientPointObservable(color, alpha, position, selected, onChangeBound);
            this._points.push(result);
            onChangeBound(result);
            return result;
        };
        DColorGradientObservable.prototype.remove = function (point) {
            var points = this._points;
            if (2 < points.length) {
                for (var i = 0, imax = points.length; i < imax; ++i) {
                    if (points[i] === point) {
                        points.splice(i, 1);
                        var isSelectionChanged = this._selected === point;
                        if (isSelectionChanged) {
                            if (i + 1 < imax) {
                                this._selected = points[i];
                            }
                            else {
                                this._selected = points[i - 1];
                            }
                        }
                        if (isSelectionChanged) {
                            this.emit("selectionchange", this._selected, this);
                        }
                        this.emit("change", this);
                        return true;
                    }
                }
            }
            return false;
        };
        DColorGradientObservable.prototype.reset = function () {
            var oldDirection = this._direction;
            this._direction = -90;
            var points = this._points;
            var oldSelected = this._selected;
            var index = oldSelected ? points.indexOf(oldSelected) : -1;
            points.length = 0;
            var onChangeBound = this._onChangeBound;
            points.push(new DColorGradientPointObservable(0xffffff, 0, 0, false, onChangeBound));
            points.push(new DColorGradientPointObservable(0xffffff, 0, 1, false, onChangeBound));
            if (0 <= index && index < points.length) {
                var point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                var point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
            return this;
        };
        DColorGradientObservable.prototype.toObject = function () {
            var pointsCopy = [];
            var points = this._points;
            for (var i = 0, imax = points.length; i < imax; ++i) {
                pointsCopy.push(points[i].toObject());
            }
            return {
                points: pointsCopy,
                direction: this._direction
            };
        };
        DColorGradientObservable.prototype.fromObject = function (data) {
            var oldDirection = this._direction;
            this._direction = data.direction;
            var points = this._points;
            var oldSelected = this._selected;
            var index = oldSelected ? points.indexOf(oldSelected) : -1;
            points.length = 0;
            var onChangeBound = this._onChangeBound;
            for (var i = 0, imax = data.points.length; i < imax; ++i) {
                var pointLike = data.points[i];
                var point = new DColorGradientPointObservable(pointLike.color, pointLike.alpha, pointLike.position, false, onChangeBound);
                points.push(point);
            }
            points.sort(POINT_SORTER);
            if (0 <= index && index < points.length) {
                var point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                var point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
            return this;
        };
        return DColorGradientObservable;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputLabel = /** @class */ (function (_super) {
        __extends(DInputLabel, _super);
        function DInputLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputLabel.prototype.getType = function () {
            return "DInputLabel";
        };
        return DInputLabel;
    }(DText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputAndLabel = /** @class */ (function (_super) {
        __extends(DInputAndLabel, _super);
        function DInputAndLabel(options) {
            var _this = _super.call(this, options) || this;
            _this.addChild((_this._label = new DInputLabel(options === null || options === void 0 ? void 0 : options.label)));
            _this.addChild((_this._input = _this.createInput(options === null || options === void 0 ? void 0 : options.input)));
            var space = options === null || options === void 0 ? void 0 : options.space;
            if (space != null) {
                _this.addChild(new DLayoutSpace(space));
            }
            return _this;
        }
        Object.defineProperty(DInputAndLabel.prototype, "input", {
            get: function () {
                return this._input;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DInputAndLabel.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: false,
            configurable: true
        });
        DInputAndLabel.prototype.getType = function () {
            return "DInputAndLabel";
        };
        return DInputAndLabel;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputRealAndLabel = /** @class */ (function (_super) {
        __extends(DInputRealAndLabel, _super);
        function DInputRealAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputRealAndLabel.prototype.createInput = function (options) {
            return new DInputReal(options);
        };
        return DInputRealAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputTextAndLabel = /** @class */ (function (_super) {
        __extends(DInputTextAndLabel, _super);
        function DInputTextAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputTextAndLabel.prototype.createInput = function (options) {
            return new DInputText(options);
        };
        return DInputTextAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorAndAlpha = /** @class */ (function () {
        function DPickerColorAndAlpha(colorAndAlpha, onColorChange, onAlphaChange) {
            this._colorAndAlpha = colorAndAlpha;
            this._onColorChange = onColorChange;
            this._onAlphaChange = onAlphaChange;
        }
        Object.defineProperty(DPickerColorAndAlpha.prototype, "color", {
            get: function () {
                return this._colorAndAlpha.color;
            },
            set: function (color) {
                if (this._colorAndAlpha.color !== color) {
                    var callback = this._onColorChange;
                    if (callback != null) {
                        callback(color);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColorAndAlpha.prototype, "alpha", {
            get: function () {
                return this._colorAndAlpha.alpha;
            },
            set: function (alpha) {
                if (this._colorAndAlpha.alpha !== alpha) {
                    var callback = this._onAlphaChange;
                    if (callback != null) {
                        callback(alpha);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        return DPickerColorAndAlpha;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorRecent = /** @class */ (function (_super) {
        __extends(DPickerColorRecent, _super);
        function DPickerColorRecent(recents, capacity) {
            var _this = _super.call(this) || this;
            _this._recents = recents;
            _this._capacity = capacity;
            return _this;
        }
        DPickerColorRecent.prototype.get = function (index) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        };
        DPickerColorRecent.prototype.set = function (index, colorAndAlpha) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                var result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = {
                    color: colorAndAlpha.color,
                    alpha: colorAndAlpha.alpha
                };
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorRecent.prototype.contains = function (colorAndAlpha) {
            var recents = this._recents;
            for (var i = 0, imax = recents.length; i < imax; ++i) {
                var recent = recents[i];
                if (recent.color === colorAndAlpha.color && recent.alpha === colorAndAlpha.alpha) {
                    return true;
                }
            }
            return false;
        };
        DPickerColorRecent.prototype.add = function (colorAndAlpha) {
            var recents = this._recents;
            recents.push({
                color: colorAndAlpha.color,
                alpha: colorAndAlpha.alpha
            });
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        };
        DPickerColorRecent.prototype.pop = function () {
            var recents = this._recents;
            var result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorRecent.prototype.size = function () {
            return this._recents.length;
        };
        return DPickerColorRecent;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColor = /** @class */ (function (_super) {
        __extends(DPickerColor, _super);
        function DPickerColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DPickerColor.prototype, "current", {
            get: function () {
                return this._currentPicker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColor.prototype, "new", {
            get: function () {
                return this._newPicker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColor.prototype, "recent", {
            get: function () {
                return this._recent;
            },
            enumerable: false,
            configurable: true
        });
        DPickerColor.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._base = 0xff0000;
            this._new = { color: 0xffffff, alpha: 1 };
            this._newPicker = new DPickerColorAndAlpha(this._new, function (color) {
                _this.setColorNew(color);
            }, function (alpha) {
                _this.setAlphaNew(alpha);
            });
            this._current = { color: 0xffffff, alpha: 1 };
            this._currentPicker = new DPickerColorAndAlpha(this._current, function (color) {
                _this.setColorCurrent(color);
            }, function (alpha) {
                _this.setAlphaCurrent(alpha);
            });
            var theme = this.theme;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingRight = padding.getRight();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            this._pointerPoint = new pixi_js.Point();
            // Main
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var mainBaseSprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
            this._mainBaseSprite = mainBaseSprite;
            mainBaseSprite.x = paddingLeft;
            mainBaseSprite.y = paddingTop;
            mainBaseSprite.width = mainWidth;
            mainBaseSprite.height = mainHeight;
            mainBaseSprite.interactive = true;
            this.addChild(mainBaseSprite);
            var mainSprite = new pixi_js.Sprite(theme.getMainTexture());
            this._mainSprite = mainSprite;
            mainSprite.x = paddingLeft;
            mainSprite.y = paddingTop;
            mainSprite.tint = this._base;
            mainSprite.interactive = false;
            this.addChild(mainSprite);
            // Main event handling
            this._onMainMoveBound = function (e) {
                _this.onMainMove(e);
            };
            this._onMainUpBound = function (e) {
                _this.onMainUp(e);
            };
            mainBaseSprite.on(UtilPointerEvent.down, function (e) {
                _this.onMainDown(e);
            });
            // Base color picker
            var baseSprite = new pixi_js.Sprite(theme.getBaseTexture());
            this._baseSprite = baseSprite;
            baseSprite.x = paddingLeft;
            baseSprite.y = mainBaseSprite.y + mainBaseSprite.height + theme.getBaseMargin();
            baseSprite.interactive = true;
            this.addChild(baseSprite);
            // Base event
            this._onBaseMoveBound = function (e) {
                _this.onBaseMove(e);
            };
            this._onBaseUpBound = function (e) {
                _this.onBaseUp(e);
            };
            baseSprite.on(UtilPointerEvent.down, function (e) {
                _this.onBaseDown(e);
            });
            // Alpha picker
            var alphaCheckerboardSprite = new pixi_js.Sprite(theme.getAlphaCheckerboardTexture());
            this._alphaCheckerboardSprite = alphaCheckerboardSprite;
            alphaCheckerboardSprite.x = padding.getLeft();
            alphaCheckerboardSprite.y = baseSprite.y + theme.getBaseHeight() + theme.getBaseMargin();
            alphaCheckerboardSprite.interactive = false;
            this.addChild(alphaCheckerboardSprite);
            var alphaSprite = new pixi_js.Sprite(theme.getAlphaTexture());
            alphaSprite.tint = this._new.color;
            alphaSprite.interactive = true;
            alphaCheckerboardSprite.addChild(alphaSprite);
            // Alpha event
            this._onAlphaMoveBound = function (e) {
                _this.onAlphaMove(e);
            };
            this._onAlphaUpBound = function (e) {
                _this.onAlphaUp(e);
            };
            alphaSprite.on(UtilPointerEvent.down, function (e) {
                _this.onAlphaDown(e);
            });
            // Pointers
            var mainPointerSprite = new pixi_js.Sprite(theme.getMainPointerTexture());
            this._mainPointerSprite = mainPointerSprite;
            mainPointerSprite.x = paddingLeft;
            mainPointerSprite.y = paddingTop;
            mainPointerSprite.anchor.x = 0.5;
            mainPointerSprite.anchor.y = 0.5;
            mainPointerSprite.tint = theme.getMainPointerColor();
            mainPointerSprite.alpha = theme.getMainPointerAlpha();
            mainPointerSprite.interactive = false;
            this.addChild(mainPointerSprite);
            var alphaPointerSprite = new pixi_js.Sprite(theme.getAlphaPointerTexture());
            this._alphaPointerSprite = alphaPointerSprite;
            alphaPointerSprite.x = mainWidth;
            alphaPointerSprite.y = alphaCheckerboardSprite.height * 0.5;
            alphaPointerSprite.tint = theme.getAlphaPointerColor();
            alphaPointerSprite.alpha = theme.getAlphaPointerAlpha();
            alphaPointerSprite.anchor.set(0.5, 0.5);
            alphaPointerSprite.interactive = false;
            alphaCheckerboardSprite.addChild(alphaPointerSprite);
            var basePointerSprite = new pixi_js.Sprite(theme.getBasePointerTexture());
            this._basePointerSprite = basePointerSprite;
            basePointerSprite.x = 0;
            basePointerSprite.y = baseSprite.height * 0.5;
            basePointerSprite.tint = theme.getBasePointerColor();
            basePointerSprite.alpha = theme.getBasePointerAlpha();
            basePointerSprite.anchor.set(0.5, 0.5);
            basePointerSprite.interactive = false;
            baseSprite.addChild(basePointerSprite);
            // Recently used
            this._recentColorSprites = [];
            var recentColorSprites = this._recentColorSprites;
            var recentColorCount = theme.getRecentColorCount();
            var recentColorWidth = theme.getRecentColorWidth();
            var recentColorHeight = theme.getRecentColorHeight();
            var recentColorWidthHalf = recentColorWidth * 0.5;
            var recentColorHeightHalf = recentColorHeight * 0.5;
            var recentColorMargin = theme.getRecentColorMargin();
            var recentColorY = alphaCheckerboardSprite.y + theme.getAlphaHeight() + theme.getRecentMargin();
            var recentCheckerboardTexture = theme.getRecentCheckerboardTexture();
            if (DPickerColor.RECENT_COLORS == null) {
                DPickerColor.RECENT_COLORS = new DPickerColorRecent(theme.getRecents().slice(0), recentColorCount);
            }
            var recent = (this._recent = DPickerColor.RECENT_COLORS);
            recent.on("change", function () {
                _this.onRecentChange();
            });
            var onRecentClick = function (e) {
                var checkerboardSprite = e.currentTarget;
                if (checkerboardSprite instanceof pixi_js.Container) {
                    var sprite = checkerboardSprite.children[0];
                    if (sprite instanceof pixi_js.Sprite) {
                        _this.setColorNew(sprite.tint);
                        _this.setAlphaNew(sprite.alpha);
                    }
                }
            };
            for (var i = 0; i < recentColorCount; ++i) {
                var x = paddingLeft + i * (recentColorWidth + recentColorMargin);
                var checkerboardSprite = new pixi_js.Sprite(recentCheckerboardTexture);
                checkerboardSprite.x = x + recentColorWidthHalf;
                checkerboardSprite.y = recentColorY + recentColorHeightHalf;
                checkerboardSprite.anchor.x = 0.5;
                checkerboardSprite.anchor.y = 0.5;
                checkerboardSprite.buttonMode = true;
                checkerboardSprite.interactive = true;
                checkerboardSprite.on(UtilPointerEvent.tap, onRecentClick);
                this.addChild(checkerboardSprite);
                var sprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
                var recentColorAndAlpha = recent.get(i);
                if (recentColorAndAlpha != null) {
                    sprite.tint = recentColorAndAlpha.color;
                    sprite.alpha = recentColorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
                sprite.width = recentColorWidth;
                sprite.height = recentColorHeight;
                sprite.anchor.x = 0.5;
                sprite.anchor.y = 0.5;
                sprite.interactive = false;
                checkerboardSprite.addChild(sprite);
                recentColorSprites.push(sprite);
            }
            // Input color
            var inputMargin = theme.getInputMargin();
            var inputLabelWidth = theme.getInputLabelWidth();
            var inputY = recentColorY + recentColorHeight + inputMargin;
            var inputWidth = (mainWidth - inputMargin) * 0.5;
            var inputAndLabelColor = new DInputTextAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY,
                width: inputWidth,
                label: {
                    width: inputLabelWidth,
                    text: {
                        value: "#"
                    },
                    interactive: DBaseInteractive.NONE
                },
                input: {
                    weight: 1,
                    text: {
                        value: "FFFFFF"
                    },
                    on: {
                        input: function (code) {
                            var color = UtilRgb.fromCode(code);
                            if (color != null) {
                                _this.setColorNew(color);
                            }
                        }
                    }
                }
            });
            this._inputAndLabelColor = inputAndLabelColor;
            var inputHeight = inputAndLabelColor.height;
            var inputAndLabelAlpha = new DInputRealAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY + inputHeight + inputMargin,
                width: inputWidth,
                label: {
                    width: inputLabelWidth,
                    text: {
                        value: "A"
                    },
                    interactive: DBaseInteractive.NONE
                },
                input: {
                    weight: 1,
                    text: {
                        value: 1
                    },
                    min: 0,
                    max: 1,
                    on: {
                        input: function (value) {
                            _this.setAlphaNew(value);
                        }
                    }
                }
            });
            this._inputAndLabelAlpha = inputAndLabelAlpha;
            // Samples
            var sampleWidth = (inputWidth - inputLabelWidth - inputMargin) * 0.5;
            var sampleHeight = inputHeight + inputMargin + inputHeight;
            var sampleX = paddingLeft + (mainWidth - inputMargin) * 0.5 + inputMargin;
            var sampleY = inputY + (inputHeight + inputMargin + inputAndLabelAlpha.height - sampleHeight) * 0.5;
            var sampleCurrentCheckerboardSprite = new pixi_js.Sprite(theme.getSampleCheckerboardTexture());
            this._sampleCurrentCheckerboardSprite = sampleCurrentCheckerboardSprite;
            sampleCurrentCheckerboardSprite.x = sampleX;
            sampleCurrentCheckerboardSprite.y = sampleY;
            sampleCurrentCheckerboardSprite.width = sampleWidth;
            sampleCurrentCheckerboardSprite.height = sampleHeight;
            sampleCurrentCheckerboardSprite.interactive = false;
            this.addChild(sampleCurrentCheckerboardSprite);
            var current = this._current;
            var sampleCurrentSprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
            this._sampleCurrentSprite = sampleCurrentSprite;
            sampleCurrentSprite.x = sampleX;
            sampleCurrentSprite.y = sampleY;
            sampleCurrentSprite.tint = current.color;
            sampleCurrentSprite.alpha = current.alpha;
            sampleCurrentSprite.width = sampleWidth;
            sampleCurrentSprite.height = sampleHeight;
            sampleCurrentSprite.interactive = true;
            sampleCurrentSprite.buttonMode = true;
            sampleCurrentSprite.on(UtilPointerEvent.tap, function () {
                _this.setColorNew(current.color);
                _this.setAlphaNew(current.alpha);
            });
            this.addChild(sampleCurrentSprite);
            var sampleNewCheckerboardSprite = new pixi_js.Sprite(theme.getSampleCheckerboardTexture());
            this._sampleNewCheckerboardSprite = sampleNewCheckerboardSprite;
            sampleNewCheckerboardSprite.x = sampleX + sampleWidth;
            sampleNewCheckerboardSprite.y = sampleY;
            sampleNewCheckerboardSprite.width = sampleWidth;
            sampleNewCheckerboardSprite.height = sampleHeight;
            sampleNewCheckerboardSprite.interactive = false;
            this.addChild(sampleNewCheckerboardSprite);
            var sampleNewSprite = new pixi_js.Sprite(pixi_js.Texture.WHITE);
            this._sampleNewSprite = sampleNewSprite;
            sampleNewSprite.x = sampleX + sampleWidth;
            sampleNewSprite.y = sampleY;
            sampleNewSprite.tint = this._new.color;
            sampleNewSprite.alpha = this._new.alpha;
            sampleNewSprite.width = sampleWidth;
            sampleNewSprite.height = sampleHeight;
            sampleNewSprite.interactive = false;
            this.addChild(sampleNewSprite);
            // Width
            if (options == null || options.width == null) {
                this.width = paddingLeft + mainWidth + paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height =
                    inputY +
                        inputAndLabelColor.height +
                        inputMargin +
                        inputAndLabelAlpha.height +
                        paddingBottom;
            }
        };
        DPickerColor.prototype.onMainDown = function (e) {
            this.onMainPick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onMainMoveBound);
                stage.on(UtilPointerEvent.up, this._onMainUpBound);
            }
        };
        DPickerColor.prototype.onMainMove = function (e) {
            this.onMainPick(e.data.global);
        };
        DPickerColor.prototype.onMainUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onMainMoveBound);
                stage.off(UtilPointerEvent.up, this._onMainUpBound);
            }
        };
        DPickerColor.prototype.toMainHex = function (b, w0, w1, shift) {
            return Math.max(0, Math.min(255, w0 * 255 + w1 * ((b >> shift) & 0xff))) << shift;
        };
        DPickerColor.prototype.toMainColor = function (base, tx, ty, width, height) {
            var hw = width * 0.5;
            var ux = Math.max(0, Math.min(1, ((tx - hw) * (1 - ty / height) + hw) / width));
            var uy = Math.max(0, Math.min(1, ty / height));
            var w1 = Math.abs(0.5 * uy - ux);
            var w0 = 1 - w1 - uy;
            var r = this.toMainHex(base, w0, w1, 16);
            var g = this.toMainHex(base, w0, w1, 8);
            var b = this.toMainHex(base, w0, w1, 0);
            return r | g | b;
        };
        DPickerColor.prototype.onMainPick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var paddingLeft = padding.getLeft();
            var paddingTop = padding.getTop();
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - paddingLeft));
            var y = Math.max(0, Math.min(mainHeight, point.y - paddingTop));
            var mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.position.set(paddingLeft + x, paddingTop + y);
            this.onColorNew(this.toMainColor(this._base, x, y, mainWidth, mainHeight));
        };
        DPickerColor.prototype.setColorCurrent = function (color) {
            this._sampleCurrentSprite.tint = this._current.color = color;
        };
        DPickerColor.prototype.setAlphaCurrent = function (alpha) {
            this._sampleCurrentSprite.alpha = this._current.alpha = alpha;
        };
        DPickerColor.prototype.setColorNew = function (color) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var padding = this._padding;
            // Base color
            var hsv = UtilHsv.fromRgb(color);
            this._mainSprite.tint = this._base = UtilHsv.toRgb(hsv[0], 255, 255);
            // Move the base pointer
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, hsv[0] / 360)) * mainWidth;
            // Move the main pointer
            var ns = Math.max(0, Math.min(1, hsv[1] / 255));
            var nv = Math.max(0, Math.min(1, 1 - hsv[2] / 255));
            var mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.tint = nv < 0.45 ? theme.getMainPointerColor() : 0xffffff;
            mainPointerSprite.position.set(padding.getLeft() + ns * mainWidth, padding.getTop() + nv * mainHeight);
            // New color
            this.onColorNew(color);
        };
        DPickerColor.prototype.onColorNew = function (color) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.lock();
            }
            this._sampleNewSprite.tint = this._new.color = color;
            this._inputAndLabelColor.input.value = UtilRgb.toCode(color);
            this.emit("newcolorchange", color, this);
            if (layer) {
                layer.unlock();
                layer.update();
            }
        };
        DPickerColor.prototype.onBaseDown = function (e) {
            this.onBasePick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.on(UtilPointerEvent.up, this._onBaseUpBound);
            }
        };
        DPickerColor.prototype.onBaseMove = function (e) {
            this.onBasePick(e.data.global);
        };
        DPickerColor.prototype.onBaseUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.off(UtilPointerEvent.up, this._onBaseUpBound);
            }
        };
        DPickerColor.prototype.toBaseHex = function (t, shift) {
            return Math.max(0, Math.min(255, t * 6 * 255)) << shift;
        };
        DPickerColor.prototype.toBaseColor = function (t) {
            if (t <= 0.167) {
                return 0xff0000 + this.toBaseHex(t, 8);
            }
            else if (t <= 0.333) {
                t = 0.333 - t;
                return 0x00ff00 + this.toBaseHex(t, 16);
            }
            else if (t <= 0.5) {
                t -= 0.333;
                return 0x00ff00 + this.toBaseHex(t, 0);
            }
            else if (t < 0.667) {
                t = 0.667 - t;
                return 0x0000ff + this.toBaseHex(t, 8);
            }
            else if (t < 0.883) {
                t -= 0.667;
                return 0x0000ff + this.toBaseHex(t, 16);
            }
            else {
                t = 0.883 - t;
                return 0xff0000 + this.toBaseHex(t, 0);
            }
        };
        DPickerColor.prototype.onBasePick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = x;
            this.onColorBase(this.toBaseColor(x / mainWidth));
        };
        DPickerColor.prototype.setColorBase = function (h) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, h / 360)) * mainWidth;
            this.onColorBase(UtilHsv.toRgb(h, 255, 255));
        };
        DPickerColor.prototype.onColorBase = function (color) {
            this._mainSprite.tint = this._base = color;
            var mainPointerSprite = this._mainPointerSprite;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            var mainHeight = theme.getMainHeight();
            var padding = this._padding;
            this.onColorNew(this.toMainColor(this._base, mainPointerSprite.x - padding.getLeft(), mainPointerSprite.y - padding.getTop(), mainWidth, mainHeight));
        };
        DPickerColor.prototype.onAlphaDown = function (e) {
            this.onAlphaPick(e.data.global);
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.on(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        };
        DPickerColor.prototype.onAlphaMove = function (e) {
            this.onAlphaPick(e.data.global);
        };
        DPickerColor.prototype.onAlphaUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.off(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        };
        DPickerColor.prototype.onAlphaPick = function (global) {
            var point = this._pointerPoint;
            var padding = this._padding;
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            this._alphaPointerSprite.x = x;
            this.onAlphaNew(x / mainWidth);
        };
        DPickerColor.prototype.setAlphaNew = function (alpha) {
            var theme = this.theme;
            var mainWidth = theme.getMainWidth();
            this._alphaPointerSprite.x = Math.max(0, Math.min(1, alpha)) * mainWidth;
            this.onAlphaNew(alpha);
        };
        DPickerColor.prototype.onAlphaNew = function (alpha) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                layer.lock();
            }
            this._sampleNewSprite.alpha = this._new.alpha = alpha;
            this._inputAndLabelAlpha.input.value = Number(alpha.toFixed(2));
            this.emit("newalphachange", alpha, this);
            if (layer) {
                layer.unlock();
                layer.update();
            }
        };
        DPickerColor.prototype.onRecentChange = function () {
            var sprites = this._recentColorSprites;
            var recent = this._recent;
            for (var i = 0, imax = sprites.length; i < imax; ++i) {
                var sprite = sprites[i];
                var colorAndAlpha = recent.get(i);
                if (colorAndAlpha != null) {
                    sprite.tint = colorAndAlpha.color;
                    sprite.alpha = colorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
            }
        };
        DPickerColor.prototype.getType = function () {
            return "DPickerColor";
        };
        DPickerColor.RECENT_COLORS = null;
        return DPickerColor;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var isEqual = function (a, b) {
        if (a.direction !== b.direction) {
            return false;
        }
        var ap = a.points;
        var bp = b.points;
        if (ap.length !== bp.length) {
            return false;
        }
        for (var j = 0, jmax = ap.length; j < jmax; ++j) {
            var apj = ap[j];
            var bpj = bp[j];
            if (apj.color !== bpj.color || apj.alpha !== bpj.alpha || apj.position !== bpj.position) {
                return false;
            }
        }
        return true;
    };
    var DPickerColorGradientRecent = /** @class */ (function (_super) {
        __extends(DPickerColorGradientRecent, _super);
        function DPickerColorGradientRecent(recents, capacity) {
            var _this = _super.call(this) || this;
            _this._recents = recents;
            _this._capacity = capacity;
            return _this;
        }
        DPickerColorGradientRecent.prototype.getCapacity = function () {
            return this._capacity;
        };
        DPickerColorGradientRecent.prototype.get = function (index) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.set = function (index, points) {
            var recents = this._recents;
            if (0 <= index && index < recents.length) {
                var result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = points;
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.contains = function (points) {
            var recents = this._recents;
            for (var i = 0, imax = recents.length; i < imax; ++i) {
                if (isEqual(recents[i], points)) {
                    return true;
                }
            }
            return false;
        };
        DPickerColorGradientRecent.prototype.add = function (points) {
            var recents = this._recents;
            recents.push(points);
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        };
        DPickerColorGradientRecent.prototype.pop = function () {
            var recents = this._recents;
            var result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        };
        DPickerColorGradientRecent.prototype.size = function () {
            return this._recents.length;
        };
        return DPickerColorGradientRecent;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var VERTEX_SHADER = "\nattribute vec2 aPosition;\nattribute vec2 aUv;\nattribute vec4 aColor;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\n\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nvoid main(void) {\n\tvec3 position = vec3(aPosition.x, aPosition.y, 1.0);\n\tgl_Position = vec4((projectionMatrix * translationMatrix * position).xy, 0.0, 1.0);\n\tvUv = aUv;\n\tvColor = aColor;\n}\n";
    var FRAGMENT_SHADER = "\nvarying vec2 vUv;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\nuniform vec2 uCheckerColors;\n\nvoid main(void) {\n\tvec4 texture = texture2D(uSampler, vUv);\n\tfloat cy = step( 1.0, mod( gl_FragCoord.y / 10.0, 2.0 ) );\n\tfloat cx = step( 1.0, mod( gl_FragCoord.x / 10.0 + cy, 2.0 ) );\n\tfloat c = mix( uCheckerColors.x, uCheckerColors.y, cx );\n\tgl_FragColor = texture * vec4( mix( vec3( c ), vColor.xyz, vColor.a ), 1.0 );\n}";
    var DPickerColorGradientView = /** @class */ (function (_super) {
        __extends(DPickerColorGradientView, _super);
        function DPickerColorGradientView(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader) {
            var _this = _super.call(this, geometry, shader) || this;
            _this.interactive = true;
            _this.interactiveChildren = false;
            _this.cursor = "pointer";
            _this._nPointsPerData = nPointsPerData;
            _this._vertices = vertices;
            _this._uvs = uvs;
            _this._colors = colors;
            _this._indices = indices;
            _this._lastHitIndex = -1;
            _this._workColor = [0, 0, 0];
            _this._workPoint = new pixi_js.Point();
            _this._parts = parts;
            shader.uniforms.uSampler.on("update", function () {
                _this.update();
                DApplications.update(_this);
            });
            _this.update();
            return _this;
        }
        DPickerColorGradientView.prototype.getRectangle = function (index) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].rect;
            }
            return null;
        };
        DPickerColorGradientView.prototype.setRectangle = function (index, x, y, width, height) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                var rect = parts[index].rect;
                rect.x = x;
                rect.y = y;
                rect.width = width;
                rect.height = height;
            }
        };
        DPickerColorGradientView.prototype.getData = function (index) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].data;
            }
            return null;
        };
        DPickerColorGradientView.prototype.setData = function (index, data) {
            var parts = this._parts;
            if (0 <= index && index < parts.length) {
                parts[index].data = data;
            }
        };
        DPickerColorGradientView.prototype.getLastHitIndex = function () {
            return this._lastHitIndex;
        };
        DPickerColorGradientView.prototype.setColors = function (ic, colors, rgb, alpha) {
            colors[ic + 0] = rgb[0];
            colors[ic + 1] = rgb[1];
            colors[ic + 2] = rgb[2];
            colors[ic + 3] = alpha;
            colors[ic + 4] = rgb[0];
            colors[ic + 5] = rgb[1];
            colors[ic + 6] = rgb[2];
            colors[ic + 7] = alpha;
        };
        DPickerColorGradientView.prototype.setColorsHex = function (ic, colors, color, alpha) {
            var rgb = pixi_js.utils.hex2rgb(color, this._workColor);
            this.setColors(ic, colors, rgb, alpha);
        };
        DPickerColorGradientView.prototype.setColorsWhite = function (ic, colors) {
            var rgb = this._workColor;
            rgb[0] = 1;
            rgb[1] = 1;
            rgb[2] = 1;
            this.setColors(ic, colors, rgb, 0);
        };
        DPickerColorGradientView.prototype.setColorsPoint = function (ic, data, index, colors) {
            var point = data.points[index];
            if (point != null) {
                this.setColorsHex(ic, colors, point.color, point.alpha);
            }
            else {
                this.setColorsWhite(ic, colors);
            }
        };
        DPickerColorGradientView.prototype.setVertices = function (iv, vertices, position, rect) {
            var y = rect.y + rect.height * position;
            vertices[iv + 0] = rect.x;
            vertices[iv + 1] = y;
            vertices[iv + 2] = rect.x + rect.width;
            vertices[iv + 3] = y;
        };
        DPickerColorGradientView.prototype.setUvs = function (iv, uvs, position, textureUvs) {
            var x0 = textureUvs.x0 + (textureUvs.x3 - textureUvs.x0) * position;
            var y0 = textureUvs.y0 + (textureUvs.y3 - textureUvs.y0) * position;
            var x1 = textureUvs.x1 + (textureUvs.x2 - textureUvs.x1) * position;
            var y1 = textureUvs.y1 + (textureUvs.y2 - textureUvs.y1) * position;
            uvs[iv + 0] = x0;
            uvs[iv + 1] = y0;
            uvs[iv + 2] = x1;
            uvs[iv + 3] = y1;
        };
        DPickerColorGradientView.prototype.newIndices = function (ii, iv, size, indices) {
            for (var i = 0; i < size; ++i) {
                indices[ii + 0] = iv + 0;
                indices[ii + 1] = iv + 1;
                indices[ii + 2] = iv + 2;
                indices[ii + 3] = iv + 2;
                indices[ii + 4] = iv + 1;
                indices[ii + 5] = iv + 3;
                ii += 6;
                iv += 2;
            }
            return indices;
        };
        DPickerColorGradientView.prototype._calculateBounds = function () {
            var worldTransform = this.transform.worldTransform;
            var rect = this._parts[0].rect;
            var bounds = this._bounds;
            var work = this._workPoint;
            work.set(rect.x, rect.y);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(rect.x + rect.width, rect.y + rect.height);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
        };
        DPickerColorGradientView.prototype.update = function () {
            var vertices = this._vertices;
            var uvs = this._uvs;
            var colors = this._colors;
            var indices = this._indices;
            var texture = this.shader.uniforms.uSampler;
            if (texture._uvs == null) {
                texture.updateUvs();
            }
            var textureUvs = texture._uvs;
            var iv = 0;
            var nv = 0;
            var ic = 0;
            var ii = 0;
            var parts = this._parts;
            for (var i = 0, imax = parts.length; i < imax; ++i) {
                var data = parts[i].data;
                var rect = parts[i].rect;
                if (data == null) {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsWhite(ic, colors);
                    this.setVertices(iv + 4, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsWhite(ic + 8, colors);
                    this.newIndices(ii, nv, 1, indices);
                    iv += 4 * 2;
                    ic += 4 * 4;
                    nv += 4;
                    ii += 6;
                }
                else {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsPoint(ic, data, 0, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    var pointSize = data.points.length;
                    for (var j = 0, jmax = Math.min(pointSize, this._nPointsPerData); j < jmax; ++j) {
                        var point = data.points[j];
                        this.setVertices(iv, vertices, point.position, rect);
                        this.setUvs(iv, uvs, point.position, textureUvs);
                        this.setColorsHex(ic, colors, point.color, point.alpha);
                        iv += 2 * 2;
                        ic += 2 * 4;
                    }
                    this.setVertices(iv, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsPoint(ic, data, pointSize - 1, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    this.newIndices(ii, nv, pointSize + 1, indices);
                    ii += (pointSize + 1) * 6;
                    nv += (pointSize + 2) * 2;
                }
            }
            this.size = ii;
            var geometry = this.geometry;
            geometry.getBuffer("aPosition").update();
            geometry.getBuffer("aUv").update();
            geometry.getBuffer("aColor").update();
            geometry.getIndex().update();
        };
        DPickerColorGradientView.prototype.containsPoint = function (point) {
            var local = this.toLocal(point, undefined, this._workPoint);
            var parts = this._parts;
            for (var i = 0, imax = parts.length; i < imax; ++i) {
                var rect = parts[i].rect;
                if (rect.contains(local.x, local.y)) {
                    this._lastHitIndex = i;
                    return true;
                }
            }
            return false;
        };
        DPickerColorGradientView.from = function (size, nPointsPerData, checkerColors, texture) {
            if (texture === void 0) { texture = pixi_js.Texture.WHITE; }
            var vertices = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            var uvs = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            var colors = new Float32Array(size * (nPointsPerData + 2) * 2 * 4);
            var indices = new Uint16Array(size * (nPointsPerData + 1) * 6);
            var parts = [];
            for (var i = 0; i < size; ++i) {
                parts.push({
                    data: null,
                    rect: new pixi_js.Rectangle()
                });
            }
            var geometry = new pixi_js.Geometry()
                .addIndex(new pixi_js.Buffer(indices, false, true))
                .addAttribute("aPosition", new pixi_js.Buffer(vertices, false, false), 2)
                .addAttribute("aUv", new pixi_js.Buffer(uvs, false, false), 2)
                .addAttribute("aColor", new pixi_js.Buffer(colors, false, false), 4);
            var shader = pixi_js.Shader.from(VERTEX_SHADER, FRAGMENT_SHADER, {
                uSampler: texture,
                uCheckerColors: checkerColors
            });
            return new DPickerColorGradientView(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader);
        };
        return DPickerColorGradientView;
    }(pixi_js.Mesh));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerColorGradient = /** @class */ (function (_super) {
        __extends(DPickerColorGradient, _super);
        function DPickerColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPickerColorGradient.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var theme = this.theme;
            var padding = this._padding;
            var paddingTop = padding.getTop();
            var paddingRight = padding.getRight();
            var paddingBottom = padding.getBottom();
            var paddingLeft = padding.getLeft();
            this._work = new pixi_js.Point();
            // Picker
            var gradientPointsWidth = theme.getGradientPointsWidth();
            var gradientPointsMargin = theme.getGradientPointsMargin();
            var picker = new DPickerColor({
                x: paddingLeft + gradientPointsWidth + gradientPointsMargin,
                y: paddingTop
            });
            this._picker = picker;
            picker.on("newcolorchange", function (color) {
                _this.onAnchorColorChange(color);
            });
            picker.on("newalphachange", function (alpha) {
                _this.onAnchorAlphaChange(alpha);
            });
            this.addChild(picker);
            // Points view
            var view = (this._view = DPickerColorGradientView.from(17, 10, theme.getGradientCheckerColors()));
            view.setRectangle(0, paddingLeft, paddingTop, gradientPointsWidth, picker.height);
            this.addChild(view);
            view.on(UtilPointerEvent.down, function (e) {
                if (view.getLastHitIndex() === 0) {
                    _this.onViewDown(e);
                }
            });
            // Anchor
            this._onAnchorDownBound = function (e) {
                _this.onAnchorDown(e);
            };
            this._onAnchorMoveBound = function (e) {
                _this.onAnchorMove(e);
            };
            this._onAnchorUpBound = function (e) {
                _this.onAnchorUp(e);
            };
            this._anchors = [];
            //
            var recentColumn = theme.getGradientRecentColumn();
            var recentWidth = theme.getGradientRecentWidth();
            var recentMargin = theme.getGradientRecentMargin();
            var recentWidthAndMargin = recentWidth + recentMargin;
            var inputLabelWidth = picker.theme.getInputLabelWidth();
            var inputWidth = recentWidth * recentColumn + recentMargin * (recentColumn - 1);
            var inputMargin = 5;
            var inputDirectionMargin = theme.getGradientDirectionMargin();
            var inputDirectionTexture = theme.getGradientDirectionTexture();
            var inputLeft = picker.x + picker.width + inputDirectionMargin;
            var inputDirection = new DInputReal({
                parent: this,
                x: inputLeft + inputLabelWidth + inputMargin,
                y: paddingTop,
                width: inputWidth - (inputLabelWidth + inputMargin) * 2,
                step: 1,
                image: {
                    source: inputDirectionTexture,
                    align: {
                        with: DAlignWith.BORDER
                    },
                    margin: {
                        horizontal: -inputDirectionTexture.width - inputMargin
                    }
                },
                on: {
                    change: function (value) {
                        _this._value._direction = value;
                    }
                }
            });
            // Recent gradients
            var x0 = inputLeft;
            var y0 = inputDirection.y + inputDirection.height + inputDirectionMargin;
            if (DPickerColorGradient.RECENT_COLOR_GRADIENT == null) {
                DPickerColorGradient.RECENT_COLOR_GRADIENT = new DPickerColorGradientRecent(theme.getGradientRecents(), theme.getGradientRecentCount());
            }
            this._recent = DPickerColorGradient.RECENT_COLOR_GRADIENT;
            var recent = this._recent;
            for (var i = 0, imax = recent.getCapacity(); i < imax; ++i) {
                var ix = i % recentColumn;
                var x = x0 + ix * recentWidthAndMargin;
                var iy = (i / recentColumn) | 0;
                var y = y0 + iy * recentWidthAndMargin;
                view.setRectangle(1 + i, x, y, recentWidth, recentWidth);
            }
            recent.on("change", function () {
                _this.onRecentUpdate();
            });
            view.on(UtilPointerEvent.tap, function (e) {
                var lastHitIndex = view.getLastHitIndex();
                if (1 <= lastHitIndex) {
                    _this.onRecentClick(view.getData(lastHitIndex));
                }
            });
            // Points
            var data = new DColorGradientObservable();
            this._value = data;
            data.on("change", function () {
                _this.updateAnchors();
                view.update();
            });
            data.on("selectionchange", function (point) {
                _this.onAnchorSelect(point);
            });
            data.on("directionchange", function (value) {
                inputDirection.value = value;
            });
            view.setData(0, data);
            view.update();
            inputDirection.value = data.direction;
            this.updateAnchors();
            var selected = data.selected;
            if (selected != null) {
                this.onAnchorSelect(selected);
            }
            // Width
            if (options == null || options.width == null) {
                this.width =
                    paddingLeft +
                        gradientPointsWidth +
                        gradientPointsMargin +
                        picker.width +
                        inputDirectionMargin +
                        (recentColumn - 1) * recentMargin +
                        recentColumn * recentWidth +
                        paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height = paddingTop + picker.height + paddingBottom;
            }
        };
        Object.defineProperty(DPickerColorGradient.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPickerColorGradient.prototype, "recent", {
            get: function () {
                return this._recent;
            },
            enumerable: false,
            configurable: true
        });
        DPickerColorGradient.prototype.onRecentClick = function (recentData) {
            var value = this._value;
            if (recentData != null) {
                value.fromObject(recentData);
            }
            else {
                value.reset();
            }
        };
        DPickerColorGradient.prototype.onRecentUpdate = function () {
            var recent = this._recent;
            var view = this._view;
            for (var i = 0, imax = recent.size(); i < imax; ++i) {
                view.setData(1 + i, recent.get(i));
            }
            view.update();
            DApplications.update(this);
        };
        DPickerColorGradient.prototype.toAnchorPosition = function (e) {
            var local = this.toLocal(e.data.global, undefined, this._work);
            return Math.max(0, Math.min(1, (local.y - this.padding.getTop()) / this._picker.height));
        };
        DPickerColorGradient.prototype.onViewDown = function (e) {
            this._value.addAt(this.toAnchorPosition(e));
            this.onAnchorDragStart();
        };
        DPickerColorGradient.prototype.onAnchorDown = function (e) {
            var target = e.target;
            if (target instanceof pixi_js.Sprite) {
                var value = this._value;
                var index = this._anchors.indexOf(target);
                if (0 <= index && index < value.points.length) {
                    value.points[index].selected = true;
                    this.onAnchorDragStart();
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorSelect = function (point) {
            var picker = this._picker;
            picker.current.color = point.color;
            picker.current.alpha = point.alpha;
            picker.new.color = point.color;
            picker.new.alpha = point.alpha;
        };
        DPickerColorGradient.prototype.onAnchorColorChange = function (color) {
            var value = this._value;
            if (value != null) {
                var selected = value.selected;
                if (selected != null) {
                    selected.color = color;
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorAlphaChange = function (alpha) {
            var value = this._value;
            if (value != null) {
                var selected = value.selected;
                if (selected != null) {
                    selected.alpha = alpha;
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorDragStart = function () {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.on(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        };
        DPickerColorGradient.prototype.onAnchorMove = function (e) {
            var value = this._value;
            if (value != null) {
                var selected = value.selected;
                if (selected != null) {
                    selected.position = this.toAnchorPosition(e);
                }
            }
        };
        DPickerColorGradient.prototype.onAnchorUp = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.off(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        };
        DPickerColorGradient.prototype.updateAnchors = function () {
            var theme = this.theme;
            var anchorTexture = theme.getGradientAnchorTexture();
            var anchorOutlinedTexture = theme.getGradientAnchorOutlinedTexture();
            var gradientPointsWidth = theme.getGradientPointsWidth();
            var value = this._value;
            var pointSize = value.points.length;
            var anchors = this._anchors;
            var anchorSize = anchors.length;
            for (var i = anchorSize; i < pointSize; ++i) {
                var newAnchor = new pixi_js.Sprite(anchorTexture);
                newAnchor.anchor.set(0.5, 0.5);
                newAnchor.cursor = "pointer";
                newAnchor.interactive = true;
                newAnchor.on(UtilPointerEvent.down, this._onAnchorDownBound);
                anchors.push(newAnchor);
                this.addChild(newAnchor);
            }
            for (var i = anchorSize - 1; pointSize <= i; --i) {
                var oldAnchor = anchors[i];
                oldAnchor.off(UtilPointerEvent.down, this._onAnchorDownBound);
                oldAnchor.destroy();
            }
            anchors.length = pointSize;
            var y = this.padding.getTop();
            var right = this.padding.getLeft() + gradientPointsWidth;
            var height = this._picker.height;
            for (var i = 0; i < pointSize; ++i) {
                var point = value.points[i];
                var anchor = anchors[i];
                anchor.tint = point.color;
                anchor.position.set(right, y + height * point.position);
                anchor.texture = point.selected ? anchorOutlinedTexture : anchorTexture;
            }
            DApplications.update(this);
        };
        DPickerColorGradient.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isDeleteKey(e)) {
                var value = this._value;
                if (value != null) {
                    var selected = value.selected;
                    if (selected != null) {
                        value.remove(selected);
                        _super.prototype.onKeyDown.call(this, e);
                        return true;
                    }
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DPickerColorGradient.prototype.getType = function () {
            return "DPickerColorGradient";
        };
        DPickerColorGradient.RECENT_COLOR_GRADIENT = null;
        return DPickerColorGradient;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogColorGradient = /** @class */ (function (_super) {
        __extends(DDialogColorGradient, _super);
        function DDialogColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogColorGradient.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        DDialogColorGradient.prototype.onOk = function (value) {
            _super.prototype.onOk.call(this, value);
            var picker = this.picker;
            var data = picker.value;
            var recent = picker.recent;
            if (!recent.contains(data)) {
                recent.add(data.toObject());
            }
        };
        Object.defineProperty(DDialogColorGradient.prototype, "value", {
            get: function () {
                return this.picker.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColorGradient.prototype, "recent", {
            get: function () {
                return this.picker.recent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColorGradient.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerColorGradient((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogColorGradient.prototype.getResolvedValue = function () {
            return this.picker.value;
        };
        DDialogColorGradient.prototype.onKeyDown = function (e) {
            this.picker.onKeyDown(e);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDialogColorGradient.prototype.getType = function () {
            return "DDialogColorGradient";
        };
        return DDialogColorGradient;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonColorGradient = /** @class */ (function (_super) {
        __extends(DButtonColorGradient, _super);
        function DButtonColorGradient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonColorGradient.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            var source = (_a = options === null || options === void 0 ? void 0 : options.image) === null || _a === void 0 ? void 0 : _a.source;
            if (source === undefined) {
                var theme = this.theme;
                var texture = theme.getViewBaseTexture();
                if (texture instanceof pixi_js.Texture) {
                    var checkers = theme.getCheckerColors();
                    var view = DPickerColorGradientView.from(1, 10, checkers, texture);
                    this._view = view;
                    view.setRectangle(0, 0, 0, texture.width, texture.height);
                    view.setData(0, this._textValueComputed);
                    view.update();
                    this.image = view;
                }
            }
        };
        DButtonColorGradient.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            var value = this._textValueComputed;
            var dialog = this.dialog;
            if (value != null) {
                dialog.value.fromObject(value);
            }
            dialog.open(this).then(function (newValue) {
                _this.onValueChange(newValue, _this.toClone(value));
            });
        };
        DButtonColorGradient.prototype.toClone = function (value) {
            var result = new DColorGradientObservable();
            if (value != null) {
                result.fromObject(value);
            }
            return result;
        };
        DButtonColorGradient.prototype.onValueChange = function (newValue, oldValue) {
            var value = this._textValueComputed;
            if (value != null) {
                value.fromObject(newValue);
            }
            var view = this._view;
            if (view != null) {
                view.update();
            }
            this.onTextChange();
            this.createOrUpdateText();
            DApplications.update(this);
            this.emit("change", newValue, oldValue, this);
        };
        Object.defineProperty(DButtonColorGradient.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonColorGradient.DIALOG == null) {
                            DButtonColorGradient.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonColorGradient.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColorGradient.prototype.newDialog = function (options) {
            return new DDialogColorGradient(options);
        };
        Object.defineProperty(DButtonColorGradient.prototype, "value", {
            get: function () {
                return this._textValueComputed;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColorGradient.prototype.getType = function () {
            return "DButtonColorGradient";
        };
        return DButtonColorGradient;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogColor = /** @class */ (function (_super) {
        __extends(DDialogColor, _super);
        function DDialogColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogColor.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.picker);
            return result;
        };
        DDialogColor.prototype.onOk = function (value) {
            _super.prototype.onOk.call(this, value);
            var picker = this.picker;
            var recent = picker.recent;
            if (!recent.contains(picker.new)) {
                recent.add(picker.new);
            }
        };
        Object.defineProperty(DDialogColor.prototype, "current", {
            get: function () {
                return this.picker.current;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "new", {
            get: function () {
                return this.picker.new;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "recent", {
            get: function () {
                return this.picker.recent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDialogColor.prototype, "picker", {
            get: function () {
                var _a;
                var result = this._picker;
                if (result == null) {
                    result = new DPickerColor((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                    this._picker = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogColor.prototype.getResolvedValue = function () {
            return this.picker.new;
        };
        DDialogColor.prototype.getType = function () {
            return "DDialogColor";
        };
        return DDialogColor;
    }(DDialogFitted));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonColor = /** @class */ (function (_super) {
        __extends(DButtonColor, _super);
        function DButtonColor() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonColor.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            var dialog = this.dialog;
            var value = this._textValueComputed;
            if (value != null) {
                var dialogCurrent = dialog.current;
                dialogCurrent.color = value.color;
                dialogCurrent.alpha = value.alpha;
                var dialogNew = dialog.new;
                dialogNew.color = value.color;
                dialogNew.alpha = value.alpha;
            }
            dialog.open(this).then(function () {
                _this.onValueChange(_this.toClone(dialog.new), _this.toClone(dialog.current));
            });
        };
        DButtonColor.prototype.toClone = function (value) {
            return {
                color: value.color,
                alpha: value.alpha
            };
        };
        DButtonColor.prototype.onValueChange = function (newValue, oldValue) {
            var value = this._textValueComputed;
            if (value != null) {
                value.color = newValue.color;
                value.alpha = newValue.alpha;
            }
            this.onColorChange();
            this.emit("change", newValue, oldValue, this);
        };
        DButtonColor.prototype.toImageTintOptions = function (tint) {
            var _this = this;
            var color = function () { return _this._textValueComputed.color; };
            if (tint) {
                return {
                    color: tint.color || color,
                    alpha: tint.alpha
                };
            }
            return {
                color: color
            };
        };
        DButtonColor.prototype.toImageOptions = function (theme, options) {
            if (options) {
                return {
                    source: options.source,
                    tint: this.toImageTintOptions(options.tint),
                    align: options.align,
                    margin: options.margin
                };
            }
            return {
                tint: this.toImageTintOptions()
            };
        };
        DButtonColor.prototype.onColorChange = function () {
            if (this._images[0].updateTint()) {
                DApplications.update(this);
            }
            this.updateTextForcibly();
        };
        DButtonColor.prototype.updateTextForcibly = function () {
            this.onTextChange();
            this.createOrUpdateText();
        };
        Object.defineProperty(DButtonColor.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonColor.DIALOG == null) {
                            DButtonColor.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonColor.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColor.prototype.newDialog = function (options) {
            return new DDialogColor(options);
        };
        Object.defineProperty(DButtonColor.prototype, "value", {
            get: function () {
                var result = this._value;
                if (result == null) {
                    result = this.newValue();
                    this._value = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DButtonColor.prototype.newValue = function () {
            var _this = this;
            var value = this._textValueComputed;
            return new DPickerColorAndAlpha(value, function (color) {
                value.color = color;
                _this.onColorChange();
            }, function (alpha) {
                value.alpha = alpha;
                _this.updateTextForcibly();
            });
        };
        DButtonColor.prototype.getType = function () {
            return "DButtonColor";
        };
        return DButtonColor;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDanger = /** @class */ (function (_super) {
        __extends(DButtonDanger, _super);
        function DButtonDanger() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDanger.prototype.getType = function () {
            return "DButtonDanger";
        };
        return DButtonDanger;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDate = /** @class */ (function (_super) {
        __extends(DButtonDate, _super);
        function DButtonDate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDate.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this._textValueComputed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open(this).then(function () {
                _this.onValueChange(dialog.new, dialog.current);
            });
        };
        DButtonDate.prototype.onValueChange = function (newValue, oldValue) {
            this.text = new Date(newValue.getTime());
            this.emit("change", newValue, oldValue, this);
        };
        Object.defineProperty(DButtonDate.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonDate.DIALOG == null) {
                            DButtonDate.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonDate.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonDate.prototype.newDialog = function (options) {
            return new DDialogDate(options);
        };
        Object.defineProperty(DButtonDate.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : new Date();
            },
            set: function (value) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed === undefined || textValueComputed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonDate.prototype.getType = function () {
            return "DButtonDate";
        };
        return DButtonDate;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDates = /** @class */ (function () {
        function DPickerDates() {
        }
        DPickerDates.format = function (date) {
            var y = toPadded(String(date.getFullYear()), 4, "0");
            var M = toPadded(String(date.getMonth() + 1), 2, "0");
            var S = toPadded(String(date.getDate()), 2, "0");
            return "".concat(y, "/").concat(M, "/").concat(S);
        };
        return DPickerDates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimes = /** @class */ (function () {
        function DPickerTimes() {
        }
        DPickerTimes.format = function (date, mask) {
            var result = "";
            if (mask & DPickerDatetimeMask.HOURS) {
                result += toPadded(String(date.getHours()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getMinutes()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getSeconds()), 2, "0");
            }
            return result;
        };
        DPickerTimes.toMask = function (options) {
            return DPickerDatetimeMasks.from("DPickerTime", options);
        };
        return DPickerTimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimes = /** @class */ (function () {
        function DPickerDatetimes() {
        }
        DPickerDatetimes.format = function (date, mask) {
            var hms = DPickerTimes.format(date, mask);
            if (0 < hms.length) {
                return "".concat(DPickerDates.format(date), " ").concat(hms);
            }
            else {
                return "".concat(DPickerDates.format(date));
            }
        };
        DPickerDatetimes.toMask = function (options) {
            return DPickerDatetimeMasks.from("DPickerDatetime", options);
        };
        return DPickerDatetimes;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonDatetime = /** @class */ (function (_super) {
        __extends(DButtonDatetime, _super);
        function DButtonDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonDatetime.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this._textValueComputed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open(this).then(function () {
                _this.onValueChange(dialog.new, dialog.current);
            });
        };
        DButtonDatetime.prototype.onValueChange = function (newValue, oldValue) {
            this.text = new Date(newValue.getTime());
            this.emit("change", newValue, oldValue, this);
        };
        DButtonDatetime.prototype.getDatetimeMask = function () {
            var _a, _b;
            var result = this._datetimeMask;
            if (result == null) {
                result = DPickerDatetimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        };
        Object.defineProperty(DButtonDatetime.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonDatetime.DIALOG == null) {
                            DButtonDatetime.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonDatetime.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonDatetime.prototype.newDialog = function (options) {
            return new DDialogDatetime(options);
        };
        Object.defineProperty(DButtonDatetime.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : new Date();
            },
            set: function (value) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed === undefined || textValueComputed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonDatetime.prototype.getType = function () {
            return "DButtonDatetime";
        };
        return DButtonDatetime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A file selector.
     */
    var DButtonFile = /** @class */ (function (_super) {
        __extends(DButtonFile, _super);
        function DButtonFile() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonFile.prototype.getChecker = function () {
            var _a, _b;
            var result = this._checker;
            if (result === undefined) {
                result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.checker) !== null && _b !== void 0 ? _b : null;
                this._checker = result;
            }
            return result;
        };
        DButtonFile.prototype.getOpener = function () {
            var result = this._opener;
            if (result == null) {
                result = this.newOpener();
                this._opener = result;
            }
            return result;
        };
        DButtonFile.prototype.newOpener = function () {
            var _a, _b;
            return new UtilFileOpener(toEnum((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.as) !== null && _b !== void 0 ? _b : UtilFileAs.TEXT, UtilFileAs), this);
        };
        DButtonFile.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            this.check(function () {
                _this.open();
            });
        };
        DButtonFile.prototype.check = function (onResolve) {
            var checker = this.getChecker();
            if (checker != null) {
                var result = checker();
                if (result === true) {
                    onResolve();
                }
                else if (result === false) ;
                else {
                    result.then(function () {
                        onResolve();
                    });
                }
            }
            else {
                onResolve();
            }
        };
        DButtonFile.prototype.open = function () {
            this.getOpener().open();
        };
        DButtonFile.prototype.getType = function () {
            return "DButtonFile";
        };
        return DButtonFile;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonLink = /** @class */ (function (_super) {
        __extends(DButtonLink, _super);
        function DButtonLink() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonLink.prototype.onClick = function (e) {
            if (!this.link.onClick(this, e)) {
                _super.prototype.onClick.call(this, e);
            }
        };
        Object.defineProperty(DButtonLink.prototype, "link", {
            get: function () {
                var result = this._link;
                if (result == null) {
                    result = new DLink(this._options);
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DButtonLink.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.link.open(e);
        };
        DButtonLink.prototype.open = function (inNewWindow) {
            this.link.open(inNewWindow);
        };
        DButtonLink.prototype.getType = function () {
            return "DButtonLink";
        };
        return DButtonLink;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRadio = /** @class */ (function (_super) {
        __extends(DButtonRadio, _super);
        function DButtonRadio() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonRadio.prototype.getType = function () {
            return "DButtonRadio";
        };
        return DButtonRadio;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRadioRight = /** @class */ (function (_super) {
        __extends(DButtonRadioRight, _super);
        function DButtonRadioRight() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonRadioRight.prototype.getType = function () {
            return "DButtonRadioRight";
        };
        return DButtonRadioRight;
    }(DButtonRadio));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonRedo = /** @class */ (function (_super) {
        __extends(DButtonRedo, _super);
        function DButtonRedo(options) {
            var _this = _super.call(this, options) || this;
            var state = _this.state;
            var commandController = DControllers.getCommandController();
            state.isDisabled = !commandController.isRedoable();
            commandController.on("change", function () {
                state.isDisabled = !commandController.isRedoable();
            });
            return _this;
        }
        DButtonRedo.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            DControllers.getCommandController().redo();
        };
        return DButtonRedo;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonSecondary = /** @class */ (function (_super) {
        __extends(DButtonSecondary, _super);
        function DButtonSecondary() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonSecondary.prototype.getType = function () {
            return "DButtonSecondary";
        };
        return DButtonSecondary;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DListDataSelection} type.
     */
    var DListDataSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItem = /** @class */ (function (_super) {
        __extends(DListItem, _super);
        function DListItem(data, options) {
            var _this = _super.call(this, options) || this;
            _this._data = data;
            _this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
            return _this;
        }
        Object.defineProperty(DListItem.prototype, "link", {
            get: function () {
                var result = this._link;
                if (result === undefined) {
                    result = this.newLink();
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DListItem.prototype.newLink = function () {
            var link = this._data.accessor.link;
            if (link) {
                return new DLink(this.toLinkOptions(link));
            }
            return null;
        };
        DListItem.prototype.onClick = function (e) {
            var _a;
            if (((_a = this.link) === null || _a === void 0 ? void 0 : _a.onClick(this, e)) !== true) {
                if (this.state.isActionable) {
                    this.activate(e);
                }
            }
        };
        DListItem.prototype.activate = function (e) {
            var value = this._value;
            if (value !== undefined) {
                this.onSelect(e, value);
            }
        };
        DListItem.prototype.toLinkOptions = function (accessor) {
            return {
                url: this.toLinkUrl(accessor.toUrl),
                target: accessor.target,
                checker: this.toLinkChecker(accessor.checker)
            };
        };
        DListItem.prototype.toLinkUrl = function (toUrl) {
            var _this = this;
            return function () {
                var value = _this._value;
                if (value !== undefined) {
                    return toUrl(value);
                }
            };
        };
        DListItem.prototype.toLinkChecker = function (checker) {
            var _this = this;
            if (checker) {
                return function () {
                    var value = _this._value;
                    if (value != null) {
                        return checker(value);
                    }
                    return false;
                };
            }
            return undefined;
        };
        Object.defineProperty(DListItem.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListItem.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        DListItem.prototype.onSelect = function (e, value) {
            var _a;
            this.emit("select", value, this);
            var data = this._data;
            var selection = data.selection;
            if (selection.type !== DListDataSelectionType.MULTIPLE) {
                selection.clearAndAdd(value);
            }
            else {
                var originalEvent = e && "data" in e ? e.data.originalEvent : e;
                if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.ctrlKey) {
                    selection.toggle(value);
                }
                else if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.shiftKey) {
                    var mapped = data.mapped;
                    var last_1 = selection.last;
                    if (value === last_1) {
                        selection.clearAndAdd(value);
                    }
                    else {
                        var isFound_1 = false;
                        var isReverse_1 = false;
                        var newSelection_1 = [];
                        mapped.each(function (item) {
                            if (isFound_1) {
                                if (isReverse_1) {
                                    newSelection_1.unshift(item);
                                    if (item === value) {
                                        return false;
                                    }
                                }
                                else {
                                    newSelection_1.push(item);
                                    if (item === last_1) {
                                        return false;
                                    }
                                }
                            }
                            else {
                                if (item === value) {
                                    isFound_1 = true;
                                    isReverse_1 = false;
                                    newSelection_1.push(item);
                                }
                                else if (item === last_1) {
                                    isFound_1 = true;
                                    isReverse_1 = true;
                                    newSelection_1.push(item);
                                }
                            }
                        });
                        selection.clearAndAddAll(newSelection_1);
                    }
                }
                else {
                    selection.clearAndAdd(value);
                }
            }
            (_a = this._link) === null || _a === void 0 ? void 0 : _a.open(e);
        };
        DListItem.prototype.set = function (value, index, forcibly) {
            var data = this._data;
            var isValueChanged = forcibly || this._value !== value;
            if (isValueChanged) {
                this._value = value;
                this._index = index;
                var accessor = data.accessor;
                this.text = accessor.toLabel(value);
                this.title = accessor.toTitle(value) || "";
                this.image = accessor.toImage(value);
            }
            var state = this.state;
            state.lock();
            state.set(DBaseState.ACTIVE, data.selection.contains(value));
            state.remove(DBaseState.DISABLED);
            state.unlock();
            if (isValueChanged) {
                this.emit("set", value, index, this);
            }
        };
        DListItem.prototype.unset = function () {
            if (this._value !== undefined) {
                this._value = undefined;
                this._index = undefined;
                this.text = undefined;
                this.title = "";
                this.image = undefined;
                var state = this.state;
                state.lock();
                state.add(DBaseState.DISABLED);
                state.remove(DBaseState.ACTIVE);
                state.unlock();
                this.emit("unset", this);
            }
        };
        DListItem.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DListItem.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.activate(e);
                return true;
            }
            return false;
        };
        DListItem.prototype.getType = function () {
            return "DListItem";
        };
        return DListItem;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectListItem = /** @class */ (function (_super) {
        __extends(DDialogSelectListItem, _super);
        function DDialogSelectListItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelectListItem.prototype.getType = function () {
            return "DDialogSelectListItem";
        };
        return DDialogSelectListItem;
    }(DListItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * The primary purpose of this class is to minimize the number of rendered items (e.g., {@link DListItem})
     * as low as possible and to update their positions and states. For this sake, the updater calculates the
     * required number of items whenever their container size changes and creates items if needed.
     */
    var DItemUpdater = /** @class */ (function () {
        function DItemUpdater(data, content, container, options) {
            this._updateItemsCount = 0;
            this._isUpdateItemsCalled = false;
            this._isUpdateItemsCalledForcibly = false;
            this._itemHeight = -1;
            this._itemWidth = -1;
            this._multiplicity = 1;
            this._itemIndexStart = 0;
            this._itemIndexEnd = 0;
            this._workItems = [];
            this._data = data;
            this._content = content;
            this._container = container;
            this._newItem = this.toNewItem(options);
            this._initItem = this.toInitItem(options);
        }
        DItemUpdater.prototype.toNewItem = function (options) {
            return (options === null || options === void 0 ? void 0 : options.newItem) || this.newItem;
        };
        DItemUpdater.prototype.toInitItem = function (options) {
            if (options) {
                var initItem = options.initItem;
                if (initItem) {
                    return initItem;
                }
                if (options.stripe !== false) {
                    return this.initItem;
                }
                return this.initItemNoStriping;
            }
            return this.initItem;
        };
        DItemUpdater.prototype.initItem = function (item, index, data) {
            item.state.isAlternated = index % 2 === 1;
            return item;
        };
        DItemUpdater.prototype.initItemNoStriping = function (item, index, data) {
            return item;
        };
        Object.defineProperty(DItemUpdater.prototype, "multiplicity", {
            get: function () {
                return this._multiplicity;
            },
            enumerable: false,
            configurable: true
        });
        DItemUpdater.prototype.lock = function () {
            this._updateItemsCount += 1;
            if (this._updateItemsCount === 1) {
                this._isUpdateItemsCalled = false;
                this._isUpdateItemsCalledForcibly = false;
            }
        };
        DItemUpdater.prototype.unlock = function (callIfNeeded) {
            this._updateItemsCount -= 1;
            if (this._updateItemsCount === 0) {
                if (callIfNeeded && this._isUpdateItemsCalled) {
                    this.update(this._isUpdateItemsCalledForcibly);
                }
                this._isUpdateItemsCalled = false;
                this._isUpdateItemsCalledForcibly = false;
            }
        };
        DItemUpdater.prototype.update = function (forcibly) {
            var _this = this;
            if (0 < this._updateItemsCount) {
                this._isUpdateItemsCalled = true;
                if (forcibly) {
                    this._isUpdateItemsCalledForcibly = true;
                }
                return;
            }
            var content = this._content;
            var contentParent = content.parent;
            if (contentParent == null) {
                return;
            }
            var container = this._container;
            var items = container.children;
            var height = contentParent.height;
            var data = this._data;
            var mapped = this.toMapped(data);
            var dataSize = mapped.size();
            var oldItemIndexStart = this._itemIndexStart;
            var oldItemIndexEnd = this._itemIndexEnd;
            var oldItemCount = oldItemIndexEnd - oldItemIndexStart;
            var newItem = this._newItem;
            var initItem = this._initItem;
            var itemHeight = this._itemHeight;
            var itemWidth = this._itemWidth;
            if (this._itemHeight < 0) {
                var item = void 0;
                if (0 < items.length) {
                    item = items[0];
                }
                else {
                    item = initItem(newItem(data), oldItemIndexStart, data);
                    container.addChild(item);
                    oldItemIndexEnd += 1;
                    oldItemCount += 1;
                }
                itemHeight = Math.max(1, item.height);
                if (isNumber(item.getWidth())) {
                    itemWidth = Math.max(1, item.width);
                }
                this._itemHeight = itemHeight;
                this._itemWidth = itemWidth;
            }
            var contentPadding = content.padding;
            var contentPaddingTop = contentPadding.getTop();
            var contentPaddingBottom = contentPadding.getBottom();
            var contentPaddingLeft = contentPadding.getLeft();
            var contentPaddingRight = contentPadding.getRight();
            var contentWidthAvailable = Math.max(0, content.width - contentPaddingLeft - contentPaddingRight);
            var multiplicity = 0 < itemWidth ? Math.max(1, Math.floor(contentWidthAvailable / itemWidth)) : 1;
            this._multiplicity = multiplicity;
            var y = content !== container ? container.transform.position.y : contentPaddingTop;
            var newHeight = Math.ceil(dataSize / multiplicity) * itemHeight;
            var newContentHeight = Math.max(height, contentPaddingTop + newHeight + contentPaddingBottom);
            var newContentY = Math.max(height - newContentHeight, content.position.y);
            var newItemIndexLowerBound = Math.floor(((0 - (newContentY + y)) * multiplicity) / itemHeight);
            var newItemIndexUpperBound = Math.floor(((height - (newContentY + y)) * multiplicity) / itemHeight);
            var newItemIndexStart = newItemIndexLowerBound - multiplicity;
            if (newItemIndexStart % 2 !== 0) {
                newItemIndexStart -= 1;
            }
            var newItemIndexEnd = newItemIndexUpperBound + multiplicity + multiplicity;
            if (newItemIndexEnd % 2 !== 0) {
                newItemIndexEnd += 1;
            }
            var newItemCount = newItemIndexEnd - newItemIndexStart;
            if (newItemCount < oldItemCount && oldItemCount - 2 <= newItemCount) {
                newItemCount = oldItemCount;
                newItemIndexEnd = newItemIndexStart + newItemCount;
            }
            if (oldItemCount < newItemCount) {
                for (var i = oldItemCount; i < newItemCount; ++i) {
                    var oldItemIndex = oldItemIndexStart + i;
                    var item = initItem(newItem(data), oldItemIndex, data);
                    container.addChild(item);
                }
                oldItemCount = newItemCount;
                oldItemIndexEnd = oldItemIndexStart + oldItemCount;
            }
            else if (newItemCount < oldItemCount) {
                for (var i = oldItemCount - 1; newItemCount <= i; --i) {
                    container.removeChild(items[i]);
                }
                oldItemCount = newItemCount;
                oldItemIndexEnd = oldItemIndexStart + oldItemCount;
            }
            this._itemIndexStart = newItemIndexStart;
            this._itemIndexEnd = newItemIndexEnd;
            var itemIndexStartDelta = newItemIndexStart - oldItemIndexStart;
            var itemIndexStartDeltaAbs = Math.abs(itemIndexStartDelta);
            var itemsLength = items.length;
            if (0 < itemIndexStartDeltaAbs && itemIndexStartDeltaAbs < itemsLength) {
                var work = this._workItems;
                if (0 < itemIndexStartDelta) {
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        var item = items[i];
                        this.reset(item);
                        work.push(item);
                    }
                    for (var i = itemIndexStartDeltaAbs; i < itemsLength; ++i) {
                        items[i - itemIndexStartDeltaAbs] = items[i];
                    }
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        items[itemsLength - itemIndexStartDeltaAbs + i] = work[i];
                    }
                }
                else {
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        var item = items[itemsLength - itemIndexStartDeltaAbs + i];
                        this.reset(item);
                        work.push(item);
                    }
                    for (var i = itemsLength - itemIndexStartDeltaAbs - 1; 0 <= i; --i) {
                        items[i + itemIndexStartDeltaAbs] = items[i];
                    }
                    for (var i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        items[i] = work[i];
                    }
                }
                work.length = 0;
            }
            var itemOffsetX = 0;
            var itemOffsetY = 0;
            if (content === container) {
                itemOffsetX = contentPaddingLeft;
                itemOffsetY = contentPaddingTop;
            }
            mapped.each(function (datum, index) {
                var item = items[index - newItemIndexStart];
                var ix = index % multiplicity;
                var iy = Math.floor(index / multiplicity);
                item.position.set(itemOffsetX + ix * itemWidth, itemOffsetY + iy * itemHeight);
                _this.set(item, datum, index, forcibly);
            }, newItemIndexStart, newItemIndexStart + itemsLength);
            for (var i = 0; newItemIndexStart + i < 0 && i < itemsLength; ++i) {
                var item = items[i];
                var index = newItemIndexStart + i;
                var ix = index % multiplicity;
                var iy = Math.floor(index / multiplicity);
                item.position.set(itemOffsetX + ix * itemWidth, itemOffsetY + iy * itemHeight);
                this.unset(item);
            }
            for (var i = itemsLength - 1; dataSize <= newItemIndexStart + i && 0 <= i; --i) {
                var item = items[i];
                var index = newItemIndexStart + i;
                var ix = index % multiplicity;
                var iy = Math.floor(index / multiplicity);
                item.position.set(itemOffsetX + ix * itemWidth, itemOffsetY + iy * itemHeight);
                this.unset(item);
            }
            this.lock();
            content.position.y = newContentY;
            content.height = newContentHeight;
            if (content !== container) {
                container.height = newHeight;
            }
            this.unlock(false);
        };
        DItemUpdater.prototype.set = function (item, value, index, forcibly) {
            item.set(value, index, forcibly);
        };
        DItemUpdater.prototype.unset = function (item) {
            item.unset();
        };
        DItemUpdater.prototype.reset = function (item) {
            item.blur(true);
            var cells = item.children;
            for (var i = 0, imax = cells.length; i < imax; ++i) {
                var cell = cells[i];
                if (cell instanceof DBase) {
                    var state = cell.state;
                    state.lock();
                    state.isPressed = false;
                    state.isHovered = false;
                    state.unlock();
                }
            }
            item.state.isHovered = false;
            return item;
        };
        DItemUpdater.prototype.moveFocus = function (e, target, moveVertically, moveHorizontally) {
            if (!(moveVertically || moveHorizontally)) {
                return false;
            }
            var isUp = moveVertically && UtilKeyboardEvent.isArrowUpKey(e);
            var isDown = moveVertically && UtilKeyboardEvent.isArrowDownKey(e);
            var isLeft = moveHorizontally && UtilKeyboardEvent.isArrowLeftKey(e);
            var isRight = moveHorizontally && UtilKeyboardEvent.isArrowRightKey(e);
            if (!(isUp || isDown || isLeft || isRight)) {
                return false;
            }
            if (!target.state.isActionable) {
                return false;
            }
            var layer = DApplications.getLayer(target);
            if (layer == null) {
                return false;
            }
            var focusController = layer.getFocusController();
            var focused = focusController.get();
            if (focused == null) {
                return false;
            }
            var container = this._container;
            if (focused.parent !== container) {
                return false;
            }
            var item = focused;
            var index = item.index;
            if (index == null) {
                return false;
            }
            var multiplicity = this._multiplicity;
            var data = this._data;
            var mapped = this.toMapped(data);
            var dataSize = mapped.size();
            var newIndex = index;
            if (isLeft || isRight) {
                if (isLeft) {
                    if (0 <= newIndex - 1) {
                        newIndex -= 1;
                    }
                }
                else {
                    if (newIndex + 1 < dataSize) {
                        newIndex += 1;
                    }
                }
            }
            if (isUp || isDown) {
                if (isUp) {
                    if (0 <= newIndex - multiplicity) {
                        newIndex -= multiplicity;
                    }
                }
                else {
                    if (newIndex + multiplicity < dataSize) {
                        newIndex += multiplicity;
                    }
                }
            }
            if (newIndex === index) {
                return false;
            }
            var items = container.children;
            var itemIndex = items.indexOf(item);
            if (itemIndex < 0) {
                return false;
            }
            var newItemIndex = itemIndex + (newIndex - index);
            if (newItemIndex < 0 || items.length <= newItemIndex) {
                return false;
            }
            var newItem = items[newItemIndex];
            focusController.focus(newItem);
            return true;
        };
        return DItemUpdater;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItemUpdater = /** @class */ (function (_super) {
        __extends(DListItemUpdater, _super);
        function DListItemUpdater() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DListItemUpdater.prototype.toMapped = function (data) {
            return data.mapped;
        };
        DListItemUpdater.prototype.newItem = function (data) {
            return new DListItem(data);
        };
        return DListItemUpdater;
    }(DItemUpdater));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectListItemUpdater = /** @class */ (function (_super) {
        __extends(DDialogSelectListItemUpdater, _super);
        function DDialogSelectListItemUpdater() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelectListItemUpdater.prototype.newItem = function (data) {
            return new DDialogSelectListItem(data);
        };
        return DDialogSelectListItemUpdater;
    }(DListItemUpdater));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataMappedImpl = /** @class */ (function () {
        function DListDataMappedImpl(parent) {
            this._parent = parent;
        }
        DListDataMappedImpl.prototype.size = function () {
            var parent = this._parent;
            return parent.before.length + parent.items.length + parent.after.length;
        };
        DListDataMappedImpl.prototype.each = function (iteratee, from, to) {
            var parent = this._parent;
            var index0 = this.each_(iteratee, parent.before, 0, from, to);
            if (index0 < 0) {
                return;
            }
            var index1 = this.each_(iteratee, parent.items, index0, from, to);
            if (index1 < 0) {
                return;
            }
            this.each_(iteratee, parent.after, index1, from, to);
        };
        DListDataMappedImpl.prototype.each_ = function (iteratee, items, start, from, to) {
            var end = start + items.length;
            var ifrom = from != null ? Math.max(start, from) : start;
            var ito = to != null ? Math.min(end, to) : end;
            for (var i = ifrom; i < ito; ++i) {
                if (iteratee(items[i - start], i) === false) {
                    return -1;
                }
            }
            return ito;
        };
        return DListDataMappedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionMultiple = /** @class */ (function (_super) {
        __extends(DListDataSelectionMultiple, _super);
        function DListDataSelectionMultiple(parent, accessor, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._accessor = accessor;
            _this._items = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DListDataSelectionMultiple.prototype, "type", {
            get: function () {
                return DListDataSelectionType.MULTIPLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionMultiple.prototype, "first", {
            get: function () {
                return this.get(0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionMultiple.prototype, "last", {
            get: function () {
                return this.get(this.size() - 1);
            },
            enumerable: false,
            configurable: true
        });
        DListDataSelectionMultiple.prototype.get = function (index) {
            var items = this._items;
            if (0 <= index && index < items.size) {
                var counter_1 = 0;
                var result_1 = null;
                items.forEach(function (item) {
                    if (counter_1 === index) {
                        result_1 = item;
                    }
                    counter_1 += 1;
                });
                return result_1;
            }
            return null;
        };
        DListDataSelectionMultiple.prototype.add = function (target) {
            var items = this._items;
            if (!items.has(target)) {
                items.add(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionMultiple.prototype.remove = function (target) {
            var items = this._items;
            if (items.has(target)) {
                items.delete(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionMultiple.prototype.toggle = function (target) {
            var items = this._items;
            if (items.has(target)) {
                items.delete(target);
            }
            else {
                items.add(target);
            }
            this.onChange();
            return true;
        };
        DListDataSelectionMultiple.prototype.clear = function () {
            var items = this._items;
            if (0 < items.size) {
                items.clear();
                this.onChange();
            }
        };
        DListDataSelectionMultiple.prototype.clearAndAdd = function (target) {
            var items = this._items;
            var size = items.size;
            if (size === 1) {
                if (items.has(target)) {
                    return false;
                }
                else {
                    items.clear();
                    items.add(target);
                    this.onChange();
                    return true;
                }
            }
            else {
                items.clear();
                items.add(target);
                this.onChange();
                return true;
            }
        };
        DListDataSelectionMultiple.prototype.clearAndAddAll = function (targets) {
            var isDirty = false;
            var newNodes = new Set();
            var oldNodes = this._items;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var target = targets[i];
                if (!oldNodes.has(target)) {
                    isDirty = true;
                }
                newNodes.add(target);
            }
            if (!isDirty) {
                oldNodes.forEach(function (oldItem) {
                    if (!newNodes.has(oldItem)) {
                        isDirty = true;
                    }
                });
            }
            if (isDirty) {
                this._items = newNodes;
                this.onChange();
            }
            return isDirty;
        };
        DListDataSelectionMultiple.prototype.contains = function (target) {
            return this._items.has(target);
        };
        DListDataSelectionMultiple.prototype.size = function () {
            return this._items.size;
        };
        DListDataSelectionMultiple.prototype.isEmpty = function () {
            return this.size() <= 0;
        };
        DListDataSelectionMultiple.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._items.forEach(function (item) {
                if (!isCanceled) {
                    if (iteratee(item) === false) {
                        isCanceled = true;
                    }
                }
            });
        };
        DListDataSelectionMultiple.prototype.toArray = function () {
            var result = [];
            this._items.forEach(function (item) {
                result.push(item);
            });
            return result;
        };
        DListDataSelectionMultiple.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DListDataSelectionMultiple.prototype.toItemIdMap = function (items, toId, result) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                result.set(toId(item), item);
            }
        };
        DListDataSelectionMultiple.prototype.toItemSet = function (items, result) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                result.add(items[i]);
            }
        };
        DListDataSelectionMultiple.prototype.onItemChange = function (before, items, after) {
            var oldItems = this._items;
            var newItems = new Set();
            var toId = this._accessor.toId;
            if (toId) {
                var newItemIdMap_1 = new Map();
                this.toItemIdMap(before, toId, newItemIdMap_1);
                this.toItemIdMap(items, toId, newItemIdMap_1);
                this.toItemIdMap(after, toId, newItemIdMap_1);
                oldItems.forEach(function (oldItem) {
                    var oldItemId = toId(oldItem);
                    var newItem = newItemIdMap_1.get(oldItemId);
                    if (newItem != null) {
                        newItems.add(newItem);
                    }
                });
                this._items = newItems;
                this.onChange();
            }
            else {
                var newItemSet_1 = new Set();
                this.toItemSet(before, newItemSet_1);
                this.toItemSet(items, newItemSet_1);
                this.toItemSet(after, newItemSet_1);
                oldItems.forEach(function (oldItem) {
                    if (newItemSet_1.has(oldItem)) {
                        newItems.add(oldItem);
                    }
                });
                if (oldItems.size !== newItems.size) {
                    this._items = newItems;
                    this.onChange();
                }
            }
        };
        DListDataSelectionMultiple.prototype.newItems = function (items, existing, result) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (existing.has(item)) {
                    result.add(item);
                }
            }
            return result;
        };
        return DListDataSelectionMultiple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionNone = /** @class */ (function (_super) {
        __extends(DListDataSelectionNone, _super);
        function DListDataSelectionNone(parent, accessor, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DListDataSelectionNone.prototype, "type", {
            get: function () {
                return DListDataSelectionType.NONE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionNone.prototype, "first", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionNone.prototype, "last", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DListDataSelectionNone.prototype.get = function (index) {
            return null;
        };
        DListDataSelectionNone.prototype.add = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.remove = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.toggle = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.clear = function () {
            // DO NOTHING
        };
        DListDataSelectionNone.prototype.clearAndAdd = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.clearAndAddAll = function (targets) {
            return false;
        };
        DListDataSelectionNone.prototype.contains = function (target) {
            return false;
        };
        DListDataSelectionNone.prototype.size = function () {
            return 0;
        };
        DListDataSelectionNone.prototype.isEmpty = function () {
            return true;
        };
        DListDataSelectionNone.prototype.each = function (iteratee) {
            // DO NOTHING
        };
        DListDataSelectionNone.prototype.toArray = function () {
            return [];
        };
        DListDataSelectionNone.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DListDataSelectionNone.prototype.onItemChange = function (before, items, after) {
            // DO NOTHING
        };
        return DListDataSelectionNone;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataSelectionSingle = /** @class */ (function (_super) {
        __extends(DListDataSelectionSingle, _super);
        function DListDataSelectionSingle(parent, accessor, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._accessor = accessor;
            _this._item = null;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DListDataSelectionSingle.prototype, "type", {
            get: function () {
                return DListDataSelectionType.SINGLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionSingle.prototype, "first", {
            get: function () {
                return this._item;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataSelectionSingle.prototype, "last", {
            get: function () {
                return this.get(this.size() - 1);
            },
            enumerable: false,
            configurable: true
        });
        DListDataSelectionSingle.prototype.get = function (index) {
            if (0 === index) {
                return this._item;
            }
            return null;
        };
        DListDataSelectionSingle.prototype.add = function (target) {
            if (this._item !== target) {
                this._item = target;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionSingle.prototype.remove = function (target) {
            if (this._item === target) {
                this._item = null;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionSingle.prototype.toggle = function (target) {
            if (this._item === target) {
                this._item = null;
            }
            else {
                this._item = target;
            }
            this.onChange();
            return true;
        };
        DListDataSelectionSingle.prototype.clear = function () {
            if (this._item != null) {
                this._item = null;
                this.onChange();
            }
        };
        DListDataSelectionSingle.prototype.clearAndAdd = function (target) {
            if (this._item !== target) {
                this._item = target;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataSelectionSingle.prototype.clearAndAddAll = function (targets) {
            var targetsLength = targets.length;
            if (0 < targetsLength) {
                var last = targets[targetsLength - 1];
                if (this._item !== last) {
                    this._item = last;
                    this.onChange();
                    return true;
                }
            }
            else {
                if (this._item != null) {
                    this._item = null;
                    this.onChange();
                    return true;
                }
            }
            return false;
        };
        DListDataSelectionSingle.prototype.contains = function (target) {
            return this._item === target;
        };
        DListDataSelectionSingle.prototype.size = function () {
            return this._item != null ? 1 : 0;
        };
        DListDataSelectionSingle.prototype.isEmpty = function () {
            return this.size() <= 0;
        };
        DListDataSelectionSingle.prototype.each = function (iteratee) {
            var item = this._item;
            if (item != null) {
                iteratee(item);
            }
        };
        DListDataSelectionSingle.prototype.toArray = function () {
            var item = this._item;
            if (item != null) {
                return [item];
            }
            return [];
        };
        DListDataSelectionSingle.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DListDataSelectionSingle.prototype.findById = function (id, toId, items) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                var itemId = toId(item);
                if (id === itemId) {
                    return item;
                }
            }
            return null;
        };
        DListDataSelectionSingle.prototype.find = function (target, items) {
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (target === item) {
                    return item;
                }
            }
            return null;
        };
        DListDataSelectionSingle.prototype.onItemChange = function (before, items, after) {
            var oldItem = this._item;
            if (oldItem == null) {
                return;
            }
            var newItem = null;
            var toId = this._accessor.toId;
            if (toId) {
                var oldItemId = toId(oldItem);
                newItem =
                    this.findById(oldItemId, toId, before) ||
                        this.findById(oldItemId, toId, items) ||
                        this.findById(oldItemId, toId, after);
            }
            else {
                newItem =
                    this.find(oldItem, before) ||
                        this.find(oldItem, items) ||
                        this.find(oldItem, after);
            }
            if (oldItem !== newItem) {
                this._item = newItem;
                this.onChange();
            }
        };
        return DListDataSelectionSingle;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toImage$1 = function (value) {
        return value.image;
    };
    var toTitle$1 = function (value) {
        return value.title;
    };
    var toLinkUrl = function (value) {
        return value.url;
    };
    var DListItemAccessorImpl = /** @class */ (function () {
        function DListItemAccessorImpl(options) {
            this.toLabel = (options === null || options === void 0 ? void 0 : options.toLabel) || toLabel$1;
            this.toTitle = (options === null || options === void 0 ? void 0 : options.toTitle) || toTitle$1;
            this.toImage = (options === null || options === void 0 ? void 0 : options.toImage) || toImage$1;
            this.toId = options === null || options === void 0 ? void 0 : options.toId;
            this.link = this.toLink(options);
        }
        DListItemAccessorImpl.prototype.toLink = function (options) {
            if (options) {
                var link = options.link;
                if (link) {
                    var toUrl = link.toUrl;
                    var target = link.target;
                    var checker = link.checker;
                    if (toUrl !== undefined || target !== undefined || checker !== undefined) {
                        return {
                            toUrl: toUrl || toLinkUrl,
                            target: target,
                            checker: checker
                        };
                    }
                }
            }
            return undefined;
        };
        return DListItemAccessorImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListDataImpl = /** @class */ (function () {
        function DListDataImpl(parent, options) {
            this._parent = parent;
            if (options) {
                this._before = options.before || [];
                this._items = options.items || [];
                this._after = options.after || [];
            }
            else {
                this._before = [];
                this._items = [];
                this._after = [];
            }
            var accessor = new DListItemAccessorImpl(options);
            this._accessor = accessor;
            this._selection = this.toSelection(accessor, options);
            this._mapped = new DListDataMappedImpl(this);
        }
        DListDataImpl.prototype.toSelection = function (accessor, options) {
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            switch (selection === null || selection === void 0 ? void 0 : selection.type) {
                case DListDataSelectionType.NONE:
                case "NONE":
                    return new DListDataSelectionNone(this, accessor, selection);
                case DListDataSelectionType.MULTIPLE:
                case "MULTIPLE":
                    return new DListDataSelectionMultiple(this, accessor, selection);
                default:
                    return new DListDataSelectionSingle(this, accessor, selection);
            }
        };
        Object.defineProperty(DListDataImpl.prototype, "before", {
            get: function () {
                return this._before;
            },
            set: function (before) {
                this._before = before;
                this._selection.onItemChange(before, this._items, this._after);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (items) {
                this._items = items;
                this._selection.onItemChange(this._before, items, this._after);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "after", {
            get: function () {
                return this._after;
            },
            set: function (after) {
                this._after = after;
                this._selection.onItemChange(this._before, this._items, after);
                this.update();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "accessor", {
            get: function () {
                return this._accessor;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DListDataImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DListDataImpl.prototype.update = function (forcibly) {
            this._parent.update(forcibly);
        };
        DListDataImpl.prototype.size = function () {
            return this._items.length;
        };
        DListDataImpl.prototype.clear = function () {
            var items = this._items;
            if (0 < items.length) {
                items.length = 0;
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataImpl.prototype.clearAndAdd = function (item) {
            var items = this._items;
            if (items.length === 1) {
                var first = items[0];
                if (first === item) {
                    return false;
                }
                else {
                    items[0] = item;
                    this.onChange();
                    return true;
                }
            }
            else {
                items.length = 0;
                items.push(item);
                this.onChange();
                return true;
            }
        };
        DListDataImpl.prototype.clearAndAddAll = function (newItems) {
            var isChanged = false;
            var items = this._items;
            if (0 < items.length) {
                items.length = 0;
                isChanged = true;
            }
            if (0 < newItems.length) {
                for (var i = 0, imax = newItems.length; i < imax; ++i) {
                    items.push(newItems[i]);
                }
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataImpl.prototype.add = function (item, index) {
            var items = this._items;
            if (index == null) {
                items.push(item);
                this.onChange();
                return true;
            }
            else if (0 <= index && index < items.length) {
                items.splice(index, 0, item);
                this.onChange();
                return true;
            }
            return false;
        };
        DListDataImpl.prototype.addAll = function (newItems, index) {
            if (0 < newItems.length) {
                var items = this._items;
                var itemsLength = items.length;
                if (index == null) {
                    for (var i = 0, imax = newItems.length; i < imax; ++i) {
                        items.push(newItems[i]);
                    }
                    this.onChange();
                    return true;
                }
                else if (0 <= index && index < itemsLength) {
                    for (var i = 0, imax = newItems.length; i < imax; ++i) {
                        items.splice(index + i, 0, newItems[i]);
                    }
                    this.onChange();
                    return true;
                }
            }
            return false;
        };
        DListDataImpl.prototype.get = function (index) {
            var items = this._items;
            if (0 <= index && index < items.length) {
                return items[index];
            }
            return null;
        };
        DListDataImpl.prototype.set = function (index, item) {
            var items = this._items;
            if (0 <= index && index < items.length) {
                var result = items[index];
                items[index] = item;
                this.onChange();
                return result;
            }
            return null;
        };
        DListDataImpl.prototype.remove = function (index) {
            var items = this._items;
            if (0 <= index && index < items.length) {
                var result = items.splice(index, 1)[0];
                this.onChange();
                return result;
            }
            return null;
        };
        DListDataImpl.prototype.each = function (iteratee, from, to) {
            var items = this._items;
            var size = items.length;
            var ifrom = from != null ? Math.max(0, from) : 0;
            var ito = to != null ? Math.min(size, to) : size;
            for (var i = ifrom; i < ito; ++i) {
                if (iteratee(items[i], i) === false) {
                    break;
                }
            }
        };
        DListDataImpl.prototype.onChange = function () {
            this.update();
        };
        return DListDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DContent = /** @class */ (function (_super) {
        __extends(DContent, _super);
        function DContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DContent.prototype.initReflowable = function () {
            // DO NOTHING
        };
        DContent.prototype.getType = function () {
            return "DContent";
        };
        return DContent;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBar = /** @class */ (function (_super) {
        __extends(DScrollBar, _super);
        function DScrollBar(options) {
            var _this = this;
            var _a, _b;
            _this = _super.call(this, options) || this;
            _this._start = 0;
            _this._end = 1;
            _this.visible = false;
            _this._touchedAt = -1;
            _this._isTouched = false;
            _this._fadeOutTimeoutId = null;
            _this._fadeOutDelay = (_b = (_a = options === null || options === void 0 ? void 0 : options.fadeOut) === null || _a === void 0 ? void 0 : _a.delay) !== null && _b !== void 0 ? _b : _this.theme.getFadeOutDelay();
            _this._isSilent = true;
            _this._onFadeOutTimeoutBound = function () {
                _this.onFadeOutTimeout();
            };
            var thumb = _this.newThumb(options === null || options === void 0 ? void 0 : options.thumb);
            thumb.on("statechange", function (newState, oldState) {
                _this.onThumbStateChange(newState, oldState);
            });
            _this._thumb = thumb;
            _this.addChild(thumb);
            return _this;
        }
        Object.defineProperty(DScrollBar.prototype, "thumb", {
            get: function () {
                return this._thumb;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DScrollBar.prototype, "start", {
            get: function () {
                return this._start;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DScrollBar.prototype, "end", {
            get: function () {
                return this._end;
            },
            enumerable: false,
            configurable: true
        });
        DScrollBar.prototype.set = function (start, end, size, silently) {
            if (size < 1) {
                start = 0;
                end = 1;
            }
            else {
                start = Math.max(0, Math.min(1, start / size));
                end = Math.max(start, Math.min(1, end / size));
            }
            if (this._start !== start || this._end !== end) {
                this._start = start;
                this._end = end;
                this.onChange(silently);
            }
        };
        DScrollBar.prototype.onChange = function (silently) {
            this.updateThumb(this.width, this.height);
            if (silently) {
                this._isSilent = true;
            }
            if (!this._isTouched) {
                this._isTouched = true;
                DApplications.update(this);
            }
        };
        DScrollBar.prototype.touch = function (silently) {
            this.onChange(silently);
        };
        DScrollBar.prototype.isRegionVisible = function () {
            return 0 < this._start || this._end < 1;
        };
        DScrollBar.prototype.render = function (renderer) {
            if (this._isTouched) {
                this._isTouched = false;
                if (!this._isSilent && this.isRegionVisible()) {
                    var fadeOutDelay = this._fadeOutDelay;
                    if (0 <= fadeOutDelay) {
                        this._touchedAt = Date.now();
                        if (this._fadeOutTimeoutId == null) {
                            this._fadeOutTimeoutId = window.setTimeout(this._onFadeOutTimeoutBound, fadeOutDelay);
                        }
                    }
                    if (!this.visible) {
                        this.visible = true;
                    }
                }
                else {
                    if (this._fadeOutDelay < 0 && this.visible) {
                        this.visible = false;
                    }
                }
            }
            if (this._isSilent) {
                this._isSilent = false;
            }
            _super.prototype.render.call(this, renderer);
        };
        DScrollBar.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.updateThumb(newWidth, newHeight);
        };
        DScrollBar.prototype.onFadeOutTimeout = function () {
            this._fadeOutTimeoutId = null;
            var fadeOutDelay = this._fadeOutDelay;
            var onTouchTimeoutBound = this._onFadeOutTimeoutBound;
            var state = this.state;
            if (state.isGesturing || state.onHovered || state.isHovered || state.isPressed) {
                this._fadeOutTimeoutId = window.setTimeout(onTouchTimeoutBound, fadeOutDelay);
                return;
            }
            var thumbState = this._thumb.state;
            if (thumbState.isGesturing || thumbState.isHovered || thumbState.isPressed) {
                this._fadeOutTimeoutId = window.setTimeout(onTouchTimeoutBound, fadeOutDelay);
                return;
            }
            var now = Date.now();
            var remainingTime = fadeOutDelay - (now - this._touchedAt);
            if (0 < remainingTime) {
                this._fadeOutTimeoutId = window.setTimeout(onTouchTimeoutBound, remainingTime);
                return;
            }
            if (this.visible) {
                this.visible = false;
                DApplications.update(this);
            }
        };
        DScrollBar.prototype.onThumbStateChange = function (newState, oldState) {
            if (!newState.isGesturing && !newState.isHovered && !newState.isPressed) {
                if (oldState.isGesturing || oldState.isHovered || oldState.isPressed) {
                    this._touchedAt = Date.now();
                }
            }
        };
        DScrollBar.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (!newState.isGesturing && !newState.isHovered && !newState.isPressed) {
                if (oldState.isGesturing || oldState.isHovered || oldState.isPressed) {
                    this._touchedAt = Date.now();
                }
            }
        };
        DScrollBar.prototype.getType = function () {
            return "DScrollBar";
        };
        return DScrollBar;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumb = /** @class */ (function (_super) {
        __extends(DScrollBarThumb, _super);
        function DScrollBarThumb() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumb.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            var position = new pixi_js.Point();
            this._gestureUtil = new UtilGesture({
                bind: this,
                on: {
                    start: function () {
                        position.copyFrom(_this.position);
                    },
                    move: function (target, dx, dy) {
                        position.set(position.x + dx, position.y + dy);
                        _this.onGestureMove(position.x, position.y);
                    }
                }
            });
        };
        DScrollBarThumb.prototype.getMinimumLength = function () {
            return this.theme.getThumbMinimumLength();
        };
        DScrollBarThumb.prototype.getType = function () {
            return "DScrollBarThumb";
        };
        return DScrollBarThumb;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbReflowableHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbReflowableHorizontal, _super);
        function DScrollBarThumbReflowableHorizontal(base) {
            var _this = _super.call(this) || this;
            base.snippet.add(_this, true);
            base.reflowable.add(_this);
            return _this;
        }
        DScrollBarThumbReflowableHorizontal.prototype.onReflow = function (base, width, height) {
            this.clear();
            var state = base.state;
            var border = base.border;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderWidth = border.getWidth(state);
                var borderAlign = border.getAlign(state);
                this.beginFill(borderColor, borderAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(0, borderAlign * (height - borderWidth), width, borderWidth);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        };
        return DScrollBarThumbReflowableHorizontal;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarThumbHorizontal, _super);
        function DScrollBarThumbHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumbHorizontal.prototype.onGestureMove = function (dx, dy) {
            this.emit("regionmove", dx, this);
        };
        DScrollBarThumbHorizontal.prototype.initReflowable = function () {
            new DScrollBarThumbReflowableHorizontal(this);
        };
        return DScrollBarThumbHorizontal;
    }(DScrollBarThumb));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarHorizontal = /** @class */ (function (_super) {
        __extends(DScrollBarHorizontal, _super);
        function DScrollBarHorizontal(options) {
            var _this = _super.call(this, options) || this;
            _this._thumb.on("regionmove", function (x) {
                _this.onThumbRegionMove(x);
            });
            return _this;
        }
        DScrollBarHorizontal.prototype.onThumbRegionMove = function (x) {
            var width = this.width;
            if (0 < width) {
                var size = this._end - this._start;
                var newStart = Math.min(1 - size, Math.max(0, x / width));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        };
        DScrollBarHorizontal.prototype.onDownThis = function (e) {
            _super.prototype.onDownThis.call(this, e);
            var width = this.width;
            if (0 < width) {
                var size = this._end - this._start;
                var position = e.data.getLocalPosition(this);
                var newStart = Math.min(1 - size, Math.max(0, position.x / width - size * 0.5));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        };
        DScrollBarHorizontal.prototype.newThumb = function (options) {
            return new DScrollBarThumbHorizontal(options);
        };
        DScrollBarHorizontal.prototype.updateThumb = function (width, height) {
            var thumb = this._thumb;
            var thumbMinimumLength = Math.min(width * 0.5, thumb.getMinimumLength());
            var space = width - thumbMinimumLength;
            var barStart = space * this._start;
            var barLength = space * this._end + thumbMinimumLength - barStart;
            thumb.position.set(barStart, 0);
            thumb.resize(barLength, height);
        };
        return DScrollBarHorizontal;
    }(DScrollBar));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbReflowableVertical = /** @class */ (function (_super) {
        __extends(DScrollBarThumbReflowableVertical, _super);
        function DScrollBarThumbReflowableVertical(base) {
            var _this = _super.call(this) || this;
            base.snippet.add(_this, true);
            base.reflowable.add(_this);
            return _this;
        }
        DScrollBarThumbReflowableVertical.prototype.onReflow = function (base, width, height) {
            this.clear();
            var state = base.state;
            var border = base.border;
            var borderColor = border.getColor(state);
            if (borderColor != null) {
                var borderAlpha = border.getAlpha(state);
                var borderWidth = border.getWidth(state);
                var borderAlign = border.getAlign(state);
                this.beginFill(borderColor, borderAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(borderAlign * (width - borderWidth), 0, borderWidth, height);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        };
        return DScrollBarThumbReflowableVertical;
    }(pixi_js.Graphics));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarThumbVertical = /** @class */ (function (_super) {
        __extends(DScrollBarThumbVertical, _super);
        function DScrollBarThumbVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DScrollBarThumbVertical.prototype.onGestureMove = function (dx, dy) {
            this.emit("regionmove", dy, this);
        };
        DScrollBarThumbVertical.prototype.initReflowable = function () {
            new DScrollBarThumbReflowableVertical(this);
        };
        return DScrollBarThumbVertical;
    }(DScrollBarThumb));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DScrollBarVertical = /** @class */ (function (_super) {
        __extends(DScrollBarVertical, _super);
        function DScrollBarVertical(options) {
            var _this = _super.call(this, options) || this;
            _this._thumb.on("regionmove", function (y) {
                _this.onThumbRegionMove(y);
            });
            return _this;
        }
        DScrollBarVertical.prototype.onThumbRegionMove = function (y) {
            var height = this.height;
            if (0 < height) {
                var size = this._end - this._start;
                var newStart = Math.min(1 - size, Math.max(0, y / height));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        };
        DScrollBarVertical.prototype.onDownThis = function (e) {
            _super.prototype.onDownThis.call(this, e);
            var height = this.height;
            if (0 < height) {
                var size = this._end - this._start;
                var position = e.data.getLocalPosition(this);
                var newStart = Math.min(1 - size, Math.max(0, position.y / height - size * 0.5));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        };
        DScrollBarVertical.prototype.newThumb = function (options) {
            return new DScrollBarThumbVertical(options);
        };
        DScrollBarVertical.prototype.updateThumb = function (width, height) {
            var thumb = this._thumb;
            var thumbMinimumLength = Math.min(height * 0.5, thumb.getMinimumLength());
            var space = height - thumbMinimumLength;
            var barStart = space * this._start;
            var barLength = space * this._end + thumbMinimumLength - barStart;
            thumb.position.set(0, barStart);
            thumb.resize(width, barLength);
            thumb.updateTransform();
        };
        return DScrollBarVertical;
    }(DScrollBar));

    var DPaneScrollBar = /** @class */ (function () {
        function DPaneScrollBar(parent, options, onUpdate) {
            this._parent = parent;
            this._onUpdate = onUpdate;
            this._isLocked = 0;
            this._isCalled = false;
            this.vertical = new DScrollBarVertical(options === null || options === void 0 ? void 0 : options.vertical);
            this.horizontal = new DScrollBarHorizontal(options === null || options === void 0 ? void 0 : options.horizontal);
        }
        DPaneScrollBar.prototype.lock = function () {
            this._isLocked += 1;
            if (this._isLocked === 1) {
                this._isCalled = false;
                this._isCalledSilently = undefined;
            }
        };
        DPaneScrollBar.prototype.unlock = function (callIfNeeded) {
            this._isLocked -= 1;
            if (this._isLocked === 0) {
                if (callIfNeeded && this._isCalled) {
                    this.update(this._isCalledSilently);
                }
                this._isCalled = false;
                this._isCalledSilently = undefined;
            }
        };
        DPaneScrollBar.prototype.update = function (silently) {
            if (0 < this._isLocked) {
                this._isCalled = true;
                if (silently != null) {
                    this._isCalledSilently || (this._isCalledSilently = silently);
                }
                return;
            }
            var parent = this._parent;
            var width = parent.width;
            var height = parent.height;
            var content = parent.content;
            var x = -content.x;
            var y = -content.y;
            var vertical = this.vertical;
            var verticalWidth = vertical.width;
            var verticalOffsetStart = this.getOffsetVerticalStart(verticalWidth);
            var verticalOffsetEnd = this.getOffsetVerticalEnd(verticalWidth);
            vertical.set(y, y + height, content.height, silently);
            vertical.position.set(width - verticalWidth, verticalOffsetStart);
            vertical.height = height - verticalOffsetStart - verticalOffsetEnd;
            var horizontal = this.horizontal;
            var horizontalHeight = horizontal.height;
            var horizontalOffsetStart = this.getOffsetHorizontalStart(horizontalHeight);
            var horizontalOffsetEnd = this.getOffsetHorizontalEnd(horizontalHeight);
            horizontal.set(x, x + width, content.width, silently);
            horizontal.position.set(horizontalOffsetStart, height - horizontalHeight);
            horizontal.width = width - horizontalOffsetStart - horizontalOffsetEnd;
            this._onUpdate(vertical.isRegionVisible() || horizontal.isRegionVisible());
        };
        DPaneScrollBar.prototype.touch = function (silently) {
            this.vertical.touch(silently);
            this.horizontal.touch(silently);
        };
        DPaneScrollBar.prototype.getOffsetHorizontalStart = function (size) {
            return size * 0.5;
        };
        DPaneScrollBar.prototype.getOffsetHorizontalEnd = function (size) {
            return size * 0.5;
        };
        DPaneScrollBar.prototype.getOffsetVerticalStart = function (size) {
            return size * 0.5;
        };
        DPaneScrollBar.prototype.getOffsetVerticalEnd = function (size) {
            return size * 0.5;
        };
        return DPaneScrollBar;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Class
    var DPane = /** @class */ (function (_super) {
        __extends(DPane, _super);
        function DPane(options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            // Mask
            var theme = _this.theme;
            if ((_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : theme.isOverflowMaskEnabled()) {
                _this.mask = _this.getOverflowMask();
            }
            // Content
            _this.addChild(_this.content);
            // Scroll bar
            var scrollbar = _this.scrollbar;
            _this.addChild(scrollbar.vertical);
            _this.addChild(scrollbar.horizontal);
            scrollbar.update();
            // Gesture
            _this.initGesture(theme, options);
            return _this;
        }
        DPane.prototype.initGesture = function (theme, options) {
            var _this = this;
            var _a, _b;
            // Edge does not fire the wheel event when scrolling using the 2-fingure scroll gesture on a touchpad.
            // Instead, it fires touch events. This is why the gesture is enabled regardless of the `UtilPointerEvent.touchable`.
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7134034/
            var mode = toEnum((_b = (_a = options === null || options === void 0 ? void 0 : options.gesture) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : theme.getGestureMode(), UtilGestureMode);
            if (mode === UtilGestureMode.ON || mode === UtilGestureMode.TOUCH) {
                var position_1 = new pixi_js.Point();
                var content_1 = this.content;
                this._gestureUtil = new UtilGesture({
                    bind: this,
                    touch: mode === UtilGestureMode.TOUCH,
                    on: {
                        start: function () {
                            position_1.copyFrom(content_1.position);
                        },
                        move: function (target, dx, dy) {
                            position_1.set(position_1.x + dx, position_1.y + dy);
                            content_1.position.set(_this.toContentX(content_1, position_1.x), _this.toContentY(content_1, position_1.y));
                        }
                    }
                });
            }
        };
        Object.defineProperty(DPane.prototype, "scrollbar", {
            get: function () {
                var _a;
                var result = this._scrollbar;
                if (result == null) {
                    result = this.newScrollBar((_a = this._options) === null || _a === void 0 ? void 0 : _a.scrollbar);
                    this.initScrollBar(result);
                    this._scrollbar = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPane.prototype.newScrollBar = function (options) {
            var _this = this;
            return new DPaneScrollBar(this, options, function (isRegionVisible) {
                _this.onScrollBarUpdate(isRegionVisible);
            });
        };
        DPane.prototype.onScrollBarUpdate = function (isRegionVisible) {
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                var content = this.content;
                if (isRegionVisible) {
                    if (content.mask !== overflowMask) {
                        content.mask = overflowMask;
                        DApplications.update(this);
                    }
                }
                else {
                    if (content.mask) {
                        content.mask = null;
                        DApplications.update(this);
                    }
                }
            }
        };
        DPane.prototype.initScrollBar = function (scrollbar) {
            var _this = this;
            scrollbar.vertical.on("regionmove", function (start) {
                _this.onScrollBarMoveY(start);
            });
            scrollbar.horizontal.on("regionmove", function (start) {
                _this.onScrollBarMoveX(start);
            });
        };
        DPane.prototype.onScrollBarMoveX = function (start) {
            var gestureUtil = this._gestureUtil;
            if (gestureUtil != null) {
                gestureUtil.stop(this);
            }
            var content = this.content;
            content.x = -content.width * start;
        };
        DPane.prototype.onScrollBarMoveY = function (start) {
            var gestureUtil = this._gestureUtil;
            if (gestureUtil != null) {
                gestureUtil.stop(this);
            }
            var content = this.content;
            content.y = -content.height * start;
        };
        DPane.prototype.onOver = function (e) {
            _super.prototype.onOver.call(this, e);
            this.scrollbar.touch();
        };
        DPane.prototype.getType = function () {
            return "DPane";
        };
        Object.defineProperty(DPane.prototype, "content", {
            get: function () {
                var result = this._content;
                if (result == null) {
                    result = this.toContent(this._options);
                    this.initContent(result);
                    this._content = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPane.prototype.toContent = function (options) {
            var content = options === null || options === void 0 ? void 0 : options.content;
            if (content) {
                if (content instanceof DBase) {
                    return content;
                }
                else {
                    return this.newContent(content);
                }
            }
            return this.newContent();
        };
        DPane.prototype.newContent = function (options) {
            return new DContent(options);
        };
        DPane.prototype.initContent = function (content) {
            var _this = this;
            content.on("move", function () {
                _this.onContentChange();
            });
            content.on("resize", function () {
                _this.onContentChange();
            });
        };
        DPane.prototype.getOverflowMask = function () {
            var result = this._overflowMask;
            if (result == null) {
                result = new DBaseOverflowMask(this);
                this._overflowMask = result;
                this.reflowable.add(result);
                this.toDirty();
            }
            return result;
        };
        DPane.prototype.onWheel = function (e, deltas, global) {
            var content = this.content;
            var x = this.getWheelContentX(content, deltas.deltaX * deltas.lowest);
            var y = this.getWheelContentY(content, deltas.deltaY * deltas.lowest);
            if (content.x !== x || content.y !== y) {
                var gestureUtil = this._gestureUtil;
                if (gestureUtil != null) {
                    gestureUtil.stop(this);
                }
                content.position.set(x, y);
                return true;
            }
            return false;
        };
        DPane.prototype.getWheelContentX = function (content, delta) {
            if (0 < delta || delta < 0) {
                var speed = this.theme.getWheelSpeed();
                return this.toContentX(content, content.x - delta * speed);
            }
            return content.x;
        };
        DPane.prototype.getWheelContentY = function (content, delta) {
            if (0 < delta || delta < 0) {
                var speed = this.theme.getWheelSpeed();
                return this.toContentY(content, content.y + delta * speed);
            }
            return content.y;
        };
        DPane.prototype.toContentX = function (content, x) {
            return Math.min(0, Math.max(this.width - content.width, x));
        };
        DPane.prototype.toContentY = function (content, y) {
            return Math.min(0, Math.max(this.height - content.height, y));
        };
        DPane.prototype.isRefitable = function (target) {
            return _super.prototype.isRefitable.call(this, target) && !(target instanceof DScrollBar);
        };
        DPane.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var scrollbar = this.scrollbar;
            scrollbar.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            scrollbar.update();
            scrollbar.unlock(true);
        };
        DPane.prototype.onContentChange = function () {
            this.scrollbar.update();
        };
        DPane.prototype.getFocusedChildClippingRect = function (focused, contentX, contentY, contentWidth, contentHeight, width, height, result) {
            result.x = 0;
            result.y = 0;
            result.width = width;
            result.height = height;
            return result;
        };
        DPane.prototype.onChildFocus = function (focused) {
            var point = DPane.WORK_POINT || new pixi_js.Point();
            DPane.WORK_POINT = point;
            // Content rectangle
            var content = this.content;
            var contentX = content.x;
            var contentY = content.y;
            var contentWidth = content.width;
            var contentHeight = content.height;
            point.set(0, 0);
            focused.toGlobal(point, point, false);
            content.toLocal(point, undefined, point, false);
            var x0 = contentX + Math.min(contentWidth, Math.max(0, point.x));
            var y0 = contentY + Math.min(contentHeight, Math.max(0, point.y));
            point.set(focused.width, focused.height);
            focused.toGlobal(point, point, true);
            content.toLocal(point, undefined, point, true);
            var x1 = contentX + Math.min(contentWidth, Math.max(0, point.x));
            var y1 = contentY + Math.min(contentHeight, Math.max(0, point.y));
            var width = this.width;
            var height = this.height;
            var clippingRect = DPane.WORK_RECTANGLE || new pixi_js.Rectangle();
            DPane.WORK_RECTANGLE = clippingRect;
            this.getFocusedChildClippingRect(focused, contentX, contentY, contentWidth, contentHeight, width, height, clippingRect);
            var clippingRectX = clippingRect.x;
            var clippingRectY = clippingRect.y;
            var clippingRectX0 = clippingRectX;
            var clippingRectY0 = clippingRectY;
            var clippingRectX1 = clippingRectX + clippingRect.width;
            var clippingRectY1 = clippingRectY + clippingRect.height;
            var newX = null;
            if (x0 < clippingRectX0) {
                if (x1 <= clippingRectX1) {
                    newX = contentX + Math.min(clippingRectX0 - x0, clippingRectX1 - x1);
                    newX = Math.max(width - contentWidth, Math.min(0, newX));
                }
            }
            else if (clippingRectX1 < x1) {
                newX = contentX - Math.min(x0 - clippingRectX0, x1 - clippingRectX1);
                newX = Math.max(width - contentWidth, Math.min(0, newX));
            }
            var newY = null;
            if (y0 < clippingRectY0) {
                if (y1 <= clippingRectY1) {
                    newY = contentY + Math.min(clippingRectY0 - y0, clippingRectY1 - y1);
                    newY = Math.max(height - contentHeight, Math.min(0, newY));
                }
            }
            else if (clippingRectY1 < y1) {
                newY = contentY - Math.min(y0 - clippingRectY0, y1 - clippingRectY1);
                newY = Math.max(height - contentHeight, Math.min(0, newY));
            }
            var contentPosition = content.position;
            if (newX != null) {
                if (newY != null) {
                    contentPosition.set(newX, newY);
                }
                else {
                    contentPosition.x = newX;
                }
            }
            else {
                if (newY != null) {
                    contentPosition.y = newY;
                }
            }
            _super.prototype.onChildFocus.call(this, focused);
        };
        DPane.prototype.destroy = function () {
            // Overflow mask
            var overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            _super.prototype.destroy.call(this);
        };
        return DPane;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DList = /** @class */ (function (_super) {
        __extends(DList, _super);
        function DList(options) {
            var _this = _super.call(this, options) || this;
            _this.update();
            return _this;
        }
        Object.defineProperty(DList.prototype, "updater", {
            get: function () {
                var result = this._updater;
                if (result == null) {
                    result = this.newUpdater(this.data, this.content, this._options);
                    this._updater = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DList.prototype.newUpdater = function (data, content, options) {
            return new DListItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        };
        Object.defineProperty(DList.prototype, "data", {
            get: function () {
                var result = this._data;
                if (result == null) {
                    result = this.toData(this._options);
                    this._data = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DList.prototype.toData = function (options) {
            var data = options && (options.data || options.items);
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            if (data == null) {
                if (selection) {
                    return new DListDataImpl(this, {
                        selection: selection
                    });
                }
                else {
                    return new DListDataImpl(this);
                }
            }
            else if (isArray(data)) {
                if (selection) {
                    return new DListDataImpl(this, {
                        items: data,
                        selection: selection
                    });
                }
                else {
                    return new DListDataImpl(this, {
                        items: data
                    });
                }
            }
            else if ("each" in data) {
                return data;
            }
            else {
                if (selection) {
                    if (data.selection === undefined) {
                        data.selection = selection;
                    }
                    return new DListDataImpl(this, data);
                }
                else {
                    return new DListDataImpl(this, data);
                }
            }
        };
        DList.prototype.onContentChange = function () {
            _super.prototype.onContentChange.call(this);
            this.update();
        };
        DList.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var updater = this.updater;
            updater.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            updater.update();
            updater.unlock(true);
        };
        Object.defineProperty(DList.prototype, "selection", {
            get: function () {
                return this.data.selection;
            },
            enumerable: false,
            configurable: true
        });
        DList.prototype.lock = function () {
            this.updater.lock();
        };
        DList.prototype.unlock = function (callIfNeeded) {
            this.updater.unlock(callIfNeeded);
        };
        /**
         * Updates items. If the `forcibly` is true, some dirty checkings for
         * avoiding unnecessary state changes are skipped.
         *
         * @param forcibly true to update forcibly
         */
        DList.prototype.update = function (forcibly) {
            this.updater.update(forcibly);
        };
        DList.prototype.onKeyDown = function (e) {
            this.updater.moveFocus(e, this, true, true);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DList.prototype.getType = function () {
            return "DList";
        };
        return DList;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectList = /** @class */ (function (_super) {
        __extends(DDialogSelectList, _super);
        function DDialogSelectList() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSelectList.prototype.newUpdater = function (data, content, options) {
            return new DDialogSelectListItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        };
        DDialogSelectList.prototype.getType = function () {
            return "DDialogSelectList";
        };
        return DDialogSelectList;
    }(DList));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectSearhImpl = /** @class */ (function (_super) {
        __extends(DDialogSelectSearhImpl, _super);
        function DDialogSelectSearhImpl(search) {
            var _this = _super.call(this) || this;
            _this._search = search || (function (_) { return Promise.resolve([]); });
            _this._id = 0;
            _this._idCompleted = 0;
            return _this;
        }
        DDialogSelectSearhImpl.prototype.create = function (args) {
            var _this = this;
            var id = ++this._id;
            this._search(args[0]).then(function (searchResult) {
                if (_this._id === id) {
                    _this._idCompleted = id;
                    _this.emit("success", _this, searchResult);
                    _this.emit("change", _this);
                }
            }, function () {
                if (_this._id === id) {
                    _this._idCompleted = id;
                    _this.emit("fail", _this);
                    _this.emit("change", _this);
                }
            });
            this.emit("change", this);
        };
        DDialogSelectSearhImpl.prototype.isDone = function () {
            return this._id === this._idCompleted;
        };
        return DDialogSelectSearhImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputSearch = /** @class */ (function (_super) {
        __extends(DInputSearch, _super);
        function DInputSearch() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputSearch.prototype.getType = function () {
            return "DInputSearch";
        };
        return DInputSearch;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNote = /** @class */ (function (_super) {
        __extends(DNote, _super);
        function DNote() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNote.prototype.getType = function () {
            return "DNote";
        };
        return DNote;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSmall = /** @class */ (function (_super) {
        __extends(DNoteSmall, _super);
        function DNoteSmall() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSmall.prototype.getType = function () {
            return "DNoteSmall";
        };
        return DNoteSmall;
    }(DNote));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSmallError = /** @class */ (function (_super) {
        __extends(DNoteSmallError, _super);
        function DNoteSmallError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSmallError.prototype.getType = function () {
            return "DNoteSmallError";
        };
        return DNoteSmallError;
    }(DNoteSmall));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSmallNoItemsFound = /** @class */ (function (_super) {
        __extends(DNoteSmallNoItemsFound, _super);
        function DNoteSmallNoItemsFound() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSmallNoItemsFound.prototype.getType = function () {
            return "DNoteSmallNoItemsFound";
        };
        return DNoteSmallNoItemsFound;
    }(DNoteSmall));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSmallSearching = /** @class */ (function (_super) {
        __extends(DNoteSmallSearching, _super);
        function DNoteSmallSearching() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSmallSearching.prototype.getType = function () {
            return "DNoteSmallSearching";
        };
        return DNoteSmallSearching;
    }(DNoteSmall));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelectSearhDismissableImpl = /** @class */ (function (_super) {
        __extends(DDialogSelectSearhDismissableImpl, _super);
        function DDialogSelectSearhDismissableImpl(target, options) {
            var _this = _super.call(this) || this;
            _this._target = target;
            _this._value = options.value;
            _this._filter = options.filter;
            target.on("change", function () {
                _this.emit("change", _this);
            });
            target.on("success", function (e, values) {
                _this.emit("success", _this, _this.toDismissable(values));
            });
            target.on("fail", function () {
                _this.emit("fail", _this);
            });
            return _this;
        }
        DDialogSelectSearhDismissableImpl.prototype.toDismissValue = function (args) {
            if (args == null) {
                return;
            }
            var value = this._value;
            if (value === undefined) {
                return;
            }
            var filter = this._filter;
            if (filter != null && !filter(value, args[0])) {
                return;
            }
            return value;
        };
        DDialogSelectSearhDismissableImpl.prototype.toDismissable = function (values) {
            var value = this.toDismissValue(this._args);
            if (value === undefined) {
                return values;
            }
            var result = [];
            for (var i = 0, imax = values.length; i < imax; ++i) {
                result.push(values[i]);
            }
            result.push(value);
            return result;
        };
        DDialogSelectSearhDismissableImpl.prototype.create = function (args) {
            this._args = args;
            this._target.create(args);
        };
        DDialogSelectSearhDismissableImpl.prototype.isDone = function () {
            return this._target.isDone();
        };
        return DDialogSelectSearhDismissableImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSelect = /** @class */ (function (_super) {
        __extends(DDialogSelect, _super);
        function DDialogSelect(options) {
            var _this = _super.call(this, options) || this;
            _this._value = null;
            // Controller binding
            var transition = new UtilTransition();
            var search = _this.search;
            search.on("success", function (e, results) {
                if (0 < results.length) {
                    transition.hide();
                }
                else {
                    transition.show(_this.noteNoItemsFound);
                }
                _this.onSearched(results);
            });
            search.on("fail", function () {
                transition.show(_this.noteError);
                _this.onSearched([]);
            });
            search.on("change", function () {
                if (!search.isDone()) {
                    var noteSearching = _this.noteSearching;
                    if (noteSearching) {
                        transition.show(noteSearching);
                    }
                }
            });
            return _this;
        }
        DDialogSelect.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.inputLayout, this.list);
            return result;
        };
        Object.defineProperty(DDialogSelect.prototype, "inputLayout", {
            get: function () {
                var result = this._inputLayout;
                if (result == null) {
                    result = this.newInputLayout(this.input, this.theme, this._options);
                    this._inputLayout = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newInputLayout = function (input, theme, options) {
            return new DLayoutHorizontal(this.toInputLayoutOptions(input, theme, options));
        };
        DDialogSelect.prototype.toInputLayoutOptions = function (input, theme, options) {
            var margin = this.toInputMargin(theme, options);
            return {
                width: "padding",
                height: "auto",
                children: [
                    new DLayoutSpace({ width: margin }),
                    input,
                    new DLayoutSpace({ width: margin })
                ]
            };
        };
        Object.defineProperty(DDialogSelect.prototype, "input", {
            get: function () {
                var result = this._input;
                if (result == null) {
                    result = this.newInput();
                    this._input = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newInput = function () {
            var _this = this;
            var result = new DInputSearch(this.toInputOptions(this.theme, this._options));
            result.on("input", function (value) {
                _this.search.create([value]);
            });
            return result;
        };
        DDialogSelect.prototype.toInputOptions = function (theme, options) {
            var result = (options === null || options === void 0 ? void 0 : options.input) || {};
            if (result.width === undefined && result.weight === undefined) {
                result.weight = 1;
            }
            return result;
        };
        DDialogSelect.prototype.toInputMargin = function (theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.input) === null || _a === void 0 ? void 0 : _a.margin) !== null && _b !== void 0 ? _b : theme.getInputMargin();
        };
        Object.defineProperty(DDialogSelect.prototype, "list", {
            get: function () {
                var result = this._list;
                if (result == null) {
                    result = this.newList();
                    this._list = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newList = function () {
            var _this = this;
            var result = new DDialogSelectList(this.toListOptions(this.theme, this._options));
            result.selection.on("change", function (selection) {
                _this.onListSelectionChange(selection);
            });
            return result;
        };
        DDialogSelect.prototype.onListSelectionChange = function (selection) {
            var selected = selection.first;
            if (selected == null) {
                return;
            }
            var options = this._options;
            if (options) {
                var dismiss = options.dismiss;
                if (dismiss) {
                    if (selected === dismiss.value) {
                        selected = null;
                    }
                }
            }
            this._value = selected;
            this.onOk(selected);
        };
        DDialogSelect.prototype.toListOptions = function (theme, options) {
            var result = (options === null || options === void 0 ? void 0 : options.list) || {};
            if (result.width === undefined) {
                result.width = "padding";
            }
            return result;
        };
        Object.defineProperty(DDialogSelect.prototype, "noteError", {
            get: function () {
                var result = this._noteError;
                if (result == null) {
                    result = this.newNoteError();
                    this._noteError = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newNoteError = function () {
            var _a, _b;
            var error = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.note) === null || _b === void 0 ? void 0 : _b.error;
            if (error !== null) {
                return new DNoteSmallError(this.toNoteOptions(this.list, error));
            }
            return null;
        };
        Object.defineProperty(DDialogSelect.prototype, "noteNoItemsFound", {
            get: function () {
                var result = this._noteNoItemsFound;
                if (result == null) {
                    result = this.newNoteNoItemsFound();
                    this._noteNoItemsFound = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newNoteNoItemsFound = function () {
            var _a, _b;
            var noItemsFound = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.note) === null || _b === void 0 ? void 0 : _b.noItemsFound;
            if (noItemsFound !== null) {
                return new DNoteSmallNoItemsFound(this.toNoteOptions(this.list, noItemsFound));
            }
            return null;
        };
        Object.defineProperty(DDialogSelect.prototype, "noteSearching", {
            get: function () {
                var result = this._noteSearching;
                if (result == null) {
                    result = this.newNoteSearching();
                    this._noteSearching = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newNoteSearching = function () {
            var _a, _b;
            var searching = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.note) === null || _b === void 0 ? void 0 : _b.searching;
            // Because the `searching` note is disabled by default,
            // if options.searching is missing, i.e., if its value is undefined,
            // this method returns null. This is why `!=` is used here instead of `!==`.
            if (searching != null) {
                return new DNoteSmallSearching(this.toNoteOptions(this.list, searching));
            }
            return null;
        };
        DDialogSelect.prototype.toNoteOptions = function (parent, options) {
            if (options != null) {
                if (options.parent == null) {
                    options.parent = parent;
                }
                if (options.visible == null) {
                    options.visible = false;
                }
                return options;
            }
            return {
                parent: parent,
                visible: false
            };
        };
        Object.defineProperty(DDialogSelect.prototype, "search", {
            get: function () {
                var result = this._search;
                if (result == null) {
                    result = this.newSearch();
                    this._search = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.newSearch = function () {
            var options = this._options;
            if (options) {
                var controller = options.controller;
                if (controller) {
                    var dismiss = options.dismiss;
                    var search = controller.search;
                    if ("create" in search) {
                        if (dismiss != null) {
                            return new DDialogSelectSearhDismissableImpl(search, dismiss);
                        }
                        else {
                            return search;
                        }
                    }
                    else {
                        if (dismiss != null) {
                            return new DDialogSelectSearhDismissableImpl(new DDialogSelectSearhImpl(search), dismiss);
                        }
                        else {
                            return new DDialogSelectSearhImpl(search);
                        }
                    }
                }
            }
            return new DDialogSelectSearhImpl();
        };
        Object.defineProperty(DDialogSelect.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        DDialogSelect.prototype.onSearched = function (results) {
            this.list.data.items = results;
        };
        DDialogSelect.prototype.getResolvedValue = function () {
            return this._value;
        };
        DDialogSelect.prototype.getType = function () {
            return "DDialogSelect";
        };
        DDialogSelect.prototype.onOpen = function () {
            _super.prototype.onOpen.call(this);
            this.list.selection.clear();
            this.search.create([this.input.value]);
        };
        DDialogSelect.prototype.onOk = function (value) {
            this.emit("select", value, this);
            _super.prototype.onOk.call(this, value);
        };
        DDialogSelect.prototype.destroy = function () {
            var input = this._input;
            if (input) {
                input.destroy();
            }
            var noteError = this._noteError;
            if (noteError) {
                noteError.destroy();
            }
            var noteNoItemsFound = this._noteNoItemsFound;
            if (noteNoItemsFound) {
                noteNoItemsFound === null || noteNoItemsFound === void 0 ? void 0 : noteNoItemsFound.destroy();
            }
            var noteSearching = this._noteSearching;
            if (noteSearching) {
                noteSearching === null || noteSearching === void 0 ? void 0 : noteSearching.destroy();
            }
            var list = this._list;
            if (list) {
                list.destroy();
            }
            _super.prototype.destroy.call(this);
        };
        return DDialogSelect;
    }(DDialogLayered));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var defaultGetter$1 = function (dialog) {
        // Assumes the dialog.value is VALUE.
        return dialog.value;
    };
    var defaultSetter$1 = function () {
        // DO NOTHING
    };
    var toOptions = function (options) {
        var _a, _b, _c;
        if (options) {
            // Try to copy text.formatter to dialog.item.text.formatter at first
            var formatter = (_a = options.text) === null || _a === void 0 ? void 0 : _a.formatter;
            if (formatter !== undefined) {
                var dialog = options.dialog;
                if (!(dialog && "open" in dialog)) {
                    dialog = dialog || {};
                    var item = (dialog.item = dialog.item || {});
                    var text = (item.text = item.text || {});
                    if (text.formatter === undefined) {
                        // Assumes formatter is ( value: DIALOG_VALUE | null, caller: any ) => string.
                        text.formatter = formatter;
                    }
                }
            }
            else {
                // Try to copy dialog.item.text.formatter to text.formatter
                var dialog = options.dialog;
                if (!(dialog && "open" in dialog)) {
                    var dialogFormatter = (_c = (_b = dialog === null || dialog === void 0 ? void 0 : dialog.item) === null || _b === void 0 ? void 0 : _b.text) === null || _c === void 0 ? void 0 : _c.formatter;
                    if (dialogFormatter !== undefined) {
                        var text = options.text || {};
                        options.text = text;
                        if (text.formatter === undefined) {
                            // Assumes dialogFormatter is ( value: VALUE | null, caller: any ) => string.
                            text.formatter = dialogFormatter;
                        }
                    }
                }
            }
        }
        return options;
    };
    var DButtonSelect = /** @class */ (function (_super) {
        __extends(DButtonSelect, _super);
        function DButtonSelect(options) {
            var _this = this;
            var _a, _b;
            _this = _super.call(this, toOptions(options)) || this;
            _this._dialogGetter = (_a = options === null || options === void 0 ? void 0 : options.getter) !== null && _a !== void 0 ? _a : defaultGetter$1;
            _this._dialogSetter = (_b = options === null || options === void 0 ? void 0 : options.setter) !== null && _b !== void 0 ? _b : defaultSetter$1;
            return _this;
        }
        DButtonSelect.prototype.onActivate = function (e) {
            var _this = this;
            var _a;
            _super.prototype.onActivate.call(this, e);
            var dialog = this.dialog;
            var oldValue = (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : null;
            this._dialogSetter(dialog, oldValue);
            dialog.open(this).then(function () {
                var newValue = _this._dialogGetter(dialog);
                if (newValue !== oldValue) {
                    _this.text = newValue;
                    _this.emit("change", newValue, oldValue, _this);
                }
            });
        };
        Object.defineProperty(DButtonSelect.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options && "open" in options) {
                        dialog = options;
                    }
                    else {
                        // Assumes DIALOG === DDialogSelect<DIALOG_VALUE>.
                        dialog = new DDialogSelect(options);
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DButtonSelect.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : null;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DButtonSelect.prototype.getType = function () {
            return "DButtonSelect";
        };
        return DButtonSelect;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonTime = /** @class */ (function (_super) {
        __extends(DButtonTime, _super);
        function DButtonTime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DButtonTime.prototype.onActivate = function (e) {
            var _this = this;
            var _a, _b;
            _super.prototype.onActivate.call(this, e);
            var value = (_b = (_a = this._textValueComputed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            var dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.open(this).then(function () {
                _this.onValueChange(dialog.new, dialog.current);
            });
        };
        DButtonTime.prototype.onValueChange = function (newValue, oldValue) {
            this.text = new Date(newValue.getTime());
            this.emit("change", newValue, oldValue, this);
        };
        DButtonTime.prototype.getDatetimeMask = function () {
            var _a, _b;
            var result = this._datetimeMask;
            if (result == null) {
                result = DPickerTimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        };
        Object.defineProperty(DButtonTime.prototype, "dialog", {
            get: function () {
                var _a;
                var dialog = this._dialog;
                if (dialog == null) {
                    var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                    if (options) {
                        dialog = this.newDialog(options);
                    }
                    else {
                        if (DButtonTime.DIALOG == null) {
                            DButtonTime.DIALOG = this.newDialog({
                                mode: "MENU",
                                sticky: true
                            });
                        }
                        dialog = DButtonTime.DIALOG;
                    }
                    this._dialog = dialog;
                }
                return dialog;
            },
            enumerable: false,
            configurable: true
        });
        DButtonTime.prototype.newDialog = function (options) {
            return new DDialogTime(options);
        };
        Object.defineProperty(DButtonTime.prototype, "value", {
            get: function () {
                var _a;
                return (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : new Date();
            },
            set: function (value) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed === undefined || textValueComputed.getTime() !== value.getTime()) {
                    this.text = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        DButtonTime.prototype.getType = function () {
            return "DButtonTime";
        };
        return DButtonTime;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DButtonUndo = /** @class */ (function (_super) {
        __extends(DButtonUndo, _super);
        function DButtonUndo(options) {
            var _this = _super.call(this, options) || this;
            var state = _this.state;
            var commandController = DControllers.getCommandController();
            state.isDisabled = !commandController.isUndoable();
            commandController.on("change", function () {
                state.isDisabled = !commandController.isUndoable();
            });
            return _this;
        }
        DButtonUndo.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            DControllers.getCommandController().undo();
        };
        return DButtonUndo;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCanvas = /** @class */ (function (_super) {
        __extends(DCanvas, _super);
        function DCanvas() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCanvas.prototype.getType = function () {
            return "DCanvas";
        };
        return DCanvas;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisPosition = {
        TOP: 0,
        BOTTOM: 1,
        LEFT: 2,
        RIGHT: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBaseBar = /** @class */ (function () {
        function DChartAxisBaseBar(parser) {
            this._parser = parser;
            this._index = 0;
        }
        Object.defineProperty(DChartAxisBaseBar.prototype, "shape", {
            get: function () {
                var result = this._shape;
                if (result == null) {
                    result = this.newShape();
                    this._shape = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseBar.prototype.newShape = function () {
            var _a;
            var parser = this._parser;
            var bar = parser.bar;
            var result = new EShapeBar();
            result.points.position = this.newShapePosition();
            result.points.style = (_a = bar.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
            result.stroke.copy(bar.stroke);
            result.text.copy(parser.label);
            return result;
        };
        DChartAxisBaseBar.prototype.newShapePosition = function () {
            switch (this._parser.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.TOP;
                default:
                    return EShapeBarPosition.LEFT;
            }
        };
        DChartAxisBaseBar.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            this.shape.attach(container.container);
        };
        DChartAxisBaseBar.prototype.unbind = function () {
            var shape = this._shape;
            if (shape != null) {
                shape.detach();
            }
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseBar.prototype.update = function () {
            var container = this._container;
            var index = this._index;
            var shape = this._shape;
            if (shape != null && container != null) {
                var plotArea = container.plotArea;
                var plotAreaWidth = plotArea.width;
                var plotAreaHeight = plotArea.height;
                var offset = this._parser.padding * index;
                shape.disallowUploadedUpdate();
                var position = shape.transform.position;
                var size = shape.size;
                switch (this._parser.position) {
                    case DChartAxisPosition.TOP:
                        position.set(plotAreaWidth * 0.5, 0 - offset);
                        size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.BOTTOM:
                        position.set(plotAreaWidth * 0.5, plotAreaHeight + offset);
                        size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.LEFT:
                        position.set(0 - offset, plotAreaHeight * 0.5);
                        size.set(0, plotAreaHeight);
                        break;
                    case DChartAxisPosition.RIGHT:
                        position.set(plotAreaWidth + offset, plotAreaHeight * 0.5);
                        size.set(0, plotAreaHeight);
                        break;
                }
                shape.allowUploadedUpdate();
                return true;
            }
            return false;
        };
        DChartAxisBaseBar.prototype.destroy = function () {
            var shape = this._shape;
            if (shape != null) {
                shape.destroy();
            }
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseBar;
    }());

    var DChartAxisBaseGuideContainer = /** @class */ (function () {
        function DChartAxisBaseGuideContainer(axis) {
            this._axis = axis;
            this._index = 0;
            this._list = [];
        }
        DChartAxisBaseGuideContainer.prototype.add = function (guide) {
            this._list.push(guide);
            var container = this._container;
            var index = this._index;
            if (container != null) {
                guide.bind(container, index, this._axis);
            }
            return this;
        };
        DChartAxisBaseGuideContainer.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartAxisBaseGuideContainer.prototype.indexOf = function (guide) {
            return this._list.indexOf(guide);
        };
        DChartAxisBaseGuideContainer.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            return this;
        };
        DChartAxisBaseGuideContainer.prototype.size = function () {
            return this._list.length;
        };
        DChartAxisBaseGuideContainer.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            var axis = this._axis;
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].bind(container, index, axis);
            }
        };
        DChartAxisBaseGuideContainer.prototype.unbind = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].unbind();
            }
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseGuideContainer.prototype.update = function () {
            var isUpdated = false;
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                if (list[i].update()) {
                    isUpdated = true;
                }
            }
            return isUpdated;
        };
        DChartAxisBaseGuideContainer.prototype.destroy = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseGuideContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisTickPosition = {
        INSIDE: 0,
        OUTSIDE: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBaseOptionParser = /** @class */ (function () {
        function DChartAxisBaseOptionParser(theme, options) {
            var _a, _b;
            this.coordinate = (_a = options === null || options === void 0 ? void 0 : options.coordinate) !== null && _a !== void 0 ? _a : 0;
            this.position = this.toPosition(theme, options);
            this.tick = this.toTick(theme, options);
            this.label = this.toLabel(theme, options);
            this.padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : theme.getPadding();
            this.bar = this.toBar(theme, options);
            this.guide = this.toGuide(theme, options);
        }
        DChartAxisBaseOptionParser.prototype.toPosition = function (theme, options) {
            var position = options === null || options === void 0 ? void 0 : options.position;
            if (isString(position)) {
                return DChartAxisPosition[position];
            }
            else if (position != null) {
                return position;
            }
            return theme.getPosition();
        };
        DChartAxisBaseOptionParser.prototype.toGuide = function (theme, options) {
            var _a, _b;
            return {
                list: (_b = (_a = options === null || options === void 0 ? void 0 : options.guide) === null || _a === void 0 ? void 0 : _a.list) !== null && _b !== void 0 ? _b : []
            };
        };
        DChartAxisBaseOptionParser.prototype.toBar = function (theme, options) {
            var _a;
            return {
                style: (_a = options === null || options === void 0 ? void 0 : options.style) !== null && _a !== void 0 ? _a : theme.getStyle(),
                stroke: this.toBarStroke(theme, options === null || options === void 0 ? void 0 : options.stroke)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTick = function (theme, options) {
            var _a;
            var tick = options === null || options === void 0 ? void 0 : options.tick;
            return {
                enable: (_a = tick === null || tick === void 0 ? void 0 : tick.enable) !== null && _a !== void 0 ? _a : theme.getTickEnable(),
                major: this.toTickMajor(theme, tick),
                minor: this.toTickMinor(theme, tick)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajor = function (theme, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            var major = options === null || options === void 0 ? void 0 : options.major;
            var position = (_b = (_a = major === null || major === void 0 ? void 0 : major.position) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.position) !== null && _b !== void 0 ? _b : theme.getMajorTickPosition();
            var optionsStyle = options === null || options === void 0 ? void 0 : options.style;
            var style = EShapePointsStyles.from((_d = (_c = major === null || major === void 0 ? void 0 : major.style) !== null && _c !== void 0 ? _c : optionsStyle) !== null && _d !== void 0 ? _d : theme.getMajorTickStyle());
            var optionsStroke = options === null || options === void 0 ? void 0 : options.stroke;
            var stroke = this.toTickMajorStroke(theme, major === null || major === void 0 ? void 0 : major.stroke, optionsStroke);
            var count = (_e = major === null || major === void 0 ? void 0 : major.count) !== null && _e !== void 0 ? _e : theme.getMajorTickCount();
            var capacity = (_f = major === null || major === void 0 ? void 0 : major.capacity) !== null && _f !== void 0 ? _f : theme.getMajorTickCapacity(count);
            return {
                count: count,
                capacity: capacity,
                step: (_g = major === null || major === void 0 ? void 0 : major.step) !== null && _g !== void 0 ? _g : theme.getMajorTickStep(),
                size: (_h = major === null || major === void 0 ? void 0 : major.size) !== null && _h !== void 0 ? _h : theme.getMajorTickSize(),
                position: this.toTickPosition(position),
                style: style,
                stroke: stroke,
                text: this.toTickMajorText(theme, major === null || major === void 0 ? void 0 : major.text),
                formatter: this.toTickMajorFormatter(theme, major),
                gridline: this.toTickMajorGridline(theme, major === null || major === void 0 ? void 0 : major.gridline, optionsStyle, optionsStroke)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorGridline = function (theme, options, optionsStyle, optionsStroke) {
            var _a, _b, _c;
            var style = EShapePointsStyles.from((_b = (_a = options === null || options === void 0 ? void 0 : options.style) !== null && _a !== void 0 ? _a : optionsStyle) !== null && _b !== void 0 ? _b : theme.getMajorTickGridlineStyle());
            return {
                enable: (_c = options === null || options === void 0 ? void 0 : options.enable) !== null && _c !== void 0 ? _c : theme.getMajorTickGridlineEnable(),
                style: style,
                stroke: this.toTickMajorGridlineStroke(theme, options === null || options === void 0 ? void 0 : options.stroke, optionsStroke)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickPosition = function (tickPosition) {
            var position = this.position;
            if (tickPosition === DChartAxisTickPosition.OUTSIDE || tickPosition === "OUTSIDE") {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.RIGHT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.LEFT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
            else {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.LEFT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.RIGHT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMinor = function (theme, options) {
            var _a, _b, _c, _d, _e, _f, _g;
            var minor = options === null || options === void 0 ? void 0 : options.minor;
            var position = (_b = (_a = minor === null || minor === void 0 ? void 0 : minor.position) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.position) !== null && _b !== void 0 ? _b : theme.getMinorTickPosition();
            var style = EShapePointsStyles.from((_d = (_c = minor === null || minor === void 0 ? void 0 : minor.style) !== null && _c !== void 0 ? _c : options === null || options === void 0 ? void 0 : options.style) !== null && _d !== void 0 ? _d : theme.getMinorTickStyle());
            return {
                count: (_e = minor === null || minor === void 0 ? void 0 : minor.count) !== null && _e !== void 0 ? _e : theme.getMinorTickCount(),
                step: (_f = minor === null || minor === void 0 ? void 0 : minor.step) !== null && _f !== void 0 ? _f : theme.getMinorTickStep(),
                size: (_g = minor === null || minor === void 0 ? void 0 : minor.size) !== null && _g !== void 0 ? _g : theme.getMinorTickSize(),
                position: this.toTickPosition(position),
                style: style,
                stroke: this.toTickMinorStroke(theme, minor === null || minor === void 0 ? void 0 : minor.stroke, options === null || options === void 0 ? void 0 : options.stroke),
                text: this.toTickMinorText(theme, minor === null || minor === void 0 ? void 0 : minor.text),
                formatter: this.toTickMinorFormatter(theme, minor)
            };
        };
        DChartAxisBaseOptionParser.prototype.toBarStroke = function (theme, options) {
            return this.toStroke(options, undefined, theme.getStrokeEnable(), theme.getStrokeColor(), theme.getStrokeAlpha(), theme.getStrokeWidth(), theme.getStrokeAlign(), theme.getStrokeSide(), theme.getStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickStrokeEnable(), theme.getMajorTickStrokeColor(), theme.getMajorTickStrokeAlpha(), theme.getMajorTickStrokeWidth(), theme.getMajorTickStrokeAlign(), theme.getMajorTickStrokeSide(), theme.getMajorTickStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorGridlineStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickGridlineStrokeEnable(), theme.getMajorTickGridlineStrokeColor(), theme.getMajorTickGridlineStrokeAlpha(), theme.getMajorTickGridlineStrokeWidth(), theme.getMajorTickGridlineStrokeAlign(), theme.getMajorTickGridlineStrokeSide(), theme.getMajorTickGridlineStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorStroke = function (theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMinorTickStrokeEnable(), theme.getMinorTickStrokeColor(), theme.getMinorTickStrokeAlpha(), theme.getMinorTickStrokeWidth(), theme.getMinorTickStrokeAlign(), theme.getMinorTickStrokeSide(), theme.getMinorTickStrokeStyle());
        };
        DChartAxisBaseOptionParser.prototype.toStroke = function (optionsA, optionsB, enable, color, alpha, width, align, side, style) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
            if (optionsA) {
                if (optionsB) {
                    return {
                        enable: (_b = (_a = optionsA.enable) !== null && _a !== void 0 ? _a : optionsB.enable) !== null && _b !== void 0 ? _b : enable,
                        color: (_d = (_c = optionsA.color) !== null && _c !== void 0 ? _c : optionsB.color) !== null && _d !== void 0 ? _d : color,
                        alpha: (_f = (_e = optionsA.alpha) !== null && _e !== void 0 ? _e : optionsB.alpha) !== null && _f !== void 0 ? _f : alpha,
                        width: (_h = (_g = optionsA.width) !== null && _g !== void 0 ? _g : optionsB.width) !== null && _h !== void 0 ? _h : width,
                        align: (_k = (_j = optionsA.align) !== null && _j !== void 0 ? _j : optionsB.align) !== null && _k !== void 0 ? _k : align,
                        side: (_m = (_l = optionsA.side) !== null && _l !== void 0 ? _l : optionsB.side) !== null && _m !== void 0 ? _m : side,
                        style: this.toStrokeStyle((_p = (_o = optionsA.style) !== null && _o !== void 0 ? _o : optionsB.style) !== null && _p !== void 0 ? _p : style)
                    };
                }
                else {
                    return {
                        enable: (_q = optionsA.enable) !== null && _q !== void 0 ? _q : enable,
                        color: (_r = optionsA.color) !== null && _r !== void 0 ? _r : color,
                        alpha: (_s = optionsA.alpha) !== null && _s !== void 0 ? _s : alpha,
                        width: (_t = optionsA.width) !== null && _t !== void 0 ? _t : width,
                        align: (_u = optionsA.align) !== null && _u !== void 0 ? _u : align,
                        side: (_v = optionsA.side) !== null && _v !== void 0 ? _v : side,
                        style: this.toStrokeStyle((_w = optionsA.style) !== null && _w !== void 0 ? _w : style)
                    };
                }
            }
            else if (optionsB) {
                return {
                    enable: (_x = optionsB.enable) !== null && _x !== void 0 ? _x : enable,
                    color: (_y = optionsB.color) !== null && _y !== void 0 ? _y : color,
                    alpha: (_z = optionsB.alpha) !== null && _z !== void 0 ? _z : alpha,
                    width: (_0 = optionsB.width) !== null && _0 !== void 0 ? _0 : width,
                    align: (_1 = optionsB.align) !== null && _1 !== void 0 ? _1 : align,
                    side: (_2 = optionsB.side) !== null && _2 !== void 0 ? _2 : side,
                    style: this.toStrokeStyle((_3 = optionsB.style) !== null && _3 !== void 0 ? _3 : style)
                };
            }
            else {
                return {
                    enable: enable,
                    color: color,
                    alpha: alpha,
                    width: width,
                    align: align,
                    side: side,
                    style: style
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toStrokeStyle = function (target) {
            if (isString(target)) {
                return EShapeStrokeStyle[target];
            }
            else if (isArray(target)) {
                var result = EShapeStrokeStyle.NONE;
                for (var i = 0, imax = target.length; i < imax; ++i) {
                    result |= EShapeStrokeStyle[target[i]];
                }
                return result;
            }
            return target;
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorFormatter = function (theme, options) {
            var text = options === null || options === void 0 ? void 0 : options.text;
            if (text) {
                var format_1 = text.format;
                if (format_1 === null) {
                    return undefined;
                }
                else if (format_1 != null) {
                    return NumberFormatters.create(format_1);
                }
                else {
                    var formatter = text.formatter;
                    if (formatter) {
                        return {
                            format: formatter
                        };
                    }
                }
            }
            var format = theme.getMajorTickTextFormat();
            if (format != null) {
                return NumberFormatters.create(format);
            }
            return undefined;
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorText = function (theme, options) {
            options = options || {};
            return {
                format: options.format,
                color: this.toTickMajorTextColor(theme, options.color),
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: toEnum(options.weight, EShapeTextWeight),
                align: this.toTickMajorTextAlign(theme, options.align),
                offset: this.toTickMajorTextOffset(theme, options.offset),
                style: toEnum(options.style, EShapeTextStyle),
                outline: this.toTickMajorTextOutline(theme, options.outline),
                spacing: this.toTickMajorTextSpacing(theme, options.spacing),
                direction: this.toTickMajorTextDirection(theme, options.direction),
                padding: this.toTickMajorTextPadding(theme, options.padding),
                clipping: options.clipping
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextAlign = function (theme, options) {
            var _a, _b;
            var position = this.position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMajorTickTextAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMajorTickTextAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextPadding = function (theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMajorTickTextPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMajorTickTextPaddingVertical()
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextDirection = function (theme, options) {
            return toEnum(options !== null && options !== void 0 ? options : theme.getMajorTickTextDirection(), EShapeTextDirection);
        };
        DChartAxisBaseOptionParser.prototype.toTickMajorTextColor = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getMajorTickTextColor();
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorFormatter = function (theme, options) {
            var text = options === null || options === void 0 ? void 0 : options.text;
            if (text) {
                var format_2 = text.format;
                if (format_2 === null) {
                    return undefined;
                }
                else if (format_2 != null) {
                    return NumberFormatters.create(format_2);
                }
                else {
                    var formatter = text.formatter;
                    if (formatter) {
                        return {
                            format: formatter
                        };
                    }
                }
            }
            var format = theme.getMinorTickTextFormat();
            if (format != null) {
                return NumberFormatters.create(format);
            }
            return undefined;
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorText = function (theme, options) {
            options = options || {};
            return {
                format: options.format,
                color: this.toTickMinorTextColor(theme, options.color),
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: toEnum(options.weight, EShapeTextWeight),
                align: this.toTickMinorTextAlign(theme, options.align),
                offset: this.toTickMinorTextOffset(theme, options.offset),
                style: toEnum(options.style, EShapeTextStyle),
                outline: this.toTickMinorTextOutline(theme, options.outline),
                spacing: this.toTickMinorTextSpacing(theme, options.spacing),
                direction: this.toTickMinorTextDirection(theme, options.direction),
                padding: this.toTickMinorTextPadding(theme, options.padding),
                clipping: options.clipping
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextAlign = function (theme, options) {
            var _a, _b;
            var position = this.position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMinorTickTextAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMinorTickTextAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextPadding = function (theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMinorTickTextPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMinorTickTextPaddingVertical()
            };
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextDirection = function (theme, options) {
            return toEnum(options !== null && options !== void 0 ? options : theme.getMinorTickTextDirection(), EShapeTextDirection);
        };
        DChartAxisBaseOptionParser.prototype.toTickMinorTextColor = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getMinorTickTextColor();
        };
        DChartAxisBaseOptionParser.prototype.toLabel = function (theme, options) {
            var label = options === null || options === void 0 ? void 0 : options.label;
            if (label) {
                return {
                    value: label.value,
                    color: this.toLabelColor(theme, label.color),
                    alpha: label.alpha,
                    family: label.family,
                    size: label.size,
                    weight: toEnum(label.weight, EShapeTextWeight),
                    align: this.toLabelAlign(theme, label.align),
                    offset: this.toLabelOffset(theme, label.offset),
                    style: toEnum(label.style, EShapeTextStyle),
                    outline: this.toLabelOutline(theme, label.outline),
                    spacing: this.toLabelSpacing(theme, label.spacing),
                    direction: this.toLabelDirection(theme, label.direction),
                    padding: this.toLabelPadding(theme, label.padding),
                    clipping: label.clipping
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelOutline = function (theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelAlign = function (theme, options) {
            var _a, _b;
            var position = this.position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getLabelAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getLabelAlignVertical(position)
            };
        };
        DChartAxisBaseOptionParser.prototype.toLabelOffset = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelSpacing = function (theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        };
        DChartAxisBaseOptionParser.prototype.toLabelPadding = function (theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getLabelPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getLabelPaddingVertical()
            };
        };
        DChartAxisBaseOptionParser.prototype.toLabelDirection = function (theme, options) {
            return toEnum(options !== null && options !== void 0 ? options : theme.getLabelDirection(), EShapeTextDirection);
        };
        DChartAxisBaseOptionParser.prototype.toLabelColor = function (theme, options) {
            return options !== null && options !== void 0 ? options : theme.getLabelColor();
        };
        return DChartAxisBaseOptionParser;
    }());

    var DChartAxisBaseTickMajorGridline = /** @class */ (function () {
        function DChartAxisBaseTickMajorGridline(parser) {
            this._parser = parser;
            this._index = 0;
        }
        Object.defineProperty(DChartAxisBaseTickMajorGridline.prototype, "shapes", {
            get: function () {
                var result = this._shapes;
                if (result == null) {
                    result = this.newShapes();
                    this._shapes = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickMajorGridline.prototype.newShapes = function () {
            var _a;
            var result = [];
            var tick = this._parser.tick;
            var major = tick.major;
            var gridline = major.gridline;
            if (tick.enable && gridline.enable) {
                var capacity = major.capacity;
                var style = (_a = gridline.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
                var position = this.newShapePosition();
                for (var i = 0; i < capacity; ++i) {
                    var shape = new EShapeBar();
                    shape.points.position = position;
                    shape.points.style = style;
                    shape.stroke.copy(gridline.stroke);
                    result.push(shape);
                }
            }
            return result;
        };
        DChartAxisBaseTickMajorGridline.prototype.newShapePosition = function () {
            switch (this._parser.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.LEFT;
                default:
                    return EShapeBarPosition.TOP;
            }
        };
        DChartAxisBaseTickMajorGridline.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            var shapes = this.shapes;
            var containerContainer = container.container;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(containerContainer);
            }
        };
        DChartAxisBaseTickMajorGridline.prototype.unbind = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].detach();
                }
            }
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseTickMajorGridline.prototype.destroy = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].destroy();
                }
            }
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseTickMajorGridline;
    }());

    var DChartAxisBaseTickMajor = /** @class */ (function () {
        function DChartAxisBaseTickMajor(parser) {
            this._parser = parser;
            this._index = 0;
            this._gridline = new DChartAxisBaseTickMajorGridline(parser);
        }
        Object.defineProperty(DChartAxisBaseTickMajor.prototype, "shapes", {
            get: function () {
                var result = this._shapes;
                if (result == null) {
                    result = this.newShapes();
                    this._shapes = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickMajor.prototype.newShapes = function () {
            var _a;
            var result = [];
            var tick = this._parser.tick;
            if (tick.enable) {
                var major = tick.major;
                var capacity = major.capacity;
                var size = major.size;
                var position = major.position;
                var style = (_a = major.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
                for (var i = 0; i < capacity; ++i) {
                    var shape = new EShapeBar();
                    shape.points.position = position;
                    shape.points.size = size;
                    shape.points.style = style;
                    shape.stroke.copy(major.stroke);
                    shape.text.copy(major.text);
                    shape.size.set(0, 0);
                    result.push(shape);
                }
            }
            return result;
        };
        Object.defineProperty(DChartAxisBaseTickMajor.prototype, "gridline", {
            get: function () {
                return this._gridline;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickMajor.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            // Gridline
            this._gridline.bind(container, index);
            // Ticks
            var shapes = this.shapes;
            var containerContainer = container.container;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(containerContainer);
            }
        };
        DChartAxisBaseTickMajor.prototype.unbind = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].detach();
                }
            }
            this._gridline.unbind();
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseTickMajor.prototype.destroy = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].destroy();
                }
            }
            this._gridline.destroy();
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseTickMajor;
    }());

    var DChartAxisBaseTickMinor = /** @class */ (function () {
        function DChartAxisBaseTickMinor(parser) {
            this._parser = parser;
            this._index = 0;
        }
        Object.defineProperty(DChartAxisBaseTickMinor.prototype, "shapes", {
            get: function () {
                var result = this._shapes;
                if (result == null) {
                    result = this.newShapes();
                    this._shapes = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickMinor.prototype.newShapes = function () {
            var _a;
            var result = [];
            var tick = this._parser.tick;
            if (tick.enable) {
                var minor = tick.minor;
                var count = minor.count;
                var size = minor.size;
                var position = minor.position;
                var style = (_a = minor.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
                var major = tick.major;
                for (var i = 0, imax = (major.capacity + 1) * count; i < imax; ++i) {
                    var shape = new EShapeBar();
                    shape.points.position = position;
                    shape.points.size = size;
                    shape.points.style = style;
                    shape.stroke.copy(minor.stroke);
                    shape.text.copy(minor.text);
                    shape.size.set(0, 0);
                    result.push(shape);
                }
            }
            return result;
        };
        DChartAxisBaseTickMinor.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            var shapes = this.shapes;
            var containerContainer = container.container;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(containerContainer);
            }
        };
        DChartAxisBaseTickMinor.prototype.unbind = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].detach();
                }
            }
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseTickMinor.prototype.destroy = function () {
            var shapes = this._shapes;
            if (shapes != null) {
                for (var i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].destroy();
                }
            }
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseTickMinor;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartRegionImpl = /** @class */ (function () {
        function DChartRegionImpl(from, to) {
            this.from = from;
            this.to = to;
        }
        DChartRegionImpl.prototype.set = function (from, to) {
            if (from != null) {
                this.from = from;
            }
            if (to != null) {
                this.to = to;
            }
            return this;
        };
        DChartRegionImpl.prototype.add = function (from, to) {
            if (!isNaN$1(from)) {
                this.from = isNaN$1(this.from) ? from : Math.min(this.from, from);
            }
            if (!isNaN$1(to)) {
                this.to = isNaN$1(this.to) ? to : Math.max(this.to, to);
            }
            return this;
        };
        DChartRegionImpl.prototype.clear = function () {
            this.from = NaN;
            this.to = NaN;
            return this;
        };
        return DChartRegionImpl;
    }());

    var DChartAxisBaseTickContainer = /** @class */ (function () {
        function DChartAxisBaseTickContainer(parser, options) {
            this._parser = parser;
            this._index = 0;
            this._major = this.newMajor(parser, options);
            this._minor = this.newMinor(parser, options);
            this._majorTicks = [];
            this._minorTicks = [];
            this._work = new DChartRegionImpl(0, 0);
        }
        Object.defineProperty(DChartAxisBaseTickContainer.prototype, "major", {
            get: function () {
                return this._major;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickContainer.prototype.newMajor = function (parser, options) {
            return new DChartAxisBaseTickMajor(parser);
        };
        Object.defineProperty(DChartAxisBaseTickContainer.prototype, "minor", {
            get: function () {
                return this._minor;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBaseTickContainer.prototype.newMinor = function (parser, options) {
            return new DChartAxisBaseTickMinor(parser);
        };
        DChartAxisBaseTickContainer.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            this._major.bind(container, index);
            this._minor.bind(container, index);
        };
        DChartAxisBaseTickContainer.prototype.unbind = function () {
            this._minor.unbind();
            this._major.unbind();
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBaseTickContainer.prototype.update = function () {
            var container = this._container;
            var majorShapes = this._major.shapes;
            var minorShapes = this._minor.shapes;
            if (container != null && majorShapes && minorShapes) {
                var plotArea = container.plotArea;
                var transform = plotArea.container.transform.localTransform;
                var gridlineShapes = this._major.gridline.shapes;
                var parser = this._parser;
                var offset = parser.padding * this._index;
                var work = this._work;
                var coordinate = void 0;
                switch (parser.position) {
                    case DChartAxisPosition.TOP:
                        coordinate = plotArea.coordinate.x.get(parser.coordinate);
                        if (coordinate) {
                            var domain = this.getDomain(plotArea, coordinate, work);
                            var domainFrom = domain.from;
                            var domainTo = domain.to;
                            var domainVisible = this.getDomainVisible(plotArea, coordinate, work);
                            var domainVisibleFrom = domainVisible.from;
                            var domainVisibleTo = domainVisible.to;
                            var plotAreaHeight = plotArea.height;
                            return this.updateX(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, 0 - offset, transform, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.BOTTOM:
                        coordinate = plotArea.coordinate.x.get(parser.coordinate);
                        if (coordinate) {
                            var domain = this.getDomain(plotArea, coordinate, work);
                            var domainFrom = domain.from;
                            var domainTo = domain.to;
                            var domainVisible = this.getDomainVisible(plotArea, coordinate, work);
                            var domainVisibleFrom = domainVisible.from;
                            var domainVisibleTo = domainVisible.to;
                            var plotAreaHeight = plotArea.height;
                            return this.updateX(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaHeight + offset, transform, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.LEFT:
                        coordinate = plotArea.coordinate.y.get(parser.coordinate);
                        if (coordinate) {
                            var range = this.getRange(plotArea, coordinate, work);
                            var rangeFrom = range.from;
                            var rangeTo = range.to;
                            var rangeVisible = this.getRangeVisible(plotArea, coordinate, work);
                            var rangeVisibleFrom = rangeVisible.from;
                            var rangeVisibleTo = rangeVisible.to;
                            var plotAreaWidth = plotArea.width;
                            return this.updateY(rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, 0 - offset, transform, plotAreaWidth);
                        }
                        break;
                    case DChartAxisPosition.RIGHT:
                        coordinate = plotArea.coordinate.y.get(parser.coordinate);
                        if (coordinate) {
                            var range = this.getRange(plotArea, coordinate, work);
                            var rangeFrom = range.from;
                            var rangeTo = range.to;
                            var rangeVisible = this.getRangeVisible(plotArea, coordinate, work);
                            var rangeVisibleFrom = rangeVisible.from;
                            var rangeVisibleTo = rangeVisible.to;
                            var plotAreaWidth = plotArea.width;
                            return this.updateY(rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaWidth + offset, transform, plotAreaWidth);
                        }
                        break;
                }
            }
            return false;
        };
        DChartAxisBaseTickContainer.prototype.getDomain = function (plotArea, coordinate, result) {
            var bounds = plotArea.getBoundsInContainer();
            var transform = coordinate.transform;
            return result.set(coordinate.unmap(transform.unmap(bounds.x)), coordinate.unmap(transform.unmap(bounds.x + bounds.width)));
        };
        DChartAxisBaseTickContainer.prototype.getDomainVisible = function (plotArea, coordinate, result) {
            return result;
        };
        DChartAxisBaseTickContainer.prototype.getRange = function (plotArea, coordinate, result) {
            var bounds = plotArea.getBoundsInContainer();
            var transform = coordinate.transform;
            return result.set(coordinate.unmap(transform.unmap(bounds.y)), coordinate.unmap(transform.unmap(bounds.y + bounds.height)));
        };
        DChartAxisBaseTickContainer.prototype.getRangeVisible = function (plotArea, coordinate, result) {
            return result;
        };
        DChartAxisBaseTickContainer.prototype.updateX = function (domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionY, transform, plotAreaHeight) {
            var tick = this._parser.tick;
            var majorTick = tick.major;
            var majorCount = majorTick.count;
            var majorCapacity = majorTick.capacity;
            var majorStep = majorTick.step;
            var majorFormatter = majorTick.formatter;
            var minorTick = tick.minor;
            var minorCountPerMajor = minorTick.count;
            var minorCount = (majorCapacity + 1) * minorCountPerMajor;
            var minorStep = minorTick.step;
            var minorFormatter = minorTick.formatter;
            var majorTicks = this._majorTicks;
            var minorTicks = this._minorTicks;
            this.newTicks(coordinate, domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorTicks, minorTicks);
            var a = transform.a;
            var tx = transform.tx;
            for (var i = 0; i < majorCapacity; ++i) {
                var majorShape = majorShapes[i];
                var imajorTick = i * 3;
                var majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    var majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    var majotTickPositionX = a * majorTickProjectedPosition + tx;
                    var majorTickStep = majorTicks[imajorTick + 2];
                    this.showMajor(majorShape, majotTickPositionX, shapePositionY, majorFormatter === null || majorFormatter === void 0 ? void 0 : majorFormatter.format(majorTickPosition, majorTickStep));
                    if (i < gridlineShapes.length) {
                        this.showMajorGridline(gridlineShapes[i], majorTickPosition, majotTickPositionX, plotAreaHeight * 0.5, 0, plotAreaHeight);
                    }
                }
                else {
                    this.hideMajor(majorShape);
                    if (i < gridlineShapes.length) {
                        this.hideMajorGridline(gridlineShapes[i]);
                    }
                }
            }
            for (var i = 0; i < minorCount; ++i) {
                var minorShape = minorShapes[i];
                var iminorTick = i * 3;
                var minorTickPosition = minorTicks[iminorTick + 0];
                if (!isNaN(minorTickPosition)) {
                    var minorTickProjectedPosition = minorTicks[iminorTick + 1];
                    var minorTickPositionX = a * minorTickProjectedPosition + tx;
                    var minorTickStep = minorTicks[iminorTick + 2];
                    this.showMinor(minorShape, minorTickPositionX, shapePositionY, minorFormatter === null || minorFormatter === void 0 ? void 0 : minorFormatter.format(minorTickPosition, minorTickStep));
                }
                else {
                    this.hideMinor(minorShape);
                }
            }
            return true;
        };
        DChartAxisBaseTickContainer.prototype.updateY = function (rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionX, transform, plotAreaWidth) {
            var tick = this._parser.tick;
            var majorTick = tick.major;
            var majorCount = majorTick.count;
            var majorCapacity = majorTick.capacity;
            var majorStep = majorTick.step;
            var majorFormatter = majorTick.formatter;
            var minorTick = tick.minor;
            var minorCountPerMajor = minorTick.count;
            var minorCount = (majorCapacity + 1) * minorCountPerMajor;
            var minorStep = minorTick.step;
            var minorFormatter = minorTick.formatter;
            var majorTicks = this._majorTicks;
            var minorTicks = this._minorTicks;
            this.newTicks(coordinate, rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorTicks, minorTicks);
            var d = transform.d;
            var ty = transform.ty;
            for (var i = 0; i < majorCapacity; ++i) {
                var majorShape = majorShapes[i];
                var imajorTick = i * 3;
                var majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    var majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    var majotTickPositionY = d * majorTickProjectedPosition + ty;
                    var majorTickStep = majorTicks[imajorTick + 2];
                    this.showMajor(majorShape, shapePositionX, majotTickPositionY, majorFormatter === null || majorFormatter === void 0 ? void 0 : majorFormatter.format(majorTickPosition, majorTickStep));
                    if (i < gridlineShapes.length) {
                        this.showMajorGridline(gridlineShapes[i], majorTickPosition, plotAreaWidth * 0.5, majotTickPositionY, plotAreaWidth, 0);
                    }
                }
                else {
                    this.hideMajor(majorShape);
                    if (i < gridlineShapes.length) {
                        this.hideMajorGridline(gridlineShapes[i]);
                    }
                }
            }
            for (var i = 0; i < minorCount; ++i) {
                var minorShape = minorShapes[i];
                var iminorTick = i * 3;
                var minorTickPosition = minorTicks[iminorTick + 0];
                if (!isNaN(minorTickPosition)) {
                    var minorTickProjectedPosition = minorTicks[iminorTick + 1];
                    var minorTickPositionY = d * minorTickProjectedPosition + ty;
                    var minorTickStep = minorTicks[iminorTick + 2];
                    this.showMinor(minorShape, shapePositionX, minorTickPositionY, minorFormatter === null || minorFormatter === void 0 ? void 0 : minorFormatter.format(minorTickPosition, minorTickStep));
                }
                else {
                    this.hideMinor(minorShape);
                }
            }
            return true;
        };
        DChartAxisBaseTickContainer.prototype.showMajor = function (shape, x, y, text) {
            shape.disallowUploadedUpdate();
            shape.visible = true;
            shape.transform.position.set(x, y);
            shape.text.value = text != null ? text : "";
            shape.allowUploadedUpdate();
        };
        DChartAxisBaseTickContainer.prototype.showMajorGridline = function (shape, value, x, y, sx, sy) {
            shape.disallowUploadedUpdate();
            shape.visible = true;
            shape.transform.position.set(x, y);
            shape.size.set(sx, sy);
            shape.allowUploadedUpdate();
        };
        DChartAxisBaseTickContainer.prototype.hideMajor = function (shape) {
            shape.visible = false;
        };
        DChartAxisBaseTickContainer.prototype.hideMajorGridline = function (shape) {
            shape.visible = false;
        };
        DChartAxisBaseTickContainer.prototype.showMinor = function (shape, x, y, text) {
            shape.disallowUploadedUpdate();
            shape.visible = true;
            shape.transform.position.set(x, y);
            shape.text.value = text != null ? text : "";
            shape.allowUploadedUpdate();
        };
        DChartAxisBaseTickContainer.prototype.hideMinor = function (shape) {
            shape.visible = false;
        };
        DChartAxisBaseTickContainer.prototype.newTicks = function (coordinate, domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult) {
            coordinate.ticks(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult);
        };
        DChartAxisBaseTickContainer.prototype.destroy = function () {
            this._major.destroy();
            this._minor.destroy();
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisBaseTickContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisBase = /** @class */ (function () {
        function DChartAxisBase(options) {
            var theme = this.toTheme(options);
            this._theme = theme;
            var parser = this.newParser(theme, options);
            this._parser = parser;
            this._index = 0;
            this._bar = this.newBar(parser, theme, options);
            this._tick = this.newTick(parser, theme, options);
            this._guide = this.newGuide(parser, theme, options);
        }
        DChartAxisBase.prototype.newParser = function (theme, options) {
            return new DChartAxisBaseOptionParser(theme, options);
        };
        Object.defineProperty(DChartAxisBase.prototype, "position", {
            get: function () {
                return this._parser.position;
            },
            set: function (position) {
                this._parser.position = position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBase.prototype, "coordinate", {
            get: function () {
                return this._parser.coordinate;
            },
            set: function (coordinate) {
                this._parser.coordinate = coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBase.prototype, "padding", {
            get: function () {
                return this._parser.padding;
            },
            set: function (padding) {
                this._parser.padding = padding;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisBase.prototype, "bar", {
            get: function () {
                return this._bar;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBase.prototype.newBar = function (parser, theme, options) {
            return new DChartAxisBaseBar(parser);
        };
        Object.defineProperty(DChartAxisBase.prototype, "tick", {
            get: function () {
                return this._tick;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBase.prototype.newTick = function (parser, theme, options) {
            return new DChartAxisBaseTickContainer(parser);
        };
        Object.defineProperty(DChartAxisBase.prototype, "guide", {
            get: function () {
                return this._guide;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisBase.prototype.newGuide = function (parser, theme, options) {
            var result = new DChartAxisBaseGuideContainer(this);
            var list = parser.guide.list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                result.add(list[i]);
            }
            return result;
        };
        DChartAxisBase.prototype.bind = function (container, index) {
            this._container = container;
            this._index = index;
            this._bar.bind(container, index);
            this._tick.bind(container, index);
            this._guide.bind(container, index);
        };
        DChartAxisBase.prototype.unbind = function () {
            this._guide.unbind();
            this._tick.unbind();
            this._bar.unbind();
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisBase.prototype.update = function () {
            var isBarUpdated = this._bar.update();
            var isTicksUpdated = this._tick.update();
            var isGuideUpdated = this._guide.update();
            if (isBarUpdated || isTicksUpdated || isGuideUpdated) {
                var container = this._container;
                if (container) {
                    DApplications.update(container.plotArea);
                }
            }
        };
        DChartAxisBase.prototype.onRender = function () {
            this._bar.update();
            this._tick.update();
            this._guide.update();
        };
        DChartAxisBase.prototype.destroy = function () {
            this._bar.destroy();
            this._tick.destroy();
            this._guide.destroy();
            this._container = undefined;
        };
        DChartAxisBase.prototype.toTheme = function (options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        };
        DChartAxisBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartAxisBase.prototype.getType = function () {
            return "DChartAxisBase";
        };
        return DChartAxisBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartAxisContainerImpl = /** @class */ (function () {
        function DChartAxisContainerImpl(plotArea, options) {
            this._plotArea = plotArea;
            this._container = new EShapeContainer();
            this._list = new Map();
        }
        Object.defineProperty(DChartAxisContainerImpl.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartAxisContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisContainerImpl.prototype.add = function (axis) {
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes == null) {
                axes = [];
                list.set(axis.position, axes);
            }
            axes.push(axis);
            axis.bind(this, axes.length - 1);
        };
        DChartAxisContainerImpl.prototype.get = function (position, index) {
            var list = this._list;
            var axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                if (0 <= index && index < axes.length) {
                    return axes[index];
                }
            }
            return null;
        };
        DChartAxisContainerImpl.prototype.indexOf = function (axis) {
            var list = this._list;
            var axes = list.get(axis.position);
            if (axes) {
                return axes.indexOf(axis);
            }
            return -1;
        };
        DChartAxisContainerImpl.prototype.clear = function (position) {
            var list = this._list;
            var axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            }
            return this;
        };
        DChartAxisContainerImpl.prototype.size = function (position) {
            var list = this._list;
            var axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                return axes.length;
            }
            return 0;
        };
        DChartAxisContainerImpl.prototype.update = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].update();
                }
            });
        };
        DChartAxisContainerImpl.prototype.onRender = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].onRender();
                }
            });
        };
        DChartAxisContainerImpl.prototype.destroy = function () {
            this._list.forEach(function (axes) {
                for (var i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            });
        };
        return DChartAxisContainerImpl;
    }());

    var DChartAxisGuideSimpleShapeImpl = /** @class */ (function () {
        function DChartAxisGuideSimpleShapeImpl(options) {
            this._options = options;
        }
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "bar", {
            get: function () {
                var result = this._bar;
                if (result === undefined) {
                    result = this.newBar();
                    this._bar = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newBar = function () {
            var _a, _b;
            var bar = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.bar) !== null && _b !== void 0 ? _b : {};
            if (bar.enable !== false) {
                var result = new EShapeBar();
                result.stroke.copy(this.toStrokeOptions(bar.stroke, EShapeStrokeStyle.DASHED));
                result.text.copy(this.toTextOptions(bar.text));
                return result;
            }
            return null;
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toStrokeOptions = function (options, style) {
            var _a;
            options = options || {};
            return {
                enable: options.enable,
                color: options.color,
                alpha: options.alpha,
                width: options.width,
                align: options.align,
                side: toEnum(options.side, EShapeStrokeSide),
                style: toEnum((_a = options.style) !== null && _a !== void 0 ? _a : style, EShapeStrokeStyle)
            };
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toTextOptions = function (options) {
            options = options || {};
            return {
                value: options.value,
                color: options.color,
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: toEnum(options.weight, EShapeTextWeight),
                align: this.toTextAlignOptions(options.align),
                offset: options.offset,
                style: toEnum(options.style, EShapeTextStyle),
                outline: options.outline,
                spacing: options.spacing,
                direction: toEnum(options.direction, EShapeTextDirection),
                padding: options.padding,
                clipping: options.clipping,
                fitting: options.fitting
            };
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toTextAlignOptions = function (options) {
            options = options || {};
            return {
                horizontal: toEnum(options === null || options === void 0 ? void 0 : options.horizontal, EShapeTextAlignHorizontal),
                vertical: toEnum(options === null || options === void 0 ? void 0 : options.vertical, EShapeTextAlignVertical)
            };
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toBarPosition = function (axis) {
            switch (axis.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.LEFT;
                default:
                    return EShapeBarPosition.TOP;
            }
        };
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "label", {
            get: function () {
                var result = this._label;
                if (result === undefined) {
                    result = this.newLabel();
                    this._label = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newLabel = function () {
            var _a, _b, _c, _d;
            var label = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : {};
            if (label.enable === true) {
                var result = new EShapeRectangleRounded();
                result.stroke.copy(this.toStrokeOptions(label.stroke));
                result.fill.copy(label.fill);
                result.text.copy(this.toTextOptions(label.text));
                result.size.set((_c = label.width) !== null && _c !== void 0 ? _c : 50, (_d = label.height) !== null && _d !== void 0 ? _d : 30);
                return result;
            }
            return null;
        };
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "labelMargin", {
            get: function () {
                var result = this._labelMargin;
                if (result == null) {
                    result = this.newLabelMargin();
                    this._labelMargin = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newLabelMargin = function () {
            var options = this._options;
            if (options != null) {
                var label = options.label;
                if (label != null) {
                    var result = label.margin;
                    if (result != null) {
                        return result;
                    }
                }
            }
            return 10;
        };
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "tick", {
            get: function () {
                var result = this._tick;
                if (result === undefined) {
                    result = this.newTick();
                    this._tick = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newTick = function () {
            var _a, _b, _c;
            var tick = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.tick) !== null && _b !== void 0 ? _b : {};
            if (tick.enable === true) {
                var result = new EShapeBar();
                result.stroke.copy(this.toStrokeOptions(tick.stroke));
                result.text.copy(this.toTextOptions(tick.text));
                var size = (_c = tick.size) !== null && _c !== void 0 ? _c : 5;
                result.size.set(size, size);
                return result;
            }
            return null;
        };
        Object.defineProperty(DChartAxisGuideSimpleShapeImpl.prototype, "tickMargin", {
            get: function () {
                var result = this._tickMargin;
                if (result == null) {
                    result = this.newTickMargin();
                    this._tickMargin = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimpleShapeImpl.prototype.newTickMargin = function () {
            var options = this._options;
            if (options != null) {
                var tick = options.tick;
                if (tick != null) {
                    var result = tick.margin;
                    if (result != null) {
                        return result;
                    }
                }
            }
            return 0;
        };
        DChartAxisGuideSimpleShapeImpl.prototype.toTickPosition = function (axis) {
            switch (axis.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.LEFT;
                default:
                    return EShapeBarPosition.TOP;
            }
        };
        DChartAxisGuideSimpleShapeImpl.prototype.bind = function (container, index, axis) {
            var bar = this.bar;
            if (bar != null) {
                bar.points.position = this.toBarPosition(axis);
                bar.attach(container.container);
            }
            var label = this.label;
            if (label != null) {
                label.attach(container.container);
            }
            var tick = this.tick;
            if (tick != null) {
                tick.points.position = this.toTickPosition(axis);
                tick.attach(container.container);
            }
        };
        DChartAxisGuideSimpleShapeImpl.prototype.unbind = function () {
            var bar = this._bar;
            if (bar != null) {
                bar.detach();
            }
            var label = this._label;
            if (label != null) {
                label.detach();
            }
            var tick = this._tick;
            if (tick != null) {
                tick.detach();
            }
        };
        DChartAxisGuideSimpleShapeImpl.prototype.update = function (position, x, y, visible, width, height, offset) {
            var bar = this._bar;
            if (bar != null) {
                bar.disallowUploadedUpdate();
                switch (position) {
                    case DChartAxisPosition.TOP:
                        bar.transform.position.set(x, y);
                        bar.size.set(0, height);
                        bar.visible = visible;
                        break;
                    case DChartAxisPosition.BOTTOM:
                        bar.transform.position.set(x, y);
                        bar.size.set(0, height);
                        bar.visible = visible;
                        break;
                    case DChartAxisPosition.LEFT:
                        bar.transform.position.set(x, y);
                        bar.size.set(width, 0);
                        bar.visible = visible;
                        break;
                    case DChartAxisPosition.RIGHT:
                        bar.transform.position.set(x, y);
                        bar.size.set(width, 0);
                        bar.visible = visible;
                        break;
                }
                bar.allowUploadedUpdate();
            }
            var label = this._label;
            if (label != null) {
                var m = this.labelMargin;
                var s = label.size;
                var ox = offset + s.x * 0.5 + m;
                var oy = offset + s.y * 0.5 + m;
                label.disallowUploadedUpdate();
                switch (position) {
                    case DChartAxisPosition.TOP:
                        label.transform.position.set(x, -oy);
                        label.visible = visible;
                        break;
                    case DChartAxisPosition.BOTTOM:
                        label.transform.position.set(x, height + oy);
                        label.visible = visible;
                        break;
                    case DChartAxisPosition.LEFT:
                        label.transform.position.set(-ox, y);
                        label.visible = visible;
                        break;
                    case DChartAxisPosition.RIGHT:
                        label.transform.position.set(width + ox, y);
                        label.visible = visible;
                        break;
                }
                label.allowUploadedUpdate();
            }
            var tick = this._tick;
            if (tick != null) {
                var m = this.tickMargin;
                var s = tick.size;
                var ox = offset + s.x * 0.5 + m;
                var oy = offset + s.y * 0.5 + m;
                tick.disallowUploadedUpdate();
                switch (position) {
                    case DChartAxisPosition.TOP:
                        tick.transform.position.set(x, -oy);
                        tick.visible = visible;
                        break;
                    case DChartAxisPosition.BOTTOM:
                        tick.transform.position.set(x, height + oy);
                        tick.visible = visible;
                        break;
                    case DChartAxisPosition.LEFT:
                        tick.transform.position.set(-ox, y);
                        tick.visible = visible;
                        break;
                    case DChartAxisPosition.RIGHT:
                        tick.transform.position.set(width + ox, y);
                        tick.visible = visible;
                        break;
                }
                tick.allowUploadedUpdate();
            }
            return true;
        };
        DChartAxisGuideSimpleShapeImpl.prototype.destroy = function () {
            var bar = this._bar;
            if (bar != null) {
                bar.destroy();
            }
            var label = this._label;
            if (label != null) {
                label.destroy();
            }
            var tick = this._tick;
            if (tick != null) {
                tick.destroy();
            }
        };
        return DChartAxisGuideSimpleShapeImpl;
    }());

    var DChartAxisGuideSimple = /** @class */ (function () {
        function DChartAxisGuideSimple(options) {
            var _a;
            this._options = options;
            this._index = 0;
            this._position = (_a = options === null || options === void 0 ? void 0 : options.position) !== null && _a !== void 0 ? _a : 0;
            this._work = new pixi_js.Point();
            this._isShown = true;
        }
        Object.defineProperty(DChartAxisGuideSimple.prototype, "shape", {
            get: function () {
                var result = this._shape;
                if (result == null) {
                    result = this.newShape();
                    this._shape = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimple.prototype.newShape = function () {
            return new DChartAxisGuideSimpleShapeImpl(this._options);
        };
        Object.defineProperty(DChartAxisGuideSimple.prototype, "position", {
            get: function () {
                return this._position;
            },
            set: function (position) {
                this._position = position;
            },
            enumerable: false,
            configurable: true
        });
        DChartAxisGuideSimple.prototype.show = function () {
            this._isShown = true;
            return this;
        };
        DChartAxisGuideSimple.prototype.isShown = function () {
            return this._isShown;
        };
        DChartAxisGuideSimple.prototype.hide = function () {
            this._isShown = false;
            return this;
        };
        DChartAxisGuideSimple.prototype.isHidden = function () {
            return !this._isShown;
        };
        DChartAxisGuideSimple.prototype.bind = function (container, index, axis) {
            this._container = container;
            this._index = index;
            this._axis = axis;
            this.shape.bind(container, index, axis);
        };
        DChartAxisGuideSimple.prototype.unbind = function () {
            var shape = this._shape;
            if (shape != null) {
                shape.unbind();
            }
            this._axis = undefined;
            this._index = 0;
            this._container = undefined;
        };
        DChartAxisGuideSimple.prototype.update = function () {
            var container = this._container;
            var index = this._index;
            var shape = this._shape;
            var axis = this._axis;
            if (shape != null && container != null && axis != null) {
                var plotArea = container.plotArea;
                var transform = plotArea.container.transform.localTransform;
                var plotAreaWidth = plotArea.width;
                var plotAreaHeight = plotArea.height;
                var offset = axis.padding * index;
                switch (axis.position) {
                    case DChartAxisPosition.TOP:
                    case DChartAxisPosition.BOTTOM:
                        var coordinateX = plotArea.coordinate.x.get(axis.coordinate);
                        if (coordinateX) {
                            var work = this._work;
                            work.set(coordinateX.transform.map(coordinateX.map(this._position)), 0);
                            transform.apply(work, work);
                            var x = work.x;
                            shape.update(axis.position, x, plotAreaHeight * 0.5, this._isShown && 0 <= x && x <= plotAreaWidth, plotAreaWidth, plotAreaHeight, offset);
                        }
                        else {
                            shape.update(axis.position, 0, plotAreaHeight * 0.5, false, plotAreaWidth, plotAreaHeight, offset);
                        }
                        break;
                    case DChartAxisPosition.LEFT:
                    case DChartAxisPosition.RIGHT:
                        var coordinateY = plotArea.coordinate.y.get(axis.coordinate);
                        if (coordinateY) {
                            var work = this._work;
                            work.set(0, coordinateY.transform.map(coordinateY.map(this._position)));
                            transform.apply(work, work);
                            var y = work.y;
                            shape.update(axis.position, plotAreaWidth * 0.5, y, this._isShown && 0 <= y && y <= plotAreaHeight, plotAreaWidth, plotAreaHeight, offset);
                        }
                        else {
                            shape.update(axis.position, plotAreaWidth * 0.5, 0, false, plotAreaWidth, plotAreaHeight, offset);
                        }
                        break;
                }
                return true;
            }
            return false;
        };
        DChartAxisGuideSimple.prototype.destroy = function () {
            var shape = this._shape;
            if (shape != null) {
                shape.destroy();
            }
            this._index = 0;
            this._container = undefined;
        };
        return DChartAxisGuideSimple;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis.
     */
    var DChartAxisX = /** @class */ (function (_super) {
        __extends(DChartAxisX, _super);
        function DChartAxisX() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisX.prototype.getType = function () {
            return "DChartAxisX";
        };
        return DChartAxisX;
    }(DChartAxisBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis for datetimes.
     */
    var DChartAxisXDatetime = /** @class */ (function (_super) {
        __extends(DChartAxisXDatetime, _super);
        function DChartAxisXDatetime() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisXDatetime.prototype.getType = function () {
            return "DChartAxisXDatetime";
        };
        return DChartAxisXDatetime;
    }(DChartAxisX));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An Y axis.
     */
    var DChartAxisY = /** @class */ (function (_super) {
        __extends(DChartAxisY, _super);
        function DChartAxisY() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartAxisY.prototype.getType = function () {
            return "DChartAxisY";
        };
        return DChartAxisY;
    }(DChartAxisBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCHART_COLOR_SET_1 = [0x10b7e3, 0xfe5420, 0xf0c312, 0x1c5d71];
    var DCHART_COLOR_SET_2 = [
        DCHART_COLOR_SET_1[0],
        UtilRgb.brighten(DCHART_COLOR_SET_1[0], 0.4),
        DCHART_COLOR_SET_1[1],
        UtilRgb.brighten(DCHART_COLOR_SET_1[1], 0.4),
        DCHART_COLOR_SET_1[2],
        UtilRgb.brighten(DCHART_COLOR_SET_1[2], 0.4),
        DCHART_COLOR_SET_1[3],
        UtilRgb.brighten(DCHART_COLOR_SET_1[3], 0.4)
    ];
    var DChartColorSet1 = function (index) {
        return DCHART_COLOR_SET_1[index % DCHART_COLOR_SET_1.length];
    };
    var DChartColorSet2 = function (index) {
        return DCHART_COLOR_SET_2[index % DCHART_COLOR_SET_2.length];
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateDirection = {
        X: 0,
        Y: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateTransformImpl = /** @class */ (function () {
        function DChartCoordinateTransformImpl(options) {
            this._theme = this.toTheme(options);
            this._id = 0;
            this._isTranslationEnabled = options === null || options === void 0 ? void 0 : options.translation;
            this._translate = 0;
            this._isScalingEnabled = options === null || options === void 0 ? void 0 : options.scaling;
            this._scale = 1;
            this._itranslate = 0;
            this._iscale = 1;
        }
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "translate", {
            get: function () {
                return this._translate;
            },
            set: function (translate) {
                this.set(translate);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateTransformImpl.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            set: function (scale) {
                this.set(undefined, scale);
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateTransformImpl.prototype.bind = function (container, direction) {
            this.set(0, direction === DChartCoordinateDirection.X ? +1 : -1);
        };
        DChartCoordinateTransformImpl.prototype.unbind = function () {
            // DO NOTHING
        };
        DChartCoordinateTransformImpl.prototype.set = function (translate, scale) {
            var isChanged = false;
            if (translate != null &&
                this._isTranslationEnabled !== false &&
                this._translate !== translate) {
                isChanged = true;
                this._translate = translate;
            }
            if (scale != null && this._isScalingEnabled !== false && this._scale !== scale) {
                isChanged = true;
                this._scale = scale;
            }
            if (isChanged) {
                this._id += 1;
                this._iscale = this._theme.isZero(this._scale) ? 0 : 1 / this._scale;
                this._itranslate = -this._translate * this._iscale;
            }
        };
        DChartCoordinateTransformImpl.prototype.blend = function (ratio, mark) {
            var ratioi = 1 - ratio;
            var newTranslate = mark.newTranslate * ratio + mark.oldTranslate * ratioi;
            var newScale = mark.newScale * ratio + mark.oldScale * ratioi;
            this.set(newTranslate, newScale);
        };
        DChartCoordinateTransformImpl.prototype.map = function (value) {
            return this._translate + this._scale * value;
        };
        DChartCoordinateTransformImpl.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            var translate = this._translate;
            var scale = this._scale;
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = translate + scale * values[i];
            }
        };
        DChartCoordinateTransformImpl.prototype.unmap = function (value) {
            return this._itranslate + this._iscale * value;
        };
        DChartCoordinateTransformImpl.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            var itranslate = this._itranslate;
            var iscale = this._iscale;
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = itranslate + iscale * values[i];
            }
        };
        DChartCoordinateTransformImpl.prototype.toTheme = function (options) {
            return (options && options.theme) || this.getThemeDefault();
        };
        DChartCoordinateTransformImpl.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateTransformImpl.prototype.getType = function () {
            return "DChartCoordinateTransform";
        };
        return DChartCoordinateTransformImpl;
    }());

    var DChartCoordinateTransformMarkImpl = /** @class */ (function () {
        function DChartCoordinateTransformMarkImpl() {
            this.oldTranslate = 0;
            this.oldScale = 1;
            this.newTranslate = 0;
            this.newScale = 1;
        }
        DChartCoordinateTransformMarkImpl.prototype.set = function (translate, scale) {
            if (translate != null) {
                this.newTranslate = translate;
            }
            if (scale != null) {
                this.newScale = scale;
            }
        };
        return DChartCoordinateTransformMarkImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateBase = /** @class */ (function () {
        function DChartCoordinateBase(options) {
            this._id = 0;
            this._direction = DChartCoordinateDirection.X;
            this._theme = this.toTheme(options);
            this._transform = this.newTransform(options === null || options === void 0 ? void 0 : options.transform);
            this._tick = this.newTick(options === null || options === void 0 ? void 0 : options.tick);
            this._work = this.newRegion();
            this._mark = this.newMark();
            this._from = options === null || options === void 0 ? void 0 : options.from;
            this._to = options === null || options === void 0 ? void 0 : options.to;
        }
        DChartCoordinateBase.prototype.newTransform = function (options) {
            return new DChartCoordinateTransformImpl(options);
        };
        DChartCoordinateBase.prototype.newRegion = function () {
            return new DChartRegionImpl(NaN, NaN);
        };
        DChartCoordinateBase.prototype.newMark = function () {
            return new DChartCoordinateTransformMarkImpl();
        };
        Object.defineProperty(DChartCoordinateBase.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                this._from = from;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateBase.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                this._to = to;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateBase.prototype.bind = function (container, direction) {
            this._container = container;
            this._direction = direction;
            this._transform.bind(container, direction);
        };
        DChartCoordinateBase.prototype.unbind = function () {
            this._container = undefined;
            this._transform.unbind();
        };
        DChartCoordinateBase.prototype.fit = function (from, to) {
            this.doFit(from, to, this._transform);
        };
        DChartCoordinateBase.prototype.mark = function (from, to) {
            var mark = this._mark;
            var transform = this._transform;
            mark.oldTranslate = transform.translate;
            mark.oldScale = transform.scale;
            this.doFit(from, to, mark);
        };
        DChartCoordinateBase.prototype.blend = function (ratio) {
            this._transform.blend(ratio, this._mark);
        };
        DChartCoordinateBase.prototype.doFit = function (from, to, result) {
            var container = this._container;
            if (container) {
                var plotArea = container.container.plotArea;
                var work = this._work;
                switch (this._direction) {
                    case DChartCoordinateDirection.X:
                        this.getPixelDomain(plotArea, work);
                        this.doFit_(work.from, work.to, this.toFitDomain(from, to, plotArea, work), result);
                        break;
                    case DChartCoordinateDirection.Y:
                        this.getPixelRange(plotArea, work);
                        this.doFit_(work.from, work.to, this.toFitRange(from, to, plotArea, work), result);
                        break;
                }
            }
        };
        DChartCoordinateBase.prototype.getPixelDomain = function (plotArea, result) {
            var padding = plotArea.padding;
            return result.set(padding.getLeft(), plotArea.width - padding.getRight());
        };
        DChartCoordinateBase.prototype.getPixelRange = function (plotArea, result) {
            var padding = plotArea.padding;
            return result.set(plotArea.height - padding.getBottom(), padding.getTop());
        };
        DChartCoordinateBase.prototype.toFitDomain = function (from, to, plotArea, result) {
            if (from == null) {
                from = this._from;
            }
            if (to == null) {
                to = this._to;
            }
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getDomain(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateBase.prototype.toFitRange = function (from, to, plotArea, result) {
            if (from == null) {
                from = this._from;
            }
            if (to == null) {
                to = this._to;
            }
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getRange(this, result);
                result.set(from, to);
            }
            return result;
        };
        DChartCoordinateBase.prototype.doFit_ = function (pixelFrom, pixelTo, region, result) {
            var regionFrom = region.from;
            var regionTo = region.to;
            if (!(isNaN$1(regionFrom) || isNaN$1(regionTo))) {
                // Scale
                var newScale = 1;
                var regionFromMapped = this.map(regionFrom);
                var regionToMapped = this.map(regionTo);
                var regionSizeMapped = regionToMapped - regionFromMapped;
                if (!this._theme.isZero(regionSizeMapped)) {
                    var pixelSize = pixelTo - pixelFrom;
                    newScale = pixelSize / regionSizeMapped;
                }
                else {
                    newScale = pixelTo < pixelFrom ? -1 : 1;
                }
                // Translation
                var newTranslation = pixelFrom - regionFromMapped * newScale;
                // Done
                result.set(newTranslation, newScale);
            }
        };
        Object.defineProperty(DChartCoordinateBase.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateBase.prototype, "transform", {
            get: function () {
                return this._transform;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateBase.prototype.map = function (value) {
            return value;
        };
        DChartCoordinateBase.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            // DO NOTHING
        };
        DChartCoordinateBase.prototype.unmap = function (value) {
            return value;
        };
        DChartCoordinateBase.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            // DO NOTHING
        };
        DChartCoordinateBase.prototype.ticks = function (domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult) {
            this._tick.calculate(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult, this);
        };
        DChartCoordinateBase.prototype.toTheme = function (options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        };
        DChartCoordinateBase.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateBase.prototype.getType = function () {
            return "DChartCoordinate";
        };
        return DChartCoordinateBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateContainerSubImpl = /** @class */ (function () {
        function DChartCoordinateContainerSubImpl(container, direction) {
            this._container = container;
            this._direction = direction;
            this._list = [];
        }
        Object.defineProperty(DChartCoordinateContainerSubImpl.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateContainerSubImpl.prototype.add = function (coordinate, index) {
            var list = this._list;
            if (index == null) {
                list.push(coordinate);
            }
            else if (0 <= index && index < list.length) {
                list.splice(index, 0, coordinate);
            }
            else {
                list.push(coordinate);
            }
            coordinate.bind(this, this._direction);
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartCoordinateContainerSubImpl.prototype.indexOf = function (coordinate) {
            return this._list.indexOf(coordinate);
        };
        DChartCoordinateContainerSubImpl.prototype.remove = function (coordinateOrIndex) {
            var list = this._list;
            if (isNumber(coordinateOrIndex)) {
                var index = coordinateOrIndex;
                if (0 <= index && index < list.length) {
                    var removed = list.splice(index, 1)[0];
                    removed.unbind();
                    return removed;
                }
            }
            else {
                var coordinate = coordinateOrIndex;
                var index = list.indexOf(coordinate);
                if (0 <= index) {
                    list.splice(index, 1);
                    coordinate.unbind();
                    return coordinate;
                }
            }
            return null;
        };
        DChartCoordinateContainerSubImpl.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].unbind();
            }
            list.length = 0;
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.destroy = function () {
            return this.clear();
        };
        DChartCoordinateContainerSubImpl.prototype.size = function () {
            return this._list.length;
        };
        DChartCoordinateContainerSubImpl.prototype.fit = function (from, to) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].fit(from, to);
            }
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.mark = function (from, to) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].mark(from, to);
            }
            return this;
        };
        DChartCoordinateContainerSubImpl.prototype.blend = function (ratio) {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].blend(ratio);
            }
            return this;
        };
        return DChartCoordinateContainerSubImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateContainerImpl = /** @class */ (function () {
        function DChartCoordinateContainerImpl(plotArea, options) {
            this._plotArea = plotArea;
            var x = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.X);
            this._x = x;
            var y = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.Y);
            this._y = y;
            if (options) {
                var cxs = options.x;
                if (cxs) {
                    if (isArray(cxs)) {
                        for (var i = 0, imax = cxs.length; i < imax; ++i) {
                            x.add(cxs[i]);
                        }
                    }
                    else {
                        x.add(cxs);
                    }
                }
                var cys = options.y;
                if (cys) {
                    if (isArray(cys)) {
                        for (var i = 0, imax = cys.length; i < imax; ++i) {
                            y.add(cys[i]);
                        }
                    }
                    else {
                        y.add(cys);
                    }
                }
            }
        }
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartCoordinateContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        DChartCoordinateContainerImpl.prototype.fit = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.fit(domainFrom, domainTo);
            this._y.fit(rangeFrom, rangeTo);
            return this;
        };
        DChartCoordinateContainerImpl.prototype.mark = function (domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.mark(domainFrom, domainTo);
            this._y.mark(rangeFrom, rangeTo);
            return this;
        };
        DChartCoordinateContainerImpl.prototype.blend = function (ratio) {
            this._x.blend(ratio);
            this._y.blend(ratio);
            return this;
        };
        return DChartCoordinateContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLinearTick = /** @class */ (function () {
        function DChartCoordinateLinearTick(options) {
            this._theme = this.toTheme(options);
        }
        DChartCoordinateLinearTick.prototype.toMajorStep = function (domainMin, domainMax, majorCount, majorStep) {
            if (majorStep == null) {
                if (0 < majorCount) {
                    return this._theme.toStep(domainMin, domainMax, majorCount);
                }
                return -1;
            }
            else if (isNumber(majorStep)) {
                return majorStep;
            }
            else {
                return majorStep(domainMin, domainMax, majorCount);
            }
        };
        DChartCoordinateLinearTick.prototype.toMinorStep = function (majorStep, minorCount, minorStep) {
            if (minorStep == null) {
                if (0 <= majorStep) {
                    return this.calcStepMinor(majorStep, minorCount);
                }
                return -1;
            }
            else if (isNumber(minorStep)) {
                return minorStep;
            }
            else {
                return minorStep(majorStep, minorCount);
            }
        };
        DChartCoordinateLinearTick.prototype.calcStepMinor = function (majorStep, minorCount) {
            return majorStep / (minorCount + 1);
        };
        DChartCoordinateLinearTick.prototype.calcTickMinorPositions = function (step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (var i = 0; i < count; i += 1) {
                var minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        };
        DChartCoordinateLinearTick.prototype.calculate = function (domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            var transform = coordinate.transform;
            var domainMin = Math.min(domainFrom, domainTo);
            var domainMax = Math.max(domainFrom, domainTo);
            var domainVisibleMin = Math.min(domainVisibleFrom, domainVisibleTo);
            var domainVisibleMax = Math.max(domainVisibleFrom, domainVisibleTo);
            var domainVisibleMinMapped = coordinate.map(domainVisibleMin);
            var domainVisibleMaxMapped = coordinate.map(domainVisibleMax);
            var from0 = Math.min(domainVisibleMinMapped, domainVisibleMaxMapped);
            var to0 = Math.max(domainVisibleMinMapped, domainVisibleMaxMapped);
            var domainMinMapped = coordinate.map(domainMin);
            var domainMaxMapped = coordinate.map(domainMax);
            var from1 = Math.min(domainMinMapped, domainMaxMapped);
            var to1 = Math.max(domainMinMapped, domainMaxMapped);
            var from = Math.max(from0, from1);
            var to = Math.min(to0, to1);
            var imajor = 0;
            var iminor = 0;
            var majorStepMapped = this.toMajorStep(domainMinMapped, domainMaxMapped, majorCount, majorStep);
            if (majorStepMapped <= 0) {
                if (from <= domainMinMapped && domainMinMapped <= to) {
                    majorResult[0] = domainMin;
                    majorResult[1] = transform.map(domainMinMapped);
                    majorResult[2] = 0;
                    imajor += 1;
                }
            }
            else {
                // Major tick start position
                var idomainStartMapped = Math.floor(domainMinMapped / majorStepMapped) - 1;
                var idomainEndMapped = Math.ceil(domainMaxMapped / majorStepMapped) + 1;
                // Major / minor tick positions
                var minorStepMapped = this.toMinorStep(majorStepMapped, minorCountPerMajor, minorStep);
                for (var i = idomainStartMapped; i <= idomainEndMapped; ++i) {
                    var majorPositionMapped = i * majorStepMapped;
                    if (imajor < majorCapacity) {
                        if (from <= majorPositionMapped && majorPositionMapped <= to) {
                            var imajorResult = imajor * 3;
                            majorResult[imajorResult + 0] = coordinate.unmap(majorPositionMapped);
                            majorResult[imajorResult + 1] = transform.map(majorPositionMapped);
                            majorResult[imajorResult + 2] = majorStepMapped;
                            imajor += 1;
                        }
                    }
                    for (var j = 0; j < minorCountPerMajor; j += 1) {
                        if (iminor < minorCount) {
                            var minorPositionMapped = majorPositionMapped + (j + 1) * minorStepMapped;
                            if (from <= minorPositionMapped && minorPositionMapped <= to) {
                                var iminorResult = iminor * 3;
                                minorResult[iminorResult + 0] = coordinate.unmap(minorPositionMapped);
                                minorResult[iminorResult + 1] = transform.map(minorPositionMapped);
                                minorResult[iminorResult + 2] = minorStepMapped;
                                iminor += 1;
                            }
                        }
                    }
                }
            }
            for (var i = imajor; i < majorCapacity; ++i) {
                var imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (var i = iminor; i < minorCount; ++i) {
                var iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        };
        DChartCoordinateLinearTick.prototype.toTheme = function (options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        };
        DChartCoordinateLinearTick.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateLinearTick.prototype.getType = function () {
            return "DChartCoordinateTick";
        };
        return DChartCoordinateLinearTick;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLinear = /** @class */ (function (_super) {
        __extends(DChartCoordinateLinear, _super);
        function DChartCoordinateLinear() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartCoordinateLinear.prototype.newTick = function (options) {
            return new DChartCoordinateLinearTick(options);
        };
        return DChartCoordinateLinear;
    }(DChartCoordinateBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLogTick = /** @class */ (function () {
        function DChartCoordinateLogTick(options) {
            this._theme = this.toTheme(options);
        }
        DChartCoordinateLogTick.prototype.toMajorStep = function (domainMin, domainMax, majorCount, majorStep) {
            if (majorStep == null) {
                if (0 < majorCount) {
                    return this._theme.toStep(domainMin, domainMax, majorCount);
                }
                return -1;
            }
            else if (isNumber(majorStep)) {
                return majorStep;
            }
            else {
                return majorStep(domainMin, domainMax, majorCount);
            }
        };
        DChartCoordinateLogTick.prototype.toMinorStep = function (majorStep, minorCount, minorStep) {
            if (minorStep == null) {
                if (0 <= majorStep) {
                    return this.calcStepMinor(majorStep, minorCount);
                }
                return -1;
            }
            else if (isNumber(minorStep)) {
                return minorStep;
            }
            else {
                return minorStep(majorStep, minorCount);
            }
        };
        DChartCoordinateLogTick.prototype.calcStepMinor = function (majorStep, minorCount) {
            return majorStep / (minorCount + 1);
        };
        DChartCoordinateLogTick.prototype.calcTickMinorPositions = function (step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (var i = 0; i < count; i += 1) {
                var minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        };
        DChartCoordinateLogTick.prototype.calculate = function (domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            var transform = coordinate.transform;
            var domainMin = Math.min(domainFrom, domainTo);
            var domainMax = Math.max(domainFrom, domainTo);
            var domainVisibleMin = Math.min(domainVisibleFrom, domainVisibleTo);
            var domainVisibleMax = Math.max(domainVisibleFrom, domainVisibleTo);
            var domainVisibleMinMapped = coordinate.map(domainVisibleMin);
            var domainVisibleMaxMapped = coordinate.map(domainVisibleMax);
            var from0 = Math.min(domainVisibleMinMapped, domainVisibleMaxMapped);
            var to0 = Math.max(domainVisibleMinMapped, domainVisibleMaxMapped);
            var domainMinMapped = coordinate.map(domainMin);
            var domainMaxMapped = coordinate.map(domainMax);
            var from1 = Math.min(domainMinMapped, domainMaxMapped);
            var to1 = Math.max(domainMinMapped, domainMaxMapped);
            var from = Math.max(from0, from1);
            var to = Math.min(to0, to1);
            var imajor = 0;
            var iminor = 0;
            var majorStepMapped = this.toMajorStep(domainMinMapped, domainMaxMapped, majorCount, majorStep);
            if (majorStepMapped <= 0) {
                if (from <= domainMinMapped && domainMinMapped <= to) {
                    majorResult[0] = domainMin;
                    majorResult[1] = transform.map(domainMinMapped);
                    majorResult[2] = 0;
                    imajor += 1;
                }
            }
            else {
                // Major tick start position
                var idomainStartMapped = Math.floor(domainMinMapped / majorStepMapped) - 1;
                var idomainEndMapped = Math.ceil(domainMaxMapped / majorStepMapped) + 1;
                // Major / minor tick positions
                var minorStepMapped = this.toMinorStep(majorStepMapped, minorCountPerMajor, minorStep);
                for (var i = idomainStartMapped; i <= idomainEndMapped; ++i) {
                    var majorPositionMapped = i * majorStepMapped;
                    if (imajor < majorCapacity) {
                        if (from <= majorPositionMapped && majorPositionMapped <= to) {
                            var imajorResult = imajor * 3;
                            majorResult[imajorResult + 0] = coordinate.unmap(majorPositionMapped);
                            majorResult[imajorResult + 1] = transform.map(majorPositionMapped);
                            majorResult[imajorResult + 2] = coordinate.unmap(majorPositionMapped - 1);
                            imajor += 1;
                        }
                    }
                    for (var j = 0; j < minorCountPerMajor; j += 1) {
                        if (iminor < minorCount) {
                            var minorPositionMapped = majorPositionMapped + (j + 1) * minorStepMapped;
                            if (from <= minorPositionMapped && minorPositionMapped <= to) {
                                var iminorResult = iminor * 3;
                                minorResult[iminorResult + 0] = coordinate.unmap(minorPositionMapped);
                                minorResult[iminorResult + 1] = transform.map(minorPositionMapped);
                                minorResult[iminorResult + 2] = coordinate.unmap(minorPositionMapped - 1);
                                iminor += 1;
                            }
                        }
                    }
                }
            }
            for (var i = imajor; i < majorCapacity; ++i) {
                var imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (var i = iminor; i < minorCount; ++i) {
                var iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        };
        DChartCoordinateLogTick.prototype.toTheme = function (options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        };
        DChartCoordinateLogTick.prototype.getThemeDefault = function () {
            return DThemes.getInstance().get(this.getType());
        };
        DChartCoordinateLogTick.prototype.getType = function () {
            return "DChartCoordinateTick";
        };
        return DChartCoordinateLogTick;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartCoordinateLog = /** @class */ (function (_super) {
        __extends(DChartCoordinateLog, _super);
        function DChartCoordinateLog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartCoordinateLog.prototype.newTick = function (options) {
            return new DChartCoordinateLogTick(options);
        };
        DChartCoordinateLog.prototype.map = function (value) {
            return Math.log(Math.max(0, value)) / Math.LN10;
        };
        DChartCoordinateLog.prototype.mapAll = function (values, ifrom, iend, stride, offset) {
            var factor = 1 / Math.LN10;
            for (var i = ifrom + offset; i < iend; i += stride) {
                var value = values[i];
                values[i] = Math.log(Math.max(0, value)) * factor;
            }
        };
        DChartCoordinateLog.prototype.unmap = function (value) {
            return Math.pow(10, value);
        };
        DChartCoordinateLog.prototype.unmapAll = function (values, ifrom, iend, stride, offset) {
            for (var i = ifrom + offset; i < iend; i += stride) {
                values[i] = Math.pow(10, values[i]);
            }
        };
        return DChartCoordinateLog;
    }(DChartCoordinateBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartLegendItem = /** @class */ (function (_super) {
        __extends(DChartLegendItem, _super);
        function DChartLegendItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartLegendItem.prototype.getType = function () {
            return "DChartLegendItem";
        };
        return DChartLegendItem;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartLegend = /** @class */ (function (_super) {
        __extends(DChartLegend, _super);
        function DChartLegend() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartLegend.prototype.getType = function () {
            return "DChartLegend";
        };
        return DChartLegend;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartOverview = /** @class */ (function (_super) {
        __extends(DChartOverview, _super);
        function DChartOverview() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartOverview.prototype.getType = function () {
            return "DChartOverview";
        };
        return DChartOverview;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaContainer = /** @class */ (function (_super) {
        __extends(DChartPlotAreaContainer, _super);
        function DChartPlotAreaContainer(onChange) {
            var _this = _super.call(this) || this;
            var transform = _this.transform;
            _this._position = new DBasePoint(transform.position, onChange);
            _this._scale = new DBasePoint(transform.scale, onChange);
            _this._workRect = new pixi_js.Rectangle();
            return _this;
        }
        Object.defineProperty(DChartPlotAreaContainer.prototype, "position", {
            // @ts-ignore
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaContainer.prototype, "scale", {
            // @ts-ignore
            get: function () {
                return this._scale;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaContainer.prototype.getBounds = function (skipUpdate, rect) {
            this._lastBoundsID = -1;
            return _super.prototype.getBounds.call(this, skipUpdate, rect);
        };
        DChartPlotAreaContainer.prototype.calculateBounds = function () {
            var bounds = this._bounds;
            var work = this._work;
            var rect = this._workRect;
            var worldTransform = this.transform.worldTransform;
            var xmin = 0;
            var xmax = 0;
            var ymin = 0;
            var ymax = 0;
            var children = this.children;
            if (0 < children.length) {
                var isFirst = true;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child.visible) {
                        child.getBoundsInternal(false, rect);
                        if (isFirst) {
                            isFirst = false;
                            xmin = rect.x;
                            ymin = rect.y;
                            xmax = rect.x + rect.width;
                            ymax = rect.y + rect.height;
                        }
                        else {
                            xmin = Math.min(xmin, rect.x);
                            ymin = Math.min(ymin, rect.y);
                            xmax = Math.max(xmax, rect.x + rect.width);
                            ymax = Math.max(ymax, rect.y + rect.height);
                        }
                    }
                }
            }
            bounds.clear();
            work.set(xmin, ymin);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(xmax, ymax);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
        };
        return DChartPlotAreaContainer;
    }(EShapeContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesHitResult = /** @class */ (function () {
        function DChartSeriesHitResult() {
            this.shape = null;
            this.x = 0;
            this.y = 0;
            this.p0x = 0;
            this.p0y = 0;
            this.p1x = 0;
            this.p1y = 0;
            this.index = 0;
            this.t = 0;
            this.distance = 0;
        }
        DChartSeriesHitResult.prototype.copyFrom = function (other) {
            this.shape = other.shape;
            this.x = other.x;
            this.y = other.y;
            this.p0x = other.p0x;
            this.p0y = other.p0y;
            this.p1x = other.p1x;
            this.p1y = other.p1y;
            this.index = other.index;
            this.t = other.t;
            this.distance = other.distance;
            return this;
        };
        return DChartSeriesHitResult;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesFillComputedImpl = /** @class */ (function () {
        function DChartSeriesFillComputedImpl(enable, color, alpha) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
        }
        DChartSeriesFillComputedImpl.from = function (base, index, fill) {
            var _a, _b, _c;
            return new DChartSeriesFillComputedImpl((_a = fill === null || fill === void 0 ? void 0 : fill.enable) !== null && _a !== void 0 ? _a : base.enable(index), (_b = fill === null || fill === void 0 ? void 0 : fill.color) !== null && _b !== void 0 ? _b : base.color(index), (_c = fill === null || fill === void 0 ? void 0 : fill.alpha) !== null && _c !== void 0 ? _c : base.alpha(index));
        };
        return DChartSeriesFillComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesScalars = /** @class */ (function () {
        function DChartSeriesScalars() {
        }
        DChartSeriesScalars.from = function (value, def) {
            if (isArray(value)) {
                return function (index) { return value[index % value.length]; };
            }
            else if (isFunction(value)) {
                return value;
            }
            else if (value != null) {
                return function () { return value; };
            }
            else if (isArray(def)) {
                return function (index) { return def[index % def.length]; };
            }
            else if (isFunction(def)) {
                return def;
            }
            else {
                return function () { return def; };
            }
        };
        return DChartSeriesScalars;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesFillImpl = /** @class */ (function () {
        function DChartSeriesFillImpl(options) {
            this.enable = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.enable, true);
            this.color = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.alpha, EShapeDefaults.FILL_ALPHA);
        }
        return DChartSeriesFillImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPaddingComputedImpl = /** @class */ (function () {
        function DChartSeriesPaddingComputedImpl(outer, inner) {
            this.outer = outer;
            this.inner = inner;
        }
        DChartSeriesPaddingComputedImpl.from = function (base, index, point) {
            var _a, _b;
            return new DChartSeriesPaddingComputedImpl((_a = point === null || point === void 0 ? void 0 : point.outer) !== null && _a !== void 0 ? _a : base.outer(index), (_b = point === null || point === void 0 ? void 0 : point.inner) !== null && _b !== void 0 ? _b : base.inner(index));
        };
        return DChartSeriesPaddingComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPaddingImpl = /** @class */ (function () {
        function DChartSeriesPaddingImpl(options) {
            this.outer = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.outer, 0.2);
            this.inner = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.inner, 0.1);
        }
        return DChartSeriesPaddingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPointComputedImpl = /** @class */ (function () {
        function DChartSeriesPointComputedImpl(x, y) {
            this.x = x;
            this.y = y;
        }
        DChartSeriesPointComputedImpl.from = function (base, index, point, x, y) {
            var _a, _b;
            return new DChartSeriesPointComputedImpl((_a = point === null || point === void 0 ? void 0 : point.x) !== null && _a !== void 0 ? _a : (base.x != null ? base.x(index) : x), (_b = point === null || point === void 0 ? void 0 : point.y) !== null && _b !== void 0 ? _b : (base.y != null ? base.y(index) : y));
        };
        return DChartSeriesPointComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesPointImpl = /** @class */ (function () {
        function DChartSeriesPointImpl(options) {
            if (options) {
                if (options.x != null) {
                    this.x = DChartSeriesScalars.from(options.x, 0);
                }
                if (options.y != null) {
                    this.y = DChartSeriesScalars.from(options.y, 0);
                }
            }
        }
        return DChartSeriesPointImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesStrokeComputedImpl = /** @class */ (function () {
        function DChartSeriesStrokeComputedImpl(enable, color, alpha, width, align, side, style) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
            this.width = width;
            this.align = align;
            this.side = side;
            this.style = style;
        }
        DChartSeriesStrokeComputedImpl.from = function (base, index, stroke) {
            var _a, _b, _c, _d, _e, _f, _g;
            return new DChartSeriesStrokeComputedImpl((_a = stroke === null || stroke === void 0 ? void 0 : stroke.enable) !== null && _a !== void 0 ? _a : base.enable(index), (_b = stroke === null || stroke === void 0 ? void 0 : stroke.color) !== null && _b !== void 0 ? _b : base.color(index), (_c = stroke === null || stroke === void 0 ? void 0 : stroke.alpha) !== null && _c !== void 0 ? _c : base.alpha(index), (_d = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _d !== void 0 ? _d : base.width(index), (_e = stroke === null || stroke === void 0 ? void 0 : stroke.align) !== null && _e !== void 0 ? _e : base.align(index), (_f = stroke === null || stroke === void 0 ? void 0 : stroke.side) !== null && _f !== void 0 ? _f : base.side(index), (_g = stroke === null || stroke === void 0 ? void 0 : stroke.style) !== null && _g !== void 0 ? _g : base.style(index));
        };
        return DChartSeriesStrokeComputedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesStrokeImpl = /** @class */ (function () {
        function DChartSeriesStrokeImpl(options) {
            this.enable = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.enable, true);
            this.color = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.alpha, EShapeDefaults.STROKE_ALPHA);
            this.width = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.width, EShapeDefaults.STROKE_WIDTH);
            this.align = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.width, EShapeDefaults.STROKE_ALIGN);
            this.side = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.side, EShapeStrokeSide.ALL);
            this.style = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.style, EShapeStrokeStyle.NON_SCALING);
        }
        return DChartSeriesStrokeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesContainerImpl = /** @class */ (function () {
        function DChartSeriesContainerImpl(plotArea, options) {
            var _a;
            this._plotArea = plotArea;
            this._domain = new DChartRegionImpl(NaN, NaN);
            this._range = new DChartRegionImpl(NaN, NaN);
            this._selection = (_a = options === null || options === void 0 ? void 0 : options.selection) !== null && _a !== void 0 ? _a : null;
            this._fill = new DChartSeriesFillImpl(options === null || options === void 0 ? void 0 : options.fill);
            this._stroke = new DChartSeriesStrokeImpl(options === null || options === void 0 ? void 0 : options.stroke);
            this._size = new DChartSeriesPointImpl(options === null || options === void 0 ? void 0 : options.size);
            this._offset = new DChartSeriesPointImpl(options === null || options === void 0 ? void 0 : options.offset);
            this._padding = new DChartSeriesPaddingImpl(options === null || options === void 0 ? void 0 : options.padding);
            this._list = [];
        }
        DChartSeriesContainerImpl.prototype.newFill = function (index, options) {
            return DChartSeriesFillComputedImpl.from(this._fill, index, options);
        };
        DChartSeriesContainerImpl.prototype.newStroke = function (index, options) {
            return DChartSeriesStrokeComputedImpl.from(this._stroke, index, options);
        };
        DChartSeriesContainerImpl.prototype.newSize = function (index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._size, index, options, x, y);
        };
        DChartSeriesContainerImpl.prototype.newOffset = function (index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._offset, index, options, x, y);
        };
        DChartSeriesContainerImpl.prototype.newPadding = function (index, options) {
            return DChartSeriesPaddingComputedImpl.from(this._padding, index, options);
        };
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "plotArea", {
            get: function () {
                return this._plotArea;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesContainerImpl.prototype.update = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].update();
            }
            var selection = this._selection;
            if (selection) {
                selection.update();
            }
        };
        DChartSeriesContainerImpl.prototype.onRender = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].onRender();
            }
            var selection = this._selection;
            if (selection) {
                selection.onRender();
            }
        };
        DChartSeriesContainerImpl.prototype.add = function (series) {
            var list = this._list;
            series.bind(this, list.length);
            list.push(series);
        };
        DChartSeriesContainerImpl.prototype.get = function (index) {
            var list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        };
        DChartSeriesContainerImpl.prototype.indexOf = function (series) {
            return this._list.indexOf(series);
        };
        DChartSeriesContainerImpl.prototype.clear = function () {
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            return this;
        };
        DChartSeriesContainerImpl.prototype.size = function () {
            return this._list.length;
        };
        DChartSeriesContainerImpl.prototype.destroy = function () {
            this.clear();
            var selection = this._selection;
            if (selection) {
                selection.unbind();
            }
        };
        DChartSeriesContainerImpl.prototype.getDomain = function (coordinate, result) {
            result.clear();
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                var series = list[i];
                if (series.coordinate.x === coordinate) {
                    var domain = series.domain;
                    result.add(domain.from, domain.to);
                }
            }
            return result;
        };
        DChartSeriesContainerImpl.prototype.getRange = function (coordinate, result) {
            result.clear();
            var list = this._list;
            for (var i = 0, imax = list.length; i < imax; ++i) {
                var series = list[i];
                if (series.coordinate.y === coordinate) {
                    var range = series.range;
                    result.add(range.from, range.to);
                }
            }
            return result;
        };
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "domain", {
            get: function () {
                var result = this._domain;
                result.clear();
                var list = this._list;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var domain = list[i].domain;
                    result.add(domain.from, domain.to);
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesContainerImpl.prototype, "range", {
            get: function () {
                var result = this._range;
                result.clear();
                var list = this._list;
                for (var i = 0, imax = list.length; i < imax; ++i) {
                    var range = list[i].range;
                    result.add(range.from, range.to);
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesContainerImpl.prototype.hitTest = function (x, y) {
            var list = this._list;
            for (var i = list.length - 1; 0 <= i; --i) {
                var series = list[i];
                if (series.hitTest(x, y)) {
                    return series;
                }
            }
            return null;
        };
        DChartSeriesContainerImpl.prototype.calcHitPoint = function (x, y, result) {
            var tmp1 = result;
            var tmp2 = DChartSeriesContainerImpl.WORK_CALCHITPOINT;
            var list = this._list;
            var closest = null;
            tmp2.distance = +Infinity;
            for (var i = list.length - 1; 0 <= i; --i) {
                var series = list[i];
                if (series.calcHitPoint(x, y, tmp1)) {
                    if (tmp1.distance < tmp2.distance) {
                        closest = series;
                        var tmp = tmp1;
                        tmp1 = tmp2;
                        tmp2 = tmp;
                    }
                }
            }
            if (closest && tmp2 !== result) {
                result.copyFrom(tmp2);
            }
            return closest;
        };
        DChartSeriesContainerImpl.WORK_CALCHITPOINT = new DChartSeriesHitResult();
        return DChartSeriesContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartPlotAreaImpl = /** @class */ (function (_super) {
        __extends(DChartPlotAreaImpl, _super);
        function DChartPlotAreaImpl(chart, options) {
            var _this = _super.call(this, options) || this;
            _this._chart = chart;
            _this._blendStartTime = 0;
            _this._blendDuration = 1000;
            _this._blendTimeout = null;
            _this._onBlendBound = function () {
                _this.onBlend();
            };
            return _this;
        }
        DChartPlotAreaImpl.prototype.init = function (options) {
            var _this = this;
            var _a;
            _super.prototype.init.call(this, options);
            this._isBoundsInContainerDirty = true;
            this._boundsInContainer = new pixi_js.Rectangle();
            this._workPoint = new pixi_js.Point();
            // Container
            var container = new DChartPlotAreaContainer(function () {
                _this._isViewDirty = true;
                _this._isBoundsInContainerDirty = true;
                DApplications.update(_this);
            });
            this._container = container;
            this.addChild(container);
            // View
            this._isViewDirty = true;
            this._view = new DViewImpl(this, function () { return container; }, options === null || options === void 0 ? void 0 : options.view);
            // Coordinate container
            this._coordinate = new DChartCoordinateContainerImpl(this, options === null || options === void 0 ? void 0 : options.coordinate);
            // Series container
            var series = new DChartSeriesContainerImpl(this, options === null || options === void 0 ? void 0 : options.series);
            this._series = series;
            // Axis container
            var axis = new DChartAxisContainerImpl(this, options === null || options === void 0 ? void 0 : options.axis);
            this._axis = axis;
            this.addChild(axis.container);
            // Selection
            var selection = series.selection;
            if (selection) {
                selection.bind(series);
            }
            // Overflow mask
            var mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : this.theme.isOverflowMaskEnabled();
            if (mask) {
                container.mask = this.getOverflowMask();
            }
            // Add series and axes
            if (options != null) {
                // Series
                var s = options.series;
                if (s != null) {
                    var list = s.list;
                    if (list) {
                        var listLength = list.length;
                        if (0 < listLength) {
                            for (var i = 0; i < listLength; ++i) {
                                series.add(list[i]);
                            }
                            series.update();
                        }
                    }
                }
                // Axes
                var a = options.axis;
                if (a != null) {
                    var list = a.list;
                    if (list) {
                        for (var i = 0, imax = list.length; i < imax; ++i) {
                            axis.add(list[i]);
                        }
                    }
                }
            }
        };
        DChartPlotAreaImpl.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            this._isViewDirty = true;
            this._isBoundsInContainerDirty = true;
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
        };
        DChartPlotAreaImpl.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        Object.defineProperty(DChartPlotAreaImpl.prototype, "chart", {
            get: function () {
                return this._chart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaImpl.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaImpl.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaImpl.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaImpl.prototype, "axis", {
            get: function () {
                return this._axis;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartPlotAreaImpl.prototype, "view", {
            get: function () {
                return this._view;
            },
            enumerable: false,
            configurable: true
        });
        DChartPlotAreaImpl.prototype.onWheel = function (e, deltas, global) {
            var vresult = this._view.onWheel(e, deltas, global);
            var sresult = _super.prototype.onWheel.call(this, e, deltas, global);
            return vresult || sresult;
        };
        DChartPlotAreaImpl.prototype.onDblClick = function (e, interactionManager) {
            var vresult = this._view.onDblClick(e, interactionManager);
            var sresult = _super.prototype.onDblClick.call(this, e, interactionManager);
            return vresult || sresult;
        };
        DChartPlotAreaImpl.prototype.onDown = function (e) {
            this._view.onDown(e);
            _super.prototype.onDown.call(this, e);
        };
        DChartPlotAreaImpl.prototype.render = function (renderer) {
            if (this._isViewDirty) {
                this._isViewDirty = false;
                this._coordinate.fit();
                this._axis.onRender();
                this._series.onRender();
            }
            _super.prototype.render.call(this, renderer);
        };
        DChartPlotAreaImpl.prototype.destroy = function () {
            this._container.destroy();
            this._series.destroy();
            this._axis.destroy();
        };
        DChartPlotAreaImpl.prototype.getType = function () {
            return "DChartPlotArea";
        };
        DChartPlotAreaImpl.prototype.getBoundsInContainer = function () {
            var result = this._boundsInContainer;
            if (this._isBoundsInContainerDirty) {
                this._isBoundsInContainerDirty = false;
                var container = this.container;
                container.updateTransform();
                var transform = container.transform.localTransform;
                var work = this._workPoint;
                work.set(0, 0);
                transform.applyInverse(work, work);
                result.x = work.x;
                result.y = work.y;
                work.set(this.width, this.height);
                transform.applyInverse(work, work);
                result.width = work.x - result.x;
                result.height = work.y - result.y;
            }
            return result;
        };
        DChartPlotAreaImpl.prototype.fit = function (duration, domainFrom, domainTo, rangeFrom, rangeTo) {
            var coordinate = this._coordinate;
            var axis = this._axis;
            var series = this._series;
            if (duration != null && duration <= 0) {
                coordinate.fit(domainFrom, domainTo, rangeFrom, rangeTo);
                axis.update();
                series.update();
            }
            else {
                this._blendDuration = duration != null ? duration : 200;
                this._blendStartTime = Date.now();
                coordinate.mark(domainFrom, domainTo, rangeFrom, rangeTo);
                var blendTimeout = this._blendTimeout;
                if (blendTimeout != null) {
                    window.clearTimeout(blendTimeout);
                }
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            return this;
        };
        DChartPlotAreaImpl.prototype.onBlend = function () {
            var now = Date.now();
            var ratio = (now - this._blendStartTime) / this._blendDuration;
            if (ratio < 1) {
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            else {
                this._blendTimeout = null;
                ratio = 1;
            }
            this._coordinate.blend(DAnimationTimings.ELASTIC(ratio));
            this._axis.update();
            this._series.update();
        };
        return DChartPlotAreaImpl;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartRegionImplObservable = /** @class */ (function () {
        function DChartRegionImplObservable(from, to, onChange) {
            this._from = from;
            this._to = to;
            this._onChange = onChange;
        }
        Object.defineProperty(DChartRegionImplObservable.prototype, "from", {
            get: function () {
                return this._from;
            },
            set: function (from) {
                this.set(from, undefined);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartRegionImplObservable.prototype, "to", {
            get: function () {
                return this._to;
            },
            set: function (to) {
                this.set(undefined, to);
            },
            enumerable: false,
            configurable: true
        });
        DChartRegionImplObservable.prototype.set = function (from, to) {
            var isChanged = false;
            if (from != null && this._from !== from) {
                if (!isNaN$1(this._from) || !isNaN$1(from)) {
                    this._from = from;
                    isChanged = true;
                }
            }
            if (to != null && this._to !== to) {
                if (!isNaN$1(this._to) || !isNaN$1(to)) {
                    this._to = to;
                    isChanged = true;
                }
            }
            if (isChanged) {
                this._onChange();
            }
            return this;
        };
        DChartRegionImplObservable.prototype.add = function (from, to) {
            var newFrom;
            if (!isNaN$1(from)) {
                newFrom = isNaN$1(this.from) ? from : Math.min(this.from, from);
            }
            var newTo;
            if (!isNaN$1(to)) {
                newTo = isNaN$1(this.to) ? to : Math.max(this.to, to);
            }
            return this.set(newFrom, newTo);
        };
        DChartRegionImplObservable.prototype.clear = function () {
            return this.set(NaN, NaN);
        };
        return DChartRegionImplObservable;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionContainerImpl = /** @class */ (function () {
        function DChartSelectionContainerImpl(x, y) {
            this._x = x;
            this._y = y;
        }
        Object.defineProperty(DChartSelectionContainerImpl.prototype, "x", {
            get: function () {
                return this._x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionContainerImpl.prototype, "y", {
            get: function () {
                return this._y;
            },
            enumerable: false,
            configurable: true
        });
        DChartSelectionContainerImpl.prototype.bind = function (container) {
            this._x.bind(container);
            this._y.bind(container);
        };
        DChartSelectionContainerImpl.prototype.unbind = function () {
            this._x.unbind();
            this._y.unbind();
        };
        DChartSelectionContainerImpl.prototype.set = function (container, position, mappedPosition, series) {
            this._x.set(container, position, mappedPosition, series);
            this._y.set(container, position, mappedPosition, series);
        };
        DChartSelectionContainerImpl.prototype.unset = function () {
            this._x.unset();
            this._y.unset();
        };
        DChartSelectionContainerImpl.prototype.update = function (container, position, mappedPosition) {
            var isXUpdated = this._x.update(container, position, mappedPosition);
            var isYUpdated = this._y.update(container, position, mappedPosition);
            return isXUpdated || isYUpdated;
        };
        return DChartSelectionContainerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionShapeBase = /** @class */ (function () {
        function DChartSelectionShapeBase(options) {
            var _a, _b, _c;
            var theme = this.toTheme(options);
            this._theme = theme;
            var state = new DBaseStateSetImpl().add((_a = options === null || options === void 0 ? void 0 : options.state) !== null && _a !== void 0 ? _a : DBaseState.HOVERED);
            this._state = state;
            this._isEnabled = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isEnabled(state);
            if (options != null) {
                var shape = options.shape;
                if (shape != null) {
                    if (isFunction(shape)) {
                        this._newShape = shape;
                    }
                    else {
                        this._shape = shape;
                    }
                }
            }
            this._style = (_c = options === null || options === void 0 ? void 0 : options.style) !== null && _c !== void 0 ? _c : this.setStyle;
        }
        DChartSelectionShapeBase.prototype.bind = function (container) {
            if (this._isEnabled) {
                var shape = this._shape;
                if (shape == null) {
                    var state = this._state;
                    var newShape = this._newShape;
                    if (newShape != null) {
                        shape = newShape(state);
                    }
                    else {
                        shape = this.newShape(state, this._theme);
                    }
                }
                this._shape = shape;
                shape.attach(container.plotArea.axis.container);
                shape.visible = false;
            }
        };
        DChartSelectionShapeBase.prototype.unbind = function () {
            var shape = this._shape;
            if (shape) {
                shape.detach();
            }
        };
        DChartSelectionShapeBase.prototype.newShape = function (state, theme) {
            return theme.newShape(state);
        };
        DChartSelectionShapeBase.prototype.set = function (container, position, mappedPosition, series) {
            this.update(container, position, mappedPosition);
            var shape = this._shape;
            if (shape) {
                this._style(shape, series);
            }
        };
        DChartSelectionShapeBase.prototype.setStyle = function (shape, series) {
            // DO NOTHING
        };
        DChartSelectionShapeBase.prototype.unset = function () {
            var shape = this._shape;
            if (shape) {
                shape.visible = false;
            }
        };
        DChartSelectionShapeBase.prototype.toTheme = function (options) {
            var theme = options === null || options === void 0 ? void 0 : options.theme;
            if (isString(theme)) {
                return this.getTheme(theme);
            }
            else if (theme != null) {
                return theme;
            }
            else {
                return this.getTheme(this.getType());
            }
        };
        DChartSelectionShapeBase.prototype.getTheme = function (type) {
            return DThemes.getInstance().get(type);
        };
        return DChartSelectionShapeBase;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineX = /** @class */ (function (_super) {
        __extends(DChartSelectionGridlineX, _super);
        function DChartSelectionGridlineX() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionGridlineX.prototype.update = function (container, position, mappedPosition) {
            var shape = this._shape;
            if (shape) {
                var mappedX = mappedPosition.x;
                var height = container.plotArea.height;
                shape.transform.position.set(mappedX, height * 0.5);
                shape.size.set(0, height);
                shape.visible = this.isVisible(container, position, mappedPosition);
                return true;
            }
            return false;
        };
        DChartSelectionGridlineX.prototype.isVisible = function (container, position, mappedPosition) {
            var x = mappedPosition.x;
            return 0 <= x && x <= container.plotArea.width;
        };
        DChartSelectionGridlineX.prototype.getType = function () {
            return "DChartSelectionGridlineX";
        };
        return DChartSelectionGridlineX;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionGridlineY = /** @class */ (function (_super) {
        __extends(DChartSelectionGridlineY, _super);
        function DChartSelectionGridlineY() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionGridlineY.prototype.update = function (container, position, mappedPosition) {
            var shape = this._shape;
            if (shape) {
                var mappedY = mappedPosition.y;
                var width = container.plotArea.width;
                shape.transform.position.set(width * 0.5, mappedY);
                shape.size.set(width, 0);
                shape.visible = this.isVisible(container, position, mappedPosition);
                return true;
            }
            return false;
        };
        DChartSelectionGridlineY.prototype.isVisible = function (container, position, mappedPosition) {
            var y = mappedPosition.y;
            return 0 <= y && y <= container.plotArea.height;
        };
        DChartSelectionGridlineY.prototype.getType = function () {
            return "DChartSelectionGridlineY";
        };
        return DChartSelectionGridlineY;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionMarker = /** @class */ (function (_super) {
        __extends(DChartSelectionMarker, _super);
        function DChartSelectionMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSelectionMarker.prototype.update = function (container, position, mappedPosition) {
            var shape = this._shape;
            if (shape) {
                shape.transform.position.copyFrom(mappedPosition);
                shape.visible = this.isVisible(container, position, mappedPosition);
                return true;
            }
            return false;
        };
        DChartSelectionMarker.prototype.isVisible = function (container, position, mappedPosition) {
            var x = mappedPosition.x;
            var y = mappedPosition.y;
            var plotArea = container.plotArea;
            return 0 <= x && x <= plotArea.width && 0 <= y && y <= plotArea.height;
        };
        DChartSelectionMarker.prototype.getType = function () {
            return "DChartSelectionMarker";
        };
        return DChartSelectionMarker;
    }(DChartSelectionShapeBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionPoint = {
        PREVIOUS: 0,
        NEXT: 1,
        CLOSER: 2,
        INTERSECTION: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionSubImpl = /** @class */ (function (_super) {
        __extends(DChartSelectionSubImpl, _super);
        function DChartSelectionSubImpl(options) {
            var _this = this;
            var _a, _b, _c, _d, _e;
            _this = _super.call(this) || this;
            _this._container = null;
            _this._series = null;
            _this._isEnabled = (_a = options.enable) !== null && _a !== void 0 ? _a : true;
            _this._gridline = new DChartSelectionContainerImpl(new DChartSelectionGridlineX((_b = options.gridline) === null || _b === void 0 ? void 0 : _b.x), new DChartSelectionGridlineY((_c = options.gridline) === null || _c === void 0 ? void 0 : _c.y));
            _this._marker = new DChartSelectionMarker(options.marker);
            _this._state = (_d = options.state) !== null && _d !== void 0 ? _d : DBaseState.HOVERED;
            _this._coordinateX = null;
            _this._coordinateY = null;
            _this._position = new pixi_js.Point();
            _this._point = (_e = options.point) !== null && _e !== void 0 ? _e : DChartSelectionPoint.CLOSER;
            _this._work = new pixi_js.Point();
            // Events
            var on = options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DChartSelectionSubImpl.prototype.bind = function (container) {
            if (this._isEnabled) {
                this._container = container;
                this._gridline.bind(container);
                this._marker.bind(container);
            }
        };
        DChartSelectionSubImpl.prototype.unbind = function () {
            this._marker.unbind();
            this._gridline.unbind();
            this._container = null;
            this._coordinateX = null;
            this._coordinateY = null;
        };
        Object.defineProperty(DChartSelectionSubImpl.prototype, "series", {
            get: function () {
                return this._series;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "position", {
            get: function () {
                return this._position;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "gridline", {
            get: function () {
                return this._gridline;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSubImpl.prototype, "marker", {
            get: function () {
                return this._marker;
            },
            enumerable: false,
            configurable: true
        });
        DChartSelectionSubImpl.prototype.set = function (series, result) {
            var container = this._container;
            var coordinateX = (this._coordinateX = series.coordinate.x);
            var coordinateY = (this._coordinateY = series.coordinate.y);
            if (container && coordinateX && coordinateY) {
                var transform = container.plotArea.container.localTransform;
                var position = this._position;
                var work = this._work;
                if (result instanceof DChartSeriesHitResult) {
                    var x = result.x;
                    var y = result.y;
                    switch (this._point) {
                        case DChartSelectionPoint.PREVIOUS:
                            x = result.p0x;
                            y = result.p0y;
                            break;
                        case DChartSelectionPoint.NEXT:
                            x = result.p1x;
                            y = result.p1y;
                            break;
                        case DChartSelectionPoint.CLOSER:
                            if (Math.abs(result.p0x - result.x) < Math.abs(result.p1x - result.x)) {
                                x = result.p0x;
                                y = result.p0y;
                            }
                            else {
                                x = result.p1x;
                                y = result.p1y;
                            }
                    }
                    work.set(x, y);
                    transform.apply(work, work);
                    position.set(coordinateX.unmap(coordinateX.transform.unmap(x)), coordinateY.unmap(coordinateY.transform.unmap(y)));
                }
                else {
                    position.copyFrom(result.position);
                    work.set(coordinateX.transform.map(coordinateX.map(position.x)), coordinateY.transform.map(coordinateY.map(position.y)));
                    transform.apply(work, work);
                }
                this._gridline.set(container, position, work, series);
                this._marker.set(container, position, work, series);
                DApplications.update(container.plotArea);
            }
            var oldSeries = this._series;
            if (oldSeries !== series) {
                var state = this._state;
                if (oldSeries) {
                    oldSeries.state.remove(state);
                }
                this._series = series;
                series.state.add(state);
            }
            this.emit("change", this);
        };
        DChartSelectionSubImpl.prototype.unset = function () {
            var series = this._series;
            if (series) {
                this._series = null;
                this._coordinateX = null;
                this._coordinateY = null;
                series.state.remove(this._state);
                this._gridline.unset();
                this._marker.unset();
                this.emit("change", this);
            }
        };
        DChartSelectionSubImpl.prototype.update = function () {
            var container = this._container;
            var coordinateX = this._coordinateX;
            var coordinateY = this._coordinateY;
            if (container && coordinateX && coordinateY) {
                var position = this._position;
                var work = this._work;
                work.set(coordinateX.transform.map(coordinateX.map(position.x)), coordinateY.transform.map(coordinateY.map(position.y)));
                container.plotArea.container.localTransform.apply(work, work);
                var isGridlineUpdated = this._gridline.update(container, position, work);
                var isMarkerUpdated = this._marker.update(container, position, work);
                return isGridlineUpdated || isMarkerUpdated;
            }
            return false;
        };
        return DChartSelectionSubImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSelectionSimple = /** @class */ (function (_super) {
        __extends(DChartSelectionSimple, _super);
        function DChartSelectionSimple(options) {
            var _this = this;
            var _a;
            _this = _super.call(this) || this;
            _this._container = null;
            var point = toEnum((_a = options === null || options === void 0 ? void 0 : options.point) !== null && _a !== void 0 ? _a : DChartSelectionPoint.CLOSER, DChartSelectionPoint);
            _this._selected = _this.newSelected(point, options === null || options === void 0 ? void 0 : options.selected);
            _this._hovered = _this.newHovered(point, options === null || options === void 0 ? void 0 : options.hovered);
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            //
            _this._onMoveBound = function (e) {
                _this.onMove(e);
            };
            _this._onClickBound = function (e) {
                _this.onClick(e);
            };
            return _this;
        }
        DChartSelectionSimple.prototype.newSelected = function (point, options) {
            return new DChartSelectionSubImpl(this.toSelectedOptions(point, options));
        };
        DChartSelectionSimple.prototype.newHovered = function (point, options) {
            return new DChartSelectionSubImpl(this.toHoveredOptions(point, options));
        };
        DChartSelectionSimple.prototype.toSelectedOptions = function (point, options) {
            return this.toSubOptions(point, options, DBaseState.ACTIVE);
        };
        DChartSelectionSimple.prototype.toHoveredOptions = function (point, options) {
            return this.toSubOptions(point, options, DBaseState.HOVERED);
        };
        DChartSelectionSimple.prototype.toSubOptions = function (point, options, state) {
            var _a, _b, _c, _d, _e, _f, _g;
            options = options || {};
            if (options.point == null) {
                options.point = point;
            }
            if (options.state == null) {
                options.state = state;
            }
            var gridline = ((_a = options.gridline) !== null && _a !== void 0 ? _a : (options.gridline = {}));
            var gridlineX = ((_b = gridline.x) !== null && _b !== void 0 ? _b : (gridline.x = {}));
            if (gridlineX.state == null) {
                gridlineX.state = state;
            }
            var gridlineY = ((_c = gridline.y) !== null && _c !== void 0 ? _c : (gridline.y = {}));
            if (gridlineY.state == null) {
                gridlineY.state = state;
            }
            var marker = ((_d = options.marker) !== null && _d !== void 0 ? _d : (options.marker = {}));
            if (marker.state == null) {
                marker.state = state;
            }
            var label = ((_e = options.label) !== null && _e !== void 0 ? _e : (options.label = {}));
            var labelX = ((_f = label.x) !== null && _f !== void 0 ? _f : (label.x = {}));
            if (labelX.state == null) {
                labelX.state = state;
            }
            var labelY = ((_g = label.y) !== null && _g !== void 0 ? _g : (label.y = {}));
            if (labelY.state == null) {
                labelY.state = state;
            }
            return options;
        };
        DChartSelectionSimple.prototype.onClick = function (e) {
            var container = this._container;
            if (container && e.target === container.plotArea) {
                var result = DChartSelectionSimple.WORK_SELECT;
                var global_1 = e.data.global;
                var series = container.calcHitPoint(global_1.x, global_1.y, result);
                var selected = this._selected;
                if (series) {
                    selected.set(series, result);
                }
                else {
                    selected.unset();
                }
            }
        };
        DChartSelectionSimple.prototype.onMove = function (e) {
            var container = this._container;
            if (container) {
                var hovered = this._hovered;
                if (e.target === container.plotArea) {
                    var result = DChartSelectionSimple.WORK_SELECT;
                    var global_2 = e.data.global;
                    var series = container.calcHitPoint(global_2.x, global_2.y, result);
                    if (series) {
                        hovered.set(series, result);
                    }
                    else {
                        hovered.unset();
                    }
                }
                else {
                    hovered.unset();
                }
            }
        };
        DChartSelectionSimple.prototype.bind = function (container) {
            this._container = container;
            this._selected.bind(container);
            this._hovered.bind(container);
            var plotArea = container.plotArea;
            plotArea.on(UtilPointerEvent.move, this._onMoveBound);
            plotArea.on(UtilPointerEvent.tap, this._onClickBound);
        };
        DChartSelectionSimple.prototype.unbind = function () {
            var container = this._container;
            this._container = null;
            if (container) {
                var plotArea = container.plotArea;
                plotArea.off(UtilPointerEvent.move, this._onMoveBound);
            }
            this._selected.unbind();
            this._hovered.unbind();
        };
        Object.defineProperty(DChartSelectionSimple.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSelectionSimple.prototype, "hovered", {
            get: function () {
                return this._hovered;
            },
            enumerable: false,
            configurable: true
        });
        DChartSelectionSimple.prototype.update = function () {
            var isSelectedUpdated = this._selected.update();
            var isHoveredUpdated = this._hovered.update();
            if (isSelectedUpdated || isHoveredUpdated) {
                var container = this._container;
                if (container != null) {
                    DApplications.update(container.plotArea);
                }
            }
        };
        DChartSelectionSimple.prototype.onRender = function () {
            this._selected.update();
            this._hovered.update();
        };
        DChartSelectionSimple.WORK_SELECT = new DChartSeriesHitResult();
        return DChartSelectionSimple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesBaseCoordinateContainer = /** @class */ (function () {
        function DChartSeriesBaseCoordinateContainer(parent, options) {
            var _a, _b;
            this._parent = parent;
            this._coordinateIndexX = (_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0;
            this._coordinateIndexY = (_b = options === null || options === void 0 ? void 0 : options.y) !== null && _b !== void 0 ? _b : 0;
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
            this._coordinateTransformIdUpdatedX = NaN;
            this._coordinateTransformIdUpdatedY = NaN;
        }
        Object.defineProperty(DChartSeriesBaseCoordinateContainer.prototype, "x", {
            get: function () {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.x.get(this._coordinateIndexX);
                }
                return null;
            },
            set: function (coordinate) {
                var index = this.toIndexX(coordinate);
                if (this._coordinateIndexX !== index) {
                    this._coordinateIndexX = index;
                    this._coordinateIdUpdatedX = NaN;
                    this._coordinateTransformIdUpdatedX = NaN;
                }
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesBaseCoordinateContainer.prototype.toIndexX = function (target) {
            if (isNumber(target)) {
                return target;
            }
            else if (target != null) {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.x.indexOf(target);
                }
            }
            return -1;
        };
        Object.defineProperty(DChartSeriesBaseCoordinateContainer.prototype, "y", {
            get: function () {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.y.get(this._coordinateIndexY);
                }
                return null;
            },
            set: function (coordinate) {
                var index = this.toIndexY(coordinate);
                if (this._coordinateIndexY !== index) {
                    this._coordinateIndexY = index;
                    this._coordinateIdUpdatedY = NaN;
                    this._coordinateTransformIdUpdatedY = NaN;
                }
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesBaseCoordinateContainer.prototype.toIndexY = function (target) {
            if (isNumber(target)) {
                return target;
            }
            else if (target != null) {
                var container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.y.indexOf(target);
                }
            }
            return -1;
        };
        DChartSeriesBaseCoordinateContainer.prototype.isDirty = function (coordinateX, coordinateY) {
            var coordinateIdX = coordinateX.id;
            var coordinateIdY = coordinateY.id;
            var isCoordinateXChanged = coordinateIdX !== this._coordinateIdUpdatedX;
            var isCoordinateYChanged = coordinateIdY !== this._coordinateIdUpdatedY;
            this._coordinateIdUpdatedX = coordinateIdX;
            this._coordinateIdUpdatedY = coordinateIdY;
            return isCoordinateXChanged || isCoordinateYChanged;
        };
        DChartSeriesBaseCoordinateContainer.prototype.isTransformDirty = function (coordinateX, coordinateY) {
            var coordinateTransformIdX = coordinateX.transform.id;
            var coordinateTransformIdY = coordinateY.transform.id;
            var isCoordinateTransformXChanged = coordinateTransformIdX !== this._coordinateTransformIdUpdatedX;
            var isCoordinateTransformYChanged = coordinateTransformIdY !== this._coordinateTransformIdUpdatedY;
            this._coordinateTransformIdUpdatedX = coordinateTransformIdX;
            this._coordinateTransformIdUpdatedY = coordinateTransformIdY;
            return isCoordinateTransformXChanged || isCoordinateTransformYChanged;
        };
        DChartSeriesBaseCoordinateContainer.prototype.reset = function () {
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
        };
        DChartSeriesBaseCoordinateContainer.prototype.destroy = function () {
            this.reset();
        };
        return DChartSeriesBaseCoordinateContainer;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     */
    var DChartSeriesBase = /** @class */ (function (_super) {
        __extends(DChartSeriesBase, _super);
        function DChartSeriesBase(options) {
            var _this = _super.call(this) || this;
            _this._coordinate = new DChartSeriesBaseCoordinateContainer(_this, options === null || options === void 0 ? void 0 : options.coordinate);
            _this._index = 0;
            _this._domain = new DChartRegionImpl(NaN, NaN);
            _this._range = new DChartRegionImpl(NaN, NaN);
            _this._regionPointId = NaN;
            _this._isShown = true;
            _this._state = new DBaseStateSetImplObservable(function (newState, oldState) {
                _this.onStateChange(newState, oldState);
            });
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DChartSeriesBase.prototype.bind = function (container, index) {
            this._container = container;
            this._coordinate.reset();
            this._index = index;
            var chart = container.plotArea.chart;
            if (chart) {
                this._state.parent = chart.state;
            }
            return this;
        };
        DChartSeriesBase.prototype.unbind = function () {
            this._container = undefined;
            return this;
        };
        Object.defineProperty(DChartSeriesBase.prototype, "domain", {
            get: function () {
                this.updateRegion();
                return this._domain;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "range", {
            get: function () {
                this.updateRegion();
                return this._range;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "container", {
            get: function () {
                return this._container || null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesBase.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesBase.prototype.show = function () {
            if (this._isShown !== true) {
                this._isShown = true;
                this.onShow();
            }
            return this;
        };
        DChartSeriesBase.prototype.onShow = function () {
            var shape = this.shape;
            if (shape != null) {
                shape.visible = true;
            }
        };
        DChartSeriesBase.prototype.isShown = function () {
            return this._isShown;
        };
        DChartSeriesBase.prototype.hide = function () {
            if (this._isShown !== false) {
                this._isShown = false;
                this.onHide();
            }
            return this;
        };
        DChartSeriesBase.prototype.onHide = function () {
            var shape = this.shape;
            if (shape != null) {
                shape.visible = false;
            }
        };
        DChartSeriesBase.prototype.isHidden = function () {
            return !this._isShown;
        };
        DChartSeriesBase.prototype.destroy = function () {
            this._container = undefined;
            this._coordinate.destroy();
            return this;
        };
        DChartSeriesBase.prototype.hitTest = function (x, y) {
            return false;
        };
        DChartSeriesBase.prototype.calcHitPoint = function (x, y, result) {
            return false;
        };
        DChartSeriesBase.prototype.onStateChange = function (newState, oldState) {
            var _a;
            this.toDirty();
            var chart = (_a = this._container) === null || _a === void 0 ? void 0 : _a.plotArea.chart;
            DApplications.update(chart);
            this.emit("statechange", newState, oldState, this);
        };
        return DChartSeriesBase;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of anything.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfAny = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfAny, _super);
        function DChartSeriesLineOfAny(options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._points = (_a = options === null || options === void 0 ? void 0 : options.points) !== null && _a !== void 0 ? _a : [];
            _this._pointId = 0;
            _this._pointIdUpdated = NaN;
            return _this;
        }
        DChartSeriesLineOfAny.prototype.getSizeDefault = function () {
            return 10;
        };
        DChartSeriesLineOfAny.prototype.getOffsetDefault = function () {
            return 0;
        };
        DChartSeriesLineOfAny.prototype.bind = function (container, index) {
            var line = this._line;
            if (!line) {
                line = this._line = this.newLineOfAny();
                line.visible = this._isShown;
                var options = this._options;
                this.initLine(line, options, container, index);
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
            return this;
        };
        DChartSeriesLineOfAny.prototype.initLine = function (line, options, container, index) {
            var fill = container.newFill(index, options === null || options === void 0 ? void 0 : options.fill);
            this._fill = fill;
            line.fill.copy(fill);
            var stroke = container.newStroke(index, options === null || options === void 0 ? void 0 : options.stroke);
            this._stroke = stroke;
            line.stroke.copy(stroke);
            var sizeDefault = this.getSizeDefault();
            var size = container.newSize(index, options === null || options === void 0 ? void 0 : options.size, sizeDefault, sizeDefault);
            this._size = size;
            line.points.size.set(size.x, size.y);
            var offsetDefault = this.getOffsetDefault();
            var offset = container.newOffset(index, options && options.offset, offsetDefault, offsetDefault);
            this._offset = offset;
            line.points.offset.set(offset.x, offset.y);
        };
        DChartSeriesLineOfAny.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
            return this;
        };
        Object.defineProperty(DChartSeriesLineOfAny.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLineOfAny.prototype, "points", {
            get: function () {
                return this._points;
            },
            set: function (points) {
                this._points = points;
                this._pointId += 1;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesLineOfAny.prototype.toDirty = function () {
            this._pointId += 1;
            return this;
        };
        DChartSeriesLineOfAny.prototype.update = function () {
            this.doUpdate(true);
            return this;
        };
        DChartSeriesLineOfAny.prototype.onRender = function () {
            this.doUpdate(false);
            return this;
        };
        DChartSeriesLineOfAny.prototype.doUpdate = function (render) {
            var line = this._line;
            if (line) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var pointId = this._pointId;
                    var isPointChanged = pointId !== this._pointIdUpdated;
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.doUpdateLine(line, coordinateX, coordinateY);
                        if (render) {
                            DApplications.update(line);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.doUpdateLine = function (line, xcoordinate, ycoordinate) {
            var values = line.points.values;
            var valuesLength = values.length;
            var ivalues = 0;
            var points = this._points;
            var xmin = NaN;
            var xmax = NaN;
            var ymin = NaN;
            var ymax = NaN;
            for (var i = 0, imax = points.length; i < imax; i += 2) {
                var x = points[i];
                var y = points[i + 1];
                if (x != null && y != null) {
                    if (ivalues < valuesLength) {
                        values[ivalues] = x;
                        values[ivalues + 1] = y;
                    }
                    else {
                        values.push(x, y);
                    }
                    ivalues += 2;
                    if (xmin !== xmin) {
                        xmin = x;
                        xmax = x;
                        ymin = y;
                        ymax = y;
                    }
                    else {
                        xmin = Math.min(xmin, x);
                        xmax = Math.max(xmax, x);
                        ymin = Math.min(ymin, y);
                        ymax = Math.max(ymax, y);
                    }
                }
            }
            if (values.length !== ivalues) {
                values.length = ivalues;
            }
            xcoordinate.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.mapAll(values, 0, ivalues, 2, 1);
            xcoordinate.transform.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.transform.mapAll(values, 0, ivalues, 2, 1);
            if (xmin !== xmin) {
                xmin = 0;
                xmax = 0;
                ymin = 0;
                ymax = 0;
            }
            var region = DChartSeriesLineOfAny.WORK_REGION || {
                xmin: 0,
                xmax: 0,
                ymin: 0,
                ymax: 0
            };
            DChartSeriesLineOfAny.WORK_REGION = region;
            this.adjustLineRegion(xmin, xmax, ymin, ymax, region);
            xmin = xcoordinate.transform.map(xcoordinate.map(region.xmin));
            xmax = xcoordinate.transform.map(xcoordinate.map(region.xmax));
            ymin = ycoordinate.transform.map(ycoordinate.map(region.ymin));
            ymax = ycoordinate.transform.map(ycoordinate.map(region.ymax));
            var sx = Math.abs(xmax - xmin);
            var sy = Math.abs(ymax - ymin);
            var cx = (xmin + xmax) * 0.5;
            var cy = (ymin + ymax) * 0.5;
            for (var i = 0, imax = values.length; i < imax; i += 2) {
                values[i + 0] -= cx;
                values[i + 1] -= cy;
            }
            line.disallowUploadedUpdate();
            this.applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
            line.allowUploadedUpdate();
        };
        DChartSeriesLineOfAny.prototype.adjustLineRegion = function (xmin, xmax, ymin, ymax, result) {
            result.xmin = xmin;
            result.xmax = xmax;
            result.ymin = ymin;
            result.ymax = ymax;
            return result;
        };
        DChartSeriesLineOfAny.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            line.points.set(values);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
        };
        DChartSeriesLineOfAny.prototype.updateRegion = function () {
            var pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                var points = this._points;
                var domain = this._domain;
                var range = this._range;
                domain.clear();
                range.clear();
                this.calcRegion(points, domain, range);
            }
        };
        DChartSeriesLineOfAny.prototype.calcRegion = function (points, domain, range) {
            for (var i = 0, imax = points.length; i < imax; i += 2) {
                var xraw = points[i];
                if (xraw != null) {
                    domain.add(xraw, xraw);
                }
                var yraw = points[i + 1];
                if (yraw != null) {
                    range.add(yraw, yraw);
                }
            }
        };
        DChartSeriesLineOfAny.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            _super.prototype.destroy.call(this);
            return this;
        };
        DChartSeriesLineOfAny.prototype.hitTest = function (x, y) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLineOfAny.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                return line.contains(local.x, local.y) != null;
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.calcHitPoint = function (x, y, result) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLineOfAny.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                result.shape = line;
                return line.calcHitPoint(local.x, local.y, null, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLineOfAny.prototype.calcHitPointTestRange = function (x, y, ax, ay, ox, oy, threshold, values, result) {
            var to = toCeilingIndex(values, x + ax + ox, 2, 0);
            var from = 0;
            for (var i = to - 1, iv = i << 1; 0 <= i; i -= 1, iv -= 2) {
                if (values[iv] <= x - ax) {
                    from = i;
                    break;
                }
            }
            result[0] = from;
            result[1] = from !== to ? to : Math.min(values.length << 1, to + 1);
            return result;
        };
        DChartSeriesLineOfAny.prototype.calcHitPointHitTester = function (x, y, ax, ay, ox, oy, px, py, sw, ss, sa, index, threshold, result) {
            var shape = result.shape;
            if (shape.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa)) {
                var transform = shape.transform;
                var position = transform.position;
                var scale = transform.scale;
                result.x = result.p0x = result.p1x = position.x + scale.x * px;
                result.y = result.p0y = result.p1y = position.y + scale.y * py;
                result.t = threshold;
                result.index = index;
                var dx = x - (px + ox);
                var dy = y - (py + oy);
                result.distance = Math.sqrt(dx * dx + dy * dy);
                return true;
            }
            return false;
        };
        DChartSeriesLineOfAny.WORK = new pixi_js.Point();
        return DChartSeriesLineOfAny;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents bars.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesBar = /** @class */ (function (_super) {
        __extends(DChartSeriesBar, _super);
        function DChartSeriesBar(options) {
            var _this = _super.call(this, options) || this;
            _this._barCount = -1;
            _this._barIndex = -1;
            _this._xcoordinateId = -1;
            _this._xcoordinateTransformId = -1;
            _this._isSizeAutomatic = (options && options.size && options.size.auto) !== false;
            return _this;
        }
        DChartSeriesBar.prototype.bind = function (container, index) {
            this._barCount = -1;
            this._barIndex = -1;
            this._xcoordinateId = -1;
            this._xcoordinateTransformId = -1;
            _super.prototype.bind.call(this, container, index);
            return this;
        };
        DChartSeriesBar.prototype.initLine = function (line, options, container, index) {
            _super.prototype.initLine.call(this, line, options, container, index);
            this._padding = container.newPadding(index, options && options.padding);
        };
        DChartSeriesBar.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangles();
        };
        DChartSeriesBar.prototype.getSizeDefault = function () {
            return 1;
        };
        DChartSeriesBar.prototype.adjustLineRegion = function (xmin, xmax, ymin, ymax, result) {
            return _super.prototype.adjustLineRegion.call(this, xmin, xmax, Math.min(0, ymin), Math.max(0, ymax), result);
        };
        DChartSeriesBar.prototype.updateBarCountAndIndex = function () {
            if (this._barIndex < 0 || this._barCount < 0) {
                var barIndex = 0;
                var barCount = 0;
                var container = this._container;
                if (container) {
                    for (var i = 0, imax = container.size(); i < imax; ++i) {
                        var series = container.get(i);
                        if (series === this) {
                            barIndex = barCount;
                        }
                        if (series instanceof DChartSeriesBar) {
                            barCount += 1;
                        }
                    }
                }
                barCount = Math.max(1, barCount);
                this._barCount = barCount;
                this._barIndex = barIndex;
                return true;
            }
            return false;
        };
        DChartSeriesBar.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            var linePoints = line.points;
            var linePointsOffset = linePoints.offset;
            var linePointsSize = linePoints.size;
            // Offset
            var size = this._size;
            var offset = this._offset;
            var padding = this._padding;
            if (size && offset && padding) {
                var xcoordinateId = xcoordinate.id;
                var xcoordinateTransformId = xcoordinate.transform.id;
                if (this.updateBarCountAndIndex() ||
                    this._xcoordinateId !== xcoordinateId ||
                    this._xcoordinateTransformId !== xcoordinateTransformId) {
                    var barCount = this._barCount;
                    var barIndex = this._barIndex;
                    this._xcoordinateId = xcoordinateId;
                    this._xcoordinateTransformId = xcoordinateTransformId;
                    var x0 = xcoordinate.transform.map(xcoordinate.map(0));
                    var x1 = xcoordinate.transform.map(xcoordinate.map(size.x));
                    var totalBandWidth = Math.abs(x0 - x1) * (1 - padding.outer);
                    if (barCount <= 1) {
                        linePointsOffset.x = offset.x;
                        linePointsSize.x = totalBandWidth;
                    }
                    else {
                        var totalBarWidth = totalBandWidth * (1 - padding.inner);
                        var totalPaddingInner = totalBandWidth - totalBarWidth;
                        var barWidth = totalBarWidth / barCount;
                        var barPadding = totalPaddingInner / (barCount - 1);
                        var barX = barWidth * (barIndex + 0.5) + barIndex * barPadding;
                        linePointsOffset.x = offset.x + barX - totalBandWidth * 0.5;
                        linePointsSize.x = barWidth;
                    }
                }
            }
            // Sizes & Offsets
            var sizes = linePointsSize.y;
            if (!isArray(sizes)) {
                sizes = [];
            }
            var sizesLength = sizes.length;
            var offsets = linePointsOffset.y;
            if (!isArray(offsets)) {
                offsets = [];
            }
            var offsetsLength = offsets.length;
            var isize = 0;
            var y0 = ycoordinate.transform.map(ycoordinate.map(0)) - cy;
            for (var i = 0, imax = values.length; i < imax; i += 2, isize += 1) {
                var distance = values[i + 1] - y0;
                var s = Math.abs(distance);
                if (isize < sizesLength) {
                    sizes[isize] = s;
                }
                else {
                    sizes.push(s);
                }
                var o = -0.5 * distance;
                if (isize < offsetsLength) {
                    offsets[isize] = o;
                }
                else {
                    offsets.push(o);
                }
            }
            if (sizes.length !== isize) {
                sizes.length = isize;
            }
            if (offsets.length !== isize) {
                offsets.length = isize;
            }
            linePointsOffset.y = offsets;
            linePointsSize.y = sizes;
            // Others
            _super.prototype.applyLine.call(this, line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        };
        DChartSeriesBar.prototype.calcSizeX = function (def) {
            var points = this._points;
            if (2 < points.length) {
                var pointsLength = points.length;
                var x0 = points[pointsLength - 2];
                for (var i = pointsLength - 4; 0 <= i; i -= 2) {
                    var x1 = points[i];
                    if (x0 != null && x1 != null) {
                        return Math.abs(x0 - x1);
                    }
                    else {
                        x0 = x1;
                    }
                }
            }
            return def;
        };
        DChartSeriesBar.prototype.calcRegion = function (points, domain, range) {
            _super.prototype.calcRegion.call(this, points, domain, range);
            var size = this._size;
            if (size) {
                var sx = size.x;
                if (this._isSizeAutomatic) {
                    sx = this.calcSizeX(sx);
                    size.x = sx;
                }
                var sxh = sx * 0.5;
                domain.set(domain.from - sxh, domain.to + sxh);
            }
            range.add(0, 0);
        };
        return DChartSeriesBar;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of circles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfCircles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfCircles, _super);
        function DChartSeriesLineOfCircles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfCircles.prototype.newLineOfAny = function () {
            return new EShapeLineOfCircles();
        };
        return DChartSeriesLineOfCircles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfRectangleRoundeds = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfRectangleRoundeds, _super);
        function DChartSeriesLineOfRectangleRoundeds() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfRectangleRoundeds.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangleRoundeds();
        };
        return DChartSeriesLineOfRectangleRoundeds;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfRectangles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfRectangles, _super);
        function DChartSeriesLineOfRectangles() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfRectangles.prototype.newLineOfAny = function () {
            return new EShapeLineOfRectangles();
        };
        return DChartSeriesLineOfRectangles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfTriangles = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfTriangles, _super);
        function DChartSeriesLineOfTriangles(options) {
            var _this = _super.call(this, options) || this;
            _this._sizeId = 0;
            return _this;
        }
        DChartSeriesLineOfTriangles.prototype.newLineOfAny = function () {
            return new EShapeLineOfTriangles();
        };
        DChartSeriesLineOfTriangles.prototype.applyLine = function (line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            // Offset
            var size = this._size;
            var offset = this._offset;
            if (size && offset && this._sizeId !== size.y) {
                this._sizeId = size.y;
                line.points.offset.y = offset.y - size.y * 0.2;
            }
            //
            _super.prototype.applyLine.call(this, line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        };
        return DChartSeriesLineOfTriangles;
    }(DChartSeriesLineOfAny));

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLineOfTriangleRoundeds = /** @class */ (function (_super) {
        __extends(DChartSeriesLineOfTriangleRoundeds, _super);
        function DChartSeriesLineOfTriangleRoundeds() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChartSeriesLineOfTriangleRoundeds.prototype.newLineOfAny = function () {
            return new EShapeLineOfTriangleRoundeds();
        };
        return DChartSeriesLineOfTriangleRoundeds;
    }(DChartSeriesLineOfTriangles));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     * Data points must be sorted in ascending order on the X axis.
     */
    var DChartSeriesLine = /** @class */ (function (_super) {
        __extends(DChartSeriesLine, _super);
        function DChartSeriesLine(options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._points = (_a = options === null || options === void 0 ? void 0 : options.points) !== null && _a !== void 0 ? _a : [];
            _this._pointId = 0;
            _this._pointIdUpdated = NaN;
            _this._centerX = 0;
            _this._centerY = 0;
            return _this;
        }
        DChartSeriesLine.prototype.bind = function (container, index) {
            var _a;
            var line = this._line;
            if (!line) {
                var stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                this._stroke = stroke;
                line = new EShapeLine();
                line.stroke.copy(stroke);
                line.visible = this._isShown;
                this._line = line;
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            _super.prototype.bind.call(this, container, index);
            return this;
        };
        DChartSeriesLine.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
            return this;
        };
        Object.defineProperty(DChartSeriesLine.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLine.prototype, "points", {
            get: function () {
                return this._points;
            },
            set: function (points) {
                this._points = points;
                this._pointId += 1;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesLine.prototype.toDirty = function () {
            this._pointId += 1;
            return this;
        };
        DChartSeriesLine.prototype.update = function () {
            this.doUpdate(true);
            return this;
        };
        DChartSeriesLine.prototype.onRender = function () {
            this.doUpdate(false);
            return this;
        };
        DChartSeriesLine.prototype.doUpdate = function (render) {
            var line = this._line;
            if (line) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    var pointId = this._pointId;
                    var isPointChanged = pointId !== this._pointIdUpdated;
                    var isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    var isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.doUpdateLine(line, coordinateX, coordinateY, isPointChanged || isCoordinateChanged);
                        if (render) {
                            DApplications.update(line);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLine.prototype.doUpdateLine = function (line, xcoordinate, ycoordinate, isPointsDirty) {
            line.disallowUploadedUpdate();
            if (isPointsDirty) {
                var values = line.points.values;
                var segments = line.points.segments;
                var valuesLength = values.length;
                var segmentsLength = segments.length;
                var ivalues = 0;
                var isegments = 0;
                var points = this._points;
                var xmin = NaN;
                var xmax = NaN;
                var ymin = NaN;
                var ymax = NaN;
                for (var i = 0, imax = points.length; i < imax; i += 2) {
                    var x = points[i];
                    var y = points[i + 1];
                    if (x != null && y != null) {
                        if (ivalues < valuesLength) {
                            values[ivalues] = x;
                            values[ivalues + 1] = y;
                        }
                        else {
                            values.push(x, y);
                        }
                        ivalues += 2;
                        if (xmin !== xmin) {
                            xmin = x;
                            xmax = x;
                            ymin = y;
                            ymax = y;
                        }
                        else {
                            xmin = Math.min(xmin, x);
                            xmax = Math.max(xmax, x);
                            ymin = Math.min(ymin, y);
                            ymax = Math.max(ymax, y);
                        }
                    }
                    else {
                        var segment = (i >> 1) - isegments;
                        if (isegments < segmentsLength) {
                            segments[isegments] = segment;
                        }
                        else {
                            segments.push(segment);
                        }
                        isegments += 1;
                    }
                }
                if (values.length !== ivalues) {
                    values.length = ivalues;
                }
                if (segments.length !== isegments) {
                    segments.length = isegments;
                }
                xcoordinate.mapAll(values, 0, ivalues, 2, 0);
                ycoordinate.mapAll(values, 0, ivalues, 2, 1);
                if (xmin !== xmin) {
                    xmin = 0;
                    xmax = 0;
                    ymin = 0;
                    ymax = 0;
                }
                xmin = xcoordinate.map(xmin);
                xmax = xcoordinate.map(xmax);
                ymin = ycoordinate.map(ymin);
                ymax = ycoordinate.map(ymax);
                var sx = Math.abs(xmax - xmin);
                var sy = Math.abs(ymax - ymin);
                var cx = (xmin + xmax) * 0.5;
                var cy = (ymin + ymax) * 0.5;
                for (var i = 0, imax = values.length; i < imax; i += 2) {
                    values[i + 0] -= cx;
                    values[i + 1] -= cy;
                }
                line.size.set(sx, sy);
                line.points.set(values, segments);
                this._centerX = cx;
                this._centerY = cy;
            }
            line.transform.position.set(xcoordinate.transform.map(this._centerX), ycoordinate.transform.map(this._centerY));
            line.transform.scale.set(xcoordinate.transform.scale, ycoordinate.transform.scale);
            line.allowUploadedUpdate();
        };
        DChartSeriesLine.prototype.updateRegion = function () {
            var pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                var points = this._points;
                var domain = this._domain;
                var range = this._range;
                domain.clear();
                range.clear();
                if (points != null) {
                    for (var i = 0, imax = points.length; i < imax; i += 2) {
                        var xraw = points[i];
                        if (xraw != null) {
                            domain.add(xraw, xraw);
                        }
                        var yraw = points[i + 1];
                        if (yraw != null) {
                            range.add(yraw, yraw);
                        }
                    }
                }
            }
        };
        DChartSeriesLine.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            _super.prototype.destroy.call(this);
            return this;
        };
        DChartSeriesLine.prototype.hitTest = function (x, y) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLine.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                return line.contains(local.x, local.y) != null;
            }
            return false;
        };
        DChartSeriesLine.prototype.calcHitPoint = function (x, y, result) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLine.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                result.shape = line;
                return line.calcHitPoint(local.x, local.y, this.toThreshold, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLine.prototype.toThreshold = function (strokeWidth, strokeScale) {
            return +Infinity;
        };
        DChartSeriesLine.prototype.calcHitPointTestRange = function (x, y, threshold, values, result) {
            var index = toCeilingIndex(values, x, 2, 0);
            result[0] = Math.max(0, index - 1);
            result[1] = index;
            return result;
        };
        DChartSeriesLine.prototype.calcHitPointHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                var l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    var t = (x - p0x) / l;
                    var p2x = x;
                    var p2y = p0y + t * (p1y - p0y);
                    var distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        var transform = result.shape.transform;
                        var position = transform.position;
                        var px = position.x;
                        var py = position.y;
                        var scale = transform.scale;
                        var sx = scale.x;
                        var sy = scale.y;
                        result.x = px + sx * p2x;
                        result.y = py + sy * p2y;
                        result.p0x = px + sx * p0x;
                        result.p0y = py + sy * p0y;
                        result.p1x = px + sx * p1x;
                        result.p1y = py + sy * p1y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLine.WORK = new pixi_js.Point();
        return DChartSeriesLine;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChartSeriesExpressionParametersImpl = /** @class */ (function () {
        function DChartSeriesExpressionParametersImpl(a, b, x0, y0) {
            this._id = 0;
            this._idUpdated = NaN;
            this._a = a;
            this._b = b;
            this._x0 = x0;
            this._y0 = y0;
        }
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "a", {
            get: function () {
                return this._a;
            },
            set: function (a) {
                if (this._a !== a) {
                    this._id += 1;
                    this._a = a;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "b", {
            get: function () {
                return this._b;
            },
            set: function (b) {
                if (this._b !== b) {
                    this._id += 1;
                    this._b = b;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "x0", {
            get: function () {
                return this._x0;
            },
            set: function (x0) {
                if (this._x0 !== x0) {
                    this._id += 1;
                    this._x0 = x0;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesExpressionParametersImpl.prototype, "y0", {
            get: function () {
                return this._y0;
            },
            set: function (y0) {
                if (this._y0 !== y0) {
                    this._id += 1;
                    this._y0 = y0;
                }
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesExpressionParametersImpl.prototype.toDirty = function () {
            this._id += 1;
        };
        DChartSeriesExpressionParametersImpl.prototype.isDirty = function () {
            return this._id !== this._idUpdated;
        };
        DChartSeriesExpressionParametersImpl.prototype.toClean = function () {
            this._idUpdated = this._id;
        };
        DChartSeriesExpressionParametersImpl.from = function (options) {
            var _c, _d, _e, _f;
            return new DChartSeriesExpressionParametersImpl((_c = options === null || options === void 0 ? void 0 : options.a) !== null && _c !== void 0 ? _c : 1, (_d = options === null || options === void 0 ? void 0 : options.b) !== null && _d !== void 0 ? _d : 1, (_e = options === null || options === void 0 ? void 0 : options.x0) !== null && _e !== void 0 ? _e : 0, (_f = options === null || options === void 0 ? void 0 : options.y0) !== null && _f !== void 0 ? _f : 0);
        };
        return DChartSeriesExpressionParametersImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a linear equation `a (x - x0) === b (y - y0)`.
     */
    var DChartSeriesLinear = /** @class */ (function (_super) {
        __extends(DChartSeriesLinear, _super);
        function DChartSeriesLinear(options) {
            var _this = _super.call(this, options) || this;
            _this._line = null;
            _this._options = options;
            _this._parameters = DChartSeriesExpressionParametersImpl.from(options);
            return _this;
        }
        DChartSeriesLinear.prototype.bind = function (container, index) {
            var _a;
            var line = this._line;
            if (!line) {
                var stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                this._stroke = stroke;
                line = new EShapeLine();
                line.stroke.copy(stroke);
                line.visible = this._isShown;
                this._line = line;
            }
            line.attach(container.plotArea.container, index);
            _super.prototype.bind.call(this, container, index);
            return this;
        };
        DChartSeriesLinear.prototype.unbind = function () {
            var line = this._line;
            if (line) {
                line.detach();
            }
            _super.prototype.unbind.call(this);
            return this;
        };
        Object.defineProperty(DChartSeriesLinear.prototype, "shape", {
            get: function () {
                return this._line;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DChartSeriesLinear.prototype, "parameters", {
            get: function () {
                return this._parameters;
            },
            enumerable: false,
            configurable: true
        });
        DChartSeriesLinear.prototype.toDirty = function () {
            this._parameters.toDirty();
            return this;
        };
        DChartSeriesLinear.prototype.update = function () {
            this.doUpdate(true);
            return this;
        };
        DChartSeriesLinear.prototype.onRender = function () {
            this.doUpdate(false);
            return this;
        };
        DChartSeriesLinear.prototype.doUpdate = function (render) {
            var line = this._line;
            var container = this._container;
            if (line && container) {
                var coordinate = this._coordinate;
                var coordinateX = coordinate.x;
                var coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    this.doUpdateLine(line, container, coordinateX, coordinateY);
                    if (render) {
                        DApplications.update(line);
                    }
                    return true;
                }
            }
            return false;
        };
        DChartSeriesLinear.prototype.doUpdateLine = function (line, container, xcoordinate, ycoordinate) {
            var values = line.points.values;
            var segments = line.points.segments;
            var parameters = this._parameters;
            var a = parameters.a;
            var b = parameters.b;
            var x0 = parameters.x0;
            var y0 = parameters.y0;
            var aabs = Math.abs(a);
            var babs = Math.abs(b);
            var p0x = NaN;
            var p0y = NaN;
            var p1x = NaN;
            var p1y = NaN;
            var threshold = 0.00001;
            var bounds = container.plotArea.getBoundsInContainer();
            if (babs <= aabs) {
                var xfrom = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x));
                var xto = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x + bounds.width));
                p0x = Math.min(xfrom, xto);
                p1x = Math.max(xfrom, xto);
                var yfrom = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y));
                var yto = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y + bounds.height));
                p0y = Math.min(yfrom, yto);
                p1y = Math.max(yfrom, yto);
                if (threshold < babs) {
                    var f = b / a;
                    var xfrom1 = f * (yfrom - y0) + x0;
                    var xto1 = f * (yto - y0) + x0;
                    var p2x = Math.min(xfrom1, xto1);
                    var p3x = Math.max(xfrom1, xto1);
                    p0x = Math.max(p0x, p2x);
                    p1x = Math.min(p1x, p3x);
                    var g = 1 / f;
                    p0y = g * (p0x - x0) + b * y0;
                    p1y = g * (p1x - x0) + b * y0;
                }
                else {
                    p0x = x0;
                    p1x = x0;
                }
            }
            else {
                var yfrom = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y));
                var yto = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y + bounds.height));
                p0y = Math.min(yfrom, yto);
                p1y = Math.max(yfrom, yto);
                var xfrom = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x));
                var xto = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x + bounds.width));
                p0x = Math.min(xfrom, xto);
                p1x = Math.max(xfrom, xto);
                if (threshold < aabs) {
                    var f = a / b;
                    var yfrom1 = f * (xfrom - x0) + y0;
                    var yto1 = f * (xto - x0) + y0;
                    var p2y = Math.min(yfrom1, yto1);
                    var p3y = Math.max(yfrom1, yto1);
                    p0y = Math.max(p0y, p2y);
                    p1y = Math.min(p1y, p3y);
                    var g = 1 / f;
                    p0x = g * (p0y - y0) + a * x0;
                    p1x = g * (p1y - y0) + a * x0;
                }
                else {
                    p0y = y0;
                    p1y = y0;
                }
            }
            p0x = xcoordinate.transform.map(xcoordinate.map(p0x));
            p0y = ycoordinate.transform.map(ycoordinate.map(p0y));
            p1x = xcoordinate.transform.map(xcoordinate.map(p1x));
            p1y = ycoordinate.transform.map(ycoordinate.map(p1y));
            var cx = (p0x + p1x) * 0.5;
            var cy = (p0y + p1y) * 0.5;
            var sx = Math.abs(p1x - p0x);
            var sy = Math.abs(p1y - p0y);
            p0x -= cx;
            p0y -= cy;
            p1x -= cx;
            p1y -= cy;
            if (values.length !== 4) {
                values.length = 0;
                values.push(p0x, p0y, p1x, p1y);
            }
            else {
                values[0] = p0x;
                values[1] = p0y;
                values[2] = p1x;
                values[3] = p1y;
            }
            if (0 < segments.length) {
                segments.length = 0;
            }
            line.disallowUploadedUpdate();
            line.points.set(values, segments);
            line.points.toFitted(sx, sy);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
            line.allowUploadedUpdate();
        };
        DChartSeriesLinear.prototype.updateRegion = function () {
            // DO NOTHING
        };
        DChartSeriesLinear.prototype.destroy = function () {
            var line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            _super.prototype.destroy.call(this);
            return this;
        };
        DChartSeriesLinear.prototype.hitTest = function (x, y) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLinear.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                return line.contains(local.x, local.y) != null;
            }
            return false;
        };
        DChartSeriesLinear.prototype.calcHitPoint = function (x, y, result) {
            var line = this._line;
            if (line) {
                var local = DChartSeriesLinear.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                result.shape = line;
                return line.calcHitPoint(local.x, local.y, this.toThreshold, null, this.calcHitPointHitTester, result);
            }
            return false;
        };
        DChartSeriesLinear.prototype.toThreshold = function (strokeWidth, strokeScale) {
            return +Infinity;
        };
        DChartSeriesLinear.prototype.calcHitPointHitTester = function (x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                var l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    var t = (x - p0x) / l;
                    var p2x = x;
                    var p2y = p0y + t * (p1y - p0y);
                    var distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        var transform = result.shape.transform;
                        var position = transform.position;
                        var px = position.x;
                        var py = position.y;
                        var scale = transform.scale;
                        var sx = scale.x;
                        var sy = scale.y;
                        result.x = result.p0x = result.p1x = px + sx * p2x;
                        result.y = result.p0y = result.p1y = py + sy * p2y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        };
        DChartSeriesLinear.WORK = new pixi_js.Point();
        return DChartSeriesLinear;
    }(DChartSeriesBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DChart = /** @class */ (function (_super) {
        __extends(DChart, _super);
        function DChart() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DChart.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            // Plot area
            var plotArea = this.plotArea;
            this.addChild(plotArea);
            // Overflow mask
            var mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : this.theme.isOverflowMaskEnabled();
            if (mask) {
                plotArea.axis.container.mask = this.getOverflowMask();
            }
        };
        DChart.prototype.getOverflowMask = function () {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        };
        Object.defineProperty(DChart.prototype, "plotArea", {
            get: function () {
                var result = this._plotArea;
                if (result == null) {
                    result = this.newPlotArea();
                    this._plotArea = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DChart.prototype.newPlotArea = function () {
            var _a;
            return new DChartPlotAreaImpl(this, (_a = this._options) === null || _a === void 0 ? void 0 : _a.plotArea);
        };
        DChart.prototype.getType = function () {
            return "DChart";
        };
        DChart.prototype.destroy = function () {
            var _a;
            if (!this._destroyed) {
                (_a = this._plotArea) === null || _a === void 0 ? void 0 : _a.destroy();
                _super.prototype.destroy.call(this);
            }
        };
        return DChart;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandCreate = /** @class */ (function (_super) {
        __extends(DCommandCreate, _super);
        function DCommandCreate() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCommandCreate.prototype.isStorable = function () {
            return false;
        };
        DCommandCreate.prototype.isClear = function () {
            return true;
        };
        return DCommandCreate;
    }(DCommandBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandSaveAs = /** @class */ (function (_super) {
        __extends(DCommandSaveAs, _super);
        function DCommandSaveAs(name) {
            var _this = _super.call(this) || this;
            _this._name = name;
            return _this;
        }
        Object.defineProperty(DCommandSaveAs.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: false,
            configurable: true
        });
        DCommandSaveAs.prototype.isStorable = function () {
            return false;
        };
        DCommandSaveAs.prototype.execute = function () {
            DControllers.getDocumentController().saveAs(this._name);
            return true;
        };
        return DCommandSaveAs;
    }(DCommandBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DCommandSave = /** @class */ (function (_super) {
        __extends(DCommandSave, _super);
        function DCommandSave() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DCommandSave.prototype.isStorable = function () {
            return false;
        };
        DCommandSave.prototype.execute = function () {
            DControllers.getDocumentController().save();
            return true;
        };
        return DCommandSave;
    }(DCommandBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramSnapshot = /** @class */ (function (_super) {
        __extends(DDiagramSnapshot, _super);
        function DDiagramSnapshot(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DDiagramSnapshot.prototype.createAsUrl = function (sizeOrOptions) {
            if (sizeOrOptions == null || isNumber(sizeOrOptions)) {
                return this.create({
                    size: sizeOrOptions,
                    extractor: function (canvas) {
                        return UtilExtract.base64({ target: canvas });
                    }
                });
            }
            else {
                return this.create({
                    size: sizeOrOptions.size,
                    cleanup: sizeOrOptions.cleanup,
                    extractor: function (canvas) {
                        return UtilExtract.base64({ target: canvas });
                    }
                });
            }
        };
        DDiagramSnapshot.prototype.createAsFile = function (sizeOrFilenameOrOptions, filename) {
            if (isString(sizeOrFilenameOrOptions)) {
                this.create({
                    extractor: function (canvas) {
                        UtilExtract.file({ target: canvas, filename: sizeOrFilenameOrOptions });
                    }
                });
            }
            else if (sizeOrFilenameOrOptions === null || isNumber(sizeOrFilenameOrOptions)) {
                this.create({
                    size: sizeOrFilenameOrOptions,
                    extractor: function (canvas) {
                        UtilExtract.file({ target: canvas, filename: filename });
                    }
                });
            }
            else {
                this.create({
                    size: sizeOrFilenameOrOptions.size,
                    cleanup: sizeOrFilenameOrOptions.cleanup,
                    extractor: function (canvas) {
                        UtilExtract.file({
                            target: canvas,
                            filename: sizeOrFilenameOrOptions.filename
                        });
                    }
                });
            }
        };
        DDiagramSnapshot.prototype.toScale = function (size, canvas) {
            if (size == null) {
                return 1;
            }
            return size / DApplications.getResolution(canvas) / Math.max(canvas.width, canvas.height);
        };
        DDiagramSnapshot.prototype.toCleanupSnap = function (options) {
            if (options == null) {
                return true;
            }
            var cleanup = options.cleanup;
            if (cleanup == null || cleanup === true) {
                return true;
            }
            return cleanup !== false && cleanup.snap !== false;
        };
        DDiagramSnapshot.prototype.toCleanupBackground = function (options) {
            if (options == null) {
                return false;
            }
            var cleanup = options.cleanup;
            if (cleanup == null || cleanup === false) {
                return false;
            }
            return cleanup === true || cleanup.background === true;
        };
        DDiagramSnapshot.prototype.toCleanupReflow = function (options) {
            if (options == null) {
                return true;
            }
            var cleanup = options.cleanup;
            if (cleanup == null || cleanup === true) {
                return true;
            }
            return cleanup !== false && cleanup.reflow !== false;
        };
        DDiagramSnapshot.prototype.create = function (options) {
            var parent = this._parent;
            var canvas = parent.canvas;
            if (canvas) {
                var view = parent.view;
                var viewPosition = view.position;
                var viewScale = view.scale;
                var oldPositionX = viewPosition.x;
                var oldPositionY = viewPosition.y;
                var oldScaleX = viewScale.x;
                var oldScaleY = viewScale.y;
                var newScale = this.toScale(options.size, canvas);
                view.transform(0, 0, newScale, newScale, 0);
                // Turns off the snap grid and targets
                var container = void 0;
                if (this.toCleanupSnap(options) && "snap" in canvas) {
                    var snap = canvas.snap;
                    if (snap != null) {
                        container = snap.container;
                        if (container.renderable) {
                            container.renderable = false;
                        }
                        else {
                            container = undefined;
                        }
                    }
                }
                // Turns off the canvas snippets
                var snippet = void 0;
                if (this.toCleanupBackground(options)) {
                    snippet = canvas.snippet;
                    if (snippet.renderable) {
                        snippet.renderable = false;
                    }
                    else {
                        snippet = undefined;
                    }
                }
                // Refit & reflow
                var reflow = this.toCleanupReflow(options);
                if (reflow) {
                    var layer = DApplications.getLayer(canvas);
                    if (layer) {
                        layer.reflow();
                    }
                }
                // Extracts
                this.emit("taking", canvas, this);
                var result = options.extractor(canvas);
                this.emit("took", canvas, null, this);
                // Turn on the canvas snippets
                if (snippet) {
                    snippet.renderable = true;
                }
                // Turn on the snap grid and targets
                if (container != null) {
                    container.renderable = true;
                }
                view.transform(oldPositionX, oldPositionY, oldScaleX, oldScaleY, 0);
                return result;
            }
        };
        return DDiagramSnapshot;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramBase = /** @class */ (function (_super) {
        __extends(DDiagramBase, _super);
        function DDiagramBase(options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            _this._serialized = null;
            _this._tileFactory = options === null || options === void 0 ? void 0 : options.tile;
            _this._controller = options === null || options === void 0 ? void 0 : options.controller;
            _this._isAmbient = (_a = options === null || options === void 0 ? void 0 : options.ambient) !== null && _a !== void 0 ? _a : _this.theme.isAmbient();
            _this._snapshot = new DDiagramSnapshot(_this, options === null || options === void 0 ? void 0 : options.snapshot);
            _this._mode = _this.toMode(options);
            return _this;
        }
        Object.defineProperty(DDiagramBase.prototype, "snapshot", {
            get: function () {
                return this._snapshot;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramBase.prototype, "controller", {
            get: function () {
                return this._controller || null;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramBase.prototype.set = function (serialized) {
            var _this = this;
            var oldSerialized = this._serialized;
            if (oldSerialized !== serialized) {
                if (oldSerialized) {
                    this._serialized = null;
                    var canvas = this.canvas;
                    if (canvas) {
                        this.canvas = null;
                    }
                    this.onUnset();
                }
                this._serialized = serialized;
                if (serialized) {
                    var canvas_1 = this.newCanvas(serialized);
                    var pieces_1 = serialized.pieces;
                    var mode_1 = this._mode;
                    var result = DDiagrams.toPieceData(this._controller, pieces_1, mode_1).then(function (pieceData) {
                        return _this.newLayer(serialized, canvas_1, mode_1, pieces_1, pieceData);
                    });
                    this.onSet(serialized, canvas_1);
                    this.canvas = canvas_1;
                    return result;
                }
                else {
                    return Promise.resolve(null);
                }
            }
            else {
                return Promise.resolve(this.canvas);
            }
        };
        DDiagramBase.prototype.onSet = function (serialized, canvas) {
            // DO NOTHING
        };
        DDiagramBase.prototype.newLayer = function (serialized, canvas, mode, pieces, pieceData) {
            var _this = this;
            var manager = new EShapeResourceManagerDeserialization(serialized, pieces, pieceData, mode, 0);
            var result = DDiagrams.newLayer(serialized, canvas.layer, manager).then(function (shapes) {
                return _this.initLayer(canvas, shapes);
            });
            if (this._isAmbient) {
                var background = this.toCanvasBaseBackgroundOptions(serialized, this.theme, false);
                this.background.color = background.color;
                this.background.alpha = background.alpha;
            }
            return result;
        };
        DDiagramBase.prototype.initLayer = function (canvas, shapes, mapper) {
            canvas.layer.init();
            canvas.initialize(shapes, mapper);
            DApplications.update(this);
            this.emit("ready", this);
            return canvas;
        };
        DDiagramBase.prototype.toCanvasBaseOptions = function (serialized) {
            var _a;
            var theme = this.theme;
            var isAmbient = this._isAmbient;
            return {
                name: serialized.name,
                width: serialized.width,
                height: serialized.height,
                background: this.toCanvasBaseBackgroundOptions(serialized, theme, isAmbient),
                border: isAmbient ? { color: null } : undefined,
                outline: isAmbient ? { color: null } : undefined,
                shadow: isAmbient ? null : theme.getCanvasShadow(),
                tile: {
                    factory: this._tileFactory,
                    mapping: (_a = serialized.tile) === null || _a === void 0 ? void 0 : _a.mapping
                },
                ambient: isAmbient
            };
        };
        DDiagramBase.prototype.toCanvasBaseBackgroundOptions = function (serialized, theme, isAmbient) {
            var _a, _b;
            if (isAmbient) {
                return {
                    color: null
                };
            }
            var background = serialized.background;
            return {
                color: (_a = background === null || background === void 0 ? void 0 : background.color) !== null && _a !== void 0 ? _a : theme.getCanvasBackgroundColor(),
                alpha: (_b = background === null || background === void 0 ? void 0 : background.alpha) !== null && _b !== void 0 ? _b : theme.getCanvasBackgroundAlpha()
            };
        };
        DDiagramBase.prototype.onUnset = function () {
            // DO NOTHING
        };
        DDiagramBase.prototype.get = function () {
            return this._serialized;
        };
        Object.defineProperty(DDiagramBase.prototype, "layer", {
            get: function () {
                var canvas = this.canvas;
                if (canvas) {
                    return canvas.layer.active;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramBase.prototype.getType = function () {
            return "DDiagramBase";
        };
        return DDiagramBase;
    }(DCanvasContainer));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditorBackground = /** @class */ (function () {
        function DDiagramCanvasEditorBackground(target, base) {
            this._target = target;
            this._base = base;
        }
        DDiagramCanvasEditorBackground.prototype.getTheme = function () {
            return this._target.getTheme();
        };
        DDiagramCanvasEditorBackground.prototype.setTheme = function (theme) {
            this._target.setTheme(theme);
        };
        DDiagramCanvasEditorBackground.prototype.getBaseColor = function () {
            return this._base;
        };
        DDiagramCanvasEditorBackground.prototype.setBaseColor = function (baseColor) {
            this._base = baseColor;
        };
        DDiagramCanvasEditorBackground.prototype.getColor = function (state) {
            var target = this._target;
            var base = this._base;
            var color = target.getColor(state);
            if (base != null) {
                if (color != null) {
                    return UtilRgb.blend(base, color, target.getAlpha(state));
                }
                return base;
            }
            return color;
        };
        Object.defineProperty(DDiagramCanvasEditorBackground.prototype, "color", {
            get: function () {
                return this._target.color;
            },
            set: function (color) {
                this._target.color = color;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasEditorBackground.prototype.getAlpha = function (state) {
            var base = this._base;
            if (base != null) {
                return 1;
            }
            return this._target.getAlpha(state);
        };
        Object.defineProperty(DDiagramCanvasEditorBackground.prototype, "alpha", {
            get: function () {
                return this._target.alpha;
            },
            set: function (alpha) {
                this._target.alpha = alpha;
            },
            enumerable: false,
            configurable: true
        });
        return DDiagramCanvasEditorBackground;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTileMappingPointImpl = /** @class */ (function (_super) {
        __extends(DDiagramCanvasTileMappingPointImpl, _super);
        function DDiagramCanvasTileMappingPointImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DDiagramCanvasTileMappingPointImpl.prototype, "lon", {
            get: function () {
                return this.x;
            },
            set: function (lon) {
                this.x = lon;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingPointImpl.prototype, "lat", {
            get: function () {
                return this.y;
            },
            set: function (lat) {
                this.y = lat;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasTileMappingPointImpl.prototype.toObject = function () {
            return {
                lon: this.x,
                lat: this.y
            };
        };
        return DDiagramCanvasTileMappingPointImpl;
    }(pixi_js.ObservablePoint));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTileMappingImpl = /** @class */ (function () {
        function DDiagramCanvasTileMappingImpl(cb, mappingOrEnable, lon0, lat0, lon1, lat1) {
            this._cb = cb;
            if (mappingOrEnable === true || mappingOrEnable === false) {
                this._enable = mappingOrEnable;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, lon0, lat0);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, lon1, lat1);
            }
            else if (mappingOrEnable != null) {
                this._enable = mappingOrEnable.enable;
                var from = mappingOrEnable.from;
                var to = mappingOrEnable.to;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, from.lon, from.lat);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, to.lon, to.lat);
            }
            else {
                this._enable = false;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, -180, +85.05112877980659);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, +180, -85.05112877980659);
            }
        }
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "enable", {
            get: function () {
                return this._enable;
            },
            set: function (enable) {
                if (this._enable !== enable) {
                    this._enable = enable;
                    this._cb();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "from", {
            get: function () {
                return this._from;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTileMappingImpl.prototype, "to", {
            get: function () {
                return this._to;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasTileMappingImpl.prototype.serialize = function () {
            return {
                enable: this._enable,
                from: this._from.toObject(),
                to: this._to.toObject()
            };
        };
        return DDiagramCanvasTileMappingImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTile = /** @class */ (function () {
        function DDiagramCanvasTile(canvas, options) {
            var _this = this;
            this._canvas = canvas;
            this._factory = options === null || options === void 0 ? void 0 : options.factory;
            this._mapping = new DDiagramCanvasTileMappingImpl(function () {
                _this.onMappingChange();
            }, options === null || options === void 0 ? void 0 : options.mapping);
        }
        DDiagramCanvasTile.prototype.init = function () {
            this.onMappingChange();
        };
        DDiagramCanvasTile.prototype.onMappingChange = function () {
            var factory = this._factory;
            if (factory) {
                var mapping = this._mapping;
                if (mapping.enable) {
                    var pyramid = this._pyramid;
                    if (pyramid) {
                        pyramid.mapping = mapping;
                    }
                    else {
                        this._pyramid = factory(this._canvas).fit();
                    }
                }
                else {
                    var pyramid = this._pyramid;
                    if (pyramid) {
                        this._pyramid = undefined;
                        pyramid.destroy();
                    }
                }
            }
        };
        Object.defineProperty(DDiagramCanvasTile.prototype, "pyramid", {
            get: function () {
                return this._pyramid;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTile.prototype, "factory", {
            get: function () {
                return this._factory;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasTile.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasTile.prototype.serialize = function () {
            return {
                mapping: this._mapping.serialize()
            };
        };
        DDiagramCanvasTile.prototype.destroy = function () {
            var pyramid = this._pyramid;
            if (pyramid != null) {
                this._pyramid = undefined;
                pyramid.destroy();
            }
        };
        return DDiagramCanvasTile;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramLayerContainer = /** @class */ (function (_super) {
        __extends(DDiagramLayerContainer, _super);
        function DDiagramLayerContainer(width, height) {
            var _this = _super.call(this) || this;
            _this._active = null;
            _this._width = width;
            _this._height = height;
            _this.interactive = false;
            _this.interactiveChildren = false;
            return _this;
        }
        DDiagramLayerContainer.prototype.init = function () {
            if (this._active == null) {
                var children = this.children;
                var childrenLength = children.length;
                if (0 < childrenLength) {
                    this._active = children[childrenLength - 1];
                }
            }
        };
        Object.defineProperty(DDiagramLayerContainer.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function (layer) {
                if (this._active !== layer && (layer == null || 0 <= this.children.indexOf(layer))) {
                    this._active = layer;
                    this.onLayerChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DDiagramLayerContainer.prototype.create = function (name, activate) {
            var result = new DDiagramLayer(name);
            this.attach(result, activate);
            return result;
        };
        /**
         * Adds the specified layer and activates it if the `activate` is true.
         *
         * @param layer
         * @param activate
         */
        DDiagramLayerContainer.prototype.attach = function (layer, activate) {
            this.addChild(layer);
            if (activate === true) {
                this._active = layer;
            }
            this.onLayerChange();
            DApplications.update(this);
        };
        DDiagramLayerContainer.prototype.attachAt = function (layer, index, activate) {
            this.addChildAt(layer, index);
            if (activate === true) {
                this._active = layer;
            }
            this.onLayerChange();
            DApplications.update(this);
        };
        /**
         * Removes the specified layer from this container and activates the specified layer.
         * This method does not destroy the secified layer.
         *
         * @param layer
         */
        DDiagramLayerContainer.prototype.detach = function (layer, active) {
            var children = this.children;
            var index = children.indexOf(layer);
            if (0 <= index) {
                this._active = active;
                children.splice(index, 1);
                layer.parent = undefined;
                this.onLayerChange();
                DApplications.update(this);
            }
        };
        /**
         * Removes the specified layer and activate the next layer.
         * This method does not destroy the specified layer.
         *
         * @param layer
         * @param activateNext
         */
        DDiagramLayerContainer.prototype.delete = function (layer, activateNext) {
            var children = this.children;
            var index = children.indexOf(layer);
            if (0 <= index) {
                children.splice(index, 1);
                layer.parent = undefined;
                if (this._active === layer) {
                    if (activateNext === true) {
                        if (index < children.length) {
                            this._active = children[index];
                        }
                        else if (0 < children.length) {
                            this._active = children[index - 1];
                        }
                        else {
                            this._active = null;
                        }
                    }
                    else {
                        this._active = null;
                    }
                }
                this.onLayerChange();
                DApplications.update(this);
            }
            return index;
        };
        DDiagramLayerContainer.prototype.get = function (index) {
            var child = this.children[index];
            if (child != null) {
                return child;
            }
            return null;
        };
        DDiagramLayerContainer.prototype.clear = function () {
            var children = this.children;
            if (0 < children.length) {
                for (var i = children.length - 1; 0 <= i; --i) {
                    var child = children[i];
                    child.parent = null;
                    child.destroy();
                }
                children.length = 0;
                this.onLayerChange();
                DApplications.update(this);
            }
        };
        DDiagramLayerContainer.prototype.destroy = function () {
            if (!this._destroyed) {
                this.clear();
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramLayerContainer.prototype.size = function () {
            return this.children.length;
        };
        DDiagramLayerContainer.prototype.onLayerChange = function () {
            this.emit("change", this);
        };
        DDiagramLayerContainer.prototype.serialize = function (manager, items) {
            var result = [];
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
            for (var i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
            for (var i = 0, imax = children.length; i < imax; ++i) {
                result.push(children[i].serialize(i, manager, items));
            }
            return result;
        };
        DDiagramLayerContainer.prototype.deserialize = function (serializedLayers, manager) {
            var serializedLayersLength = serializedLayers.length;
            if (0 < serializedLayersLength) {
                var width = this._width;
                var height = this._height;
                for (var i = 0; i < serializedLayersLength; ++i) {
                    this.addChild(DDiagramLayer.deserialize(serializedLayers[i], manager, width, height));
                }
                this.onLayerChange();
                DApplications.update(this);
            }
        };
        return DDiagramLayerContainer;
    }(pixi_js.Container));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasBase = /** @class */ (function (_super) {
        __extends(DDiagramCanvasBase, _super);
        function DDiagramCanvasBase(options) {
            var _this = _super.call(this, options) || this;
            // Background
            var theme = _this.theme;
            if (!_this.isAmbient(theme, options)) {
                _this._background = new DDiagramCanvasEditorBackground(_this._background, _this.toBackgroundBase(theme, options));
            }
            // Layer
            var layer = new DDiagramLayerContainer(_this.width, _this.height);
            _this._layer = layer;
            _this.addChild(layer);
            // Tile
            var tile = new DDiagramCanvasTile(_this, options === null || options === void 0 ? void 0 : options.tile);
            _this._tile = tile;
            tile.init();
            return _this;
        }
        DDiagramCanvasBase.prototype.isAmbient = function (theme, options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.ambient) !== null && _a !== void 0 ? _a : theme.isAmbient();
        };
        DDiagramCanvasBase.prototype.toBackgroundBase = function (theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.background) === null || _a === void 0 ? void 0 : _a.base) !== null && _b !== void 0 ? _b : theme.getBackgroundBase();
        };
        Object.defineProperty(DDiagramCanvasBase.prototype, "tile", {
            get: function () {
                return this._tile;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasBase.prototype, "layer", {
            get: function () {
                return this._layer;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasBase.prototype.initialize = function (shapes, mapper) {
            // DO NOTHING
        };
        DDiagramCanvasBase.prototype.destroy = function () {
            if (!this._destroyed) {
                this.onDestroy();
                _super.prototype.destroy.call(this);
            }
        };
        DDiagramCanvasBase.prototype.onDestroy = function () {
            this._tile.destroy();
            this._layer.destroy();
        };
        DDiagramCanvasBase.prototype.hitTest = function (global, onHit) {
            var layers = this._layer.children;
            for (var i = layers.length - 1; 0 <= i; --i) {
                var layer = layers[i];
                if (layer.visible) {
                    var shape = layer.hitTest(global, onHit);
                    if (shape != null) {
                        return shape;
                    }
                }
            }
            return null;
        };
        DDiagramCanvasBase.prototype.getType = function () {
            return "DDiagramCanvasBase";
        };
        return DDiagramCanvasBase;
    }(DCanvas));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasBaseShapeImpl = /** @class */ (function () {
        function DDiagramCanvasBaseShapeImpl(canvas) {
            this._canvas = canvas;
        }
        DDiagramCanvasBaseShapeImpl.prototype.each = function (iteratee, ignoreCapability) {
            var canvas = this._canvas;
            var layers = canvas.layer.children;
            for (var i = 0, imax = layers.length; i < imax; ++i) {
                if (this.each_(layers[i].children, iteratee, ignoreCapability) === false) {
                    break;
                }
            }
            return this;
        };
        DDiagramCanvasBaseShapeImpl.prototype.each_ = function (shapes, iteratee, ignoreCapability) {
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                var shape = shapes[i];
                if (iteratee(shape) === false) {
                    return false;
                }
                if (ignoreCapability || EShapeCapabilities.contains(shape, EShapeCapability.CHILDREN)) {
                    var children = shape.children;
                    if (0 < children.length) {
                        if (this.each_(children, iteratee, ignoreCapability) === false) {
                            return false;
                        }
                    }
                }
            }
        };
        return DDiagramCanvasBaseShapeImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasDataImpl = /** @class */ (function () {
        function DDiagramCanvasDataImpl() {
        }
        Object.defineProperty(DDiagramCanvasDataImpl.prototype, "private", {
            get: function () {
                var result = this._private;
                if (result == null) {
                    result = this.newPrivate();
                    this._private = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasDataImpl.prototype.newPrivate = function () {
            return new EShapeDataScopedImpl();
        };
        Object.defineProperty(DDiagramCanvasDataImpl.prototype, "protected", {
            get: function () {
                var result = this._protected;
                if (result == null) {
                    result = this.newProtected();
                    this._protected = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasDataImpl.prototype.newProtected = function () {
            return new EShapeDataScopedImpl();
        };
        Object.defineProperty(DDiagramCanvasDataImpl.prototype, "extended", {
            get: function () {
                var result = this._extended;
                if (result == null) {
                    result = this.newExtended();
                    this._extended = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasDataImpl.prototype.newExtended = function () {
            return new EShapeDataScopedImpl();
        };
        Object.defineProperty(DDiagramCanvasDataImpl.prototype, "ids", {
            get: function () {
                var data = this._data;
                if (data == null) {
                    return [];
                }
                var result = [];
                data.forEach(function (value, id) {
                    result.push(id);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasDataImpl.prototype.each = function (iteratee) {
            var data = this._data;
            if (data == null) {
                return null;
            }
            var result = null;
            data.forEach(function (value, id) {
                if (result == null) {
                    if (iteratee(id) === false) {
                        result = id;
                    }
                }
            });
            return result;
        };
        DDiagramCanvasDataImpl.prototype.add = function (id, value) {
            var _a;
            var data = ((_a = this._data) !== null && _a !== void 0 ? _a : (this._data = new Map()));
            var list = data.get(id);
            if (list == null) {
                data.set(id, [value]);
            }
            else {
                list.push(value);
            }
        };
        DDiagramCanvasDataImpl.prototype.set = function (id, value, time, state, from, to) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                var datumValue = datum[i];
                var range = datumValue.range;
                // Range
                range.set(from, to);
                // Time
                if (time !== undefined) {
                    datumValue.time = time;
                }
                // State
                if (state !== undefined) {
                    datumValue.state = state;
                }
                // Value
                if (value !== undefined) {
                    datumValue.value = value;
                }
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.get = function (id) {
            var data = this._data;
            if (data == null) {
                return null;
            }
            var datum = data.get(id);
            if (datum == null) {
                return null;
            }
            return datum;
        };
        DDiagramCanvasDataImpl.prototype.clear = function (id) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].clear();
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.toDirty = function (id) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].toDirty();
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setAll = function (id, values, times, states, from, to) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                var datumValue = datum[i];
                var range = datumValue.range;
                // Range
                range.set(from, to);
                // Time
                if (times !== undefined) {
                    datumValue.times = times;
                }
                // State
                if (states !== undefined) {
                    datumValue.states = states;
                }
                // Value
                if (values !== undefined) {
                    datumValue.values = values;
                }
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setValue = function (id, value) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].value = value;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setValues = function (id, values) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].values = values;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setTime = function (id, time) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].time = time;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setTimes = function (id, times) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].times = times;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setState = function (id, state) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].state = state;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setStates = function (id, states) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                datum[i].states = states;
            }
            return true;
        };
        DDiagramCanvasDataImpl.prototype.setRange = function (id, from, to) {
            var data = this._data;
            if (data == null) {
                return false;
            }
            var datum = data.get(id);
            if (datum == null) {
                return false;
            }
            var size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (var i = 0; i < size; ++i) {
                var range = datum[i].range;
                if (from !== undefined) {
                    if (from !== null) {
                        range.type |= EShapeDataValueRangeType.FROM;
                        range.from = from;
                    }
                    else {
                        range.type &= ~EShapeDataValueRangeType.FROM;
                    }
                }
                if (to !== undefined) {
                    if (to !== null) {
                        range.type |= EShapeDataValueRangeType.TO;
                        range.to = to;
                    }
                    else {
                        range.type &= ~EShapeDataValueRangeType.TO;
                    }
                }
            }
            return true;
        };
        return DDiagramCanvasDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditorShapeImpl = /** @class */ (function (_super) {
        __extends(DDiagramCanvasEditorShapeImpl, _super);
        function DDiagramCanvasEditorShapeImpl() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DDiagramCanvasEditorShapeImpl;
    }(DDiagramCanvasBaseShapeImpl));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditorSnap = /** @class */ (function () {
        function DDiagramCanvasEditorSnap(parent, theme, options) {
            var _this = this;
            this._parent = parent;
            // Controller
            var controller = options.controller;
            this._controller = controller;
            var onChangeBound = function () {
                _this.onChange();
            };
            controller.grid.on("change", onChangeBound);
            controller.target.on("change", onChangeBound);
            // Container
            var container = new EShapeContainer();
            container.visible = false;
            this._container = container;
            parent.addChildAt(container, parent.children.length - 1);
            // Grid
            this._grid = this.toGrid(theme, options.grid);
            // Target
            this._target = this.toTarget(theme, options.target);
        }
        DDiagramCanvasEditorSnap.prototype.toGrid = function (theme, options) {
            var _a;
            return {
                major: this.toGridMajor(theme, options === null || options === void 0 ? void 0 : options.major),
                minor: this.toGridMinor(theme, options === null || options === void 0 ? void 0 : options.minor),
                size: (_a = options === null || options === void 0 ? void 0 : options.size) !== null && _a !== void 0 ? _a : theme.getSnapGridSize()
            };
        };
        DDiagramCanvasEditorSnap.prototype.toGridMajor = function (theme, options) {
            var _a, _b, _c, _d, _e;
            return {
                interval: (_a = options === null || options === void 0 ? void 0 : options.interval) !== null && _a !== void 0 ? _a : theme.getSnapGridMajorInterval(),
                color: (_b = options === null || options === void 0 ? void 0 : options.color) !== null && _b !== void 0 ? _b : theme.getSnapGridMajorColor(),
                alpha: (_c = options === null || options === void 0 ? void 0 : options.alpha) !== null && _c !== void 0 ? _c : theme.getSnapGridMajorAlpha(),
                width: (_d = options === null || options === void 0 ? void 0 : options.width) !== null && _d !== void 0 ? _d : theme.getSnapGridMajorWidth(),
                style: (_e = options === null || options === void 0 ? void 0 : options.style) !== null && _e !== void 0 ? _e : theme.getSnapGridMajorStyle()
            };
        };
        DDiagramCanvasEditorSnap.prototype.toGridMinor = function (theme, options) {
            var _a, _b, _c, _d;
            return {
                color: (_a = options === null || options === void 0 ? void 0 : options.color) !== null && _a !== void 0 ? _a : theme.getSnapGridMinorColor(),
                alpha: (_b = options === null || options === void 0 ? void 0 : options.alpha) !== null && _b !== void 0 ? _b : theme.getSnapGridMinorAlpha(),
                width: (_c = options === null || options === void 0 ? void 0 : options.width) !== null && _c !== void 0 ? _c : theme.getSnapGridMinorWidth(),
                style: (_d = options === null || options === void 0 ? void 0 : options.style) !== null && _d !== void 0 ? _d : theme.getSnapGridMinorStyle()
            };
        };
        DDiagramCanvasEditorSnap.prototype.toTarget = function (theme, options) {
            var _a, _b, _c, _d;
            return {
                color: (_a = options === null || options === void 0 ? void 0 : options.color) !== null && _a !== void 0 ? _a : theme.getSnapTargetColor(),
                alpha: (_b = options === null || options === void 0 ? void 0 : options.alpha) !== null && _b !== void 0 ? _b : theme.getSnapTargetAlpha(),
                width: (_c = options === null || options === void 0 ? void 0 : options.width) !== null && _c !== void 0 ? _c : theme.getSnapTargetWidth(),
                style: (_d = options === null || options === void 0 ? void 0 : options.style) !== null && _d !== void 0 ? _d : theme.getSnapTargetStyle()
            };
        };
        DDiagramCanvasEditorSnap.prototype.onChange = function () {
            var parent = this._parent;
            parent.toDirty();
            DApplications.update(parent);
        };
        Object.defineProperty(DDiagramCanvasEditorSnap.prototype, "container", {
            get: function () {
                return this._container;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasEditorSnap.prototype.serialize = function () {
            return this._controller.serialize();
        };
        DDiagramCanvasEditorSnap.prototype.onReflow = function () {
            var parent = this._parent;
            var container = this._container;
            var controller = this._controller;
            var isGridVisible = controller.grid.visible;
            var isTargetVisible = controller.target.visible;
            if (isGridVisible || isTargetVisible) {
                var w = parent.width;
                var h = parent.height;
                var wh = 0.5 * w;
                var hh = 0.5 * h;
                var TOP = EShapeBarPosition.TOP;
                var LEFT = EShapeBarPosition.LEFT;
                var shapes = container.children;
                var index = 0;
                // Grid
                if (isGridVisible) {
                    var grid = this._grid;
                    var major = grid.major;
                    var minor = grid.minor;
                    var interval = major.interval;
                    var size = grid.size(controller.grid.size, w, h);
                    for (var x = size, ix = 1; x < w; x += size, ix += 1, index += 1) {
                        var style = ix % interval === 0 ? major : minor;
                        this.update(container, shapes, index, x, hh, TOP, w, h, style);
                    }
                    for (var y = size, iy = 1; y < h; y += size, iy += 1, index += 1) {
                        var style = iy % interval === 0 ? major : minor;
                        this.update(container, shapes, index, wh, y, LEFT, w, h, style);
                    }
                }
                // Target
                if (isTargetVisible) {
                    var values = controller.target.values;
                    var target = this._target;
                    for (var i = 0, imax = values.length; i < imax; i += 1, index += 1) {
                        var value = values[i];
                        var position = value.position;
                        if (value.type === ESnapperTargetValueType.VERTICAL) {
                            this.update(container, shapes, index, position, hh, TOP, w, h, target);
                        }
                        else {
                            this.update(container, shapes, index, wh, position, LEFT, w, h, target);
                        }
                    }
                }
                for (var i = index, imax = shapes.length; i < imax; ++i) {
                    shapes[i].visible = false;
                }
                container.visible = true;
            }
            else {
                container.visible = false;
            }
        };
        DDiagramCanvasEditorSnap.prototype.update = function (container, shapes, index, x, y, position, w, h, style) {
            var shape = null;
            if (index < shapes.length) {
                shape = shapes[index];
                shape.disallowUploadedUpdate();
                shape.points.position = position;
                shape.transform.position.set(x, y);
                shape.stroke.set(true, style.color, style.alpha, style.width, undefined, undefined, style.style);
                shape.size.set(w, h);
                shape.visible = true;
                shape.allowUploadedUpdate();
            }
            else {
                shape = new EShapeBar();
                shape.disallowUploadedUpdate();
                shape.points.position = position;
                shape.transform.position.set(x, y);
                shape.stroke.set(true, style.color, style.alpha, style.width, undefined, undefined, style.style);
                shape.size.set(w, h);
                shape.visible = true;
                shape.allowUploadedUpdate();
                shape.attach(container);
            }
        };
        return DDiagramCanvasEditorSnap;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramSerializedVersion = 1;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasEditor = /** @class */ (function (_super) {
        __extends(DDiagramCanvasEditor, _super);
        function DDiagramCanvasEditor(options) {
            var _this = _super.call(this, options) || this;
            _this._snap = _this.toSnap(_this.theme, options.snap);
            return _this;
        }
        DDiagramCanvasEditor.prototype.toSnap = function (theme, options) {
            if (options) {
                return new DDiagramCanvasEditorSnap(this, theme, options);
            }
            return null;
        };
        Object.defineProperty(DDiagramCanvasEditor.prototype, "snap", {
            get: function () {
                return this._snap;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvasEditor.prototype, "shape", {
            get: function () {
                var result = this._shape;
                if (result == null) {
                    result = this.newShape();
                    this._shape = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvasEditor.prototype.newShape = function () {
            return new DDiagramCanvasEditorShapeImpl(this);
        };
        DDiagramCanvasEditor.prototype.serialize = function (id, thumbnail) {
            var _a;
            var manager = new EShapeResourceManagerSerialization();
            var items = [];
            var background = this._background;
            var backgroundColor = background.color;
            var backgroundAlpha = background.alpha;
            return {
                version: DDiagramSerializedVersion,
                id: id,
                name: this.name,
                width: this.width,
                height: this.height,
                background: {
                    color: isNumber(backgroundColor) ? backgroundColor : 0xffffff,
                    alpha: isNumber(backgroundAlpha) ? backgroundAlpha : 0
                },
                tile: this._tile.serialize(),
                resources: manager.resources,
                data: manager.data,
                pieces: manager.pieces,
                layers: this._layer.serialize(manager, items),
                items: items,
                snap: (_a = this._snap) === null || _a === void 0 ? void 0 : _a.serialize(),
                thumbnail: thumbnail === null || thumbnail === void 0 ? void 0 : thumbnail.serialize()
            };
        };
        DDiagramCanvasEditor.prototype.onReflow = function () {
            var _a;
            _super.prototype.onReflow.call(this);
            (_a = this._snap) === null || _a === void 0 ? void 0 : _a.onReflow();
        };
        DDiagramCanvasEditor.prototype.getType = function () {
            return "DDiagramCanvasEditor";
        };
        return DDiagramCanvasEditor;
    }(DDiagramCanvasBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasShapeImpl = /** @class */ (function (_super) {
        __extends(DDiagramCanvasShapeImpl, _super);
        function DDiagramCanvasShapeImpl(canvas) {
            var _this = _super.call(this, canvas) || this;
            _this._data = new Map();
            return _this;
        }
        DDiagramCanvasShapeImpl.prototype.add = function (id, shape) {
            var data = this._data;
            var shapes = data.get(id);
            if (shapes == null) {
                data.set(id, [shape]);
            }
            else {
                shapes.push(shape);
            }
        };
        DDiagramCanvasShapeImpl.prototype.get = function (id) {
            var shapes = this._data.get(id);
            if (shapes && 0 < shapes.length) {
                return shapes[0];
            }
            return null;
        };
        DDiagramCanvasShapeImpl.prototype.getAll = function (id) {
            return this._data.get(id) || [];
        };
        return DDiagramCanvasShapeImpl;
    }(DDiagramCanvasBaseShapeImpl));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramTicker = /** @class */ (function () {
        function DDiagramTicker(parent, interval) {
            var _this = this;
            this._parent = parent;
            this._values = [];
            this._interval = interval;
            this._onTimeBound = function () {
                _this.onTime();
            };
        }
        DDiagramTicker.prototype.add = function (value) {
            this._values.push(value);
        };
        DDiagramTicker.prototype.start = function () {
            if (this._timeoutId == null) {
                this.onTime();
            }
        };
        DDiagramTicker.prototype.getInterval = function () {
            var now = Date.now();
            var interval = this._interval;
            return Math.max(0, interval - (now % interval));
        };
        DDiagramTicker.prototype.onTime = function () {
            var values = this._values;
            if (0 < values.length) {
                var t = Date.now() / this._interval;
                for (var i = 0, imax = values.length; i < imax; ++i) {
                    values[i].value = t;
                }
                DApplications.update(this._parent);
            }
            this._timeoutId = window.setTimeout(this._onTimeBound, this.getInterval());
        };
        DDiagramTicker.prototype.stop = function () {
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
                this._timeoutId = undefined;
            }
        };
        return DDiagramTicker;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramCanvasTickerImpl = /** @class */ (function () {
        function DDiagramCanvasTickerImpl(parent) {
            this._parent = parent;
            this._data = new Map();
        }
        DDiagramCanvasTickerImpl.prototype.add = function (interval) {
            var data = this._data;
            var normalized = this.toNormalized(interval);
            var ticker = data.get(normalized);
            if (ticker != null) {
                return ticker;
            }
            var newTicker = new DDiagramTicker(this._parent, normalized);
            data.set(normalized, newTicker);
            return newTicker;
        };
        DDiagramCanvasTickerImpl.prototype.toNormalized = function (interval) {
            return isNumber(interval) ? Math.max(1, Math.round(interval)) : 1000;
        };
        DDiagramCanvasTickerImpl.prototype.start = function () {
            this._data.forEach(function (ticker) {
                ticker.start();
            });
        };
        DDiagramCanvasTickerImpl.prototype.stop = function () {
            this._data.forEach(function (ticker) {
                ticker.stop();
            });
        };
        return DDiagramCanvasTickerImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var INITIAL_ZERO = "0";
    var INITIAL_ARRAY = "[]";
    var INITIAL_STRING = '""';
    var INITIAL_OBJECT = "{}";
    var INITIAL_FALSE = "false";
    var INITIALIZER_ZERO = function () {
        return 0;
    };
    var INITIALIZER_ARRAY = function () {
        return [];
    };
    var INITIALIZER_STRING = function () {
        return "";
    };
    var INITIALIZER_OBJECT = function () {
        return {};
    };
    var INITIALIZER_FALSE = function () {
        return false;
    };
    var DDiagramCanvas = /** @class */ (function (_super) {
        __extends(DDiagramCanvas, _super);
        function DDiagramCanvas(options) {
            var _this = _super.call(this, options) || this;
            _this._data = new DDiagramCanvasDataImpl();
            _this._shape = new DDiagramCanvasShapeImpl(_this);
            _this._ticker = new DDiagramCanvasTickerImpl(_this);
            _this._actionables = [];
            _this._downeds = new Set();
            _this._updateBound = function () {
                DApplications.update(_this);
            };
            return _this;
        }
        Object.defineProperty(DDiagramCanvas.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvas.prototype, "shape", {
            get: function () {
                return this._shape;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramCanvas.prototype, "ticker", {
            get: function () {
                return this._ticker;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramCanvas.prototype.initialize = function (shapes, mapper) {
            var _this = this;
            var actionables = this._actionables;
            var data = this._data;
            this.initialize_(shapes, null, null, mapper, new Map(), new Map(), new Map(), this._ticker, this._shape, data, actionables);
            var layers = this._layer.children;
            var layersLength = layers.length;
            for (var i = 0; i < layersLength; ++i) {
                layers[i].initialize(actionables);
            }
            EShapeActionEnvironment.isInitializing = true;
            var time = Date.now();
            for (var i = 0; i < layersLength; ++i) {
                layers[i].update(time);
            }
            EShapeActionEnvironment.isInitializing = false;
            data.extended.each(function (id) {
                var extension = EShapeDataValueExtensions.getById(id);
                if (extension) {
                    var start = extension.start;
                    if (start) {
                        start(_this);
                    }
                }
            });
            this._ticker.start();
        };
        DDiagramCanvas.prototype.initialize_ = function (shapes, dataShape, containerShape, mapper, formatters, initializers, actionValueToRuntime, canvasTicker, canvasShape, canvasData, actionables) {
            var _loop_1 = function (i, imax) {
                var shape = shapes[i];
                // ID
                var id = shape.id;
                if (0 < id.length) {
                    canvasShape.add(id, shape);
                }
                // Data
                this_1.initData(shape, dataShape, containerShape, mapper, formatters, initializers, canvasTicker, canvasData);
                // Runtime
                var runtime = new (EShapeRuntimes[shape.type] || EShapeRuntimeImpl)(shape);
                shape.runtime = runtime;
                // Action
                this_1.initActions(shape, runtime, actionValueToRuntime);
                // Init the runtime
                runtime.initialize(shape);
                // Shortcut
                var shortcut = shape.shortcut;
                if (shortcut != null) {
                    UtilKeyboardEvent.on(shape, shortcut, function (e) {
                        runtime.onClick(shape, e);
                    });
                }
                // Actionables
                if (runtime.isActionable()) {
                    actionables.push(shape);
                }
                // Children
                var children = shape.children;
                if (0 < children.length) {
                    var newDataShape = dataShape;
                    var newContainerShape = containerShape;
                    if (shape instanceof EShapeEmbedded) {
                        if (newDataShape == null) {
                            newDataShape = shape;
                        }
                        newContainerShape = shape;
                    }
                    this_1.initialize_(children, newDataShape, newContainerShape, mapper, formatters, initializers, actionValueToRuntime, canvasTicker, canvasShape, canvasData, actionables);
                }
            };
            var this_1 = this;
            for (var i = 0, imax = shapes.length; i < imax; ++i) {
                _loop_1(i);
            }
        };
        DDiagramCanvas.prototype.initData = function (shape, dataShape, containerShape, mapper, formatters, initializers, canvasTicker, canvasData) {
            var data = shape.data;
            for (var i = 0, imax = data.size(); i < imax; ++i) {
                var value = data.get(i);
                if (value == null) {
                    continue;
                }
                switch (value.type) {
                    case EShapeDataValueType.BOOLEAN:
                    case EShapeDataValueType.BOOLEAN_ARRAY:
                    case EShapeDataValueType.NUMBER:
                    case EShapeDataValueType.NUMBER_ARRAY:
                    case EShapeDataValueType.STRING:
                    case EShapeDataValueType.STRING_ARRAY:
                    case EShapeDataValueType.OBJECT:
                    case EShapeDataValueType.OBJECT_ARRAY:
                        this.initDataValue(value, shape, dataShape, containerShape, mapper, formatters, initializers, canvasData);
                        break;
                    case EShapeDataValueType.TICKER:
                        this.initDataTicker(value, initializers, canvasTicker);
                        break;
                    default:
                        this.initDataExtension(value, canvasData);
                        break;
                }
            }
        };
        DDiagramCanvas.prototype.initDataValue = function (value, shape, dataShape, containerShape, mapper, formatters, initializers, canvasData) {
            // Mapping
            if (value.scope === EShapeDataValueScope.PRIVATE) {
                var id = value.id;
                if (0 < id.length) {
                    if (containerShape) {
                        containerShape.data.private.add(id, value);
                    }
                    else {
                        canvasData.private.add(id, value);
                    }
                }
            }
            else if (value.scope === EShapeDataValueScope.PROTECTED) {
                var id = value.id;
                if (0 < id.length) {
                    canvasData.protected.add(id, value);
                }
            }
            else {
                if (mapper) {
                    mapper(value, dataShape || shape);
                }
                var id = value.id;
                if (0 < id.length) {
                    canvasData.add(id, value);
                }
            }
            // Format
            var format = value.format;
            var initial = value.initial;
            var formatToFormatter = formatters.get(value.type);
            if (formatToFormatter == null) {
                formatToFormatter = new Map();
                formatters.set(value.type, formatToFormatter);
            }
            var oldFormatter = formatToFormatter.get(format);
            if (oldFormatter != null) {
                value.formatter = oldFormatter;
            }
            else if (0 < format.length) {
                var newFormatter = this.calcFormatter(value, format, initial);
                formatToFormatter.set(format, newFormatter);
                value.formatter = newFormatter;
            }
            // Initial
            var initialToInitializer = initializers.get(value.type);
            if (initialToInitializer == null) {
                initialToInitializer = new Map();
                initializers.set(value.type, initialToInitializer);
            }
            var oldInitializer = initialToInitializer.get(initial);
            if (oldInitializer != null) {
                value.value = oldInitializer();
            }
            else {
                var newInitializer = this.calcInitial(value, initial);
                initialToInitializer.set(initial, newInitializer);
                value.value = newInitializer();
            }
        };
        DDiagramCanvas.prototype.initDataTicker = function (value, initializers, canvasTicker) {
            var initial = value.initial;
            var initialToInitializer = initializers.get(value.type);
            if (initialToInitializer == null) {
                initialToInitializer = new Map();
                initializers.set(value.type, initialToInitializer);
            }
            var oldInitializer = initialToInitializer.get(initial);
            if (oldInitializer !== undefined) {
                value.value = 0;
                canvasTicker.add(oldInitializer()).add(value);
            }
            else {
                var newInitializer = this.calcInitial(value, initial);
                initialToInitializer.set(initial, newInitializer);
                value.value = 0;
                canvasTicker.add(newInitializer()).add(value);
            }
        };
        DDiagramCanvas.prototype.initDataExtension = function (value, canvasData) {
            var extension = EShapeDataValueExtensions.get(value.type);
            if (extension) {
                canvasData.extended.add(extension.id, value);
                value.value = extension.initial;
            }
        };
        DDiagramCanvas.prototype.initActions = function (shape, shapeRuntime, valueToRuntime) {
            var values = shape.action.values;
            var runtimes = shapeRuntime.actions;
            var typeRuntimes = EShapeActionRuntimes.get(shape.type);
            if (typeRuntimes != null) {
                for (var i = 0, imax = typeRuntimes.length; i < imax; ++i) {
                    var typeRuntime = typeRuntimes[i];
                    runtimes.push(typeRuntime);
                    shapeRuntime.reset |= typeRuntime.reset;
                }
            }
            for (var i = 0, imax = values.length; i < imax; ++i) {
                var value = values[i];
                var runtime = valueToRuntime.get(value);
                if (runtime == null) {
                    runtime = value.toRuntime();
                    if (runtime != null) {
                        valueToRuntime.set(value, runtime);
                        runtimes.push(runtime);
                        shapeRuntime.reset |= runtime.reset;
                    }
                }
                else {
                    runtimes.push(runtime);
                    shapeRuntime.reset |= runtime.reset;
                }
            }
        };
        DDiagramCanvas.prototype.calcFormatter = function (value, format, initial) {
            var def = this.toInitial(value);
            try {
                return Function("value", 
                /* eslint-disable prettier/prettier */
                "try {" +
                    "return (".concat(format, ");") +
                    "} catch( e1 ) {" +
                    "try {" +
                    "return (".concat(0 < initial.length ? initial : def, ");") +
                    "} catch( e2 ) {" +
                    "return ".concat(def, ";") +
                    "}" +
                    "}"
                /* eslint-enable prettier/prettier */
                );
            }
            catch (e) {
                return this.toInitializer(value);
            }
        };
        DDiagramCanvas.prototype.calcInitial = function (value, initial) {
            if (initial.length <= 0) {
                return this.toInitializer(value);
            }
            try {
                return Function(
                /* eslint-disable prettier/prettier */
                "try {" +
                    "return (".concat(initial, ");") +
                    "} catch( e ) {" +
                    "return ".concat(this.toInitial(value), ";") +
                    "}"
                /* eslint-enable prettier/prettier */
                );
            }
            catch (e) {
                return this.toInitializer(value);
            }
        };
        DDiagramCanvas.prototype.toInitial = function (value) {
            var valueType = value.type;
            switch (valueType) {
                case EShapeDataValueType.BOOLEAN:
                    return INITIAL_FALSE;
                case EShapeDataValueType.BOOLEAN_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.NUMBER:
                    return INITIAL_ZERO;
                case EShapeDataValueType.NUMBER_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.STRING:
                    return INITIAL_STRING;
                case EShapeDataValueType.STRING_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.OBJECT:
                    return INITIAL_OBJECT;
                case EShapeDataValueType.OBJECT_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.TICKER:
                    return INITIAL_ZERO;
                default:
                    return INITIAL_ZERO;
            }
        };
        DDiagramCanvas.prototype.toInitializer = function (value) {
            var valueType = value.type;
            switch (valueType) {
                case EShapeDataValueType.BOOLEAN:
                    return INITIALIZER_FALSE;
                case EShapeDataValueType.BOOLEAN_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.NUMBER:
                    return INITIALIZER_ZERO;
                case EShapeDataValueType.NUMBER_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.STRING:
                    return INITIALIZER_STRING;
                case EShapeDataValueType.STRING_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.OBJECT:
                    return INITIALIZER_OBJECT;
                case EShapeDataValueType.OBJECT_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.TICKER:
                    return INITIALIZER_ZERO;
                default:
                    return INITIALIZER_ZERO;
            }
        };
        DDiagramCanvas.prototype.onDestroy = function () {
            var _this = this;
            this._data.extended.each(function (id) {
                var extension = EShapeDataValueExtensions.getById(id);
                if (extension) {
                    var stop_1 = extension.stop;
                    if (stop_1) {
                        stop_1(_this);
                    }
                }
            });
            this._ticker.stop();
            _super.prototype.onDestroy.call(this);
        };
        DDiagramCanvas.prototype.hitTestInteractives = function (global) {
            var layers = this._layer.children;
            for (var i = layers.length - 1; 0 <= i; --i) {
                var layer = layers[i];
                if (layer.visible) {
                    var result = layer.hitTestInteractives(global);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        DDiagramCanvas.prototype.onShapeMove = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            // Cursor
            this.cursor = this._cursor = this.toShapeCursor(found);
            // TItle
            var layer = DApplications.getLayer(this);
            if (layer) {
                var title = this.toShapeTitle(found);
                var view = layer.view;
                if (view.title !== title) {
                    view.title = title;
                }
            }
            var overed = this._overed;
            this._overed = found;
            if (found === overed) {
                if (found != null) {
                    var runtime = found.runtime;
                    if (runtime) {
                        runtime.onMove(found, e);
                    }
                }
            }
            else {
                this.onShapeOut(e, overed, found);
                this.onShapeOver(e, found);
            }
            return found != null;
        };
        DDiagramCanvas.prototype.toShapeCursor = function (target) {
            if (target != null) {
                var current = target;
                while (true) {
                    var cursor = current.cursor;
                    if (cursor != null && 0 < cursor.length) {
                        return cursor;
                    }
                    var parent_1 = current.parent;
                    if (parent_1 instanceof EShapeBase) {
                        current = parent_1;
                    }
                    else {
                        break;
                    }
                }
            }
            return "auto";
        };
        DDiagramCanvas.prototype.toShapeTitle = function (target) {
            if (target != null) {
                var current = target;
                while (true) {
                    var title = current.title;
                    if (title != null && 0 < title.length) {
                        return title;
                    }
                    var parent_2 = current.parent;
                    if (parent_2 instanceof EShapeBase) {
                        current = parent_2;
                    }
                    else {
                        break;
                    }
                }
            }
            return "";
        };
        DDiagramCanvas.prototype.onShapeOut = function (e, target, except) {
            while (target != null && target !== except && target instanceof EShapeBase) {
                var runtime = target.runtime;
                if (runtime) {
                    runtime.onOut(target, e);
                }
                target = target.parent;
            }
        };
        DDiagramCanvas.prototype.onShapeOver = function (e, target, except) {
            while (target != null && target !== except && target instanceof EShapeBase) {
                var runtime = target.runtime;
                if (runtime) {
                    runtime.onOver(target, e);
                }
                target = target.parent;
            }
        };
        DDiagramCanvas.prototype.onShapeDown = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            this._downed = found;
            if (found) {
                this._downeds.add(found);
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onDown(target, e);
                    }
                    var parent_3 = target.parent;
                    if (parent_3 instanceof EShapeBase) {
                        target = parent_3;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeUp = function (e) {
            var downeds = this._downeds;
            var found = this.hitTestInteractives(e.data.global);
            if (found) {
                downeds.delete(found);
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onUp(target, e);
                    }
                    var parent_4 = target.parent;
                    if (parent_4 instanceof EShapeBase) {
                        target = parent_4;
                    }
                    else {
                        break;
                    }
                }
            }
            this.onShapeCancel(e);
            return found != null;
        };
        DDiagramCanvas.prototype.onShapeCancel = function (e) {
            var downeds = this._downeds;
            if (0 < downeds.size) {
                downeds.forEach(function (downed) {
                    var target = downed;
                    while (true) {
                        var runtime = target.runtime;
                        if (runtime) {
                            runtime.onUpOutside(target, e);
                        }
                        var parent_5 = target.parent;
                        if (parent_5 instanceof EShapeBase) {
                            target = parent_5;
                        }
                        else {
                            break;
                        }
                    }
                });
                downeds.clear();
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeClick = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            if (found && this._downed === found) {
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onClick(target, e);
                    }
                    var parent_6 = target.parent;
                    if (parent_6 instanceof EShapeBase) {
                        target = parent_6;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeDblClick = function (e, interactionManager) {
            var _a;
            var global = ((_a = DDiagramCanvas.WORK_DBLCLICK) !== null && _a !== void 0 ? _a : (DDiagramCanvas.WORK_DBLCLICK = new pixi_js.Point()));
            UtilPointerEvent.toGlobal(e, interactionManager, global);
            var found = this.hitTestInteractives(global);
            if (found) {
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onDblClick(target, e, interactionManager);
                    }
                    var parent_7 = target.parent;
                    if (parent_7 instanceof EShapeBase) {
                        target = parent_7;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeRightClick = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            if (found && this._downed === found) {
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onRightClick(target, e);
                    }
                    var parent_8 = target.parent;
                    if (parent_8 instanceof EShapeBase) {
                        target = parent_8;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeRightDown = function (e) {
            var found = this.hitTestInteractives(e.data.global);
            this._downed = found;
            if (found) {
                this._downeds.add(found);
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onRightDown(target, e);
                    }
                    var parent_9 = target.parent;
                    if (parent_9 instanceof EShapeBase) {
                        target = parent_9;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.onShapeRightUp = function (e) {
            var downeds = this._downeds;
            var found = this.hitTestInteractives(e.data.global);
            if (found) {
                downeds.delete(found);
                var target = found;
                while (true) {
                    var runtime = target.runtime;
                    if (runtime) {
                        runtime.onRightUp(target, e);
                    }
                    var parent_10 = target.parent;
                    if (parent_10 instanceof EShapeBase) {
                        target = parent_10;
                    }
                    else {
                        break;
                    }
                }
            }
            this.onShapeRightCancel(e);
            return found != null;
        };
        DDiagramCanvas.prototype.onShapeRightCancel = function (e) {
            var downeds = this._downeds;
            if (0 < downeds.size) {
                downeds.forEach(function (downed) {
                    var target = downed;
                    while (true) {
                        var runtime = target.runtime;
                        if (runtime) {
                            runtime.onRightUpOutside(target, e);
                        }
                        var parent_11 = target.parent;
                        if (parent_11 instanceof EShapeBase) {
                            target = parent_11;
                        }
                        else {
                            break;
                        }
                    }
                });
                downeds.clear();
                return true;
            }
            return false;
        };
        DDiagramCanvas.prototype.update = function () {
            var actionables = this._actionables;
            if (0 < actionables.length) {
                var effect = -1;
                var time = Date.now();
                for (var i = 0, imax = actionables.length; i < imax; ++i) {
                    var actionable = actionables[i];
                    actionable.update(time);
                    var runtime = actionable.runtime;
                    if (runtime) {
                        var runtimeEffect = runtime.effect;
                        if (time < runtimeEffect) {
                            effect = effect < 0 ? runtimeEffect : Math.min(effect, runtimeEffect);
                        }
                    }
                }
                if (0 <= effect) {
                    window.setTimeout(this._updateBound, effect - Date.now());
                }
            }
        };
        DDiagramCanvas.prototype.onRender = function (renderer) {
            var actionables = this._actionables;
            if (0 < actionables.length) {
                var effect = -1;
                var time = Date.now();
                for (var i = 0, imax = actionables.length; i < imax; ++i) {
                    var actionable = actionables[i];
                    actionable.onRender(time, renderer);
                    var runtime = actionable.runtime;
                    if (runtime) {
                        var runtimeEffect = runtime.effect;
                        if (time < runtimeEffect) {
                            effect = effect < 0 ? runtimeEffect : Math.min(effect, runtimeEffect);
                        }
                    }
                }
                if (0 <= effect) {
                    window.setTimeout(this._updateBound, effect - Date.now());
                }
            }
        };
        DDiagramCanvas.prototype.getType = function () {
            return "DDiagramCanvas";
        };
        return DDiagramCanvas;
    }(DDiagramCanvasBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramDataPrivateImpl = /** @class */ (function () {
        function DDiagramDataPrivateImpl(diagram) {
            this._diagram = diagram;
        }
        Object.defineProperty(DDiagramDataPrivateImpl.prototype, "ids", {
            get: function () {
                var canvas = this._diagram.canvas;
                if (canvas != null) {
                    return canvas.data.private.ids;
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        DDiagramDataPrivateImpl.prototype.set = function (id, value, time, state, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.set(id, value, time, state, from, to);
            }
            return false;
        };
        DDiagramDataPrivateImpl.prototype.toDirty = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.toDirty(id);
            }
            return false;
        };
        DDiagramDataPrivateImpl.prototype.each = function (iteratee) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.each(iteratee);
            }
            return null;
        };
        return DDiagramDataPrivateImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramDataProtectedImpl = /** @class */ (function () {
        function DDiagramDataProtectedImpl(diagram) {
            this._diagram = diagram;
        }
        Object.defineProperty(DDiagramDataProtectedImpl.prototype, "ids", {
            get: function () {
                var canvas = this._diagram.canvas;
                if (canvas != null) {
                    return canvas.data.protected.ids;
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        DDiagramDataProtectedImpl.prototype.set = function (id, value, time, state, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.set(id, value, time, state, from, to);
            }
            return false;
        };
        DDiagramDataProtectedImpl.prototype.toDirty = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.toDirty(id);
            }
            return false;
        };
        DDiagramDataProtectedImpl.prototype.each = function (iteratee) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.each(iteratee);
            }
            return null;
        };
        return DDiagramDataProtectedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramDataRemoteImpl = /** @class */ (function () {
        function DDiagramDataRemoteImpl(options) {
            this._controller = options && options.controller;
        }
        DDiagramDataRemoteImpl.prototype.set = function (id, value) {
            var controller = this._controller;
            if (controller) {
                controller.write(id, value);
                return true;
            }
            return false;
        };
        return DDiagramDataRemoteImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramDataExtendedImpl = /** @class */ (function () {
        function DDiagramDataExtendedImpl(diagram) {
            this._diagram = diagram;
        }
        Object.defineProperty(DDiagramDataExtendedImpl.prototype, "ids", {
            get: function () {
                var canvas = this._diagram.canvas;
                if (canvas != null) {
                    return canvas.data.extended.ids;
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        DDiagramDataExtendedImpl.prototype.set = function (id, value, time, state, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.set(id, value, time, state, from, to);
            }
            return false;
        };
        DDiagramDataExtendedImpl.prototype.toDirty = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.toDirty(id);
            }
            return false;
        };
        DDiagramDataExtendedImpl.prototype.each = function (iteratee) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.each(iteratee);
            }
            return null;
        };
        return DDiagramDataExtendedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A data helper class for diagrams.
     */
    var DDiagramDataImpl = /** @class */ (function () {
        function DDiagramDataImpl(diagram, options) {
            this._diagram = diagram;
            this._mapper = (options && options.mapper) || null;
            this._remote = new DDiagramDataRemoteImpl(options && options.remote);
            this._private = new DDiagramDataPrivateImpl(diagram);
            this._protected = new DDiagramDataProtectedImpl(diagram);
            this._extended = new DDiagramDataExtendedImpl(diagram);
        }
        DDiagramDataImpl.prototype.update = function () {
            // DO NOTHING
        };
        Object.defineProperty(DDiagramDataImpl.prototype, "mapper", {
            get: function () {
                return this._mapper;
            },
            set: function (mapper) {
                this._mapper = mapper;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "remote", {
            get: function () {
                return this._remote;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "private", {
            get: function () {
                return this._private;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "protected", {
            get: function () {
                return this._protected;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "extended", {
            get: function () {
                return this._extended;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramDataImpl.prototype, "ids", {
            get: function () {
                var canvas = this._diagram.canvas;
                if (canvas) {
                    return canvas.data.ids;
                }
                return [];
            },
            enumerable: false,
            configurable: true
        });
        DDiagramDataImpl.prototype.each = function (iteratee) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.each(iteratee);
            }
            return null;
        };
        DDiagramDataImpl.prototype.set = function (id, value, time, state, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.set(id, value, time, state, from, to);
            }
            return false;
        };
        DDiagramDataImpl.prototype.get = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.get(id);
            }
            return null;
        };
        DDiagramDataImpl.prototype.clear = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.clear(id);
            }
            return false;
        };
        DDiagramDataImpl.prototype.toDirty = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.toDirty(id);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setAll = function (id, values, times, states, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setAll(id, values, times, states, from, to);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setValue = function (id, value) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setValue(id, value);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setValues = function (id, values) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setValues(id, values);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setTime = function (id, time) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setTime(id, time);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setTimes = function (id, times) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setTimes(id, times);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setState = function (id, state) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setState(id, state);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setStates = function (id, states) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setStates(id, states);
            }
            return false;
        };
        DDiagramDataImpl.prototype.setRange = function (id, from, to) {
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setRange(id, from, to);
            }
            return false;
        };
        return DDiagramDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramEditorThumbnail = /** @class */ (function () {
        function DDiagramEditorThumbnail(snapshot, theme, options) {
            this._snapshot = snapshot;
            this._isEnabled = this.toIsEnabled(theme, options);
            this._options = this.toCreateAsUrlOptions(theme, options);
        }
        DDiagramEditorThumbnail.prototype.toIsEnabled = function (theme, options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : theme.isThumbnailEnabled();
        };
        DDiagramEditorThumbnail.prototype.toSize = function (theme, options) {
            return options !== undefined ? options : theme.getThumbnailSize();
        };
        DDiagramEditorThumbnail.prototype.toCleanup = function (theme, cleanup) {
            var _a, _b;
            if (cleanup == null || cleanup === true) {
                return {
                    snap: true,
                    background: true
                };
            }
            else if (cleanup === false) {
                return {
                    snap: false,
                    background: false
                };
            }
            return {
                snap: (_a = cleanup.snap) !== null && _a !== void 0 ? _a : true,
                background: (_b = cleanup.background) !== null && _b !== void 0 ? _b : true
            };
        };
        DDiagramEditorThumbnail.prototype.toCreateAsUrlOptions = function (theme, options) {
            return {
                size: this.toSize(theme, options === null || options === void 0 ? void 0 : options.size),
                cleanup: this.toCleanup(theme, options === null || options === void 0 ? void 0 : options.cleanup)
            };
        };
        Object.defineProperty(DDiagramEditorThumbnail.prototype, "enable", {
            get: function () {
                return this._isEnabled;
            },
            set: function (enable) {
                this._isEnabled = enable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramEditorThumbnail.prototype, "size", {
            get: function () {
                return this._options.size;
            },
            set: function (size) {
                this._options.size = size;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramEditorThumbnail.prototype, "cleanup", {
            get: function () {
                return this._options.cleanup;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramEditorThumbnail.prototype.serialize = function () {
            if (this._isEnabled) {
                return this._snapshot.createAsUrl(this._options);
            }
        };
        return DDiagramEditorThumbnail;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagramEditor = /** @class */ (function (_super) {
        __extends(DDiagramEditor, _super);
        function DDiagramEditor(options) {
            var _this = _super.call(this, options) || this;
            _this._isChanged = false;
            _this._isChanged = false;
            var commands = DControllers.getCommandController();
            commands.on("dirty", function () {
                if (_this._isChanged !== true) {
                    _this._isChanged = true;
                    _this.emit("change", _this);
                }
            });
            var theme = _this.theme;
            _this._snapper = new ESnapper(_this, theme, options === null || options === void 0 ? void 0 : options.snapper);
            _this._thumbnail = new DDiagramEditorThumbnail(_this._snapshot, theme, options === null || options === void 0 ? void 0 : options.thumbnail);
            return _this;
        }
        Object.defineProperty(DDiagramEditor.prototype, "thumbnail", {
            get: function () {
                return this._thumbnail;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DDiagramEditor.prototype, "snapper", {
            get: function () {
                return this._snapper;
            },
            enumerable: false,
            configurable: true
        });
        DDiagramEditor.prototype.toMode = function (options) {
            if (options === null || options === void 0 ? void 0 : options.mapping) {
                return EShapeResourceManagerDeserializationMode.EDITOR_DATA_MAPPED;
            }
            return EShapeResourceManagerDeserializationMode.EDITOR;
        };
        DDiagramEditor.prototype.newCanvas = function (serialized) {
            return new DDiagramCanvasEditor(this.toCanvasOptions(serialized));
        };
        DDiagramEditor.prototype.toCanvasOptions = function (serialized) {
            var options = this.toCanvasBaseOptions(serialized);
            // Snapper
            var snapper = this._snapper;
            var snap = options.snap;
            if (snap == null) {
                options.snap = {
                    controller: snapper
                };
            }
            else if (snap.controller == null) {
                snap.controller = snapper;
            }
            return options;
        };
        DDiagramEditor.prototype.serialize = function () {
            var canvas = this.canvas;
            var serialized = this._serialized;
            if (canvas != null && serialized != null) {
                this.emit("serializing", canvas, this);
                try {
                    var result = canvas.serialize(serialized.id, this._thumbnail);
                    this.emit("serialized", canvas, null, this);
                    return result;
                }
                catch (e) {
                    this.emit("serialized", canvas, "exception", this);
                    return null;
                }
            }
            return null;
        };
        DDiagramEditor.prototype.save = function () {
            var _this = this;
            var serialized = this.serialize();
            if (serialized != null) {
                var controller = this._controller;
                if (controller) {
                    var simple = DDiagrams.toSimple(serialized);
                    this.emit("saving", simple, this);
                    return controller.save(simple).then(function (newId) {
                        _this._isChanged = false;
                        serialized.id = newId;
                        _this._serialized = serialized;
                        _this.emit("change", _this);
                        _this.emit("saved", null, _this);
                    }, function (reason) {
                        _this.emit("saved", reason, _this);
                    });
                }
                else {
                    this.emit("saved", "no-controller", this);
                    return Promise.reject();
                }
            }
            this.emit("saved", null, this);
            return Promise.resolve();
        };
        DDiagramEditor.prototype.saveAs = function (name) {
            var _this = this;
            var serialized = this.serialize();
            if (serialized != null) {
                var controller = this._controller;
                if (controller) {
                    serialized.id = undefined;
                    serialized.name = name;
                    var simple = DDiagrams.toSimple(serialized);
                    this.emit("saving", simple, this);
                    return controller.save(simple).then(function (newId) {
                        _this._isChanged = false;
                        serialized.id = newId;
                        _this._serialized = serialized;
                        var canvas = _this.canvas;
                        if (canvas != null) {
                            canvas.name = name;
                        }
                        _this.emit("change", _this);
                        _this.emit("saved", null, _this);
                    }, function (reason) {
                        _this.emit("saved", reason, _this);
                    });
                }
                else {
                    this.emit("saved", "no-controller", this);
                    return Promise.reject("no-controller");
                }
            }
            this.emit("saved", null, this);
            return Promise.resolve();
        };
        DDiagramEditor.prototype.delete = function () {
            var _this = this;
            var serialized = this._serialized;
            if (serialized && serialized.id != null) {
                var controller = this._controller;
                if (controller) {
                    this.emit("deleting", this);
                    return controller.delete(serialized.id).then(function () {
                        var result = _this.set(null);
                        _this.emit("deleted", null, _this);
                        return result;
                    }, function (reason) {
                        _this.emit("deleted", reason, _this);
                        return Promise.reject(reason);
                    });
                }
                else {
                    this.emit("deleted", "no-controller", this);
                    return Promise.reject("no-controller");
                }
            }
            this.set(null);
            this.emit("deleted", null, this);
            return Promise.resolve(null);
        };
        DDiagramEditor.prototype.create = function (name, width, height) {
            return this.set({
                version: DDiagramSerializedVersion,
                id: undefined,
                name: name,
                width: width,
                height: height,
                resources: [],
                data: [],
                layers: [["Default layer"]],
                items: [],
                snap: undefined
            });
        };
        DDiagramEditor.prototype.onSet = function (serialized, canvas) {
            _super.prototype.onSet.call(this, serialized, canvas);
            // Snap settings
            var snap = serialized.snap;
            var snapper = this._snapper;
            if (snap != null) {
                snapper.deserialize(snap);
            }
            else {
                snapper.reset();
            }
            if (this._isAmbient) {
                snapper.target.visible = false;
                snapper.grid.visible = false;
            }
            // Reset the isChanged flag
            this._isChanged = false;
            // Done
            this.emit("change", this);
        };
        DDiagramEditor.prototype.onUnset = function () {
            _super.prototype.onUnset.call(this);
            this._isChanged = false;
            this.emit("change", this);
        };
        DDiagramEditor.prototype.open = function (id) {
            var _this = this;
            var controller = this._controller;
            if (controller) {
                this.emit("opening", this);
                return controller.get(id).then(function (serialized) {
                    var result = _this.set(DDiagrams.toSerialized(serialized));
                    _this.emit("opened", null, _this);
                    return result;
                }, function (reason) {
                    _this.emit("opened", reason, _this);
                    return Promise.reject(reason);
                });
            }
            this.emit("opened", "no-controller", this);
            return Promise.reject("no-controller");
        };
        DDiagramEditor.prototype.close = function () {
            return this.set(null);
        };
        DDiagramEditor.prototype.isChanged = function () {
            return this._isChanged || this.isNew();
        };
        DDiagramEditor.prototype.isNew = function () {
            var serialized = this._serialized;
            if (serialized != null) {
                return serialized.id == null;
            }
            return false;
        };
        DDiagramEditor.prototype.getName = function () {
            var serialized = this._serialized;
            if (serialized != null) {
                return serialized.name;
            }
            return null;
        };
        DDiagramEditor.prototype.getType = function () {
            return "DDiagramEditor";
        };
        return DDiagramEditor;
    }(DDiagramBase));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A shape helper class for diagrams.
     */
    var DDiagramShape = /** @class */ (function (_super) {
        __extends(DDiagramShape, _super);
        function DDiagramShape(diagram) {
            var _this = _super.call(this) || this;
            _this._diagram = diagram;
            _this._updateBound = function () {
                DApplications.update(diagram);
            };
            return _this;
        }
        DDiagramShape.prototype.update = function () {
            var canvas = this._diagram.canvas;
            if (canvas) {
                canvas.update();
            }
        };
        DDiagramShape.prototype.onRender = function (renderer) {
            var canvas = this._diagram.canvas;
            if (canvas) {
                canvas.onRender(renderer);
            }
        };
        DDiagramShape.prototype.get = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas) {
                return canvas.shape.get(id);
            }
            return null;
        };
        DDiagramShape.prototype.getAll = function (id) {
            var canvas = this._diagram.canvas;
            if (canvas) {
                return canvas.shape.getAll(id);
            }
            return [];
        };
        DDiagramShape.prototype.each = function (iteratee, reverse) {
            if (reverse === void 0) { reverse = false; }
            var canvas = this._diagram.canvas;
            if (canvas != null) {
                var layers = canvas.layer.children;
                if (!reverse) {
                    for (var i = 0, imax = layers.length; i < imax; ++i) {
                        var layer = layers[i];
                        var children = layer.children;
                        for (var j = 0, jmax = children.length; j < jmax; ++j) {
                            var child = children[j];
                            if (iteratee(child) === false) {
                                return child;
                            }
                        }
                    }
                }
                else {
                    for (var i = layers.length - 1; 0 <= i; --i) {
                        var layer = layers[i];
                        var children = layer.children;
                        for (var j = children.length - 1; 0 <= j; --j) {
                            var child = children[j];
                            if (iteratee(child) === false) {
                                return child;
                            }
                        }
                    }
                }
            }
            return null;
        };
        return DDiagramShape;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDiagram = /** @class */ (function (_super) {
        __extends(DDiagram, _super);
        function DDiagram(options) {
            var _this = _super.call(this, options) || this;
            // Event handlers
            _this.on(UtilPointerEvent.move, function (e) {
                _this.onShapeMove(e);
            });
            _this.on(UtilPointerEvent.up, function (e) {
                _this.onShapeUp(e);
            });
            _this.on(UtilPointerEvent.upoutside, function (e) {
                _this.onShapeCancel(e);
            });
            _this.on(UtilPointerEvent.cancel, function (e) {
                _this.onShapeCancel(e);
            });
            _this.on(UtilPointerEvent.tap, function (e) {
                _this.onShapeClick(e);
            });
            _this.on(UtilPointerEvent.righttap, function (e) {
                _this.onShapeRightClick(e);
            });
            _this.on(UtilPointerEvent.rightdown, function (e) {
                _this.onShapeRightDown(e);
            });
            _this.on(UtilPointerEvent.rightup, function (e) {
                _this.onShapeRightUp(e);
            });
            _this.on(UtilPointerEvent.rightupoutside, function (e) {
                _this.onShapeRightCancel(e);
            });
            // Data
            var data = new DDiagramDataImpl(_this, options && (options.data || options.tag));
            _this.data = data;
            _this.tag = data;
            // Shape
            _this.shape = new DDiagramShape(_this);
            return _this;
        }
        DDiagram.prototype.initLayer = function (canvas, shapes, mapper) {
            return _super.prototype.initLayer.call(this, canvas, shapes, mapper || this.data.mapper);
        };
        DDiagram.prototype.toMode = function (options) {
            return EShapeResourceManagerDeserializationMode.VIEWER;
        };
        DDiagram.prototype.newCanvas = function (serialized) {
            return new DDiagramCanvas(this.toCanvasOptions(serialized));
        };
        DDiagram.prototype.toCanvasOptions = function (serialized) {
            return this.toCanvasBaseOptions(serialized);
        };
        DDiagram.prototype.onDown = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                _super.prototype.onDown.call(this, e, canvas.onShapeDown(e));
            }
            else {
                _super.prototype.onDown.call(this, e);
            }
        };
        DDiagram.prototype.onShapeMove = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeMove(e);
                }
            }
        };
        DDiagram.prototype.onShapeUp = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeUp(e);
                }
            }
        };
        DDiagram.prototype.onShapeCancel = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeCancel(e);
                }
            }
        };
        DDiagram.prototype.onShapeClick = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeClick(e);
                }
            }
        };
        DDiagram.prototype.onShapeRightClick = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightClick(e);
                }
            }
        };
        DDiagram.prototype.onShapeRightDown = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                canvas.onShapeRightDown(e);
            }
        };
        DDiagram.prototype.onShapeRightUp = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightUp(e);
                }
            }
        };
        DDiagram.prototype.onShapeRightCancel = function (e) {
            var canvas = this.canvas;
            if (canvas) {
                var target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightCancel(e);
                }
            }
        };
        DDiagram.prototype.onDblClick = function (e, manager) {
            var canvas = this.canvas;
            if (canvas) {
                return _super.prototype.onDblClick.call(this, e, manager, canvas.onShapeDblClick(e, manager));
            }
            else {
                return _super.prototype.onDblClick.call(this, e, manager);
            }
        };
        DDiagram.prototype.render = function (renderer) {
            this.shape.onRender(renderer);
            _super.prototype.render.call(this, renderer);
        };
        DDiagram.prototype.getType = function () {
            return "DDiagram";
        };
        return DDiagram;
    }(DDiagramBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmMessage = /** @class */ (function (_super) {
        __extends(DDialogConfirmMessage, _super);
        function DDialogConfirmMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmMessage.prototype.getType = function () {
            return "DDialogConfirmMessage";
        };
        return DDialogConfirmMessage;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirm = /** @class */ (function (_super) {
        __extends(DDialogConfirm, _super);
        function DDialogConfirm() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirm.prototype.newContentChildren = function (theme, options) {
            var result = _super.prototype.newContentChildren.call(this, theme, options);
            result.push(this.message);
            return result;
        };
        DDialogConfirm.prototype.toMessage = function (theme, options) {
            var message = options === null || options === void 0 ? void 0 : options.message;
            if (message != null) {
                if (isString(message) || isFunction(message)) {
                    return this.newMessage(this.toMessageOptions(message));
                }
                else if (message instanceof DBase) {
                    return message;
                }
                else {
                    return this.newMessage(this.toMessageOptionsMerged(message, theme.getMessage()));
                }
            }
            return this.newMessage(this.toMessageOptions(theme.getMessage()));
        };
        DDialogConfirm.prototype.toMessageOptionsMerged = function (options, message) {
            var text = options.text;
            if (text == null) {
                text = {};
                options.text = text;
            }
            if (text.value === undefined) {
                text.value = message;
            }
            return options;
        };
        DDialogConfirm.prototype.toMessageOptions = function (message) {
            return {
                text: {
                    value: message
                }
            };
        };
        DDialogConfirm.prototype.newMessage = function (options) {
            return new DDialogConfirmMessage(options);
        };
        Object.defineProperty(DDialogConfirm.prototype, "message", {
            get: function () {
                var result = this._message;
                if (result == null) {
                    result = this.toMessage(this.theme, this._options);
                    this._message = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DDialogConfirm.prototype.getResolvedValue = function () {
            return undefined;
        };
        DDialogConfirm.prototype.getType = function () {
            return "DDialogConfirm";
        };
        return DDialogConfirm;
    }(DDialogLayered));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmDelete = /** @class */ (function (_super) {
        __extends(DDialogConfirmDelete, _super);
        function DDialogConfirmDelete() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmDelete.prototype.getType = function () {
            return "DDialogConfirmDelete";
        };
        return DDialogConfirmDelete;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogConfirmDiscard = /** @class */ (function (_super) {
        __extends(DDialogConfirmDiscard, _super);
        function DDialogConfirmDiscard() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogConfirmDiscard.prototype.getType = function () {
            return "DDialogConfirmDiscard";
        };
        return DDialogConfirmDiscard;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogMessage = /** @class */ (function (_super) {
        __extends(DDialogMessage, _super);
        function DDialogMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogMessage.prototype.getType = function () {
            return "DDialogMessage";
        };
        return DDialogMessage;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogProcessingMessage = /** @class */ (function (_super) {
        __extends(DDialogProcessingMessage, _super);
        function DDialogProcessingMessage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogProcessingMessage.prototype.getType = function () {
            return "DDialogProcessingMessage";
        };
        return DDialogProcessingMessage;
    }(DDialogConfirmMessage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogProcessing = /** @class */ (function (_super) {
        __extends(DDialogProcessing, _super);
        function DDialogProcessing(options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            _this._isDone = true;
            _this._startTime = 0;
            var delay = options === null || options === void 0 ? void 0 : options.delay;
            _this._delayDone = (_a = delay === null || delay === void 0 ? void 0 : delay.done) !== null && _a !== void 0 ? _a : _this.theme.getDoneDelay();
            var delayClose = delay === null || delay === void 0 ? void 0 : delay.close;
            _this._delayClose = delayClose !== undefined ? delayClose : _this.theme.getCloseDelay();
            _this._messageText = _this.message.text;
            return _this;
        }
        DDialogProcessing.prototype.newMessage = function (options) {
            return new DDialogProcessingMessage(options);
        };
        DDialogProcessing.prototype.onOpen = function () {
            this._isDone = false;
            this._startTime = Date.now();
            var timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
            var closeTimeoutId = this._closeTimeoutId;
            if (closeTimeoutId != null) {
                clearTimeout(closeTimeoutId);
            }
            var message = this.message;
            message.text = this._messageText;
            message.state.removeAll(DBaseState.SUCCEEDED, DBaseState.FAILED);
            var footer = this._footer;
            if (footer != null) {
                footer.hide();
            }
            _super.prototype.onOpen.call(this);
        };
        DDialogProcessing.prototype.onDone = function (delay) {
            var _this = this;
            if (delay != null) {
                this._closeTimeoutId = window.setTimeout(function () {
                    _this.close();
                }, delay);
            }
            else {
                this.close();
            }
        };
        DDialogProcessing.prototype.onResolved = function (message) {
            if (message != null) {
                this.message.text = message;
            }
            this.message.state.set(DBaseState.SUCCEEDED, DBaseState.FAILED);
            var delayClose = this._delayClose;
            if (delayClose != null) {
                this.onDone(delayClose);
            }
            else {
                var footer = this._footer;
                if (footer != null) {
                    footer.show();
                }
                else {
                    this.close();
                }
            }
        };
        DDialogProcessing.prototype.onRejected = function (message) {
            if (message != null) {
                this.message.text = message;
            }
            this.message.state.set(DBaseState.FAILED, DBaseState.SUCCEEDED);
            var footer = this._footer;
            if (footer != null) {
                footer.show();
            }
            else {
                this.onDone(this._delayClose);
            }
        };
        DDialogProcessing.prototype.resolve = function (message) {
            var _this = this;
            if (!this._isDone) {
                this._isDone = true;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onResolved(message);
                    }, delay);
                }
                else {
                    this.onResolved(message);
                }
            }
        };
        DDialogProcessing.prototype.reject = function (message) {
            var _this = this;
            if (!this._isDone) {
                this._isDone = true;
                var elapsedTime = Date.now() - this._startTime;
                var delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(function () {
                        _this._timeoutId = undefined;
                        _this.onRejected(message);
                    }, delay);
                }
                else {
                    this.onRejected(message);
                }
            }
        };
        DDialogProcessing.prototype.onCloseOn = function () {
            if (this._isDone) {
                _super.prototype.onCloseOn.call(this);
            }
        };
        DDialogProcessing.prototype.getType = function () {
            return "DDialogProcessing";
        };
        return DDialogProcessing;
    }(DDialogConfirm));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDialogSaveAs = /** @class */ (function (_super) {
        __extends(DDialogSaveAs, _super);
        function DDialogSaveAs() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDialogSaveAs.prototype.onOpen = function () {
            var name = DControllers.getDocumentController().getName();
            if (name != null) {
                this.input.value = name;
            }
            _super.prototype.onOpen.call(this);
        };
        DDialogSaveAs.prototype.onOk = function (value) {
            _super.prototype.onOk.call(this, value);
            var commandController = DControllers.getCommandController();
            if (isString(value)) {
                commandController.push(new DCommandSaveAs(value));
            }
            else {
                value.then(function (resolved) {
                    commandController.push(new DCommandSaveAs(resolved));
                });
            }
        };
        DDialogSaveAs.prototype.getType = function () {
            return "DDialogSaveAs";
        };
        return DDialogSaveAs;
    }(DDialogInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuContext = /** @class */ (function () {
        function DMenuContext(owner) {
            this._owner = owner;
            this._closeables = [];
        }
        DMenuContext.prototype.indexOf = function (target) {
            return this._closeables.indexOf(target);
        };
        DMenuContext.prototype.close = function (index) {
            var closeables = this._closeables;
            var imin = Math.max(0, index);
            for (var i = closeables.length - 1; imin <= i; --i) {
                closeables[i].close();
            }
        };
        DMenuContext.prototype.add = function (closeable) {
            this._closeables.push(closeable);
        };
        DMenuContext.prototype.trim = function (closeable) {
            this.close(this.indexOf(closeable) + 1);
        };
        DMenuContext.prototype.remove = function (closeable) {
            var index = this.indexOf(closeable);
            if (0 <= index) {
                this.close(index + 1);
                this._closeables.splice(index, 1);
            }
        };
        return DMenuContext;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenu = /** @class */ (function (_super) {
        __extends(DMenu, _super);
        function DMenu() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenu.prototype.init = function (options) {
            var _this = this;
            var _a, _b, _c;
            _super.prototype.init.call(this, options);
            this._onPrerenderBound = function () {
                _this.onPrerender();
            };
            this._align = toEnum((_a = options === null || options === void 0 ? void 0 : options.align) !== null && _a !== void 0 ? _a : UtilAttachAlign.BOTTOM, UtilAttachAlign);
            this._fit = (_b = options === null || options === void 0 ? void 0 : options.fit) !== null && _b !== void 0 ? _b : false;
            this._sticky = (_c = options === null || options === void 0 ? void 0 : options.sticky) !== null && _c !== void 0 ? _c : false;
            this._sub = false;
            this._owner = null;
            this._context = null;
            this.visible = false;
            // Event handlers
            UtilClickOutside.apply(this, function () {
                _this.close();
            });
            this.on("select", function () {
                _this.close();
            });
            // Items
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items) {
                DMenus.newItems(this, items, this._sticky);
            }
            // Overlay
            this._overlay = new UtilOverlay(options);
        };
        DMenu.prototype.findItem = function (value) {
            var children = this.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItem && child.value === value) {
                    return child;
                }
            }
            return null;
        };
        DMenu.prototype.getType = function () {
            return "DMenu";
        };
        DMenu.prototype.getContext = function () {
            return this._context;
        };
        DMenu.prototype.getCloseable = function () {
            return this;
        };
        DMenu.prototype.open = function (owner, closeable, context) {
            if (this.isHidden()) {
                var layer = this._overlay.pick(this);
                this._owner = owner;
                // States
                var children = this.children;
                for (var i = 0, imax = children.length; i < imax; ++i) {
                    var child = children[i];
                    if (child instanceof DBase) {
                        child.state.removeAll(DBaseState.FOCUSED, DBaseState.HOVERED);
                    }
                }
                // Position & size
                var renderer = layer.renderer;
                var onPrerenderBound = this._onPrerenderBound;
                if (this._sticky) {
                    renderer.on("prerender", onPrerenderBound);
                }
                else {
                    renderer.once("prerender", onPrerenderBound);
                }
                if (this._fit) {
                    var bounds = owner.getBounds();
                    if (bounds != null) {
                        this.width = bounds.width;
                    }
                }
                // Target
                this._sub = context != null;
                context = context || new DMenuContext(owner);
                if (closeable != null) {
                    context.trim(closeable);
                }
                context.add(this);
                this._context = context;
                // Stage
                layer.stage.addChild(this);
                // Focus
                this._focused = layer.getFocusController().get();
                this.focus();
                // Show
                _super.prototype.show.call(this);
                // Event
                this.emit("open", this);
            }
            return this;
        };
        DMenu.prototype.onPrerender = function () {
            var owner = this._owner;
            if (owner) {
                var bounds = owner.getBounds();
                if (bounds) {
                    if (this._fit) {
                        this.width = bounds.width;
                    }
                    var layer = this._overlay.picked;
                    if (layer) {
                        var theme = this.theme;
                        UtilAttach.attach(this, bounds, theme.getOffsetX(), theme.getOffsetY(), layer.width, layer.height, this._align);
                    }
                }
            }
        };
        DMenu.prototype.close = function () {
            if (this.isShown()) {
                // Remove from the context
                var context = this._context;
                if (context) {
                    context.remove(this);
                }
                // Remove the prerender event handler
                var layer = this._overlay.picked;
                if (layer) {
                    layer.renderer.off("prerender", this._onPrerenderBound);
                }
                // Forget the owner
                this._owner = null;
                // Restore the focus
                var focused = this._focused;
                if (focused != null) {
                    this._focused = null;
                    if (layer) {
                        var focusedLayer = DApplications.getLayer(focused);
                        if (focusedLayer != null && layer !== focusedLayer) {
                            focusedLayer.view.focus();
                        }
                        layer.getFocusController().focus(focused);
                    }
                    else {
                        this.blur(true);
                    }
                }
                else {
                    this.blur(true);
                }
                // Visibility
                _super.prototype.hide.call(this);
                // Remove from the tree
                var parent_1 = this.parent;
                if (parent_1) {
                    parent_1.removeChild(this);
                }
                // Emit the event
                this.emit("close", this);
            }
            return this;
        };
        DMenu.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusVertically(e, this, this._overlay);
            if (this.state.isActionable &&
                (UtilKeyboardEvent.isArrowLeftKey(e) || UtilKeyboardEvent.isCancelKey(e))) {
                this.close();
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenu.prototype.containsGlobalPoint = function (point) {
            return !this._sub;
        };
        return DMenu;
    }(DLayoutVertical));
    DMenus.setMenuCreator(function (options) { return new DMenu(options); });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dropdown base class.
     */
    var DDropdownBase = /** @class */ (function (_super) {
        __extends(DDropdownBase, _super);
        function DDropdownBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDropdownBase.prototype.onMenuSelect = function (value, item, menu) {
            this.emit("select", value, item, this);
        };
        DDropdownBase.prototype.onMenuClose = function (menu) {
            if (menu) {
                var onMenuSelectBound = this._onMenuSelectBound;
                if (onMenuSelectBound) {
                    menu.off("select", onMenuSelectBound);
                }
                var onMenuCloseBound = this._onMenuCloseBound;
                if (onMenuCloseBound) {
                    menu.off("close", onMenuCloseBound);
                }
            }
        };
        DDropdownBase.prototype.toMenu = function (theme, options) {
            var menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof DMenu) {
                return menu;
            }
            return new DMenu(this.toMenuOptions(theme, menu));
        };
        DDropdownBase.prototype.toMenuOptions = function (theme, options) {
            if (options) {
                if (options.fit == null) {
                    options.fit = true;
                }
                return options;
            }
            return {
                fit: true
            };
        };
        Object.defineProperty(DDropdownBase.prototype, "menu", {
            get: function () {
                var result = this._menu;
                if (result == null) {
                    result = this.toMenu(this.theme, this._options);
                    this._menu = result;
                }
                return result;
            },
            set: function (newMenu) {
                var oldMenu = this._menu;
                if (oldMenu != newMenu) {
                    this._menu = newMenu;
                    this.onMenuReplaced(newMenu, oldMenu);
                }
            },
            enumerable: false,
            configurable: true
        });
        DDropdownBase.prototype.onMenuReplaced = function (newMenu, oldMenu) {
            if (oldMenu != null) {
                this.onMenuClose(oldMenu);
            }
        };
        DDropdownBase.prototype.getType = function () {
            return "DDropdownBase";
        };
        DDropdownBase.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.onKeyDownArrowDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DDropdownBase.prototype.onKeyDownArrowDown = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.activate(e);
                return true;
            }
            return false;
        };
        DDropdownBase.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.open();
        };
        DDropdownBase.prototype.open = function () {
            var _this = this;
            var menu = this.menu;
            if (menu.isHidden()) {
                // In the case that the menu is created elsewhere,
                // the menu might be opened by other UI elements
                // and the `select` event might be triggered. In
                // that case, we are not supposed to catct that
                // `select` event. This is why the `select` event
                // handler is registered here. Instead of the
                // initialization time.
                var onMenuSelectBound = this._onMenuSelectBound;
                if (onMenuSelectBound == null) {
                    onMenuSelectBound = function (value, item, m) {
                        _this.onMenuSelect(value, item, m);
                    };
                    this._onMenuSelectBound = onMenuSelectBound;
                }
                var onMenuCloseBound = this._onMenuCloseBound;
                if (onMenuCloseBound == null) {
                    onMenuCloseBound = function () {
                        _this.onMenuClose(_this._menu);
                    };
                }
                menu.on("select", onMenuSelectBound);
                menu.on("close", onMenuCloseBound);
                menu.open(this);
                this.emit("open", menu, this);
            }
        };
        DDropdownBase.prototype.close = function () {
            this.menu.close();
        };
        return DDropdownBase;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DDropdown = /** @class */ (function (_super) {
        __extends(DDropdown, _super);
        function DDropdown() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DDropdown.prototype.getType = function () {
            return "DDropdown";
        };
        return DDropdown;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DExpandableHeader = /** @class */ (function (_super) {
        __extends(DExpandableHeader, _super);
        function DExpandableHeader(options) {
            var _this = _super.call(this, options) || this;
            _this.on(UtilPointerEvent.down, function (e) {
                if (_this.state.isActionable) {
                    _this.onSelect(e);
                }
            });
            return _this;
        }
        DExpandableHeader.prototype.onSelect = function (e) {
            this.emit("select", this);
        };
        DExpandableHeader.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DExpandableHeader.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onSelect(e);
                return true;
            }
            return false;
        };
        DExpandableHeader.prototype.getType = function () {
            return "DExpandableHeader";
        };
        return DExpandableHeader;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DExpandable = /** @class */ (function (_super) {
        __extends(DExpandable, _super);
        function DExpandable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DExpandable.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            // Header
            var theme = this.theme;
            var header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", function () {
                _this.toggle();
            });
            this.addChild(header);
            // Body
            var body = this.toBody(theme, options);
            this._body = body;
            this.addChild(body);
            //
            if (this.state.isActive) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        };
        DExpandable.prototype.toHeader = function (theme, options) {
            if (options && options.header) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        };
        DExpandable.prototype.newHeader = function (theme, options) {
            return new DExpandableHeader(options);
        };
        DExpandable.prototype.toBody = function (theme, options) {
            return options.body;
        };
        DExpandable.prototype.open = function () {
            this.state.isActive = true;
        };
        DExpandable.prototype.close = function () {
            this.state.isActive = false;
        };
        DExpandable.prototype.toggle = function () {
            this.state.isActive = !this.state.isActive;
        };
        DExpandable.prototype.onActivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        };
        DExpandable.prototype.onDeactivated = function () {
            var body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        };
        DExpandable.prototype.onStateChange = function (newState, oldState) {
            _super.prototype.onStateChange.call(this, newState, oldState);
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this.onActivated();
                }
            }
            else {
                if (oldState.isActive) {
                    this.onDeactivated();
                }
            }
        };
        DExpandable.prototype.getType = function () {
            return "DExpandable";
        };
        return DExpandable;
    }(DLayoutVertical));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputIntegerAndLabel = /** @class */ (function (_super) {
        __extends(DInputIntegerAndLabel, _super);
        function DInputIntegerAndLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputIntegerAndLabel.prototype.createInput = function (options) {
            return new DInputInteger(options);
        };
        return DInputIntegerAndLabel;
    }(DInputAndLabel));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DInputTextArea = /** @class */ (function (_super) {
        __extends(DInputTextArea, _super);
        function DInputTextArea() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DInputTextArea.prototype.newUtil = function () {
            return new UtilInputTextArea(this, this.newOperation(), this.theme, this._options);
        };
        DInputTextArea.prototype.getType = function () {
            return "DInputTextArea";
        };
        return DInputTextArea;
    }(DInput));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DListItemAmbient = /** @class */ (function (_super) {
        __extends(DListItemAmbient, _super);
        function DListItemAmbient() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DListItemAmbient.prototype.getType = function () {
            return "DListItemAmbient";
        };
        return DListItemAmbient;
    }(DListItem));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapCoordinateEPSG3857 = /** @class */ (function () {
        function DMapCoordinateEPSG3857(tileSize) {
            if (tileSize === void 0) { tileSize = 256; }
            this._tileSize = tileSize;
        }
        DMapCoordinateEPSG3857.prototype.getTileSize = function () {
            return this._tileSize;
        };
        /**
         * Converts the given (lon, lat) point in WGS84 to (x, y) in EPSG:900913.
         * The origin of the converted point (x, y) is at the middle-left corner.
         * The `meters` can be the same instance that is passed in as the `lonlat`.
         *
         * @param lonlat (lon, lat) point
         * @param meters (x, y) point in meters converted from the given lonlat.
         * @return (x, y) point in meters
         * @see https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/
         * @see https://qiita.com/MALORGIS/items/1a9114dd090e5b891bf7
         */
        DMapCoordinateEPSG3857.prototype.lonLatToMeters = function (lonlat, meters) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = (lonlat.x * C) / 180;
            meters.y = (Math.log(Math.tan(((90 + lonlat.y) * Math.PI) / 360)) * C) / Math.PI;
            return meters;
        };
        /**
         * The `lonlat` can be the same instance that is passed in as the `meters`.
         *
         * @param meters
         * @param lonlat
         */
        DMapCoordinateEPSG3857.prototype.metersToLonLat = function (meters, lonlat) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            lonlat.x = (meters.x / C) * 180;
            lonlat.y = (Math.atan(Math.exp((meters.y * Math.PI) / C)) * 360) / Math.PI - 90;
            return lonlat;
        };
        /**
         * Converts pixel coordinates in given zoom level of pyramid to EPSG:900913.
         * The origin of the `pixels` is the top-left corner.
         * The `meters` can be the same instance that is passed in as the `pixels`.
         */
        DMapCoordinateEPSG3857.prototype.pixelsToMeters = function (pixels, tz, tileSize, meters) {
            var R = this.toResolution(tz, tileSize);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = pixels.x * R - C;
            meters.y = C - pixels.y * R;
            return meters;
        };
        /**
         * Converts EPSG:900913 to pyramid pixel coordinates in given zoom level.
         * The origin of the pixels is the top-left corner.
         * The `pixels` can be the same instance that is passed in as the `meters`.
         */
        DMapCoordinateEPSG3857.prototype.metersToPixels = function (meters, tz, tileSize, pixels) {
            var R = this.toResolution(tz, tileSize);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            pixels.x = (meters.x + C) / R;
            pixels.y = (C - meters.y) / R;
            return pixels;
        };
        /**
         * Returns a tile covering region in given pixel coordinates.
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `pixels`.
         */
        DMapCoordinateEPSG3857.prototype.pixelsToTile = function (pixels, tileSize, tile) {
            tile.x = Math.ceil(pixels.x / tileSize) - 1;
            tile.y = Math.ceil(pixels.y / tileSize) - 1;
            return tile;
        };
        /**
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `meters`.
         */
        DMapCoordinateEPSG3857.prototype.metersToTile = function (meters, tz, tile) {
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            var Z = 1 << tz;
            tile.x = Math.ceil(0.5 * (meters.x / C + 1) * Z) - 1;
            tile.y = Math.ceil(0.5 * (1 - meters.y / C) * Z) - 1;
            return tile;
        };
        DMapCoordinateEPSG3857.prototype.lonLatToTile = function (lonlat, tz, tile) {
            return this.metersToTile(this.lonLatToMeters(lonlat, tile), tz, tile);
        };
        DMapCoordinateEPSG3857.prototype.lonLatToPixels = function (lonlat, tz, tileSize, pixels) {
            return this.metersToPixels(this.lonLatToMeters(lonlat, pixels), tz, tileSize, pixels);
        };
        DMapCoordinateEPSG3857.prototype.pixelsToLonLat = function (pixels, tz, tileSize, lonlat) {
            return this.metersToLonLat(this.pixelsToMeters(pixels, tz, tileSize, lonlat), lonlat);
        };
        /**
         * The `pixels` can be the same instance that is passed in as the `tile`.
         */
        DMapCoordinateEPSG3857.prototype.tileToPixels = function (tile, tileSize, pixels) {
            pixels.x = tile.x * tileSize;
            pixels.y = tile.y * tileSize;
            return pixels;
        };
        /**
         * Returns bounds of the given tile in EPSG:900913 coordinates
         * The `meters` can be the same instance that is passed in as the `tile`.
         */
        DMapCoordinateEPSG3857.prototype.tileToMeters = function (tile, tz, meters) {
            var R = this.toResolutionMeter(tz);
            var C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = tile.x * R + C;
            meters.y = C - tile.y * R;
            return meters;
        };
        DMapCoordinateEPSG3857.prototype.toResolutionMeter = function (tz) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (1 << tz);
        };
        DMapCoordinateEPSG3857.prototype.toResolution = function (tz, tileSize) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (tileSize << tz);
        };
        DMapCoordinateEPSG3857.prototype.toTileCount = function (tz) {
            return 1 << tz;
        };
        DMapCoordinateEPSG3857.prototype.toTileCode = function (tz, tx, ty) {
            return (tx << tz) + ty;
        };
        DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF = Math.PI * 6378137 /* Approximate earth radius in meter */;
        return DMapCoordinateEPSG3857;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapCoordinates = /** @class */ (function () {
        function DMapCoordinates() {
        }
        Object.defineProperty(DMapCoordinates, "DEFAULT", {
            get: function () {
                if (this._default == null) {
                    this._default = new DMapCoordinateEPSG3857();
                }
                return this._default;
            },
            enumerable: false,
            configurable: true
        });
        return DMapCoordinates;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTile = /** @class */ (function () {
        function DMapTile(parent, tx, ty, px, py, scale) {
            this.tx = tx;
            this.ty = ty;
            var sprite = new pixi_js.Sprite(pixi_js.Texture.EMPTY);
            sprite.parent = parent;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
            this._sprite = sprite;
        }
        DMapTile.prototype.load = function (url, onLoaded) {
            var texture = pixi_js.Texture.from(url, { resolution: 1 });
            this._sprite.texture = texture;
            if (texture.valid) {
                onLoaded();
            }
            else {
                texture.on("update", onLoaded);
            }
        };
        DMapTile.prototype.transform = function (px, py, scale) {
            var sprite = this._sprite;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
        };
        Object.defineProperty(DMapTile.prototype, "loaded", {
            get: function () {
                return this._sprite.texture.valid;
            },
            enumerable: false,
            configurable: true
        });
        DMapTile.prototype.render = function (renderer) {
            var sprite = this._sprite;
            sprite.updateTransform();
            sprite.render(renderer);
        };
        DMapTile.prototype.destroy = function () {
            var sprite = this._sprite;
            var texture = sprite.texture;
            var resource = texture.baseTexture.resource;
            var image = null;
            if (resource instanceof pixi_js.resources.BaseImageResource) {
                if (resource.source instanceof HTMLImageElement) {
                    image = resource.source;
                }
            }
            texture.destroy(true);
            sprite.destroy();
            if (image) {
                image.src = "";
            }
        };
        return DMapTile;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTilePlane = /** @class */ (function () {
        function DMapTilePlane(parent, builder, tz, mapping, coordinate, onLoaded) {
            var _this = this;
            this._parent = parent;
            this._builder = builder;
            this._onLoaded = onLoaded;
            this._isOnLoadedCalled = false;
            this._isOnLoadedAllowed = true;
            this._onLoadedBound = function () {
                _this.onLoaded();
            };
            this._tz = tz;
            this._lon0 = NaN;
            this._lat0 = NaN;
            this._lon1 = NaN;
            this._lat1 = NaN;
            this._tiles = new Map();
            this._renderTileBound = function (tile) {
                _this.renderTile(tile);
            };
            this._txmin = NaN;
            this._txmax = NaN;
            this._tymin = NaN;
            this._tymax = NaN;
            this._deleteTileBound = function (tile, tileCode, tiles) {
                _this.deleteTile(tile, tileCode, tiles);
            };
            this._destroyTileBound = function (tile) {
                _this.destroyTile(tile);
            };
            this._updateLoadingStateForEach = function (tile) {
                if (!tile.loaded) {
                    _this._isLoaded = false;
                }
            };
            this._tileCount = coordinate.toTileCount(tz);
            this._tileScaleRelative = 1 / this._tileCount;
            this._tileScale = mapping.scale * this._tileScaleRelative;
            this._tileSize = coordinate.getTileSize() * mapping.scale;
            this._mapping = mapping;
            this._coordinate = coordinate;
            this._isLoaded = true;
        }
        DMapTilePlane.prototype.newTile = function (tx, ty, px, py, scale) {
            return new DMapTile(this._parent, tx, ty, px, py, scale);
        };
        DMapTilePlane.prototype.renderTile = function (tile) {
            tile.render(this._renderer);
        };
        Object.defineProperty(DMapTilePlane.prototype, "tz", {
            get: function () {
                return this._tz;
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePlane.prototype.render = function (renderer) {
            this._renderer = renderer;
            this._tiles.forEach(this._renderTileBound);
        };
        DMapTilePlane.prototype.move = function (lon0, lat0, lon1, lat1) {
            var oldLon0 = this._lon0;
            var oldLat0 = this._lat0;
            var oldLon1 = this._lon1;
            var oldLat1 = this._lat1;
            if (oldLon0 !== lon0 || oldLat0 !== lat0 || oldLon1 !== lon1 || oldLat1 !== lat1) {
                this._lon0 = lon0;
                this._lat0 = lat0;
                this._lon1 = lon1;
                this._lat1 = lat1;
                var tz = this._tz;
                var coordinate = this._coordinate;
                var work = DMapTilePlane.WORK;
                work.set(lon0, lat0);
                coordinate.lonLatToTile(work, tz, work);
                var tx0 = work.x;
                var ty0 = work.y;
                work.set(lon1, lat1);
                coordinate.lonLatToTile(work, tz, work);
                var tx1 = work.x;
                var ty1 = work.y;
                var tileCount = this._tileCount;
                var txmin = Math.max(0, tx0);
                var txmax = Math.min(tileCount - 1, tx1);
                var tymin = Math.max(0, ty0);
                var tymax = Math.min(tileCount - 1, ty1);
                var dtxmin = txmin - this._txmin;
                var dtxmax = txmax - this._txmax;
                var dtymin = tymin - this._tymin;
                var dtymax = tymax - this._tymax;
                var isTxMinChanged = dtxmin !== dtxmin || dtxmin < 0 || 1 < dtxmin;
                var isTxMaxChanged = dtxmax !== dtxmax || 0 < dtxmax || dtxmax < -1;
                var isTyMinChanged = dtymin !== dtymin || dtymin < 0 || 1 < dtymin;
                var isTyMaxChanged = dtymax !== dtymax || 0 < dtymax || dtymax < -1;
                if (isTxMinChanged || isTxMaxChanged || isTyMinChanged || isTyMaxChanged) {
                    if (isTxMinChanged) {
                        this._txmin = txmin;
                    }
                    else {
                        txmin = this._txmin;
                    }
                    if (isTxMaxChanged) {
                        this._txmax = txmax;
                    }
                    else {
                        txmax = this._txmax;
                    }
                    if (isTyMinChanged) {
                        this._tymin = tymin;
                    }
                    else {
                        tymin = this._tymin;
                    }
                    if (isTyMaxChanged) {
                        this._tymax = tymax;
                    }
                    else {
                        tymax = this._tymax;
                    }
                    var tiles = this._tiles;
                    tiles.forEach(this._deleteTileBound);
                    var ctx = (txmin + txmax) >> 1;
                    var cty = (tymin + tymax) >> 1;
                    var ltx = Math.max(ctx - txmin, txmax - ctx);
                    var lty = Math.max(cty - tymin, tymax - cty);
                    var lt = Math.max(ltx, lty);
                    this.toOffset(work);
                    var offsetX = work.x;
                    var offsetY = work.y;
                    this._isOnLoadedCalled = false;
                    this._isOnLoadedAllowed = false;
                    this.loadTile(tz, ctx, cty, offsetX, offsetY, work);
                    for (var it = 1; it <= lt; ++it) {
                        var txa = ctx - it;
                        if (txmin <= txa) {
                            this.loadTilesY(tz, txa, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        var txb = ctx + it;
                        if (txb <= txmax) {
                            this.loadTilesY(tz, txb, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        var tya = cty - it;
                        if (tymin <= tya) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tya, offsetX, offsetY, work);
                        }
                        var tyb = cty + it;
                        if (tyb <= tymax) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tyb, offsetX, offsetY, work);
                        }
                    }
                    this._isOnLoadedAllowed = true;
                    if (this._isOnLoadedCalled) {
                        this.onLoaded();
                    }
                }
            }
        };
        DMapTilePlane.prototype.loadTilesX = function (tz, ctx, ltx, txmin, txmax, ty, ox, oy, work) {
            this.loadTile(tz, ctx, ty, ox, oy, work);
            for (var i = 1; i <= ltx; ++i) {
                var txa = ctx - i;
                if (txmin <= txa) {
                    this.loadTile(tz, txa, ty, ox, oy, work);
                }
                var txb = ctx + i;
                if (txb <= txmax) {
                    this.loadTile(tz, txb, ty, ox, oy, work);
                }
            }
        };
        DMapTilePlane.prototype.loadTilesY = function (tz, tx, cty, lty, tymin, tymax, ox, oy, work) {
            this.loadTile(tz, tx, cty, ox, oy, work);
            for (var i = 1; i <= lty; ++i) {
                var tya = cty - i;
                if (tymin <= tya) {
                    this.loadTile(tz, tx, tya, ox, oy, work);
                }
                var tyb = cty + i;
                if (tyb <= tymax) {
                    this.loadTile(tz, tx, tyb, ox, oy, work);
                }
            }
        };
        DMapTilePlane.prototype.loadTile = function (tz, tx, ty, ox, oy, work) {
            var coordinate = this._coordinate;
            var tileCode = coordinate.toTileCode(tz, tx, ty);
            var tiles = this._tiles;
            var tile = tiles.get(tileCode);
            if (tile == null) {
                this.toTilePosition(tx, ty, ox, oy, work);
                tile = this.newTile(tx, ty, work.x, work.y, this._tileScale);
                tiles.set(tileCode, tile);
                tile.load(this._builder(tz, tx, ty), this._onLoadedBound);
                this._isLoaded = false;
            }
        };
        DMapTilePlane.prototype.toTilePosition = function (tx, ty, ox, oy, result) {
            var tileSize = this._tileSize;
            var tileScaleRelative = this._tileScaleRelative;
            result.set(tx, ty);
            this._coordinate.tileToPixels(result, tileSize, result);
            result.set(result.x * tileScaleRelative + ox, result.y * tileScaleRelative + oy);
            return result;
        };
        DMapTilePlane.prototype.toOffset = function (result) {
            var parent = this._parent;
            var mapping = this._mapping;
            var tileSize = this._tileSize;
            result.set(-mapping.x * tileSize + parent.width * 0.5, -mapping.y * tileSize + parent.height * 0.5);
            return result;
        };
        DMapTilePlane.prototype.deleteTile = function (tile, tileCode, tiles) {
            var tx = tile.tx;
            var ty = tile.ty;
            if (tx < this._txmin || this._txmax < tx || ty < this._tymin || this._tymax < ty) {
                tiles.delete(tileCode);
                tile.destroy();
            }
        };
        DMapTilePlane.prototype.destroy = function () {
            var tiles = this._tiles;
            tiles.forEach(this._destroyTileBound);
            tiles.clear();
        };
        DMapTilePlane.prototype.destroyTile = function (tile) {
            tile.destroy();
        };
        DMapTilePlane.prototype.updateLoadingState = function () {
            this._isLoaded = true;
            this._tiles.forEach(this._updateLoadingStateForEach);
        };
        DMapTilePlane.prototype.onLoaded = function () {
            if (this._isOnLoadedAllowed) {
                this._onLoaded();
            }
            else {
                this._isOnLoadedCalled = true;
            }
        };
        Object.defineProperty(DMapTilePlane.prototype, "loaded", {
            get: function () {
                if (!this._isLoaded) {
                    this.updateLoadingState();
                }
                return this._isLoaded;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DMapTilePlane.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            set: function (mapping) {
                var _this = this;
                var coordinate = this._coordinate;
                var tileScale = mapping.scale * this._tileScaleRelative;
                var tileSize = coordinate.getTileSize() * mapping.scale;
                this._tileScale = tileScale;
                this._tileSize = tileSize;
                this._mapping = mapping;
                var work = DMapTilePlane.WORK;
                this.toOffset(work);
                var offsetX = work.x;
                var offsetY = work.y;
                this._tiles.forEach(function (tile) {
                    _this.toTilePosition(tile.tx, tile.ty, offsetX, offsetY, work);
                    tile.transform(work.x, work.y, tileScale);
                });
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePlane.WORK = new pixi_js.Point();
        return DMapTilePlane;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTilePyramidImpl = /** @class */ (function (_super) {
        __extends(DMapTilePyramidImpl, _super);
        function DMapTilePyramidImpl(options) {
            var _this = _super.call(this) || this;
            var canvas = options.canvas;
            _this._canvas = canvas;
            _this._builder = options.builder;
            var mapping = options.mapping;
            _this._mapping = mapping;
            var coordinate = options.coordinate;
            _this._coordinate = coordinate;
            _this._mappingInternal = _this.toMapping(canvas, mapping, coordinate);
            _this._z = NaN;
            _this._tz = NaN;
            _this._minZ = options.plane.min;
            _this._maxZ = options.plane.max;
            _this._planes = [];
            _this._onLoadedBound = function () {
                _this.onLoaded();
            };
            _this._fitBound = function () {
                _this._fitBoundTimeout = undefined;
                _this.fit();
            };
            _this._fitThrottle = options.plane.throttle;
            var fitThrottledBound = function () {
                _this.fitThrottled();
            };
            _this._fitThrottledBound = fitThrottledBound;
            canvas.on("scale", fitThrottledBound);
            canvas.on("move", fitThrottledBound);
            canvas.snippet.add(_this, true);
            return _this;
        }
        Object.defineProperty(DMapTilePyramidImpl.prototype, "coordinate", {
            get: function () {
                return this._coordinate;
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePyramidImpl.prototype.fitThrottled = function () {
            if (this._fitBoundTimeout == null) {
                this._fitBoundTimeout = window.setTimeout(this._fitBound, this._fitThrottle);
            }
        };
        DMapTilePyramidImpl.prototype.toMapping = function (canvas, mapping, coordinate) {
            var work = DMapTilePyramidImpl.WORK_LONLAT;
            var tileSize = coordinate.getTileSize();
            work.set(mapping.from.lon, mapping.from.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            var x0 = work.x;
            var y0 = work.y;
            work.set(mapping.to.lon, mapping.to.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            var x1 = work.x;
            var y1 = work.y;
            var dx = Math.abs(x1 - x0);
            var dy = Math.abs(y1 - y0);
            var dmin = 0.0000001;
            var scale = 1;
            if (dmin < dx) {
                if (dmin < dy) {
                    scale = Math.max(canvas.width / dx, canvas.height / dy);
                }
                else {
                    scale = canvas.width / dx;
                }
            }
            else {
                if (dmin < dy) {
                    scale = canvas.height / dy;
                }
            }
            return {
                scale: scale,
                x: (0.5 * (x1 + x0)) / tileSize,
                y: (0.5 * (y1 + y0)) / tileSize
            };
        };
        Object.defineProperty(DMapTilePyramidImpl.prototype, "mapping", {
            get: function () {
                return this._mapping;
            },
            set: function (mapping) {
                var oldMapping = this._mappingInternal;
                var newMapping = this.toMapping(this._canvas, mapping, this._coordinate);
                var threshold = 0.0000001;
                if (threshold < Math.abs(oldMapping.scale - newMapping.scale) ||
                    threshold < Math.abs(oldMapping.x - newMapping.x) ||
                    threshold < Math.abs(oldMapping.y - newMapping.y)) {
                    this._mappingInternal = newMapping;
                    var planes = this._planes;
                    for (var i = 0, imax = planes.length; i < imax; ++i) {
                        var plane = planes[i];
                        if (plane) {
                            plane.mapping = newMapping;
                        }
                    }
                    DApplications.update(this._canvas);
                    this._fitThrottledBound();
                }
            },
            enumerable: false,
            configurable: true
        });
        DMapTilePyramidImpl.prototype.newPlane = function (tz) {
            return new DMapTilePlane(this._canvas, this._builder, tz, this._mappingInternal, this._coordinate, this._onLoadedBound);
        };
        DMapTilePyramidImpl.prototype.render = function (renderer) {
            var tz = this._tz;
            var planes = this._planes;
            for (var i = 0; i < tz; ++i) {
                var plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            for (var i = planes.length - 1; tz < i; --i) {
                var plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            var planeTz = planes[tz];
            if (planeTz != null) {
                planeTz.render(renderer);
            }
        };
        DMapTilePyramidImpl.prototype.toTileZ = function (tz) {
            return Math.min(this._maxZ, Math.max(this._minZ, Math.floor(tz)));
        };
        DMapTilePyramidImpl.prototype.updateTransform = function () {
            // DO NOTHING
        };
        DMapTilePyramidImpl.prototype.toZ = function (scale) {
            return Math.log(this._mappingInternal.scale * scale) / Math.log(2);
        };
        DMapTilePyramidImpl.prototype.move = function (scale, lon0, lat0, lon1, lat1) {
            var planes = this._planes;
            var z = this.toZ(scale);
            if (this._z !== z) {
                this._z = z;
                var tz = this.toTileZ(z);
                if (this._tz !== tz) {
                    this._tz = tz;
                    var newPlane = planes[tz];
                    if (newPlane == null) {
                        newPlane = this.newPlane(tz);
                        planes[tz] = newPlane;
                    }
                }
            }
            var plane = planes[this._tz];
            if (plane != null) {
                plane.move(lon0, lat0, lon1, lat1);
            }
            return this;
        };
        DMapTilePyramidImpl.prototype.fit = function () {
            var canvas = this._canvas;
            if (canvas != null) {
                var container = canvas.parent;
                if (container != null) {
                    var scale = canvas.scale;
                    var scaleX = scale.x;
                    var scaleY = scale.y;
                    var x = canvas.x;
                    var y = canvas.y;
                    var coordinate = this._coordinate;
                    var mapping = this._mappingInternal;
                    var tileSize = coordinate.getTileSize() * mapping.scale;
                    var x0 = mapping.x * tileSize - (x / scaleX + 0.5 * canvas.width);
                    var x1 = x0 + container.width / scaleX;
                    var y0 = mapping.y * tileSize - (y / scaleY + 0.5 * canvas.height);
                    var y1 = y0 + container.height / scaleY;
                    var work = DMapTilePyramidImpl.WORK_LONLAT;
                    work.set(x0, y0);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    var lon0 = work.x;
                    var lat0 = work.y;
                    work.set(x1, y1);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    var lon1 = work.x;
                    var lat1 = work.y;
                    this.move(scaleX, lon0, lat0, lon1, lat1);
                }
            }
            return this;
        };
        DMapTilePyramidImpl.prototype.destroyPlanesBefore = function (tz, planes) {
            for (var i = 0; i < tz; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        };
        DMapTilePyramidImpl.prototype.destroyPlanesAfter = function (tz, planes) {
            for (var i = tz + 1, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        };
        DMapTilePyramidImpl.prototype.cleanup = function () {
            var tz = this._tz;
            var planes = this._planes;
            var planeTz = planes[tz];
            if (planeTz && planeTz.loaded) {
                this.destroyPlanesBefore(tz, planes);
                this.destroyPlanesAfter(tz, planes);
                return;
            }
            for (var i = tz + 1, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(tz, planes);
                    this.destroyPlanesAfter(i, planes);
                    return;
                }
            }
            for (var i = tz - 1; 0 <= i; --i) {
                var plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(i, planes);
                    return;
                }
            }
        };
        DMapTilePyramidImpl.prototype.onLoaded = function () {
            this.cleanup();
            DApplications.update(this._canvas);
        };
        DMapTilePyramidImpl.prototype.destroy = function () {
            var planes = this._planes;
            for (var i = 0, imax = planes.length; i < imax; ++i) {
                var plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
            var canvas = this._canvas;
            var fitThrottledBound = this._fitThrottledBound;
            canvas.off("scale", fitThrottledBound);
            canvas.off("move", fitThrottledBound);
            canvas.snippet.remove(this, true);
            return this;
        };
        DMapTilePyramidImpl.WORK_LONLAT = new pixi_js.Point();
        return DMapTilePyramidImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMapTileUrlBuilderKokudo = function (tz, tx, ty) {
        if (5 <= tz) {
            return "https://cyberjapandata.gsi.go.jp/xyz/pale/".concat(tz, "/").concat(tx, "/").concat(ty, ".png");
        }
        else if (2 <= tz) {
            return "https://cyberjapandata.gsi.go.jp/xyz/std/".concat(tz, "/").concat(tx, "/").concat(ty, ".png");
        }
        else {
            return "https://cyberjapandata.gsi.go.jp/xyz/earthhillshade/".concat(tz, "/").concat(tx, "/").concat(ty, ".png");
        }
    };
    var DMapTileUrlBuilderOsm = function (tz, tx, ty) {
        return "https://".concat("abc"[(tx + ty) % 3], ".tile.openstreetmap.org/").concat(tz, "/").concat(tx, "/").concat(ty, ".png");
    };
    var DMapTileUrlBuilderOsmfj = function (tz, tx, ty) {
        return "https://j.tile.openstreetmap.jp/".concat(tz, "/").concat(tx, "/").concat(ty, ".png");
    };
    var DMapTilePyramids = /** @class */ (function () {
        function DMapTilePyramids() {
        }
        DMapTilePyramids.toPlaneOptions = function (options) {
            var _a, _b, _c;
            var plane = options.plane;
            return {
                min: (_a = plane === null || plane === void 0 ? void 0 : plane.min) !== null && _a !== void 0 ? _a : this.MIN,
                max: (_b = plane === null || plane === void 0 ? void 0 : plane.max) !== null && _b !== void 0 ? _b : this.MAX,
                throttle: (_c = plane === null || plane === void 0 ? void 0 : plane.throttle) !== null && _c !== void 0 ? _c : this.THROTTLE
            };
        };
        DMapTilePyramids.from = function (options) {
            return new DMapTilePyramidImpl({
                canvas: options.canvas,
                builder: options.builder || DMapTileUrlBuilderOsmfj,
                mapping: options.canvas.tile.mapping,
                coordinate: options.coordinate || DMapCoordinates.DEFAULT,
                plane: this.toPlaneOptions(options)
            });
        };
        DMapTilePyramids.MIN = 0;
        DMapTilePyramids.MAX = 18;
        DMapTilePyramids.THROTTLE = 333;
        return DMapTilePyramids;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuBarItem = /** @class */ (function (_super) {
        __extends(DMenuBarItem, _super);
        function DMenuBarItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuBarItem.prototype.toMenu = function (theme, options) {
            var menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof DMenu) {
                return menu;
            }
            else {
                return new DMenu(this.toMenuOptions(theme, menu));
            }
        };
        DMenuBarItem.prototype.newMenu = function (theme, options) {
            return new DMenu(this.toMenuOptions(theme, options));
        };
        DMenuBarItem.prototype.toMenuOptions = function (theme, options) {
            if (options) {
                if (options.fit == null) {
                    options.fit = false;
                }
                return options;
            }
            return {
                fit: false
            };
        };
        DMenuBarItem.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.open();
        };
        DMenuBarItem.prototype.open = function () {
            this.menu.open(this);
        };
        DMenuBarItem.prototype.close = function () {
            this.menu.close();
        };
        Object.defineProperty(DMenuBarItem.prototype, "menu", {
            get: function () {
                var _this = this;
                var result = this._menu;
                if (result == null) {
                    result = this.toMenu(this.theme, this._options);
                    result.on("select", function (value, item, menu) {
                        _this.onMenuSelect(value, item, menu);
                    });
                    this._menu = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DMenuBarItem.prototype.onMenuSelect = function (value, item, menu) {
            this.emit("select", value, item, this);
            var parent = this.parent;
            if (parent) {
                parent.emit("select", value, item, parent);
            }
        };
        DMenuBarItem.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.onKeyDownArrowDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuBarItem.prototype.onKeyDownArrowDown = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onActivate(e);
                return true;
            }
            return false;
        };
        DMenuBarItem.prototype.getType = function () {
            return "DMenuBarItem";
        };
        return DMenuBarItem;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuBar = /** @class */ (function (_super) {
        __extends(DMenuBar, _super);
        function DMenuBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuBar.prototype.init = function (options) {
            _super.prototype.init.call(this, options);
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items) {
                for (var i = 0, imax = items.length; i < imax; ++i) {
                    var item = this.toItem(items[i]);
                    if (item) {
                        this.addChild(item);
                    }
                }
            }
        };
        DMenuBar.prototype.toItem = function (item) {
            if (item == null) {
                return null;
            }
            else if (item instanceof pixi_js.DisplayObject) {
                return item;
            }
            else if ("space" in item) {
                return new DLayoutSpace(item);
            }
            return new DMenuBarItem(item);
        };
        DMenuBar.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusHorizontally(e, this);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuBar.prototype.getType = function () {
            return "DMenuBar";
        };
        return DMenuBar;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedContent = /** @class */ (function (_super) {
        __extends(DMenuSidedContent, _super);
        function DMenuSidedContent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DMenuSidedContent.prototype.initReflowable = function () {
            // DO NOTHING
        };
        DMenuSidedContent.prototype.getType = function () {
            return "DMenuSidedContent";
        };
        return DMenuSidedContent;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSidedSelectionType = {
        NONE: 0,
        SINGLE: 1,
        SINGLE_ONCE: 2
    };
    var defaultFilter = function () { return true; };
    var DMenuSidedSelection = /** @class */ (function (_super) {
        __extends(DMenuSidedSelection, _super);
        function DMenuSidedSelection(content, options) {
            var _this = this;
            var _a, _b, _c;
            _this = _super.call(this) || this;
            _this._content = content;
            _this._item = null;
            _this._isDirty = true;
            _this._type = toEnum((_b = (_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : DMenuSidedSelectionType.SINGLE_ONCE, DMenuSidedSelectionType);
            _this._filter = (_c = options === null || options === void 0 ? void 0 : options.filter) !== null && _c !== void 0 ? _c : _this.getFilterDefault();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        DMenuSidedSelection.prototype.first = function () {
            return this._item;
        };
        DMenuSidedSelection.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DMenuSidedSelection.prototype.update = function () {
            if (this._isDirty) {
                this._isDirty = false;
                this.update_(this._content);
            }
        };
        DMenuSidedSelection.prototype.hasMenu = function (child) {
            return child && child.menu instanceof DMenu;
        };
        DMenuSidedSelection.prototype.update_ = function (root) {
            var children = root.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemBase) {
                    if (child.state.isActive) {
                        this.set_(child, false);
                    }
                }
                if (child instanceof pixi_js.Container) {
                    this.update_(child);
                }
                if (this.hasMenu(child)) {
                    this.update_(child.menu);
                }
            }
        };
        DMenuSidedSelection.prototype.add = function (item) {
            this.update();
            this.set_(item, true);
        };
        DMenuSidedSelection.prototype.set = function (item) {
            this.update();
            this.set_(item, true);
        };
        DMenuSidedSelection.prototype.get = function (index) {
            this.update();
            return this._item;
        };
        DMenuSidedSelection.prototype.getIndex = function (index) {
            return null;
        };
        DMenuSidedSelection.prototype.size = function () {
            return this._item ? 1 : 0;
        };
        DMenuSidedSelection.prototype.isEmpty = function () {
            return this._item == null;
        };
        DMenuSidedSelection.prototype.remove = function (item) {
            this.update();
            if (this._item === item) {
                this.set_(null, true);
            }
        };
        DMenuSidedSelection.prototype.clear = function () {
            this.update();
            this.set_(null, true);
        };
        DMenuSidedSelection.prototype.getFilterDefault = function () {
            return defaultFilter;
        };
        DMenuSidedSelection.prototype.set_ = function (item, emit) {
            var oldItem = this._item;
            var mode = this._type;
            if (mode !== DMenuSidedSelectionType.NONE && this._filter(item) && oldItem !== item) {
                this.setState(oldItem, mode, false);
                this._item = item;
                this.setState(item, mode, true);
                if (emit) {
                    this.emit("change", this);
                }
            }
        };
        DMenuSidedSelection.prototype.setState = function (item, mode, isOn) {
            if (item) {
                if (mode === DMenuSidedSelectionType.SINGLE) {
                    item.state.isActive = isOn;
                }
                else {
                    if (isOn) {
                        item.state.addAll(DBaseState.ACTIVE, DBaseState.READ_ONLY);
                    }
                    else {
                        item.state.removeAll(DBaseState.ACTIVE, DBaseState.READ_ONLY);
                    }
                }
            }
        };
        return DMenuSidedSelection;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DMenuSided = /** @class */ (function (_super) {
        __extends(DMenuSided, _super);
        function DMenuSided(options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            var context = new DMenuContext(_this);
            _this._context = context;
            context.add(_this);
            var items = options === null || options === void 0 ? void 0 : options.items;
            if (items != null) {
                var sticky = (_a = options === null || options === void 0 ? void 0 : options.sticky) !== null && _a !== void 0 ? _a : false;
                _this.newItems(items, sticky);
            }
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            _this._selection =
                selection instanceof DMenuSidedSelection ? selection : _this.newSelection(selection);
            return _this;
        }
        DMenuSided.prototype.newSelection = function (options) {
            return new DMenuSidedSelection(this.content, options);
        };
        DMenuSided.prototype.onHierarchyDirty = function () {
            var selection = this._selection;
            if (selection != null) {
                selection.toDirty();
            }
            _super.prototype.onHierarchyDirty.call(this);
        };
        DMenuSided.prototype.newItems = function (items, sticky) {
            DMenuSideds.newItems(this.content, items, sticky);
        };
        DMenuSided.prototype.newContent = function (options) {
            return new DMenuSidedContent(options);
        };
        Object.defineProperty(DMenuSided.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DMenuSided.prototype.getContext = function () {
            return this._context;
        };
        DMenuSided.prototype.getCloseable = function () {
            return this;
        };
        DMenuSided.prototype.open = function () {
            // DO NOTHING
        };
        DMenuSided.prototype.close = function () {
            // DO NOTHING
        };
        DMenuSided.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusVertically(e, this);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DMenuSided.prototype.getType = function () {
            return "DMenuSided";
        };
        return DMenuSided;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteError = /** @class */ (function (_super) {
        __extends(DNoteError, _super);
        function DNoteError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteError.prototype.getType = function () {
            return "DNoteError";
        };
        return DNoteError;
    }(DNote));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteNoItemsFound = /** @class */ (function (_super) {
        __extends(DNoteNoItemsFound, _super);
        function DNoteNoItemsFound() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteNoItemsFound.prototype.getType = function () {
            return "DNoteNoItemsFound";
        };
        return DNoteNoItemsFound;
    }(DNote));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNoteSearching = /** @class */ (function (_super) {
        __extends(DNoteSearching, _super);
        function DNoteSearching() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DNoteSearching.prototype.getType = function () {
            return "DNoteSearching";
        };
        return DNoteSearching;
    }(DNote));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DNotification = /** @class */ (function (_super) {
        __extends(DNotification, _super);
        function DNotification() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DNotification;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonLast = /** @class */ (function (_super) {
        __extends(DPaginationButtonLast, _super);
        function DPaginationButtonLast() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonLast.prototype.getType = function () {
            return "DPaginationButtonLast";
        };
        return DPaginationButtonLast;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonNext = /** @class */ (function (_super) {
        __extends(DPaginationButtonNext, _super);
        function DPaginationButtonNext() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonNext.prototype.getType = function () {
            return "DPaginationButtonNext";
        };
        return DPaginationButtonNext;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonPage = /** @class */ (function (_super) {
        __extends(DPaginationButtonPage, _super);
        function DPaginationButtonPage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonPage.prototype.getType = function () {
            return "DPaginationButtonPage";
        };
        return DPaginationButtonPage;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonPrevious = /** @class */ (function (_super) {
        __extends(DPaginationButtonPrevious, _super);
        function DPaginationButtonPrevious() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonPrevious.prototype.getType = function () {
            return "DPaginationButtonPrevious";
        };
        return DPaginationButtonPrevious;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationButtonTop = /** @class */ (function (_super) {
        __extends(DPaginationButtonTop, _super);
        function DPaginationButtonTop() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationButtonTop.prototype.getType = function () {
            return "DPaginationButtonTop";
        };
        return DPaginationButtonTop;
    }(DButtonAmbient));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationDots = /** @class */ (function (_super) {
        __extends(DPaginationDots, _super);
        function DPaginationDots() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationDots.prototype.getType = function () {
            return "DPaginationDots";
        };
        return DPaginationDots;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPaginationPage = /** @class */ (function (_super) {
        __extends(DPaginationPage, _super);
        function DPaginationPage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DPaginationPage.prototype.getType = function () {
            return "DPaginationPage";
        };
        return DPaginationPage;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPagination = /** @class */ (function (_super) {
        __extends(DPagination, _super);
        function DPagination(options) {
            var _this = this;
            var _a, _b, _c, _d;
            _this = _super.call(this, options) || this;
            if (options != null) {
                _this._size = (_b = (_a = options.size) !== null && _a !== void 0 ? _a : options.total) !== null && _b !== void 0 ? _b : 10;
                _this._value = (_d = (_c = options.value) !== null && _c !== void 0 ? _c : options.selected) !== null && _d !== void 0 ? _d : 0;
            }
            else {
                _this._size = 10;
                _this._value = 0;
            }
            var buttonTop = _this.buttonTop;
            var buttonPrevious = _this.buttonPrevious;
            if (buttonTop != null) {
                _this.addChild(buttonTop);
            }
            if (buttonPrevious != null) {
                _this.addChild(buttonPrevious);
            }
            if (buttonTop != null || buttonPrevious != null) {
                _this.addChild(_this.newSpace());
            }
            var buttonPages0 = _this.buttonPages0;
            var buttonPages0Length = buttonPages0.length;
            _this.addChild(buttonPages0[buttonPages0Length - 1]);
            _this.addChild(_this.dots0);
            for (var i = buttonPages0Length - 2; 0 <= i; --i) {
                _this.addChild(buttonPages0[i]);
            }
            _this.addChild(_this.page);
            var buttonPages1 = _this.buttonPages1;
            var buttonPages1Length = buttonPages1.length;
            for (var i = 0, imax = buttonPages1Length - 1; i < imax; ++i) {
                _this.addChild(buttonPages1[i]);
            }
            _this.addChild(_this.dots1);
            _this.addChild(buttonPages1[buttonPages1Length - 1]);
            var buttonNext = _this.buttonNext;
            var buttonLast = _this.buttonLast;
            if (buttonNext != null || buttonLast != null) {
                _this.addChild(_this.newSpace());
            }
            if (buttonNext != null) {
                _this.addChild(buttonNext);
            }
            if (buttonLast != null) {
                _this.addChild(buttonLast);
            }
            _this.update();
            return _this;
        }
        DPagination.prototype.newSpace = function () {
            var _a, _b, _c;
            return new DLayoutSpace({
                width: (_c = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.space) !== null && _c !== void 0 ? _c : this.theme.getButtonSpace()
            });
        };
        Object.defineProperty(DPagination.prototype, "value", {
            /**
             * Returns a value that is an index of a current page.
             *
             * @returns a value that is an index of a selected page.
             */
            get: function () {
                return this._value;
            },
            /**
             * Sets a value that is an index of a current page.
             *
             * @param value a value that is an index of a page
             */
            set: function (value) {
                if (0 <= value && value < this._size && this._value !== value) {
                    this._value = value;
                    this.update();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "selected", {
            /**
             * Returns an index of the selected page.
             *
             * @returns an index of the selected page.
             * @deprecated in favor of {@link value}.
             */
            get: function () {
                return this.value;
            },
            /**
             * Selects a page.
             *
             * @param index an index of a page
             * @deprecated in favor of {@link #value}.
             */
            set: function (index) {
                this.value = index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "size", {
            /**
             * Returns a number of total pages.
             *
             * @returns a number of total pages.
             */
            get: function () {
                return this._size;
            },
            /**
             * Sets a number of total pages.
             *
             * @param size a number of pages
             */
            set: function (size) {
                if (0 <= size && this._size !== size) {
                    this._size = size;
                    if (size === 0) {
                        this._value = -1;
                    }
                    else {
                        this._value = Math.max(0, Math.min(this._size - 1, this._value));
                    }
                    this.update();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "total", {
            /**
             * Returns a number of total pages.
             *
             * @returns a number of total pages.
             * @deprecated in favor of {@link size}
             */
            get: function () {
                return this.size;
            },
            /**
             * Sets a number of total pages.
             *
             * @param total a number of pages
             * @deprecated in favor of {@link size}
             */
            set: function (total) {
                this.size = total;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "dots0", {
            get: function () {
                var result = this._dots0;
                if (result == null) {
                    result = this.newDots();
                    this._dots0 = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DPagination.prototype, "dots1", {
            get: function () {
                var result = this._dots1;
                if (result == null) {
                    result = this.newDots();
                    this._dots1 = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newDots = function () {
            return new DPaginationDots();
        };
        Object.defineProperty(DPagination.prototype, "buttonLast", {
            get: function () {
                var result = this._buttonLast;
                if (result === undefined) {
                    result = this.newButtonLast();
                    this._buttonLast = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonLast = function () {
            var _this = this;
            var _a, _b;
            var last = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.last;
            if (last !== null && last !== false && last !== undefined) {
                var result = new DPaginationButtonLast(last !== true ? last : undefined);
                result.on("active", function () {
                    _this.onButtonLastActive();
                });
                return result;
            }
            return null;
        };
        DPagination.prototype.onButtonLastActive = function () {
            this.moveTo(this._size - 1);
        };
        DPagination.prototype.moveTo = function (index) {
            if (0 <= index && index < this._size && this._value !== index) {
                var oldIndex = this._value;
                this._value = index;
                this.emit("change", index, oldIndex, this);
                this.update();
            }
        };
        Object.defineProperty(DPagination.prototype, "buttonNext", {
            get: function () {
                var result = this._buttonNext;
                if (result === undefined) {
                    result = this.newButtonNext();
                    this._buttonNext = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonNext = function () {
            var _this = this;
            var _a, _b;
            var next = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.next;
            if (next !== null && next !== false) {
                var result = new DPaginationButtonNext(next !== true ? next : undefined);
                result.on("active", function () {
                    _this.onButtonNextActive();
                });
                return result;
            }
            return null;
        };
        DPagination.prototype.onButtonNextActive = function () {
            this.moveTo(this._value + 1);
        };
        Object.defineProperty(DPagination.prototype, "buttonPrevious", {
            get: function () {
                var result = this._buttonPrevious;
                if (result === undefined) {
                    result = this.newButtonPrevious();
                    this._buttonPrevious = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonPrevious = function () {
            var _this = this;
            var _a, _b;
            var previous = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.previous;
            if (previous !== null && previous !== false) {
                var result = new DPaginationButtonPrevious(previous !== true ? previous : undefined);
                result.on("active", function () {
                    _this.onButtonPreviousActive();
                });
                return result;
            }
            return null;
        };
        DPagination.prototype.onButtonPreviousActive = function () {
            this.moveTo(this._value - 1);
        };
        Object.defineProperty(DPagination.prototype, "buttonTop", {
            get: function () {
                var result = this._buttonTop;
                if (result === undefined) {
                    result = this.newButtonTop();
                    this._buttonTop = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonTop = function () {
            var _this = this;
            var _a, _b;
            var top = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.top;
            if (top !== null && top !== false && top !== undefined) {
                var result = new DPaginationButtonTop(top !== true ? top : undefined);
                result.on("active", function () {
                    _this.onButtonTopActive();
                });
                return result;
            }
            return null;
        };
        DPagination.prototype.onButtonTopActive = function () {
            this.moveTo(0);
        };
        DPagination.prototype.newButtonPage = function () {
            var _this = this;
            var _a, _b;
            var result = new DPaginationButtonPage((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.page);
            result.on("active", function () {
                _this.onButtonPageActive(result);
            });
            return result;
        };
        Object.defineProperty(DPagination.prototype, "buttonPages0", {
            get: function () {
                var result = this._buttonPages0;
                if (result == null) {
                    result = this.newButtonPages0();
                    this._buttonPages0 = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonPages0 = function () {
            return [
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage()
            ];
        };
        Object.defineProperty(DPagination.prototype, "buttonPages1", {
            get: function () {
                var result = this._buttonPages1;
                if (result == null) {
                    result = this.newButtonPages1();
                    this._buttonPages1 = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newButtonPages1 = function () {
            return [
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage()
            ];
        };
        Object.defineProperty(DPagination.prototype, "page", {
            get: function () {
                var result = this._page;
                if (result == null) {
                    result = this.newPage();
                    this._page = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DPagination.prototype.newPage = function () {
            var _a;
            return new DPaginationPage((_a = this._options) === null || _a === void 0 ? void 0 : _a.page);
        };
        DPagination.prototype.onButtonPageActive = function (button) {
            var text = button.text;
            if (isNumber(text)) {
                this.moveTo(text - 1);
                if (button.state.isFocused) {
                    button.state.isHovered = false;
                    this.page.focus();
                }
            }
        };
        DPagination.prototype.update = function () {
            var size = this._size;
            var value = this._value;
            if (size <= 0) {
                var buttonTop = this.buttonTop;
                if (buttonTop != null) {
                    buttonTop.state.isEnabled = false;
                }
                var buttonPrevious = this.buttonPrevious;
                if (buttonPrevious != null) {
                    buttonPrevious.state.isEnabled = false;
                }
                this.hideDots(this.dots0);
                var buttonPages0 = this.buttonPages0;
                for (var i = 0, imax = buttonPages0.length; i < imax; ++i) {
                    this.hidePage(buttonPages0[i]);
                }
                this.hidePage(this.page);
                var buttonPages1 = this.buttonPages1;
                for (var i = 0, imax = buttonPages1.length; i < imax; ++i) {
                    this.hidePage(buttonPages1[i]);
                }
                this.hideDots(this.dots1);
                var buttonNext = this.buttonNext;
                if (buttonNext != null) {
                    buttonNext.state.isEnabled = false;
                }
                var buttonLast = this.buttonLast;
                if (buttonLast) {
                    buttonLast.state.isEnabled = false;
                }
            }
            else {
                var from = value - 2;
                var to = value + 2;
                if (from < 0) {
                    to = to - from;
                    from = 0;
                }
                else if (size <= to) {
                    var delta = to - size + 1;
                    to -= delta;
                    from -= delta;
                }
                var top_1 = false;
                if (0 < from) {
                    top_1 = true;
                    from = Math.min(from + 1, value);
                }
                var last = false;
                if (to < size - 1) {
                    last = true;
                    to = Math.max(to - 1, value);
                }
                var buttonTop = this.buttonTop;
                if (buttonTop != null) {
                    buttonTop.state.isEnabled = 0 < value;
                }
                var buttonPrevious = this.buttonPrevious;
                if (buttonPrevious != null) {
                    buttonPrevious.state.isEnabled = 0 < value;
                }
                if (top_1) {
                    this.showDots(this.dots0, 1, from - 1);
                }
                else {
                    this.hideDots(this.dots0);
                }
                var buttonPages0 = this.buttonPages0;
                for (var i = 0, imax = buttonPages0.length; i < imax; ++i) {
                    var index = value - i - 1;
                    var buttonPage = buttonPages0[i];
                    if (from <= index && index <= to && 0 <= index) {
                        this.showPage(buttonPage, index);
                    }
                    else {
                        if (top_1 && i === imax - 1) {
                            this.showPage(buttonPage, 0);
                        }
                        else {
                            this.hidePage(buttonPage);
                        }
                    }
                }
                this.showPage(this.page, value);
                var buttonPages1 = this.buttonPages1;
                for (var i = 0, imax = buttonPages1.length; i < imax; ++i) {
                    var index = value + i + 1;
                    var buttonPage = buttonPages1[i];
                    if (from <= index && index <= to && index < size) {
                        this.showPage(buttonPage, index);
                    }
                    else {
                        if (last && i === imax - 1) {
                            this.showPage(buttonPage, size - 1);
                        }
                        else {
                            this.hidePage(buttonPage);
                        }
                    }
                }
                if (last) {
                    this.showDots(this.dots1, to + 1, size - 2);
                }
                else {
                    this.hideDots(this.dots1);
                }
                var buttonNext = this.buttonNext;
                if (buttonNext != null) {
                    buttonNext.state.isEnabled = value < size - 1;
                }
                var buttonLast = this.buttonLast;
                if (buttonLast != null) {
                    buttonLast.state.isEnabled = value < size - 1;
                }
            }
        };
        DPagination.prototype.showPage = function (button, index) {
            button.text = index + 1;
            button.show();
        };
        DPagination.prototype.hidePage = function (button) {
            button.hide();
        };
        DPagination.prototype.showDots = function (dots, from, to) {
            dots.show();
        };
        DPagination.prototype.hideDots = function (dots) {
            dots.hide();
        };
        DPagination.prototype.getType = function () {
            return "DPagination";
        };
        return DPagination;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerDatetimeRange = /** @class */ (function (_super) {
        __extends(DPickerDatetimeRange, _super);
        function DPickerDatetimeRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DPickerDatetimeRange;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DPickerTimeRange = /** @class */ (function (_super) {
        __extends(DPickerTimeRange, _super);
        function DPickerTimeRange() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DPickerTimeRange;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A multi-value selector class.
     */
    var DSelectMultiple = /** @class */ (function (_super) {
        __extends(DSelectMultiple, _super);
        function DSelectMultiple(options) {
            var _this = _super.call(this, options) || this;
            // Default values
            _this._values = [];
            var values = options === null || options === void 0 ? void 0 : options.values;
            if (values) {
                _this.values = values;
            }
            return _this;
        }
        DSelectMultiple.prototype.onMenuSelect = function (value, item, menu) {
            _super.prototype.onMenuSelect.call(this, value, item, menu);
            if (item instanceof DMenuItemCheck) {
                var oldValues = this._values;
                var newValues = [];
                var newItems = [];
                if (item.state.isActive) {
                    this.updateMenuItems(menu, oldValues, value, undefined, newValues, newItems);
                }
                else {
                    this.updateMenuItems(menu, oldValues, undefined, value, newValues, newItems);
                }
                this._values = newValues;
                this.text = newItems;
                this.onValueChange(newValues, oldValues, newItems);
            }
        };
        DSelectMultiple.prototype.onMenuReplaced = function (newMenu, oldMenu) {
            _super.prototype.onMenuReplaced.call(this, newMenu, oldMenu);
            // Update the values
            var values = this._values;
            var newValues = [];
            var newItems = [];
            this.updateMenuItems(newMenu, values, undefined, undefined, newValues, newItems);
            this._values = newValues;
            this.text = newItems;
        };
        DSelectMultiple.prototype.onValueChange = function (newValues, oldValues, items) {
            this.emit("change", newValues, oldValues, items, this);
        };
        DSelectMultiple.prototype.open = function () {
            this.updateMenuItems(this.menu, this._values);
            _super.prototype.open.call(this);
        };
        Object.defineProperty(DSelectMultiple.prototype, "values", {
            /**
             * Returns a selected value or null.
             */
            get: function () {
                return this._values;
            },
            /**
             * Sets to the specified value.
             */
            set: function (values) {
                var oldValues = this._values;
                if (!this.isSameValues(values, oldValues)) {
                    var newValues = [];
                    var newItems = [];
                    this.updateMenuItems(this.menu, values, undefined, undefined, newValues, newItems);
                    this._values = newValues;
                    this.text = newItems;
                }
            },
            enumerable: false,
            configurable: true
        });
        DSelectMultiple.prototype.isSameValues = function (a, b) {
            if (a.length === b.length) {
                for (var i = 0, imax = a.length; i < imax; ++i) {
                    if (b.indexOf(a[i]) < 0) {
                        return false;
                    }
                }
            }
            return false;
        };
        DSelectMultiple.prototype.updateMenuItems = function (menu, oldValues, addedValue, removedValue, newValues, newItems) {
            var children = menu.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemMenu) {
                    this.updateMenuItems(child.menu, oldValues, addedValue, removedValue, newValues, newItems);
                }
                else if (child instanceof DMenuItemCheck) {
                    var childValue = child.value;
                    if (removedValue !== undefined && removedValue === childValue) {
                        child.state.isActive = false;
                    }
                    else if ((addedValue !== undefined && child.value === addedValue) ||
                        0 <= oldValues.indexOf(child.value)) {
                        if (newValues) {
                            newValues.push(child.value);
                        }
                        if (newItems) {
                            newItems.push(child);
                        }
                        child.state.isActive = true;
                    }
                    else {
                        child.state.isActive = false;
                    }
                }
            }
        };
        DSelectMultiple.prototype.getType = function () {
            return "DSelectMultiple";
        };
        return DSelectMultiple;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A selector class.
     */
    var DSelect = /** @class */ (function (_super) {
        __extends(DSelect, _super);
        function DSelect(options) {
            var _this = _super.call(this, options) || this;
            // Default value
            _this._value = null;
            var value = options === null || options === void 0 ? void 0 : options.value;
            if (value != null) {
                _this.value = value;
            }
            return _this;
        }
        DSelect.prototype.onMenuSelect = function (newValue, item, menu) {
            _super.prototype.onMenuSelect.call(this, newValue, item, menu);
            var oldValue = this._value;
            if (oldValue !== newValue) {
                this._value = newValue;
                this.text = item;
                this.onValueChange(newValue, oldValue, item);
            }
        };
        DSelect.prototype.onMenuReplaced = function (newMenu, oldMenu) {
            _super.prototype.onMenuReplaced.call(this, newMenu, oldMenu);
            // Update the value
            var value = this._value;
            if (value != null) {
                var item = this.findMenuItem(newMenu, value);
                if (item != null) {
                    this._value = value;
                    this.text = item;
                }
                else {
                    this._value = null;
                    this.text = null;
                }
            }
            else {
                this._value = null;
                this.text = null;
            }
        };
        DSelect.prototype.onValueChange = function (newValue, oldValue, item) {
            this.emit("change", newValue, oldValue, item, this);
        };
        DSelect.prototype.findMenuItem = function (menu, value) {
            var children = menu.children;
            for (var i = 0, imax = children.length; i < imax; ++i) {
                var child = children[i];
                if (child instanceof DMenuItemMenu) {
                    var result = this.findMenuItem(child.menu, value);
                    if (result != null) {
                        return result;
                    }
                }
                else if (child instanceof DMenuItem) {
                    if (child.value === value) {
                        return child;
                    }
                }
            }
            return null;
        };
        Object.defineProperty(DSelect.prototype, "value", {
            /**
             * Returns a selected value or null.
             */
            get: function () {
                return this._value;
            },
            /**
             * Sets to the specified value.
             */
            set: function (value) {
                if (this._value !== value) {
                    var item = this.findMenuItem(this.menu, value);
                    if (item != null) {
                        this._value = value;
                        this.text = item;
                    }
                    else {
                        this._value = null;
                        this.text = null;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        DSelect.prototype.getType = function () {
            return "DSelect";
        };
        return DSelect;
    }(DDropdownBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DShadowImpl = /** @class */ (function (_super) {
        __extends(DShadowImpl, _super);
        function DShadowImpl(texture, width, height, offsetX, offsetY) {
            var _this = _super.call(this, texture, width, height, width, height) || this;
            _this._offsetX = offsetX;
            _this._offsetY = offsetY;
            _this._shiftX = width * 0.5;
            _this._shiftY = height * 0.5;
            _this.interactive = false;
            _this.interactiveChildren = false;
            texture.on("update", function () {
                _this.onTextureUpdate();
            });
            return _this;
        }
        DShadowImpl.prototype.onTextureUpdate = function () {
            this.emit("update", this);
        };
        DShadowImpl.prototype.onReflow = function (base, width, height) {
            var sx = this._shiftX;
            var sy = this._shiftY;
            this.x = -sx + this._offsetX;
            this.y = -sy + this._offsetY;
            this.width = sx + width + sx;
            this.height = sy + height + sy;
        };
        DShadowImpl.prototype.render = function (renderer) {
            var parent = this.parent;
            if (parent) {
                var alpha = parent.alpha;
                this.alpha = alpha * alpha * alpha;
            }
            _super.prototype.render.call(this, renderer);
        };
        return DShadowImpl;
    }(pixi_js.NineSlicePlane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderLabel = /** @class */ (function (_super) {
        __extends(DSliderLabel, _super);
        function DSliderLabel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderLabel.prototype.init = function (options) {
            var _a;
            _super.prototype.init.call(this, options);
            this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : 0;
        };
        Object.defineProperty(DSliderLabel.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        DSliderLabel.prototype.getType = function () {
            return "DSliderLabel";
        };
        return DSliderLabel;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderThumb = /** @class */ (function (_super) {
        __extends(DSliderThumb, _super);
        function DSliderThumb() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderThumb.prototype.getType = function () {
            return "DSliderThumb";
        };
        return DSliderThumb;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderValue = /** @class */ (function (_super) {
        __extends(DSliderValue, _super);
        function DSliderValue(options) {
            var _this = this;
            var _a, _b;
            _this = _super.call(this, options) || this;
            _this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : 0;
            _this._rounder = _this.toRounder(options);
            _this._delta = (_b = options === null || options === void 0 ? void 0 : options.delta) !== null && _b !== void 0 ? _b : 1;
            return _this;
        }
        DSliderValue.prototype.toRounder = function (options) {
            var _a;
            var rounder = options === null || options === void 0 ? void 0 : options.rounder;
            if (rounder) {
                return rounder;
            }
            var precision = (_a = options === null || options === void 0 ? void 0 : options.precision) !== null && _a !== void 0 ? _a : this.theme.getPrecision();
            var base = Math.pow(10, precision);
            return function (value) {
                return Math.round(value * base) / base;
            };
        };
        Object.defineProperty(DSliderValue.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (value) {
                this._value = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSliderValue.prototype, "rounder", {
            get: function () {
                return this._rounder;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSliderValue.prototype, "delta", {
            get: function () {
                return this._delta;
            },
            enumerable: false,
            configurable: true
        });
        DSliderValue.prototype.getType = function () {
            return "DSliderValue";
        };
        return DSliderValue;
    }(DTextBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A slider class.
     */
    var DSlider = /** @class */ (function (_super) {
        __extends(DSlider, _super);
        function DSlider() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSlider.prototype.init = function (options) {
            var _this = this;
            _super.prototype.init.call(this, options);
            this._ratioValue = 0;
            this._track = this.newTrack(options);
            this.addChild(this._track);
            this._trackSelected = this.newTrackSelected(options);
            this._trackSelected.state.isActive = true;
            this.addChild(this._trackSelected);
            this._thumb = this.newThumb(options);
            this.addChild(this._thumb);
            this._min = this.newLabelMin(options);
            this.addChild(this._min);
            this._max = this.newLabelMax(options);
            this.addChild(this._max);
            this._value = this.newValue(options);
            this.addChild(this._value);
            // Event listeners
            this._track.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = _this.state.inEnabled;
                _this.onTrackDown(e.data.global);
            });
            this._trackSelected.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = _this.state.inEnabled;
                _this.onTrackSelectedDown(e.data.global);
            });
            this._onTrackUpBound = function (e) {
                _this.onTrackUpBound(e);
                _this._value.visible = false;
            };
            this._onTrackSelectedUpBound = function (e) {
                _this.onTrackSelectedUpBound(e);
                _this._value.visible = false;
            };
            this._thumb.on(UtilPointerEvent.down, function (e) {
                _this._value.visible = true;
                _this.onThumbDown(e);
            });
            this._onThumbMoveBound = function (e) {
                _this.onThumbMove(e);
            };
            this._onThumbUpBound = function (e) {
                _this.onThumbUp(e);
                _this._value.visible = false;
            };
            //
            this.onValuesChange();
        };
        DSlider.prototype.newThumb = function (options) {
            return new DSliderThumb(options === null || options === void 0 ? void 0 : options.thumb);
        };
        DSlider.prototype.newValue = function (options) {
            return new DSliderValue(this.toValueOptions(options === null || options === void 0 ? void 0 : options.value));
        };
        DSlider.prototype.toValueOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            var text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = options.value;
            }
            if (options.visible == null) {
                options.visible = false;
            }
            return options;
        };
        DSlider.prototype.newLabelMin = function (options) {
            return new DSliderLabel(this.toLabelMinOptions(options === null || options === void 0 ? void 0 : options.min));
        };
        DSlider.prototype.toLabelMinOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            var text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = "".concat(options.value);
            }
            return options;
        };
        DSlider.prototype.newLabelMax = function (options) {
            return new DSliderLabel(this.toLabelMaxOptions(options === null || options === void 0 ? void 0 : options.max));
        };
        DSlider.prototype.toLabelMaxOptions = function (options) {
            options = options || {};
            if (options.value == null) {
                options.value = 1;
            }
            var text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = "".concat(options.value);
            }
            return options;
        };
        DSlider.prototype.getValueMargin = function () {
            return 14;
        };
        DSlider.prototype.onTrackDown = function (global) {
            if (this.state.inDisabled) {
                return;
            }
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                var onTrackUpBound = this._onTrackUpBound;
                interactionManager.on(UtilPointerEvent.up, onTrackUpBound);
                interactionManager.on(UtilPointerEvent.upoutside, onTrackUpBound);
                interactionManager.on(UtilPointerEvent.cancel, onTrackUpBound);
            }
            this.onPick(global);
        };
        DSlider.prototype.onTrackSelectedDown = function (global) {
            if (this.state.inDisabled) {
                return;
            }
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                var onTrackSelectedUpBound = this._onTrackSelectedUpBound;
                interactionManager.on(UtilPointerEvent.up, onTrackSelectedUpBound);
                interactionManager.on(UtilPointerEvent.upoutside, onTrackSelectedUpBound);
                interactionManager.on(UtilPointerEvent.cancel, onTrackSelectedUpBound);
            }
            this.onPick(global);
        };
        DSlider.prototype.onTrackUpBound = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                var onTrackUpBound = this._onTrackUpBound;
                interactionManager.off(UtilPointerEvent.up, onTrackUpBound);
                interactionManager.off(UtilPointerEvent.upoutside, onTrackUpBound);
                interactionManager.off(UtilPointerEvent.cancel, onTrackUpBound);
            }
        };
        DSlider.prototype.onTrackSelectedUpBound = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                var onTrackSelectedUpBound = this._onTrackSelectedUpBound;
                interactionManager.off(UtilPointerEvent.up, onTrackSelectedUpBound);
                interactionManager.off(UtilPointerEvent.upoutside, onTrackSelectedUpBound);
                interactionManager.off(UtilPointerEvent.cancel, onTrackSelectedUpBound);
            }
        };
        DSlider.prototype.onThumbMove = function (e) {
            if (this.state.inDisabled) {
                return;
            }
            this.onPick(e.data.global);
        };
        DSlider.prototype.onThumbDown = function (e) {
            var layer = DApplications.getLayer(this);
            if (layer) {
                var interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                var onThumbMoveBound = this._onThumbMoveBound;
                interactionManager.on(UtilPointerEvent.move, onThumbMoveBound);
                var onThumbUpBound = this._onThumbUpBound;
                interactionManager.on(UtilPointerEvent.up, onThumbUpBound);
                interactionManager.on(UtilPointerEvent.upoutside, onThumbUpBound);
                interactionManager.on(UtilPointerEvent.cancel, onThumbUpBound);
            }
        };
        DSlider.prototype.onThumbUp = function (e) {
            var interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                var onThumbMoveBound = this._onThumbMoveBound;
                interactionManager.off(UtilPointerEvent.move, onThumbMoveBound);
                var onThumbUpBound = this._onThumbUpBound;
                interactionManager.off(UtilPointerEvent.up, onThumbUpBound);
                interactionManager.off(UtilPointerEvent.upoutside, onThumbUpBound);
                interactionManager.off(UtilPointerEvent.cancel, onThumbUpBound);
            }
        };
        DSlider.prototype.updateValue = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value;
            var newValue = value.rounder(min + this._ratioValue * (max - min));
            var oldValue = value.value;
            if (newValue !== oldValue) {
                value.value = newValue;
                value.text = value.value;
                this.emit("change", newValue, oldValue, this);
            }
        };
        DSlider.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.onValuesChange();
        };
        Object.defineProperty(DSlider.prototype, "value", {
            /**
             * Returns a current value.
             */
            get: function () {
                return this._value.value;
            },
            /**
             * Sets a current value.
             */
            set: function (value) {
                value = Math.max(this._min.value, Math.min(this._max.value, value));
                // Adjust if value is new
                if (this._value.value !== value) {
                    this._value.value = value;
                    this.onValuesChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSlider.prototype, "min", {
            /**
             * Returns a minimum value.
             */
            get: function () {
                return this._min.value;
            },
            /**
             * Sets a minimum value.
             */
            set: function (newMin) {
                var min = this._min;
                newMin = Math.min(this._max.value, newMin);
                if (min.value !== newMin) {
                    var value = this._value;
                    min.text = min.value = newMin;
                    value.value = Math.max(newMin, value.value);
                    this.onValuesChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DSlider.prototype, "max", {
            /**
             * Returns a maximum value.
             */
            get: function () {
                return this._max.value;
            },
            /**
             * Sets a maximum value.
             */
            set: function (newMax) {
                var max = this._max;
                newMax = Math.max(this._min.value, newMax);
                if (max.value !== newMax) {
                    var value = this._value;
                    max.text = max.value = newMax;
                    value.value = Math.min(newMax, value.value);
                    this.onValuesChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        DSlider.prototype.getType = function () {
            return "DSlider";
        };
        return DSlider;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrack = /** @class */ (function (_super) {
        __extends(DSliderTrack, _super);
        function DSliderTrack() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrack.prototype.getType = function () {
            return "DSliderTrack";
        };
        return DSliderTrack;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrackHorizontal = /** @class */ (function (_super) {
        __extends(DSliderTrackHorizontal, _super);
        function DSliderTrackHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrackHorizontal.prototype.getType = function () {
            return "DSliderTrackHorizontal";
        };
        return DSliderTrackHorizontal;
    }(DSliderTrack));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderHorizontal = /** @class */ (function (_super) {
        __extends(DSliderHorizontal, _super);
        function DSliderHorizontal() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderHorizontal.prototype.newTrack = function (options) {
            return new DSliderTrackHorizontal(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderHorizontal.prototype.newTrackSelected = function (options) {
            return new DSliderTrackHorizontal(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderHorizontal.prototype.toValueOptions = function (options) {
            var _this = this;
            options = _super.prototype.toValueOptions.call(this, options);
            if (options.y == null) {
                options.y = function (p, s) { return p * 0.5 - s - _this.getValueMargin(); };
            }
            return options;
        };
        DSliderHorizontal.prototype.toLabelMinOptions = function (options) {
            options = _super.prototype.toLabelMinOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s * 0.5; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s; };
            }
            return options;
        };
        DSliderHorizontal.prototype.toLabelMaxOptions = function (options) {
            options = _super.prototype.toLabelMaxOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return p - s * 0.5; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s; };
            }
            return options;
        };
        DSliderHorizontal.prototype.onPick = function (global) {
            var point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            var x = Math.max(0, Math.min(this._track.width, point.x));
            this._ratioValue = x / this._track.width;
            this.moveThumbPosition(x);
        };
        DSliderHorizontal.prototype.onValuesChange = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            var x = this._ratioValue * this._track.width;
            this.moveThumbPosition(x);
        };
        DSliderHorizontal.prototype.moveThumbPosition = function (x) {
            var thumb = this._thumb;
            thumb.x = x - thumb.width * 0.5;
            this._trackSelected.width = x;
            var value = this._value;
            value.x = x - value.width * 0.5;
            this.updateValue();
        };
        DSliderHorizontal.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                this.value += this._value.delta;
            }
            else if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                this.value -= this._value.delta;
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DSliderHorizontal.prototype.getType = function () {
            return "DSliderHorizontal";
        };
        return DSliderHorizontal;
    }(DSlider));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderTrackVertical = /** @class */ (function (_super) {
        __extends(DSliderTrackVertical, _super);
        function DSliderTrackVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderTrackVertical.prototype.getType = function () {
            return "DSliderTrackVertical";
        };
        return DSliderTrackVertical;
    }(DSliderTrack));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DSliderVertical = /** @class */ (function (_super) {
        __extends(DSliderVertical, _super);
        function DSliderVertical() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DSliderVertical.prototype.newTrack = function (options) {
            return new DSliderTrackVertical(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderVertical.prototype.newTrackSelected = function (options) {
            return new DSliderTrackVertical(options === null || options === void 0 ? void 0 : options.track);
        };
        DSliderVertical.prototype.toLabelMinOptions = function (options) {
            options = _super.prototype.toLabelMinOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return p - s * 0.5; };
            }
            var text = options.text || {};
            options.text = text;
            var textAlign = text.align || {};
            text.align = textAlign;
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        };
        DSliderVertical.prototype.toLabelMaxOptions = function (options) {
            options = _super.prototype.toLabelMaxOptions.call(this, options);
            if (options.x == null) {
                options.x = function (p, s) { return -s; };
            }
            if (options.y == null) {
                options.y = function (p, s) { return -s * 0.5; };
            }
            var text = options.text || {};
            options.text = text;
            var textAlign = text.align || {};
            text.align = textAlign;
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        };
        DSliderVertical.prototype.onPick = function (global) {
            var point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            var height = this.height;
            var y = Math.max(0, Math.min(height, point.y));
            this._ratioValue = (height - y) / height;
            this.moveThumbPosition(y);
        };
        DSliderVertical.prototype.onValuesChange = function () {
            var min = this._min.value;
            var max = this._max.value;
            var value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            var y = this.height * (1 - this._ratioValue);
            this.moveThumbPosition(y);
        };
        DSliderVertical.prototype.moveThumbPosition = function (y) {
            var thumb = this._thumb;
            thumb.y = y - thumb.height * 0.5;
            var trackSelected = this._trackSelected;
            trackSelected.y = y;
            trackSelected.height = this.height - y;
            var value = this._value;
            value.y = y - value.height - this.getValueMargin();
            this.updateValue();
        };
        DSliderVertical.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isArrowUpKey(e)) {
                this.value += this._value.delta;
            }
            else if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.value -= this._value.delta;
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DSliderVertical.prototype.getType = function () {
            return "DSliderVertical";
        };
        return DSliderVertical;
    }(DSlider));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCells = /** @class */ (function () {
        function DTableBodyCells() {
        }
        DTableBodyCells.set = function (target, row, columnIndex, column, readOnly) {
            var _a;
            var renderable = this.toRenderable(row, columnIndex, column);
            target.renderable = renderable;
            var state = target.state;
            state.lock();
            state.isDisabled = !renderable;
            if (readOnly !== false) {
                state.isReadOnly = this.toReadOnly(row, columnIndex, column);
            }
            var columnStateModifier = (_a = column.state) === null || _a === void 0 ? void 0 : _a.modifier;
            if (columnStateModifier) {
                columnStateModifier(row, columnIndex, target.state);
            }
            state.unlock();
        };
        DTableBodyCells.toReadOnly = function (row, columnIndex, column) {
            var enable = column.editing.enable;
            if (enable === true) {
                return false;
            }
            else if (enable === false) {
                return true;
            }
            else {
                return !enable(row, columnIndex);
            }
        };
        DTableBodyCells.toRenderable = function (row, columnIndex, column) {
            var renderable = column.renderable;
            if (renderable === true) {
                return true;
            }
            else if (renderable === false) {
                return false;
            }
            else {
                return renderable(row, columnIndex);
            }
        };
        return DTableBodyCells;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectDialog = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectDialog, _super);
        function DTableBodyCellSelectDialog(columnIndex, column, onChange, options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            _this._isSyncEnabled = (_a = options === null || options === void 0 ? void 0 : options.sync) !== null && _a !== void 0 ? _a : _this.theme.isSyncEnabled();
            return _this;
        }
        DTableBodyCellSelectDialog.prototype.onActivate = function (e) {
            var _this = this;
            var _a;
            _super.prototype.onActivate.call(this, e);
            var selecting = this._column.selecting;
            var dialog = selecting.dialog;
            if (dialog) {
                var oldValue_1 = (_a = this._textValueComputed) !== null && _a !== void 0 ? _a : null;
                selecting.setter(dialog, oldValue_1);
                dialog.open(this).then(function () {
                    var newValue = selecting.getter(dialog);
                    if (_this._isSyncEnabled) {
                        if (newValue !== oldValue_1) {
                            _this.text = newValue;
                            _this.onValueChange(newValue, oldValue_1);
                        }
                    }
                    else {
                        _this.onValueChange(newValue, null);
                    }
                });
            }
        };
        DTableBodyCellSelectDialog.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectDialog.prototype, "value", {
            get: function () {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed !== undefined) {
                    return textValueComputed;
                }
                return null;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectDialog.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (forcibly) {
                this._textValue = value;
                this._textValueComputed = value;
                this.onTextChange();
                this.createOrUpdateText();
            }
            else {
                this.text = value;
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellSelectDialog.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectDialog.prototype.getType = function () {
            return "DTableBodyCellSelectDialog";
        };
        return DTableBodyCellSelectDialog;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionDialog = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionDialog, _super);
        function DTableBodyCellActionDialog() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellActionDialog.prototype.getType = function () {
            return "DTableBodyCellActionDialog";
        };
        return DTableBodyCellActionDialog;
    }(DTableBodyCellSelectDialog));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionMenu = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionMenu, _super);
        function DTableBodyCellActionMenu(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellActionMenu.prototype.onMenuSelect = function (selected, item, menu) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, selected);
                _super.prototype.onMenuSelect.call(this, selected, item, menu);
                this._onChange(selected, null, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellActionMenu.prototype.onKeyDownArrowDown = function (e) {
            return false;
        };
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellActionMenu.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellActionMenu.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellActionMenu.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellActionMenu.prototype.getType = function () {
            return "DTableBodyCellActionMenu";
        };
        return DTableBodyCellActionMenu;
    }(DDropdown));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectPromise = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectPromise, _super);
        function DTableBodyCellSelectPromise(columnIndex, column, onChange, options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            _this._isSyncEnabled = (_a = options === null || options === void 0 ? void 0 : options.sync) !== null && _a !== void 0 ? _a : _this.theme.isSyncEnabled();
            return _this;
        }
        DTableBodyCellSelectPromise.prototype.onActivate = function (e) {
            var _this = this;
            _super.prototype.onActivate.call(this, e);
            var selecting = this._column.selecting;
            var promise = selecting.promise;
            if (promise) {
                promise().then(function (newValue) {
                    var _a;
                    if (_this._isSyncEnabled) {
                        var oldValue = (_a = _this._textValueComputed) !== null && _a !== void 0 ? _a : null;
                        if (newValue !== oldValue) {
                            _this.text = newValue;
                            _this.onValueChange(newValue, oldValue);
                        }
                    }
                    else {
                        _this.onValueChange(newValue, null);
                    }
                });
            }
        };
        DTableBodyCellSelectPromise.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectPromise.prototype, "value", {
            get: function () {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed !== undefined) {
                    return textValueComputed;
                }
                return null;
            },
            set: function (value) {
                this.text = value;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectPromise.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (forcibly) {
                this._textValue = value;
                this._textValueComputed = value;
                this.onTextChange();
                this.createOrUpdateText();
            }
            else {
                this.text = value;
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellSelectPromise.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectPromise.prototype.getType = function () {
            return "DTableBodyCellSelectPromise";
        };
        return DTableBodyCellSelectPromise;
    }(DButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellActionPromise = /** @class */ (function (_super) {
        __extends(DTableBodyCellActionPromise, _super);
        function DTableBodyCellActionPromise() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellActionPromise.prototype.getType = function () {
            return "DTableBodyCellActionPromise";
        };
        return DTableBodyCellActionPromise;
    }(DTableBodyCellSelectPromise));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellText = /** @class */ (function (_super) {
        __extends(DTableBodyCellText, _super);
        function DTableBodyCellText(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        Object.defineProperty(DTableBodyCellText.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellText.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellText.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellText.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellText.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellText.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellText.prototype.getType = function () {
            return "DTableBodyCellText";
        };
        return DTableBodyCellText;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellButton = /** @class */ (function (_super) {
        __extends(DTableBodyCellButton, _super);
        function DTableBodyCellButton(columnIndex, column, onChange, options) {
            var _this = this;
            var _a;
            _this = _super.call(this, columnIndex, column, onChange, options) || this;
            _this._when = toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : DButtonBaseWhen.CLICKED, DButtonBaseWhen);
            _this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
            return _this;
        }
        DTableBodyCellButton.prototype.onClick = function (e) {
            if (this._when === DButtonBaseWhen.CLICKED && this.state.isActionable) {
                this.activate(e);
            }
        };
        DTableBodyCellButton.prototype.onDblClick = function (e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED && this.state.isActionable) {
                this.activate(e);
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DTableBodyCellButton.prototype.activate = function (e) {
            this.onActivate(e);
        };
        DTableBodyCellButton.prototype.onActivate = function (e) {
            this.emit("active", this);
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this.emit("change", null, null, this);
                this._onChange(null, null, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellButton.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        };
        DTableBodyCellButton.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.onActivate(e);
                }
                this.state.isPressed = false;
            }
        };
        DTableBodyCellButton.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTableBodyCellButton.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTableBodyCellButton.prototype.getType = function () {
            return "DTableBodyCellButton";
        };
        return DTableBodyCellButton;
    }(DTableBodyCellText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableColumnType = {
        INDEX: 0,
        TEXT: 1,
        INTEGER: 2,
        REAL: 3,
        CHECK: 4,
        CHECK_SINGLE: 5,
        COLOR: 6,
        BUTTON: 7,
        SELECT: 8,
        DATE: 9,
        DATETIME: 10,
        TIME: 11,
        ACTION: 12,
        LINK: 13,
        TREE: 14
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellCheck = /** @class */ (function (_super) {
        __extends(DTableBodyCellCheck, _super);
        function DTableBodyCellCheck(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellCheck.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.onValueChange(true, false);
        };
        DTableBodyCellCheck.prototype.onInactivate = function (e) {
            _super.prototype.onInactivate.call(this, e);
            this.onValueChange(false, true);
        };
        DTableBodyCellCheck.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                var column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                var onChange = this._onChange;
                onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
                if (newValue && column.type === DTableColumnType.CHECK_SINGLE) {
                    this.onChangeSingle(rowIndex, columnIndex, column, onChange);
                }
            }
        };
        DTableBodyCellCheck.prototype.onChangeSingle = function (rowIndex, columnIndex, column, onChange) {
            var _this = this;
            var tableBodyRow = this.parent;
            if (tableBodyRow) {
                var tableBody = tableBodyRow.parent;
                if (tableBody) {
                    var isChanged_1 = false;
                    var getter_1 = column.getter;
                    var setter_1 = column.setter;
                    var data = tableBody.data;
                    data.each(function (row, index) {
                        if (rowIndex !== index && getter_1(row, columnIndex)) {
                            setter_1(row, columnIndex, false);
                            isChanged_1 = true;
                            onChange(false, true, row, index, columnIndex, _this);
                            return false;
                        }
                        return true;
                    });
                    if (isChanged_1) {
                        tableBody.update(true);
                    }
                }
            }
        };
        Object.defineProperty(DTableBodyCellCheck.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellCheck.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellCheck.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellCheck.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellCheck.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.state.isActive = !!value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellCheck.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellCheck.prototype.getType = function () {
            return "DTableBodyCellCheck";
        };
        return DTableBodyCellCheck;
    }(DButtonCheck));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellColor = /** @class */ (function (_super) {
        __extends(DTableBodyCellColor, _super);
        function DTableBodyCellColor(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellColor.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
            else {
                _super.prototype.onValueChange.call(this, newValue, oldValue);
            }
        };
        Object.defineProperty(DTableBodyCellColor.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellColor.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellColor.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellColor.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellColor.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            var cell = this.value;
            if (isNumber(value)) {
                cell.color = value;
                cell.alpha = 1;
            }
            else if (isString(value)) {
                var parsed = Number(value);
                cell.color = parsed === parsed ? parsed : 0xffffff;
                cell.alpha = 1;
            }
            else if (value != null) {
                var color = value.color;
                var alpha = value.alpha;
                cell.color = isNumber(color) ? color : 0xffffff;
                cell.alpha = isNumber(alpha) ? alpha : 1;
            }
            else {
                cell.color = 0xffffff;
                cell.alpha = 1;
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellColor.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellColor.prototype.getType = function () {
            return "DTableBodyCellColor";
        };
        return DTableBodyCellColor;
    }(DButtonColor));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellDate = /** @class */ (function (_super) {
        __extends(DTableBodyCellDate, _super);
        function DTableBodyCellDate(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellDate.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
            else {
                _super.prototype.onValueChange.call(this, newValue, oldValue);
            }
        };
        Object.defineProperty(DTableBodyCellDate.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDate.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellDate.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this._textValue = value;
                    this._textValueComputed = value;
                    this.onTextChange();
                    this.createOrUpdateText();
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed === undefined) {
                    this.text = new Date(value);
                }
                else if (textValueComputed.getTime() !== value) {
                    textValueComputed.setTime(value);
                    this.onTextChange();
                    this.createOrUpdateText();
                }
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellDate.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellDate.prototype.getType = function () {
            return "DTableBodyCellDate";
        };
        return DTableBodyCellDate;
    }(DButtonDate));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellDatetime = /** @class */ (function (_super) {
        __extends(DTableBodyCellDatetime, _super);
        function DTableBodyCellDatetime(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellDatetime.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
            else {
                _super.prototype.onValueChange.call(this, newValue, oldValue);
            }
        };
        Object.defineProperty(DTableBodyCellDatetime.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellDatetime.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellDatetime.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this._textValue = value;
                    this._textValueComputed = value;
                    this.onTextChange();
                    this.createOrUpdateText();
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed == null) {
                    this.text = new Date(value);
                }
                else if (textValueComputed.getTime() !== value) {
                    textValueComputed.setTime(value);
                    this.onTextChange();
                    this.createOrUpdateText();
                }
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellDatetime.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellDatetime.prototype.getType = function () {
            return "DTableBodyCellDatetime";
        };
        return DTableBodyCellDatetime;
    }(DButtonDatetime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellIndex = /** @class */ (function (_super) {
        __extends(DTableBodyCellIndex, _super);
        function DTableBodyCellIndex(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        Object.defineProperty(DTableBodyCellIndex.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellIndex.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellIndex.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellIndex.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellIndex.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = rowIndex;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellIndex.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellIndex.prototype.getType = function () {
            return "DTableBodyCellIndex";
        };
        return DTableBodyCellIndex;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputInteger = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputInteger, _super);
        function DTableBodyCellInputInteger(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputInteger.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputInteger.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputInteger.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = Number(value);
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellInputInteger.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputInteger.prototype.getType = function () {
            return "DTableBodyCellInputInteger";
        };
        return DTableBodyCellInputInteger;
    }(DInputInteger));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputReal = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputReal, _super);
        function DTableBodyCellInputReal(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputReal.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputReal.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputReal.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputReal.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputReal.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputReal.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = Number(value);
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellInputReal.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputReal.prototype.getType = function () {
            return "DTableBodyCellInputReal";
        };
        return DTableBodyCellInputReal;
    }(DInputReal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputText = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputText, _super);
        function DTableBodyCellInputText(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellInputText.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        Object.defineProperty(DTableBodyCellInputText.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputText.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputText.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputText.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputText.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = String(value);
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellInputText.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellInputText.prototype.getType = function () {
            return "DTableBodyCellInputText";
        };
        return DTableBodyCellInputText;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTreeInput = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTreeInput, _super);
        function DTableBodyCellInputTreeInput(options) {
            var _this = _super.call(this, options) || this;
            _this._padding = new DBasePaddingAdjustable(_this._padding);
            return _this;
        }
        Object.defineProperty(DTableBodyCellInputTreeInput.prototype, "padding", {
            get: function () {
                return this._padding;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputTreeInput.prototype.getType = function () {
            return "DTableBodyCellInputTreeInput";
        };
        return DTableBodyCellInputTreeInput;
    }(DInputText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellInputTreeMarker = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTreeMarker, _super);
        function DTableBodyCellInputTreeMarker() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableBodyCellInputTreeMarker.prototype.getType = function () {
            return "DTableBodyCellInputTreeMarker";
        };
        return DTableBodyCellInputTreeMarker;
    }(DButtonBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTable} states.
     */
    var DTableState = {
        /**
         * Start cells in rows.
         */
        START: "START",
        /**
         * End cells in rows.
         */
        END: "END",
        /**
         * Cells of frozen columns.
         */
        FROZEN: "FROZEN",
        /**
         * Cells of a right-most frozen column.
         */
        FROZEN_END: "FROZEN_END",
        /**
         * Header cells of sortable columns.
         */
        SORTABLE: "SORTABLE",
        /**
         * Header cells of columns sorted in the ascending order.
         */
        SORTED_ASCENDING: "SORTED_ASCENDING",
        /**
         * Header cells of columns sorted in the descending order.
         */
        SORTED_DESCENDING: "SORTED_DESCENDING",
        /**
         * Tree cells with child cells.
         */
        HAS_CHILDREN: "HAS_CHILDREN",
        /**
         * Tree cells opened.
         */
        OPENED: "OPENED",
        /**
         * Header cells of checkable columns.
         */
        CHECKABLE: "CHECKABLE",
        /**
         * Selectable row
         */
        SELECTABLE: "SELECTABLE"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toBaseOptions = function (options) {
        if (options != null) {
            return {
                weight: options.weight,
                width: options.width
            };
        }
        return undefined;
    };
    var DTableBodyCellInputTree = /** @class */ (function (_super) {
        __extends(DTableBodyCellInputTree, _super);
        function DTableBodyCellInputTree(columnIndex, column, onChange, options) {
            var _this = _super.call(this, toBaseOptions(options)) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            // Input
            var input = _this.newInput(options);
            _this._input = input;
            _this.addChild(input);
            // Marker
            var marker = _this.newMarker(options);
            _this._marker = marker;
            _this.addChild(marker);
            return _this;
        }
        DTableBodyCellInputTree.prototype.newInput = function (options) {
            return new DTableBodyCellInputTreeInput(this.toInputOptions(options));
        };
        DTableBodyCellInputTree.prototype.toInputOptions = function (options) {
            var _this = this;
            return {
                weight: 1,
                text: options === null || options === void 0 ? void 0 : options.text,
                editing: options === null || options === void 0 ? void 0 : options.editing,
                when: options === null || options === void 0 ? void 0 : options.when,
                cursor: options === null || options === void 0 ? void 0 : options.cursor,
                on: {
                    change: function (newValue, oldValue) {
                        _this.onInputChange(newValue, oldValue);
                    }
                }
            };
        };
        DTableBodyCellInputTree.prototype.onInputChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellInputTree.prototype.newMarker = function (options) {
            var _this = this;
            return new DTableBodyCellInputTreeMarker({
                visible: false,
                on: {
                    active: function () {
                        _this.onMarkerActive();
                    }
                }
            });
        };
        DTableBodyCellInputTree.prototype.onMarkerActive = function () {
            if (this._marker.state.is(DTableState.HAS_CHILDREN)) {
                this.toggle();
            }
        };
        Object.defineProperty(DTableBodyCellInputTree.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTree.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTree.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellInputTree.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellInputTree.prototype.toggle = function () {
            var row = this._row;
            if (row === undefined) {
                return;
            }
            var parent = this.parent;
            if (parent == null) {
                return;
            }
            var body = parent.parent;
            if (body == null) {
                return;
            }
            var data = body.data;
            if (data && data.toggle) {
                if (data.isExpanded(row)) {
                    if (data.collapse(row)) {
                        this.emit("collapse", this);
                        data.emit("collapse", row, this);
                    }
                }
                else {
                    if (data.expand(row)) {
                        this.emit("expand", this);
                        data.emit("expand", row, this);
                    }
                }
            }
        };
        DTableBodyCellInputTree.prototype.onRowSelect = function (e, local) {
            if (local.x <= this.position.x + this._input.padding.getLeft()) {
                return true;
            }
            return false;
        };
        DTableBodyCellInputTree.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            var input = this._input;
            input.visible = true;
            input.text = String(value);
            var marker = this._marker;
            if (isNumber(supplimental)) {
                var isOpened = !!(supplimental & 0x1);
                var hasChildren = !!(supplimental & 0x2);
                var level = supplimental >> 2;
                var markerState = marker.state;
                markerState.lock();
                markerState.set(DTableState.HAS_CHILDREN, hasChildren);
                markerState.set(DBaseState.DISABLED, !hasChildren);
                markerState.set(DTableState.OPENED, isOpened);
                markerState.unlock();
                var padding = this.theme.getLevelPadding(level);
                marker.width = padding;
                if (hasChildren) {
                    marker.show();
                }
                else {
                    marker.hide();
                }
                input.padding.adjLeft(padding);
            }
            else {
                marker.state.removeAll(DTableState.OPENED, DTableState.HAS_CHILDREN);
                marker.hide();
                input.padding.adjLeft(0);
            }
            DTableBodyCells.set(this._input, row, columnIndex, this._column);
        };
        DTableBodyCellInputTree.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
            this._input.visible = false;
            this._marker.hide();
        };
        DTableBodyCellInputTree.prototype.getType = function () {
            return "DTableBodyCellInputTree";
        };
        return DTableBodyCellInputTree;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLinkOptions = function (cell, options) {
        if (options) {
            return {
                url: toUrl(cell, options.url),
                target: options.target,
                checker: toChecker(cell, options.checker),
                menu: options.menu
            };
        }
        return undefined;
    };
    var toUrl = function (cell, url) {
        if (isString(url) || url == null) {
            return url;
        }
        else {
            return function () {
                var row = cell.row;
                if (row !== undefined) {
                    return url(row, cell.rowIndex, cell.columnIndex, cell);
                }
                return null;
            };
        }
    };
    var toChecker = function (cell, checker) {
        if (checker != null) {
            return function () {
                var row = cell.row;
                if (row !== undefined) {
                    return checker(row, cell.rowIndex, cell.columnIndex, cell);
                }
                return false;
            };
        }
        return undefined;
    };
    var DTableBodyCellLink = /** @class */ (function (_super) {
        __extends(DTableBodyCellLink, _super);
        function DTableBodyCellLink(columnIndex, column, onChange, options) {
            var _a;
            return _super.call(this, columnIndex, column, onChange, DLinks.toStateOptions((_a = options === null || options === void 0 ? void 0 : options.link) === null || _a === void 0 ? void 0 : _a.target, options)) || this;
        }
        DTableBodyCellLink.prototype.onClick = function (e) {
            if (!this.link.onClick(this, e)) {
                _super.prototype.onClick.call(this, e);
            }
        };
        Object.defineProperty(DTableBodyCellLink.prototype, "link", {
            get: function () {
                var _a;
                var result = this._link;
                if (result == null) {
                    result = new DLink(toLinkOptions(this, (_a = this._options) === null || _a === void 0 ? void 0 : _a.link));
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellLink.prototype.getType = function () {
            return "DTableBodyCellLink";
        };
        DTableBodyCellLink.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            this.link.open(e);
        };
        DTableBodyCellLink.prototype.open = function (inNewWindow) {
            this.link.open(inNewWindow);
        };
        return DTableBodyCellLink;
    }(DTableBodyCellButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectMenu = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectMenu, _super);
        function DTableBodyCellSelectMenu(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellSelectMenu.prototype.onValueChange = function (newValue, oldValue, item) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue, item);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellSelectMenu.prototype.onKeyDownArrowDown = function (e) {
            return false;
        };
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMenu.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectMenu.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.value = value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellSelectMenu.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectMenu.prototype.getType = function () {
            return "DTableBodyCellSelectMenu";
        };
        return DTableBodyCellSelectMenu;
    }(DSelect));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellSelectMultiple = /** @class */ (function (_super) {
        __extends(DTableBodyCellSelectMultiple, _super);
        function DTableBodyCellSelectMultiple(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellSelectMultiple.prototype.onValueChange = function (newValues, oldValues, items) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValues);
                _super.prototype.onValueChange.call(this, newValues, oldValues, items);
                this._onChange(newValues, oldValues, row, rowIndex, columnIndex, this);
            }
        };
        DTableBodyCellSelectMultiple.prototype.onKeyDownArrowDown = function (e) {
            return false;
        };
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellSelectMultiple.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellSelectMultiple.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.values = value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellSelectMultiple.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellSelectMultiple.prototype.getType = function () {
            return "DTableBodyCellSelectMultiple";
        };
        return DTableBodyCellSelectMultiple;
    }(DSelectMultiple));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellTime = /** @class */ (function (_super) {
        __extends(DTableBodyCellTime, _super);
        function DTableBodyCellTime(columnIndex, column, onChange, options) {
            var _this = _super.call(this, options) || this;
            _this._rowIndex = -1;
            _this._columnIndex = columnIndex;
            _this._column = column;
            _this._onChange = onChange;
            return _this;
        }
        DTableBodyCellTime.prototype.onValueChange = function (newValue, oldValue) {
            var row = this._row;
            if (row !== undefined) {
                var rowIndex = this._rowIndex;
                var columnIndex = this._columnIndex;
                this._column.setter(row, columnIndex, newValue);
                _super.prototype.onValueChange.call(this, newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, this);
            }
            else {
                _super.prototype.onValueChange.call(this, newValue, oldValue);
            }
        };
        Object.defineProperty(DTableBodyCellTime.prototype, "row", {
            get: function () {
                return this._row;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "rowIndex", {
            get: function () {
                return this._rowIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyCellTime.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellTime.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                if (forcibly) {
                    this._textValue = value;
                    this._textValueComputed = value;
                    this.onTextChange();
                    this.createOrUpdateText();
                }
                else {
                    this.text = value;
                }
            }
            else if (isNumber(value)) {
                var textValueComputed = this._textValueComputed;
                if (textValueComputed == null) {
                    this.text = new Date(value);
                }
                else if (textValueComputed.getTime() !== value) {
                    textValueComputed.setTime(value);
                    this.onTextChange();
                    this.createOrUpdateText();
                }
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        };
        DTableBodyCellTime.prototype.unset = function () {
            this._row = undefined;
            this._rowIndex = -1;
        };
        DTableBodyCellTime.prototype.getType = function () {
            return "DTableBodyCellTime";
        };
        return DTableBodyCellTime;
    }(DButtonTime));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyCellTree = /** @class */ (function (_super) {
        __extends(DTableBodyCellTree, _super);
        function DTableBodyCellTree(columnIndex, column, onChange, options) {
            var _this = this;
            var _a;
            _this = _super.call(this, columnIndex, column, onChange, DLinks.toStateOptions((_a = options === null || options === void 0 ? void 0 : options.link) === null || _a === void 0 ? void 0 : _a.target, options)) || this;
            _this._padding = new DBasePaddingAdjustable(_this._padding);
            return _this;
        }
        DTableBodyCellTree.prototype.onClick = function (e) {
            var _a;
            if (((_a = this.link) === null || _a === void 0 ? void 0 : _a.onClick(this, e)) !== true) {
                _super.prototype.onClick.call(this, e);
            }
        };
        Object.defineProperty(DTableBodyCellTree.prototype, "link", {
            get: function () {
                var result = this._link;
                if (result === undefined) {
                    result = this.newLink();
                    this._link = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyCellTree.prototype.newLink = function () {
            var _a;
            var options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.link;
            if (options) {
                return new DLink(toLinkOptions(this, options));
            }
            return null;
        };
        DTableBodyCellTree.prototype.onActivate = function (e) {
            var _a;
            _super.prototype.onActivate.call(this, e);
            if (this.state.is(DTableState.HAS_CHILDREN)) {
                this.toggle();
            }
            else {
                (_a = this.link) === null || _a === void 0 ? void 0 : _a.open(e);
            }
        };
        DTableBodyCellTree.prototype.toggle = function () {
            var row = this._row;
            if (row === undefined) {
                return;
            }
            var parent = this.parent;
            if (parent == null) {
                return;
            }
            var body = parent.parent;
            if (body == null) {
                return;
            }
            var data = body.data;
            if (data && data.toggle) {
                if (data.isExpanded(row)) {
                    if (data.collapse(row)) {
                        this.emit("collapse", this);
                        data.emit("collapse", row, this);
                    }
                }
                else {
                    if (data.expand(row)) {
                        this.emit("expand", this);
                        data.emit("expand", row, this);
                    }
                }
            }
        };
        DTableBodyCellTree.prototype.onRowSelect = function (e, local) {
            if (local.x <= this.position.x + this.padding.getLeft()) {
                this.toggle();
                return true;
            }
            return false;
        };
        DTableBodyCellTree.prototype.set = function (value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            DTableBodyCells.set(this, row, columnIndex, this._column, false);
            var link = this.link;
            var padding = this._padding;
            if (isNumber(supplimental)) {
                var isOpened = !!(supplimental & 0x1);
                var hasChildren = !!(supplimental & 0x2);
                var level = supplimental >> 2;
                var state = this.state;
                state.lock();
                state.set(DTableState.HAS_CHILDREN, hasChildren);
                state.set(DTableState.OPENED, isOpened);
                state.unlock();
                padding.adjLeft(this.theme.getLevelPadding(level));
                if (link) {
                    link.menu.enable = !hasChildren;
                }
            }
            else {
                this.state.removeAll(DTableState.OPENED, DTableState.HAS_CHILDREN);
                padding.adjLeft(0);
                if (link) {
                    link.menu.enable = false;
                }
            }
        };
        DTableBodyCellTree.prototype.getType = function () {
            return "DTableBodyCellTree";
        };
        return DTableBodyCellTree;
    }(DTableBodyCellButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTableDataSelection} type.
     */
    var DTableDataSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableRow = /** @class */ (function (_super) {
        __extends(DTableRow, _super);
        function DTableRow(options) {
            var _this = this;
            var _a, _b;
            _this = _super.call(this, options) || this;
            _this._reverse = true;
            _this._frozen = (_a = options.frozen) !== null && _a !== void 0 ? _a : 0;
            _this._columns = (_b = options.columns) !== null && _b !== void 0 ? _b : [];
            return _this;
        }
        DTableRow.prototype.initCells = function (options, columns, frozen) {
            var iend = this.toIndexEnd(columns);
            for (var i = columns.length - 1; 0 <= i; --i) {
                var cell = this.newCell(i, columns[i], columns, options);
                var cellState = cell.state;
                cellState.lock(false);
                if (i === 0) {
                    cellState.add(DTableState.START);
                }
                if (i === iend) {
                    cellState.add(DTableState.END);
                }
                if (i < frozen) {
                    cellState.add(DTableState.FROZEN);
                }
                if (i === frozen - 1) {
                    cellState.add(DTableState.FROZEN_END);
                }
                cellState.unlock();
                this.addChild(cell);
            }
        };
        DTableRow.prototype.toIndexEnd = function (columns) {
            var imax = columns.length;
            for (var i = 0; i < imax; ++i) {
                var column = columns[i];
                if (column.weight !== undefined) {
                    return imax - 1;
                }
            }
            return imax;
        };
        DTableRow.prototype.onRefit = function () {
            _super.prototype.onRefit.call(this);
            this.resetFrozenCellPosition();
        };
        DTableRow.prototype.updateFrozenCellPosition = function (x) {
            var columns = this._columns;
            var cells = this.children;
            var cellsLength = cells.length;
            var frozen = this._frozen;
            for (var i = 0; i < frozen; ++i) {
                var column = columns[i];
                var cell = cells[cellsLength - 1 - i];
                cell.position.x = -x + column.offset;
            }
        };
        DTableRow.prototype.resetFrozenCellPosition = function () {
            var columns = this._columns;
            var cells = this.children;
            var cellsLength = cells.length;
            var frozen = this._frozen;
            var x = this.getContentPositionX();
            for (var i = 0; i < frozen; ++i) {
                var column = columns[i];
                var cell = cells[cellsLength - 1 - i];
                column.offset = cell.position.x;
                cell.position.x = -x + column.offset;
            }
        };
        DTableRow.prototype.getClippingRect = function (target, result) {
            _super.prototype.getClippingRect.call(this, target, result);
            var frozen = this._frozen;
            if (0 < frozen) {
                var cell = target;
                if (cell && cell.parent === this) {
                    var cells = this.children;
                    var cellIndex = cells.indexOf(cell);
                    if (0 <= cellIndex) {
                        var columnIndex = cells.length - 1 - cellIndex;
                        if (frozen <= columnIndex) {
                            var previous = cells[cellIndex + 1];
                            var shiftX = previous.position.x + previous.width;
                            result.x += shiftX;
                            result.width -= shiftX;
                        }
                    }
                }
            }
        };
        DTableRow.prototype.getType = function () {
            return "DTableRow";
        };
        return DTableRow;
    }(DLayoutHorizontal));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableBodyRow = /** @class */ (function (_super) {
        __extends(DTableBodyRow, _super);
        function DTableBodyRow(onChange, isEven, columnIndexToCellOptions, options) {
            var _this = _super.call(this, options) || this;
            _this._index = -1;
            _this._onCellChangeBound = function (newValue, oldValue, row, rowIndex, columnIndex) {
                _this.emit("change", newValue, oldValue, row, rowIndex, columnIndex, _this);
                onChange(newValue, oldValue, row, rowIndex, columnIndex, _this);
            };
            _this._columnIndexToCellOptions = columnIndexToCellOptions;
            _this.state.isAlternated = !isEven;
            _this.initCells(options, _this._columns, _this._frozen);
            return _this;
        }
        DTableBodyRow.prototype.newCell = function (columnIndex, column, columns, options) {
            var onChange = this._onCellChangeBound;
            var columnIndexToCellOptions = this._columnIndexToCellOptions;
            var cellOptions = columnIndexToCellOptions.get(columnIndex);
            if (cellOptions == null) {
                cellOptions = this.toCellOptions(columnIndex, column, options);
                columnIndexToCellOptions.set(columnIndex, cellOptions);
            }
            if (column.editing.enable !== false) {
                return this.newCellEditable(columnIndex, column, onChange, cellOptions);
            }
            else {
                var cell = this.newCellUnediable(columnIndex, column, onChange, cellOptions);
                if (column.type !== DTableColumnType.TREE) {
                    cell.state.isReadOnly = true;
                }
                return cell;
            }
        };
        DTableBodyRow.prototype.newCellEditable = function (columnIndex, column, onChange, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellInputText(columnIndex, column, onChange, options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellInputTree(columnIndex, column, onChange, options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellInputInteger(columnIndex, column, onChange, options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellInputReal(columnIndex, column, onChange, options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(columnIndex, column, onChange, options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(columnIndex, column, onChange, options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(columnIndex, column, onChange, options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(columnIndex, column, onChange, options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(columnIndex, column, onChange, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(columnIndex, column, onChange, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(columnIndex, column, onChange, options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(columnIndex, column, onChange, options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(columnIndex, column, onChange, options);
                default:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.newCellUnediable = function (columnIndex, column, onChange, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellTree(columnIndex, column, onChange, options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(columnIndex, column, onChange, options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(columnIndex, column, onChange, options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(columnIndex, column, onChange, options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(columnIndex, column, onChange, options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(columnIndex, column, onChange, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(columnIndex, column, onChange, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(columnIndex, column, onChange, options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(columnIndex, column, onChange, options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(columnIndex, column, onChange, options);
                default:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.newCellSelect = function (columnIndex, column, onChange, options) {
            var selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellSelectMenu(columnIndex, column, onChange, options);
            }
            else if (selecting.multiple != null) {
                return new DTableBodyCellSelectMultiple(columnIndex, column, onChange, options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellSelectDialog(columnIndex, column, onChange, options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellSelectPromise(columnIndex, column, onChange, options);
            }
            else {
                return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.newCellAction = function (columnIndex, column, onChange, options) {
            var selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellActionMenu(columnIndex, column, onChange, options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellActionDialog(columnIndex, column, onChange, options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellActionPromise(columnIndex, column, onChange, options);
            }
            else {
                return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        };
        DTableBodyRow.prototype.toCellOptions = function (columnIndex, column, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            var _p;
            var result = toMerged(column.body, options.cell);
            // Weight
            result.weight = column.weight;
            // Width
            result.width = column.width;
            // State
            (_a = result.state) !== null && _a !== void 0 ? _a : (result.state = column.state.initial);
            // Text formatter
            var columnFormatter = column.formatter;
            if (columnFormatter != null) {
                var text = ((_b = result.text) !== null && _b !== void 0 ? _b : (result.text = {}));
                (_c = text.formatter) !== null && _c !== void 0 ? _c : (text.formatter = columnFormatter);
            }
            // Text align horizontal
            var columnAlign = column.align;
            if (columnAlign != null) {
                var text = ((_d = result.text) !== null && _d !== void 0 ? _d : (result.text = {}));
                var textAlign = ((_e = text.align) !== null && _e !== void 0 ? _e : (text.align = {}));
                (_f = textAlign.horizontal) !== null && _f !== void 0 ? _f : (textAlign.horizontal = columnAlign);
            }
            // Editing
            var columnEditing = column.editing;
            if (columnEditing.enable !== false) {
                var editing = ((_g = (_p = result).editing) !== null && _g !== void 0 ? _g : (_p.editing = {}));
                (_h = editing.formatter) !== null && _h !== void 0 ? _h : (editing.formatter = columnEditing.formatter);
                (_j = editing.unformatter) !== null && _j !== void 0 ? _j : (editing.unformatter = columnEditing.unformatter);
                (_k = editing.validator) !== null && _k !== void 0 ? _k : (editing.validator = columnEditing.validator);
            }
            // Link
            var columnLink = column.link;
            if (columnLink !== undefined) {
                result.link = columnLink;
            }
            // Selecting
            var columnSelecting = column.selecting;
            var columnSelectingMenu = (_l = columnSelecting.menu) !== null && _l !== void 0 ? _l : columnSelecting.multiple;
            if (columnSelectingMenu !== undefined) {
                result.menu = columnSelectingMenu;
            }
            var selectionType = (_o = (_m = options === null || options === void 0 ? void 0 : options.selection) === null || _m === void 0 ? void 0 : _m.type) !== null && _o !== void 0 ? _o : DTableDataSelectionType.NONE;
            if (selectionType !== DTableDataSelectionType.NONE) {
                result.when = "DOUBLE_CLICKED";
                result.cursor = function (state) {
                    if (state.in(DTableState.SELECTABLE)) {
                        return "pointer";
                    }
                    return undefined;
                };
            }
            return result;
        };
        DTableBodyRow.prototype.getType = function () {
            return "DTableBodyRow";
        };
        Object.defineProperty(DTableBodyRow.prototype, "value", {
            /**
             * Returns a row data if exists.
             * Returns undefined if a row data does not exit.
             *
             * @returns a row data or undefined.
             */
            get: function () {
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableBodyRow.prototype, "index", {
            /**
             * Returns a row index if a row data exists.
             * Returns -1 if a row data does not exit.
             *
             * @returns a row index or -1.
             */
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        DTableBodyRow.prototype.isCell = function (target) {
            return target != null && "set" in target;
        };
        DTableBodyRow.prototype.set = function (value, supplimental, rowIndex, forcibly) {
            if (forcibly || this._value !== value || this._index !== rowIndex) {
                this._value = value;
                this._index = rowIndex;
                var cells = this.children;
                var cellsLength = cells.length;
                var columns = this._columns;
                var columnsLength = columns.length;
                for (var i = 0; i < cellsLength; ++i) {
                    var cell = cells[i];
                    var columnIndex = columnsLength - 1 - i;
                    var column = columns[columnIndex];
                    if (this.isCell(cell)) {
                        cell.set(column.getter(value, columnIndex), value, supplimental, rowIndex, columnIndex, forcibly);
                    }
                }
                this.onSet(value, rowIndex);
            }
        };
        DTableBodyRow.prototype.onSet = function (value, rowIndex) {
            this.emit("set", value, rowIndex, this);
        };
        DTableBodyRow.prototype.unset = function () {
            if (this._value !== undefined) {
                this._value = undefined;
                this._index = -1;
                var cells = this.children;
                var cellsLength = cells.length;
                for (var i = 0; i < cellsLength; ++i) {
                    var cell = cells[i];
                    if (this.isCell(cell)) {
                        cell.unset();
                    }
                }
                this.onUnset();
            }
        };
        DTableBodyRow.prototype.onUnset = function () {
            this.emit("unset", this);
        };
        DTableBodyRow.prototype.getContentPositionX = function () {
            var parent = this.parent;
            if (parent) {
                var content = parent.parent;
                if (content) {
                    return content.position.x;
                }
            }
            return 0;
        };
        return DTableBodyRow;
    }(DTableRow));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataListFilter = /** @class */ (function (_super) {
        __extends(DTableDataListFilter, _super);
        function DTableDataListFilter(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._sorterId = -1;
            _this._parent = parent;
            _this._filter = null;
            _this._filtered = null;
            return _this;
        }
        Object.defineProperty(DTableDataListFilter.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListFilter.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataListFilter.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataListFilter.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataListFilter.prototype.newFiltered = function () {
            var filter = this._filter;
            if (filter != null) {
                var filtered = [];
                var parent_1 = this._parent;
                var sorter = parent_1.sorter;
                var rows = parent_1.rows;
                if (isFunction(filter)) {
                    var indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (var i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            var indexSorted = indicesSorted[i];
                            if (filter(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (var i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                else {
                    var indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (var i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            var indexSorted = indicesSorted[i];
                            if (filter.test(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (var i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter.test(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                return filtered;
            }
            else {
                return null;
            }
        };
        DTableDataListFilter.prototype.get = function () {
            return this._filter;
        };
        DTableDataListFilter.prototype.set = function (filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        };
        DTableDataListFilter.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataListFilter.prototype.update = function () {
            if (this._id !== this._idUpdated || this._parent.sorter.id !== this._sorterId) {
                this._idUpdated = this._id;
                this._sorterId = this._parent.sorter.id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataListFilter.prototype, "indices", {
            get: function () {
                this.update();
                return this._filtered;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListFilter.prototype.map = function (sortedIndex) {
            var result = sortedIndex;
            var indicesFiltered = this.indices;
            if (indicesFiltered) {
                var index = indicesFiltered.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataListFilter.prototype.unmap = function (index) {
            var result = index;
            var indicesFiltered = this.indices;
            if (indicesFiltered) {
                result = indicesFiltered[result];
            }
            return result;
        };
        return DTableDataListFilter;
    }(pixi_js.utils.EventEmitter));

    var DTableDataListMapped = /** @class */ (function () {
        function DTableDataListMapped(parent) {
            this._parent = parent;
        }
        Object.defineProperty(DTableDataListMapped.prototype, "rows", {
            get: function () {
                var result = [];
                this.each(function (row) {
                    result.push(row);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListMapped.prototype.map = function (unmappedIndex) {
            var parent = this._parent;
            var sortedIndex = parent.sorter.map(unmappedIndex);
            if (sortedIndex != null) {
                return parent.filter.map(sortedIndex);
            }
            return null;
        };
        DTableDataListMapped.prototype.unmap = function (index) {
            var parent = this._parent;
            return parent.sorter.unmap(parent.filter.unmap(index));
        };
        DTableDataListMapped.prototype.size = function () {
            var parent = this._parent;
            var indicesFiltered = parent.filter.indices;
            return indicesFiltered != null ? indicesFiltered.length : parent.size();
        };
        DTableDataListMapped.prototype.get = function (index) {
            var parent = this._parent;
            return parent.get(this.unmap(index));
        };
        DTableDataListMapped.prototype.each = function (iteratee, ifrom, ito) {
            var parent = this._parent;
            var rows = parent.rows;
            var supplimentals = parent.supplimentals;
            var indicesFiltered = parent.filter.indices;
            var indicesSorted = parent.sorter.indices;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            if (indicesFiltered) {
                var size = indicesFiltered.length;
                ito = ito != null ? Math.min(size, ito) : size;
                if (indicesSorted) {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesSorted[indicesFiltered[i]];
                        var row = rows[unmappedIndex];
                        var supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesFiltered[i];
                        var row = rows[unmappedIndex];
                        var supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
            }
            else {
                var size = rows.length;
                ito = ito != null ? Math.min(size, ito) : size;
                if (indicesSorted) {
                    for (var i = ifrom; i < ito; ++i) {
                        var unmappedIndex = indicesSorted[i];
                        var row = rows[unmappedIndex];
                        var supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (var i = ifrom; i < ito; ++i) {
                        var row = rows[i];
                        var supplimental = supplimentals ? supplimentals[i] : null;
                        if (iteratee(row, supplimental, i, i) === false) {
                            break;
                        }
                    }
                }
            }
        };
        return DTableDataListMapped;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var COMPARATOR$1 = function (a, b) {
        return a[0] - b[0];
    };
    var DTableDataListSelection = /** @class */ (function (_super) {
        __extends(DTableDataListSelection, _super);
        function DTableDataListSelection(parent, options) {
            var _this = this;
            var _a;
            _this = _super.call(this) || this;
            _this._parent = parent;
            _this._type = toEnum((_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : DTableDataSelectionType.NONE, DTableDataSelectionType);
            _this._indices = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTableDataListSelection.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSelection.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSelection.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTableDataListSelection.prototype.toggle = function (rowIndex) {
            var indices = this._indices;
            if (indices.has(rowIndex)) {
                indices.delete(rowIndex);
            }
            else {
                indices.add(rowIndex);
            }
            this.onChange();
        };
        DTableDataListSelection.prototype.add = function (rowIndex) {
            var indices = this._indices;
            var oldSize = indices.size;
            indices.add(rowIndex);
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        Object.defineProperty(DTableDataListSelection.prototype, "first", {
            get: function () {
                var indices = this._indices;
                if (0 < indices.size) {
                    var result_1 = NaN;
                    indices.forEach(function (index) {
                        if (result_1 !== result_1) {
                            result_1 = index;
                        }
                    });
                    return result_1;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSelection.prototype, "last", {
            get: function () {
                var indices = this._indices;
                if (0 < indices.size) {
                    var result_2 = 0;
                    indices.forEach(function (index) {
                        result_2 = index;
                    });
                    return result_2;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSelection.prototype.addTo = function (rowIndex) {
            var lastRowIndex = this.last;
            if (lastRowIndex != null) {
                this.addRange(lastRowIndex, false, rowIndex, true);
            }
        };
        DTableDataListSelection.prototype.addRange = function (from, includeFrom, to, includeTo) {
            var indices = this._indices;
            var oldSize = indices.size;
            if (from < to) {
                var ifrom = from + (includeFrom ? 0 : 1);
                var ito = to + (includeTo ? 1 : 0);
                for (var i = ifrom; i < ito; ++i) {
                    indices.add(i);
                }
            }
            else {
                var ifrom = to + (includeTo ? 0 : 1);
                var ito = from + (includeFrom ? 1 : 0);
                for (var i = ifrom; i < ito; ++i) {
                    indices.add(i);
                }
            }
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.addAll = function (rowIndices) {
            var indices = this._indices;
            var oldSize = indices.size;
            for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                indices.add(rowIndices[i]);
            }
            var newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.contains = function (rowIndex) {
            return this._indices.has(rowIndex);
        };
        DTableDataListSelection.prototype.remove = function (rowIndex) {
            if (this._indices.delete(rowIndex)) {
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.clear = function () {
            var indices = this._indices;
            if (0 < indices.size) {
                indices.clear();
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.clearAndAdd = function (rowIndex) {
            var indices = this._indices;
            if (!indices.has(rowIndex) || indices.size !== 1) {
                indices.clear();
                indices.add(rowIndex);
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.clearAndAddAll = function (rowIndices) {
            var indices = this._indices;
            if (0 < indices.size || 0 < rowIndices.length) {
                indices.clear();
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    indices.add(rowIndices[i]);
                }
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.shift = function (rowIndex, amount) {
            var shifted = [];
            var indices = this._indices;
            indices.forEach(function (index) {
                if (rowIndex <= index) {
                    shifted.push(index);
                }
            });
            var shiftedLength = shifted.length;
            if (0 < shiftedLength) {
                for (var i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.delete(shifted[i]);
                }
                for (var i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.add(shifted[i] + amount);
                }
                this.onChange();
            }
        };
        DTableDataListSelection.prototype.size = function () {
            return this._indices.size;
        };
        DTableDataListSelection.prototype.isEmpty = function () {
            return this._indices.size === 0;
        };
        DTableDataListSelection.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._indices.forEach(function (index) {
                if (!isCanceled) {
                    if (iteratee(index) === false) {
                        isCanceled = true;
                    }
                }
            });
        };
        Object.defineProperty(DTableDataListSelection.prototype, "indices", {
            /**
             * Returns a copy of an index array of selected rows.
             * The order of indices is an insertion order.
             */
            get: function () {
                var result = [];
                this._indices.forEach(function (index) {
                    result.push(index);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSelection.prototype, "rows", {
            /**
             * Returns a copy of an array of selected row value.
             * The order is an insertion order.
             */
            get: function () {
                var result = [];
                var parent = this._parent;
                this._indices.forEach(function (index) {
                    result.push(parent.get(index));
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns an array of the (index, row value) pairs of selected rows.
         * The order of pairs is an insertion order.
         */
        DTableDataListSelection.prototype.toArray = function () {
            var result = [];
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result.push([index, parent.get(index)]);
            });
            return result;
        };
        /**
         * Returns an sorted array of the (index, row value) pairs of selected rows.
         */
        DTableDataListSelection.prototype.toSortedArray = function () {
            return this.toArray().sort(COMPARATOR$1);
        };
        DTableDataListSelection.prototype.toObject = function () {
            var result = {};
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result[index] = parent.get(index);
            });
            return result;
        };
        DTableDataListSelection.prototype.toMap = function () {
            var result = new Map();
            var parent = this._parent;
            this._indices.forEach(function (index) {
                result.set(index, parent.get(index));
            });
            return result;
        };
        return DTableDataListSelection;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A sort order.
     */
    var DTableDataOrder = {
        ASCENDING: 0,
        DESCENDING: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataListSorter = /** @class */ (function (_super) {
        __extends(DTableDataListSorter, _super);
        function DTableDataListSorter(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._parent = parent;
            _this._comparator = null;
            _this._sorted = null;
            _this._order = DTableDataOrder.ASCENDING;
            return _this;
        }
        Object.defineProperty(DTableDataListSorter.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataListSorter.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (order) {
                this._order = order;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSorter.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataListSorter.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataListSorter.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataListSorter.prototype.newSorted = function () {
            var comparator = this._comparator;
            if (comparator != null) {
                var parent_1 = this._parent;
                var sorted = [];
                var rows = parent_1.rows;
                for (var i = 0, imax = rows.length; i < imax; ++i) {
                    sorted.push(i);
                }
                sorted.sort(this.toComparator(rows, comparator));
                return sorted;
            }
            else {
                return null;
            }
        };
        DTableDataListSorter.prototype.toComparator = function (rows, comparator) {
            var order = this._order;
            if (isFunction(comparator)) {
                if (order === DTableDataOrder.ASCENDING) {
                    return function (indexA, indexB) {
                        return comparator(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return function (indexA, indexB) {
                        return comparator(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
            else {
                if (order === DTableDataOrder.ASCENDING) {
                    return function (indexA, indexB) {
                        return comparator.compare(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return function (indexA, indexB) {
                        return comparator.compare(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
        };
        DTableDataListSorter.prototype.get = function () {
            return this._comparator;
        };
        DTableDataListSorter.prototype.set = function (comparator) {
            if (this._comparator !== comparator) {
                this._comparator = comparator;
            }
        };
        DTableDataListSorter.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataListSorter.prototype.update = function () {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._sorted = this.newSorted();
                    this.emit("change", this);
                }
                else if (this._sorted != null) {
                    this._sorted = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataListSorter.prototype, "indices", {
            get: function () {
                this.update();
                return this._sorted;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataListSorter.prototype.map = function (unmappedIndex) {
            var result = unmappedIndex;
            var indicesSorted = this.indices;
            if (indicesSorted) {
                var index = indicesSorted.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataListSorter.prototype.unmap = function (index) {
            var result = index;
            var indicesSorted = this.indices;
            if (indicesSorted) {
                result = indicesSorted[result];
            }
            return result;
        };
        return DTableDataListSorter;
    }(pixi_js.utils.EventEmitter));

    var DTableDataList = /** @class */ (function (_super) {
        __extends(DTableDataList, _super);
        function DTableDataList(options) {
            var _this = _super.call(this) || this;
            _this._parent = null;
            _this._rows = _this.toRows(options === null || options === void 0 ? void 0 : options.rows);
            _this._mapped = new DTableDataListMapped(_this);
            _this._selection = _this.toSelection(options === null || options === void 0 ? void 0 : options.selection);
            _this._filter = new DTableDataListFilter(_this);
            _this._sorter = new DTableDataListSorter(_this);
            if (options) {
                // Filter
                var filter = options.filter;
                if (filter) {
                    _this._filter.set(filter);
                }
                // Comparator
                var comparator = options.comparator;
                if (comparator) {
                    _this._sorter.set(comparator);
                }
                // Events
                var on = options.on;
                if (on) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            return _this;
        }
        DTableDataList.prototype.toSelection = function (options) {
            if (options instanceof pixi_js.utils.EventEmitter) {
                return options;
            }
            else if (isFunction(options)) {
                return options(this);
            }
            return this.newSelection(options);
        };
        DTableDataList.prototype.newSelection = function (options) {
            return new DTableDataListSelection(this, options);
        };
        DTableDataList.prototype.bind = function (parent) {
            this._parent = parent;
        };
        DTableDataList.prototype.toRows = function (row) {
            var result = [];
            if (row != null) {
                for (var i = 0, imax = row.length; i < imax; ++i) {
                    result.push(row[i]);
                }
            }
            return result;
        };
        Object.defineProperty(DTableDataList.prototype, "rows", {
            get: function () {
                return this._rows;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataList.prototype.update = function () {
            var parent = this._parent;
            if (parent) {
                parent.update();
            }
        };
        DTableDataList.prototype.lock = function () {
            var parent = this._parent;
            if (parent) {
                parent.lock();
            }
        };
        DTableDataList.prototype.unlock = function () {
            var parent = this._parent;
            if (parent) {
                parent.unlock(false);
                parent.update();
            }
        };
        DTableDataList.prototype.size = function () {
            return this._rows.length;
        };
        DTableDataList.prototype.clear = function () {
            var rows = this._rows;
            if (0 < rows.length) {
                rows.length = 0;
                this.lock();
                this._selection.clear();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.unlock();
            }
        };
        DTableDataList.prototype.clearAndAdd = function (row) {
            var rows = this._rows;
            rows.length = 0;
            rows.push(row);
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.unlock();
        };
        DTableDataList.prototype.clearAndAddAll = function (newRows) {
            var rows = this._rows;
            rows.length = 0;
            for (var i = 0, imax = newRows.length; i < imax; ++i) {
                rows.push(newRows[i]);
            }
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.unlock();
        };
        DTableDataList.prototype.add = function (row, index) {
            var rows = this._rows;
            var selection = this._selection;
            var sorter = this._sorter;
            var filter = this._filter;
            if (index == null) {
                rows.push(row);
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
            else if (0 <= index && index < rows.length) {
                rows.splice(index, 0, row);
                this.lock();
                selection.shift(index, 1);
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
        };
        DTableDataList.prototype.addAll = function (newRows, index) {
            var rows = this._rows;
            var rowsLength = rows.length;
            var selection = this._selection;
            var sorter = this._sorter;
            var filter = this._filter;
            if (index == null) {
                var newRowsLength = newRows.length;
                for (var i = 0, imax = newRowsLength; i < imax; ++i) {
                    rows.push(newRows[i]);
                }
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
            else if (0 <= index && index < rowsLength) {
                var newRowsLength = newRows.length;
                for (var i = 0; i < newRowsLength; ++i) {
                    rows.splice(index + i, 0, newRows[i]);
                }
                this.lock();
                selection.shift(index, newRowsLength);
                sorter.toDirty();
                filter.toDirty();
                this.unlock();
            }
        };
        DTableDataList.prototype.get = function (index) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableDataList.prototype.set = function (index, row) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                var result = rows[index];
                rows[index] = row;
                this.lock();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.unlock();
                return result;
            }
            return null;
        };
        DTableDataList.prototype.remove = function (index) {
            var rows = this._rows;
            if (0 <= index && index < rows.length) {
                var result = rows.splice(index, 1)[0];
                this.lock();
                this._selection.remove(index);
                this._sorter.toDirty();
                this._filter.toDirty();
                this.unlock();
                return result;
            }
            return null;
        };
        DTableDataList.prototype.each = function (iteratee, ifrom, ito) {
            var rows = this._rows;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            ito = ito != null ? Math.min(rows.length, ito) : rows.length;
            for (var i = ifrom; i < ito; ++i) {
                var row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        };
        Object.defineProperty(DTableDataList.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "filter", {
            get: function () {
                return this._filter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "sorter", {
            get: function () {
                return this._sorter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataList.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        return DTableDataList;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toRowOptions = function (theme, options, selectionType) {
        var columns = options.columns || [];
        var result = options.row;
        if (result != null) {
            if (result.height == null) {
                result.height = theme.getRowHeight();
            }
            if (result.columns === undefined) {
                result.columns = columns;
            }
            if (result.frozen == null) {
                result.frozen = options.frozen;
            }
            if (result.selection === undefined) {
                result.selection = {
                    type: selectionType
                };
            }
            else if (result.selection.type === undefined) {
                result.selection.type = selectionType;
            }
        }
        else {
            result = {
                columns: columns,
                height: theme.getRowHeight(),
                frozen: options.frozen,
                selection: {
                    type: selectionType
                }
            };
        }
        return result;
    };
    var DTableBody = /** @class */ (function (_super) {
        __extends(DTableBody, _super);
        function DTableBody(options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            _this.transform.position.y = (_a = options.offset) !== null && _a !== void 0 ? _a : 0;
            var data = _this.toData(options.data);
            _this._data = data;
            data.bind(_this);
            var theme = _this.theme;
            var rowOptions = toRowOptions(theme, options, data.selection.type);
            _this._rowOptions = rowOptions;
            _this._rowHeight = rowOptions.height != null ? rowOptions.height : theme.getRowHeight();
            _this._columns = rowOptions.columns || [];
            _this._rowIndexMappedStart = 0;
            _this._rowIndexMappedEnd = 0;
            _this._updateRowsCount = 0;
            _this._isUpdateRowsCalled = false;
            _this._isUpdateRowsCalledForcibly = false;
            _this._workRows = [];
            _this._onRowChangeBound = function (newValue, oldValue, row, rowIndex, columnIndex) {
                data.emit("change", newValue, oldValue, row, rowIndex, columnIndex, data);
            };
            _this._columnIndexToCellOptions = new Map();
            _this._data.emit("init", _this._data);
            return _this;
        }
        DTableBody.prototype.toData = function (options) {
            if (this.isData(options)) {
                return options;
            }
            return new DTableDataList(options);
        };
        DTableBody.prototype.isData = function (target) {
            return target != null && "mapped" in target;
        };
        DTableBody.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            this.update();
        };
        Object.defineProperty(DTableBody.prototype, "selection", {
            get: function () {
                return this._data.selection;
            },
            enumerable: false,
            configurable: true
        });
        DTableBody.prototype.lock = function () {
            this._updateRowsCount += 1;
            if (this._updateRowsCount === 1) {
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        };
        DTableBody.prototype.unlock = function (callIfNeeded) {
            this._updateRowsCount -= 1;
            if (this._updateRowsCount === 0) {
                if (callIfNeeded && this._isUpdateRowsCalled) {
                    this.update(this._isUpdateRowsCalledForcibly);
                }
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        };
        /**
         * Updates rows. If the `forcibly` is true, some dirty checkings for
         * avoiding unnecessary state changes are skipped.
         *
         * @param forcibly true to update forcibly
         */
        DTableBody.prototype.update = function (forcibly) {
            if (0 < this._updateRowsCount) {
                this._isUpdateRowsCalled = true;
                if (forcibly) {
                    this._isUpdateRowsCalledForcibly = true;
                }
                return;
            }
            var content = this.parent;
            if (content == null) {
                return;
            }
            var contentParent = content.parent;
            if (contentParent == null) {
                return;
            }
            var rows = this.children;
            var height = contentParent.height;
            var rowHeight = this._rowHeight;
            var data = this._data;
            var dataMappedSize = data.mapped.size();
            var oldRowIndexMappedStart = this._rowIndexMappedStart;
            var oldRowIndexMappedEnd = this._rowIndexMappedEnd;
            var oldRowCount = oldRowIndexMappedEnd - oldRowIndexMappedStart;
            var y = this.transform.position.y;
            var newHeight = y + dataMappedSize * rowHeight;
            var newContentHeight = Math.max(height, newHeight);
            var newContentY = Math.max(height - newContentHeight, content.position.y);
            var newRowIndexMappedLowerBound = -newContentY / rowHeight;
            var newRowIndexMappedUpperBound = (height - (newContentY + y)) / rowHeight;
            var newRowIndexMappedStart = Math.floor(newRowIndexMappedLowerBound);
            newRowIndexMappedStart -= newRowIndexMappedStart % 2 === 0 ? 2 : 1;
            var newRowIndexMappedEnd = Math.floor(newRowIndexMappedUpperBound);
            newRowIndexMappedEnd += (newRowIndexMappedEnd - newRowIndexMappedStart) % 2 === 1 ? 3 : 2;
            var newRowCount = newRowIndexMappedEnd - newRowIndexMappedStart;
            if (newRowCount < oldRowCount && oldRowCount - 2 <= newRowCount) {
                newRowCount = oldRowCount;
                newRowIndexMappedEnd = newRowIndexMappedStart + newRowCount;
            }
            if (oldRowCount < newRowCount) {
                for (var i = oldRowCount; i < newRowCount; ++i) {
                    var oldRowIndexMapped = oldRowIndexMappedStart + i;
                    var newRow = this.newRow(oldRowIndexMapped % 2 === 0);
                    this.addChild(newRow);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            else if (newRowCount < oldRowCount) {
                for (var i = oldRowCount - 1; newRowCount <= i; --i) {
                    this.removeChild(rows[i]);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            this._rowIndexMappedStart = newRowIndexMappedStart;
            this._rowIndexMappedEnd = newRowIndexMappedEnd;
            var rowIndexMappedStartDelta = newRowIndexMappedStart - oldRowIndexMappedStart;
            var rowIndexMappedStartDeltaAbs = Math.abs(rowIndexMappedStartDelta);
            var rowsLength = rows.length;
            if (0 < rowIndexMappedStartDeltaAbs && rowIndexMappedStartDeltaAbs < rowsLength) {
                var work = this._workRows;
                if (0 < rowIndexMappedStartDelta) {
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[i]));
                    }
                    for (var i = rowIndexMappedStartDeltaAbs; i < rowsLength; ++i) {
                        rows[i - rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[rowsLength - rowIndexMappedStartDeltaAbs + i] = work[i];
                    }
                }
                else {
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[rowsLength - rowIndexMappedStartDeltaAbs + i]));
                    }
                    for (var i = rowsLength - rowIndexMappedStartDeltaAbs - 1; 0 <= i; --i) {
                        rows[i + rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (var i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[i] = work[i];
                    }
                }
                work.length = 0;
            }
            var selection = data.selection;
            var isRowSelectable = selection.type !== DTableDataSelectionType.NONE;
            data.mapped.each(function (datum, supplimental, index, unmappedIndex) {
                var row = rows[index - newRowIndexMappedStart];
                // Position
                row.position.y = index * rowHeight;
                // State
                var rowState = row.state;
                rowState.lock();
                rowState.set(DTableState.SELECTABLE, isRowSelectable);
                rowState.set(DBaseState.ACTIVE, selection.contains(unmappedIndex));
                rowState.remove(DBaseState.DISABLED);
                rowState.unlock();
                // Data
                row.set(datum, supplimental, unmappedIndex, forcibly);
            }, newRowIndexMappedStart, newRowIndexMappedStart + rowsLength);
            for (var i = 0; newRowIndexMappedStart + i < 0 && i < rowsLength; ++i) {
                var row = rows[i];
                // Position
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                // State
                var rowState = row.state;
                rowState.lock();
                rowState.add(DBaseState.DISABLED);
                rowState.removeAll(DTableState.SELECTABLE, DBaseState.ACTIVE);
                rowState.unlock();
                // Data
                row.unset();
            }
            for (var i = rowsLength - 1; dataMappedSize <= newRowIndexMappedStart + i && 0 <= i; --i) {
                var row = rows[i];
                // Position
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                // State
                var rowState = row.state;
                rowState.lock();
                rowState.add(DBaseState.DISABLED);
                rowState.removeAll(DTableState.SELECTABLE, DBaseState.ACTIVE);
                rowState.unlock();
                // Data
                row.unset();
            }
            this.lock();
            content.position.y = newContentY;
            content.height = newContentHeight;
            this.height = newHeight;
            this.unlock(false);
            this.emit("update", newRowIndexMappedLowerBound, newRowIndexMappedUpperBound, this);
        };
        DTableBody.prototype.resetRow = function (row) {
            row.blur(true);
            var cells = row.children;
            for (var i = 0, imax = cells.length; i < imax; ++i) {
                var cell = cells[i];
                if (cell instanceof DBase) {
                    cell.state.isPressed = false;
                }
            }
            return row;
        };
        DTableBody.prototype.newRow = function (isEven) {
            return new DTableBodyRow(this._onRowChangeBound, isEven, this._columnIndexToCellOptions, this._rowOptions);
        };
        DTableBody.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            _super.prototype.onParentMove.call(this, newX, newY, oldX, oldY);
            this.updateFrozenCellPosition(newX);
        };
        DTableBody.prototype.updateFrozenCellPosition = function (x) {
            var frozen = this._rowOptions.frozen;
            if (frozen != null && 0 < frozen) {
                var rows = this.children;
                for (var i = 0, imax = rows.length; i < imax; ++i) {
                    rows[i].updateFrozenCellPosition(x);
                }
            }
        };
        DTableBody.prototype.getClippingRect = function (target, result) {
            _super.prototype.getClippingRect.call(this, target, result);
            var parent = this.parent;
            if (parent) {
                var dy = -parent.transform.position.y;
                result.y += dy;
                result.height -= dy;
            }
        };
        /**
         * Scroll to the given row or row index.
         *
         * @param target a row or an row index to which the body scrolls to.
         * @returns true if succeeded
         */
        DTableBody.prototype.scrollTo = function (target) {
            var parent = this.parent;
            if (parent == null) {
                return false;
            }
            var parentParent = parent.parent;
            if (parentParent == null) {
                return false;
            }
            var rowIndexMapped = -1;
            if (isNumber(target)) {
                if (0 <= target && target < this.data.mapped.size()) {
                    rowIndexMapped = target;
                }
            }
            else {
                this.data.mapped.each(function (row, _, index) {
                    if (row === target) {
                        rowIndexMapped = index;
                        return false;
                    }
                    return true;
                });
            }
            if (rowIndexMapped < 0) {
                return false;
            }
            parent.position.y = Math.max(Math.min(0, parentParent.height - parent.height), -rowIndexMapped * this._rowHeight);
            DApplications.update(this);
            return true;
        };
        DTableBody.prototype.toRowIndexMapped = function (local) {
            if (0 <= this.parent.position.y + local.y) {
                return Math.floor(local.y / this._rowHeight);
            }
            return -1;
        };
        DTableBody.prototype.toRow = function (rowIndexMapped) {
            var index = rowIndexMapped - this._rowIndexMappedStart;
            var rows = this.children;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableBody.prototype.toCell = function (row, local) {
            var cells = row.children;
            var cellsLength = cells.length;
            var columns = this._columns;
            var columnsLength = columns.length;
            for (var i = 0, imax = Math.min(cellsLength, columnsLength); i < imax; ++i) {
                var cell = cells[cellsLength - i - 1];
                var x = local.x - cell.position.x;
                if (0 <= x && x <= cell.width) {
                    return cell;
                }
            }
            return null;
        };
        DTableBody.prototype.onRowClick = function (e) {
            if (this.state.isActionable) {
                var local = DTableBody.WORK_ON_CLICK;
                local.copyFrom(e.data.global);
                this.toLocal(local, undefined, local, false);
                var rowIndexMapped = this.toRowIndexMapped(local);
                if (0 <= rowIndexMapped && rowIndexMapped < this._data.mapped.size()) {
                    // Delegate to the cell at first
                    var row = this.toRow(rowIndexMapped);
                    if (row) {
                        var cell = this.toCell(row, local);
                        if (cell && cell.onRowSelect && cell.onRowSelect(e, local)) {
                            return;
                        }
                    }
                    // Fallback to the default
                    this.onRowSelect(e, rowIndexMapped);
                }
            }
        };
        DTableBody.prototype.onRowSelect = function (e, rowIndexMapped) {
            var data = this._data;
            var selection = data.selection;
            var isSingle = selection.type === DTableDataSelectionType.SINGLE;
            var isNotSingle = !isSingle;
            var rowIndex = data.mapped.unmap(rowIndexMapped);
            var originalEvent = e.data.originalEvent;
            var ctrlKey = originalEvent.ctrlKey;
            var shiftKey = originalEvent.shiftKey;
            if (isSingle || selection.isEmpty() || !(isNotSingle && (ctrlKey || shiftKey))) {
                selection.clearAndAdd(rowIndex);
            }
            else if (ctrlKey) {
                selection.toggle(rowIndex);
            }
            else if (shiftKey) {
                var lastRowIndex = selection.last;
                if (lastRowIndex != null) {
                    var sorter = data.sorter;
                    var filter = data.filter;
                    var rowIndexSorted = sorter.map(rowIndex);
                    var lastRowIndexSorted = sorter.map(lastRowIndex);
                    if (rowIndexSorted != null && lastRowIndexSorted != null) {
                        var istart = lastRowIndexSorted + 1;
                        var iend = rowIndexSorted + 1;
                        if (rowIndexSorted < lastRowIndexSorted) {
                            istart = rowIndexSorted;
                            iend = lastRowIndexSorted;
                        }
                        if (istart < iend) {
                            var rowIndices = [];
                            var indicesFiltered = filter.indices;
                            var indicesSorted = sorter.indices;
                            if (indicesFiltered) {
                                if (indicesSorted) {
                                    for (var i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                        var indexFiltered = indicesFiltered[i];
                                        if (istart <= indexFiltered && indexFiltered < iend) {
                                            rowIndices.push(indicesSorted[indexFiltered]);
                                        }
                                    }
                                }
                                else {
                                    for (var i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                        var indexFiltered = indicesFiltered[i];
                                        if (istart <= indexFiltered && indexFiltered < iend) {
                                            rowIndices.push(indexFiltered);
                                        }
                                    }
                                }
                            }
                            else {
                                if (indicesSorted) {
                                    for (var i = istart; i < iend; ++i) {
                                        rowIndices.push(indicesSorted[i]);
                                    }
                                }
                                else {
                                    for (var i = istart; i < iend; ++i) {
                                        rowIndices.push(i);
                                    }
                                }
                            }
                            selection.addAll(rowIndices);
                        }
                    }
                }
            }
        };
        DTableBody.prototype.onDblClick = function (e, interactionManager) {
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DTableBody.prototype.getType = function () {
            return "DTableBody";
        };
        Object.defineProperty(DTableBody.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        DTableBody.WORK_ON_CLICK = new pixi_js.Point();
        return DTableBody;
    }(DBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCategoryCell = /** @class */ (function (_super) {
        __extends(DTableCategoryCell, _super);
        function DTableCategoryCell() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableCategoryCell.prototype.getType = function () {
            return "DTableCategoryCell";
        };
        return DTableCategoryCell;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableCategory = /** @class */ (function (_super) {
        __extends(DTableCategory, _super);
        function DTableCategory(options) {
            var _this = this;
            var _a;
            _this = _super.call(this, options) || this;
            var offset = (_a = options.offset) !== null && _a !== void 0 ? _a : 0;
            _this._offset = offset;
            _this.transform.position.y = offset;
            _this.initCells(options, _this._columns, _this._frozen);
            return _this;
        }
        DTableCategory.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            _super.prototype.onParentMove.call(this, newX, newY, oldX, oldY);
            this.transform.position.y = -newY + this._offset;
            this.updateFrozenCellPosition(newX);
        };
        DTableCategory.prototype.getContentPositionX = function () {
            var content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        };
        DTableCategory.prototype.newCell = function (columnIndex, column, columns, options) {
            return new DTableCategoryCell(this.toCellOptions(columnIndex, column, options));
        };
        DTableCategory.prototype.toCellOptions = function (columnIndex, column, options) {
            var result = options.cell;
            if (result) {
                result.weight = column.weight;
                result.width = column.width;
                var text = result.text || {};
                result.text = text;
                text.value = text.value || column.label;
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    }
                };
            }
        };
        DTableCategory.prototype.getType = function () {
            return "DTableCategory";
        };
        return DTableCategory;
    }(DTableRow));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataTreeFilter = /** @class */ (function (_super) {
        __extends(DTableDataTreeFilter, _super);
        function DTableDataTreeFilter(parent) {
            var _this = _super.call(this) || this;
            _this._id = 0;
            _this._idUpdated = -1;
            _this._isApplied = false;
            _this._parent = parent;
            _this._filter = null;
            _this._filtered = null;
            return _this;
        }
        Object.defineProperty(DTableDataTreeFilter.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeFilter.prototype.apply = function () {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        };
        DTableDataTreeFilter.prototype.unapply = function () {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        };
        DTableDataTreeFilter.prototype.isApplied = function () {
            return this._isApplied;
        };
        DTableDataTreeFilter.prototype.isFiltered = function (node, index, filter) {
            if (isFunction(filter)) {
                return filter(node, index);
            }
            else {
                return filter.test(node, index);
            }
        };
        DTableDataTreeFilter.prototype.hasFiltered = function (parent, nodes, filter) {
            var accessor = this._parent.accessor;
            var toChildren = accessor.toChildren;
            var hasChildren = accessor.hasChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (this.isFiltered(node, -1, filter)) {
                    return true;
                }
                var children = toChildren(node);
                if (hasChildren(node, children) && this.hasFiltered(parent, children, filter)) {
                    return true;
                }
            }
            return false;
        };
        DTableDataTreeFilter.prototype.addAllToFiltered = function (parent, nodes, filtered, cursor) {
            var accessor = this._parent.accessor;
            var toChildren = accessor.toChildren;
            var hasChildren = accessor.hasChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                filtered.push(cursor[0]);
                cursor[0] += 1;
                var children = toChildren(node);
                if (hasChildren(node, children) && parent.isOpened(node)) {
                    this.addAllToFiltered(parent, children, filtered, cursor);
                }
            }
        };
        DTableDataTreeFilter.prototype.newFilteredSub = function (parent, nodes, filter, filtered, cursor) {
            var result = false;
            var accessor = this._parent.accessor;
            var toChildren = accessor.toChildren;
            var hasChildren = accessor.hasChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                var index = cursor[0];
                cursor[0] += 1;
                var isFiltered = this.isFiltered(node, index, filter);
                var children = toChildren(node);
                if (hasChildren(node, children)) {
                    if (parent.isOpened(node)) {
                        if (isFiltered) {
                            filtered.push(index);
                            result = true;
                            this.addAllToFiltered(parent, children, filtered, cursor);
                        }
                        else {
                            var position = filtered.length;
                            if (this.newFilteredSub(parent, children, filter, filtered, cursor)) {
                                filtered.splice(position, 0, index);
                                result = true;
                            }
                        }
                    }
                    else if (isFiltered || this.hasFiltered(parent, children, filter)) {
                        filtered.push(index);
                        result = true;
                    }
                }
                else if (isFiltered) {
                    filtered.push(index);
                    result = true;
                }
            }
            return result;
        };
        DTableDataTreeFilter.prototype.newFiltered = function () {
            var filter = this._filter;
            if (filter != null) {
                var filtered = [];
                var parent_1 = this._parent;
                var nodes = parent_1.nodes;
                if (nodes) {
                    var cursor = [0];
                    this.newFilteredSub(parent_1, nodes, filter, filtered, cursor);
                }
                return filtered;
            }
            return null;
        };
        DTableDataTreeFilter.prototype.get = function () {
            return this._filter;
        };
        DTableDataTreeFilter.prototype.set = function (filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        };
        DTableDataTreeFilter.prototype.toDirty = function () {
            this._id += 1;
        };
        DTableDataTreeFilter.prototype.update = function () {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        };
        Object.defineProperty(DTableDataTreeFilter.prototype, "indices", {
            get: function () {
                this.update();
                return this._filtered;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeFilter.prototype.map = function (sortedIndex) {
            var result = sortedIndex;
            var indices = this.indices;
            if (indices) {
                var index = indices.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        };
        DTableDataTreeFilter.prototype.unmap = function (index) {
            var result = index;
            var indices = this.indices;
            if (indices) {
                result = indices[result];
            }
            return result;
        };
        return DTableDataTreeFilter;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toParent = function (node) {
        return node.parent;
    };
    var toChildren$1 = function (node) {
        return node.children;
    };
    var hasChildren = function (node, children) {
        return children != null && 0 < children.length;
    };
    var DTableDataTreeItemAccessor = /** @class */ (function () {
        function DTableDataTreeItemAccessor(options) {
            if (options != null) {
                this.toParent = options.toParent || toParent;
                this.toChildren = options.toChildren || toChildren$1;
                this.hasChildren = options.hasChildren || hasChildren;
            }
            else {
                this.toParent = toParent;
                this.toChildren = toChildren$1;
                this.hasChildren = hasChildren;
            }
        }
        return DTableDataTreeItemAccessor;
    }());

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var COMPARATOR = function (a, b) {
        return a[0] - b[0];
    };
    var DTableDataTreeSelectionImpl = /** @class */ (function (_super) {
        __extends(DTableDataTreeSelectionImpl, _super);
        function DTableDataTreeSelectionImpl(parent, options) {
            var _this = this;
            var _a;
            _this = _super.call(this) || this;
            _this._parent = parent;
            _this._type = toEnum((_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : DTableDataSelectionType.NONE, DTableDataSelectionType);
            _this._rows = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSelectionImpl.prototype.onNodeChange = function (nodes) {
            if (nodes != null) {
                var accessor = this._parent.accessor;
                var toChildren = accessor.toChildren;
                var hasChildren = accessor.hasChildren;
                var oldRows = this._rows;
                var newRows = this.newRows(nodes, toChildren, hasChildren, oldRows, new Set());
                if (oldRows.size !== newRows.size) {
                    this._rows = newRows;
                    this.onChange();
                }
            }
            else {
                var rows = this._rows;
                if (0 < rows.size) {
                    rows.clear();
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.newRows = function (nodes, toChildren, hasChildren, rows, result) {
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (rows.has(node)) {
                    result.add(node);
                }
                var children = toChildren(node);
                if (hasChildren(node, children)) {
                    this.newRows(children, toChildren, hasChildren, rows, result);
                }
            }
            return result;
        };
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "indices", {
            get: function () {
                var rows = this._rows;
                var result = [];
                this._parent.each(function (row, index) {
                    if (rows.has(row)) {
                        result.push(index);
                    }
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "rows", {
            get: function () {
                var result = [];
                this._rows.forEach(function (row) {
                    result.push(row);
                });
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSelectionImpl.prototype.getFirst = function () {
            var rows = this._rows;
            if (0 < rows.size) {
                var result_1 = null;
                rows.forEach(function (row) {
                    if (result_1 == null) {
                        result_1 = row;
                    }
                });
                return result_1;
            }
            return null;
        };
        DTableDataTreeSelectionImpl.prototype.getLast = function () {
            var rows = this._rows;
            if (0 < rows.size) {
                var result_2 = null;
                rows.forEach(function (row) {
                    result_2 = row;
                });
                return result_2;
            }
            return null;
        };
        DTableDataTreeSelectionImpl.prototype.toIndex = function (target) {
            var result = null;
            this._parent.each(function (row, index) {
                if (target === row) {
                    result = index;
                    return false;
                }
                return true;
            });
            return result;
        };
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "first", {
            get: function () {
                var row = this.getFirst();
                if (row) {
                    return this.toIndex(row);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSelectionImpl.prototype, "last", {
            get: function () {
                var row = this.getLast();
                if (row) {
                    return this.toIndex(row);
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSelectionImpl.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTableDataTreeSelectionImpl.prototype.toggle = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (rows.has(row)) {
                    rows.delete(row);
                }
                else {
                    rows.add(row);
                }
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.add = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (!rows.has(row)) {
                    rows.add(row);
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.addTo = function (rowIndex) {
            var lastRowIndex = this.last;
            if (lastRowIndex != null) {
                this.addRange(lastRowIndex, false, rowIndex, true);
            }
        };
        DTableDataTreeSelectionImpl.prototype.addRange = function (from, includeFrom, to, includeTo) {
            var rows = this._rows;
            var oldSize = rows.size;
            var parent = this._parent;
            if (from < to) {
                parent.each(function (row) {
                    rows.add(row);
                }, from + (includeFrom ? 0 : 1), to + (includeTo ? 1 : 0));
            }
            else {
                parent.each(function (row) {
                    rows.add(row);
                }, to + (includeTo ? 0 : 1), from + (includeFrom ? 1 : 0));
            }
            var newSize = rows.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.addAll = function (rowIndices) {
            if (0 < rowIndices.length) {
                var rows = this._rows;
                var parent_1 = this._parent;
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    var row = parent_1.get(rowIndices[i]);
                    if (row) {
                        rows.add(row);
                    }
                }
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.contains = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                return this._rows.has(row);
            }
            return false;
        };
        DTableDataTreeSelectionImpl.prototype.remove = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (rows.has(row)) {
                    rows.delete(row);
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.clear = function () {
            var rows = this._rows;
            if (0 < rows.size) {
                rows.clear();
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.clearAndAdd = function (rowIndex) {
            var row = this._parent.get(rowIndex);
            if (row) {
                var rows = this._rows;
                if (rows.has(row)) {
                    if (1 < rows.size) {
                        rows.clear();
                        rows.add(row);
                        this.onChange();
                    }
                }
                else {
                    rows.clear();
                    rows.add(row);
                    this.onChange();
                }
            }
        };
        DTableDataTreeSelectionImpl.prototype.clearAndAddAll = function (rowIndices) {
            var rows = this._rows;
            if (0 < rows.size || 0 < rowIndices.length) {
                rows.clear();
                var parent_2 = this._parent;
                for (var i = 0, imax = rowIndices.length; i < imax; ++i) {
                    var row = parent_2.get(rowIndices[i]);
                    if (row) {
                        rows.add(row);
                    }
                }
                this.onChange();
            }
        };
        DTableDataTreeSelectionImpl.prototype.shift = function (rowIndex, amount) {
            // DO NOTHING
        };
        DTableDataTreeSelectionImpl.prototype.size = function () {
            return this._rows.size;
        };
        DTableDataTreeSelectionImpl.prototype.isEmpty = function () {
            return this._rows.size <= 0;
        };
        DTableDataTreeSelectionImpl.prototype.each = function (iteratee) {
            var rows = this._rows;
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    if (iteratee(index) === false) {
                        return false;
                    }
                }
                return true;
            });
        };
        DTableDataTreeSelectionImpl.prototype.toArray = function () {
            var rows = this._rows;
            var result = [];
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    result.push([index, row]);
                }
            });
            return result;
        };
        DTableDataTreeSelectionImpl.prototype.toSortedArray = function () {
            return this.toArray().sort(COMPARATOR);
        };
        DTableDataTreeSelectionImpl.prototype.toObject = function () {
            var rows = this._rows;
            var result = {};
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    result[index] = row;
                }
            });
            return result;
        };
        DTableDataTreeSelectionImpl.prototype.toMap = function () {
            var rows = this._rows;
            var result = new Map();
            this._parent.each(function (row, index) {
                if (rows.has(row)) {
                    result.set(index, row);
                }
            });
            return result;
        };
        return DTableDataTreeSelectionImpl;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableDataTreeSorter = /** @class */ (function (_super) {
        __extends(DTableDataTreeSorter, _super);
        function DTableDataTreeSorter() {
            return _super.call(this) || this;
        }
        Object.defineProperty(DTableDataTreeSorter.prototype, "id", {
            get: function () {
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTreeSorter.prototype, "order", {
            get: function () {
                return DTableDataOrder.ASCENDING;
            },
            set: function (order) {
                // DO NOTHING
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSorter.prototype.apply = function () {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.unapply = function () {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.isApplied = function () {
            return false;
        };
        DTableDataTreeSorter.prototype.get = function () {
            return null;
        };
        DTableDataTreeSorter.prototype.set = function (comparator) {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.toDirty = function () {
            // DO NOTHING
        };
        DTableDataTreeSorter.prototype.update = function () {
            // DO NOTHING
        };
        Object.defineProperty(DTableDataTreeSorter.prototype, "indices", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTreeSorter.prototype.map = function (unmappedIndex) {
            return unmappedIndex;
        };
        DTableDataTreeSorter.prototype.unmap = function (index) {
            return index;
        };
        return DTableDataTreeSorter;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Please note that this data class does not support the sorter.
     */
    var DTableDataTree = /** @class */ (function (_super) {
        __extends(DTableDataTree, _super);
        function DTableDataTree(options) {
            var _this = _super.call(this) || this;
            _this._parent = null;
            _this._accessor = _this.toAccessor(options);
            _this._mapped = new DTableDataListMapped(_this);
            _this._rows = [];
            _this._isRowsDirty = false;
            _this._supplimentals = [];
            _this._flags = new WeakMap();
            _this._reverse = !!(options === null || options === void 0 ? void 0 : options.reverse);
            _this._selection = _this.toSelection(options === null || options === void 0 ? void 0 : options.selection);
            _this._filter = new DTableDataTreeFilter(_this);
            _this._sorter = new DTableDataTreeSorter();
            if (options) {
                // Filter
                var filter = options.filter;
                if (filter) {
                    _this._filter.set(filter);
                }
                // Events
                var on = options.on;
                if (on) {
                    for (var name_1 in on) {
                        var handler = on[name_1];
                        if (handler) {
                            _this.on(name_1, handler);
                        }
                    }
                }
            }
            // Update rows
            _this.nodes = options === null || options === void 0 ? void 0 : options.nodes;
            return _this;
        }
        DTableDataTree.prototype.toSelection = function (options) {
            if (options instanceof pixi_js.utils.EventEmitter) {
                return options;
            }
            else if (isFunction(options)) {
                return options(this);
            }
            return this.newSelection(options);
        };
        DTableDataTree.prototype.newSelection = function (options) {
            return new DTableDataTreeSelectionImpl(this, options);
        };
        DTableDataTree.prototype.toAccessor = function (options) {
            return new DTableDataTreeItemAccessor(options);
        };
        DTableDataTree.prototype.bind = function (parent) {
            this._parent = parent;
        };
        Object.defineProperty(DTableDataTree.prototype, "nodes", {
            get: function () {
                return this._nodes;
            },
            set: function (nodes) {
                this._nodes = nodes;
                this._isRowsDirty = true;
                this._selection.onNodeChange(nodes);
                this._filter.toDirty();
                this.update(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "rows", {
            get: function () {
                if (this._isRowsDirty) {
                    this._isRowsDirty = false;
                    this.updateRows(this._nodes);
                }
                return this._rows;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "supplimentals", {
            get: function () {
                return this._supplimentals;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "accessor", {
            get: function () {
                return this._accessor;
            },
            enumerable: false,
            configurable: true
        });
        DTableDataTree.prototype.updateRows = function (nodes) {
            var rows = this._rows;
            var supplimentals = this._supplimentals;
            var flags = this._flags;
            if (nodes != null) {
                var accessor = this._accessor;
                var irows = this.newRows(nodes, 0, 0, rows, supplimentals, flags, this._reverse, accessor.toChildren, accessor.hasChildren);
                if (irows !== rows.length) {
                    rows.length = irows;
                    supplimentals.length = irows;
                }
            }
            else {
                rows.length = 0;
                supplimentals.length = 0;
            }
        };
        DTableDataTree.prototype.toSupplimental = function (ilevel, hasChildren, isOpened) {
            return (ilevel << 2) | (hasChildren ? 2 : 0) | (isOpened ? 1 : 0);
        };
        DTableDataTree.prototype.newRows = function (nodes, irows, ilevel, rows, supplimentals, flags, reverse, toChildren, hasChildren) {
            var nodesLength = nodes.length;
            var istart = reverse ? nodesLength - 1 : 0;
            var idelta = reverse ? -1 : +1;
            for (var i = istart; 0 <= i && i < nodesLength; i += idelta) {
                var node = nodes[i];
                var children = toChildren(node);
                var isOpened = flags.has(node);
                var supplimental = this.toSupplimental(ilevel, hasChildren(node, children), isOpened);
                if (irows < rows.length) {
                    rows[irows] = node;
                    supplimentals[irows] = supplimental;
                }
                else {
                    rows.push(node);
                    supplimentals.push(supplimental);
                }
                irows += 1;
                if (isOpened && children) {
                    irows = this.newRows(children, irows, ilevel + 1, rows, supplimentals, flags, reverse, toChildren, hasChildren);
                }
            }
            return irows;
        };
        DTableDataTree.prototype.update = function (forcibly) {
            var parent = this._parent;
            if (parent) {
                parent.update(forcibly);
            }
        };
        DTableDataTree.prototype.size = function () {
            return this.rows.length;
        };
        DTableDataTree.prototype.get = function (index) {
            var rows = this.rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        };
        DTableDataTree.prototype.expand = function (node) {
            var flags = this._flags;
            if (!flags.has(node)) {
                flags.set(node, 1);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
                return true;
            }
            return false;
        };
        DTableDataTree.prototype.collapse = function (node) {
            var flags = this._flags;
            if (flags.has(node)) {
                flags.delete(node);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
                return true;
            }
            return false;
        };
        DTableDataTree.prototype.isCollapsed = function (node) {
            return !this._flags.has(node);
        };
        DTableDataTree.prototype.isExpanded = function (node) {
            return this._flags.has(node);
        };
        DTableDataTree.prototype.toggle = function (node) {
            if (this.isExpanded(node)) {
                return this.collapse(node);
            }
            else {
                return this.expand(node);
            }
        };
        /** @deprecated in favor of {@link expand}. */
        DTableDataTree.prototype.open = function (node) {
            return this.expand(node);
        };
        /** @deprecated in favor of {@link collapse}. */
        DTableDataTree.prototype.close = function (node) {
            return this.collapse(node);
        };
        /** @deprecated in favor of {@link isExpanded}. */
        DTableDataTree.prototype.isOpened = function (node) {
            return this.isExpanded(node);
        };
        DTableDataTree.prototype.each = function (iteratee, ifrom, ito) {
            var rows = this.rows;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            ito = ito != null ? Math.min(rows.length, ito) : rows.length;
            for (var i = ifrom; i < ito; ++i) {
                var row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        };
        Object.defineProperty(DTableDataTree.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "filter", {
            get: function () {
                return this._filter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "sorter", {
            get: function () {
                return this._sorter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableDataTree.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        return DTableDataTree;
    }(pixi_js.utils.EventEmitter));

    var DTableHeaderCellCheck = /** @class */ (function () {
        function DTableHeaderCellCheck(parent, options) {
            var _a, _b, _c;
            this._parent = parent;
            this._isEnabled = (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : false;
            this._isFilterable = (_b = options === null || options === void 0 ? void 0 : options.filterable) !== null && _b !== void 0 ? _b : true;
            this._isEmittable = (_c = options === null || options === void 0 ? void 0 : options.emittable) !== null && _c !== void 0 ? _c : true;
        }
        Object.defineProperty(DTableHeaderCellCheck.prototype, "isEnabled", {
            get: function () {
                return this._isEnabled;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCellCheck.prototype, "isFilterable", {
            get: function () {
                return this._isFilterable;
            },
            set: function (isFilterable) {
                this._isFilterable = isFilterable;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCellCheck.prototype, "isEmittable", {
            get: function () {
                return this._isEmittable;
            },
            set: function (isEmittable) {
                this._isEmittable = isEmittable;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCellCheck.prototype.newIteratee = function (table, isChecked) {
            var parent = this._parent;
            var column = parent.column;
            var columnIndex = parent.columnIndex;
            if (column != null && columnIndex != null) {
                var getter_1 = column.getter;
                var setter_1 = column.setter;
                if (this._isEmittable) {
                    var data_1 = table.data;
                    return function (row, rowIndex) {
                        if (getter_1(row, columnIndex) !== isChecked) {
                            setter_1(row, columnIndex, isChecked);
                            data_1.emit("change", isChecked, !isChecked, row, rowIndex, columnIndex, data_1);
                            return true;
                        }
                        return false;
                    };
                }
                else {
                    return function (row) {
                        if (getter_1(row, columnIndex) !== isChecked) {
                            setter_1(row, columnIndex, isChecked);
                            return true;
                        }
                        return false;
                    };
                }
            }
            return null;
        };
        DTableHeaderCellCheck.prototype.execute = function (isChecked) {
            var _a;
            var table = (_a = this._parent.header) === null || _a === void 0 ? void 0 : _a.table;
            if (table) {
                var iteratee_1 = this.newIteratee(table, isChecked);
                if (iteratee_1) {
                    var isChanged_1 = false;
                    if (this._isFilterable) {
                        table.data.mapped.each(function (row, supplimental, index, unmappedIndex) {
                            if (iteratee_1(row, unmappedIndex)) {
                                isChanged_1 = true;
                            }
                        });
                    }
                    else {
                        table.data.each(function (row, index) {
                            if (iteratee_1(row, index)) {
                                isChanged_1 = true;
                            }
                        });
                    }
                    if (isChanged_1) {
                        table.body.update(true);
                    }
                }
            }
        };
        return DTableHeaderCellCheck;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var InteractionEvent = pixi_js.interaction.InteractionEvent;
    var DTableHeaderCell = /** @class */ (function (_super) {
        __extends(DTableHeaderCell, _super);
        function DTableHeaderCell() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableHeaderCell.prototype.init = function (options) {
            if (options != null) {
                this._header = options.header;
                this._column = options.column;
                this._columnIndex = options.columnIndex;
                this._check = new DTableHeaderCellCheck(this, options.check);
            }
            else {
                this._check = new DTableHeaderCellCheck(this);
            }
            _super.prototype.init.call(this, options);
            this.initOnClick(options);
        };
        Object.defineProperty(DTableHeaderCell.prototype, "column", {
            get: function () {
                return this._column;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "columnIndex", {
            get: function () {
                return this._columnIndex;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "header", {
            get: function () {
                return this._header;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "check", {
            get: function () {
                return this._check;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCell.prototype.initOnClick = function (options) {
            var _this = this;
            var column = this._column;
            if (column) {
                var sortable = column.sorting.enable;
                var checkable = this._check.isEnabled;
                if (checkable || sortable) {
                    this.on(UtilPointerEvent.tap, function (e) {
                        _this.onClick(e);
                    });
                    var state = this.state;
                    state.lock();
                    state.set(DTableState.SORTABLE, sortable);
                    state.set(DTableState.CHECKABLE, checkable);
                    state.unlock();
                }
            }
        };
        Object.defineProperty(DTableHeaderCell.prototype, "sorter", {
            get: function () {
                var _this = this;
                var sorter = this._sorter;
                if (sorter == null) {
                    var header = this._header;
                    if (header) {
                        var table = header.table;
                        if (table) {
                            sorter = table.data.sorter;
                            this._sorter = sorter;
                            this._onSorterChangeBound =
                                this._onSorterChangeBound ||
                                    (function () {
                                        _this.onSorterChange();
                                    });
                            sorter.on("change", this._onSorterChangeBound);
                        }
                        else {
                            return null;
                        }
                    }
                    else {
                        return null;
                    }
                }
                return sorter;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "comparator", {
            get: function () {
                var column = this._column;
                if (column) {
                    return column.sorting.comparator || null;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCell.prototype.onSorterChange = function () {
            var comparator = this.comparator;
            if (comparator) {
                var sorter = this._sorter;
                if (sorter) {
                    var SORTED_ASCENDING = DTableState.SORTED_ASCENDING;
                    var SORTED_DESCENDING = DTableState.SORTED_DESCENDING;
                    if (sorter.isApplied() && sorter.get() === comparator) {
                        if (sorter.order === DTableDataOrder.ASCENDING) {
                            this.state.set(SORTED_ASCENDING, SORTED_DESCENDING);
                        }
                        else {
                            this.state.set(SORTED_DESCENDING, SORTED_ASCENDING);
                        }
                    }
                    else {
                        this.state.removeAll(SORTED_ASCENDING, SORTED_DESCENDING);
                    }
                }
            }
        };
        DTableHeaderCell.prototype.toClickPosition = function (e) {
            var checkWork = this._checkWork || new pixi_js.Point();
            this._checkWork = checkWork;
            return e.data.getLocalPosition(this, checkWork).x;
        };
        DTableHeaderCell.prototype.isCheckClicked = function (e) {
            if (e instanceof InteractionEvent && this._check.isEnabled) {
                if (this.isSortable) {
                    var image = this._images[1];
                    if (image && image.image != null) {
                        var position = this.toClickPosition(e);
                        var bound = image.bound;
                        var margin = image.margin.horizontal;
                        return bound.left - margin <= position && position <= bound.right + margin;
                    }
                }
                else {
                    return true;
                }
            }
            return false;
        };
        DTableHeaderCell.prototype.onClick = function (e) {
            if (this.state.isActionable) {
                this.activate(e);
            }
        };
        DTableHeaderCell.prototype.activate = function (e) {
            this.onActivate(e);
        };
        DTableHeaderCell.prototype.onActivate = function (e) {
            if (this.isCheckClicked(e)) {
                this.onToggleStart();
                this.onToggleEnd();
            }
            else {
                this.doSort(e);
                this.emit("active", this);
            }
        };
        DTableHeaderCell.prototype.doSort = function (e) {
            if (this.isSortable) {
                var comparator = this.comparator;
                if (comparator) {
                    var sorter = this.sorter;
                    if (sorter) {
                        if (sorter.get() === comparator) {
                            if (sorter.order === DTableDataOrder.ASCENDING) {
                                sorter.order = DTableDataOrder.DESCENDING;
                                sorter.apply();
                            }
                            else {
                                sorter.set(null);
                                sorter.apply();
                            }
                        }
                        else {
                            sorter.set(comparator);
                            sorter.order = DTableDataOrder.ASCENDING;
                            sorter.apply();
                        }
                    }
                }
            }
        };
        Object.defineProperty(DTableHeaderCell.prototype, "isSortable", {
            get: function () {
                var column = this._column;
                if (column) {
                    return column.sorting.enable;
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTableHeaderCell.prototype, "isToggle", {
            get: function () {
                return this._check.isEnabled;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeaderCell.prototype.toggle = function () {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
            }
        };
        DTableHeaderCell.prototype.onToggleStart = function () {
            this.state.isActive = !this.state.isActive;
        };
        DTableHeaderCell.prototype.onToggleEnd = function () {
            if (this.state.isActive) {
                this._check.execute(true);
                this.emit("active", this);
            }
            else {
                this._check.execute(false);
                this.emit("inactive", this);
            }
        };
        DTableHeaderCell.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleStart();
                }
                else {
                    this.state.isPressed = true;
                }
            }
        };
        DTableHeaderCell.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleEnd();
                }
                else {
                    if (this.state.isPressed) {
                        this.activate(e);
                    }
                    this.state.isPressed = false;
                }
            }
        };
        DTableHeaderCell.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTableHeaderCell.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTableHeaderCell.prototype.getType = function () {
            return "DTableHeaderCell";
        };
        DTableHeaderCell.prototype.destroy = function () {
            var sorter = this._sorter;
            var onSorterChangeBound = this._onSorterChangeBound;
            if (sorter && onSorterChangeBound) {
                sorter.off("change", onSorterChangeBound);
            }
            this._sorter = undefined;
            this._onSorterChangeBound = undefined;
            _super.prototype.destroy.call(this);
        };
        return DTableHeaderCell;
    }(DImage));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTableHeader = /** @class */ (function (_super) {
        __extends(DTableHeader, _super);
        function DTableHeader(options) {
            var _this = this;
            var _a, _b;
            _this = _super.call(this, options) || this;
            _this._table = (_a = options.table) !== null && _a !== void 0 ? _a : null;
            var offset = (_b = options.offset) !== null && _b !== void 0 ? _b : 0;
            _this._offset = offset;
            _this.transform.position.y = offset;
            _this.initCells(options, _this._columns, _this._frozen);
            return _this;
        }
        Object.defineProperty(DTableHeader.prototype, "table", {
            get: function () {
                return this._table;
            },
            enumerable: false,
            configurable: true
        });
        DTableHeader.prototype.onParentMove = function (newX, newY, oldX, oldY) {
            _super.prototype.onParentMove.call(this, newX, newY, oldX, oldY);
            this.transform.position.y = -newY + this._offset;
            this.updateFrozenCellPosition(newX);
        };
        DTableHeader.prototype.getContentPositionX = function () {
            var content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        };
        DTableHeader.prototype.newCell = function (columnIndex, column, columns, options) {
            return new DTableHeaderCell(this.toCellOptions(columnIndex, column, options));
        };
        DTableHeader.prototype.toCellOptions = function (columnIndex, column, options) {
            var result = column.header || options.cell;
            if (result != null) {
                if (result.weight === undefined) {
                    result.weight = column.weight;
                }
                if (result.width === undefined) {
                    result.width = column.width;
                }
                if (result.text === undefined) {
                    result.text = {
                        value: column.label
                    };
                }
                else if (result.text.value === undefined) {
                    result.text.value = column.label;
                }
                if (result.header === undefined) {
                    result.header = this;
                }
                if (result.column === undefined) {
                    result.column = column;
                }
                if (result.columnIndex === undefined) {
                    result.columnIndex = columnIndex;
                }
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    },
                    header: this,
                    column: column,
                    columnIndex: columnIndex
                };
            }
        };
        DTableHeader.prototype.getType = function () {
            return "DTableHeader";
        };
        return DTableHeader;
    }(DTableRow));

    var DTableScrollBar = /** @class */ (function (_super) {
        __extends(DTableScrollBar, _super);
        function DTableScrollBar() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTableScrollBar.prototype.getOffsetVerticalStart = function (size) {
            return size * 0.5 + this._parent.body.position.y;
        };
        return DTableScrollBar;
    }(DPaneScrollBar));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var defaultGetter = function (row, columnIndex) {
        return row[columnIndex];
    };
    var defaultSetter = function (row, columnIndex, cell) {
        row[columnIndex] = cell;
    };
    var defaultGetterEmpty = function () { return ""; };
    var defaultSetterEmpty = function () {
        // DO NOTHING
    };
    var toPathGetter = function (path, def) {
        if (path.length <= 1) {
            var key_1 = path[0];
            if (def === undefined) {
                return function (row) {
                    return row[key_1];
                };
            }
            else {
                return function (row) {
                    return Object.prototype.hasOwnProperty.call(row, key_1) ? row[key_1] : def;
                };
            }
        }
        else {
            if (def === undefined) {
                return function (row) {
                    for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    return row[path[path.length - 1]];
                };
            }
            else {
                return function (row) {
                    for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    var key = path[path.length - 1];
                    return Object.prototype.hasOwnProperty.call(row, key) ? row[key] : def;
                };
            }
        }
    };
    var toPathSetter = function (path) {
        if (path.length <= 1) {
            var key_2 = path[0];
            return function (row, columnIndex, cell) {
                row[key_2] = cell;
            };
        }
        else {
            return function (row, columnIndex, cell) {
                for (var i = 0, imax = path.length - 1; i < imax; ++i) {
                    row = row[path[i]] || {};
                }
                row[path[path.length - 1]] = cell;
            };
        }
    };
    var toColumnAlign = function (options, type) {
        var align = options.align;
        if (align != null) {
            if (isString(align)) {
                return DAlignHorizontal[align];
            }
            else {
                return align;
            }
        }
        switch (type) {
            case DTableColumnType.TEXT:
                return DAlignHorizontal.LEFT;
            case DTableColumnType.REAL:
            case DTableColumnType.INTEGER:
                return DAlignHorizontal.RIGHT;
            case DTableColumnType.BUTTON:
            case DTableColumnType.INDEX:
            case DTableColumnType.SELECT:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
            case DTableColumnType.CHECK:
            case DTableColumnType.CHECK_SINGLE:
            case DTableColumnType.COLOR:
                return DAlignHorizontal.CENTER;
            default:
                return DAlignHorizontal.LEFT;
        }
    };
    var toColumnDataChecker = function (path) {
        if (path != null) {
            var pathLength_1 = path.length;
            if (pathLength_1 <= 1) {
                var key_3 = path[0];
                return function (row) {
                    return Object.prototype.hasOwnProperty.call(row, key_3);
                };
            }
            else {
                return function (row) {
                    for (var i = 0; i < pathLength_1; ++i) {
                        var part = path[i];
                        if (part in row) {
                            row = row[part];
                        }
                        else {
                            return false;
                        }
                    }
                    return true;
                };
            }
        }
        return function (row, columnIndex) {
            return columnIndex < row.length;
        };
    };
    var toColumnEditingEnable = function (enable, path) {
        if (isString(enable)) {
            return toColumnDataChecker(path);
        }
        else if (enable != null) {
            return enable;
        }
        else {
            return false;
        }
    };
    var toColumnEditing = function (options, path) {
        var _a;
        var editing = options.editing;
        var editable = options.editable;
        if (editing) {
            return {
                enable: toColumnEditingEnable((_a = editing.enable) !== null && _a !== void 0 ? _a : editable, path),
                formatter: editing.formatter,
                unformatter: editing.unformatter,
                validator: editing.validator
            };
        }
        return {
            enable: toColumnEditingEnable(editable, path)
        };
    };
    var toComparator = function (getter, index) {
        return function (rowA, rowB) {
            var valueA = getter(rowA, index);
            var valueB = getter(rowB, index);
            return valueA < valueB ? -1 : valueB < valueA ? +1 : 0;
        };
    };
    var toColumnSorting = function (getter, index, options) {
        var sorting = options.sorting;
        var sortable = options.sortable;
        if (sorting) {
            if (sorting.enable || sortable) {
                return {
                    enable: true,
                    comparator: sorting.comparator || toComparator(getter, index)
                };
            }
            return {
                enable: false
            };
        }
        if (sortable) {
            return {
                enable: true,
                comparator: toComparator(getter, index)
            };
        }
        return {
            enable: false
        };
    };
    var toColumnMenu = function (options) {
        if (options == null) {
            return undefined;
        }
        else if (options instanceof DMenu) {
            return options;
        }
        else {
            return new DMenu(options);
        }
    };
    var toColumnDialog = function (options) {
        if (options == null) {
            return undefined;
        }
        else if ("open" in options) {
            return options;
        }
        else {
            return new DDialogSelect(options);
        }
    };
    var defaultSelectingGetter = function (dialog) {
        return dialog.value;
    };
    var defaultSelectingSetter = function () {
        // DO NOTHING
    };
    var toColumnSelecting = function (options) {
        if (options) {
            return {
                getter: options.getter || defaultSelectingGetter,
                setter: options.setter || defaultSelectingSetter,
                menu: toColumnMenu(options.menu),
                multiple: toColumnMenu(options.multiple),
                dialog: toColumnDialog(options.dialog),
                promise: options.promise
            };
        }
        return {
            getter: defaultSelectingGetter,
            setter: defaultSelectingSetter
        };
    };
    var toColumnGetter = function (options, type, parts) {
        var getter = options.getter;
        if (getter) {
            return getter;
        }
        switch (type) {
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultGetterEmpty;
            default:
                if (parts == null) {
                    return defaultGetter;
                }
                else {
                    return toPathGetter(parts, options.default);
                }
        }
    };
    var toColumnSetter = function (options, type, path) {
        var setter = options.setter;
        if (setter) {
            return setter;
        }
        switch (type) {
            case DTableColumnType.BUTTON:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultSetterEmpty;
            default:
                if (path == null) {
                    return defaultSetter;
                }
                else {
                    return toPathSetter(path);
                }
        }
    };
    var toColumnState = function (options) {
        var state = options.state;
        if (state != null) {
            if (isString(state) || isArray(state)) {
                return {
                    initial: state,
                    modifier: undefined
                };
            }
            else {
                return {
                    initial: undefined,
                    modifier: state
                };
            }
        }
        return {
            initial: undefined,
            modifier: undefined
        };
    };
    var toColumnPath = function (options) {
        return options.path != null ? options.path.split(".") : null;
    };
    var toColumnRenderable = function (options, path) {
        var renderable = options.renderable;
        if (isString(renderable)) {
            return toColumnDataChecker(path);
        }
        else if (renderable != null) {
            return renderable;
        }
        return true;
    };
    var toColumn = function (index, options) {
        var _a;
        var weight = options.weight;
        var width = options.width;
        if (weight != null) {
            if (width != null) {
                width = undefined;
            }
        }
        else if (width == null) {
            weight = 1;
        }
        var type = toEnum((_a = options.type) !== null && _a !== void 0 ? _a : DTableColumnType.TEXT, DTableColumnType);
        var align = toColumnAlign(options, type);
        var label = options.label || "";
        var path = toColumnPath(options);
        var getter = toColumnGetter(options, type, path);
        var setter = toColumnSetter(options, type, path);
        return {
            weight: weight,
            width: width,
            type: type,
            label: label,
            getter: getter,
            setter: setter,
            formatter: options.formatter,
            renderable: toColumnRenderable(options, path),
            align: align,
            state: toColumnState(options),
            editing: toColumnEditing(options, path),
            sorting: toColumnSorting(getter, index, options),
            header: options.header,
            body: options.body,
            selecting: toColumnSelecting(options.selecting),
            category: options.category,
            frozen: options.frozen,
            offset: 0.0,
            link: options.link
        };
    };
    var toColumns = function (options) {
        var result = [];
        for (var i = 0, imax = options.length; i < imax; ++i) {
            result.push(toColumn(i, options[i]));
        }
        return result;
    };
    var toFrozen = function (columns) {
        for (var i = columns.length - 1; 0 <= i; --i) {
            if (columns[i].frozen === true) {
                return i + 1;
            }
        }
        return 0;
    };
    var DTable = /** @class */ (function (_super) {
        __extends(DTable, _super);
        function DTable(options) {
            var _this = _super.call(this, options) || this;
            var content = _this.content;
            content.setWidth(_this.toContentWidth(options));
            var body = _this.body;
            content.addChild(body);
            if (body.data.selection.type !== DTableDataSelectionType.NONE) {
                _this.on(UtilPointerEvent.tap, function (e) {
                    body.onRowClick(e);
                });
            }
            var header = _this.header;
            if (header) {
                content.addChild(header);
            }
            var categories = _this.categories;
            for (var i = categories.length - 1; 0 <= i; --i) {
                content.addChild(categories[i]);
            }
            body.update();
            return _this;
        }
        Object.defineProperty(DTable.prototype, "columns", {
            get: function () {
                var result = this._columns;
                if (result == null) {
                    var options = this._options;
                    result = options ? toColumns(options.columns) : [];
                    this._columns = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "frozen", {
            get: function () {
                var result = this._frozen;
                if (result == null) {
                    result = toFrozen(this.columns);
                    this._frozen = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTable.prototype, "categories", {
            get: function () {
                var result = this._categories;
                if (result == null) {
                    result = this.newCategories(this._options, this.columns, this.frozen);
                    this._categories = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.initContent = function (content) {
            _super.prototype.initContent.call(this, content);
            content.state.isFocusReverse = true;
        };
        DTable.prototype.onContentChange = function () {
            _super.prototype.onContentChange.call(this);
            this.body.update();
        };
        DTable.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var scrollbar = this.scrollbar;
            scrollbar.lock();
            var body = this.body;
            body.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            body.update();
            body.unlock(true);
            scrollbar.unlock(true);
        };
        DTable.prototype.getCategoryCount = function (columns) {
            var result = 0;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var category = columns[i].category;
                if (category != null) {
                    var count = isString(category) ? 1 : category.length;
                    result = Math.max(result, count);
                }
            }
            return result;
        };
        DTable.prototype.toCategoryLabel = function (index, category) {
            if (category) {
                if (isString(category)) {
                    if (index === 0) {
                        return category;
                    }
                }
                else {
                    if (index < category.length) {
                        return category[index];
                    }
                }
            }
            return undefined;
        };
        DTable.prototype.isSameCategory = function (index, a, b) {
            if (a != null) {
                if (b != null) {
                    if (isString(a)) {
                        if (isString(b)) {
                            if (0 < index) {
                                return true;
                            }
                            else {
                                return a === b;
                            }
                        }
                        else {
                            if (0 < index) {
                                return b.length <= index;
                            }
                            else {
                                return b.length === 1 && a === b[0];
                            }
                        }
                    }
                    else {
                        if (isString(b)) {
                            if (0 < index) {
                                return a.length <= index;
                            }
                            else {
                                return a.length === 1 && a[0] === b;
                            }
                        }
                        else {
                            if (a.length <= index && b.length <= index) {
                                return true;
                            }
                            else if (b.length === a.length) {
                                for (var i = index, imax = a.length; i < imax; ++i) {
                                    if (a[i] !== b[i]) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                            return false;
                        }
                    }
                }
                else {
                    if (isString(a)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (a.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            else {
                if (b != null) {
                    if (isString(b)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (b.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    return true;
                }
            }
        };
        DTable.prototype.toCategoryColumns = function (index, columns, frozen) {
            var result = [];
            var tcolumn = null;
            var ccolumn = null;
            for (var i = 0, imax = columns.length; i < imax; ++i) {
                var column = columns[i];
                if (i !== frozen &&
                    ccolumn &&
                    tcolumn &&
                    this.isSameCategory(index, tcolumn.category, column.category)) {
                    if (ccolumn.weight != null && column.weight != null) {
                        ccolumn.weight += column.weight;
                    }
                    else if (ccolumn.width != null && column.width != null) {
                        ccolumn.width += column.width;
                    }
                    else {
                        tcolumn = column;
                        ccolumn = {
                            label: this.toCategoryLabel(index, column.category),
                            weight: column.weight,
                            width: column.width,
                            offset: 0.0
                        };
                        result.push(ccolumn);
                    }
                }
                else {
                    tcolumn = column;
                    ccolumn = {
                        label: this.toCategoryLabel(index, column.category),
                        weight: column.weight,
                        width: column.width,
                        offset: 0.0
                    };
                    result.push(ccolumn);
                }
            }
            return result;
        };
        DTable.prototype.toCategoryOptions = function (index, options, columns, frozen, offset) {
            if (options) {
                if (options.columns === undefined) {
                    options.columns = this.toCategoryColumns(index, columns, frozen);
                }
                if (options.frozen == null) {
                    options.frozen = frozen;
                }
                if (options.offset == null) {
                    options.offset = offset;
                }
                return options;
            }
            return {
                columns: this.toCategoryColumns(index, columns, frozen),
                frozen: frozen,
                offset: offset
            };
        };
        DTable.prototype.newCategories = function (options, columns, frozen) {
            var count = this.getCategoryCount(columns);
            var result = [];
            var offset = 0;
            for (var i = count - 1; 0 <= i; --i) {
                var category = new DTableCategory(this.toCategoryOptions(i, options === null || options === void 0 ? void 0 : options.category, columns, frozen, offset));
                result.push(category);
                offset += category.height;
            }
            return result;
        };
        DTable.prototype.onDblClick = function (e, interactionManager) {
            var result = this.body.onDblClick(e, interactionManager);
            return _super.prototype.onDblClick.call(this, e, interactionManager) || result;
        };
        DTable.prototype.newScrollBar = function (options) {
            var _this = this;
            return new DTableScrollBar(this, options, function (isRegionVisible) {
                _this.onScrollBarUpdate(isRegionVisible);
            });
        };
        DTable.prototype.toContentWidth = function (options) {
            var columnWidthTotal = 0;
            var columns = options === null || options === void 0 ? void 0 : options.columns;
            if (columns) {
                for (var i = 0, imax = columns.length; i < imax; ++i) {
                    var column = columns[i];
                    var columnWidth = column.width;
                    if (columnWidth != null) {
                        columnWidthTotal += columnWidth;
                    }
                }
            }
            if (0 < columnWidthTotal) {
                return function (p) {
                    return Math.max(p, columnWidthTotal);
                };
            }
            return "100%";
        };
        DTable.prototype.getHeaderOffset = function () {
            var result = this._headerOffset;
            if (result == null) {
                result = this.newHeaderOffset();
                this._headerOffset = result;
            }
            return result;
        };
        DTable.prototype.newHeaderOffset = function () {
            var result = 0;
            var categories = this.categories;
            for (var i = 0, imax = categories.length; i < imax; ++i) {
                result += categories[i].height;
            }
            return result;
        };
        Object.defineProperty(DTable.prototype, "header", {
            get: function () {
                var result = this._header;
                if (result === undefined) {
                    result = this.newHeader(this._options, this.columns, this.frozen, this.getHeaderOffset());
                    this._header = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.hasHeader = function (options) {
            if (options) {
                var columns = options.columns;
                for (var i = 0, imax = columns.length; i < imax; ++i) {
                    if (columns[i].label != null) {
                        return true;
                    }
                }
            }
            return false;
        };
        DTable.prototype.newHeader = function (options, columns, frozen, offset) {
            if (this.hasHeader(options)) {
                return new DTableHeader(this.toHeaderOptions(options === null || options === void 0 ? void 0 : options.header, columns, frozen, offset));
            }
            return null;
        };
        DTable.prototype.toHeaderOptions = function (options, columns, frozen, offset) {
            if (options) {
                if (options.columns === undefined) {
                    options.columns = columns;
                }
                if (options.frozen == null) {
                    options.frozen = frozen;
                }
                if (options.offset === undefined) {
                    options.offset = offset;
                }
                if (options.table === undefined) {
                    options.table = this;
                }
                return options;
            }
            return {
                columns: columns,
                frozen: frozen,
                offset: offset,
                table: this
            };
        };
        DTable.prototype.getBodyOffset = function () {
            var result = this._bodyOffset;
            if (result == null) {
                result = this.newBodyOffset();
                this._bodyOffset = result;
            }
            return result;
        };
        DTable.prototype.newBodyOffset = function () {
            var _a, _b;
            return this.getHeaderOffset() + ((_b = (_a = this.header) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0);
        };
        Object.defineProperty(DTable.prototype, "body", {
            get: function () {
                var result = this._body;
                if (result == null) {
                    result = this.newBody(this._options, this.columns, this.frozen, this.getBodyOffset());
                    this._body = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.newBody = function (options, columns, frozen, offset) {
            return new DTableBody(this.toBodyOptions(options === null || options === void 0 ? void 0 : options.body, columns, frozen, offset, options === null || options === void 0 ? void 0 : options.data));
        };
        DTable.prototype.toBodyOptions = function (options, columns, frozen, offset, data) {
            if (options != null) {
                if (options.columns === undefined) {
                    options.columns = columns;
                }
                if (options.frozen == null) {
                    options.frozen = frozen;
                }
                if (options.offset === undefined) {
                    options.offset = offset;
                }
                if (options.data === undefined && data !== undefined) {
                    if (isArray(data)) {
                        options.data = {
                            rows: data
                        };
                    }
                    else {
                        options.data = data;
                    }
                }
                if (options.height === undefined && options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            if (isArray(data)) {
                return {
                    columns: columns,
                    frozen: frozen,
                    offset: offset,
                    data: {
                        rows: data
                    },
                    weight: 1
                };
            }
            else {
                return {
                    columns: columns,
                    frozen: frozen,
                    offset: offset,
                    data: data,
                    weight: 1
                };
            }
        };
        Object.defineProperty(DTable.prototype, "data", {
            get: function () {
                return this.body.data;
            },
            enumerable: false,
            configurable: true
        });
        DTable.prototype.getFocusedChildClippingRect = function (focused, contentX, contentY, contentWidth, contentHeight, width, height, result) {
            _super.prototype.getFocusedChildClippingRect.call(this, focused, contentX, contentY, contentWidth, contentHeight, width, height, result);
            var cell = this.toCell(focused);
            if (cell) {
                // X
                var dx = contentX + this.toFrozenCellX(cell) - result.x;
                if (0 < dx) {
                    result.x += dx;
                    result.width -= dx;
                }
                // Y
                if (cell.parent.parent === this.body) {
                    var dy = this.getBodyOffset();
                    result.y += dy;
                    result.height -= dy;
                }
            }
            // Done
            return result;
        };
        DTable.prototype.toFrozenCellX = function (cell) {
            var frozen = this.frozen;
            if (0 < frozen) {
                var cells = cell.parent.children;
                var cellIndex = cells.indexOf(cell);
                if (0 <= cellIndex) {
                    var cellsLength = cells.length;
                    var columnIndex = cellsLength - 1 - cellIndex;
                    if (frozen <= columnIndex) {
                        var cellFrozen = cells[cellsLength - frozen];
                        return cellFrozen.position.x + cellFrozen.width;
                    }
                }
            }
            return 0;
        };
        DTable.prototype.onKeyDown = function (e) {
            UtilKeyboardEvent.moveFocusHorizontally(e, this);
            var isArrowUpKey = UtilKeyboardEvent.isArrowUpKey(e);
            var isArrowDownKey = UtilKeyboardEvent.isArrowDownKey(e);
            if (isArrowUpKey || isArrowDownKey) {
                this.onKeyDownArrowUpOrDown(e, isArrowDownKey);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTable.prototype.onKeyDownArrowUpOrDown = function (e, isDown) {
            var layer = DApplications.getLayer(this);
            if (layer == null) {
                return false;
            }
            var focusController = layer.getFocusController();
            var oldFocusable = focusController.get();
            if (oldFocusable == null) {
                return false;
            }
            var oldCell = this.toCell(oldFocusable);
            if (oldCell == null) {
                return false;
            }
            var oldRow = oldCell.parent;
            if (oldRow == null) {
                return false;
            }
            var newRowChild = focusController.find(oldRow, false, false, isDown, this);
            if (newRowChild == null) {
                return false;
            }
            var newCellSibling = this.toCell(newRowChild);
            if (newCellSibling == null) {
                return false;
            }
            var newRow = newCellSibling.parent;
            if (newRow == null) {
                return false;
            }
            var oldCellIndex = oldRow.children.indexOf(oldCell);
            if (oldCellIndex < 0) {
                return false;
            }
            var newCell = newRow.children[oldCellIndex];
            if (newCell == null || newCell === oldCell || !("state" in newCell)) {
                return false;
            }
            var newFocusable = focusController.find(newCell, true, true, isDown, this);
            if (newFocusable == null) {
                return false;
            }
            focusController.focus(newFocusable);
            return true;
        };
        DTable.prototype.toCell = function (focused) {
            var current = focused;
            while (current != null) {
                var parent_1 = current.parent;
                if (parent_1 instanceof DTableRow) {
                    if (current instanceof DBase) {
                        return current;
                    }
                    return null;
                }
                current = parent_1;
            }
            return null;
        };
        DTable.prototype.getType = function () {
            return "DTable";
        };
        return DTable;
    }(DPane));

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var toLabel = function (item) {
        var text = item.text;
        if (isString(text)) {
            return text;
        }
        var label = item.label;
        if (isString(label)) {
            return label;
        }
        var name = item.name;
        if (isString(name)) {
            return name;
        }
        return undefined;
    };
    var toTitle = function (item) {
        var title = item.title;
        if (isString(title)) {
            return title;
        }
        return undefined;
    };
    var toImage = function (item) {
        return item.image;
    };
    var toChildren = function (item) {
        return item.children;
    };
    var newChildren = function (item) {
        return (item.children = []);
    };
    var DTreeNodeAccessorImpl = /** @class */ (function () {
        function DTreeNodeAccessorImpl(options) {
            var _a, _b, _c, _d, _e;
            this.toLabel = (_a = options === null || options === void 0 ? void 0 : options.toLabel) !== null && _a !== void 0 ? _a : toLabel;
            this.toTitle = (_b = options === null || options === void 0 ? void 0 : options.toTitle) !== null && _b !== void 0 ? _b : toTitle;
            this.toImage = (_c = options === null || options === void 0 ? void 0 : options.toImage) !== null && _c !== void 0 ? _c : toImage;
            this.toChildren = (_d = options === null || options === void 0 ? void 0 : options.toChildren) !== null && _d !== void 0 ? _d : toChildren;
            this.newChildren = (_e = options === null || options === void 0 ? void 0 : options.newChildren) !== null && _e !== void 0 ? _e : newChildren;
        }
        return DTreeNodeAccessorImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTreeDataSelection} type.
     */
    var DTreeDataSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataMappedImpl = /** @class */ (function () {
        function DTreeDataMappedImpl(parent, reverse) {
            this._parent = parent;
            this._nodes = [];
            this._levels = [];
            this._reverse = reverse;
            this._isDirty = false;
        }
        Object.defineProperty(DTreeDataMappedImpl.prototype, "nodes", {
            get: function () {
                this.update();
                return this._nodes;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataMappedImpl.prototype, "levels", {
            get: function () {
                this.update();
                return this._levels;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataMappedImpl.prototype.toDirty = function () {
            this._isDirty = true;
        };
        DTreeDataMappedImpl.prototype.size = function () {
            this.update();
            return this._nodes.length;
        };
        DTreeDataMappedImpl.prototype.each = function (iteratee, from, to) {
            this.update();
            var nodes = this._nodes;
            var ifrom = from != null ? Math.max(0, from) : 0;
            var ito = to != null ? Math.min(nodes.length, to) : nodes.length;
            for (var i = ifrom; i < ito; ++i) {
                if (iteratee(nodes[i], i) === false) {
                    break;
                }
            }
        };
        DTreeDataMappedImpl.prototype.update = function () {
            if (this._isDirty) {
                this._isDirty = false;
                var parent_1 = this._parent;
                var parentNodes = parent_1.nodes;
                var toChildren = parent_1.accessor.toChildren;
                var nodes = this._nodes;
                var levels = this._levels;
                var size = this.newNodes(parent_1, parentNodes, 0, 0, nodes, levels, this._reverse, toChildren);
                if (nodes.length !== size) {
                    nodes.length = size;
                    levels.length = size;
                }
            }
        };
        DTreeDataMappedImpl.prototype.newNodes = function (parent, parentNodes, index, level, nodes, levels, reverse, toChildren) {
            var parentNodesLength = parentNodes.length;
            var istart = reverse ? parentNodesLength - 1 : 0;
            var idelta = reverse ? -1 : +1;
            for (var i = istart; 0 <= i && i < parentNodesLength; i += idelta) {
                var parentNode = parentNodes[i];
                if (index < nodes.length) {
                    nodes[index] = parentNode;
                    levels[index] = level;
                }
                else {
                    nodes.push(parentNode);
                    levels.push(level);
                }
                index += 1;
                var children = toChildren(parentNode);
                if (children && parent.isExpanded(parentNode)) {
                    index = this.newNodes(parent, children, index, level + 1, nodes, levels, reverse, toChildren);
                }
            }
            return index;
        };
        return DTreeDataMappedImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionMultiple = /** @class */ (function (_super) {
        __extends(DTreeDataSelectionMultiple, _super);
        function DTreeDataSelectionMultiple(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._nodes = new Set();
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTreeDataSelectionMultiple.prototype, "type", {
            get: function () {
                return DTreeDataSelectionType.MULTIPLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionMultiple.prototype, "first", {
            get: function () {
                var nodes = this._nodes;
                if (0 < nodes.size) {
                    var result_1 = null;
                    nodes.forEach(function (item) {
                        if (result_1 == null) {
                            result_1 = item;
                        }
                    });
                    return result_1;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionMultiple.prototype, "last", {
            get: function () {
                var nodes = this._nodes;
                if (0 < nodes.size) {
                    var result_2 = null;
                    nodes.forEach(function (row) {
                        result_2 = row;
                    });
                    return result_2;
                }
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataSelectionMultiple.prototype.get = function (index) {
            var nodes = this._nodes;
            if (0 <= index && index < nodes.size) {
                var counter_1 = 0;
                var result_3 = null;
                nodes.forEach(function (node) {
                    if (counter_1 === index) {
                        result_3 = node;
                    }
                    counter_1 += 1;
                });
                return result_3;
            }
            return null;
        };
        DTreeDataSelectionMultiple.prototype.add = function (target) {
            var nodes = this._nodes;
            if (!nodes.has(target)) {
                nodes.add(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionMultiple.prototype.remove = function (target) {
            var nodes = this._nodes;
            if (nodes.has(target)) {
                nodes.delete(target);
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionMultiple.prototype.toggle = function (target) {
            var nodes = this._nodes;
            if (nodes.has(target)) {
                nodes.delete(target);
            }
            else {
                nodes.add(target);
            }
            this.onChange();
            return true;
        };
        DTreeDataSelectionMultiple.prototype.clear = function () {
            var nodes = this._nodes;
            if (0 < nodes.size) {
                nodes.clear();
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionMultiple.prototype.clearAndAdd = function (target) {
            var nodes = this._nodes;
            var size = nodes.size;
            if (size === 1) {
                if (nodes.has(target)) {
                    return false;
                }
                else {
                    nodes.clear();
                    nodes.add(target);
                    this.onChange();
                    return true;
                }
            }
            else {
                nodes.clear();
                nodes.add(target);
                this.onChange();
                return true;
            }
        };
        DTreeDataSelectionMultiple.prototype.clearAndAddAll = function (targets) {
            var isDirty = false;
            var newNodes = new Set();
            var oldNodes = this._nodes;
            for (var i = 0, imax = targets.length; i < imax; ++i) {
                var target = targets[i];
                if (!oldNodes.has(target)) {
                    isDirty = true;
                }
                newNodes.add(target);
            }
            if (!isDirty) {
                oldNodes.forEach(function (oldItem) {
                    if (!newNodes.has(oldItem)) {
                        isDirty = true;
                    }
                });
            }
            if (isDirty) {
                this._nodes = newNodes;
                this.onChange();
            }
            return isDirty;
        };
        DTreeDataSelectionMultiple.prototype.contains = function (target) {
            return this._nodes.has(target);
        };
        DTreeDataSelectionMultiple.prototype.size = function () {
            return this._nodes.size;
        };
        DTreeDataSelectionMultiple.prototype.isEmpty = function () {
            return this._nodes.size <= 0;
        };
        DTreeDataSelectionMultiple.prototype.each = function (iteratee) {
            var isCanceled = false;
            this._nodes.forEach(function (item) {
                if (!isCanceled) {
                    if (iteratee(item) === false) {
                        isCanceled = true;
                    }
                }
            });
        };
        DTreeDataSelectionMultiple.prototype.toArray = function () {
            var result = [];
            this._nodes.forEach(function (item) {
                result.push(item);
            });
            return result;
        };
        DTreeDataSelectionMultiple.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTreeDataSelectionMultiple.prototype.onNodeChange = function (nodes) {
            var oldNodes = this._nodes;
            if (0 < oldNodes.size) {
                var newNodes = this.newNodes(nodes, oldNodes, new Set());
                if (oldNodes.size !== newNodes.size) {
                    this._nodes = newNodes;
                    this.onChange();
                }
            }
        };
        DTreeDataSelectionMultiple.prototype.newNodes = function (items, existing, result) {
            var toChildren = this._parent.accessor.toChildren;
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (existing.has(item)) {
                    result.add(item);
                }
                var children = toChildren(item);
                if (children) {
                    this.newNodes(children, existing, result);
                }
            }
            return result;
        };
        return DTreeDataSelectionMultiple;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionSingle = /** @class */ (function (_super) {
        __extends(DTreeDataSelectionSingle, _super);
        function DTreeDataSelectionSingle(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._node = null;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTreeDataSelectionSingle.prototype, "type", {
            get: function () {
                return DTreeDataSelectionType.SINGLE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionSingle.prototype, "first", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionSingle.prototype, "last", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataSelectionSingle.prototype.get = function (index) {
            if (index === 0) {
                return this._node;
            }
            return null;
        };
        DTreeDataSelectionSingle.prototype.add = function (target) {
            if (this._node !== target) {
                this._node = target;
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionSingle.prototype.remove = function (target) {
            if (this._node === target) {
                this._node = null;
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionSingle.prototype.toggle = function (target) {
            if (this._node === target) {
                this._node = null;
            }
            else {
                this._node = target;
            }
            this.onChange();
            return true;
        };
        DTreeDataSelectionSingle.prototype.clear = function () {
            if (this._node != null) {
                this._node = null;
                this.onChange();
                return true;
            }
            return false;
        };
        DTreeDataSelectionSingle.prototype.clearAndAdd = function (target) {
            if (this._node === target) {
                return false;
            }
            else {
                this._node = target;
                this.onChange();
                return true;
            }
        };
        DTreeDataSelectionSingle.prototype.clearAndAddAll = function (targets) {
            if (0 < targets.length) {
                var last = targets[targets.length - 1];
                return this.clearAndAdd(last);
            }
            else {
                return this.clear();
            }
        };
        DTreeDataSelectionSingle.prototype.contains = function (target) {
            return this._node === target;
        };
        DTreeDataSelectionSingle.prototype.size = function () {
            return this._node != null ? 1 : 0;
        };
        DTreeDataSelectionSingle.prototype.isEmpty = function () {
            return this._node == null;
        };
        DTreeDataSelectionSingle.prototype.each = function (iteratee) {
            var node = this._node;
            if (node != null) {
                iteratee(node);
            }
        };
        DTreeDataSelectionSingle.prototype.toArray = function () {
            var node = this._node;
            if (node != null) {
                return [node];
            }
            return [];
        };
        DTreeDataSelectionSingle.prototype.onChange = function () {
            this._parent.update();
            this.emit("change", this);
        };
        DTreeDataSelectionSingle.prototype.onNodeChange = function (nodes) {
            var oldNode = this._node;
            if (oldNode != null) {
                var newNode = this.newNode(nodes, oldNode);
                if (oldNode !== newNode) {
                    this._node = newNode;
                    this.onChange();
                }
            }
        };
        DTreeDataSelectionSingle.prototype.newNode = function (items, existing) {
            var toChildren = this._parent.accessor.toChildren;
            for (var i = 0, imax = items.length; i < imax; ++i) {
                var item = items[i];
                if (existing === item) {
                    return item;
                }
                var children = toChildren(item);
                if (children) {
                    var result = this.newNode(children, existing);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        };
        return DTreeDataSelectionSingle;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataSelectionNone = /** @class */ (function (_super) {
        __extends(DTreeDataSelectionNone, _super);
        function DTreeDataSelectionNone(parent, options) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            // Events
            var on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (var name_1 in on) {
                    var handler = on[name_1];
                    if (handler) {
                        _this.on(name_1, handler);
                    }
                }
            }
            return _this;
        }
        Object.defineProperty(DTreeDataSelectionNone.prototype, "type", {
            get: function () {
                return DTreeDataSelectionType.NONE;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionNone.prototype, "first", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataSelectionNone.prototype, "last", {
            get: function () {
                return null;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataSelectionNone.prototype.get = function (index) {
            return null;
        };
        DTreeDataSelectionNone.prototype.add = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.remove = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.toggle = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.clear = function () {
            return false;
        };
        DTreeDataSelectionNone.prototype.clearAndAdd = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.clearAndAddAll = function (targets) {
            return false;
        };
        DTreeDataSelectionNone.prototype.contains = function (target) {
            return false;
        };
        DTreeDataSelectionNone.prototype.size = function () {
            return 0;
        };
        DTreeDataSelectionNone.prototype.isEmpty = function () {
            return true;
        };
        DTreeDataSelectionNone.prototype.each = function (iteratee) {
            // DO NOTHING
        };
        DTreeDataSelectionNone.prototype.toArray = function () {
            return [];
        };
        DTreeDataSelectionNone.prototype.onNodeChange = function (nodes) {
            // DO NOTHING
        };
        return DTreeDataSelectionNone;
    }(pixi_js.utils.EventEmitter));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeDataImpl = /** @class */ (function () {
        function DTreeDataImpl(parent, options) {
            this._parent = parent;
            this._nodeToFlag = new WeakMap();
            this._selection = this.toSelection(options);
            this._accessor = new DTreeNodeAccessorImpl(options);
            var mapped = new DTreeDataMappedImpl(this, !!(options === null || options === void 0 ? void 0 : options.reverse));
            this._mapped = mapped;
            var nodes = options === null || options === void 0 ? void 0 : options.nodes;
            if (nodes != null) {
                this._nodes = nodes;
                mapped.toDirty();
            }
            else {
                this._nodes = [];
            }
        }
        DTreeDataImpl.prototype.toSelection = function (options) {
            var selection = options === null || options === void 0 ? void 0 : options.selection;
            switch (selection === null || selection === void 0 ? void 0 : selection.type) {
                case DTreeDataSelectionType.NONE:
                case "NONE":
                    return new DTreeDataSelectionNone(this, selection);
                case DTreeDataSelectionType.MULTIPLE:
                case "MULTIPLE":
                    return new DTreeDataSelectionMultiple(this, selection);
                default:
                    return new DTreeDataSelectionSingle(this, selection);
            }
        };
        Object.defineProperty(DTreeDataImpl.prototype, "nodes", {
            get: function () {
                return this._nodes;
            },
            set: function (nodes) {
                this._nodes = nodes;
                this.update(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataImpl.prototype, "mapped", {
            get: function () {
                return this._mapped;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataImpl.prototype, "accessor", {
            get: function () {
                return this._accessor;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeDataImpl.prototype, "selection", {
            get: function () {
                return this._selection;
            },
            enumerable: false,
            configurable: true
        });
        DTreeDataImpl.prototype.update = function (forcibly) {
            if (forcibly) {
                this._mapped.toDirty();
                this._selection.onNodeChange(this._nodes);
            }
            this._parent.update(forcibly);
        };
        DTreeDataImpl.prototype.toggle = function (target) {
            var nodeToFlag = this._nodeToFlag;
            if (nodeToFlag.has(target)) {
                nodeToFlag.delete(target);
            }
            else {
                nodeToFlag.set(target, 1);
            }
            this._mapped.toDirty();
            this.update();
            return true;
        };
        DTreeDataImpl.prototype.expand = function (target) {
            var nodeToFlag = this._nodeToFlag;
            if (!nodeToFlag.has(target)) {
                nodeToFlag.set(target, 1);
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.collapse = function (target) {
            var nodeToFlag = this._nodeToFlag;
            if (nodeToFlag.has(target)) {
                nodeToFlag.delete(target);
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.expandAll = function () {
            var isDirty = false;
            var nodeToFlag = this._nodeToFlag;
            this.each(function (node) {
                if (!nodeToFlag.has(node)) {
                    nodeToFlag.set(node, 1);
                    isDirty = true;
                }
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.collapseAll = function () {
            var isDirty = false;
            var nodeToFlag = this._nodeToFlag;
            this.each(function (node) {
                if (nodeToFlag.has(node)) {
                    nodeToFlag.delete(node);
                    isDirty = true;
                }
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.isCollapsed = function (target) {
            return !this.isExpanded(target);
        };
        DTreeDataImpl.prototype.isExpanded = function (target) {
            return this._nodeToFlag.has(target);
        };
        DTreeDataImpl.prototype.clear = function () {
            var nodes = this._nodes;
            if (0 < nodes.length) {
                nodes.length = 0;
                this._mapped.toDirty();
                this._selection.clear();
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.remove = function (target) {
            var isDirty = false;
            this.each(function (node, index, nodes) {
                if (node === target) {
                    nodes.splice(index, 1);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this._selection.remove(target);
                this.update();
                return true;
            }
            return false;
        };
        DTreeDataImpl.prototype.add = function (target, parent) {
            var isDirty = false;
            if (parent) {
                var accessor = this._accessor;
                var children = accessor.toChildren(parent);
                if (children) {
                    children.push(target);
                    isDirty = true;
                }
                else {
                    var newChildren = accessor.newChildren(parent);
                    if (newChildren) {
                        newChildren.push(target);
                        isDirty = true;
                    }
                }
            }
            else {
                var nodes = this._nodes;
                if (nodes) {
                    nodes.push(target);
                }
                else {
                    this._nodes = [target];
                }
                isDirty = true;
            }
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return true;
        };
        DTreeDataImpl.prototype.addBefore = function (target, sibling) {
            var isDirty = false;
            this.each(function (node, index, nodes) {
                if (node === sibling) {
                    nodes.splice(index, 0, target);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return isDirty;
        };
        DTreeDataImpl.prototype.addAfter = function (target, sibling) {
            var isDirty = false;
            this.each(function (node, index, nodes) {
                if (node === sibling) {
                    nodes.splice(index + 1, 0, target);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return isDirty;
        };
        DTreeDataImpl.prototype.each = function (iteratee) {
            var value = this._nodes;
            if (value) {
                this.each_(value, null, iteratee);
            }
        };
        DTreeDataImpl.prototype.each_ = function (nodes, parent, iteratee) {
            var toChildren = this._accessor.toChildren;
            for (var i = 0, imax = nodes.length; i < imax; ++i) {
                var node = nodes[i];
                if (iteratee(node, i, nodes, parent) === false) {
                    return;
                }
                var children = toChildren(node);
                if (children) {
                    this.each_(children, node, iteratee);
                }
            }
        };
        return DTreeDataImpl;
    }());

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Tree item states.
     */
    var DTreeItemState = {
        /**
         * A node has children.
         */
        HAS_CHILDREN: "HAS_CHILDREN",
        /**
         * A node is opened.
         */
        OPENED: "OPENED"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemText = /** @class */ (function (_super) {
        __extends(DTreeItemText, _super);
        function DTreeItemText(data, options) {
            var _this = _super.call(this, options) || this;
            _this._padding = new DBasePaddingAdjustable(_this._padding);
            _this._data = data;
            return _this;
        }
        Object.defineProperty(DTreeItemText.prototype, "node", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeItemText.prototype, "value", {
            get: function () {
                return this._node;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeItemText.prototype, "index", {
            get: function () {
                return this._index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTreeItemText.prototype, "data", {
            get: function () {
                return this._data;
            },
            enumerable: false,
            configurable: true
        });
        DTreeItemText.prototype.toggle = function () {
            var node = this._node;
            if (node !== undefined) {
                this._data.toggle(node);
            }
        };
        DTreeItemText.prototype.set = function (node, index, forcibly) {
            var _a;
            var data = this._data;
            var isNodeChanged = forcibly || this._node !== node;
            if (isNodeChanged) {
                this._node = node;
                this._index = index;
                var accessor = data.accessor;
                this.text = accessor.toLabel(node);
                this.title = (_a = accessor.toTitle(node)) !== null && _a !== void 0 ? _a : "";
                this.image = accessor.toImage(node);
            }
            var level = data.mapped.levels[index];
            this._padding.adjLeft(this.theme.getLevelPadding(level));
            var children = data.accessor.toChildren(node);
            var hasChildren = !!(children && 0 < children.length);
            var state = this.state;
            state.lock();
            state.set(DBaseState.ACTIVE, data.selection.contains(node));
            state.remove(DBaseState.DISABLED);
            state.set(DTreeItemState.HAS_CHILDREN, hasChildren);
            state.set(DTreeItemState.OPENED, data.isExpanded(node));
            state.unlock();
            if (isNodeChanged) {
                this.emit("set", node, index, this);
            }
        };
        DTreeItemText.prototype.unset = function () {
            if (this._node !== undefined) {
                this._node = undefined;
                this._index = undefined;
                this.text = undefined;
                this.title = "";
                this.image = undefined;
                var state = this.state;
                state.lock();
                state.add(DBaseState.DISABLED);
                state.remove(DBaseState.ACTIVE);
                state.unlock();
                this.emit("unset", this);
            }
        };
        DTreeItemText.prototype.onSelect = function (e, value) {
            var data = this._data;
            var selection = data.selection;
            if (selection.type !== DTreeDataSelectionType.MULTIPLE) {
                selection.clearAndAdd(value);
            }
            else {
                var originalEvent = e && "data" in e ? e.data.originalEvent : e;
                if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.ctrlKey) {
                    selection.toggle(value);
                }
                else if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.shiftKey) {
                    var mapped = data.mapped;
                    var last_1 = selection.last;
                    if (value === last_1) {
                        selection.clearAndAdd(value);
                    }
                    else {
                        var isFound_1 = false;
                        var isReverse_1 = false;
                        var newSelection_1 = [];
                        mapped.each(function (node) {
                            if (isFound_1) {
                                if (isReverse_1) {
                                    newSelection_1.unshift(node);
                                    if (node === value) {
                                        return false;
                                    }
                                }
                                else {
                                    newSelection_1.push(node);
                                    if (node === last_1) {
                                        return false;
                                    }
                                }
                            }
                            else {
                                if (node === value) {
                                    isFound_1 = true;
                                    isReverse_1 = false;
                                    newSelection_1.push(node);
                                }
                                else if (node === last_1) {
                                    isFound_1 = true;
                                    isReverse_1 = true;
                                    newSelection_1.push(node);
                                }
                            }
                        });
                        selection.clearAndAddAll(newSelection_1);
                    }
                }
                else {
                    selection.clearAndAdd(value);
                }
            }
        };
        DTreeItemText.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                var node = this._node;
                if (node !== undefined) {
                    if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                        this._data.expand(node);
                    }
                }
            }
            if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                var node = this._node;
                if (node !== undefined) {
                    if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                        this._data.collapse(node);
                    }
                }
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTreeItemText.prototype.onKeyDownActivate = function (e) {
            if (this.state.isActionable && this.state.isFocused) {
                var node = this._node;
                if (node !== undefined) {
                    this.onSelect(e, node);
                }
                return true;
            }
            return false;
        };
        DTreeItemText.prototype.getType = function () {
            return "DTreeItemText";
        };
        return DTreeItemText;
    }(DImageBase));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemButton = /** @class */ (function (_super) {
        __extends(DTreeItemButton, _super);
        function DTreeItemButton(data, options) {
            var _this = this;
            var _a;
            _this = _super.call(this, data, options) || this;
            _this._when = toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : DButtonBaseWhen.CLICKED, DButtonBaseWhen);
            _this.on(UtilPointerEvent.tap, function (e) {
                _this.onClick(e);
            });
            return _this;
        }
        DTreeItemButton.prototype.onClick = function (e) {
            if (this._when === DButtonBaseWhen.CLICKED && this.state.isActionable) {
                this.activate(e);
            }
        };
        DTreeItemButton.prototype.onDblClick = function (e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED) {
                this.activate(e);
            }
            return _super.prototype.onDblClick.call(this, e, interactionManager);
        };
        DTreeItemButton.prototype.activate = function (e) {
            this.onActivate(e);
        };
        DTreeItemButton.prototype.onActivate = function (e) {
            this.emit("active", this);
        };
        DTreeItemButton.prototype.onActivateKeyDown = function (e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        };
        DTreeItemButton.prototype.onActivateKeyUp = function (e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.activate(e);
                }
                this.state.isPressed = false;
            }
        };
        DTreeItemButton.prototype.onKeyDown = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTreeItemButton.prototype.onKeyUp = function (e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return _super.prototype.onKeyUp.call(this, e);
        };
        DTreeItemButton.prototype.getType = function () {
            return "DTreeItemButton";
        };
        return DTreeItemButton;
    }(DTreeItemText));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemNonEditable = /** @class */ (function (_super) {
        __extends(DTreeItemNonEditable, _super);
        function DTreeItemNonEditable() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTreeItemNonEditable.prototype.onActivate = function (e) {
            _super.prototype.onActivate.call(this, e);
            var node = this._node;
            if (node !== undefined) {
                if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                    if (e && "data" in e) {
                        var local = this.toLocal(e.data.global, undefined, DTreeItemNonEditable.WORK_CONTAINS_POINT);
                        if (local.x <= this.padding.getLeft()) {
                            this.toggle();
                        }
                        else {
                            this.onSelect(e, node);
                        }
                    }
                }
                else {
                    this.onSelect(e, node);
                }
            }
        };
        DTreeItemNonEditable.prototype.getType = function () {
            return "DTreeItemNonEditable";
        };
        return DTreeItemNonEditable;
    }(DTreeItemButton));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTreeItemUpdater = /** @class */ (function (_super) {
        __extends(DTreeItemUpdater, _super);
        function DTreeItemUpdater() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DTreeItemUpdater.prototype.toMapped = function (data) {
            return data.mapped;
        };
        DTreeItemUpdater.prototype.newItem = function (data) {
            return new DTreeItemNonEditable(data);
        };
        return DTreeItemUpdater;
    }(DItemUpdater));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    var DTree = /** @class */ (function (_super) {
        __extends(DTree, _super);
        function DTree(options) {
            var _this = _super.call(this, options) || this;
            _this.update();
            return _this;
        }
        DTree.prototype.onContentChange = function () {
            _super.prototype.onContentChange.call(this);
            this.update();
        };
        DTree.prototype.onResize = function (newWidth, newHeight, oldWidth, oldHeight) {
            var updater = this.updater;
            updater.lock();
            _super.prototype.onResize.call(this, newWidth, newHeight, oldWidth, oldHeight);
            updater.update();
            updater.unlock(true);
        };
        Object.defineProperty(DTree.prototype, "updater", {
            get: function () {
                var result = this._updater;
                if (result == null) {
                    result = this.newUpdater(this.data, this.content, this._options);
                    this._updater = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTree.prototype.newUpdater = function (data, content, options) {
            return new DTreeItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        };
        Object.defineProperty(DTree.prototype, "data", {
            get: function () {
                var result = this._data;
                if (result == null) {
                    result = this.toData(this._options);
                    this._data = result;
                }
                return result;
            },
            enumerable: false,
            configurable: true
        });
        DTree.prototype.toData = function (options) {
            var data = (options && (options.data || options.nodes || options.value)) || [];
            if (isArray(data)) {
                return new DTreeDataImpl(this, {
                    nodes: data
                });
            }
            else if ("add" in data) {
                return data;
            }
            else {
                return new DTreeDataImpl(this, data);
            }
        };
        DTree.prototype.update = function (forcibly) {
            this.updater.update(forcibly);
        };
        DTree.prototype.lock = function () {
            this.updater.lock();
        };
        DTree.prototype.unlock = function (callIfNeeded) {
            this.updater.unlock(callIfNeeded);
        };
        Object.defineProperty(DTree.prototype, "selection", {
            get: function () {
                return this.data.selection;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTree.prototype, "value", {
            get: function () {
                return this.data.nodes;
            },
            set: function (value) {
                this.data.nodes = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DTree.prototype, "nodes", {
            get: function () {
                return this.data.nodes;
            },
            set: function (nodes) {
                this.data.nodes = nodes;
            },
            enumerable: false,
            configurable: true
        });
        DTree.prototype.toggle = function (target) {
            return this.data.toggle(target);
        };
        DTree.prototype.expand = function (target) {
            return this.data.expand(target);
        };
        DTree.prototype.collapse = function (target) {
            return this.data.collapse(target);
        };
        DTree.prototype.expandAll = function () {
            return this.data.expandAll();
        };
        DTree.prototype.collapseAll = function () {
            return this.data.collapseAll();
        };
        DTree.prototype.isCollapsed = function (target) {
            return this.data.isCollapsed(target);
        };
        DTree.prototype.isExpanded = function (target) {
            return this.data.isExpanded(target);
        };
        DTree.prototype.clear = function () {
            return this.data.clear();
        };
        DTree.prototype.remove = function (target) {
            return this.data.remove(target);
        };
        DTree.prototype.add = function (target, parent) {
            return this.data.add(target, parent);
        };
        DTree.prototype.addBefore = function (target, sibling) {
            return this.data.addBefore(target, sibling);
        };
        DTree.prototype.addAfter = function (target, sibling) {
            return this.data.addAfter(target, sibling);
        };
        DTree.prototype.each = function (iteratee) {
            return this.data.each(iteratee);
        };
        DTree.prototype.onKeyDown = function (e) {
            this.updater.moveFocus(e, this, true, false);
            return _super.prototype.onKeyDown.call(this, e);
        };
        DTree.prototype.getType = function () {
            return "DTree";
        };
        return DTree;
    }(DPane));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */

    var ui = {
        __proto__: null,
        loadAll: loadAll,
        loadMenuItemAll: loadMenuItemAll,
        loadMenuItemExpandable: loadMenuItemExpandable,
        loadMenuItem: loadMenuItem,
        loadMenuSidedItemExpandable: loadMenuSidedItemExpandable,
        loadMenuSidedItem: loadMenuSidedItem,
        deserializeActionValue: deserializeActionValue,
        EShapeActionBases: EShapeActionBases,
        EShapeActionEnvironment: EShapeActionEnvironment,
        EShapeActionExpressions: EShapeActionExpressions,
        EShapeActionOpenDialogExtensions: EShapeActionOpenDialogExtensions,
        EShapeActionOpenExtensions: EShapeActionOpenExtensions,
        EShapeActionOpenOpeners: EShapeActionOpenOpeners,
        EShapeActionRuntimeBase: EShapeActionRuntimeBase,
        EShapeActionRuntimeBlinkBrighten: EShapeActionRuntimeBlinkBrighten,
        EShapeActionRuntimeBlinkColorFill: EShapeActionRuntimeBlinkColorFill,
        EShapeActionRuntimeBlinkColorStroke: EShapeActionRuntimeBlinkColorStroke,
        EShapeActionRuntimeBlinkDarken: EShapeActionRuntimeBlinkDarken,
        EShapeActionRuntimeBlinkOpacity: EShapeActionRuntimeBlinkOpacity,
        EShapeActionRuntimeBlinkVisibility: EShapeActionRuntimeBlinkVisibility,
        EShapeActionRuntimeBlink: EShapeActionRuntimeBlink,
        EShapeActionRuntimeChangeColorBrightness: EShapeActionRuntimeChangeColorBrightness,
        EShapeActionRuntimeChangeColorCode: EShapeActionRuntimeChangeColorCode,
        EShapeActionRuntimeChangeColor: EShapeActionRuntimeChangeColor,
        EShapeActionRuntimeChangeCursor: EShapeActionRuntimeChangeCursor,
        EShapeActionRuntimeChangeTextNumber: EShapeActionRuntimeChangeTextNumber,
        EShapeActionRuntimeChangeTextText: EShapeActionRuntimeChangeTextText,
        EShapeActionRuntimeConditional: EShapeActionRuntimeConditional,
        EShapeActionRuntimeEmitEvent: EShapeActionRuntimeEmitEvent,
        EShapeActionRuntimeGestureLayer: EShapeActionRuntimeGestureLayer,
        EShapeActionRuntimeGestureShape: EShapeActionRuntimeGestureShape,
        EShapeActionRuntimeMiscEmitEvent: EShapeActionRuntimeMiscEmitEvent,
        EShapeActionRuntimeMiscExecute: EShapeActionRuntimeMiscExecute,
        EShapeActionRuntimeMiscHtmlElement: EShapeActionRuntimeMiscHtmlElement,
        EShapeActionRuntimeMiscInputInput: EShapeActionRuntimeMiscInputInput,
        EShapeActionRuntimeMiscInputInteger: EShapeActionRuntimeMiscInputInteger,
        EShapeActionRuntimeMiscInputNumber: EShapeActionRuntimeMiscInputNumber,
        EShapeActionRuntimeMiscInputReal: EShapeActionRuntimeMiscInputReal,
        EShapeActionRuntimeMiscInputText: EShapeActionRuntimeMiscInputText,
        EShapeActionRuntimeMiscInput: EShapeActionRuntimeMiscInput,
        EShapeActionRuntimeMiscWriteBoth: EShapeActionRuntimeMiscWriteBoth,
        EShapeActionRuntimeMiscWriteLocal: EShapeActionRuntimeMiscWriteLocal,
        EShapeActionRuntimeMiscWriteRemote: EShapeActionRuntimeMiscWriteRemote,
        EShapeActionRuntimeMiscWrite: EShapeActionRuntimeMiscWrite,
        EShapeActionRuntimeOpenDialogBoolean: EShapeActionRuntimeOpenDialogBoolean,
        EShapeActionRuntimeOpenDialogDate: EShapeActionRuntimeOpenDialogDate,
        EShapeActionRuntimeOpenDialogDatetime: EShapeActionRuntimeOpenDialogDatetime,
        EShapeActionRuntimeOpenDialogExtension: EShapeActionRuntimeOpenDialogExtension,
        EShapeActionRuntimeOpenDialogInteger: EShapeActionRuntimeOpenDialogInteger,
        EShapeActionRuntimeOpenDialogReal: EShapeActionRuntimeOpenDialogReal,
        EShapeActionRuntimeOpenDialogText: EShapeActionRuntimeOpenDialogText,
        EShapeActionRuntimeOpenDialogTime: EShapeActionRuntimeOpenDialogTime,
        EShapeActionRuntimeOpenDialog: EShapeActionRuntimeOpenDialog,
        EShapeActionRuntimeOpen: EShapeActionRuntimeOpen,
        EShapeActionRuntimeShowHideLayer: EShapeActionRuntimeShowHideLayer,
        EShapeActionRuntimeShowHideShape: EShapeActionRuntimeShowHideShape,
        EShapeActionRuntimeShowHide: EShapeActionRuntimeShowHide,
        EShapeActionRuntimeTransformMoveAbsoluteX: EShapeActionRuntimeTransformMoveAbsoluteX,
        EShapeActionRuntimeTransformMoveAbsoluteY: EShapeActionRuntimeTransformMoveAbsoluteY,
        EShapeActionRuntimeTransformMoveForwardOrBackward: EShapeActionRuntimeTransformMoveForwardOrBackward,
        EShapeActionRuntimeTransformMoveLeftOrRight: EShapeActionRuntimeTransformMoveLeftOrRight,
        EShapeActionRuntimeTransformMoveRelativeX: EShapeActionRuntimeTransformMoveRelativeX,
        EShapeActionRuntimeTransformMoveRelativeY: EShapeActionRuntimeTransformMoveRelativeY,
        EShapeActionRuntimeTransformMove: EShapeActionRuntimeTransformMove,
        EShapeActionRuntimeTransformResizeHeightAbsolute: EShapeActionRuntimeTransformResizeHeightAbsolute,
        EShapeActionRuntimeTransformResizeHeightRelative: EShapeActionRuntimeTransformResizeHeightRelative,
        EShapeActionRuntimeTransformResizeSizeAbsolute: EShapeActionRuntimeTransformResizeSizeAbsolute,
        EShapeActionRuntimeTransformResizeSizeRelative: EShapeActionRuntimeTransformResizeSizeRelative,
        EShapeActionRuntimeTransformResizeWidthAbsolute: EShapeActionRuntimeTransformResizeWidthAbsolute,
        EShapeActionRuntimeTransformResizeWidthRelative: EShapeActionRuntimeTransformResizeWidthRelative,
        EShapeActionRuntimeTransformResize: EShapeActionRuntimeTransformResize,
        EShapeActionRuntimeTransformRotateAbsolute: EShapeActionRuntimeTransformRotateAbsolute,
        EShapeActionRuntimeTransformRotateRelative: EShapeActionRuntimeTransformRotateRelative,
        EShapeActionRuntimeTransformRotate: EShapeActionRuntimeTransformRotate,
        EShapeActionRuntimes: EShapeActionRuntimes,
        EShapeActionValueBase: EShapeActionValueBase,
        EShapeActionValueBlinkType: EShapeActionValueBlinkType,
        EShapeActionValueBlink: EShapeActionValueBlink,
        EShapeActionValueChangeColorBrightness: EShapeActionValueChangeColorBrightness,
        EShapeActionValueChangeColorCode: EShapeActionValueChangeColorCode,
        EShapeActionValueChangeColorTarget: EShapeActionValueChangeColorTarget,
        EShapeActionValueChangeColorTypeLegacy: EShapeActionValueChangeColorTypeLegacy,
        EShapeActionValueChangeColorType: EShapeActionValueChangeColorType,
        EShapeActionValueChangeColorTypes: EShapeActionValueChangeColorTypes,
        EShapeActionValueChangeColor: EShapeActionValueChangeColor,
        EShapeActionValueChangeCursor: EShapeActionValueChangeCursor,
        EShapeActionValueChangeTextType: EShapeActionValueChangeTextType,
        EShapeActionValueChangeText: EShapeActionValueChangeText,
        EShapeActionValueDeserializers: EShapeActionValueDeserializers,
        EShapeActionValueEmitEvent: EShapeActionValueEmitEvent,
        EShapeActionValueGestureOperationType: EShapeActionValueGestureOperationType,
        EShapeActionValueGestureType: EShapeActionValueGestureType,
        EShapeActionValueGesture: EShapeActionValueGesture,
        EShapeActionValueMiscEmitEvent: EShapeActionValueMiscEmitEvent,
        EShapeActionValueMiscExecute: EShapeActionValueMiscExecute,
        EShapeActionValueMiscHtmlElement: EShapeActionValueMiscHtmlElement,
        EShapeActionValueMiscInput: EShapeActionValueMiscInput,
        EShapeActionValueMiscType: EShapeActionValueMiscType,
        EShapeActionValueMiscWrite: EShapeActionValueMiscWrite,
        EShapeActionValueMisc: EShapeActionValueMisc,
        EShapeActionValueOnInputAction: EShapeActionValueOnInputAction,
        EShapeActionValueOnInputActions: EShapeActionValueOnInputActions,
        EShapeActionValueOpenDialogExtension: EShapeActionValueOpenDialogExtension,
        EShapeActionValueOpenDialogType: EShapeActionValueOpenDialogType,
        EShapeActionValueOpenDialog: EShapeActionValueOpenDialog,
        EShapeActionValueOpenExtension: EShapeActionValueOpenExtension,
        EShapeActionValueOpenType: EShapeActionValueOpenType,
        EShapeActionValueOpen: EShapeActionValueOpen,
        EShapeActionValueOpetyped: EShapeActionValueOpetyped,
        EShapeActionValueShowHideLayer: EShapeActionValueShowHideLayer,
        EShapeActionValueShowHideShape: EShapeActionValueShowHideShape,
        EShapeActionValueShowHideType: EShapeActionValueShowHideType,
        EShapeActionValueShowHide: EShapeActionValueShowHide,
        EShapeActionValueSubtyped: EShapeActionValueSubtyped,
        EShapeActionValueTransformMoveType: EShapeActionValueTransformMoveType,
        EShapeActionValueTransformMove: EShapeActionValueTransformMove,
        EShapeActionValueTransformResizeType: EShapeActionValueTransformResizeType,
        EShapeActionValueTransformResize: EShapeActionValueTransformResize,
        EShapeActionValueTransformRotateType: EShapeActionValueTransformRotateType,
        EShapeActionValueTransformRotate: EShapeActionValueTransformRotate,
        EShapeActionValueTransformType: EShapeActionValueTransformType,
        EShapeActionValueType: EShapeActionValueType,
        EShapeActionValues: EShapeActionValues,
        EShapeAction: EShapeAction,
        EShapeActions: EShapeActions,
        loadShapeAll: loadShapeAll,
        loadShapeBar: loadShapeBar,
        loadShapeButton: loadShapeButton,
        loadShapeCircle: loadShapeCircle,
        loadShapeClipperEx: loadShapeClipperEx,
        isShapeClipperExLoaded: isShapeClipperExLoaded,
        loadShapeConnectorElbow: loadShapeConnectorElbow,
        loadShapeConnectorLine: loadShapeConnectorLine,
        loadShapeEmbedded: loadShapeEmbedded,
        loadShapeGroupShadowed: loadShapeGroupShadowed,
        loadShapeGroup: loadShapeGroup,
        loadShapeImage: loadShapeImage,
        loadShapeLabel: loadShapeLabel,
        loadShapeLineOfCircles: loadShapeLineOfCircles,
        loadShapeLineOfRectangleRoundeds: loadShapeLineOfRectangleRoundeds,
        loadShapeLineOfRectangles: loadShapeLineOfRectangles,
        loadShapeLineOfTriangleRoundeds: loadShapeLineOfTriangleRoundeds,
        loadShapeLineOfTriangles: loadShapeLineOfTriangles,
        loadShapeLine: loadShapeLine,
        loadShapeNull: loadShapeNull,
        loadShapeRectangleRounded: loadShapeRectangleRounded,
        loadShapeRectangle: loadShapeRectangle,
        loadShapeSemicircle: loadShapeSemicircle,
        loadShapeTriangleRounded: loadShapeTriangleRounded,
        loadShapeTriangle: loadShapeTriangle,
        BAR_VERTEX_COUNT: BAR_VERTEX_COUNT,
        BAR_INDEX_COUNT: BAR_INDEX_COUNT,
        buildBarClipping: buildBarClipping,
        buildBarIndex: buildBarIndex,
        buildBarVertexStepAndColorFill: buildBarVertexStepAndColorFill,
        buildBarUv: buildBarUv,
        CIRCLE_VERTEX_COUNT: CIRCLE_VERTEX_COUNT,
        CIRCLE_INDEX_COUNT: CIRCLE_INDEX_COUNT,
        CIRCLE_WORLD_SIZE: CIRCLE_WORLD_SIZE,
        buildCircleClipping: buildCircleClipping,
        buildCircleIndex: buildCircleIndex,
        buildCircleVertex: buildCircleVertex,
        buildCircleStep: buildCircleStep,
        buildCircleUv: buildCircleUv,
        buildColor: buildColor,
        IMAGE_SDF_VERTEX_COUNT: IMAGE_SDF_VERTEX_COUNT,
        IMAGE_SDF_INDEX_COUNT: IMAGE_SDF_INDEX_COUNT,
        IMAGE_SDF_WORLD_SIZE: IMAGE_SDF_WORLD_SIZE,
        buildImageSdfClipping: buildImageSdfClipping,
        buildImageSdfIndex: buildImageSdfIndex,
        buildImageSdfStep: buildImageSdfStep,
        buildImageSdfVertex: buildImageSdfVertex,
        buildImageSdfUv: buildImageSdfUv,
        toLineOfAnyPointCount: toLineOfAnyPointCount,
        buildLineOfAnyColor: buildLineOfAnyColor,
        toPointsCount: toPointsCount,
        toLinePointCount: toLinePointCount,
        toLineVertexCount: toLineVertexCount,
        toLineIndexCount: toLineIndexCount,
        buildLineClipping: buildLineClipping,
        buildLineIndex: buildLineIndex,
        buildLineUv: buildLineUv,
        buildLineVertexStepAndColorFill: buildLineVertexStepAndColorFill,
        buildNullClipping: buildNullClipping,
        buildNullIndex: buildNullIndex,
        buildNullVertex: buildNullVertex,
        buildNullStep: buildNullStep,
        buildNullUv: buildNullUv,
        RECTANGLE_ROUNDED_VERTEX_COUNT: RECTANGLE_ROUNDED_VERTEX_COUNT,
        RECTANGLE_ROUNDED_INDEX_COUNT: RECTANGLE_ROUNDED_INDEX_COUNT,
        RECTANGLE_ROUNDED_WORLD_SIZE: RECTANGLE_ROUNDED_WORLD_SIZE,
        buildRectangleRoundedIndex: buildRectangleRoundedIndex,
        buildRectangleRoundedVertex: buildRectangleRoundedVertex,
        buildRectangleRoundedClipping: buildRectangleRoundedClipping,
        buildRectangleRoundedStep: buildRectangleRoundedStep,
        buildRectangleRoundedUv: buildRectangleRoundedUv,
        RECTANGLE_VERTEX_COUNT: RECTANGLE_VERTEX_COUNT,
        RECTANGLE_INDEX_COUNT: RECTANGLE_INDEX_COUNT,
        RECTANGLE_WORLD_SIZE: RECTANGLE_WORLD_SIZE,
        buildRectangleClipping: buildRectangleClipping,
        buildRectangleIndex: buildRectangleIndex,
        buildRectangleVertex: buildRectangleVertex,
        buildRectangleStep: buildRectangleStep,
        buildRectangleUv: buildRectangleUv,
        SEMICIRCLE_VERTEX_COUNT: SEMICIRCLE_VERTEX_COUNT,
        SEMICIRCLE_INDEX_COUNT: SEMICIRCLE_INDEX_COUNT,
        SEMICIRCLE_WORLD_SIZE: SEMICIRCLE_WORLD_SIZE,
        buildSemicircleClipping: buildSemicircleClipping,
        buildSemicircleIndex: buildSemicircleIndex,
        buildSemicircleVertex: buildSemicircleVertex,
        buildSemicircleStep: buildSemicircleStep,
        buildSemicircleUv: buildSemicircleUv,
        TEXT_VERTEX_COUNT: TEXT_VERTEX_COUNT,
        TEXT_INDEX_COUNT: TEXT_INDEX_COUNT,
        TEXT_FMIN: TEXT_FMIN,
        toTextBufferCount: toTextBufferCount,
        buildTextClipping: buildTextClipping,
        buildTextIndex: buildTextIndex,
        buildTextStep: buildTextStep,
        buildTextVertex: buildTextVertex,
        TRIANGLE_ROUNDED_VERTEX_COUNT: TRIANGLE_ROUNDED_VERTEX_COUNT,
        TRIANGLE_ROUNDED_INDEX_COUNT: TRIANGLE_ROUNDED_INDEX_COUNT,
        TRIANGLE_ROUNDED_WORLD_SIZE: TRIANGLE_ROUNDED_WORLD_SIZE,
        buildTriangleRoundedIndex: buildTriangleRoundedIndex,
        buildTriangleRoundedVertex: buildTriangleRoundedVertex,
        buildTriangleRoundedClipping: buildTriangleRoundedClipping,
        buildTriangleRoundedStep: buildTriangleRoundedStep,
        buildTriangleRoundedUv: buildTriangleRoundedUv,
        TRIANGLE_VERTEX_COUNT: TRIANGLE_VERTEX_COUNT,
        TRIANGLE_INDEX_COUNT: TRIANGLE_INDEX_COUNT,
        TRIANGLE_WORLD_SIZE: TRIANGLE_WORLD_SIZE,
        buildTriangleClipping: buildTriangleClipping,
        buildTriangleIndex: buildTriangleIndex,
        buildTriangleVertex: buildTriangleVertex,
        buildTriangleStep: buildTriangleStep,
        buildTriangleUv: buildTriangleUv,
        BuilderBar: BuilderBar,
        BuilderBase: BuilderBase,
        BuilderCircle: BuilderCircle,
        BuilderImageSdf: BuilderImageSdf,
        BuilderLabel: BuilderLabel,
        BuilderLineOfAny: BuilderLineOfAny,
        BuilderLineOfCircles: BuilderLineOfCircles,
        BuilderLineOfRectangleRoundeds: BuilderLineOfRectangleRoundeds,
        BuilderLineOfRectangles: BuilderLineOfRectangles,
        BuilderLineOfTriangleRoundeds: BuilderLineOfTriangleRoundeds,
        BuilderLineOfTriangles: BuilderLineOfTriangles,
        BuilderLine: BuilderLine,
        BuilderMarkerCircleHead: BuilderMarkerCircleHead,
        BuilderMarkerCircleTail: BuilderMarkerCircleTail,
        BuilderMarkerCircle: BuilderMarkerCircle,
        BuilderMarkerRectangleHead: BuilderMarkerRectangleHead,
        BuilderMarkerRectangleTail: BuilderMarkerRectangleTail,
        BuilderMarkerRectangle: BuilderMarkerRectangle,
        BuilderMarkerTriangleHead: BuilderMarkerTriangleHead,
        BuilderMarkerTriangleTail: BuilderMarkerTriangleTail,
        BuilderMarkerTriangle: BuilderMarkerTriangle,
        BuilderNull: BuilderNull,
        BuilderRectanglePivoted: BuilderRectanglePivoted,
        BuilderRectangleRounded: BuilderRectangleRounded,
        BuilderRectangle: BuilderRectangle,
        BuilderSemicircle: BuilderSemicircle,
        BuilderText: BuilderText,
        BuilderTriangleRounded: BuilderTriangleRounded,
        BuilderTriangle: BuilderTriangle,
        toTransformLocalId: toTransformLocalId,
        toTexture: toTexture,
        toTextureTransformId: toTextureTransformId,
        toTextureUvs: toTextureUvs,
        copyClipping: copyClipping,
        copyIndex: copyIndex,
        copyStep: copyStep,
        copyUvs: copyUvs,
        copyVertex: copyVertex,
        createBarUploaded: createBarUploaded,
        createButtonUploaded: createButtonUploaded,
        createCircleUploaded: createCircleUploaded,
        createRectanglePivotedUploaded: createRectanglePivotedUploaded,
        createGroupUploaded: createGroupUploaded,
        createImageSdfUploaded: createImageSdfUploaded,
        createImageSdf: createImageSdf,
        createImage: createImage,
        createLabelUploaded: createLabelUploaded,
        createLineOfAnyUploaded: createLineOfAnyUploaded,
        createLineOfCirclesUploaded: createLineOfCirclesUploaded,
        createLineOfRectangleRoundedsUploaded: createLineOfRectangleRoundedsUploaded,
        createLineOfRectanglesUploaded: createLineOfRectanglesUploaded,
        createLineOfTriangleRoundedsUploaded: createLineOfTriangleRoundedsUploaded,
        createLineOfTrianglesUploaded: createLineOfTrianglesUploaded,
        createLineUploaded: createLineUploaded,
        createLine: createLine,
        createNullUploaded: createNullUploaded,
        createRectangleRoundedUploaded: createRectangleRoundedUploaded,
        createRectangleUploaded: createRectangleUploaded,
        createSemicircleUploaded: createSemicircleUploaded,
        createTriangleRoundedUploaded: createTriangleRoundedUploaded,
        createTriangleUploaded: createTriangleUploaded,
        deserializeAll: deserializeAll,
        deserializeBar: deserializeBar,
        deserializeBase: deserializeBase,
        deserializeButton: deserializeButton,
        deserializeCircle: deserializeCircle,
        deserializeConnectorElbow: deserializeConnectorElbow,
        deserializeConnectorLine: deserializeConnectorLine,
        onDeserializedConnectorLine: onDeserializedConnectorLine,
        deserializeEmbedded: deserializeEmbedded,
        deserializeEmbeddedLayer: deserializeEmbeddedLayer,
        deserializeGradient: deserializeGradient,
        deserializeGroupShadowed: deserializeGroupShadowed,
        deserializeGroup: deserializeGroup,
        deserializeImageSdf: deserializeImageSdf,
        deserializeImage: deserializeImage,
        deserializeLabel: deserializeLabel,
        deserializeLineOfCircles: deserializeLineOfCircles,
        deserializeLineOfRectangleRoundeds: deserializeLineOfRectangleRoundeds,
        deserializeLineOfRectangles: deserializeLineOfRectangles,
        deserializeLineOfTriangleRoundeds: deserializeLineOfTriangleRoundeds,
        deserializeLineOfTriangles: deserializeLineOfTriangles,
        deserializeLine: deserializeLine,
        deserializeNull: deserializeNull,
        deserializeRectanglePivoted: deserializeRectanglePivoted,
        deserializeRectangleRounded: deserializeRectangleRounded,
        deserializeRectangle: deserializeRectangle,
        deserializeSemicircle: deserializeSemicircle,
        deserializeTriangleRounded: deserializeTriangleRounded,
        deserializeTriangle: deserializeTriangle,
        deserialize: deserialize,
        EShapeBarPoints: EShapeBarPoints,
        EShapeBarPosition: EShapeBarPosition,
        EShapeBar: EShapeBar,
        EShapeBaseHitTestData: EShapeBaseHitTestData,
        EShapeBase: EShapeBase,
        EShapeButtonRuntimeActionToggle: EShapeButtonRuntimeActionToggle,
        EShapeButtonRuntimeAction: EShapeButtonRuntimeAction,
        EShapeButtonRuntime: EShapeButtonRuntime,
        EShapeButton: EShapeButton,
        EShapeCircle: EShapeCircle,
        EShapeConnectorElbowPointsFiller: EShapeConnectorElbowPointsFiller,
        EShapeConnectorElbow: EShapeConnectorElbow,
        EShapeConnectorLine: EShapeConnectorLine,
        EShapeEmbeddedDatum: EShapeEmbeddedDatum,
        EShapeEmbeddedLayerContainer: EShapeEmbeddedLayerContainer,
        EShapeEmbeddedLayer: EShapeEmbeddedLayer,
        EShapeEmbedded: EShapeEmbedded,
        EShapeEmbeddeds: EShapeEmbeddeds,
        EShapeFillImpl: EShapeFillImpl,
        EShapeGroupFillEditor: EShapeGroupFillEditor,
        EShapeGroupFillViewer: EShapeGroupFillViewer,
        EShapeGroupPoints: EShapeGroupPoints,
        EShapeGroupShadowed: EShapeGroupShadowed,
        EShapeGroupSizeEditor: EShapeGroupSizeEditor,
        EShapeGroupSizeLayout: EShapeGroupSizeLayout,
        EShapeGroupSizeShadowed: EShapeGroupSizeShadowed,
        EShapeGroupSizeViewer: EShapeGroupSizeViewer,
        EShapeGroupStrokeEditor: EShapeGroupStrokeEditor,
        EShapeGroupStrokeViewer: EShapeGroupStrokeViewer,
        EShapeGroupViewer: EShapeGroupViewer,
        EShapeGroup: EShapeGroup,
        EShapeImageSdf: EShapeImageSdf,
        EShapeImage: EShapeImage,
        EShapeLabel: EShapeLabel,
        EShapeLineBaseHitPart: EShapeLineBaseHitPart,
        EShapeLineBase: EShapeLineBase,
        EShapeLineOfAnyPointsFillImpl: EShapeLineOfAnyPointsFillImpl,
        EShapeLineOfAnyPointsImpl: EShapeLineOfAnyPointsImpl,
        EShapeLineOfAnyPointsPointImpl: EShapeLineOfAnyPointsPointImpl,
        EShapeLineOfAnyPointsStrokeImpl: EShapeLineOfAnyPointsStrokeImpl,
        EShapeLineOfCircles: EShapeLineOfCircles,
        EShapeLineOfRectangleRoundeds: EShapeLineOfRectangleRoundeds,
        EShapeLineOfRectangles: EShapeLineOfRectangles,
        EShapeLineOfTriangleRoundeds: EShapeLineOfTriangleRoundeds,
        EShapeLineOfTriangles: EShapeLineOfTriangles,
        EShapeLinePoints: EShapeLinePoints,
        EShapeLine: EShapeLine,
        EShapeNull: EShapeNull,
        EShapePrimitive: EShapePrimitive,
        EShapeRectanglePivoted: EShapeRectanglePivoted,
        EShapeRectangleRounded: EShapeRectangleRounded,
        EShapeRectangle: EShapeRectangle,
        EShapeSemicircle: EShapeSemicircle,
        EShapeStrokeImpl: EShapeStrokeImpl,
        EShapeTextAlignImpl: EShapeTextAlignImpl,
        EShapeTextImpl: EShapeTextImpl,
        EShapeTextOffsetImpl: EShapeTextOffsetImpl,
        EShapeTextOutlineImpl: EShapeTextOutlineImpl,
        EShapeTriangleRounded: EShapeTriangleRounded,
        EShapeTriangle: EShapeTriangle,
        hitTestBBox: hitTestBBox,
        hitTestCircle: hitTestCircle,
        hitTestSemicircle: hitTestSemicircle,
        hitTestRectangleRounded: hitTestRectangleRounded,
        hitTestRectangle: hitTestRectangle,
        hitTestTriangleRounded: hitTestTriangleRounded,
        hitTestTriangleFilled: hitTestTriangleFilled,
        hitTestTriangle: hitTestTriangle,
        isStatic: isStatic,
        toComputed: toComputed,
        toDash: toDash,
        toGradientImageUrl: toGradientImageUrl,
        toGradientSerialized: toGradientSerialized,
        toImageElement: toImageElement,
        toLength: toLength,
        toResized: toResized,
        toScaleInvariant: toScaleInvariant,
        toSizeNormalized: toSizeNormalized,
        toSizeRounded: toSizeRounded,
        toThresholdDefault: toThresholdDefault,
        EShapeAcceptorImpl: EShapeAcceptorImpl,
        EShapeAcceptorType: EShapeAcceptorType,
        EShapeAcceptors: EShapeAcceptors,
        EShapeBufferUnitBuilder: EShapeBufferUnitBuilder,
        EShapeBufferUnit: EShapeBufferUnit,
        EShapeBuffer: EShapeBuffer,
        EShapeCapabilities: EShapeCapabilities,
        EShapeCapabilityContainerImpl: EShapeCapabilityContainerImpl,
        EShapeCapability: EShapeCapability,
        EShapeConnectorBodies: EShapeConnectorBodies,
        EShapeConnectorBodyImpl: EShapeConnectorBodyImpl,
        EShapeConnectorContainerImpl: EShapeConnectorContainerImpl,
        EShapeConnectorEdgeAcceptorImpl: EShapeConnectorEdgeAcceptorImpl,
        EShapeConnectorEdgeContainerImpl: EShapeConnectorEdgeContainerImpl,
        EShapeConnectorEdgeImpl: EShapeConnectorEdgeImpl,
        EShapeConnectors: EShapeConnectors,
        EShapeContainer: EShapeContainer,
        EShapeCopyPart: EShapeCopyPart,
        EShapeCorner: EShapeCorner,
        EShapeDataImpl: EShapeDataImpl,
        EShapeDataMapperImpl: EShapeDataMapperImpl,
        EShapeDataMappingImpl: EShapeDataMappingImpl,
        EShapeDataScopedImpl: EShapeDataScopedImpl,
        EShapeDataSystemImpl: EShapeDataSystemImpl,
        EShapeDataValueExtensions: EShapeDataValueExtensions,
        EShapeDataValueImpl: EShapeDataValueImpl,
        EShapeDataValueOrder: EShapeDataValueOrder,
        EShapeDataValueRangeImpl: EShapeDataValueRangeImpl,
        EShapeDataValueRangeType: EShapeDataValueRangeType,
        EShapeDataValueScope: EShapeDataValueScope,
        EShapeDataValueState: EShapeDataValueState,
        EShapeDataValueType: EShapeDataValueType,
        EShapeDefaults: EShapeDefaults,
        EShapeDeleter: EShapeDeleter,
        EShapeDeserializers: EShapeDeserializers,
        EShapeOnDeserializeds: EShapeOnDeserializeds,
        EShapeEditor: EShapeEditor,
        EShapeLayerState: EShapeLayerState,
        toPointsBoundary: toPointsBoundary,
        eShapePointsFormatterCurve: eShapePointsFormatterCurve,
        EShapePointsFormatters: EShapePointsFormatters,
        EShapePointsMarkerBase: EShapePointsMarkerBase,
        EShapePointsMarkerContainerImplNoop: EShapePointsMarkerContainerImplNoop,
        EShapePointsMarkerContainerImpl: EShapePointsMarkerContainerImpl,
        EShapePointsMarkerHead: EShapePointsMarkerHead,
        EShapePointsMarkerNoop: EShapePointsMarkerNoop,
        EShapePointsMarkerTail: EShapePointsMarkerTail,
        EShapePointsMarkerType: EShapePointsMarkerType,
        EShapePointsStyle: EShapePointsStyle,
        EShapePointsStyles: EShapePointsStyles,
        EShapeRendererIteratorDatum: EShapeRendererIteratorDatum,
        EShapeRendererIterator: EShapeRendererIterator,
        EShapeRenderer: EShapeRenderer,
        EShapeResourceManagerDeserializationMode: EShapeResourceManagerDeserializationMode,
        EShapeResourceManagerDeserialization: EShapeResourceManagerDeserialization,
        EShapeResourceManagerSerialization: EShapeResourceManagerSerialization,
        EShapeRuntimeImpl: EShapeRuntimeImpl,
        EShapeRuntimeReset: EShapeRuntimeReset,
        EShapeRuntimes: EShapeRuntimes,
        EShapeSearch: EShapeSearch,
        EShapeStateSetImplObservable: EShapeStateSetImplObservable,
        EShapeState: EShapeState,
        EShapeStrokeSide: EShapeStrokeSide,
        EShapeStrokeStyle: EShapeStrokeStyle,
        EShapeTextAlignHorizontal: EShapeTextAlignHorizontal,
        EShapeTextAlignVertical: EShapeTextAlignVertical,
        EShapeTextDirection: EShapeTextDirection,
        EShapeTextWeight: EShapeTextWeight,
        EShapeTextStyle: EShapeTextStyle,
        EShapeTransformImpl: EShapeTransformImpl,
        EShapeTransforms: EShapeTransforms,
        EShapeType: EShapeType,
        EShapeUploadedImpl: EShapeUploadedImpl,
        EShapeUploadeds: EShapeUploadeds,
        EShapeUuidMappingImpl: EShapeUuidMappingImpl,
        ESnapperGrid: ESnapperGrid,
        ESnapperResultScale: ESnapperResultScale,
        ESnapperResult: ESnapperResult,
        ESnapperTargetValueType: ESnapperTargetValueType,
        ESnapperTargetValue: ESnapperTargetValue,
        ESnapperTarget: ESnapperTarget,
        ESnapperModifierAnchor: ESnapperModifierAnchor,
        ESnapper: ESnapper,
        DThemes: DThemes,
        FormatNodeA: FormatNodeA,
        FormatNodea: FormatNodea,
        FormatNodeD: FormatNodeD,
        FormatNoded: FormatNoded,
        FormatNodee: FormatNodee,
        FormatNodef: FormatNodef,
        FormatNodefsi: FormatNodefsi,
        FormatNodeg: FormatNodeg,
        FormatNodeH: FormatNodeH,
        FormatNodeh: FormatNodeh,
        FormatNodeM: FormatNodeM,
        FormatNodem: FormatNodem,
        FormatNodemi: FormatNodemi,
        FormatNodeP: FormatNodeP,
        FormatNodep: FormatNodep,
        FormatNodePadding: FormatNodePadding,
        FormatNodeParenthesis: FormatNodeParenthesis,
        FormatNodePlus: FormatNodePlus,
        FormatNodePrecision: FormatNodePrecision,
        FormatNoderd: FormatNoderd,
        FormatNodeRP: FormatNodeRP,
        FormatNoderp: FormatNoderp,
        FormatNodesdt: FormatNodesdt,
        FormatNodeSpace: FormatNodeSpace,
        FormatNodessi: FormatNodessi,
        FormatNodeString: FormatNodeString,
        FormatNodeY: FormatNodeY,
        FormatNodey: FormatNodey,
        FormatNodez: FormatNodez,
        FormatNodes: FormatNodes,
        DynamicAtlasItemEmpty: DynamicAtlasItemEmpty,
        DynamicAtlasItemFontAtlas: DynamicAtlasItemFontAtlas,
        DynamicAtlasItemImage: DynamicAtlasItemImage,
        DynamicAtlasItemText: DynamicAtlasItemText,
        DynamicAtlasItemWhite: DynamicAtlasItemWhite,
        DynamicAtlasItem: DynamicAtlasItem,
        DynamicAtlas: DynamicAtlas,
        DynamicFontAtlasCharacterOrigin: DynamicFontAtlasCharacterOrigin,
        DynamicFontAtlasCharacterType: DynamicFontAtlasCharacterType,
        DynamicFontAtlasCharacter: DynamicFontAtlasCharacter,
        DynamicFontAtlasFont: DynamicFontAtlasFont,
        DynamicFontAtlas: DynamicFontAtlas,
        DynamicFontAtlases: DynamicFontAtlases,
        DynamicSDFFontAtlas: DynamicSDFFontAtlas,
        DynamicSDFFontAtlases: DynamicSDFFontAtlases,
        DynamicSDFFontGenerator: DynamicSDFFontGenerator,
        isArray: isArray,
        isFunction: isFunction,
        isNaN: isNaN$1,
        isNumber: isNumber,
        isObject: isObject,
        isString: isString,
        Lazy: Lazy,
        NumberFormatterImpl: NumberFormatterImpl,
        NumberFormatters: NumberFormatters,
        toCeilingIndex: toCeilingIndex,
        toCloned: toCloned,
        toEnum: toEnum,
        toIndexOf: toIndexOf,
        toLabel: toLabel$1,
        toMerged: toMerged,
        toPadded: toPadded,
        toString: toString,
        toSvgTexture: toSvgTexture,
        toSvgUrl: toSvgUrl,
        UtilAlpha: UtilAlpha,
        UtilSvgAtlasBuilder: UtilSvgAtlasBuilder,
        UtilAttachAlign: UtilAttachAlign,
        UtilAttach: UtilAttach,
        UtilCharacterIterator: UtilCharacterIterator,
        UtilClickOutside: UtilClickOutside,
        UtilClipboard: UtilClipboard,
        UtilGestureData: UtilGestureData,
        UtilGestureEasingHistory: UtilGestureEasingHistory,
        UtilGestureEasing: UtilGestureEasing,
        UtilGestureMode: UtilGestureMode,
        UtilGestureModifier: UtilGestureModifier,
        UtilGestureModifiers: UtilGestureModifiers,
        UtilGesture: UtilGesture,
        UtilExtract: UtilExtract,
        UtilExtractor: UtilExtractor,
        UtilFileDownloader: UtilFileDownloader,
        UtilFileAs: UtilFileAs,
        UtilFileOpener: UtilFileOpener,
        UtilFont: UtilFont,
        UtilHsv: UtilHsv,
        UtilHtmlElementClipperExImpl: UtilHtmlElementClipperExImpl,
        UtilHtmlElementClipperExRectsImpl: UtilHtmlElementClipperExRectsImpl,
        UtilHtmlElementWhen: UtilHtmlElementWhen,
        UtilHtmlElement: UtilHtmlElement,
        UtilInputInput: UtilInputInput,
        UtilInputNumber: UtilInputNumber,
        UtilInputTextArea: UtilInputTextArea,
        UtilInputText: UtilInputText,
        UtilInput: UtilInput,
        UtilKeyboardEvent: UtilKeyboardEvent,
        UtilName: UtilName,
        UtilOverlay: UtilOverlay,
        UtilPointerEvent: UtilPointerEvent,
        UtilRgb: UtilRgb,
        UtilRgba: UtilRgba,
        UtilStateBlinker: UtilStateBlinker,
        UtilTransition: UtilTransition,
        UtilWheelEvent: UtilWheelEvent,
        DAlignHorizontal: DAlignHorizontal,
        DAlignVertical: DAlignVertical,
        DAlignWith: DAlignWith,
        DAnimationBase: DAnimationBase,
        DAnimationEmpty: DAnimationEmpty,
        DAnimationFadeIn: DAnimationFadeIn,
        DAnimationTimings: DAnimationTimings,
        DApplicationLayerOptions: DApplicationLayerOptions,
        DApplicationLayer: DApplicationLayer,
        DApplicationPadding: DApplicationPadding,
        DApplication: DApplication,
        DApplications: DApplications,
        DBaseAutoSet: DBaseAutoSet,
        DBaseAuto: DBaseAuto,
        DBaseBackgroundMeshGeometry: DBaseBackgroundMeshGeometry,
        DBaseBackgroundMesh: DBaseBackgroundMesh,
        DBaseBackgroundSnippet: DBaseBackgroundSnippet,
        DBaseBackground: DBaseBackground,
        DBaseBorderMeshGeometry: DBaseBorderMeshGeometry,
        DBaseBorderMesh: DBaseBorderMesh,
        DBaseBorderSnippet: DBaseBorderSnippet,
        DBaseBorder: DBaseBorder,
        DBaseCorner: DBaseCorner,
        DBaseInteractive: DBaseInteractive,
        DBaseMeshGeometry: DBaseMeshGeometry,
        DBaseOutlineSnippet: DBaseOutlineSnippet,
        DBaseOutline: DBaseOutline,
        DBaseOverflowMaskSimple: DBaseOverflowMaskSimple,
        DBaseOverflowMask: DBaseOverflowMask,
        DBasePaddingAdjustable: DBasePaddingAdjustable,
        DBasePadding: DBasePadding,
        DBasePoint: DBasePoint,
        DBaseReflowableContainer: DBaseReflowableContainer,
        DBaseReflowableImpl: DBaseReflowableImpl,
        DBaseSnippetContainer: DBaseSnippetContainer,
        DBaseStateSetBlinkerDatumImpl: DBaseStateSetBlinkerDatumImpl,
        DBaseStateSetBlinkerImpl: DBaseStateSetBlinkerImpl,
        DBaseStateSetImplObservable: DBaseStateSetImplObservable,
        DBaseStateSetImpl: DBaseStateSetImpl,
        DBaseStateSetSubDatumImp: DBaseStateSetSubDatumImp,
        DBaseStateSetSubImpl: DBaseStateSetSubImpl,
        DBaseStateSetTickerDatumImpl: DBaseStateSetTickerDatumImpl,
        DBaseStateSetTickerImpl: DBaseStateSetTickerImpl,
        DBaseState: DBaseState,
        DBase: DBase,
        DBoard: DBoard,
        DBorderMask: DBorderMask,
        DButtonAmbient: DButtonAmbient,
        DButtonBaseWhen: DButtonBaseWhen,
        DButtonBase: DButtonBase,
        DButtonCheckRight: DButtonCheckRight,
        DButtonCheck: DButtonCheck,
        DButtonColorGradient: DButtonColorGradient,
        DButtonColor: DButtonColor,
        DButtonDanger: DButtonDanger,
        DButtonDate: DButtonDate,
        DButtonDatetime: DButtonDatetime,
        DButtonFileAs: UtilFileAs,
        DButtonFile: DButtonFile,
        DButtonGroup: DButtonGroup,
        DButtonLink: DButtonLink,
        DButtonPrimary: DButtonPrimary,
        DButtonRadioRight: DButtonRadioRight,
        DButtonRadio: DButtonRadio,
        DButtonRedo: DButtonRedo,
        DButtonSecondary: DButtonSecondary,
        DButtonSelect: DButtonSelect,
        DButtonTime: DButtonTime,
        DButtonUndo: DButtonUndo,
        DButton: DButton,
        DCanvasContainer: DCanvasContainer,
        DCanvas: DCanvas,
        DChartAxisBaseBar: DChartAxisBaseBar,
        DChartAxisBaseGuideContainer: DChartAxisBaseGuideContainer,
        DChartAxisBaseOptionParser: DChartAxisBaseOptionParser,
        DChartAxisBaseTickContainer: DChartAxisBaseTickContainer,
        DChartAxisBaseTickMajorGridline: DChartAxisBaseTickMajorGridline,
        DChartAxisBaseTickMajor: DChartAxisBaseTickMajor,
        DChartAxisBaseTickMinor: DChartAxisBaseTickMinor,
        DChartAxisBase: DChartAxisBase,
        DChartAxisContainerImpl: DChartAxisContainerImpl,
        DChartAxisGuideSimpleShapeImpl: DChartAxisGuideSimpleShapeImpl,
        DChartAxisGuideSimple: DChartAxisGuideSimple,
        DChartAxisPosition: DChartAxisPosition,
        DChartAxisTickPosition: DChartAxisTickPosition,
        DChartAxisXDatetime: DChartAxisXDatetime,
        DChartAxisX: DChartAxisX,
        DChartAxisY: DChartAxisY,
        DChartColorSet1: DChartColorSet1,
        DChartColorSet2: DChartColorSet2,
        DChartCoordinateBase: DChartCoordinateBase,
        DChartCoordinateContainerImpl: DChartCoordinateContainerImpl,
        DChartCoordinateContainerSubImpl: DChartCoordinateContainerSubImpl,
        DChartCoordinateDirection: DChartCoordinateDirection,
        DChartCoordinateLinearTick: DChartCoordinateLinearTick,
        DChartCoordinateLinear: DChartCoordinateLinear,
        DChartCoordinateLogTick: DChartCoordinateLogTick,
        DChartCoordinateLog: DChartCoordinateLog,
        DChartCoordinateTransformImpl: DChartCoordinateTransformImpl,
        DChartCoordinateTransformMarkImpl: DChartCoordinateTransformMarkImpl,
        DChartLegendItem: DChartLegendItem,
        DChartLegend: DChartLegend,
        DChartOverview: DChartOverview,
        DChartPlotAreaContainer: DChartPlotAreaContainer,
        DChartPlotAreaImpl: DChartPlotAreaImpl,
        DChartRegionImplObservable: DChartRegionImplObservable,
        DChartRegionImpl: DChartRegionImpl,
        DChartSelectionContainerImpl: DChartSelectionContainerImpl,
        DChartSelectionGridlineX: DChartSelectionGridlineX,
        DChartSelectionGridlineY: DChartSelectionGridlineY,
        DChartSelectionMarker: DChartSelectionMarker,
        DChartSelectionShapeBase: DChartSelectionShapeBase,
        DChartSelectionSimple: DChartSelectionSimple,
        DChartSelectionSubImpl: DChartSelectionSubImpl,
        DChartSelectionPoint: DChartSelectionPoint,
        DChartSeriesBar: DChartSeriesBar,
        DChartSeriesBaseCoordinateContainer: DChartSeriesBaseCoordinateContainer,
        DChartSeriesBase: DChartSeriesBase,
        DChartSeriesContainerImpl: DChartSeriesContainerImpl,
        DChartSeriesFillComputedImpl: DChartSeriesFillComputedImpl,
        DChartSeriesFillImpl: DChartSeriesFillImpl,
        DChartSeriesLineOfAny: DChartSeriesLineOfAny,
        DChartSeriesLineOfCircles: DChartSeriesLineOfCircles,
        DChartSeriesLineOfRectangleRoundeds: DChartSeriesLineOfRectangleRoundeds,
        DChartSeriesLineOfRectangles: DChartSeriesLineOfRectangles,
        DChartSeriesLineOfTriangleRoundeds: DChartSeriesLineOfTriangleRoundeds,
        DChartSeriesLineOfTriangles: DChartSeriesLineOfTriangles,
        DChartSeriesLine: DChartSeriesLine,
        DChartSeriesExpressionParametersImpl: DChartSeriesExpressionParametersImpl,
        DChartSeriesLinear: DChartSeriesLinear,
        DChartSeriesPaddingComputedImpl: DChartSeriesPaddingComputedImpl,
        DChartSeriesPaddingImpl: DChartSeriesPaddingImpl,
        DChartSeriesPointComputedImpl: DChartSeriesPointComputedImpl,
        DChartSeriesPointImpl: DChartSeriesPointImpl,
        DChartSeriesScalars: DChartSeriesScalars,
        DChartSeriesStrokeComputedImpl: DChartSeriesStrokeComputedImpl,
        DChartSeriesStrokeImpl: DChartSeriesStrokeImpl,
        DChartSeriesHitResult: DChartSeriesHitResult,
        DChart: DChart,
        DColorGradientObservable: DColorGradientObservable,
        DColorGradientPointObservable: DColorGradientPointObservable,
        DCommandBase: DCommandBase,
        DCommandClear: DCommandClear,
        DCommandCreate: DCommandCreate,
        DCommandSaveAs: DCommandSaveAs,
        DCommandSave: DCommandSave,
        DContent: DContent,
        DControllerCommandImpl: DControllerCommandImpl,
        DControllerFocusImpl: DControllerFocusImpl,
        DControllerKeyboardImpl: DControllerKeyboardImpl,
        DControllers: DControllers,
        DCornerMask: DCornerMask,
        DDiagramBaseControllerOpenType: DDiagramBaseControllerOpenType,
        DDiagramBase: DDiagramBase,
        DDiagramCanvasBase: DDiagramCanvasBase,
        DDiagramCanvasBaseShapeImpl: DDiagramCanvasBaseShapeImpl,
        DDiagramCanvasDataImpl: DDiagramCanvasDataImpl,
        DDiagramCanvasEditorBackground: DDiagramCanvasEditorBackground,
        DDiagramCanvasEditorShapeImpl: DDiagramCanvasEditorShapeImpl,
        DDiagramCanvasEditorSnap: DDiagramCanvasEditorSnap,
        DDiagramCanvasEditor: DDiagramCanvasEditor,
        DDiagramCanvasTileMappingImpl: DDiagramCanvasTileMappingImpl,
        DDiagramCanvasTileMappingPointImpl: DDiagramCanvasTileMappingPointImpl,
        DDiagramCanvasShapeImpl: DDiagramCanvasShapeImpl,
        DDiagramCanvasTickerImpl: DDiagramCanvasTickerImpl,
        DDiagramCanvasTile: DDiagramCanvasTile,
        DDiagramCanvas: DDiagramCanvas,
        DDiagramDataImpl: DDiagramDataImpl,
        DDiagramDataPrivateImpl: DDiagramDataPrivateImpl,
        DDiagramDataRemoteImpl: DDiagramDataRemoteImpl,
        DDiagramEditorThumbnail: DDiagramEditorThumbnail,
        DDiagramEditor: DDiagramEditor,
        DDiagramLayerContainer: DDiagramLayerContainer,
        DDiagramLayer: DDiagramLayer,
        DDiagramLayers: DDiagramLayers,
        DDiagramSerializedVersion: DDiagramSerializedVersion,
        DDiagramShape: DDiagramShape,
        DDiagramSnapshot: DDiagramSnapshot,
        DDiagramTicker: DDiagramTicker,
        DDiagram: DDiagram,
        DDiagrams: DDiagrams,
        DDialogAlign: UtilAttachAlign,
        DDialogCloseOn: DDialogCloseOn,
        DDialogColorGradient: DDialogColorGradient,
        DDialogColor: DDialogColor,
        DDialogConfirmDelete: DDialogConfirmDelete,
        DDialogConfirmDiscard: DDialogConfirmDiscard,
        DDialogConfirmMessage: DDialogConfirmMessage,
        DDialogConfirm: DDialogConfirm,
        DDialogDate: DDialogDate,
        DDialogDatetime: DDialogDatetime,
        DDialogFittedContent: DDialogFittedContent,
        DDialogFitted: DDialogFitted,
        DDialogGestureImpl: DDialogGestureImpl,
        DDialogGestureMode: DDialogGestureMode,
        DDialogInputBoolean: DDialogInputBoolean,
        DDialogInputInteger: DDialogInputInteger,
        DDialogInputReal: DDialogInputReal,
        DDialogInputText: DDialogInputText,
        DDialogInput: DDialogInput,
        DDialogLayeredContent: DDialogLayeredContent,
        DDialogLayeredFooter: DDialogLayeredFooter,
        DDialogLayeredHeaderButtonClose: DDialogLayeredHeaderButtonClose,
        DDialogLayeredHeaderSeparator: DDialogLayeredHeaderSeparator,
        DDialogLayeredHeader: DDialogLayeredHeader,
        DDialogLayered: DDialogLayered,
        DDialogMessage: DDialogMessage,
        DDialogMode: DDialogMode,
        DDialogProcessingMessage: DDialogProcessingMessage,
        DDialogProcessing: DDialogProcessing,
        DDialogSaveAs: DDialogSaveAs,
        DDialogSelectListItemUpdater: DDialogSelectListItemUpdater,
        DDialogSelectListItem: DDialogSelectListItem,
        DDialogSelectList: DDialogSelectList,
        DDialogSelectSearhDismissableImpl: DDialogSelectSearhDismissableImpl,
        DDialogSelectSearhImpl: DDialogSelectSearhImpl,
        DDialogSelect: DDialogSelect,
        DDialogState: DDialogState,
        DDialogTime: DDialogTime,
        DDialog: DDialog,
        DDropdownBase: DDropdownBase,
        DDropdown: DDropdown,
        DDynamicTextGeometry: DDynamicTextGeometry,
        DDynamicTextMeasureResultCharacter: DDynamicTextMeasureResultCharacter,
        DDynamicTextMeasureResult: DDynamicTextMeasureResult,
        DDynamicTextMeasure: DDynamicTextMeasure,
        DDynamicTextStyleWordWrap: DDynamicTextStyleWordWrap,
        DDynamicTextStyle: DDynamicTextStyle,
        DDynamicText: DDynamicText,
        DExpandableHeader: DExpandableHeader,
        DExpandable: DExpandable,
        DHtmlElementState: DHtmlElementState,
        DHtmlElement: DHtmlElement,
        DImageBaseThemeWrapperSecondary: DImageBaseThemeWrapperSecondary,
        DImageBaseThemeWrapperTertiary: DImageBaseThemeWrapperTertiary,
        DImageBase: DImageBase,
        DImagePieceLayouterPartBottom: DImagePieceLayouterPartBottom,
        DImagePieceLayouterPartCenter: DImagePieceLayouterPartCenter,
        DImagePieceLayouterPartContainer: DImagePieceLayouterPartContainer,
        DImagePieceLayouterPartLeft: DImagePieceLayouterPartLeft,
        DImagePieceLayouterPartMiddle: DImagePieceLayouterPartMiddle,
        DImagePieceLayouterPartRight: DImagePieceLayouterPartRight,
        DImagePieceLayouterPartTop: DImagePieceLayouterPartTop,
        DImagePieceLayouterPart: DImagePieceLayouterPart,
        DImagePieceLayouter: DImagePieceLayouter,
        DImagePiece: DImagePiece,
        DImage: DImage,
        DInputAndLabel: DInputAndLabel,
        DInputBooleanButtonOff: DInputBooleanButtonOff,
        DInputBooleanButtonOn: DInputBooleanButtonOn,
        DInputBoolean: DInputBoolean,
        DInputInput: DInputInput,
        DInputIntegerAndLabel: DInputIntegerAndLabel,
        DInputInteger: DInputInteger,
        DInputLabel: DInputLabel,
        DInputNumber: DInputNumber,
        DInputRealAndLabel: DInputRealAndLabel,
        DInputReal: DInputReal,
        DInputSearch: DInputSearch,
        DInputTextAndLabel: DInputTextAndLabel,
        DInputTextArea: DInputTextArea,
        DInputText: DInputText,
        DInput: DInput,
        DItemUpdater: DItemUpdater,
        DLayoutClearType: DLayoutClearType,
        DLayoutDirection: DLayoutDirection,
        DLayoutHorizontal: DLayoutHorizontal,
        DLayoutSpace: DLayoutSpace,
        DLayoutVertical: DLayoutVertical,
        DLayout: DLayout,
        DLinkMenuItemId: DLinkMenuItemId,
        DLinkMenu: DLinkMenu,
        DLinkTarget: DLinkTarget,
        DLink: DLink,
        DLinks: DLinks,
        DListDataImpl: DListDataImpl,
        DListDataMappedImpl: DListDataMappedImpl,
        DListDataSelectionMultiple: DListDataSelectionMultiple,
        DListDataSelectionNone: DListDataSelectionNone,
        DListDataSelectionSingle: DListDataSelectionSingle,
        DListDataSelectionType: DListDataSelectionType,
        DListItemAccessorImpl: DListItemAccessorImpl,
        DListItemAmbient: DListItemAmbient,
        DListItemUpdater: DListItemUpdater,
        DListItem: DListItem,
        DList: DList,
        DMapCoordinateEPSG3857: DMapCoordinateEPSG3857,
        DMapCoordinates: DMapCoordinates,
        DMapTilePlane: DMapTilePlane,
        DMapTilePyramidImpl: DMapTilePyramidImpl,
        DMapTileUrlBuilderKokudo: DMapTileUrlBuilderKokudo,
        DMapTileUrlBuilderOsm: DMapTileUrlBuilderOsm,
        DMapTileUrlBuilderOsmfj: DMapTileUrlBuilderOsmfj,
        DMapTilePyramids: DMapTilePyramids,
        DMapTile: DMapTile,
        DMenuAlign: UtilAttachAlign,
        DMenuBarItem: DMenuBarItem,
        DMenuBar: DMenuBar,
        DMenuContext: DMenuContext,
        DMenuItemBase: DMenuItemBase,
        DMenuItemCheckIsCompatible: DMenuItemCheckIsCompatible,
        DMenuItemCheck: DMenuItemCheck,
        DMenuItemExpandableBody: DMenuItemExpandableBody,
        DMenuItemExpandableHeader: DMenuItemExpandableHeader,
        DMenuItemExpandableIsCompatible: DMenuItemExpandableIsCompatible,
        DMenuItemExpandableItemCheck: DMenuItemExpandableItemCheck,
        DMenuItemExpandableItemLink: DMenuItemExpandableItemLink,
        DMenuItemExpandableItemMenu: DMenuItemExpandableItemMenu,
        DMenuItemExpandableItemSeparator: DMenuItemExpandableItemSeparator,
        DMenuItemExpandableItemSpace: DMenuItemExpandableItemSpace,
        DMenuItemExpandableItemText: DMenuItemExpandableItemText,
        DMenuItemExpandable: DMenuItemExpandable,
        DMenuItemExpandables: DMenuItemExpandables,
        DMenuItemLinkIsCompatible: DMenuItemLinkIsCompatible,
        DMenuItemLink: DMenuItemLink,
        DMenuItemMenuIsCompatible: DMenuItemMenuIsCompatible,
        DMenuItemMenuToSubMenuOptions: DMenuItemMenuToSubMenuOptions,
        DMenuItemMenu: DMenuItemMenu,
        DMenuItemSeparatorReflowable: DMenuItemSeparatorReflowable,
        DMenuItemSeparatorIsCompatible: DMenuItemSeparatorIsCompatible,
        DMenuItemSeparator: DMenuItemSeparator,
        DMenuItemSpaceIsCompatible: DMenuItemSpaceIsCompatible,
        DMenuItemSpace: DMenuItemSpace,
        DMenuItemText: DMenuItemText,
        DMenuItem: DMenuItem,
        DMenuSidedContent: DMenuSidedContent,
        DMenuSidedItemCheck: DMenuSidedItemCheck,
        DMenuSidedItemExpandableItemCheck: DMenuSidedItemExpandableItemCheck,
        DMenuSidedItemExpandableItemLink: DMenuSidedItemExpandableItemLink,
        DMenuSidedItemExpandableItemMenu: DMenuSidedItemExpandableItemMenu,
        DMenuSidedItemExpandableItemSeparator: DMenuSidedItemExpandableItemSeparator,
        DMenuSidedItemExpandableItemSpace: DMenuSidedItemExpandableItemSpace,
        DMenuSidedItemExpandableItemText: DMenuSidedItemExpandableItemText,
        DMenuSidedItemExpandable: DMenuSidedItemExpandable,
        DMenuSidedItemExpandables: DMenuSidedItemExpandables,
        DMenuSidedItemLink: DMenuSidedItemLink,
        DMenuSidedItemMenu: DMenuSidedItemMenu,
        DMenuSidedItemSeparator: DMenuSidedItemSeparator,
        DMenuSidedItemSpace: DMenuSidedItemSpace,
        DMenuSidedItemText: DMenuSidedItemText,
        DMenuSidedSelectionType: DMenuSidedSelectionType,
        DMenuSidedSelection: DMenuSidedSelection,
        DMenuSided: DMenuSided,
        DMenuSideds: DMenuSideds,
        DMenu: DMenu,
        DMenus: DMenus,
        DNoteError: DNoteError,
        DNoteNoItemsFound: DNoteNoItemsFound,
        DNoteSearching: DNoteSearching,
        DNoteSmallError: DNoteSmallError,
        DNoteSmallNoItemsFound: DNoteSmallNoItemsFound,
        DNoteSmallSearching: DNoteSmallSearching,
        DNoteSmall: DNoteSmall,
        DNote: DNote,
        DNotification: DNotification,
        DPaginationButtonLast: DPaginationButtonLast,
        DPaginationButtonNext: DPaginationButtonNext,
        DPaginationButtonPage: DPaginationButtonPage,
        DPaginationButtonPrevious: DPaginationButtonPrevious,
        DPaginationButtonTop: DPaginationButtonTop,
        DPaginationDots: DPaginationDots,
        DPaginationPage: DPaginationPage,
        DPagination: DPagination,
        DPaneScrollBar: DPaneScrollBar,
        DPane: DPane,
        DPickerColorAndAlpha: DPickerColorAndAlpha,
        DPickerColorGradientRecent: DPickerColorGradientRecent,
        DPickerColorGradientView: DPickerColorGradientView,
        DPickerColorGradient: DPickerColorGradient,
        DPickerColorRecent: DPickerColorRecent,
        DPickerColor: DPickerColor,
        DPickerDate: DPickerDate,
        DPickerDates: DPickerDates,
        DPickerDatetimeButtonBack: DPickerDatetimeButtonBack,
        DPickerDatetimeButtonDate: DPickerDatetimeButtonDate,
        DPickerDatetimeButtonNext: DPickerDatetimeButtonNext,
        DPickerDatetimeLabelDate: DPickerDatetimeLabelDate,
        DPickerDatetimeLabel: DPickerDatetimeLabel,
        DPickerDatetimeMask: DPickerDatetimeMask,
        DPickerDatetimeMasks: DPickerDatetimeMasks,
        DPickerDatetimeRange: DPickerDatetimeRange,
        DPickerDatetimeSpace: DPickerDatetimeSpace,
        DPickerDatetime: DPickerDatetime,
        DPickerDatetimes: DPickerDatetimes,
        DPickerTimeBoundHours: DPickerTimeBoundHours,
        DPickerTimeBoundMinutes: DPickerTimeBoundMinutes,
        DPickerTimeBoundSeconds: DPickerTimeBoundSeconds,
        DPickerTimeBound: DPickerTimeBound,
        DPickerTimeBounds: DPickerTimeBounds,
        DPickerTimeRange: DPickerTimeRange,
        DPickerTime: DPickerTime,
        DPickerTimes: DPickerTimes,
        DScalarExpressionNodeType: DScalarExpressionNodeType,
        DScalarExpression: DScalarExpression,
        DScalarFunctions: DScalarFunctions,
        DScrollBarHorizontal: DScrollBarHorizontal,
        DScrollBarThumbHorizontal: DScrollBarThumbHorizontal,
        DScrollBarThumbReflowableHorizontal: DScrollBarThumbReflowableHorizontal,
        DScrollBarThumbReflowableVertical: DScrollBarThumbReflowableVertical,
        DScrollBarThumbVertical: DScrollBarThumbVertical,
        DScrollBarThumb: DScrollBarThumb,
        DScrollBarVertical: DScrollBarVertical,
        DScrollBar: DScrollBar,
        DSelectMultiple: DSelectMultiple,
        DSelect: DSelect,
        DShadowImpl: DShadowImpl,
        DSliderHorizontal: DSliderHorizontal,
        DSliderLabel: DSliderLabel,
        DSliderThumb: DSliderThumb,
        DSliderTrackHorizontal: DSliderTrackHorizontal,
        DSliderTrackVertical: DSliderTrackVertical,
        DSliderTrack: DSliderTrack,
        DSliderValue: DSliderValue,
        DSliderVertical: DSliderVertical,
        DSlider: DSlider,
        DTableBodyCellActionDialog: DTableBodyCellActionDialog,
        DTableBodyCellActionMenu: DTableBodyCellActionMenu,
        DTableBodyCellActionPromise: DTableBodyCellActionPromise,
        DTableBodyCellButton: DTableBodyCellButton,
        DTableBodyCellCheck: DTableBodyCellCheck,
        DTableBodyCellColor: DTableBodyCellColor,
        DTableBodyCellDate: DTableBodyCellDate,
        DTableBodyCellDatetime: DTableBodyCellDatetime,
        DTableBodyCellIndex: DTableBodyCellIndex,
        DTableBodyCellInputInteger: DTableBodyCellInputInteger,
        DTableBodyCellInputReal: DTableBodyCellInputReal,
        DTableBodyCellInputText: DTableBodyCellInputText,
        DTableBodyCellInputTreeInput: DTableBodyCellInputTreeInput,
        DTableBodyCellInputTreeMarker: DTableBodyCellInputTreeMarker,
        DTableBodyCellInputTree: DTableBodyCellInputTree,
        toLinkOptions: toLinkOptions,
        toUrl: toUrl,
        toChecker: toChecker,
        DTableBodyCellLink: DTableBodyCellLink,
        DTableBodyCellSelectDialog: DTableBodyCellSelectDialog,
        DTableBodyCellSelectMenu: DTableBodyCellSelectMenu,
        DTableBodyCellSelectMultiple: DTableBodyCellSelectMultiple,
        DTableBodyCellSelectPromise: DTableBodyCellSelectPromise,
        DTableBodyCellText: DTableBodyCellText,
        DTableBodyCellTime: DTableBodyCellTime,
        DTableBodyCellTree: DTableBodyCellTree,
        DTableBodyCells: DTableBodyCells,
        DTableBodyRow: DTableBodyRow,
        DTableBody: DTableBody,
        DTableCategoryCell: DTableCategoryCell,
        DTableCategory: DTableCategory,
        DTableColumnType: DTableColumnType,
        DTableDataListFilter: DTableDataListFilter,
        DTableDataListMapped: DTableDataListMapped,
        DTableDataListSelection: DTableDataListSelection,
        DTableDataListSorter: DTableDataListSorter,
        DTableDataList: DTableDataList,
        DTableDataSelectionType: DTableDataSelectionType,
        DTableDataOrder: DTableDataOrder,
        DTableDataTreeFilter: DTableDataTreeFilter,
        DTableDataTreeItemAccessor: DTableDataTreeItemAccessor,
        DTableDataTreeSelectionImpl: DTableDataTreeSelectionImpl,
        DTableDataTreeSorter: DTableDataTreeSorter,
        DTableDataTree: DTableDataTree,
        DTableHeaderCellCheck: DTableHeaderCellCheck,
        DTableHeaderCell: DTableHeaderCell,
        DTableHeader: DTableHeader,
        DTableRow: DTableRow,
        DTableScrollBar: DTableScrollBar,
        DTableState: DTableState,
        DTable: DTable,
        DTextBase: DTextBase,
        DText: DText,
        DTreeDataImpl: DTreeDataImpl,
        DTreeDataMappedImpl: DTreeDataMappedImpl,
        DTreeDataSelectionMultiple: DTreeDataSelectionMultiple,
        DTreeDataSelectionNone: DTreeDataSelectionNone,
        DTreeDataSelectionSingle: DTreeDataSelectionSingle,
        DTreeDataSelectionType: DTreeDataSelectionType,
        DTreeItemButton: DTreeItemButton,
        DTreeItemNonEditable: DTreeItemNonEditable,
        DTreeItemState: DTreeItemState,
        DTreeItemText: DTreeItemText,
        DTreeItemUpdater: DTreeItemUpdater,
        DTreeNodeAccessorImpl: DTreeNodeAccessorImpl,
        DTree: DTree,
        DViewGestureImpl: DViewGestureImpl,
        DViewImpl: DViewImpl,
        DViewTransformImpl: DViewTransformImpl
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    loadAll();
    var global = window;
    global.wcardinal = global.wcardinal || {};
    global.wcardinal.ui = ui;

})(PIXI);
