/*
 Winter Cardinal UI v0.452.0
 Copyright (C) 2019 Toshiba Corporation
 SPDX-License-Identifier: Apache-2.0

 Material Design icons by Google
 Apache license version 2.0.
*/
(function (pixi_js) {
    'use strict';

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Mappings of shape types and deserializers.
     */
    const EShapeDeserializers = {};
    /**
     * Mappings of shape types and `onDeserialized` handlers.
     */
    const EShapeOnDeserializeds = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeType = {
        CIRCLE: 0,
        RECTANGLE: 1,
        RECTANGLE_ROUNDED: 2,
        TRIANGLE: 3,
        TRIANGLE_ROUNDED: 4,
        LINE: 5,
        IMAGE: 6,
        IMAGE_SDF: 7,
        GROUP: 8,
        BAR: 9,
        LABEL: 10,
        NULL: 11,
        GROUP_SHADOWED: 12,
        LINE_OF_CIRCLES: 13,
        LINE_OF_RECTANGLES: 14,
        LINE_OF_RECTANGLE_ROUNDEDS: 15,
        LINE_OF_TRIANGLES: 16,
        LINE_OF_TRIANGLE_ROUNDEDS: 17,
        EMBEDDED: 18,
        EMBEDDED_LAYER: 19,
        BUTTON: 20,
        RECTANGLE_PIVOTED: 21,
        CONNECTOR_LINE: 22,
        CONNECTOR_ELBOW: 23,
        SEMICIRCLE: 24,
        EMBEDDED_ACCEPTOR_EDGE: 25,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeUploadeds = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeUploadedImpl {
        constructor(buffer, vertexOffset, indexOffset, vertexCount, indexCount, builders) {
            this._builders = builders;
            this._vertexOffset = vertexOffset;
            this._indexOffset = indexOffset;
            this._vertexCount = vertexCount;
            this._indexCount = indexCount;
        }
        init(shape) {
            shape.uploaded = this;
            const builders = this._builders;
            for (let i = 0, imax = builders.length; i < imax; ++i) {
                builders[i].init();
            }
            this.update(shape);
            return this;
        }
        reinit(buffer, shape, vertexOffset, indexOffset) {
            const builders = this._builders;
            let voffset = vertexOffset;
            let ioffset = indexOffset;
            for (let i = 0, imax = builders.length; i < imax; ++i) {
                const builder = builders[i];
                if (!builder.reinit(buffer, shape, voffset, ioffset)) {
                    return false;
                }
                const vertexCount = builder.vertexCount;
                const indexCount = builder.indexCount;
                voffset += vertexCount;
                ioffset += indexCount;
            }
            this._vertexCount = voffset - vertexOffset;
            this._indexCount = ioffset - indexOffset;
            this.update(shape);
            return true;
        }
        update(shape) {
            const builders = this._builders;
            for (let i = 0, imax = builders.length; i < imax; ++i) {
                builders[i].update(shape);
            }
            return this;
        }
        isCompatible(shape) {
            const builders = this._builders;
            for (let i = 0, imax = builders.length; i < imax; ++i) {
                if (!builders[i].isCompatible(shape)) {
                    return false;
                }
            }
            return true;
        }
        getVertexOffset() {
            return this._vertexOffset;
        }
        getVertexCount() {
            return this._vertexCount;
        }
        getIndexOffset() {
            return this._indexOffset;
        }
        getIndexCount() {
            return this._indexCount;
        }
        buildUnit(builder) {
            const builders = this._builders;
            for (let i = 0, imax = builders.length; i < imax; ++i) {
                builders[i].buildUnit(builder);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const NON_EXPANDING_WIDTH$1 = 2;
    const NON_SHRINKING_WIDTH$1 = 4;
    const NON_SCALING_DOT_AND_DASH$1 = 8;
    const DOTTED$1 = 16;
    const DOTTED_DENSELY$1 = 32;
    const DOTTED_LOOSELY$1 = 64;
    const DASHED$1 = 128;
    const DASHED_DENSELY$1 = 256;
    const DASHED_LOOSELY$1 = 512;
    const EShapeStrokeStyle = {
        NONE: 0,
        NON_EXPANDING_WIDTH: NON_EXPANDING_WIDTH$1,
        NON_SHRINKING_WIDTH: NON_SHRINKING_WIDTH$1,
        NON_SCALING_DOT_AND_DASH: NON_SCALING_DOT_AND_DASH$1,
        NON_SCALING: NON_EXPANDING_WIDTH$1 | NON_SHRINKING_WIDTH$1 | NON_SCALING_DOT_AND_DASH$1,
        NON_SCALING_MASK: NON_EXPANDING_WIDTH$1 | NON_SHRINKING_WIDTH$1 | NON_SCALING_DOT_AND_DASH$1,
        DOTTED: DOTTED$1,
        DOTTED_DENSELY: DOTTED_DENSELY$1,
        DOTTED_LOOSELY: DOTTED_LOOSELY$1,
        DOTTED_MASK: DOTTED$1 | DOTTED_DENSELY$1 | DOTTED_LOOSELY$1,
        DASHED: DASHED$1,
        DASHED_DENSELY: DASHED_DENSELY$1,
        DASHED_LOOSELY: DASHED_LOOSELY$1,
        DASHED_MASK: DASHED$1 | DASHED_DENSELY$1 | DASHED_LOOSELY$1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toDash = (style) => {
        if (style & EShapeStrokeStyle.DOTTED_MASK) {
            if (style & EShapeStrokeStyle.DOTTED) {
                return 1;
            }
            else if (style & EShapeStrokeStyle.DOTTED_DENSELY) {
                return 2;
            }
            else {
                return 3;
            }
        }
        else if (style & EShapeStrokeStyle.DASHED_MASK) {
            if (style & EShapeStrokeStyle.DASHED) {
                return 4;
            }
            else if (style & EShapeStrokeStyle.DASHED_DENSELY) {
                return 5;
            }
            else {
                return 6;
            }
        }
        else {
            return 0;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toScaleInvariant = (style) => {
        const nonExpandingWidth = style & EShapeStrokeStyle.NON_EXPANDING_WIDTH ? 1 : 0;
        const nonShrinkingWidth = style & EShapeStrokeStyle.NON_SHRINKING_WIDTH ? 2 : 0;
        const nonScalingDotAndDash = style & EShapeStrokeStyle.NON_SCALING_DOT_AND_DASH ? 4 : 0;
        if (style & (EShapeStrokeStyle.DOTTED_MASK || EShapeStrokeStyle.DASHED_MASK)) {
            return nonExpandingWidth | nonShrinkingWidth | nonScalingDotAndDash;
        }
        else {
            return nonExpandingWidth | nonShrinkingWidth;
        }
    };

    const toVector = (x0, y0, x1, y1, result) => {
        result[0] = x1 - x0;
        result[1] = y1 - y0;
        return result;
    };

    const toNormal = (v, l) => {
        if (0.00001 < l) {
            const f = 1 / l;
            const v0 = v[0] * f;
            const v1 = v[1] * f;
            v[0] = -v1;
            v[1] = +v0;
        }
        else {
            v[0] = 0;
            v[1] = 1;
        }
        return v;
    };

    const toNormalPacked = (n0, n1) => {
        const x = Math.round(511.5 * (1 + n0[0]));
        const y = Math.round(511.5 * (1 + n1[0]));
        const z = (0 <= n0[1] ? 1 : 0) + (0 <= n1[1] ? 2 : 0);
        return x + (y << 10) + (z << 20);
    };

    const toPackedI4x64 = (i0, i1, i2, i3) => {
        return i0 + (i1 << 6) + (i2 << 12) + (i3 << 18);
    };
    const toPackedF2x1024 = (f0, f1) => {
        return Math.round(1023 * f0) + (Math.round(1023 * f1) << 10);
    };

    const BAR_VERTEX_COUNT = 4;
    const BAR_INDEX_COUNT = 2;
    const BAR_NPREV = [0, 1];
    const BAR_NNEXT = [0, 1];
    const BAR_FMIN = 0.00001;
    const buildBarIndex = (indices, voffset, ioffset) => {
        let ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
    };
    const buildBarVertexStep = (vertices, steps, voffset, pointValues, pointsSize, strokeWidth, strokeStyle, internalTransform) => {
        // First point
        const a = internalTransform.a;
        const b = internalTransform.b;
        const c = internalTransform.c;
        const d = internalTransform.d;
        const tx = internalTransform.tx;
        const ty = internalTransform.ty;
        const pv0 = pointValues[0];
        const pv1 = pointValues[1];
        const p1x = a * pv0 + c * pv1 + tx;
        const p1y = b * pv0 + d * pv1 + ty;
        // Last point
        const pv2 = pointValues[2];
        const pv3 = pointValues[3];
        let p2x = a * pv2 + c * pv3 + tx;
        let p2y = b * pv2 + d * pv3 + ty;
        // Normal
        let dx = p2x - p1x;
        let dy = p2y - p1y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        let l = distance;
        if (0 <= pointsSize && BAR_FMIN < distance) {
            const ratio = pointsSize / distance;
            dx *= ratio;
            dy *= ratio;
            p2x = p1x + dx;
            p2y = p1y + dy;
            l = pointsSize;
        }
        const nprev = BAR_NPREV;
        const nnext = BAR_NNEXT;
        toVector(p1x - dx, p1y - dy, p1x, p1y, nprev);
        toVector(p1x, p1y, p2x, p2y, nnext);
        toNormal(nprev, l);
        toNormal(nnext, l);
        const packed = toNormalPacked(nprev, nnext);
        //
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const dash = toDash(strokeStyle);
        const e3 = toPackedI4x64(3, scaleInvariant, dash, 0);
        const e5 = toPackedI4x64(5, scaleInvariant, dash, 0);
        let iv = (voffset << 1) - 1;
        let is = voffset * 6 - 1;
        vertices[++iv] = p1x;
        vertices[++iv] = p1y;
        vertices[++iv] = p1x;
        vertices[++iv] = p1y;
        steps[++is] = strokeWidth;
        steps[++is] = e3;
        steps[++is] = packed;
        steps[++is] = 0;
        steps[++is] = l;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e5;
        steps[++is] = packed;
        steps[++is] = 0;
        steps[++is] = l;
        steps[++is] = 0;
        vertices[++iv] = p2x;
        vertices[++iv] = p2y;
        vertices[++iv] = p2x;
        vertices[++iv] = p2y;
        steps[++is] = strokeWidth;
        steps[++is] = e3;
        steps[++is] = packed;
        steps[++is] = l;
        steps[++is] = l;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e5;
        steps[++is] = packed;
        steps[++is] = l;
        steps[++is] = l;
        steps[++is] = 0;
    };
    const buildBarUv = (uvs, voffset, textureUvs) => {
        let iuv = (voffset << 1) - 1;
        uvs[++iuv] = textureUvs.x0;
        uvs[++iuv] = textureUvs.y0;
        uvs[++iuv] = textureUvs.x3;
        uvs[++iuv] = textureUvs.y3;
        uvs[++iuv] = textureUvs.x1;
        uvs[++iuv] = textureUvs.y1;
        uvs[++iuv] = textureUvs.x2;
        uvs[++iuv] = textureUvs.y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeTextWeight = {
        NORMAL: 0,
        BOLD: 1
    };
    const EShapeTextStyle = {
        NORMAL: 0,
        ITALIC: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeTextAlignHorizontal = {
        LEFT: 0,
        CENTER: 1,
        RIGHT: 2,
        OUTSIDE_LEFT: 3,
        OUTSIDE_RIGHT: 4
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeTextAlignVertical = {
        TOP: 0,
        MIDDLE: 1,
        BOTTOM: 2,
        OUTSIDE_TOP: 3,
        OUTSIDE_BOTTOM: 4
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeTextDirection = {
        LEFT_TO_RIGHT: 0,
        TOP_TO_BOTTOM: 1,
        BOTTOM_TO_TOP: 2,
        RIGHT_TO_LEFT: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toLength = (p0x, p0y, p1x, p1y) => {
        const dx01 = p1x - p0x;
        const dy01 = p1y - p0y;
        return Math.sqrt(dx01 * dx01 + dy01 * dy01);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const Character = {
        ASCII: "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
        SPACE: " ",
        TAB: "\t",
        SOFT_TAB: "    ",
        DOTS: "...",
        NEW_LINE: "\n"
    };

    const TEXT_VERTEX_COUNT = 4;
    const TEXT_VERTEX_COUNT_SHIFT = 2;
    const TEXT_INDEX_COUNT = 2;
    const TEXT_INDEX_COUNT_SHIFT = 1;
    const TEXT_FMIN = 0.00001;
    const TEXT_WORK_POINT = new pixi_js.Point();
    const toTextBufferCount = (shape) => {
        const l = shape.text.plength;
        return ((l >> 3) + (0 < (l & 0x7) ? 1 : 0)) << 3;
    };
    const buildTextIndex = (indices, voffset, ioffset, icount) => {
        let ii = ioffset * 3 - 1;
        const iimax = (ioffset + icount) * 3 - 1;
        let iv = voffset;
        for (; ii < iimax;) {
            indices[++ii] = iv;
            indices[++ii] = iv + 1;
            indices[++ii] = iv + 3;
            indices[++ii] = iv + 1;
            indices[++ii] = iv + 2;
            indices[++ii] = iv + 3;
            iv += 4;
        }
    };
    const buildTextStep = (steps, voffset, vcount, textAtlas, textSize, textOutlineWidth, textWeight, scaleX, scaleY) => {
        let is = voffset * 6 - 1;
        const ismax = (voffset + vcount) * 6 - 1;
        const scaleInvariant = toScaleInvariant(EShapeStrokeStyle.NONE);
        const e = toPackedI4x64(2, scaleInvariant, 1, 1);
        if (textAtlas != null) {
            const scale = textAtlas.font.size / (textSize * (scaleX + scaleY) * 0.5);
            const position = textWeight === EShapeTextWeight.NORMAL ? 0.0 : 0.05;
            for (; is < ismax;) {
                steps[++is] = textOutlineWidth;
                steps[++is] = e;
                steps[++is] = scale;
                steps[++is] = 0;
                steps[++is] = position;
                steps[++is] = 0;
            }
        }
        else {
            for (; is < ismax;) {
                steps[++is] = 0;
                steps[++is] = e;
                steps[++is] = 0;
                steps[++is] = 0;
                steps[++is] = 0;
                steps[++is] = 0;
            }
        }
    };
    const getTextBBox = (halign, valign, hoffset, voffset, hpadding, vpadding, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, result) => {
        switch (halign) {
            case EShapeTextAlignHorizontal.LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y0 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x3) +
                                hnx * (hoffset + hpadding) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y3) +
                                hny * (hoffset + hpadding) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x3 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y3 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x0 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y0 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y3 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.CENTER:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x =
                            0.5 * (x0 + x1) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset + vpadding);
                        result.y =
                            0.5 * (y0 + y1) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            0.5 * (x3 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            0.5 * (y3 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            0.5 * (x0 + x1) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            0.5 * (y0 + y1) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x =
                            0.5 * (x3 + x2) +
                                hnx * (hoffset - 0.5 * width) +
                                vnx * (voffset + vpadding);
                        result.y =
                            0.5 * (y3 + y2) +
                                hny * (hoffset - 0.5 * width) +
                                vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y1 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x1 + x2) +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y1 + y2) +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x2 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y2 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x1 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y1 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y2 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x0 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y0 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x0 + x3) +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y0 + y3) +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x3 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y3 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x0 +
                                hnx * (hoffset - hpadding - width) +
                                vnx * (voffset - vpadding - height);
                        result.y =
                            y0 +
                                hny * (hoffset - hpadding - width) +
                                vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x3 + hnx * (hoffset - hpadding - width) + vnx * (voffset + vpadding);
                        result.y = y3 + hny * (hoffset - hpadding - width) + vny * (voffset + vpadding);
                        break;
                }
                break;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                switch (valign) {
                    case EShapeTextAlignVertical.TOP:
                        result.x = x1 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y1 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                    case EShapeTextAlignVertical.MIDDLE:
                        result.x =
                            0.5 * (x1 + x2) +
                                hnx * (hoffset + hpadding) +
                                vnx * (voffset - 0.5 * height);
                        result.y =
                            0.5 * (y1 + y2) +
                                hny * (hoffset + hpadding) +
                                vny * (voffset - 0.5 * height);
                        break;
                    case EShapeTextAlignVertical.BOTTOM:
                        result.x =
                            x2 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y2 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_TOP:
                        result.x =
                            x1 + hnx * (hoffset + hpadding) + vnx * (voffset - vpadding - height);
                        result.y =
                            y1 + hny * (hoffset + hpadding) + vny * (voffset - vpadding - height);
                        break;
                    case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        result.x = x2 + hnx * (hoffset + hpadding) + vnx * (voffset + vpadding);
                        result.y = y2 + hny * (hoffset + hpadding) + vny * (voffset + vpadding);
                        break;
                }
                break;
        }
    };
    const rotateAlignHorizontalRight = (align) => {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
        }
    };
    const rotateAlignVerticalRight = (align) => {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
        }
    };
    const rotateAlignHorizontalLeft = (align) => {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
        }
    };
    const rotateAlignVerticalLeft = (align) => {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
        }
    };
    const invertAlignHorizontal = (align) => {
        switch (align) {
            case EShapeTextAlignHorizontal.LEFT:
                return EShapeTextAlignHorizontal.RIGHT;
            case EShapeTextAlignHorizontal.CENTER:
                return EShapeTextAlignHorizontal.CENTER;
            case EShapeTextAlignHorizontal.RIGHT:
                return EShapeTextAlignHorizontal.LEFT;
            case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                return EShapeTextAlignHorizontal.OUTSIDE_RIGHT;
            case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                return EShapeTextAlignHorizontal.OUTSIDE_LEFT;
        }
    };
    const invertAlignVertical = (align) => {
        switch (align) {
            case EShapeTextAlignVertical.TOP:
                return EShapeTextAlignVertical.BOTTOM;
            case EShapeTextAlignVertical.MIDDLE:
                return EShapeTextAlignVertical.MIDDLE;
            case EShapeTextAlignVertical.BOTTOM:
                return EShapeTextAlignVertical.TOP;
            case EShapeTextAlignVertical.OUTSIDE_TOP:
                return EShapeTextAlignVertical.OUTSIDE_BOTTOM;
            case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                return EShapeTextAlignVertical.OUTSIDE_TOP;
        }
    };
    const buildTextVertex = (vertices, uvs, voffset, vcount, originX, originY, sizeX, sizeY, textAtlas, textSize, textCharacters, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textFitting, textWorld, textureUvs, internalTransform) => {
        // Calculate the transformed positions
        //
        //  0               1
        // |---------------|
        // |               |
        // |3              |2
        // |---------------|
        //
        const sx = sizeX * 0.5;
        const sy = sizeY * 0.5;
        const a = internalTransform.a;
        const b = internalTransform.b;
        const c = internalTransform.c;
        const d = internalTransform.d;
        const tx = internalTransform.tx;
        const ty = internalTransform.ty;
        const ltx = originX - sx;
        const lty = originY - sy;
        const rtx = originX + sx;
        const rty = originY - sy;
        const rbx = originX + sx;
        const rby = originY + sy;
        const x0 = a * ltx + c * lty + tx;
        const y0 = b * ltx + d * lty + ty;
        const x1 = a * rtx + c * rty + tx;
        const y1 = b * rtx + d * rty + ty;
        const x2 = a * rbx + c * rby + tx;
        const y2 = b * rbx + d * rby + ty;
        const x3 = x0 + (x2 - x1);
        const y3 = y0 + (y2 - y1);
        // Horizontal normal
        const hl = toLength(x0, y0, x1, y1);
        let hnl = toLength(0, 0, a, b);
        let hnx = 1;
        let hny = 0;
        if (TEXT_FMIN < hnl) {
            const hnli = 1 / hnl;
            hnx = a * hnli;
            hny = b * hnli;
        }
        // Vertical normal
        const vl = toLength(x0, y0, x3, y3);
        let vnl = toLength(0, 0, c, d);
        let vnx = 0;
        let vny = 1;
        if (TEXT_FMIN < hnl) {
            const vnli = 1 / vnl;
            vnx = c * vnli;
            vny = d * vnli;
        }
        const work = TEXT_WORK_POINT;
        switch (textDirection) {
            case EShapeTextDirection.LEFT_TO_RIGHT:
                // DO NOTHING
                break;
            case EShapeTextDirection.TOP_TO_BOTTOM:
                work.set(vnx, vny);
                vnx = -hnx;
                vny = -hny;
                hnx = work.x;
                hny = work.y;
                work.x = vnl;
                vnl = hnl;
                hnl = work.x;
                break;
            case EShapeTextDirection.BOTTOM_TO_TOP:
                work.set(vnx, vny);
                vnx = hnx;
                vny = hny;
                hnx = -work.x;
                hny = -work.y;
                work.x = vnl;
                vnl = hnl;
                hnl = work.x;
                break;
            case EShapeTextDirection.RIGHT_TO_LEFT:
                hnx = -hnx;
                hny = -hny;
                vnx = -vnx;
                vny = -vny;
                break;
        }
        // Calculate the width / height
        let width = 0;
        let height = 0;
        let heightChar = 0;
        let textSizeY = textSize * vnl;
        let lineHeight = Math.max(0, textSize + textSpacingVertical) * vnl;
        let lineWidth = 0;
        let lineCount = 1;
        const textAtlasCharacters = textAtlas.characters;
        let advancePrevious = 0;
        for (let i = 0, imax = textCharacters.length; i < imax; ++i) {
            const character = textCharacters[i];
            if (character !== Character.NEW_LINE) {
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                const data = textAtlasCharacters.get(character);
                if (data) {
                    advancePrevious = data.advance;
                    heightChar = data.height;
                }
                else {
                    advancePrevious = 0;
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                width = Math.max(width, lineWidth);
                lineWidth = 0;
                height += lineHeight;
                lineCount += 1;
            }
        }
        lineWidth += advancePrevious;
        width = Math.max(width, lineWidth);
        height += textSizeY;
        lineWidth = 0;
        if (textFitting && isIn(textAlignHorizontal, textAlignVertical)) {
            let w0 = 0;
            let h0 = 0;
            switch (textDirection) {
                case EShapeTextDirection.LEFT_TO_RIGHT:
                case EShapeTextDirection.RIGHT_TO_LEFT:
                    w0 = Math.max(0, hl - textPaddingHorizontal * 2);
                    h0 = Math.max(0, vl - textPaddingVertical * 2);
                    break;
                case EShapeTextDirection.TOP_TO_BOTTOM:
                case EShapeTextDirection.BOTTOM_TO_TOP:
                    w0 = Math.max(0, vl - textPaddingVertical * 2);
                    h0 = Math.max(0, hl - textPaddingHorizontal * 2);
                    break;
            }
            const w1 = width * hnl * (textSize / textAtlas.font.size);
            const h1 = height;
            const s = Math.min(1, Math.min(w0 / w1, h0 / h1));
            textSize *= s;
            textSizeY *= s;
            lineHeight *= s;
            height *= s;
        }
        const scaleZ = textSize / textAtlas.font.size;
        const scaleX = hnl * scaleZ;
        const scaleY = vnl * scaleZ;
        width *= scaleX;
        heightChar *= scaleY;
        //
        let tx0 = 0;
        let ty0 = 0;
        let lineWidthMaximum = width;
        switch (textDirection) {
            case EShapeTextDirection.LEFT_TO_RIGHT:
                getTextBBox(textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textPaddingHorizontal, textPaddingVertical, width, height, x0, y0, x1, y1, x2, y2, x3, y3, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = hl - textPaddingHorizontal * 2;
                }
                break;
            case EShapeTextDirection.TOP_TO_BOTTOM:
                getTextBBox(rotateAlignVerticalRight(textAlignVertical), rotateAlignHorizontalRight(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x1, y1, x2, y2, x3, y3, x0, y0, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = vl - textPaddingVertical * 2;
                }
                break;
            case EShapeTextDirection.BOTTOM_TO_TOP:
                getTextBBox(rotateAlignVerticalLeft(textAlignVertical), rotateAlignHorizontalLeft(textAlignHorizontal), textOffsetVertical, textOffsetHorizontal, textPaddingVertical, textPaddingHorizontal, width, height, x3, y3, x0, y0, x1, y1, x2, y2, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = vl - textPaddingVertical * 2;
                }
                break;
            case EShapeTextDirection.RIGHT_TO_LEFT:
                getTextBBox(invertAlignHorizontal(textAlignHorizontal), invertAlignVertical(textAlignVertical), textOffsetHorizontal, textOffsetVertical, textPaddingHorizontal, textPaddingVertical, width, height, x2, y2, x3, y3, x0, y0, x1, y1, hnx, hny, vnx, vny, work);
                tx0 = work.x;
                ty0 = work.y;
                if (textClipping && isIn(textAlignHorizontal, textAlignVertical)) {
                    lineWidthMaximum = hl - textPaddingHorizontal * 2;
                }
                break;
        }
        //
        if (lineWidthMaximum < width) {
            const dwidth = (width - lineWidthMaximum) * 0.5;
            textWorld[0] = tx0 + hnx * dwidth;
            textWorld[1] = ty0 + hny * dwidth;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = lineWidthMaximum;
            textWorld[7] = height;
            textWorld[8] = hnl;
            textWorld[9] = vnl;
        }
        else {
            textWorld[0] = tx0;
            textWorld[1] = ty0;
            textWorld[2] = hnx;
            textWorld[3] = hny;
            textWorld[4] = vnx;
            textWorld[5] = vny;
            textWorld[6] = width;
            textWorld[7] = height;
            textWorld[8] = hnl;
            textWorld[9] = vnl;
        }
        // Texture
        const uvx0 = textureUvs.x0;
        const uvx1 = textureUvs.x1;
        const uvx3 = textureUvs.x3;
        const uvy0 = textureUvs.y0;
        const uvy1 = textureUvs.y1;
        const uvy3 = textureUvs.y3;
        const duvx01 = uvx1 - uvx0;
        const duvy01 = uvy1 - uvy0;
        const duvx03 = uvx3 - uvx0;
        const duvy03 = uvy3 - uvy0;
        // Vertices & UVs
        const lhx = lineHeight * vnx;
        const lhy = lineHeight * vny;
        const snx = scaleX * hnx;
        const sny = scaleX * hny;
        const offsetY = (heightChar - textSizeY) * 0.5;
        const oyx = offsetY * vnx;
        const oyy = offsetY * vny;
        const offsetItalic = textStyle === EShapeTextStyle.NORMAL ? 0 : textSize * 0.25;
        let bx0 = tx0 - oyx + offsetItalic * snx;
        let by0 = ty0 - oyy + offsetItalic * sny;
        let bx3 = tx0 + oyx + textSizeY * vnx;
        let by3 = ty0 + oyy + textSizeY * vny;
        let cx0 = bx0;
        let cy0 = by0;
        let cx3 = bx3;
        let cy3 = by3;
        lineWidth = 0;
        advancePrevious = 0;
        lineCount = 0;
        let iv = voffset * 2;
        for (let i = 0, imax = textCharacters.length; i < imax; i += 1, iv += 8) {
            const character = textCharacters[i];
            if (character !== Character.NEW_LINE) {
                const lineWidthPrevious = lineWidth;
                if (0 < advancePrevious) {
                    lineWidth += Math.max(0, advancePrevious + textSpacingHorizontal);
                }
                const ax = lineWidth * snx;
                const ay = lineWidth * sny;
                cx0 = bx0 + ax;
                cy0 = by0 + ay;
                cx3 = bx3 + ax;
                cy3 = by3 + ay;
                const data = textAtlasCharacters.get(character);
                lineCount += 1;
                if (data) {
                    const advance = data.advance;
                    if (lineWidthMaximum < (lineWidth + advance) * scaleX) {
                        const dots = textAtlasCharacters.get(Character.DOTS);
                        if (dots) {
                            if (1 < lineCount &&
                                lineWidthMaximum < (lineWidth + dots.advance) * scaleX) {
                                lineWidth = lineWidthPrevious;
                                iv -= 8;
                                lineCount -= 1;
                                const bx = lineWidth * snx;
                                const by = lineWidth * sny;
                                cx0 = bx0 + bx;
                                cy0 = by0 + by;
                                cx3 = bx3 + bx;
                                cy3 = by3 + by;
                            }
                            advancePrevious = dots.advance;
                            writeCharacter(vertices, uvs, iv, dots, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                            for (iv += 8; true; iv += 8) {
                                if (i + 1 < imax && textCharacters[i + 1] !== Character.NEW_LINE) {
                                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                                    lineCount += 1;
                                    i += 1;
                                }
                                else {
                                    iv -= 8;
                                    break;
                                }
                            }
                        }
                        else {
                            advancePrevious = advance;
                            writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                        }
                    }
                    else {
                        advancePrevious = advance;
                        writeCharacter(vertices, uvs, iv, data, textAtlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0);
                    }
                }
                else {
                    advancePrevious = 0;
                    writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                }
            }
            else {
                lineWidth += advancePrevious;
                advancePrevious = 0;
                bx0 += lhx;
                by0 += lhy;
                bx3 += lhx;
                by3 += lhy;
                cx0 = bx0;
                cy0 = by0;
                cx3 = bx3;
                cy3 = by3;
                writeCharacterEmpty(vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3);
                adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scaleX, textDirection, textAlignHorizontal, textAlignVertical);
                lineWidth = 0;
                lineCount = 0;
            }
        }
        lineWidth += advancePrevious;
        adjustTextAlignment(vertices, hnx, hny, lineCount, iv, width - lineWidth * scaleX, textDirection, textAlignHorizontal, textAlignVertical);
        for (const ivmax = (voffset + vcount) * 2; iv < ivmax; iv += 2) {
            vertices[iv + 0] = tx0;
            vertices[iv + 1] = ty0;
            uvs[iv + 0] = uvx0;
            uvs[iv + 1] = uvy0;
        }
    };
    const isIn = (textAlignHorizontal, textAlignVertical) => {
        switch (textAlignHorizontal) {
            case EShapeTextAlignHorizontal.LEFT:
            case EShapeTextAlignHorizontal.CENTER:
            case EShapeTextAlignHorizontal.RIGHT:
                switch (textAlignVertical) {
                    case EShapeTextAlignVertical.TOP:
                    case EShapeTextAlignVertical.MIDDLE:
                    case EShapeTextAlignVertical.BOTTOM:
                        return true;
                }
                break;
        }
        return false;
    };
    const writeCharacterEmpty = (vertices, uvs, iv, cx0, cy0, cx3, cy3, uvx0, uvy0, uvx3, uvy3) => {
        vertices[iv + 0] = cx0;
        vertices[iv + 1] = cy0;
        vertices[iv + 2] = cx0;
        vertices[iv + 3] = cy0;
        vertices[iv + 4] = cx3;
        vertices[iv + 5] = cy3;
        vertices[iv + 6] = cx3;
        vertices[iv + 7] = cy3;
        uvs[iv + 0] = uvx0;
        uvs[iv + 1] = uvy0;
        uvs[iv + 2] = uvx0;
        uvs[iv + 3] = uvy0;
        uvs[iv + 4] = uvx3;
        uvs[iv + 5] = uvy3;
        uvs[iv + 6] = uvx3;
        uvs[iv + 7] = uvy3;
    };
    const writeCharacter = (vertices, uvs, iv, data, atlas, snx, sny, cx0, cy0, cx3, cy3, duvx01, duvy01, duvx03, duvy03, uvx0, uvy0) => {
        // Vertices
        const dataOffsetX = data.x - data.origin.x;
        const dataWidth = data.width;
        const dx0 = dataOffsetX * snx;
        const dy0 = dataOffsetX * sny;
        const dx1 = (dataOffsetX + dataWidth) * snx;
        const dy1 = (dataOffsetX + dataWidth) * sny;
        vertices[iv + 0] = cx0 + dx0;
        vertices[iv + 1] = cy0 + dy0;
        vertices[iv + 2] = cx0 + dx1;
        vertices[iv + 3] = cy0 + dy1;
        vertices[iv + 4] = cx3 + dx1;
        vertices[iv + 5] = cy3 + dy1;
        vertices[iv + 6] = cx3 + dx0;
        vertices[iv + 7] = cy3 + dy0;
        // UVs
        const px0 = data.x / atlas.width;
        const py0 = data.y / atlas.height;
        const px1 = (data.x + data.width) / atlas.width;
        const py1 = (data.y + data.height) / atlas.height;
        const dux0 = duvx01 * px0;
        const duy0 = duvy01 * px0;
        const dux1 = duvx01 * px1;
        const duy1 = duvy01 * px1;
        const dvx0 = duvx03 * py0;
        const dvy0 = duvy03 * py0;
        const dvx1 = duvx03 * py1;
        const dvy1 = duvy03 * py1;
        uvs[iv + 0] = uvx0 + dux0 + dvx0;
        uvs[iv + 1] = uvy0 + duy0 + dvy0;
        uvs[iv + 2] = uvx0 + dux1 + dvx0;
        uvs[iv + 3] = uvy0 + duy1 + dvy0;
        uvs[iv + 4] = uvx0 + dux1 + dvx1;
        uvs[iv + 5] = uvy0 + duy1 + dvy1;
        uvs[iv + 6] = uvx0 + dux0 + dvx1;
        uvs[iv + 7] = uvy0 + duy0 + dvy1;
    };
    const moveText = (vertices, vertexIndex, textCount, dx, dy) => {
        let iv = vertexIndex - 8 * textCount - 1;
        for (let i = 0; i < textCount; ++i) {
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
            vertices[++iv] += dx;
            vertices[++iv] += dy;
        }
    };
    const moveTextHalf = (vertices, vertexIndex, textCount, offset, nx, ny) => {
        offset *= 0.5;
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    const moveTextFull = (vertices, vertexIndex, textCount, offset, nx, ny) => {
        moveText(vertices, vertexIndex, textCount, offset * nx, offset * ny);
    };
    const adjustTextAlignment = (vertices, nx, ny, lineCount, vertexIndex, offset, textDirection, textAlignHorizontal, textAlignVertical) => {
        if (TEXT_FMIN < offset) {
            switch (textDirection) {
                case EShapeTextDirection.LEFT_TO_RIGHT:
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                        case EShapeTextAlignHorizontal.LEFT:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignHorizontal.CENTER:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                        case EShapeTextAlignHorizontal.RIGHT:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.TOP_TO_BOTTOM:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            // DO NOTHING
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                    }
                    break;
                case EShapeTextDirection.BOTTOM_TO_TOP:
                    switch (textAlignVertical) {
                        case EShapeTextAlignVertical.OUTSIDE_BOTTOM:
                        case EShapeTextAlignVertical.TOP:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.MIDDLE:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignVertical.OUTSIDE_TOP:
                        case EShapeTextAlignVertical.BOTTOM:
                            // DO NOTHING
                            break;
                    }
                    break;
                case EShapeTextDirection.RIGHT_TO_LEFT:
                    switch (textAlignHorizontal) {
                        case EShapeTextAlignHorizontal.OUTSIDE_RIGHT:
                        case EShapeTextAlignHorizontal.LEFT:
                            moveTextFull(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.CENTER:
                            moveTextHalf(vertices, vertexIndex, lineCount, offset, nx, ny);
                            break;
                        case EShapeTextAlignHorizontal.OUTSIDE_LEFT:
                        case EShapeTextAlignHorizontal.RIGHT:
                            // DO NOTHING
                            break;
                    }
                    break;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const CLOSED = 1;
    const NON_EXPANDING_WIDTH = 2;
    const NON_SHRINKING_WIDTH = 4;
    const NON_SCALING_DOT_AND_DASH = 8;
    const DOTTED = 16;
    const DOTTED_DENSELY = 32;
    const DOTTED_LOOSELY = 64;
    const DASHED = 128;
    const DASHED_DENSELY = 256;
    const DASHED_LOOSELY = 512;
    const FORMATTER_SHIFT = 10;
    const FORMATTER_MASK = 0xffc00;
    const FORMATTER_EXTENSION_LOWEST = 512;
    const FORMATTER_EXTENSION_HIGHEST = 1023;
    const FORMATTER_CURVE_SPLINE = 1;
    const FORMATTER_CURVE_BEZIER_QUADRATIC = 2;
    const CURVE_SPLINE = FORMATTER_CURVE_SPLINE << FORMATTER_SHIFT;
    const CURVE_BEZIER_QUADRATIC = FORMATTER_CURVE_BEZIER_QUADRATIC << FORMATTER_SHIFT;
    /**
     * EShape point style.
     *
     * * Bits 0 to 9: Bit field of styles.
     * * Bits 10 to 19: Formatter ID.
     */
    const EShapePointsStyle = {
        NONE: 0,
        CLOSED,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_EXPANDING_WIDTH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_SHRINKING_WIDTH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_SCALING_DOT_AND_DASH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        NON_SCALING_MASK: NON_EXPANDING_WIDTH | NON_SHRINKING_WIDTH | NON_SCALING_DOT_AND_DASH,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED_DENSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED_LOOSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DOTTED_MASK: DOTTED | DOTTED_DENSELY | DOTTED_LOOSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED_DENSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED_LOOSELY,
        /** @deprecated in favor of EShapeStrokeStyle. */
        DASHED_MASK: DASHED | DASHED_DENSELY | DASHED_LOOSELY,
        /** @deprecated in favor of CURVE_SPLINE. */
        CURVE: CURVE_SPLINE,
        CURVE_SPLINE: CURVE_SPLINE,
        CURVE_BEZIER_QUADRATIC: CURVE_BEZIER_QUADRATIC,
        FORMATTER_SHIFT,
        FORMATTER_MASK,
        FORMATTER_EXTENSION_LOWEST,
        FORMATTER_EXTENSION_HIGHEST,
        /** @deprecated in favor of FORMATTER_CURVE_SPLINE. */
        FORMATTER_CURVE: FORMATTER_CURVE_SPLINE,
        FORMATTER_CURVE_SPLINE,
        FORMATTER_CURVE_BEZIER_QUADRATIC
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const NONE$1 = 0;
    const VERTEX = 1;
    const STEP = 2;
    const COLOR = 4;
    const UV = 8;
    const INDEX = 16;
    const VERTEX_AND_STEP = VERTEX | STEP;
    const VERTEX_STEP_AND_UV = VERTEX_AND_STEP | UV;
    const ALL$1 = VERTEX | STEP | COLOR | UV | INDEX;
    const BuilderFlag = {
        NONE: NONE$1,
        VERTEX,
        STEP,
        COLOR,
        UV,
        INDEX,
        VERTEX_AND_STEP,
        VERTEX_STEP_AND_UV,
        ALL: ALL$1
    };

    const buildColor = (fillColor, fillAlpha, strokeColor, strokeAlpha, voffset, vcount, colors) => {
        const alpha = toPackedF2x1024(Math.max(0, Math.min(1, fillAlpha)), Math.max(0, Math.min(1, strokeAlpha)));
        let ic = voffset * 3 - 1;
        const icmax = (voffset + vcount) * 3 - 1;
        for (; ic < icmax;) {
            colors[++ic] = fillColor;
            colors[++ic] = strokeColor;
            colors[++ic] = alpha;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const TOP$1 = 1;
    const RIGHT$1 = 2;
    const BOTTOM$1 = 4;
    const LEFT$1 = 8;
    const EShapeStrokeSide = {
        NONE: 0,
        TOP: TOP$1,
        RIGHT: RIGHT$1,
        BOTTOM: BOTTOM$1,
        LEFT: LEFT$1,
        TOP_OR_LEFT: TOP$1 | LEFT$1,
        TOP_OR_RIGHT: TOP$1 | RIGHT$1,
        BOTTOM_OR_LEFT: BOTTOM$1 | LEFT$1,
        BOTTOM_OR_RIGHT: BOTTOM$1 | RIGHT$1,
        ALL: TOP$1 | RIGHT$1 | BOTTOM$1 | LEFT$1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderBase {
        constructor(buffer, vertexOffset, indexOffset, vertexCount, indexCount) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = vertexCount;
            this.indexCount = indexCount;
            this.inited = BuilderFlag.NONE;
            this.sizeX = 0;
            this.sizeY = 0;
            this.transformLocalId = -1;
            this.strokeAlign = 0;
            this.strokeWidth = 0;
            this.strokeSide = EShapeStrokeSide.NONE;
            this.strokeStyle = EShapeStrokeStyle.NONE;
            this.colorFill = 0;
            this.alphaFill = 0;
            this.colorStroke = 0;
            this.alphaStroke = 0;
            this.texture = null;
            this.textureTransformId = -1;
        }
        reinit(buffer, shape, vertexOffset, indexOffset) {
            if (this.buffer !== buffer ||
                this.vertexOffset !== vertexOffset ||
                this.indexOffset !== indexOffset) {
                if (buffer.check(vertexOffset, indexOffset, this.vertexCount, this.indexCount)) {
                    this.inited = BuilderFlag.NONE;
                    this.buffer = buffer;
                    this.vertexOffset = vertexOffset;
                    this.indexOffset = indexOffset;
                    this.init();
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        }
        isCompatible(shape) {
            return true;
        }
        updateColor(buffer, shape) {
            const fill = shape.fill;
            const colorFill = fill.color;
            const alphaFill = shape.visible && fill.enable ? fill.alpha : 0;
            const stroke = shape.stroke;
            const colorStroke = stroke.color;
            const alphaStroke = shape.visible && stroke.enable && 0 < stroke.width ? stroke.alpha : 0;
            const isNotInited = !(this.inited & BuilderFlag.COLOR);
            if (isNotInited ||
                colorFill !== this.colorFill ||
                alphaFill !== this.alphaFill ||
                colorStroke !== this.colorStroke ||
                alphaStroke !== this.alphaStroke) {
                this.inited |= BuilderFlag.COLOR;
                this.colorFill = colorFill;
                this.alphaFill = alphaFill;
                this.colorStroke = colorStroke;
                this.alphaStroke = alphaStroke;
                buffer.updateColors();
                buildColor(colorFill, alphaFill, colorStroke, alphaStroke, this.vertexOffset, this.vertexCount, buffer.colors);
            }
        }
        buildUnit(builder) {
            const texture = this.texture || pixi_js.Texture.WHITE;
            const baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                const indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toTransformLocalId = (shape) => {
        shape.updateTransform();
        return shape.transform.getLocalId();
    };
    const toTexture = (shape) => {
        return shape.texture || pixi_js.Texture.WHITE;
    };
    const toTextureTransformId = (texture) => {
        const textureAny = texture;
        if (textureAny._uvs == null) {
            texture.updateUvs();
        }
        return textureAny._updateID;
    };
    const toTextureUvs = (texture) => {
        return texture._uvs;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DThemes {
        static setDefaultThemeClass(theme) {
            this.DEFAULT_THEME_CLASS = theme;
        }
        static getDefaultThemeClass() {
            return this.DEFAULT_THEME_CLASS;
        }
        static getInstance() {
            if (this.INSTANCE == null) {
                const defaultThemeClass = this.getDefaultThemeClass();
                if (defaultThemeClass == null) {
                    throw new Error("No default theme class found");
                }
                this.INSTANCE = new defaultThemeClass();
            }
            return this.INSTANCE;
        }
        static setInstance(instance) {
            const result = this.INSTANCE;
            this.INSTANCE = instance;
            return result;
        }
        static get(type) {
            return this.getInstance().get(type);
        }
        static set(type, instance) {
            this.getInstance().set(type, instance);
        }
        static getClass(type) {
            return this.getInstance().getClass(type);
        }
        static setClass(type, themeClass) {
            this.getInstance().setClass(type, themeClass);
        }
        static getAtlas() {
            return this.getInstance().getAtlas();
        }
    }
    DThemes.DEFAULT_THEME_CLASS = null;
    DThemes.INSTANCE = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeDefaults {
        static get THEME() {
            const theme = this._THEME;
            if (theme != null) {
                return theme;
            }
            const newTheme = DThemes.getInstance().get("EShape");
            this._THEME = newTheme;
            return newTheme;
        }
        static get FILL_COLOR() {
            return this.THEME.getFillColor();
        }
        static get FILL_ALPHA() {
            return this.THEME.getFillAlpha();
        }
        static get STROKE_COLOR() {
            return this.THEME.getStrokeColor();
        }
        static get STROKE_ALPHA() {
            return this.THEME.getStrokeAlpha();
        }
        static get STROKE_WIDTH() {
            return this.THEME.getStrokeWidth();
        }
        static get STROKE_ALIGN() {
            return this.THEME.getStrokeAlign();
        }
        static get STROKE_SIDE() {
            return this.THEME.getStrokeSide();
        }
        static get STROKE_STYLE() {
            return this.THEME.getStrokeStyle();
        }
        static get TEXT_VALUE() {
            return this.THEME.getTextValue();
        }
        static get TEXT_COLOR() {
            return this.THEME.getTextColor();
        }
        static get TEXT_ALPHA() {
            return this.THEME.getTextAlpha();
        }
        static get TEXT_FAMILY() {
            return this.THEME.getTextFamily();
        }
        static get TEXT_SIZE() {
            return this.THEME.getTextSize();
        }
        static get RADIUS() {
            return this.THEME.getRadius();
        }
        static get SIZE_X() {
            return this.THEME.getSizeX();
        }
        static get SIZE_Y() {
            return this.THEME.getSizeY();
        }
        static get HIGHLIGHT_COLOR() {
            return this.THEME.getHighlightColor();
        }
        static get CURVE_SEGMENT_COUNT() {
            return this.THEME.getCurveSegmentCount();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapePointsMarkerType = {
        NONE: 0,
        CIRCLE: 1,
        TRIANGLE: 2,
        RECTANGLE: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeFillImpl {
        constructor(parent, enable, color, alpha) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
        }
        get enable() {
            return this._enable;
        }
        set enable(enable) {
            if (this._enable !== enable) {
                this._enable = enable;
                this._parent.updateUploaded();
            }
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                this._parent.updateUploaded();
            }
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                this._parent.updateUploaded();
            }
        }
        copy(target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha);
            }
        }
        set(enable, color, alpha) {
            let isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        }
        clone() {
            return new EShapeFillImpl(this._parent, this._enable, this._color, this._alpha);
        }
        toObject() {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha
            };
        }
        serialize(manager) {
            const stringified = `[${this._enable ? 1 : 0},${this._color},${this._alpha}]`;
            return manager.addResource(stringified);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                const parsed = manager.getFill(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2]);
                }
                else {
                    const deserialized = JSON.parse(resources[target]);
                    manager.setFill(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2]);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapePointsMarkerNoop {
        lock() {
            return this;
        }
        unlock() {
            return this;
        }
        get type() {
            return EShapePointsMarkerType.NONE;
        }
        set type(type) {
            // DO NOTHING
        }
        get size() {
            let result = this._size;
            if (result == null) {
                result = new pixi_js.Point();
                this._size = result;
            }
            return result;
        }
        get transform() {
            let result = this._transform;
            if (result == null) {
                result = new pixi_js.Matrix();
                this._transform = result;
            }
            return result;
        }
        get fill() {
            let result = this._fill;
            if (result == null) {
                result = new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, 1);
                this._fill = result;
            }
            return result;
        }
        updateUploaded() {
            // DO NOTHING
        }
        copy(source) {
            return this;
        }
        set(type, sizeX, sizeY) {
            return this;
        }
        serialize(manager) {
            return -1;
        }
        deserialize(resourceId, manager) {
            // DO NOTHING
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapePointsMarkerContainerImplNoop {
        constructor() {
            this._marker = new EShapePointsMarkerNoop();
        }
        lock() {
            return this;
        }
        unlock() {
            return this;
        }
        get head() {
            return this._marker;
        }
        get tail() {
            return this._marker;
        }
        copy(source) {
            return this;
        }
        serialize(manager) {
            return -1;
        }
        deserialize(resourceId, manager) {
            // DO NOTHING
        }
        static getInstance() {
            let result = this.INSTANCE;
            if (result == null) {
                result = new EShapePointsMarkerContainerImplNoop();
                this.INSTANCE = result;
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeBarPosition = {
        TOP: 0,
        LEFT: 1,
        RIGHT: 2,
        BOTTOM: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeBarPoints {
        constructor(parent) {
            this._parent = parent;
            this._id = 0;
            this._values = [0, 0, 0, 0];
            this._segments = [];
            this._style = EShapePointsStyle.NONE;
            this._size = -1;
            this._position = EShapeBarPosition.TOP;
            this._updatedSize = NaN;
            this._updatedParentSizeX = NaN;
            this._updatedParentSizeY = NaN;
            this._updatedPosition = NaN;
        }
        getComputedSize(size, position, sizeX, sizeY) {
            if (0 <= size) {
                return size;
            }
            else {
                switch (position) {
                    case EShapeBarPosition.TOP:
                    case EShapeBarPosition.BOTTOM:
                        return Math.abs(sizeY);
                    case EShapeBarPosition.RIGHT:
                    case EShapeBarPosition.LEFT:
                        return Math.abs(sizeX);
                }
                return 0;
            }
        }
        onSizeChange() {
            this.update();
        }
        update() {
            const parentSize = this._parent.size;
            const parentSizeX = parentSize.x;
            const parentSizeY = parentSize.y;
            const position = this._position;
            const size = this._size;
            if (this._updatedSize !== size ||
                this._updatedParentSizeX !== parentSizeX ||
                this._updatedParentSizeY !== parentSizeY ||
                this._updatedPosition !== position) {
                this._id += 1;
                this._updatedSize = size;
                this._updatedParentSizeX = parentSizeX;
                this._updatedParentSizeY = parentSizeY;
                this._updatedPosition = position;
                const psxh = parentSizeX * 0.5;
                const psyh = parentSizeY * 0.5;
                const computedSize = this.getComputedSize(size, position, parentSizeX, parentSizeY);
                const values = this._values;
                switch (position) {
                    case EShapeBarPosition.TOP:
                        values[0] = 0;
                        values[1] = -psyh;
                        values[2] = 0;
                        values[3] = -psyh + computedSize;
                        break;
                    case EShapeBarPosition.RIGHT:
                        values[0] = psxh;
                        values[1] = 0;
                        values[2] = psxh - computedSize;
                        values[3] = 0;
                        break;
                    case EShapeBarPosition.BOTTOM:
                        values[0] = 0;
                        values[1] = psyh;
                        values[2] = 0;
                        values[3] = psyh - computedSize;
                        break;
                    case EShapeBarPosition.LEFT:
                        values[0] = -psxh;
                        values[1] = 0;
                        values[2] = -psxh + computedSize;
                        values[3] = 0;
                        break;
                }
            }
        }
        get length() {
            return 2;
        }
        get plength() {
            return 2;
        }
        get id() {
            this.update();
            return this._id;
        }
        get values() {
            this.update();
            return this._values;
        }
        set values(values) {
            // SUPPOSED NOT TO BE CALLED
        }
        get segments() {
            return this._segments;
        }
        set segments(segments) {
            // SUPPOSED NOT TO BE CALLED
        }
        get size() {
            return this._size;
        }
        set size(size) {
            this.moveTo(undefined, size, undefined);
        }
        get position() {
            return this._position;
        }
        set position(position) {
            this.moveTo(position, undefined, undefined);
        }
        get style() {
            return this._style;
        }
        set style(style) {
            this.moveTo(undefined, undefined, style);
        }
        get marker() {
            let result = this._marker;
            if (result == null) {
                result = EShapePointsMarkerContainerImplNoop.getInstance();
                this._marker = result;
            }
            return result;
        }
        getMarker() {
            return undefined;
        }
        get formatter() {
            return null;
        }
        set formatter(formatter) {
            // DO NOTHING
        }
        get formatted() {
            return this;
        }
        copy(source) {
            if (source instanceof EShapeBarPoints) {
                return this.moveTo(source.position, source.size, source.style);
            }
            else {
                return this.moveTo(undefined, undefined, source.style);
            }
        }
        set(newValues, newSegments, newStyle) {
            let newPosition;
            let newSize;
            if (newValues != null) {
                const x0 = newValues[0];
                if (x0 === 0) {
                    const y0 = newValues[1];
                    newPosition = y0 <= 0 ? EShapeBarPosition.TOP : EShapeBarPosition.BOTTOM;
                    newSize = Math.abs(newValues[3] - y0);
                }
                else {
                    newPosition = x0 <= 0 ? EShapeBarPosition.LEFT : EShapeBarPosition.RIGHT;
                    newSize = Math.abs(newValues[2] - x0);
                }
            }
            return this.moveTo(newPosition, newSize, newStyle);
        }
        moveTo(position, size, style) {
            let isChanged = false;
            if (style != null && this._style !== style) {
                this._style = style;
                isChanged = true;
            }
            if (position != null && this._position !== position) {
                this._position = position;
                isChanged = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
            return this;
        }
        clone(parent) {
            return new EShapeBarPoints(parent).copy(this);
        }
        toPoints(transform) {
            const result = [];
            const values = this.values;
            for (let i = 0, imax = values.length; i < imax; i += 2) {
                const point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        }
        serialize(manager) {
            return manager.addResource(`[${this._position},${this._size},${this._style}]`);
        }
        deserialize(resourceId, manager) {
            if (0 <= resourceId && resourceId < manager.resources.length) {
                const resource = manager.resources[resourceId];
                const parsed = JSON.parse(resource);
                this.moveTo(parsed[0], parsed[1], parsed[2]);
            }
        }
        calcHitPointAbs(x, y, ax, ay, threshold, toRange, tester, result) {
            const length = this.length;
            if (2 <= length) {
                const values = this._values;
                const v0x = values[0];
                const v0y = values[1];
                const v1x = values[2];
                const v1y = values[3];
                if (tester(x, y, v0x, v0y, v1x, v1y, 0, threshold, result)) {
                    return true;
                }
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeLineBaseHitPart = {
        NONE: 0,
        LINE: 1,
        MARKER_TAIL: 2,
        MARKER_HEAD: 3,
        TEXT: 4,
        CHILDREN: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const TOP_LEFT$1 = 1;
    const TOP_RIGHT$1 = 2;
    const BOTTOM_LEFT$1 = 4;
    const BOTTOM_RIGHT$1 = 8;
    const EShapeCorner = {
        NONE: 0,
        TOP_LEFT: TOP_LEFT$1,
        TOP_RIGHT: TOP_RIGHT$1,
        BOTTOM_LEFT: BOTTOM_LEFT$1,
        BOTTOM_RIGHT: BOTTOM_RIGHT$1,
        TOP: TOP_LEFT$1 | TOP_RIGHT$1,
        BOTTOM: BOTTOM_LEFT$1 | BOTTOM_RIGHT$1,
        LEFT: TOP_LEFT$1 | BOTTOM_LEFT$1,
        RIGHT: TOP_RIGHT$1 | BOTTOM_RIGHT$1,
        ALL: TOP_LEFT$1 | TOP_RIGHT$1 | BOTTOM_LEFT$1 | BOTTOM_RIGHT$1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DApplications {
        static add(instance) {
            const instances = DApplications.INSTANCES;
            instances.push(instance);
        }
        static first() {
            const instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[0];
            }
            throw new Error("No application found.");
        }
        static last() {
            const instances = DApplications.INSTANCES;
            if (0 < instances.length) {
                return instances[instances.length - 1];
            }
            throw new Error("No application found.");
        }
        static get(index) {
            const instances = DApplications.INSTANCES;
            if (0 <= index && index < instances.length) {
                return instances[index];
            }
            return null;
        }
        static indexOf(instance) {
            return DApplications.INSTANCES.indexOf(instance);
        }
        static size() {
            return DApplications.INSTANCES.length;
        }
        static getStage(target) {
            let stage = target;
            while (stage.parent) {
                stage = stage.parent;
            }
            if ("application" in stage && "layer" in stage) {
                return stage;
            }
            return null;
        }
        static find(target) {
            const stage = this.getStage(target);
            if (stage) {
                return stage.layer.application;
            }
            return null;
        }
        static getLayerBase(target) {
            const stage = this.getStage(target);
            if (stage) {
                return stage.layer.application.getLayerBase();
            }
            return null;
        }
        static getLayerOverlay(target) {
            const stage = this.getStage(target);
            if (stage) {
                return stage.layer.application.getLayerOverlay();
            }
            return null;
        }
        static getLayer(target) {
            const stage = this.getStage(target);
            if (stage) {
                return stage.layer;
            }
            return null;
        }
        static getResolution(target) {
            var _a;
            const layer = this.getLayer(target);
            if (layer) {
                return layer.renderer.resolution;
            }
            return (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        }
        static update(target) {
            if (target) {
                const stage = this.getStage(target);
                if (stage) {
                    stage.layer.update();
                }
            }
            else {
                const instances = DApplications.INSTANCES;
                for (let i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].update();
                }
            }
        }
        static render(target) {
            if (target) {
                const stage = this.getStage(target);
                if (stage) {
                    stage.layer.render();
                }
            }
            else {
                const instances = DApplications.INSTANCES;
                for (let i = 0, imax = instances.length; i < imax; ++i) {
                    instances[i].render();
                }
            }
        }
    }
    DApplications.INSTANCES = [];

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeAction {
        constructor() {
            this.values = [];
        }
        add(value, index) {
            const values = this.values;
            if (index != null) {
                values.splice(index, 0, value);
            }
            else {
                values.push(value);
            }
            return this;
        }
        addAll(values) {
            const destination = this.values;
            for (let i = 0, imax = values.length; i < imax; ++i) {
                destination.push(values[i]);
            }
            return this;
        }
        clearAndAdd(value) {
            this.clear();
            this.add(value);
            return this;
        }
        clearAndAddAll(values) {
            this.clear();
            this.addAll(values);
            return this;
        }
        indexOf(target) {
            const values = this.values;
            // Instance-based matching
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                if (value.isEquals(target)) {
                    return i;
                }
            }
            return -1;
        }
        get(index) {
            const values = this.values;
            if (0 <= index || index < values.length) {
                return values[index];
            }
            return null;
        }
        set(index, value) {
            const values = this.values;
            if (0 <= index || index < values.length) {
                const result = values[index];
                values[index] = value;
                return result;
            }
            return null;
        }
        remove(index) {
            const values = this.values;
            if (0 <= index || index < values.length) {
                return values.splice(index, 1)[0];
            }
            return null;
        }
        clear() {
            this.values.length = 0;
            return this;
        }
        size() {
            return this.values.length;
        }
        swap(indexA, indexB) {
            const values = this.values;
            const tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
            return this;
        }
        serialize(manager) {
            const result = [];
            const values = this.values;
            for (let i = 0, imax = values.length; i < imax; ++i) {
                result.push(values[i].serialize(manager));
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectorContainerImpl {
        constructor(parent) {
            this._parent = parent;
            this._edges = new Set();
        }
        add(target) {
            const edges = this._edges;
            if (!edges.has(target)) {
                edges.add(target);
                return true;
            }
            return false;
        }
        contains(target) {
            return this._edges.has(target);
        }
        size() {
            return this._edges.size;
        }
        remove(target) {
            return this._edges.delete(target);
        }
        clear() {
            const edges = this._edges;
            if (0 < edges.size) {
                this._edges.clear();
                return true;
            }
            return false;
        }
        copy(source) {
            const edges = this._edges;
            edges.clear();
            source.each((edge) => {
                edges.add(edge);
            });
            return this;
        }
        each(iteratee) {
            this._edges.forEach(iteratee);
            return this;
        }
        fit(forcibly) {
            this._edges.forEach(this.toOnFitBound(forcibly));
        }
        toOnFitBound(forcibly) {
            if (forcibly) {
                let result = this._onFitBoundForcibly;
                if (result == null) {
                    result = this.newOnFitBound(true);
                    this._onFitBoundForcibly = result;
                }
                return result;
            }
            else {
                let result = this._onFitBound;
                if (result == null) {
                    result = this.newOnFitBound(false);
                    this._onFitBound = result;
                }
                return result;
            }
        }
        newOnFitBound(forcibly) {
            return (edge) => {
                this.onFit(edge, forcibly);
            };
        }
        onFit(target, forcibly) {
            target.fit(forcibly);
        }
        attach() {
            const parent = this._parent;
            this._edges.forEach((edge) => {
                edge.set(parent);
            });
            return this;
        }
        detach(exceptions) {
            this._edges.forEach((edge) => {
                if (exceptions == null || !exceptions.has(edge.parent)) {
                    edge.set(null);
                }
            });
            return this;
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const TRANSFORM = 1;
    const SIZE = 2;
    const STYLE = 4;
    const ACTION$1 = 8;
    const POINTS = 16;
    const STATE = 32;
    const IMAGE = 64;
    const DATA$1 = 128;
    const CONNECTOR$1 = 256;
    const CAPABILITY = 512;
    const EShapeCopyPart = {
        NONE: 0,
        TRANSFORM,
        SIZE,
        STYLE,
        ACTION: ACTION$1,
        POINTS,
        STATE,
        IMAGE,
        DATA: DATA$1,
        /** @deprecated in favor of {@link DATA} */
        TAG: DATA$1,
        CONNECTOR: CONNECTOR$1,
        CAPABILITY,
        ALL: TRANSFORM | SIZE | STYLE | ACTION$1 | POINTS | STATE | IMAGE | DATA$1 | CONNECTOR$1 | CAPABILITY
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DBaseState = {
        HOVERED: "HOVERED",
        ACTIVE: "ACTIVE",
        FOCUSED: "FOCUSED",
        UNFOCUSABLE: "UNFOCUSABLE",
        FOCUS_ROOT: "FOCUS_ROOT",
        FOCUS_REVERSE: "FOCUS_REVERSE",
        READ_ONLY: "READ_ONLY",
        DISABLED: "DISABLED",
        GESTURING: "GESTURING",
        PRESSED: "PRESSED",
        INVALID: "INVALID",
        PROCESSING: "PROCESSING",
        SUCCEEDED: "SUCCEEDED",
        FAILED: "FAILED",
        WARNED: "WARNED",
        CHANGED: "CHANGED",
        ALTERNATED: "ALTERNATED",
        NEW_WINDOW: "NEW_WINDOW"
    };

    class DBaseStateSetSubDatumImp {
        constructor(interval) {
            this._stateToTargets = new Map();
            this._interval = interval;
            this._onTimeBound = () => this.onTime();
        }
        get interval() {
            return this._interval;
        }
        add(state, target) {
            const stateToTargets = this._stateToTargets;
            let targets = stateToTargets.get(state);
            if (targets == null) {
                targets = new Set();
                targets.add(target);
                stateToTargets.set(state, targets);
                if (stateToTargets.size <= 1) {
                    this.start();
                }
            }
            else {
                targets.add(target);
            }
            return this;
        }
        remove(state, target) {
            const stateToTargets = this._stateToTargets;
            const targets = stateToTargets.get(state);
            if (targets != null && targets.has(target)) {
                targets.delete(target);
                target.remove(state);
                if (targets.size <= 0) {
                    stateToTargets.delete(state);
                }
                if (stateToTargets.size <= 0) {
                    this.stop();
                }
            }
            return this;
        }
        start() {
            if (this._timeoutId == null) {
                this.onTime();
            }
            return this;
        }
        stop() {
            const timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
                this._timeoutId = undefined;
            }
            return this;
        }
        onTime() {
            const now = Date.now();
            const interval = this.interval;
            const value = this.newValue(now, interval);
            const on = this.newOn(now, interval);
            this._stateToTargets.forEach((targets, state) => {
                targets.forEach((target) => {
                    target.set(state, value, on);
                });
            });
            this._timeoutId = window.setTimeout(this._onTimeBound, Math.max(0, interval - (now % interval)));
        }
    }

    class DBaseStateSetBlinkerDatumImpl extends DBaseStateSetSubDatumImp {
        newValue(now, interval) {
            return null;
        }
        newOn(now, interval) {
            return Math.round(now / interval) % 2 === 0;
        }
    }

    class DBaseStateSetSubImpl {
        constructor(parent, intervalToDatum) {
            this._parent = parent;
            this._stateToInterval = new Map();
            this._intervalToDatum = intervalToDatum;
        }
        add(state, interval) {
            // Check if the interval is not same
            const stateToInterval = this._stateToInterval;
            const oldInterval = stateToInterval.get(state);
            if (oldInterval === interval) {
                return this;
            }
            // Remove the existing one
            if (oldInterval != null) {
                stateToInterval.delete(state);
                const datum = this._intervalToDatum.get(oldInterval);
                if (datum != null) {
                    datum.remove(state, this._parent);
                }
            }
            // Add a new one
            stateToInterval.set(state, interval);
            let datum = this._intervalToDatum.get(interval);
            if (datum == null) {
                datum = this.newDatum(interval);
                this._intervalToDatum.set(interval, datum);
            }
            datum.add(state, this._parent);
            // Done
            return this;
        }
        remove(state) {
            const interval = this._stateToInterval.get(state);
            if (interval == null) {
                return this;
            }
            this._stateToInterval.delete(state);
            const datum = this._intervalToDatum.get(interval);
            if (datum == null) {
                return this;
            }
            datum.remove(state, this._parent);
            return this;
        }
        set(state, interval, on) {
            if (on) {
                return this.add(state, interval);
            }
            else {
                return this.remove(state);
            }
        }
        has(state) {
            return this._stateToInterval.has(state);
        }
        clear() {
            const parent = this._parent;
            const stateToInterval = this._stateToInterval;
            stateToInterval.forEach((interval, state) => {
                const datum = this._intervalToDatum.get(interval);
                if (datum != null) {
                    datum.remove(state, parent);
                }
            });
            stateToInterval.clear();
            return this;
        }
    }

    let intervalToDatum$1;
    class DBaseStateSetBlinkerImpl extends DBaseStateSetSubImpl {
        constructor(parent) {
            super(parent, (intervalToDatum$1 !== null && intervalToDatum$1 !== void 0 ? intervalToDatum$1 : (intervalToDatum$1 = new Map())));
        }
        newDatum(interval) {
            return new DBaseStateSetBlinkerDatumImpl(interval);
        }
    }

    class DBaseStateSetTickerDatumImpl extends DBaseStateSetSubDatumImp {
        newValue(now, interval) {
            return Math.round(now / interval);
        }
        newOn(now, interval) {
            return true;
        }
    }

    let intervalToDatum;
    class DBaseStateSetTickerImpl extends DBaseStateSetSubImpl {
        constructor(parent) {
            super(parent, (intervalToDatum !== null && intervalToDatum !== void 0 ? intervalToDatum : (intervalToDatum = new Map())));
        }
        newDatum(interval) {
            return new DBaseStateSetTickerDatumImpl(interval);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const isArray = Array.isArray ||
        ((target) => {
            return Object.prototype.toString.call(target) === "[object Array]";
        });

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    const isFunction = (target) => {
        return typeof target === "function";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const isNumber = (target) => {
        return (typeof target === "number" || Object.prototype.toString.call(target) === "[object Number]");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const isString = (target) => {
        return (typeof target === "string" || Object.prototype.toString.call(target) === "[object String]");
    };

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseStateSetImpl {
        constructor() {
            this._local = new Map();
            this._parent = null;
        }
        get local() {
            return this._local;
        }
        get parent() {
            return this._parent;
        }
        set parent(parent) {
            if (this._parent !== parent) {
                this.begin();
                this._parent = parent;
                this.end();
            }
        }
        onParentChange(newState, oldState) {
            this._parent = oldState;
            this.begin();
            this._parent = newState;
            this.end();
        }
        get blinker() {
            let result = this._blinker;
            if (result == null) {
                result = this.newBlinker();
                this._blinker = result;
            }
            return result;
        }
        newBlinker() {
            return new DBaseStateSetBlinkerImpl(this);
        }
        get ticker() {
            let result = this._ticker;
            if (result == null) {
                result = this.newTicker();
                this._ticker = result;
            }
            return result;
        }
        newTicker() {
            return new DBaseStateSetTickerImpl(this);
        }
        is(state, value) {
            const v = this._local.get(state);
            return v !== undefined && (value === undefined || value === v);
        }
        in(state, value) {
            return this.is(state, value) || this.under(state, value);
        }
        on(state, value) {
            const parent = this._parent;
            return parent != null && parent.is(state, value);
        }
        under(state, value) {
            const parent = this._parent;
            return parent != null && parent.in(state, value);
        }
        lock(callOnChange) {
            return this;
        }
        unlock() {
            return this;
        }
        begin() {
            return this;
        }
        end() {
            return this;
        }
        checkAdded(added, value) {
            const v = this._local.get(added);
            return v === undefined || v !== value;
        }
        add(state, value = null) {
            if (this.checkAdded(state, value)) {
                this.begin();
                this._local.set(state, value);
                this.end();
            }
            return this;
        }
        checkAddedsString(states) {
            const local = this._local;
            for (let i = 0, imax = states.length; i < imax; ++i) {
                const v = local.get(states[i]);
                if (v === undefined || v !== null) {
                    return true;
                }
            }
            return false;
        }
        checkAddedsObject(states) {
            const local = this._local;
            for (let i = 0, imax = states.length; i < imax; ++i) {
                const state = states[i];
                const v = local.get(state.state);
                if (v === undefined || v !== state.value) {
                    return true;
                }
            }
            return false;
        }
        addAll(first) {
            if (isString(first)) {
                return this.addAllString(arguments); // eslint-disable-line prefer-rest-params
            }
            else if (isArray(first)) {
                if (0 < first.length) {
                    const element = first[0];
                    if (isString(element)) {
                        return this.addAllString(first);
                    }
                    else {
                        return this.addAllObject(first);
                    }
                }
                return this;
            }
            else {
                return this.addAllObject(arguments); // eslint-disable-line prefer-rest-params
            }
        }
        addAllString(states) {
            if (this.checkAddedsString(states)) {
                this.begin();
                const local = this._local;
                for (let i = 0, imax = states.length; i < imax; ++i) {
                    local.set(states[i], null);
                }
                this.end();
            }
            return this;
        }
        addAllObject(states) {
            if (this.checkAddedsObject(states)) {
                this.begin();
                const local = this._local;
                for (let i = 0, imax = states.length; i < imax; ++i) {
                    const state = states[i];
                    local.set(state.state, state.value);
                }
                this.end();
            }
            return this;
        }
        checkRemoved(removed) {
            return this._local.has(removed);
        }
        remove(state) {
            if (this.checkRemoved(state)) {
                this.begin();
                this._local.delete(state);
                this.end();
            }
            return this;
        }
        checkRemovedsString(states) {
            const local = this._local;
            for (let i = 0, imax = states.length; i < imax; ++i) {
                if (local.has(states[i])) {
                    return true;
                }
            }
            return false;
        }
        checkRemovedsObject(states) {
            const local = this._local;
            for (let i = 0, imax = states.length; i < imax; ++i) {
                if (local.has(states[i].state)) {
                    return true;
                }
            }
            return false;
        }
        removeAll(first) {
            if (isFunction(first)) {
                return this.removeAllMatcher(first);
            }
            else if (isString(first)) {
                return this.removeAllString(arguments); // eslint-disable-line prefer-rest-params
            }
            else if (isArray(first)) {
                if (0 < first.length) {
                    const element = first[0];
                    if (isString(element)) {
                        return this.removeAllString(first);
                    }
                    else {
                        return this.removeAllObject(first);
                    }
                }
                return this;
            }
            else {
                return this.removeAllObject(arguments); // eslint-disable-line prefer-rest-params
            }
        }
        removeAllMatcher(matcher) {
            let isDirty = false;
            const local = this._local;
            local.forEach((value, state) => {
                if (matcher(state)) {
                    if (!isDirty) {
                        isDirty = true;
                        this.begin();
                    }
                    local.delete(state);
                }
            });
            if (isDirty) {
                this.end();
            }
            return this;
        }
        removeAllString(states) {
            if (this.checkRemovedsString(states)) {
                this.begin();
                const local = this._local;
                for (let i = 0, imax = states.length; i < imax; ++i) {
                    local.delete(states[i]);
                }
                this.end();
            }
            return this;
        }
        removeAllObject(states) {
            if (this.checkRemovedsObject(states)) {
                this.begin();
                const local = this._local;
                for (let i = 0, imax = states.length; i < imax; ++i) {
                    local.delete(states[i].state);
                }
                this.end();
            }
            return this;
        }
        set(first, second, third) {
            if (second === true) {
                if (first != null) {
                    this.add(first);
                }
            }
            else if (second === false) {
                if (first != null) {
                    this.remove(first);
                }
            }
            else if (second == null || isNumber(second)) {
                if (third === true) {
                    if (first != null) {
                        this.add(first, second);
                    }
                }
                else if (third === false) {
                    if (first != null) {
                        this.remove(first);
                    }
                }
                else {
                    return this.doSet(first, second, third);
                }
            }
            else {
                return this.doSet(first, null, second);
            }
            return this;
        }
        doSet(added, value, removed) {
            if (added != null) {
                if (removed != null) {
                    if (this.checkAdded(added, value) || this.checkRemoved(removed)) {
                        this.begin();
                        this._local.set(added, value).delete(removed);
                        this.end();
                    }
                }
                else {
                    this.add(added, value);
                }
            }
            else if (removed != null) {
                this.remove(removed);
            }
            return this;
        }
        setAll(first, second) {
            if (second === true) {
                if (first != null) {
                    this.addAll(first);
                }
            }
            else if (second === false) {
                if (first != null) {
                    this.removeAll(first);
                }
            }
            else {
                if (first != null && 0 < first.length) {
                    if (second != null && 0 < second.length) {
                        const added = first[0];
                        if (isString(added)) {
                            return this.setAllString(first, second);
                        }
                        else {
                            return this.setAllObject(first, second);
                        }
                    }
                    else {
                        this.addAll(first);
                    }
                }
                else if (second != null) {
                    this.removeAll(second);
                }
            }
            return this;
        }
        setAllString(addeds, removeds) {
            if (this.checkAddedsString(addeds) || this.checkRemovedsString(removeds)) {
                this.begin();
                const local = this._local;
                for (let i = 0, imax = addeds.length; i < imax; ++i) {
                    local.set(addeds[i], null);
                }
                for (let i = 0, imax = removeds.length; i < imax; ++i) {
                    local.delete(removeds[i]);
                }
                this.end();
            }
            return this;
        }
        setAllObject(addeds, removeds) {
            if (this.checkAddedsObject(addeds) || this.checkRemovedsString(removeds)) {
                this.begin();
                const local = this._local;
                for (let i = 0, imax = addeds.length; i < imax; ++i) {
                    const added = addeds[i];
                    local.set(added.state, added.value);
                }
                for (let i = 0, imax = removeds.length; i < imax; ++i) {
                    local.delete(removeds[i]);
                }
                this.end();
            }
            return this;
        }
        clear() {
            const local = this._local;
            if (0 < local.size) {
                this.begin();
                local.clear();
                this.end();
            }
            return this;
        }
        valueOf(state, def) {
            const result = this._local.get(state);
            if (result !== undefined) {
                if (result == null && def !== undefined) {
                    return def;
                }
                return result;
            }
            const parent = this._parent;
            if (parent != null) {
                if (def !== undefined) {
                    return parent.valueOf(state, def);
                }
                else {
                    return parent.valueOf(state);
                }
            }
            return def;
        }
        each(iteratee) {
            this._local.forEach((value, state) => {
                iteratee(state, value);
            });
            return this;
        }
        size() {
            return this._local.size;
        }
        copy(other) {
            if (other instanceof DBaseStateSetImpl) {
                this.begin();
                const local = this._local;
                local.clear();
                other.local.forEach((value, state) => {
                    local.set(state, value);
                });
                this._parent = other.parent;
                this.end();
            }
            return this;
        }
        get isHovered() {
            return this.is(DBaseState.HOVERED);
        }
        set isHovered(isHovered) {
            this.set(DBaseState.HOVERED, isHovered);
        }
        get inHovered() {
            return this.in(DBaseState.HOVERED);
        }
        get onHovered() {
            return this.on(DBaseState.HOVERED);
        }
        get underHovered() {
            return this.under(DBaseState.HOVERED);
        }
        get isActive() {
            return this.is(DBaseState.ACTIVE);
        }
        set isActive(isActive) {
            this.set(DBaseState.ACTIVE, isActive);
        }
        get inActive() {
            return this.in(DBaseState.ACTIVE);
        }
        get onActive() {
            return this.on(DBaseState.ACTIVE);
        }
        get underActive() {
            return this.under(DBaseState.ACTIVE);
        }
        get isPressed() {
            return this.is(DBaseState.PRESSED);
        }
        set isPressed(isPressed) {
            this.set(DBaseState.PRESSED, isPressed);
        }
        get inPressed() {
            return this.in(DBaseState.PRESSED);
        }
        get onPressed() {
            return this.on(DBaseState.PRESSED);
        }
        get underPressed() {
            return this.under(DBaseState.PRESSED);
        }
        get isReadOnly() {
            return this.is(DBaseState.READ_ONLY);
        }
        set isReadOnly(isReadOnly) {
            this.set(DBaseState.READ_ONLY, isReadOnly);
        }
        get inReadOnly() {
            return this.in(DBaseState.READ_ONLY);
        }
        get onReadOnly() {
            return this.on(DBaseState.READ_ONLY);
        }
        get underReadOnly() {
            return this.under(DBaseState.READ_ONLY);
        }
        get isEnabled() {
            return !this.is(DBaseState.DISABLED);
        }
        set isEnabled(isEnabled) {
            this.set(DBaseState.DISABLED, !isEnabled);
        }
        get inEnabled() {
            return !this.in(DBaseState.DISABLED);
        }
        get onEnabled() {
            return !this.on(DBaseState.DISABLED);
        }
        get underEnabled() {
            return !this.under(DBaseState.DISABLED);
        }
        get isDisabled() {
            return this.is(DBaseState.DISABLED);
        }
        set isDisabled(isDisabled) {
            this.set(DBaseState.DISABLED, isDisabled);
        }
        get inDisabled() {
            return this.in(DBaseState.DISABLED);
        }
        get onDisabled() {
            return this.on(DBaseState.DISABLED);
        }
        get underDisabled() {
            return this.under(DBaseState.DISABLED);
        }
        get isActionable() {
            return !this.in(DBaseState.DISABLED) && !this.in(DBaseState.READ_ONLY);
        }
        get isGesturing() {
            return this.is(DBaseState.GESTURING);
        }
        set isGesturing(isGesturing) {
            this.set(DBaseState.GESTURING, isGesturing);
        }
        get inGesturing() {
            return this.in(DBaseState.GESTURING);
        }
        get onGesturing() {
            return this.on(DBaseState.GESTURING);
        }
        get underGesturing() {
            return this.under(DBaseState.GESTURING);
        }
        get isFocused() {
            return this.is(DBaseState.FOCUSED);
        }
        set isFocused(isFocused) {
            this.set(DBaseState.FOCUSED, isFocused);
        }
        get inFocused() {
            return this.in(DBaseState.FOCUSED);
        }
        get onFocused() {
            return this.on(DBaseState.FOCUSED);
        }
        get underFocused() {
            return this.under(DBaseState.FOCUSED);
        }
        get isFocusRoot() {
            return this.is(DBaseState.FOCUS_ROOT);
        }
        set isFocusRoot(isFocusRoot) {
            this.set(DBaseState.FOCUS_ROOT, isFocusRoot);
        }
        get inFocusRoot() {
            return this.in(DBaseState.FOCUS_ROOT);
        }
        get onFocusRoot() {
            return this.on(DBaseState.FOCUS_ROOT);
        }
        get underFocusRoot() {
            return this.under(DBaseState.FOCUS_ROOT);
        }
        get isFocusReverse() {
            return this.is(DBaseState.FOCUS_REVERSE);
        }
        set isFocusReverse(isFocusReverse) {
            this.set(DBaseState.FOCUS_REVERSE, isFocusReverse);
        }
        get inFocusReverse() {
            return this.in(DBaseState.FOCUS_REVERSE);
        }
        get onFocusReverse() {
            return this.on(DBaseState.FOCUS_REVERSE);
        }
        get underFocusReverse() {
            return this.under(DBaseState.FOCUS_REVERSE);
        }
        get isFocusable() {
            return !this.is(DBaseState.UNFOCUSABLE);
        }
        set isFocusable(isFocusable) {
            this.set(DBaseState.UNFOCUSABLE, !isFocusable);
        }
        get inFocusable() {
            return !this.in(DBaseState.UNFOCUSABLE);
        }
        get onFocusable() {
            return !this.on(DBaseState.UNFOCUSABLE);
        }
        get underFocusable() {
            return !this.under(DBaseState.UNFOCUSABLE);
        }
        get isUnfocusable() {
            return this.is(DBaseState.UNFOCUSABLE);
        }
        set isUnfocusable(unfocusable) {
            this.set(DBaseState.UNFOCUSABLE, unfocusable);
        }
        get inUnfocusable() {
            return this.in(DBaseState.UNFOCUSABLE);
        }
        get onUnfocusable() {
            return this.on(DBaseState.UNFOCUSABLE);
        }
        get underUnfocusable() {
            return this.under(DBaseState.UNFOCUSABLE);
        }
        get isInvalid() {
            return this.is(DBaseState.INVALID);
        }
        set isInvalid(invalid) {
            this.set(DBaseState.INVALID, invalid);
        }
        get inInvalid() {
            return this.in(DBaseState.INVALID);
        }
        get onInvalid() {
            return this.on(DBaseState.INVALID);
        }
        get underInvalid() {
            return this.on(DBaseState.INVALID);
        }
        get isProcessing() {
            return this.is(DBaseState.PROCESSING);
        }
        set isProcessing(processing) {
            this.set(DBaseState.PROCESSING, processing);
        }
        get inProcessing() {
            return this.in(DBaseState.PROCESSING);
        }
        get onProcessing() {
            return this.on(DBaseState.PROCESSING);
        }
        get underProcessing() {
            return this.under(DBaseState.PROCESSING);
        }
        get isSucceeded() {
            return this.is(DBaseState.SUCCEEDED);
        }
        set isSucceeded(succeeded) {
            this.set(DBaseState.SUCCEEDED, succeeded);
        }
        get inSucceeded() {
            return this.in(DBaseState.SUCCEEDED);
        }
        get onSucceeded() {
            return this.on(DBaseState.SUCCEEDED);
        }
        get underSucceeded() {
            return this.under(DBaseState.SUCCEEDED);
        }
        get isFailed() {
            return this.is(DBaseState.FAILED);
        }
        set isFailed(failed) {
            this.set(DBaseState.FAILED, failed);
        }
        get inFailed() {
            return this.in(DBaseState.FAILED);
        }
        get onFailed() {
            return this.on(DBaseState.FAILED);
        }
        get underFailed() {
            return this.under(DBaseState.FAILED);
        }
        get isWarned() {
            return this.is(DBaseState.WARNED);
        }
        set isWarned(isWarned) {
            this.set(DBaseState.WARNED, isWarned);
        }
        get inWarned() {
            return this.in(DBaseState.WARNED);
        }
        get onWarned() {
            return this.on(DBaseState.WARNED);
        }
        get underWarned() {
            return this.on(DBaseState.WARNED);
        }
        get isChanged() {
            return this.is(DBaseState.CHANGED);
        }
        set isChanged(isChanged) {
            this.set(DBaseState.CHANGED, isChanged);
        }
        get inChanged() {
            return this.in(DBaseState.CHANGED);
        }
        get onChanged() {
            return this.on(DBaseState.CHANGED);
        }
        get underChanged() {
            return this.on(DBaseState.CHANGED);
        }
        get isAlternated() {
            return this.is(DBaseState.ALTERNATED);
        }
        set isAlternated(isAlternated) {
            this.set(DBaseState.ALTERNATED, isAlternated);
        }
        get inAlternated() {
            return this.in(DBaseState.ALTERNATED);
        }
        get onAlternated() {
            return this.on(DBaseState.ALTERNATED);
        }
        get underAlternated() {
            return this.on(DBaseState.ALTERNATED);
        }
        toObject() {
            const states = [];
            this._local.forEach((value, state) => {
                states.push(state);
            });
            return {
                local: states
            };
        }
        toString() {
            return JSON.stringify(this.toObject());
        }
    }

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseStateSetImplObservable extends DBaseStateSetImpl {
        constructor(onChange) {
            super();
            this._onChange = onChange;
            this._isLocked = 0;
            this._isSaved = false;
            this._doSave = true;
        }
        lock(callOnChange) {
            this._isLocked += 1;
            if (callOnChange === false) {
                this._doSave = false;
            }
            return this;
        }
        unlock() {
            this._isLocked -= 1;
            return this.end();
        }
        get saved() {
            let result = this._saved;
            if (result == null) {
                result = new DBaseStateSetImpl();
                this._saved = result;
            }
            return result;
        }
        begin() {
            if (this._doSave && !this._isSaved) {
                this._isSaved = true;
                this.saved.copy(this);
            }
            return this;
        }
        end() {
            if (this._isLocked <= 0) {
                this._doSave = true;
                if (this._isSaved) {
                    this._isSaved = false;
                    this.onChange(this, this.saved);
                }
            }
            return this;
        }
        onChange(newState, oldState) {
            this._onChange(newState, oldState);
        }
    }

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeState = {
        CLICKED: "CLICKED",
        DBL_CLICKED: "DBL_CLICKED",
        DOWN: "DOWN",
        UP: "UP",
        UP_OUTSIDE: "UP_OUTSIDE",
        RIGHT_CLICKED: "RIGHT_CLICKED",
        RIGHT_DOWN: "RIGHT_DOWN",
        RIGHT_UP: "RIGHT_UP",
        RIGHT_UP_OUTSIDE: "RIGHT_UP_OUTSIDE",
        RIGHT_PRESSED: "RIGHT_PRESSED",
        ACTIVATED: "ACTIVATED",
        DEACTIVATED: "DEACTIVATED"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeStateSetImplObservable extends DBaseStateSetImplObservable {
        onChange(newState, oldState) {
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this._local.set(EShapeState.ACTIVATED, null).delete(EShapeState.DEACTIVATED);
                }
            }
            else {
                if (oldState.isActive) {
                    this._local.set(EShapeState.DEACTIVATED, null).delete(EShapeState.ACTIVATED);
                }
            }
            super.onChange(newState, oldState);
        }
        get isClicked() {
            return this.is(EShapeState.CLICKED);
        }
        set isClicked(isClicked) {
            this.set(EShapeState.CLICKED, isClicked);
        }
        get inClicked() {
            return this.in(EShapeState.CLICKED);
        }
        get onClicked() {
            return this.on(EShapeState.CLICKED);
        }
        get underClicked() {
            return this.under(EShapeState.CLICKED);
        }
        get isDblClicked() {
            return this.is(EShapeState.DBL_CLICKED);
        }
        set isDblClicked(isDblClicked) {
            this.set(EShapeState.DBL_CLICKED, isDblClicked);
        }
        get inDblClicked() {
            return this.in(EShapeState.DBL_CLICKED);
        }
        get onDblClicked() {
            return this.on(EShapeState.DBL_CLICKED);
        }
        get underDblClicked() {
            return this.under(EShapeState.DBL_CLICKED);
        }
        get isDown() {
            return this.is(EShapeState.DOWN);
        }
        set isDown(isDown) {
            this.set(EShapeState.DOWN, isDown);
        }
        get inDown() {
            return this.in(EShapeState.DOWN);
        }
        get onDown() {
            return this.on(EShapeState.DOWN);
        }
        get underDown() {
            return this.under(EShapeState.DOWN);
        }
        get isUp() {
            return this.is(EShapeState.UP);
        }
        set isUp(isUp) {
            this.set(EShapeState.UP, isUp);
        }
        get inUp() {
            return this.in(EShapeState.UP);
        }
        get onUp() {
            return this.on(EShapeState.UP);
        }
        get underUp() {
            return this.under(EShapeState.UP);
        }
        get isUpOutside() {
            return this.is(EShapeState.UP_OUTSIDE);
        }
        set isUpOutside(isUpOutside) {
            this.set(EShapeState.UP_OUTSIDE, isUpOutside);
        }
        get inUpOutside() {
            return this.in(EShapeState.UP_OUTSIDE);
        }
        get onUpOutside() {
            return this.on(EShapeState.UP_OUTSIDE);
        }
        get underUpOutside() {
            return this.under(EShapeState.UP_OUTSIDE);
        }
        get isRightClicked() {
            return this.is(EShapeState.RIGHT_CLICKED);
        }
        set isRightClicked(isRightClicked) {
            this.set(EShapeState.RIGHT_CLICKED, isRightClicked);
        }
        get inRightClicked() {
            return this.in(EShapeState.RIGHT_CLICKED);
        }
        get onRightClicked() {
            return this.on(EShapeState.RIGHT_CLICKED);
        }
        get underRightClicked() {
            return this.under(EShapeState.RIGHT_CLICKED);
        }
        get isRightDown() {
            return this.is(EShapeState.RIGHT_DOWN);
        }
        set isRightDown(isRightDown) {
            this.set(EShapeState.RIGHT_DOWN, isRightDown);
        }
        get inRightDown() {
            return this.in(EShapeState.RIGHT_DOWN);
        }
        get onRightDown() {
            return this.on(EShapeState.RIGHT_DOWN);
        }
        get underRightDown() {
            return this.under(EShapeState.RIGHT_DOWN);
        }
        get isRightUp() {
            return this.is(EShapeState.RIGHT_UP);
        }
        set isRightUp(isRightUp) {
            this.set(EShapeState.RIGHT_UP, isRightUp);
        }
        get inRightUp() {
            return this.in(EShapeState.RIGHT_UP);
        }
        get onRightUp() {
            return this.on(EShapeState.RIGHT_UP);
        }
        get underRightUp() {
            return this.under(EShapeState.RIGHT_UP);
        }
        get isRightUpOutside() {
            return this.is(EShapeState.RIGHT_UP_OUTSIDE);
        }
        set isRightUpOutside(isRightUpOutside) {
            this.set(EShapeState.RIGHT_UP_OUTSIDE, isRightUpOutside);
        }
        get inRightUpOutside() {
            return this.in(EShapeState.RIGHT_UP_OUTSIDE);
        }
        get onRightUpOutside() {
            return this.on(EShapeState.RIGHT_UP_OUTSIDE);
        }
        get underRightUpOutside() {
            return this.under(EShapeState.RIGHT_UP_OUTSIDE);
        }
        get isRightPressed() {
            return this.is(EShapeState.RIGHT_PRESSED);
        }
        set isRightPressed(isRightPressed) {
            this.set(EShapeState.RIGHT_PRESSED, isRightPressed);
        }
        get inRightPressed() {
            return this.in(EShapeState.RIGHT_PRESSED);
        }
        get onRightPressed() {
            return this.on(EShapeState.RIGHT_PRESSED);
        }
        get underRightPressed() {
            return this.under(EShapeState.RIGHT_PRESSED);
        }
        get isActivated() {
            return this.is(EShapeState.ACTIVATED);
        }
        set isActivated(isActivated) {
            this.set(EShapeState.ACTIVATED, isActivated);
        }
        get inActivated() {
            return this.in(EShapeState.ACTIVATED);
        }
        get onActivated() {
            return this.on(EShapeState.ACTIVATED);
        }
        get underActivated() {
            return this.under(EShapeState.ACTIVATED);
        }
        get isDeactivated() {
            return this.is(EShapeState.DEACTIVATED);
        }
        set isDeactivated(isDeactivated) {
            this.set(EShapeState.DEACTIVATED, isDeactivated);
        }
        get inDeactivated() {
            return this.in(EShapeState.DEACTIVATED);
        }
        get onDeactivated() {
            return this.on(EShapeState.DEACTIVATED);
        }
        get underDeactivated() {
            return this.under(EShapeState.DEACTIVATED);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeTransformImpl extends pixi_js.Transform {
        constructor(parent) {
            super();
            this.internalTransform = new pixi_js.Matrix();
            this._parent = parent;
        }
        onChange() {
            super.onChange();
            this._parent.onTransformChange();
        }
        updateSkew() {
            super.updateSkew();
            this._parent.onTransformChange();
        }
        getLocalIdCurrent() {
            return this._currentLocalID;
        }
        getLocalId() {
            return this._localID;
        }
        getParentId() {
            return this._parentID;
        }
        getWorldId() {
            return this._worldID;
        }
        updateTransform(parentTransform) {
            const oldLocalId = this._currentLocalID;
            const oldWorldId = this._worldID;
            super.updateTransform(parentTransform);
            const newLocalId = this._currentLocalID;
            const newWorldId = this._worldID;
            if (oldLocalId !== newLocalId) {
                const localTransform = this.localTransform;
                const internalTransform = this.internalTransform;
                localTransform.copyTo(internalTransform);
                if (parentTransform instanceof EShapeTransformImpl) {
                    internalTransform.prepend(parentTransform.internalTransform);
                }
            }
            else if (oldWorldId !== newWorldId) {
                const localTransform = this.localTransform;
                const internalTransform = this.internalTransform;
                if (parentTransform instanceof EShapeTransformImpl) {
                    localTransform.copyTo(internalTransform).prepend(parentTransform.internalTransform);
                    this._currentLocalID += 1;
                    this._localID = this._currentLocalID;
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeBaseHitTestData {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            this.strokeWidth = 0;
            this.strokeScale = 1;
            this.strokeAlign = 0;
        }
        set(x, y, width, height, strokeWidth, strokeScale, strokeAlign) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.strokeWidth = strokeWidth;
            this.strokeScale = strokeScale;
            this.strokeAlign = strokeAlign;
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const hitTestBBox = (x, y, ax, ay) => {
        return -ax <= x && x <= +ax && -ay <= y && y <= +ay;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /* eslint-disable prettier/prettier */
    const NONE = 0x0;
    const ID = 0x1;
    const POSITION = 0x2;
    const WIDTH$1 = 0x4;
    const HEIGHT$1 = 0x8;
    const ROTATION$1 = 0x10;
    const SKEW = 0x20;
    const REPLACING = 0x40;
    const GROUPING = 0x80;
    const UNGROUPING = 0x100;
    const FILL$1 = 0x200;
    const STROKE$1 = 0x400;
    const STROKE_SIDE = 0x800;
    const BORDER_RADIUS = 0x1000;
    const TEXT$2 = 0x2000;
    const TEXTURE = 0x4000;
    const DATA = 0x8000;
    const ACTION = 0x10000;
    const CURSOR$1 = 0x20000;
    const ORDER_IN_LAYER = 0x40000;
    const CHILDREN$1 = 0x80000;
    const DATA_MAPPING = 0x100000;
    const LINE = 0x200000;
    const LINE_TAIL = 0x400000;
    const LINE_HEAD = 0x800000;
    const COORDINATE = POSITION | WIDTH$1 | HEIGHT$1 | ROTATION$1 | SKEW;
    const SHAPE = REPLACING | GROUPING | FILL$1 | STROKE$1 | LINE | LINE_TAIL | LINE_HEAD;
    const LAYER = ORDER_IN_LAYER;
    const PRIMITIVE = ID | COORDINATE | SHAPE | TEXT$2 | TEXTURE | DATA | ACTION | CURSOR$1 | LAYER | CHILDREN$1;
    const GROUP = PRIMITIVE | UNGROUPING;
    const EMBEDDED = ID | COORDINATE | REPLACING | GROUPING | TEXT$2 | DATA | ACTION | LAYER | DATA_MAPPING;
    const EMBEDDED_ACCEPTOR_EDGE = ID | COORDINATE | REPLACING | FILL$1 | STROKE$1 | TEXT$2 | TEXTURE | DATA | ACTION | CURSOR$1 | LAYER;
    const CONNECTOR = ID | SHAPE | TEXT$2 | TEXTURE | DATA | ACTION | CURSOR$1 | LAYER | CHILDREN$1;
    const ALL = PRIMITIVE | STROKE_SIDE | BORDER_RADIUS | DATA_MAPPING | UNGROUPING;
    const EShapeCapability = {
        NONE,
        /**
         * Allows shape IDs to be modified.
         */
        ID,
        /**
         * Allows shape positions to be modified.
         */
        POSITION,
        /**
         * Allows shape widths to be modified.
         */
        WIDTH: WIDTH$1,
        /**
         * Allows shape heights to be modified.
         */
        HEIGHT: HEIGHT$1,
        /**
         * Allows shape rotations to be modified.
         */
        ROTATION: ROTATION$1,
        /**
         * Allows shape skews to be modified.
         */
        SKEW,
        /** @deprecated */
        ALIGN: NONE,
        /**
         * Allows shapes to be replaced with other shapes.
         */
        REPLACING,
        /**
         * Allows shapes to be grouped.
         */
        GROUPING,
        /**
         * Allows grouped shapes to be ungrouped.
         */
        UNGROUPING,
        /**
         * Allows shape fills to be modified.
         */
        FILL: FILL$1,
        /**
         * Allows shape strokes to be modified.
         */
        STROKE: STROKE$1,
        /**
         * Allows shape stroke sides to be modified.
         */
        STROKE_SIDE,
        /**
         * Allows shape border radiuses to be modified.
         */
        BORDER_RADIUS,
        /**
         * Allows shape texts to be modified.
         */
        TEXT: TEXT$2,
        /**
         * Allows shape textures to be modified.
         */
        TEXTURE,
        /** @deprecated in favor of {@link DATA} */
        TAG: DATA,
        /**
         * Allows shape data to be modified.
         */
        DATA,
        /**
         * Allows shape data mapping to be modified.
         */
        DATA_MAPPING,
        /**
         * Allows shape actions to be modified.
         */
        ACTION,
        /**
         * Allows shape cursors to be modified.
         */
        CURSOR: CURSOR$1,
        /**
         * Allows shape orders in layer to be modified.
         */
        ORDER_IN_LAYER,
        /**
         * Allows shape children to be modified.
         */
        CHILDREN: CHILDREN$1,
        /**
         * Allows shape line to be modified.
         */
        LINE,
        /**
         * Allows shape line tail to be modified.
         */
        LINE_TAIL,
        /**
         * Allows shape line head to be modified.
         */
        LINE_HEAD,
        COORDINATE,
        SHAPE,
        LAYER,
        PRIMITIVE,
        GROUP,
        EMBEDDED,
        EMBEDDED_ACCEPTOR_EDGE,
        CONNECTOR,
        ALL
    };

    class EShapeCapabilityContainerImpl {
        constructor() {
            this.added = EShapeCapability.NONE;
            this.removed = EShapeCapability.NONE;
            this.locked = EShapeCapability.NONE;
        }
        add(target) {
            this.removed &= ~target;
            this.added |= target;
            return this;
        }
        remove(target) {
            this.added &= ~target;
            this.removed |= target;
            return this;
        }
        lock(target) {
            this.locked |= target;
            return this;
        }
        unlock(target) {
            this.locked &= ~target;
            return this;
        }
        clear() {
            this.added = EShapeCapability.NONE;
            this.removed = EShapeCapability.NONE;
            this.locked = EShapeCapability.NONE;
            return this;
        }
        set(added, removed, locked) {
            if (added != null) {
                this.added = added;
            }
            if (removed != null) {
                this.removed = removed;
            }
            if (locked != null) {
                this.locked = locked;
            }
            return this;
        }
        copy(target) {
            this.added = target.added;
            this.removed = target.removed;
            this.locked = target.locked;
            return this;
        }
    }

    class EShapeLock {
        constructor() {
            this._count = 0;
            this._flag = 0;
        }
        lock() {
            this._count += 1;
            if (this._count === 1) {
                this._flag = 0;
                return true;
            }
            return false;
        }
        unlock() {
            this._count -= 1;
            return this._count <= 0 && this._flag !== 0;
        }
        isLocked(high) {
            if (0 < this._count) {
                this._flag |= high ? 3 : 1;
                return true;
            }
            return false;
        }
        isHigh() {
            return 1 < this._flag;
        }
    }

    const EShapeLockPart = {
        TRANSFORM_CHILD: 1,
        TRANSFORM_THIS: 2,
        TRANSFORM_PARENT: 4,
        TRANSFORM: 7,
        UPLOADED: 8,
        TRANSFORM_AND_UPLOADED: 15,
        CONNECTOR: 16,
        ALL: 31
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeBase extends pixi_js.utils.EventEmitter {
        constructor(type) {
            super();
            this.id = "";
            this.uuid = 0;
            this.type = type;
            this.transform = this.newTransform();
            this.action = new EShapeAction();
            this._visible = true;
            this._lockTransformChild = new EShapeLock();
            this._lockTransformThis = new EShapeLock();
            this._lockTransformParent = new EShapeLock();
            this._lockUploaded = new EShapeLock();
            this._boundsTransformId = -1;
            this._boundsInternalTransformId = -1;
            this._boundsLocalTransformId = -1;
            this.interactive = false;
            //
            this.parent = null;
            this.children = [];
            //
            this.selected = false;
            this.index = 0;
            this.reference = 0;
        }
        newTransform() {
            return new EShapeTransformImpl(this);
        }
        onSizeChange() {
            this._boundsTransformId = -1;
            this._boundsInternalTransformId = -1;
            this._boundsLocalTransformId = -1;
            if (!this._lockTransformChild.isLocked()) {
                this.callChildTransformChange();
            }
            const points = this._points;
            if (points != null) {
                points.onSizeChange();
            }
            this.updateUploaded();
            const connector = this._connector;
            if (connector != null) {
                connector.fit(true);
            }
            const runtime = this.runtime;
            if (runtime != null) {
                runtime.onResize(this);
            }
        }
        onTransformChange() {
            if (!this._lockTransformChild.isLocked()) {
                this.callChildTransformChange();
            }
            if (!this._lockTransformThis.isLocked()) {
                this.onThisTransformChange();
            }
            if (!this._lockTransformParent.isLocked()) {
                this.callParentTransformChange();
            }
        }
        callChildTransformChange() {
            const parent = this.parent;
            if (parent != null) {
                parent.onChildTransformChange();
            }
        }
        onThisTransformChange() {
            this.updateUploaded();
            const connector = this._connector;
            if (connector != null) {
                connector.fit(true);
            }
        }
        callParentTransformChange() {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].onParentTransformChange();
            }
        }
        onParentTransformChange() {
            if (!this._lockTransformThis.isLocked()) {
                this.onThisTransformChange();
            }
            if (!this._lockTransformParent.isLocked()) {
                this.callParentTransformChange();
            }
        }
        lock(part) {
            if (part & EShapeLockPart.UPLOADED) {
                this._lockUploaded.lock();
            }
            if (part & EShapeLockPart.TRANSFORM_PARENT) {
                this._lockTransformParent.lock();
            }
            if (part & EShapeLockPart.TRANSFORM_THIS) {
                this._lockTransformThis.lock();
            }
            if (part & EShapeLockPart.TRANSFORM_CHILD) {
                this._lockTransformChild.lock();
            }
            return this;
        }
        unlock(part, invoke) {
            if (part & EShapeLockPart.TRANSFORM_CHILD) {
                if (this._lockTransformChild.unlock() && invoke) {
                    const parent = this.parent;
                    if (parent != null) {
                        parent.onChildTransformChange();
                    }
                }
            }
            if (part & EShapeLockPart.TRANSFORM_THIS) {
                if (this._lockTransformThis.unlock() && invoke) {
                    this.onThisTransformChange();
                }
            }
            if (part & EShapeLockPart.TRANSFORM_PARENT) {
                if (this._lockTransformParent.unlock() && invoke) {
                    const children = this.children;
                    for (let i = 0, imax = children.length; i < imax; ++i) {
                        children[i].onParentTransformChange();
                    }
                }
            }
            if (part & EShapeLockPart.UPLOADED) {
                const lockUploaded = this._lockUploaded;
                if (lockUploaded.unlock() && invoke) {
                    this.updateUploaded(lockUploaded.isHigh());
                }
            }
            return this;
        }
        onChildTransformChange() {
            //
        }
        updateUploaded(recursively) {
            if (this._lockUploaded.isLocked(recursively)) {
                return;
            }
            const uploaded = this.uploaded;
            if (uploaded != null) {
                uploaded.update(this);
            }
            if (recursively === true) {
                const children = this.children;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    children[i].updateUploaded(true);
                }
            }
        }
        get points() {
            return this._points;
        }
        get root() {
            let root = this;
            while (root.parent instanceof EShapeBase) {
                root = root.parent;
            }
            return root;
        }
        get connector() {
            let result = this._connector;
            if (result == null) {
                result = new EShapeConnectorContainerImpl(this);
                this._connector = result;
            }
            return result;
        }
        get visible() {
            if (this._visible) {
                const parent = this.parent;
                if (parent instanceof EShapeBase) {
                    return parent.visible;
                }
                return true;
            }
            return false;
        }
        set visible(visible) {
            if (this._visible !== visible) {
                this._visible = visible;
                this.updateUploaded(true);
            }
        }
        get worldVisible() {
            if (this._visible) {
                const parent = this.parent;
                if (parent) {
                    return parent.worldVisible;
                }
                return true;
            }
            return false;
        }
        //
        toDirty() {
            const parent = this.parent;
            if (parent != null) {
                parent.toDirty();
            }
        }
        // Hierarchy
        attach(parent, at) {
            this.detach();
            this.parent = parent;
            const children = parent.children;
            if (at != null && 0 <= at && at < children.length) {
                children.splice(at, 0, this);
            }
            else {
                children.push(this);
            }
            parent.onChildTransformChange();
            parent.toDirty();
            this.onAttach();
            return this;
        }
        onAttach() {
            this.uploaded = undefined;
            const connector = this._connector;
            if (connector) {
                connector.attach();
                connector.fit(true);
            }
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].onAttach();
            }
        }
        detach(exceptions) {
            const parent = this.parent;
            if (parent) {
                this.parent = null;
                const children = parent.children;
                const index = children.indexOf(this);
                if (0 <= index) {
                    children.splice(index, 1);
                    parent.onChildTransformChange();
                    parent.toDirty();
                    this.onDetach(exceptions);
                }
            }
            return this;
        }
        onDetach(exceptions) {
            this.uploaded = undefined;
            const connector = this._connector;
            if (connector) {
                connector.detach(exceptions);
            }
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].onDetach(exceptions);
            }
        }
        // Transform
        updateTransform() {
            const parent = this.parent;
            if (parent) {
                if (parent.parent) {
                    parent.updateTransform();
                }
                this.transform.updateTransform(parent.transform);
            }
            else {
                this.transform.updateTransform(pixi_js.Transform.IDENTITY);
            }
        }
        // Serialization
        serializeChildren(manager) {
            const children = this.children;
            const childrenSerialized = [];
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                childrenSerialized.push(child.serialize(manager));
            }
            return childrenSerialized;
        }
        serializeState(manager) {
            const state = this.state;
            return (this.interactive ? 1 : 0) | (state.isFocusable ? 0 : 2) | (state.isActive ? 4 : 0);
        }
        serialize(manager) {
            const transform = this.transform;
            const position = transform.position;
            const pivot = transform.pivot;
            const size = this.size;
            const shortcut = this.shortcut;
            const shortcutId = shortcut != null ? manager.addResource(shortcut) : -1;
            const cursor = this.cursor;
            const cursorId = cursor != null ? manager.addResource(cursor) : -1;
            const title = this.title;
            const titleId = title != null ? manager.addResource(title) : -1;
            let capabilitiesAdded = EShapeCapability.NONE;
            let capabilitiesRemoved = EShapeCapability.NONE;
            let capabilitiesLocked = EShapeCapability.NONE;
            const capability = this._capability;
            if (capability != null) {
                capabilitiesAdded = capability.added;
                capabilitiesRemoved = capability.removed;
                capabilitiesLocked = capability.locked;
            }
            return [
                this.type,
                manager.addResource(this.id),
                position.x,
                position.y,
                size.x,
                size.y,
                transform.rotation,
                transform.skew.x,
                this.fill.serialize(manager),
                this.stroke.serialize(manager),
                cursorId,
                this.text.serialize(manager),
                this.data.serialize(manager),
                this.radius,
                this.corner,
                -1,
                -1,
                this.action.serialize(manager),
                this.serializeImage(manager),
                this.serializeGradient(manager),
                this.serializeChildren(manager),
                pivot.x,
                pivot.y,
                this.serializeState(manager),
                shortcutId,
                titleId,
                this.uuid,
                capabilitiesAdded,
                capabilitiesRemoved,
                capabilitiesLocked
            ];
        }
        addUuid(manager) {
            this.uuid = manager.addUuid(this.uuid);
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
        }
        updateUuid(manager) {
            this.uuid = manager.updateUuid(this.uuid);
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
        }
        // Hit test
        getShapeScale() {
            const container = this.root.parent;
            if (container != null && container.getShapeScale != null) {
                return container.getShapeScale();
            }
            return 1.0;
        }
        getStrokeWidthScale(style) {
            if (style & EShapeStrokeStyle.NON_EXPANDING_WIDTH) {
                if (style & EShapeStrokeStyle.NON_SHRINKING_WIDTH) {
                    return this.getShapeScale();
                }
                else {
                    return Math.min(1.0, this.getShapeScale());
                }
            }
            else {
                if (style & EShapeStrokeStyle.NON_SHRINKING_WIDTH) {
                    return Math.max(1.0, this.getShapeScale());
                }
                else {
                    return 1.0;
                }
            }
        }
        getHitTestSize(result) {
            const size = this.size;
            result.width = 0.5 * size.x;
            result.height = 0.5 * size.y;
            return result;
        }
        toHitTestData(x, y) {
            var _a;
            const result = this.getHitTestSize(((_a = EShapeBase.WORK_HIT_TEST_DATA) !== null && _a !== void 0 ? _a : (EShapeBase.WORK_HIT_TEST_DATA = new EShapeBaseHitTestData())));
            const sx = result.width;
            const sy = result.height;
            const pivot = this.transform.pivot;
            const dx = x - pivot.x;
            const dy = y - pivot.y;
            const stroke = this.stroke;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeScale = this.getStrokeWidthScale(stroke.style);
            const strokeAlign = stroke.align;
            const s = strokeWidth * strokeScale * strokeAlign;
            return result.set(0 <= sx ? +dx : -dx, 0 <= sy ? +dy : -dy, Math.abs(sx) + s, Math.abs(sy) + s, strokeWidth, strokeScale, strokeAlign);
        }
        contains(x, y) {
            const data = this.toHitTestData(x, y);
            if (this.containsAbs(data.x, data.y, data.width, data.height, data.strokeWidth, data.strokeScale, data.strokeAlign)) {
                return this;
            }
            return this.containsText(x, y) || this.containsChildren(x, y);
        }
        containsText(x, y) {
            const text = this.text;
            const textAtlas = text.atlas;
            if (textAtlas != null) {
                const textWorld = text.world;
                if (textWorld != null) {
                    const transform = this.transform.internalTransform;
                    const tx = transform.a * x + transform.c * y + transform.tx - textWorld[0];
                    const ty = transform.b * x + transform.d * y + transform.ty - textWorld[1];
                    const th = textWorld[2] * tx + textWorld[3] * ty;
                    const tv = textWorld[4] * tx + textWorld[5] * ty;
                    const w = textWorld[6];
                    const h = textWorld[7];
                    if (0 <= th && th <= w && 0 <= tv && tv <= h) {
                        return this;
                    }
                }
            }
            return null;
        }
        containsChildren(x, y) {
            const children = this.children;
            for (let i = children.length - 1; 0 <= i; --i) {
                const child = children[i];
                child.updateTransform();
                const localTransform = child.transform.localTransform;
                const a = localTransform.a;
                const b = localTransform.b;
                const c = localTransform.c;
                const d = localTransform.d;
                const tx = localTransform.tx;
                const ty = localTransform.ty;
                const id = 1 / (a * d - c * b);
                const lx = (d * x - c * y + ty * c - tx * d) * id;
                const ly = (a * y - b * x - ty * a + tx * b) * id;
                const childResult = child.contains(lx, ly);
                if (childResult != null) {
                    return childResult;
                }
            }
            return null;
        }
        containsBBox(x, y) {
            const data = this.toHitTestData(x, y);
            return this.containsAbsBBox(data.x, data.y, data.width, data.height);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            return this.containsAbsBBox(x, y, ax, ay);
        }
        containsAbsBBox(x, y, ax, ay) {
            return hitTestBBox(x, y, ax, ay);
        }
        select(point) {
            return false;
        }
        //
        toGlobal(position, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            result.copyFrom(position);
            this.transform.worldTransform.apply(result, result);
            return result;
        }
        toLocal(position, from, result, skipUpdate) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            if (result === undefined) {
                result = new pixi_js.Point();
            }
            result.copyFrom(position);
            this.transform.worldTransform.applyInverse(result, result);
            return result;
        }
        getBounds(skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            const bounds = this._bounds || new pixi_js.Rectangle();
            this._bounds = bounds;
            const worldId = this.transform.getWorldId();
            if (worldId !== this._boundsTransformId) {
                this._boundsTransformId = worldId;
                this.getBounds_(this.transform.worldTransform, bounds);
            }
            result !== null && result !== void 0 ? result : (result = new pixi_js.Rectangle());
            result.copyFrom(bounds);
            return result;
        }
        getBoundsInternal(skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            const boundsInternal = this._boundsInternal || new pixi_js.Rectangle();
            this._boundsInternal = boundsInternal;
            const currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsInternalTransformId) {
                this._boundsInternalTransformId = currentLocalId;
                this.getBounds_(this.transform.internalTransform, boundsInternal);
            }
            result !== null && result !== void 0 ? result : (result = new pixi_js.Rectangle());
            result.copyFrom(boundsInternal);
            return result;
        }
        getBoundsLocal(skipUpdate, result) {
            if (skipUpdate !== true) {
                this.updateTransform();
            }
            const boundsLocal = this._boundsLocal || new pixi_js.Rectangle();
            this._boundsLocal = boundsLocal;
            const currentLocalId = this.transform.getLocalIdCurrent();
            if (currentLocalId !== this._boundsLocalTransformId) {
                this._boundsLocalTransformId = currentLocalId;
                this.getBounds_(this.transform.localTransform, boundsLocal);
            }
            result !== null && result !== void 0 ? result : (result = new pixi_js.Rectangle());
            result.copyFrom(boundsLocal);
            return result;
        }
        getBoundsSize() {
            return this.size;
        }
        getBounds_(transform, result) {
            const pivot = this.transform.pivot;
            const px = pivot.x;
            const py = pivot.y;
            const size = this.getBoundsSize();
            const sx = 0.5 * size.x;
            const sy = 0.5 * size.y;
            const a = transform.a;
            const b = transform.b;
            const c = transform.c;
            const d = transform.d;
            let x = -sx + px;
            let y = -sy + py;
            const x0 = a * x + c * y;
            const y0 = b * x + d * y;
            x = +sx + px;
            y = -sy + py;
            const x1 = a * x + c * y;
            const y1 = b * x + d * y;
            x = -sx + px;
            y = +sy + py;
            const x2 = a * x + c * y;
            const y2 = b * x + d * y;
            x = +sx + px;
            y = +sy + py;
            const x3 = a * x + c * y;
            const y3 = b * x + d * y;
            const xmin = Math.min(x0, x1, x2, x3);
            const ymin = Math.min(y0, y1, y2, y3);
            const xmax = Math.max(x0, x1, x2, x3);
            const ymax = Math.max(y0, y1, y2, y3);
            result.x = xmin + transform.tx;
            result.y = ymin + transform.ty;
            result.width = xmax - xmin;
            result.height = ymax - ymin;
            return result;
        }
        //
        destroy() {
            const children = this.children;
            for (let i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
        }
        //
        onStateChange(newState, oldState) {
            const runtime = this.runtime;
            if (runtime != null) {
                runtime.onStateChange(this, newState, oldState);
            }
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child instanceof EShapeBase) {
                    child.state.onParentChange(newState, oldState);
                }
            }
        }
        get state() {
            let result = this._state;
            if (result == null) {
                result = new EShapeStateSetImplObservable((newState, oldState) => {
                    this.onStateChange(newState, oldState);
                });
                this._state = result;
            }
            return result;
        }
        get capability() {
            let result = this._capability;
            if (result == null) {
                result = new EShapeCapabilityContainerImpl();
                this._capability = result;
            }
            return result;
        }
        getCapability() {
            return this._capability;
        }
        focus() {
            this.setFocused(true);
            return this;
        }
        blur() {
            this.setFocused(false);
            return this;
        }
        setFocused(isFocused) {
            if (this.state.isFocused !== isFocused) {
                const layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().set(this, isFocused);
                }
            }
        }
        onKeyDown(e) {
            const runtime = this.runtime;
            if (runtime) {
                return runtime.onKeyDown(this, e);
            }
            return false;
        }
        onKeyUp(e) {
            const runtime = this.runtime;
            if (runtime) {
                return runtime.onKeyUp(this, e);
            }
            return false;
        }
        //
        update(time) {
            const runtime = this.runtime;
            if (runtime) {
                runtime.update(this, time);
            }
        }
        onRender(time, renderer) {
            const runtime = this.runtime;
            if (runtime) {
                runtime.onRender(this, time, renderer);
            }
        }
        copy(source, part = EShapeCopyPart.ALL) {
            this.lock(EShapeLockPart.ALL);
            this.id = source.id;
            this.uuid = source.uuid;
            this.visible = source.visible;
            if (part & EShapeCopyPart.TRANSFORM) {
                const transform = this.transform;
                const sourceTransform = source.transform;
                transform.position.copyFrom(sourceTransform.position);
                transform.rotation = sourceTransform.rotation;
                transform.skew.copyFrom(sourceTransform.skew);
                transform.pivot.copyFrom(sourceTransform.pivot);
                transform.scale.copyFrom(sourceTransform.scale);
            }
            if (part & EShapeCopyPart.SIZE) {
                this.size.copyFrom(source.size);
            }
            if (part & EShapeCopyPart.STYLE) {
                this.fill.copy(source.fill);
                this.stroke.copy(source.stroke);
                this.text.copy(source.text);
                this.radius = source.radius;
                this.corner = source.corner;
            }
            if (part & EShapeCopyPart.DATA) {
                this.data.copy(source.data);
            }
            if (part & EShapeCopyPart.IMAGE) {
                this.image = source.image;
            }
            if (part & EShapeCopyPart.ACTION) {
                this.action.clearAndAddAll(source.action.values);
                this.interactive = source.interactive;
                this.title = source.title;
                this.cursor = source.cursor;
                this.shortcut = source.shortcut;
            }
            if (part & EShapeCopyPart.POINTS) {
                const sourcePoints = source.points;
                if (sourcePoints != null) {
                    const points = this.points;
                    if (points != null) {
                        points.copy(sourcePoints);
                    }
                }
            }
            if (part & EShapeCopyPart.STATE) {
                this.state.lock(false).copy(source.state).unlock();
            }
            if (part & EShapeCopyPart.CONNECTOR) {
                if (source instanceof EShapeBase) {
                    const sourceConnector = source._connector;
                    if (sourceConnector) {
                        this.connector.copy(sourceConnector);
                    }
                    else {
                        const connector = this._connector;
                        if (connector) {
                            connector.clear();
                        }
                    }
                }
                else {
                    const connector = this._connector;
                    if (connector) {
                        connector.clear();
                    }
                }
            }
            if (part & EShapeCopyPart.CAPABILITY) {
                const sourceCapability = source.getCapability();
                if (sourceCapability != null) {
                    this.capability.copy(sourceCapability);
                }
                else {
                    const capability = this._capability;
                    if (capability != null) {
                        capability.clear();
                    }
                }
            }
            this.unlock(EShapeLockPart.ALL, true);
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeStrokeImpl {
        constructor(parent, enable, color, alpha, width, align, side, style) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
            this._align = align;
            this._side = side;
            this._style = style;
        }
        get enable() {
            return this._enable;
        }
        set enable(enable) {
            if (this._enable !== enable) {
                this._enable = enable;
                this._parent.updateUploaded();
            }
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                this._parent.updateUploaded();
            }
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                this._parent.updateUploaded();
            }
        }
        get width() {
            return this._width;
        }
        set width(width) {
            if (this._width !== width) {
                this._width = width;
                this._parent.updateUploaded();
            }
        }
        get align() {
            return this._align;
        }
        set align(align) {
            if (this._align !== align) {
                this._align = align;
                this._parent.updateUploaded();
            }
        }
        get side() {
            return this._side;
        }
        set side(side) {
            if (this._side !== side) {
                this._side = side;
                this._parent.updateUploaded();
            }
        }
        get style() {
            return this._style;
        }
        set style(style) {
            if (this._style !== style) {
                this._style = style;
                this._parent.updateUploaded();
            }
        }
        copy(target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width, target.align, target.side, target.style);
            }
        }
        set(enable, color, alpha, width, align, side, style) {
            let isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (align !== undefined && this._align !== align) {
                this._align = align;
                isChanged = true;
            }
            if (side !== undefined && this._side !== side) {
                this._side = side;
                isChanged = true;
            }
            if (style !== undefined && this._style !== style) {
                this._style = style;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        }
        clone() {
            return new EShapeStrokeImpl(this._parent, this._enable, this._color, this._alpha, this._width, this._align, this._side, this._style);
        }
        toObject() {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width,
                align: this._align,
                side: this._side,
                style: this._style
            };
        }
        serialize(manager) {
            const enable = this._enable ? 1 : 0;
            const serialized = `[${enable},${this._color},${this._alpha},${this._width},${this._align},${this._side},${this._style}]`;
            return manager.addResource(serialized);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                const parsed = manager.getStroke(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2], parsed[3], parsed[4], parsed[5], parsed[6]);
                }
                else {
                    const deserialized = JSON.parse(resources[target]);
                    manager.setStroke(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2], deserialized[3], deserialized[4], deserialized[5], deserialized[6]);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const FROM = 1;
    const TO = 2;
    const EShapeDataValueRangeType = {
        NONE: 0,
        FROM,
        TO,
        FROM_TO: FROM | TO
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeDataValueRangeImpl {
        constructor() {
            this._type = EShapeDataValueRangeType.NONE;
            this._from = 0;
            this._to = 1;
        }
        get type() {
            return this._type;
        }
        set type(type) {
            if (this._type !== type) {
                this._type = type;
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
        }
        get from() {
            return this._from;
        }
        set from(from) {
            if (this._from !== from) {
                this._from = from;
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
        }
        get to() {
            return this._to;
        }
        set to(to) {
            if (this._to !== to) {
                this._to = to;
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
        }
        set(from, to) {
            let result = false;
            if (from !== undefined && to !== undefined) {
                if (from !== null && to !== null) {
                    const type = this._type | EShapeDataValueRangeType.FROM | EShapeDataValueRangeType.TO;
                    if (this._type !== type || this._from !== from || this._to !== to) {
                        this._type = type;
                        this._from = from;
                        this._to = to;
                        result = true;
                    }
                }
                else if (from !== null) {
                    const type = (this._type | EShapeDataValueRangeType.FROM) & ~EShapeDataValueRangeType.TO;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else if (to !== null) {
                    const type = (this._type | EShapeDataValueRangeType.TO) & ~EShapeDataValueRangeType.FROM;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    const type = this._type & ~(EShapeDataValueRangeType.TO | EShapeDataValueRangeType.FROM);
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (from !== undefined) {
                if (from !== null) {
                    const type = this._type | EShapeDataValueRangeType.FROM;
                    if (this._type !== type || this._from !== from) {
                        this._type = type;
                        this._from = from;
                        result = true;
                    }
                }
                else {
                    const type = this._type & ~EShapeDataValueRangeType.FROM;
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            else if (to !== undefined) {
                if (to !== null) {
                    const type = this._type | EShapeDataValueRangeType.TO;
                    if (this._type !== type || this._to !== to) {
                        this._type = type;
                        this._to = to;
                        result = true;
                    }
                }
                else {
                    const type = this._type & ~EShapeDataValueRangeType.TO;
                    if (this._type !== type) {
                        this._type = type;
                        result = true;
                    }
                }
            }
            if (result) {
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
            return result;
        }
        normalize(value) {
            const type = this._type;
            const from = this._from;
            const to = this._to;
            switch (type) {
                case EShapeDataValueRangeType.FROM_TO:
                    return (value - from) / (to - from);
                case EShapeDataValueRangeType.FROM:
                    return value - from;
                case EShapeDataValueRangeType.TO:
                    return to - value;
                case EShapeDataValueRangeType.NONE:
                default:
                    return value;
            }
        }
        isEquals(target) {
            return this._type === target.type && this._from === target.from && this._to === target.to;
        }
        copy(target) {
            return this.copy_(target.type, target.from, target.to);
        }
        copy_(type, from, to) {
            let isChanged = false;
            if (this._type !== type) {
                this._type = type;
                isChanged = true;
            }
            if (this._from !== from) {
                this._from = from;
                isChanged = true;
            }
            if (this._to !== to) {
                this._to = to;
                isChanged = true;
            }
            if (isChanged) {
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
            return this;
        }
        toObject() {
            return {
                type: this.type,
                from: this.from,
                to: this.to
            };
        }
        serialize(manager) {
            const serialized = `[${this._type},${this._from},${this._to}]`;
            return manager.addResource(serialized);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                const parsed = manager.getRange(target);
                if (parsed != null) {
                    this.copy_(parsed[0], parsed[1], parsed[2]);
                }
                else {
                    const deserialized = JSON.parse(resources[target]);
                    manager.setRange(target, deserialized);
                    this.copy_(deserialized[0], deserialized[1], deserialized[2]);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeDataValueOrder = {
        ASCENDING: 0,
        DESCENDING: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeDataValueType = {
        BOOLEAN: 7,
        BOOLEAN_ARRAY: 8,
        NUMBER: 0,
        NUMBER_ARRAY: 1,
        STRING: 2,
        STRING_ARRAY: 3,
        OBJECT: 4,
        OBJECT_ARRAY: 5,
        TICKER: 6,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeDataValueScope = {
        /**
         * A private data is accessible only from inside the graphic that this data belongs to.
         * The data is not accessible from anywhere outside the graphic.
         */
        PRIVATE: 0,
        /**
         * A public data is accessible from anywhere outside graphics.
         */
        PUBLIC: 1,
        /**
         * A protected data is accessible only from inside graphics.
         * Unlike the private data, the protected data is also accessible from parent graphics
         * containing the graphic that this data belongs to.
         */
        PROTECTED: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeDataValueState = {
        /**
         * The data status is not known.
         * This is the default state.
         */
        UNKNOWN: -1,
        /**
         * The request succeeded.
         */
        FOUND: 0,
        /**
         * The server can not find the requested data.
         */
        NOT_FOUND: 1,
        /**
         * The settings or something provided by clients are considered incorrect.
         */
        BAD_REQUEST: 2,
        /**
         * The server has encountered unknown errors.
         */
        SERVER_ERROR: 3,
        /**
         * The server is not ready to handle the request.
         */
        SERVICE_UNAVAILABLE: 4,
        /**
         * A client is not allowed to access this data.
         */
        FORBIDDEN: 5,
        /**
         * The server can not find the definition of the requested data.
         */
        NOT_DEFINED: 6
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const INDEX_COMPARATOR = (a, b) => {
        return a - b;
    };
    class EShapeDataValueImpl {
        constructor() {
            this.id = "";
            this.as = "";
            this.type = EShapeDataValueType.NUMBER;
            this.scope = EShapeDataValueScope.PUBLIC;
            this.initial = "";
            this.format = "";
            this.range = new EShapeDataValueRangeImpl();
            this._value = 0;
            this._time = 0;
            this._state = EShapeDataValueState.UNKNOWN;
            this._capacity = 0;
            this._order = EShapeDataValueOrder.ASCENDING;
        }
        get parent() {
            return this._parent;
        }
        set parent(parent) {
            if (this._parent !== parent) {
                this._parent = parent;
                this.range.parent = parent;
            }
        }
        get value() {
            return this._value;
        }
        set value(newValue) {
            const formatter = this.formatter;
            if (formatter != null) {
                newValue = formatter(newValue);
            }
            const capacity = this._capacity;
            if (capacity <= 0) {
                if (this._value !== newValue) {
                    this._value = newValue;
                    const parent = this.parent;
                    if (parent != null) {
                        parent.isChanged = true;
                    }
                }
            }
            else {
                let values = this._values;
                if (values == null) {
                    values = [];
                    this._values = values;
                }
                // Update the value
                this._value = newValue;
                // Update the values
                const order = this._order;
                if (order === EShapeDataValueOrder.ASCENDING) {
                    values.push(newValue);
                }
                else {
                    values.unshift(newValue);
                }
                // Remove the unnecessary values
                const count = values.length - capacity;
                if (0 < count) {
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        for (let i = 0; i < count; ++i) {
                            values.shift();
                        }
                    }
                    else {
                        values.length = capacity;
                    }
                }
                // Tell the parent it's changed
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
        }
        get nvalue() {
            return this.range.normalize(this._value);
        }
        get values() {
            let result = this._values;
            if (result == null) {
                result = [];
                this._values = result;
            }
            return result;
        }
        set values(newValues) {
            const newValuesLength = newValues.length;
            if (0 < newValuesLength) {
                const capacity = this._capacity;
                if (capacity <= 0) {
                    let newValue = newValues[newValuesLength - 1];
                    const formatter = this.formatter;
                    if (formatter != null) {
                        newValue = formatter(newValue);
                    }
                    if (this._value !== newValue) {
                        this._value = newValue;
                        const parent = this.parent;
                        if (parent != null) {
                            parent.isChanged = true;
                        }
                    }
                }
                else {
                    let values = this._values;
                    if (values == null) {
                        values = [];
                        this._values = values;
                    }
                    const order = this._order;
                    const formatter = this.formatter;
                    if (formatter != null) {
                        // Update the value
                        this._value = formatter(newValues[newValuesLength - 1]);
                        // Update the values
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (let i = 0; i < newValuesLength; ++i) {
                                values.push(formatter(newValues[i]));
                            }
                        }
                        else {
                            for (let i = 0; i < newValuesLength; ++i) {
                                values.unshift(formatter(newValues[i]));
                            }
                        }
                    }
                    else {
                        // Update the value
                        this._value = newValues[newValuesLength - 1];
                        // Update the values
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (let i = 0; i < newValuesLength; ++i) {
                                values.push(newValues[i]);
                            }
                        }
                        else {
                            for (let i = 0; i < newValuesLength; ++i) {
                                values.unshift(newValues[i]);
                            }
                        }
                    }
                    // Remove the unnecessary values
                    const count = values.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (let i = 0; i < count; ++i) {
                                values.shift();
                            }
                        }
                        else {
                            values.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    const parent = this.parent;
                    if (parent != null) {
                        parent.isChanged = true;
                    }
                }
            }
        }
        get time() {
            return this._time;
        }
        set time(newTime) {
            const capacity = this._capacity;
            if (capacity <= 0) {
                if (this._time !== newTime) {
                    this._time = newTime;
                    const parent = this.parent;
                    if (parent != null) {
                        parent.isChanged = true;
                    }
                }
            }
            else {
                // Update the times
                let times = this._times;
                if (times == null) {
                    times = [];
                    this._times = times;
                }
                // Update the time
                this._time = newTime;
                // Update the times
                const order = this._order;
                if (order === EShapeDataValueOrder.ASCENDING) {
                    times.push(newTime);
                }
                else {
                    times.unshift(newTime);
                }
                // Remove the unnecessary times
                const count = times.length - capacity;
                if (0 < count) {
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        for (let i = 0; i < count; ++i) {
                            times.shift();
                        }
                    }
                    else {
                        times.length = capacity;
                    }
                }
                // Tell the parent it's changed
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
        }
        get times() {
            let result = this._times;
            if (result == null) {
                result = [];
                this._times = result;
            }
            return result;
        }
        set times(newTimes) {
            const newTimesLength = newTimes.length;
            if (0 < newTimesLength) {
                const capacity = this._capacity;
                if (capacity <= 0) {
                    const newTime = newTimes[newTimesLength - 1];
                    if (this._time !== newTime) {
                        this._time = newTime;
                        const parent = this.parent;
                        if (parent != null) {
                            parent.isChanged = true;
                        }
                    }
                }
                else {
                    // Update the times
                    let times = this._times;
                    if (times == null) {
                        times = [];
                        this._times = times;
                    }
                    // Update the value
                    this._time = newTimes[newTimesLength - 1];
                    //
                    const order = this._order;
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        for (let i = 0; i < newTimesLength; ++i) {
                            times.push(newTimes[i]);
                        }
                    }
                    else {
                        for (let i = 0; i < newTimesLength; ++i) {
                            times.unshift(newTimes[i]);
                        }
                    }
                    //
                    const count = times.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (let i = 0; i < count; ++i) {
                                times.shift();
                            }
                        }
                        else {
                            times.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    const parent = this.parent;
                    if (parent != null) {
                        parent.isChanged = true;
                    }
                }
            }
        }
        get state() {
            return this._state;
        }
        set state(newState) {
            const capacity = this._capacity;
            if (capacity <= 0) {
                if (this._state !== newState) {
                    this._state = newState;
                    const parent = this.parent;
                    if (parent != null) {
                        parent.isChanged = true;
                    }
                }
            }
            else {
                // Update the states
                let states = this._states;
                if (states == null) {
                    states = [];
                    this._states = states;
                }
                // Update the state
                this._state = newState;
                // Update the states
                const order = this._order;
                if (order === EShapeDataValueOrder.ASCENDING) {
                    states.push(newState);
                }
                else {
                    states.unshift(newState);
                }
                // Remove the unnecessary states
                const count = states.length - capacity;
                if (0 < count) {
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        for (let i = 0; i < count; ++i) {
                            states.shift();
                        }
                    }
                    else {
                        states.length = capacity;
                    }
                }
                // Tell the parent it's changed
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
        }
        get states() {
            let result = this._states;
            if (result == null) {
                result = [];
                this._states = result;
            }
            return result;
        }
        set states(newStates) {
            const newStatesLength = newStates.length;
            if (0 < newStatesLength) {
                const capacity = this._capacity;
                if (capacity <= 0) {
                    const newState = newStates[newStatesLength - 1];
                    if (this._state !== newState) {
                        this._state = newState;
                        const parent = this.parent;
                        if (parent != null) {
                            parent.isChanged = true;
                        }
                    }
                }
                else {
                    // Update the states
                    let states = this._states;
                    if (states == null) {
                        states = [];
                        this._states = states;
                    }
                    // Update the value
                    this._state = newStates[newStatesLength - 1];
                    //
                    const order = this._order;
                    if (order === EShapeDataValueOrder.ASCENDING) {
                        for (let i = 0; i < newStatesLength; ++i) {
                            states.push(newStates[i]);
                        }
                    }
                    else {
                        for (let i = 0; i < newStatesLength; ++i) {
                            states.unshift(newStates[i]);
                        }
                    }
                    //
                    const count = states.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (let i = 0; i < count; ++i) {
                                states.shift();
                            }
                        }
                        else {
                            states.length = capacity;
                        }
                    }
                    // Tell the parent it's changed
                    const parent = this.parent;
                    if (parent != null) {
                        parent.isChanged = true;
                    }
                }
            }
        }
        get capacity() {
            return this._capacity;
        }
        set capacity(capacity) {
            if (this._capacity < capacity) {
                this._capacity = capacity;
            }
            else if (capacity < this._capacity) {
                this._capacity = capacity;
                let isChanged = false;
                // Values
                const order = this._order;
                const values = this._values;
                if (values != null) {
                    const count = values.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (let i = 0; i < count; ++i) {
                                values.shift();
                            }
                        }
                        else {
                            values.length = capacity;
                        }
                        isChanged = true;
                    }
                }
                // Times
                const times = this._times;
                if (times != null) {
                    const count = times.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (let i = 0; i < count; ++i) {
                                times.shift();
                            }
                        }
                        else {
                            times.length = capacity;
                        }
                        isChanged = true;
                    }
                }
                // States
                const states = this._states;
                if (states != null) {
                    const count = states.length - capacity;
                    if (0 < count) {
                        if (order === EShapeDataValueOrder.ASCENDING) {
                            for (let i = 0; i < count; ++i) {
                                states.shift();
                            }
                        }
                        else {
                            states.length = capacity;
                        }
                        isChanged = true;
                    }
                }
                if (isChanged) {
                    const parent = this.parent;
                    if (parent != null) {
                        parent.isChanged = true;
                    }
                }
            }
        }
        get order() {
            return this._order;
        }
        set order(order) {
            this._order = order;
        }
        remove(index) {
            let isChanged = false;
            // Values
            const values = this._values;
            if (values != null) {
                if (0 <= index && index < values.length) {
                    values.splice(index, 1);
                    isChanged = true;
                }
            }
            // Times
            const times = this._times;
            if (times != null) {
                if (0 <= index && index < times.length) {
                    times.splice(index, 1);
                    isChanged = true;
                }
            }
            // States
            const states = this._states;
            if (states != null) {
                if (0 <= index && index < states.length) {
                    states.splice(index, 1);
                    isChanged = true;
                }
            }
            if (isChanged) {
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
        }
        removeAll(indices) {
            let isChanged = false;
            const sorted = indices.slice(0).sort(INDEX_COMPARATOR);
            const sortedLength = sorted.length;
            // Values
            const values = this._values;
            if (values != null) {
                for (let i = sortedLength - 1; 0 <= i; --i) {
                    const index = sorted[i];
                    if (0 <= index && index < values.length) {
                        values.splice(index, 1);
                        isChanged = true;
                    }
                }
            }
            // Times
            const times = this._times;
            if (times != null) {
                for (let i = sortedLength - 1; 0 <= i; --i) {
                    const index = sorted[i];
                    if (0 <= index && index < times.length) {
                        times.splice(index, 1);
                        isChanged = true;
                    }
                }
            }
            // States
            const states = this._states;
            if (states != null) {
                for (let i = sortedLength - 1; 0 <= i; --i) {
                    const index = sorted[i];
                    if (0 <= index && index < states.length) {
                        states.splice(index, 1);
                        isChanged = true;
                    }
                }
            }
            if (isChanged) {
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
        }
        clear() {
            let isChanged = false;
            // Values
            const values = this._values;
            if (values != null) {
                values.length = 0;
                isChanged = true;
            }
            // Times
            const times = this._times;
            if (times != null) {
                times.length = 0;
                isChanged = true;
            }
            // States
            const states = this._states;
            if (states != null) {
                states.length = 0;
                isChanged = true;
            }
            // Change flag
            if (isChanged) {
                const parent = this.parent;
                if (parent != null) {
                    parent.isChanged = true;
                }
            }
        }
        toDirty() {
            const parent = this.parent;
            if (parent != null) {
                parent.isChanged = true;
            }
        }
        /**
         * This method does not copy the `#values` and `#times` for the performance.
         *
         * @param target a copy target
         */
        copy(target) {
            this.id = target.id;
            this.as = target.as;
            this.type = target.type;
            this.scope = target.scope;
            this.initial = target.initial;
            this.format = target.format;
            this.formatter = target.formatter;
            this.range.copy(target.range);
            this._value = target.value;
            this._time = target.time;
            this._state = target.state;
            this._capacity = target.capacity;
            return this;
        }
        isEquals(target) {
            return (this.id === target.id &&
                this.as === target.as &&
                this.type === target.type &&
                this.scope === target.scope &&
                this.initial === target.initial &&
                this.formatter === target.formatter &&
                this.range.isEquals(target.range));
        }
        serialize(manager) {
            const id = manager.addData(this.id);
            const as = manager.addResource(this.as);
            const initial = manager.addResource(this.initial);
            const format = manager.addResource(this.format.trim());
            const range = this.range.serialize(manager);
            return manager.addResource(`[${id},${initial},${format},${range},${this._capacity},${this._order},${this.type},${this.scope},${as}]`);
        }
        deserialize(target, manager) {
            var _a, _b;
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getDataValue(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setDataValue(target, parsed);
                }
                this.id = manager.data[parsed[0]] || "";
                const as = parsed[8];
                this.as = as != null ? resources[as] || "" : "";
                this.type = (_a = parsed[6]) !== null && _a !== void 0 ? _a : EShapeDataValueType.NUMBER;
                this.scope = (_b = parsed[7]) !== null && _b !== void 0 ? _b : EShapeDataValueScope.PUBLIC;
                this.initial = resources[parsed[1]] || "";
                this.format = resources[parsed[2]] || "";
                this.range.deserialize(parsed[3], manager);
                this._capacity = parsed[4];
                this._order = parsed[5];
            }
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeDataMappingImpl {
        constructor() {
            this.values = [];
        }
        add(value, index) {
            const values = this.values;
            if (index != null) {
                values.splice(index, 0, value);
            }
            else {
                values.push(value);
            }
            return this;
        }
        addAll(values) {
            const destination = this.values;
            for (let i = 0, imax = values.length; i < imax; ++i) {
                destination.push(values[i]);
            }
            return this;
        }
        clearAndAdd(value) {
            this.clear();
            this.add(value);
            return this;
        }
        clearAndAddAll(values) {
            this.clear();
            this.addAll(values);
            return this;
        }
        indexOf(target) {
            const values = this.values;
            // Instance-based matching
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                if (value[0] === target[0] && value[1] === target[1] && value[2] === target[2]) {
                    return i;
                }
            }
            return -1;
        }
        get(index) {
            const values = this.values;
            if (0 <= index || index < values.length) {
                return values[index];
            }
            return null;
        }
        set(index, value) {
            const values = this.values;
            if (0 <= index || index < values.length) {
                const result = values[index];
                values[index] = value;
                return result;
            }
            return null;
        }
        remove(index) {
            const values = this.values;
            if (0 <= index || index < values.length) {
                return values.splice(index, 1)[0];
            }
            return null;
        }
        clear() {
            this.values.length = 0;
            return this;
        }
        size() {
            return this.values.length;
        }
        swap(indexA, indexB) {
            const values = this.values;
            const tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
            return this;
        }
        copy(target) {
            this.clearAndAddAll(target.values);
        }
        serialize(manager) {
            const values = this.values;
            const valuesLength = values.length;
            if (valuesLength <= 0) {
                return -1;
            }
            let result = "[";
            let delimiter = "";
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                const s = manager.addResource(value[0]);
                const d = manager.addResource(value[1]);
                const t = manager.addResource(value[2]);
                result += `${delimiter}${s},${d},${t}`;
                delimiter = ",";
            }
            result += "]";
            return manager.addResource(result);
        }
        deserialize(target, manager) {
            const values = this.values;
            values.length = 0;
            const resources = manager.resources;
            const resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                let parsed = manager.getDataMapping(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setDataMapping(target, parsed);
                }
                for (let i = 0, imax = parsed.length; i < imax; i += 3) {
                    const is = parsed[i];
                    const id = parsed[i + 1];
                    const it = parsed[i + 2];
                    values.push([
                        0 <= is && is < resourcesLength ? resources[is] : "",
                        0 <= id && id < resourcesLength ? resources[id] : "",
                        0 <= it && it < resourcesLength ? resources[it] : ""
                    ]);
                }
            }
        }
    }

    class EShapeDataScopedImpl {
        get ids() {
            const data = this._data;
            if (data == null) {
                return [];
            }
            const result = [];
            data.forEach((value, id) => {
                result.push(id);
            });
            return result;
        }
        add(id, value) {
            var _a;
            const data = ((_a = this._data) !== null && _a !== void 0 ? _a : (this._data = new Map()));
            const list = data.get(id);
            if (list == null) {
                data.set(id, [value]);
            }
            else {
                list.push(value);
            }
        }
        set(id, value, time, state, from, to) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                const datumValue = datum[i];
                const range = datumValue.range;
                // Range
                range.set(from, to);
                // Time
                if (time !== undefined) {
                    datumValue.time = time;
                }
                // State
                if (state !== undefined) {
                    datumValue.state = state;
                }
                // Value
                datumValue.value = value;
            }
            return true;
        }
        toDirty(id) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                datum[i].toDirty();
            }
            return true;
        }
        each(iteratee) {
            const data = this._data;
            if (data == null) {
                return null;
            }
            let result = null;
            data.forEach((values, id) => {
                if (result == null) {
                    if (iteratee(id) === false) {
                        result = id;
                    }
                }
            });
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeDataSystemImpl {
        constructor() {
            this._data = new Map();
        }
        set(key, value) {
            this._data.set(key, value);
            return this;
        }
        get(key) {
            var _a;
            return (_a = this._data.get(key)) !== null && _a !== void 0 ? _a : null;
        }
        contains(key) {
            return this._data.has(key);
        }
        remove(key) {
            const data = this._data;
            const result = data.get(key);
            data.delete(key);
            return result !== null && result !== void 0 ? result : null;
        }
        clear() {
            this._data.clear();
            return this;
        }
        size() {
            return this._data.size;
        }
        each(iteratee) {
            let isCanceled = false;
            this._data.forEach((value, key) => {
                if (!isCanceled) {
                    if (iteratee(value, key) === false) {
                        isCanceled = true;
                    }
                }
            });
            return this;
        }
        copy(target) {
            const data = this._data;
            data.clear();
            target.each((value, key) => {
                data.set(key, value);
            });
            return this;
        }
        serialize(manager) {
            const data = this._data;
            if (data.size <= 0) {
                return -1;
            }
            const result = [];
            data.forEach((value, key) => {
                const valueId = manager.addResource(value);
                const keyId = manager.addResource(key);
                result.push(keyId, valueId);
            });
            return manager.addResource(JSON.stringify(result));
        }
        deserialize(target, manager) {
            const data = this._data;
            data.clear();
            const resources = manager.resources;
            const resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                let parsed = manager.getDataSystem(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setDataSystem(target, parsed);
                }
                for (let i = 0, imax = parsed.length; i < imax; i += 2) {
                    const keyId = parsed[i];
                    if (0 <= keyId && keyId < resourcesLength) {
                        const key = resources[keyId];
                        const valueId = parsed[i + 1];
                        if (0 <= valueId && valueId < resourcesLength) {
                            data.set(key, resources[valueId]);
                        }
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    let RANGE_DUMMY;
    let ALIAS_DUMMY;
    class EShapeDataImpl {
        constructor() {
            this._values = [];
            this._isChanged = true;
        }
        get values() {
            return this._values;
        }
        get isChanged() {
            return this._isChanged;
        }
        set isChanged(isChanged) {
            this._isChanged = isChanged;
        }
        get id() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].id;
            }
            return "";
        }
        get as() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].as;
            }
            return "";
        }
        get type() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].type;
            }
            return EShapeDataValueType.NUMBER;
        }
        get scope() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].scope;
            }
            return EShapeDataValueScope.PRIVATE;
        }
        get initial() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].initial;
            }
            return "";
        }
        get format() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].format;
            }
            return "";
        }
        get range() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].range;
            }
            return (RANGE_DUMMY !== null && RANGE_DUMMY !== void 0 ? RANGE_DUMMY : (RANGE_DUMMY = new EShapeDataValueRangeImpl()));
        }
        get value() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].value;
            }
            return 0;
        }
        set value(value) {
            const values = this._values;
            if (0 < values.length) {
                values[0].value = value;
            }
        }
        get nvalue() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].nvalue;
            }
            return 0;
        }
        get time() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].time;
            }
            return 0;
        }
        set time(time) {
            const values = this._values;
            if (0 < values.length) {
                values[0].time = time;
            }
        }
        get state() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].state;
            }
            return EShapeDataValueState.UNKNOWN;
        }
        set state(state) {
            const values = this._values;
            if (0 < values.length) {
                values[0].state = state;
            }
        }
        get capacity() {
            const values = this._values;
            if (0 < values.length) {
                return values[0].capacity;
            }
            return 0;
        }
        set capacity(capacity) {
            const values = this._values;
            if (0 < values.length) {
                values[0].capacity = capacity;
            }
        }
        get alias() {
            let result = this._alias;
            if (result == null) {
                result = this.newAlias();
                this._alias = result;
            }
            return result;
        }
        newAlias() {
            const values = this._values;
            const valuesLength = values.length;
            if (0 < valuesLength) {
                const result = {};
                for (let i = 0; i < valuesLength; ++i) {
                    const value = values[i];
                    result[value.as || value.id] = value;
                }
                return result;
            }
            else {
                return (ALIAS_DUMMY !== null && ALIAS_DUMMY !== void 0 ? ALIAS_DUMMY : (ALIAS_DUMMY = {}));
            }
        }
        get mapping() {
            let result = this._mapping;
            if (result == null) {
                result = this.newMapping();
                this._mapping = result;
            }
            return result;
        }
        newMapping() {
            return new EShapeDataMappingImpl();
        }
        getMapping() {
            return this._mapping;
        }
        get private() {
            let result = this._private;
            if (result == null) {
                result = this.newPrivate();
                this._private = result;
            }
            return result;
        }
        newPrivate() {
            return new EShapeDataScopedImpl();
        }
        getPrivate() {
            return this._private;
        }
        get system() {
            let result = this._system;
            if (result == null) {
                result = this.newSystem();
                this._system = result;
            }
            return result;
        }
        newSystem() {
            return new EShapeDataSystemImpl();
        }
        getSystem() {
            return this._system;
        }
        add(value, index) {
            const values = this._values;
            value.parent = this;
            if (index === undefined) {
                values.push(value);
            }
            else {
                values.splice(index, 0, value);
            }
        }
        set(index, value) {
            const values = this._values;
            if (0 <= index && index < values.length) {
                const result = values[index];
                value.parent = this;
                values[index] = value;
                result.parent = undefined;
                return result;
            }
            return null;
        }
        remove(index) {
            const values = this._values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1)[0].parent = undefined;
            }
        }
        indexOf(target) {
            const values = this._values;
            const valuesLength = values.length;
            // Instance-based matching
            for (let i = 0; i < valuesLength; ++i) {
                if (values[i] === target) {
                    return i;
                }
            }
            // Data-based matching
            for (let i = 0; i < valuesLength; ++i) {
                if (values[i].isEquals(target)) {
                    return i;
                }
            }
            // ID-based matching
            for (let i = 0; i < valuesLength; ++i) {
                if (values[i].id === target.id) {
                    return i;
                }
            }
            return -1;
        }
        get(index) {
            const values = this._values;
            if (0 <= index && index < values.length) {
                return values[index];
            }
            return null;
        }
        size() {
            return this._values.length;
        }
        swap(indexA, indexB) {
            const values = this._values;
            const tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
        }
        copy(target) {
            const values = this._values;
            values.length = 0;
            for (let i = 0, imax = target.size(); i < imax; ++i) {
                const value = target.get(i);
                if (value != null) {
                    const newValue = new EShapeDataValueImpl().copy(value);
                    newValue.parent = this;
                    values.push(newValue);
                }
            }
            const targetMapping = target.getMapping();
            if (targetMapping) {
                this.mapping.copy(targetMapping);
            }
            const targetSystem = target.getSystem();
            if (targetSystem) {
                this.system.copy(targetSystem);
            }
            return this;
        }
        serialize(manager) {
            const values = this._values;
            const result = [];
            for (let i = 0, imax = values.length; i < imax; ++i) {
                result.push(values[i].serialize(manager));
            }
            const mapping = this._mapping;
            if (mapping != null) {
                result.push(mapping.serialize(manager));
                const system = this._system;
                if (system != null) {
                    return manager.addResource(`[${JSON.stringify(result)},${system.serialize(manager)}]`);
                }
                else {
                    return manager.addResource(`[${JSON.stringify(result)}]`);
                }
            }
            else {
                const system = this._system;
                if (system != null) {
                    result.push(-1);
                    return manager.addResource(`[${JSON.stringify(result)},${system.serialize(manager)}]`);
                }
                else {
                    return manager.addResource(JSON.stringify(result));
                }
            }
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getData(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setData(target, parsed);
                }
                const values = this._values;
                values.length = 0;
                if (this.isMapped(parsed)) {
                    const first = parsed[0];
                    const firstLength = first.length;
                    for (let i = 0, imax = firstLength - 1; i < imax; ++i) {
                        const index = first[i];
                        const value = new EShapeDataValueImpl();
                        value.parent = this;
                        value.deserialize(index, manager);
                        values.push(value);
                    }
                    const mappingId = first[firstLength - 1];
                    if (0 <= mappingId) {
                        this.mapping.deserialize(mappingId, manager);
                    }
                    const systemId = parsed[1];
                    if (systemId != null && 0 <= systemId) {
                        this.system.deserialize(systemId, manager);
                    }
                }
                else {
                    for (let i = 0, imax = parsed.length; i < imax; ++i) {
                        const index = parsed[i];
                        const value = new EShapeDataValueImpl();
                        value.parent = this;
                        value.deserialize(index, manager);
                        values.push(value);
                    }
                }
            }
        }
        isMapped(target) {
            return 0 < target.length && isArray(target[0]);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeTextAlignImpl {
        constructor(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        get horizontal() {
            return this._horizontal;
        }
        set horizontal(horizontal) {
            if (this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                this._parent.updateUploaded();
            }
        }
        get vertical() {
            return this._vertical;
        }
        set vertical(vertical) {
            if (this._vertical !== vertical) {
                this._vertical = vertical;
                this._parent.updateUploaded();
            }
        }
        copy(target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        }
        set(horizontal, vertical) {
            let isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        }
        toObject() {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        }
        serialize(manager) {
            return manager.addResource(`[${this._horizontal},${this._vertical}]`);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                const parsed = manager.getAlign(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    const deserialized = JSON.parse(resources[target]);
                    manager.setAlign(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeTextOffsetImpl {
        constructor(parent, horizontal, vertical) {
            this._parent = parent;
            this._horizontal = horizontal;
            this._vertical = vertical;
        }
        get horizontal() {
            return this._horizontal;
        }
        set horizontal(horizontal) {
            if (this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                this._parent.updateUploaded();
            }
        }
        get vertical() {
            return this._vertical;
        }
        set vertical(vertical) {
            if (this._vertical !== vertical) {
                this._vertical = vertical;
                this._parent.updateUploaded();
            }
        }
        copy(target) {
            if (target) {
                this.set(target.horizontal, target.vertical);
            }
        }
        set(horizontal, vertical) {
            let isChanged = false;
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        }
        toObject() {
            return {
                horizontal: this._horizontal,
                vertical: this._vertical
            };
        }
        serialize(manager) {
            return manager.addResource(`[${this._horizontal},${this._vertical}]`);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                const parsed = manager.getMargin(target);
                if (parsed != null) {
                    this.set(parsed[0], parsed[1]);
                }
                else {
                    const deserialized = JSON.parse(resources[target]);
                    manager.setMargin(target, deserialized);
                    this.set(deserialized[0], deserialized[1]);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeTextOutlineImpl {
        constructor(parent, enable, color, alpha, width) {
            this._parent = parent;
            this._enable = enable;
            this._color = color;
            this._alpha = alpha;
            this._width = width;
        }
        get enable() {
            return this._enable;
        }
        set enable(enable) {
            if (this._enable !== enable) {
                this._enable = enable;
                this._parent.updateUploaded();
            }
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                this._parent.updateUploaded();
            }
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                this._parent.updateUploaded();
            }
        }
        get width() {
            return this._width;
        }
        set width(width) {
            if (this._width !== width) {
                this._width = width;
                this._parent.updateUploaded();
            }
        }
        copy(target) {
            if (target) {
                this.set(target.enable, target.color, target.alpha, target.width);
            }
        }
        set(enable, color, alpha, width) {
            let isChanged = false;
            if (enable !== undefined && this._enable !== enable) {
                this._enable = enable;
                isChanged = true;
            }
            if (color !== undefined && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (width !== undefined && this._width !== width) {
                this._width = width;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.updateUploaded();
            }
        }
        clone() {
            return new EShapeTextOutlineImpl(this._parent, this._enable, this._color, this._alpha, this._width);
        }
        toObject() {
            return {
                enable: this._enable,
                color: this._color,
                alpha: this._alpha,
                width: this._width
            };
        }
        serialize(manager) {
            const serialized = `[${this._enable ? 1 : 0},${this._color},${this._alpha},${this._width}]`;
            return manager.addResource(serialized);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                const parsed = manager.getTextOutline(target);
                if (parsed != null) {
                    this.set(!!parsed[0], parsed[1], parsed[2], parsed[3]);
                }
                else {
                    const deserialized = JSON.parse(resources[target]);
                    manager.setTextOutline(target, deserialized);
                    this.set(!!deserialized[0], deserialized[1], deserialized[2], deserialized[3]);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeTextImpl {
        constructor(parent, value, color, alpha, family, size) {
            this._parent = parent;
            this._enable = true;
            this._value = value;
            this._plength = this._length = value.length;
            this._color = color;
            this._alpha = alpha;
            this._family = family;
            this._size = size;
            this._weight = EShapeTextWeight.NORMAL;
            this.align = new EShapeTextAlignImpl(parent, EShapeTextAlignHorizontal.CENTER, EShapeTextAlignVertical.MIDDLE);
            this.offset = new EShapeTextOffsetImpl(parent, 0, 0);
            this._style = EShapeTextStyle.NORMAL;
            this.spacing = new EShapeTextOffsetImpl(parent, 0, 0);
            this.outline = new EShapeTextOutlineImpl(parent, false, 0xffffff, 1.0, 0.5);
            this._direction = EShapeTextDirection.LEFT_TO_RIGHT;
            this.padding = new EShapeTextOffsetImpl(parent, 10, 10);
            this._clipping = false;
            this._fitting = false;
            this._characters = [];
            this._nacharacters = [];
            this.updateCharacters(value);
        }
        get enable() {
            return this._enable;
        }
        set enable(enable) {
            if (this._enable !== enable) {
                this._enable = enable;
                this._parent.updateUploaded();
            }
        }
        get value() {
            return this._value;
        }
        set value(value) {
            if (this._value !== value) {
                this._value = value;
                const length = value.length;
                this._length = length;
                if (this._plength < length) {
                    this._plength = length;
                }
                this.updateCharacters(value);
                if (this.isCompatible()) {
                    this._parent.updateUploaded();
                }
                else {
                    this.atlas = undefined;
                    this._parent.toDirty();
                }
            }
        }
        get characters() {
            return this._characters;
        }
        get nacharacters() {
            return this._nacharacters;
        }
        updateCharacters(value) {
            const characters = this._characters;
            const charactersLength = characters.length;
            let icharacters = 0;
            const nacharacters = this._nacharacters;
            const nacharactersLength = nacharacters.length;
            let inacharacters = 0;
            for (let i = 0, imax = value.length; i < imax;) {
                if (value.charCodeAt(i) <= 0xff) {
                    // Add an ASCII character
                    const ac = value.substring(i, i + 1);
                    if (icharacters < charactersLength) {
                        characters[icharacters] = ac;
                    }
                    else {
                        characters.push(ac);
                    }
                    icharacters += 1;
                    i += 1;
                    continue;
                }
                let j = i + 1;
                for (; j < imax; ++j) {
                    const cc = value.charCodeAt(j);
                    if ((0xdc00 <= cc && cc <= 0xdfff) || (0xfe00 <= cc && cc <= 0xfe0f)) {
                        // Low surrogate
                        // Variation selector
                        continue;
                    }
                    break;
                }
                // Add an non-ascii character
                const nac = value.substring(i, j);
                if (icharacters < charactersLength) {
                    characters[icharacters] = nac;
                }
                else {
                    characters.push(nac);
                }
                icharacters += 1;
                if (inacharacters < nacharactersLength) {
                    nacharacters[inacharacters] = nac;
                }
                else {
                    nacharacters.push(nac);
                }
                inacharacters += 1;
                // Go to the next
                i = j;
            }
            if (icharacters < charactersLength) {
                characters.length = icharacters;
            }
            if (inacharacters < nacharactersLength) {
                nacharacters.length = inacharacters;
            }
        }
        isCompatible() {
            // Compatibility check
            const parent = this._parent;
            const uploaded = parent.uploaded;
            if (uploaded == null || !uploaded.isCompatible(parent)) {
                return false;
            }
            // Character code check
            const atlas = this.atlas;
            if (atlas == null) {
                return false;
            }
            const atlasCharacters = atlas.characters;
            const nacharacters = this._nacharacters;
            for (let i = 0, imax = nacharacters.length; i < imax; ++i) {
                if (!atlasCharacters.has(nacharacters[i])) {
                    return false;
                }
            }
            // Done
            return true;
        }
        get length() {
            return this._length;
        }
        get plength() {
            return this._plength;
        }
        get family() {
            return this._family;
        }
        set family(family) {
            if (this._family !== family) {
                this._family = family;
                this._parent.toDirty();
            }
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                this._parent.updateUploaded();
            }
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                this._parent.updateUploaded();
            }
        }
        get size() {
            return this._size;
        }
        set size(size) {
            if (this._size !== size) {
                this._size = size;
                this._parent.updateUploaded();
            }
        }
        get weight() {
            return this._weight;
        }
        set weight(weight) {
            if (this._weight !== weight) {
                this._weight = weight;
                this._parent.updateUploaded();
            }
        }
        get style() {
            return this._style;
        }
        set style(style) {
            if (this._style !== style) {
                this._style = style;
                this._parent.updateUploaded();
            }
        }
        get direction() {
            return this._direction;
        }
        set direction(direction) {
            if (this._direction !== direction) {
                this._direction = direction;
                this._parent.updateUploaded();
            }
        }
        get clipping() {
            return this._clipping;
        }
        set clipping(clipping) {
            if (this._clipping !== clipping) {
                this._clipping = clipping;
                this._parent.updateUploaded();
            }
        }
        get fitting() {
            return this._fitting;
        }
        set fitting(fitting) {
            if (this._fitting !== fitting) {
                this._fitting = fitting;
                this._parent.updateUploaded();
            }
        }
        copy(target) {
            if (target) {
                this.set(target.value, target.color, target.alpha, target.family, target.size, target.weight, target.style, target.direction, target.clipping, target.fitting);
                this.align.copy(target.align);
                this.offset.copy(target.offset);
                this.outline.copy(target.outline);
                this.spacing.copy(target.spacing);
                this.padding.copy(target.padding);
            }
            return this;
        }
        set(value, color, alpha, family, size, weight, style, direction, clipping, fitting) {
            let isChangedDirty = false;
            let isChangedUploaded = false;
            if (value != null && this._value !== value) {
                this._value = value;
                const length = value.length;
                this._length = length;
                if (this._plength < length) {
                    this._plength = length;
                }
                this.updateCharacters(value);
                if (this.isCompatible()) {
                    isChangedUploaded = true;
                }
                else {
                    this.atlas = undefined;
                    isChangedDirty = true;
                }
            }
            if (color != null && this._color !== color) {
                this._color = color;
                isChangedUploaded = true;
            }
            if (alpha != null && this._alpha !== alpha) {
                this._alpha = alpha;
                isChangedUploaded = true;
            }
            if (family != null && this._family !== family) {
                this._family = family;
                isChangedDirty = true;
            }
            if (size != null && this._size !== size) {
                this._size = size;
                isChangedUploaded = true;
            }
            if (weight != null && this._weight !== weight) {
                this._weight = weight;
                isChangedUploaded = true;
            }
            if (style != null && this._style !== style) {
                this._style = style;
                isChangedUploaded = true;
            }
            if (direction != null && this._direction !== direction) {
                this._direction = direction;
                isChangedUploaded = true;
            }
            if (clipping != null && this._clipping !== clipping) {
                this._clipping = clipping;
                isChangedUploaded = true;
            }
            if (fitting != null && this._fitting !== fitting) {
                this._fitting = fitting;
                isChangedUploaded = true;
            }
            if (isChangedDirty) {
                this._parent.toDirty();
            }
            else if (isChangedUploaded) {
                this._parent.updateUploaded();
            }
            return this;
        }
        toObject() {
            return {
                value: this._value,
                color: this._color,
                alpha: this._alpha,
                family: this._family,
                size: this._size,
                weight: this._weight,
                align: this.align.toObject(),
                offset: this.offset.toObject(),
                style: this._style,
                outline: this.outline.toObject(),
                direction: this._direction,
                spacing: this.spacing.toObject(),
                padding: this.padding.toObject(),
                clipping: this._clipping,
                fitting: this._fitting
            };
        }
        serialize(manager) {
            const valueId = manager.addResource(this._value);
            const familyId = manager.addResource(this._family);
            const alignId = this.align.serialize(manager);
            const offsetId = this.offset.serialize(manager);
            const outlineId = this.outline.serialize(manager);
            const spacingId = this.spacing.serialize(manager);
            const paddingId = this.padding.serialize(manager);
            const clipping = this._clipping ? 1 : 0;
            const fitting = this._fitting ? 1 : 0;
            const serialized = `[${valueId},${this._color},${this._alpha},${familyId},${this._size},` +
                `${this._weight},${alignId},${offsetId},${this._style},${outlineId},` +
                `${spacingId},${this._direction},${paddingId},${clipping},${fitting}]`;
            return manager.addResource(serialized);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getText(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setText(target, parsed);
                }
                this.set(resources[parsed[0]] || "", parsed[1], parsed[2], resources[parsed[3]] || "auto", parsed[4], parsed[5], parsed[8], parsed[11], !!parsed[13], !!parsed[14]);
                this.align.deserialize(parsed[6], manager);
                this.offset.deserialize(parsed[7], manager);
                this.outline.deserialize(parsed[9], manager);
                this.spacing.deserialize(parsed[10], manager);
                this.padding.deserialize(parsed[12], manager);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toGradientSerialized = (gradient) => {
        const points = gradient.points;
        let result = `[${gradient.direction}`;
        for (let i = 0, imax = points.length, j = 1; i < imax; i += 1, j += 3) {
            const point = points[i];
            result += `,${point.color},${point.alpha},${point.position}`;
        }
        result += "]";
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapePrimitive extends EShapeBase {
        constructor(type) {
            super(type);
            this.size = this.newSize();
            this.fill = this.newFill();
            this.stroke = this.newStroke();
            this._radius = EShapeDefaults.RADIUS;
            this._corner = EShapeCorner.ALL;
            const data = new EShapeDataImpl();
            this.data = data;
            this.tag = data;
            this.text = this.newText();
        }
        newSize() {
            return new pixi_js.ObservablePoint(() => {
                this.onSizeChange();
            }, undefined, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
        }
        newFill() {
            return new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, EShapeDefaults.FILL_ALPHA);
        }
        newStroke() {
            return new EShapeStrokeImpl(this, true, EShapeDefaults.STROKE_COLOR, EShapeDefaults.STROKE_ALPHA, EShapeDefaults.STROKE_WIDTH, EShapeDefaults.STROKE_ALIGN, EShapeDefaults.STROKE_SIDE, EShapeDefaults.STROKE_STYLE);
        }
        newText() {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.TEXT_COLOR, EShapeDefaults.TEXT_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        }
        get corner() {
            return this._corner;
        }
        set corner(corner) {
            if (this._corner !== corner) {
                this._corner = corner;
                this.updateUploaded();
            }
        }
        get radius() {
            return this._radius;
        }
        set radius(radius) {
            if (this._radius !== radius) {
                this._radius = radius;
                this.updateUploaded();
            }
        }
        get image() {
            return this._image;
        }
        set image(image) {
            if (this._image !== image) {
                if (image != null) {
                    this._image = image;
                }
                else {
                    this._image = undefined;
                }
                const parent = this.parent;
                if (parent != null) {
                    parent.toDirty();
                }
            }
        }
        serializeImage(manager) {
            const image = this._image;
            return image != null ? manager.addResource(image.url) : -1;
        }
        serializeGradient(manager) {
            const gradient = this.gradient;
            if (gradient != null) {
                if (gradient.serialized == null) {
                    gradient.serialized = toGradientSerialized(gradient);
                }
                return manager.addResource(gradient.serialized);
            }
            return -1;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const hitTestCircle = (shape, x, y, ax, ay, sw, ss) => {
        const fill = shape.fill;
        if (fill.enable) {
            const x2 = x * x;
            const y2 = y * y;
            const ax2 = ax * ax;
            const ay2 = ay * ay;
            if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                return true;
            }
        }
        else {
            if (0 < sw) {
                const s = sw * ss;
                const x2 = x * x;
                const y2 = y * y;
                const wx = Math.max(0.0, ax - s);
                const wy = Math.max(0.0, ay - s);
                const wx2 = wx * wx;
                const wy2 = wy * wy;
                if (wx2 * wy2 <= x2 * wy2 + y2 * wx2) {
                    const ax2 = ax * ax;
                    const ay2 = ay * ay;
                    if (x2 * ay2 + y2 * ax2 <= ax2 * ay2) {
                        return true;
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const hitTestRectangle = (shape, x, y, ax, ay, sw, ss) => {
        if (hitTestBBox(x, y, ax, ay)) {
            const fill = shape.fill;
            if (fill.enable) {
                return true;
            }
            else {
                const strokeSide = shape.stroke.side;
                if (0 < sw && strokeSide !== EShapeStrokeSide.NONE) {
                    const s = sw * ss;
                    const wx = Math.max(0.0, ax - s);
                    const wy = Math.max(0.0, ay - s);
                    if (!hitTestBBox(x, y, wx, wy)) {
                        if (strokeSide === EShapeStrokeSide.ALL) {
                            return true;
                        }
                        else {
                            if (x <= -wx) {
                                if (y <= -wy) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP_OR_LEFT);
                                }
                                else if (+wy <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM_OR_LEFT);
                                }
                                else {
                                    return !!(strokeSide & EShapeStrokeSide.LEFT);
                                }
                            }
                            else if (+wx <= x) {
                                if (y <= -wy) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP_OR_RIGHT);
                                }
                                else if (+wy <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM_OR_RIGHT);
                                }
                                else {
                                    return !!(strokeSide & EShapeStrokeSide.RIGHT);
                                }
                            }
                            else {
                                if (y <= -wy) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP);
                                }
                                else if (+wy <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                }
                                else {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const hitTestTriangleFilled = (x, y, a, ay1, ay2) => {
        // a = 2 * ay / ax
        // y = + a * x + ay1
        // y = - a * x + ay1
        // y = ay2;
        return +a * x + ay1 - y <= 0 && -a * x + ay1 - y <= 0 && y <= ay2;
    };
    const hitTestTriangle = (shape, x, y, ax, ay, sw, ss) => {
        const a = (2 * ay) / ax;
        const fill = shape.fill;
        if (fill.enable) {
            if (hitTestTriangleFilled(x, y, a, -ay, +ay)) {
                return true;
            }
        }
        else {
            if (0 < sw) {
                const s = sw * ss;
                if (hitTestTriangleFilled(x, y, a, -ay, +ay)) {
                    const az = Math.sqrt(ax * ax + 4 * ay * ay);
                    const aw = (2 * ax * ay) / (ax + az);
                    const cy = ay - aw;
                    const ay1 = cy + ((-ay - cy) * Math.max(0.0, aw - s)) / aw;
                    const ay2 = ay - s;
                    if (!hitTestTriangleFilled(x, y, a, ay1, ay2)) {
                        return true;
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toThresholdDefault = (size, scale, offset) => {
        return 0.5 * (offset + size * scale);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineBase extends EShapePrimitive {
        getHitTestSize(result) {
            const formatted = this._points.formatted;
            if ("boundary" in formatted) {
                const boundary = formatted.boundary;
                result.width = Math.max(Math.abs(boundary[0]), Math.abs(boundary[2]));
                result.height = Math.max(Math.abs(boundary[1]), Math.abs(boundary[3]));
            }
            else {
                super.getHitTestSize(result);
            }
            return result;
        }
        toMarkerSize(points) {
            let result = 0;
            const marker = points.getMarker();
            if (marker) {
                const head = marker.head;
                if (head.type !== EShapePointsMarkerType.NONE) {
                    const size = head.size;
                    result = Math.max(result, Math.max(Math.abs(size.x), Math.abs(size.y)) * 2);
                }
                const tail = marker.tail;
                if (tail.type !== EShapePointsMarkerType.NONE) {
                    const size = tail.size;
                    result = Math.max(result, Math.max(Math.abs(size.x), Math.abs(size.y)) * 2);
                }
            }
            return result;
        }
        containsAbsMarker(marker, x, y, sw, ss, sa) {
            const type = marker.type;
            if (type !== EShapePointsMarkerType.NONE) {
                const transform = marker.transform;
                const a = transform.a;
                const b = transform.b;
                const c = transform.c;
                const d = transform.d;
                const tx = transform.tx;
                const ty = transform.ty;
                const id = 1 / (a * d - c * b);
                const lx = (d * x - c * y + ty * c - tx * d) * id;
                const ly = (a * y - b * x - ty * a + tx * b) * id;
                const size = marker.size;
                let sx = 0.5 * size.x;
                let sy = 0.5 * size.y;
                if (sx < 0) {
                    sx = -sx;
                    x = -x;
                }
                if (sy < 0) {
                    sy = -sy;
                    y = -y;
                }
                const s = sw * ss * sa;
                sx += s;
                sy += s;
                switch (type) {
                    case EShapePointsMarkerType.CIRCLE:
                        return hitTestCircle(this, lx, ly, sx, sy, sw, ss);
                    case EShapePointsMarkerType.TRIANGLE:
                        return hitTestTriangle(this, lx, ly, sx, sy, sw, ss);
                    case EShapePointsMarkerType.RECTANGLE:
                        return hitTestRectangle(this, lx, ly, sx, sy, sw, ss);
                }
            }
            return false;
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            const points = this._points;
            const threshold = toThresholdDefault(sw, ss, 0);
            const margin = threshold + this.toMarkerSize(points);
            if (this.containsAbsBBox(x, y, ax + margin, ay + margin)) {
                const marker = points.getMarker();
                if (marker) {
                    if (this.containsAbsMarker(marker.head, x, y, sw, ss, sa)) {
                        return true;
                    }
                    if (this.containsAbsMarker(marker.tail, x, y, sw, ss, sa)) {
                        return true;
                    }
                }
                const tester = this.calcHitPointAbsHitTester;
                return points.calcHitPointAbs(x, y, ax, ay, threshold, null, tester, null);
            }
            return false;
        }
        calcHitPart(x, y) {
            const data = this.toHitTestData(x, y);
            const sw = data.strokeWidth;
            const ss = data.strokeScale;
            const threshold = toThresholdDefault(sw, ss, 0);
            const points = this._points;
            const margin = threshold + this.toMarkerSize(points);
            const dx = data.x;
            const dy = data.y;
            const ax = data.width;
            const ay = data.height;
            if (this.containsAbsBBox(dx, dy, ax + margin, ay + margin)) {
                const marker = points.getMarker();
                if (marker) {
                    const sa = data.strokeAlign;
                    if (this.containsAbsMarker(marker.head, dx, dy, sw, ss, sa)) {
                        return EShapeLineBaseHitPart.MARKER_HEAD;
                    }
                    if (this.containsAbsMarker(marker.tail, dx, dy, sw, ss, sa)) {
                        return EShapeLineBaseHitPart.MARKER_TAIL;
                    }
                }
                const tester = this.calcHitPointAbsHitTester;
                if (points.calcHitPointAbs(dx, dy, ax, ay, threshold, null, tester, null)) {
                    return EShapeLineBaseHitPart.LINE;
                }
            }
            if (this.containsText(x, y)) {
                return EShapeLineBaseHitPart.TEXT;
            }
            if (this.containsChildren(x, y)) {
                return EShapeLineBaseHitPart.CHILDREN;
            }
            return EShapeLineBaseHitPart.NONE;
        }
        calcHitPoint(x, y, toThreshold, toRange, tester, result) {
            const points = this._points;
            const data = this.toHitTestData(x, y);
            const threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, 0);
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return points.calcHitPointAbs(data.x, data.y, data.width, data.height, threshold, toRange, tester, result);
            }
            return false;
        }
        calcHitPointAbsHitTester(x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            // (x, y) = p0 + (p1 - p0) * t where 0 <= t <= 1
            // d0 := p1 - p0
            // d1 := v - p0
            // (p0.x + d0.x * t - x)^2 + (p0.y + d0.y * t - y)^2
            // (d0.x t - d1.x)^2 + (d0.y t - d1.y)^2
            // (d0.x^2 + d0.y^2) t^2 - 2 (d0.x * d1.x + d0.y * d1.y) t + (d1.x^2 + d1.y^2)
            // a := dot( d0, d0 )
            // b := dot( d0, d1 )
            // c := dot( d1, d1 )
            // a t^2 - 2 b t + c = a (t - b / a)^2 + c - b * b / a
            // t0 = b / a  min = c - b * b / a
            const d0x = p1x - p0x;
            const d0y = p1y - p0y;
            const d1x = x - p0x;
            const d1y = y - p0y;
            const a = d0x * d0x + d0y * d0y;
            const b = d0x * d1x + d0y * d1y;
            const c = d1x * d1x + d1y * d1y;
            if (0.0001 < a) {
                const t = Math.max(0, Math.min(1, b / a));
                const d = a * t * t - 2 * b * t + c;
                if (d < threshold * threshold) {
                    return true;
                }
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeBar extends EShapeLineBase {
        constructor(type = EShapeType.BAR) {
            super(type);
            this._points = new EShapeBarPoints(this);
        }
        get points() {
            return this._points;
        }
        clone() {
            return new EShapeBar(this.type).copy(this);
        }
        containsAbsBBox(x, y, ax, ay) {
            const size = Math.max(0, this._points.size);
            return super.containsAbsBBox(x, y, ax + size, ay + size);
        }
        serialize(manager) {
            const result = super.serialize(manager);
            result[15] = this._points.serialize(manager);
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderBar extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, BAR_VERTEX_COUNT, BAR_INDEX_COUNT);
            this.pointsId = -1;
            this.pointsStyle = EShapePointsStyle.NONE;
        }
        init() {
            const voffset = this.vertexOffset;
            const ioffset = this.indexOffset;
            const buffer = this.buffer;
            buffer.updateIndices();
            buildBarIndex(buffer.indices, voffset, ioffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        }
        updateVertexStep(buffer, shape) {
            if (shape instanceof EShapeBar) {
                const size = shape.size;
                const sizeX = size.x;
                const sizeY = size.y;
                const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
                const stroke = shape.stroke;
                const strokeWidth = stroke.enable ? stroke.width : 0;
                const strokeStyle = stroke.style;
                const isStrokeWidthChanged = strokeWidth !== this.strokeWidth || strokeStyle !== this.strokeStyle;
                const transformLocalId = toTransformLocalId(shape);
                const isTransformChanged = this.transformLocalId !== transformLocalId;
                const points = shape.points;
                const pointsId = points.id;
                const isPointsIdChanged = pointsId !== this.pointsId;
                const pointsStyle = points.style;
                const isPointsStyleChanged = pointsStyle !== this.pointsStyle;
                const isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
                if (isNotInited ||
                    isSizeChanged ||
                    isTransformChanged ||
                    isStrokeWidthChanged ||
                    isPointsIdChanged ||
                    isPointsStyleChanged) {
                    this.inited |= BuilderFlag.VERTEX_AND_STEP;
                    this.sizeX = sizeX;
                    this.sizeY = sizeY;
                    this.strokeWidth = strokeWidth;
                    this.strokeStyle = strokeStyle;
                    this.transformLocalId = transformLocalId;
                    this.pointsId = pointsId;
                    this.pointsStyle = pointsStyle;
                    if (isPointsIdChanged) {
                        // Invalidate the UV buffer
                        this.inited &= ~BuilderFlag.UV;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    buildBarVertexStep(buffer.vertices, buffer.steps, this.vertexOffset, points.values, points.size, strokeWidth, strokeStyle, shape.transform.internalTransform);
                }
            }
        }
        updateUv(buffer, shape) {
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildBarUv(buffer.uvs, this.vertexOffset, toTextureUvs(texture));
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderText {
        constructor(buffer, vertexOffset, indexOffset, vertexCount, indexCount) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = vertexCount;
            this.indexCount = indexCount;
            this.inited = BuilderFlag.NONE;
            this.sizeX = 0;
            this.sizeY = 0;
            this.transformLocalId = 0;
            this.scaleX = 1;
            this.scaleY = 1;
            this.size = 0;
            this.family = "auto";
            this.value = "";
            this.texture = null;
            this.textureTransformId = 0;
            this.color = 0;
            this.alpha = 0;
            this.weight = 0;
            this.style = 0;
            this.alignHorizontal = 0;
            this.alignVertical = 0;
            this.offsetHorizontal = 0;
            this.offsetVertical = 0;
            this.outlineWidth = 0;
            this.outlineColor = 0;
            this.outlineAlpha = 0;
            this.spacingHorizontal = 0;
            this.spacingVertical = 0;
            this.direction = 0;
            this.paddingHorizontal = 0;
            this.paddingVertical = 0;
            this.clipping = false;
            this.fitting = false;
        }
        init() {
            const vcount = this.vertexCount;
            if (0 < vcount) {
                // Indices
                const buffer = this.buffer;
                const voffset = this.vertexOffset;
                buffer.updateIndices();
                buildTextIndex(buffer.indices, voffset, this.indexOffset, this.indexCount);
            }
            this.inited |= BuilderFlag.INDEX;
            return this;
        }
        reinit(buffer, shape, vertexOffset, indexOffset) {
            const tcount = toTextBufferCount(shape);
            const vertexCount = tcount << TEXT_VERTEX_COUNT_SHIFT;
            const indexCount = tcount << TEXT_INDEX_COUNT_SHIFT;
            if (this.buffer !== buffer ||
                this.vertexOffset !== vertexOffset ||
                this.indexOffset !== indexOffset ||
                this.vertexCount !== vertexCount ||
                this.indexCount !== indexCount) {
                if (buffer.check(vertexOffset, indexOffset, vertexCount, indexCount)) {
                    this.inited = BuilderFlag.NONE;
                    this.buffer = buffer;
                    this.vertexOffset = vertexOffset;
                    this.indexOffset = indexOffset;
                    this.vertexCount = vertexCount;
                    this.indexCount = indexCount;
                    this.init();
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        }
        isCompatible(shape) {
            return toTextBufferCount(shape) << TEXT_VERTEX_COUNT_SHIFT === this.vertexCount;
        }
        update(shape) {
            const vcount = this.vertexCount;
            if (0 < vcount) {
                const textAtlas = shape.text.atlas;
                if (textAtlas != null) {
                    const buffer = this.buffer;
                    this.updateVertex(buffer, shape, textAtlas);
                    this.updateColor(buffer, shape);
                    this.updateStep(buffer, shape);
                }
            }
            return this;
        }
        updateVertex(buffer, shape, textAtlas) {
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const text = shape.text;
            const textSize = text.size;
            const textFamily = text.family;
            const textValue = text.value;
            const textStyle = text.style;
            const textAlignHorizontal = text.align.horizontal;
            const textAlignVertical = text.align.vertical;
            const textOffsetHorizontal = text.offset.horizontal;
            const textOffsetVertical = text.offset.vertical;
            const textSpacingHorizontal = text.spacing.horizontal;
            const textSpacingVertical = text.spacing.vertical;
            const textDirection = text.direction;
            const textPaddingHorizontal = text.padding.horizontal;
            const textPaddingVertical = text.padding.vertical;
            const textClipping = text.clipping;
            const textFitting = text.fitting;
            const textTexture = text.texture || pixi_js.Texture.WHITE;
            const textTextureTransformId = toTextureTransformId(textTexture);
            const isCharChanged = textValue !== this.value || textFamily !== this.family;
            const isCharSizeChanged = textSize !== this.size;
            const isCharStyleChanged = textStyle !== this.style;
            const isCharAlignChanged = textAlignHorizontal !== this.alignHorizontal ||
                textAlignVertical !== this.alignVertical;
            const isCharOffsetChanged = textOffsetHorizontal !== this.offsetHorizontal ||
                textOffsetVertical !== this.offsetVertical;
            const isCharSpacingChanged = textSpacingHorizontal !== this.spacingHorizontal ||
                textSpacingVertical !== this.spacingVertical ||
                textPaddingHorizontal !== this.paddingHorizontal ||
                textPaddingVertical !== this.paddingVertical;
            const isCharDirectionChanged = textDirection !== this.direction;
            const isClippingChanged = this.clipping !== textClipping;
            const isFittingChanged = this.fitting !== textFitting;
            const isTextureChanged = textTexture !== this.texture || textTextureTransformId !== this.textureTransformId;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX);
            if (isNotInited ||
                isSizeChanged ||
                isTransformChanged ||
                isCharChanged ||
                isCharSizeChanged ||
                isCharStyleChanged ||
                isCharAlignChanged ||
                isCharOffsetChanged ||
                isCharSpacingChanged ||
                isCharDirectionChanged ||
                isClippingChanged ||
                isFittingChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX;
                this.size = textSize;
                this.family = textFamily;
                this.value = textValue;
                this.style = textStyle;
                this.alignHorizontal = textAlignHorizontal;
                this.alignVertical = textAlignVertical;
                this.offsetHorizontal = textOffsetHorizontal;
                this.offsetVertical = textOffsetVertical;
                this.spacingHorizontal = textSpacingHorizontal;
                this.spacingVertical = textSpacingVertical;
                this.direction = textDirection;
                this.paddingHorizontal = textPaddingHorizontal;
                this.paddingVertical = textPaddingVertical;
                this.clipping = textClipping;
                this.fitting = textFitting;
                this.texture = textTexture;
                this.textureTransformId = textTextureTransformId;
                if (isCharSizeChanged || isFittingChanged || (textFitting && isSizeChanged)) {
                    // Invalidate the step buffer.
                    this.inited &= ~BuilderFlag.STEP;
                }
                // Vertices & UVs
                buffer.updateVertices();
                buffer.updateUvs();
                const shapeSize = shape.size;
                let textWorld = text.world;
                if (textWorld == null) {
                    textWorld = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
                    text.world = textWorld;
                }
                buildTextVertex(buffer.vertices, buffer.uvs, this.vertexOffset, this.vertexCount, 0, 0, shapeSize.x, shapeSize.y, textAtlas, textSize, text.characters, textStyle, textAlignHorizontal, textAlignVertical, textOffsetHorizontal, textOffsetVertical, textSpacingHorizontal, textSpacingVertical, textDirection, textPaddingHorizontal, textPaddingVertical, textClipping, textFitting, textWorld, toTextureUvs(textTexture), shape.transform.internalTransform);
            }
        }
        updateColor(buffer, shape) {
            const text = shape.text;
            const color = text.color;
            const alpha = shape.visible && text.enable ? text.alpha : 0;
            const outline = text.outline;
            const outlineColor = outline.color;
            const outlineAlpha = shape.visible && text.enable ? outline.alpha : 0;
            const isNotInited = !(this.inited & BuilderFlag.COLOR);
            if (isNotInited ||
                color !== this.color ||
                alpha !== this.alpha ||
                color !== this.outlineColor ||
                alpha !== this.outlineAlpha) {
                this.inited |= BuilderFlag.COLOR;
                this.color = color;
                this.alpha = alpha;
                this.outlineColor = outlineColor;
                this.outlineAlpha = outlineAlpha;
                buffer.updateColors();
                buildColor(color, alpha, outlineColor, outlineAlpha, this.vertexOffset, this.vertexCount, buffer.colors);
            }
        }
        updateStep(buffer, shape) {
            const text = shape.text;
            const textOutline = text.outline;
            const textOutlineWidth = textOutline.enable ? textOutline.width : 0;
            const isOutlineWidthChanged = textOutlineWidth !== this.outlineWidth;
            const textWeight = text.weight;
            const isWeightChanged = textWeight !== this.weight;
            let scaleX = 1;
            let scaleY = 1;
            const textWorld = text.world;
            if (textWorld != null) {
                scaleX = textWorld[8];
                scaleY = textWorld[9];
            }
            const isScaleChanged = TEXT_FMIN < Math.abs(this.scaleX - scaleX) ||
                TEXT_FMIN < Math.abs(this.scaleY - scaleY);
            const isNotInited = !(this.inited & BuilderFlag.STEP);
            if (isNotInited || isWeightChanged || isOutlineWidthChanged || isScaleChanged) {
                this.inited |= BuilderFlag.STEP;
                this.weight = textWeight;
                this.outlineWidth = textOutlineWidth;
                this.scaleX = scaleX;
                this.scaleY = scaleY;
                buffer.updateSteps();
                buildTextStep(buffer.steps, this.vertexOffset, this.vertexCount, text.atlas, text.size, textOutlineWidth, textWeight, this.scaleX, this.scaleY);
            }
        }
        buildUnit(builder) {
            if (0 < this.vertexCount) {
                const textTexture = this.texture || pixi_js.Texture.WHITE;
                const textBaseTexture = textTexture.baseTexture;
                if (textBaseTexture !== builder.baseTexture) {
                    builder.baseTexture = textBaseTexture;
                    builder.push(textTexture, this.indexOffset);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createBarUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = BAR_VERTEX_COUNT + tvcount;
        const icount = BAR_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderBar(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + BAR_VERTEX_COUNT, ioffset + BAR_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toPadded = (str, length, c) => {
        const strLength = str.length;
        if (length < strLength) {
            return str;
        }
        let padding = "";
        for (let i = 0, imax = length - strLength; i < imax; ++i) {
            padding += c;
        }
        return padding + str;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilRgb {
        static toCode(color) {
            return toPadded(color.toString(16).toUpperCase(), 6, "0");
        }
        static fromCode(code) {
            const trimmed = code.trim().toLowerCase();
            if (trimmed.length === 6) {
                const color = Number(`0x${trimmed}`);
                if (color === color) {
                    return color;
                }
            }
            return null;
        }
        static fromRgb(r, g, b) {
            return ((r * 0xff) << 16) | ((g * 0xff) << 8) | ((b * 0xff) | 0);
        }
        static blend(colorA, colorB, t) {
            const ar = (colorA >> 16) & 0xff;
            const ag = (colorA >> 8) & 0xff;
            const ab = (colorA | 0) & 0xff;
            const br = (colorB >> 16) & 0xff;
            const bg = (colorB >> 8) & 0xff;
            const bb = (colorB | 0) & 0xff;
            const w1 = Math.max(0, Math.min(1, t));
            const w0 = 1 - w1;
            const cr = Math.max(0, Math.min(0xff, ar * w0 + br * w1));
            const cg = Math.max(0, Math.min(0xff, ag * w0 + bg * w1));
            const cb = Math.max(0, Math.min(0xff, ab * w0 + bb * w1));
            return (cr << 16) | (cg << 8) | (cb | 0);
        }
        static brighten(color, amount) {
            if (0 <= amount) {
                return this.blend(color, 0xffffff, amount);
            }
            else {
                return this.blend(color, 0x000000, -amount);
            }
        }
        static darken(color, amount) {
            if (0 <= amount) {
                return this.blend(color, 0x000000, amount);
            }
            else {
                return this.blend(color, 0xffffff, -amount);
            }
        }
        /**
         * Convertes the given color to a grayscale color.
         *
         * @param color a color to be converted
         * @returns a grayscale color
         * @see https://en.wikipedia.org/wiki/Grayscale
         */
        static toGrayscale(color) {
            const l = this.toLuma(color);
            return (l << 16) | (l << 8) | l;
        }
        /**
         * Convertes the given color to a luma in the range [0, 255].
         *
         * @param color a color to be converted
         * @returns a luma in the range [0, 255]
         * @see https://en.wikipedia.org/wiki/Grayscale
         */
        static toLuma(color) {
            const r = (color >> 16) & 0xff;
            const g = (color >> 8) & 0xff;
            const b = (color | 0) & 0xff;
            return (0.2126 * r + 0.7152 * g + 0.0722 * b) & 0xff;
        }
    }

    const POSITION_X = 1;
    const POSITION_Y = 2;
    const ROTATION = 4;
    const COLOR_FILL = 8;
    const COLOR_STROKE = 16;
    const COLOR_TEXT = 32;
    const COLOR_TEXT_OUTLINE = 64;
    const VISIBILITY = 128;
    const HEIGHT = 256;
    const WIDTH = 512;
    const TEXT$1 = 1024;
    const CURSOR = 2048;
    const EShapeRuntimeReset = {
        NONE: 0,
        POSITION_X,
        POSITION_Y,
        POSITION: POSITION_X | POSITION_Y,
        ROTATION,
        COLOR_FILL,
        COLOR_STROKE,
        COLOR_FILL_AND_STROKE: COLOR_FILL | COLOR_STROKE,
        COLOR_TEXT,
        COLOR_TEXT_OUTLINE,
        COLOR: COLOR_FILL | COLOR_STROKE | COLOR_TEXT | COLOR_TEXT_OUTLINE,
        VISIBILITY,
        HEIGHT,
        WIDTH,
        SIZE: HEIGHT | WIDTH,
        TEXT: TEXT$1,
        CURSOR
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionBases {
        static toBaseFill(shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_FILL ? shape : runtime).fill;
        }
        static toBaseStroke(shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_STROKE ? shape : runtime).stroke;
        }
        static toBaseText(shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT ? shape : runtime).text;
        }
        static toBaseTextOutline(shape, runtime) {
            return (runtime.written & EShapeRuntimeReset.COLOR_TEXT_OUTLINE ? shape : runtime).text
                .outline;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionEnvironment = {
        isInitializing: false
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link EShape} action expression utility class.
     */
    class EShapeActionExpressions {
        static from(expression, caster, def, defLiteral, nullable, parameter) {
            if (expression.trim().length <= 0) {
                return def;
            }
            try {
                /* eslint-disable prettier/prettier */
                const body = `` +
                    `try {` +
                    `with (shape) {` +
                    `with (state) {` +
                    `with (data.alias) {` +
                    `with (environment) {` +
                    (nullable ?
                        (`var result = (${expression});` +
                            `return (result != null ? ${caster}(result) : null);`) :
                        `return ${caster}(${expression});`) +
                    `}` +
                    `}` +
                    `}` +
                    `}` +
                    `} catch (e) {` +
                    `return ${defLiteral};` +
                    `}`;
                /* eslint-enable prettier/prettier */
                if (parameter == null) {
                    return Function("shape", "time", "environment", body);
                }
                else {
                    return Function("shape", "time", "environment", parameter, body);
                }
            }
            catch (e) {
                return def;
            }
        }
        static ofNumberOrNull(expression) {
            return this.from(expression, "Number", this.NULL, "null", true);
        }
        static ofStringOrNull(expression) {
            return this.from(expression, "String", this.NULL, "null", true);
        }
        static ofUnknown(expression) {
            return this.from(expression, "", this.NULL, "null", false);
        }
        static ofNumber(expression) {
            return this.from(expression, "Number", this.ZERO, "0", false);
        }
        static ofNumberOrOne(expression) {
            return this.from(expression, "Number", this.ONE, "1", false);
        }
        static ofNumberOrOneHundred(expression) {
            return this.from(expression, "Number", this.ONE_HUNDRED, "100", false);
        }
        static ofString(expression) {
            return this.from(expression, "String", this.EMPTY, '""', false);
        }
        static ofBoolean(expression) {
            return this.from(expression, "Boolean", this.TRUE, "true", false);
        }
        static ofBooleanOrTrue(expression) {
            return this.from(expression, "Boolean", this.TRUE, "true", false);
        }
        static ofBooleanOrFalse(expression) {
            return this.from(expression, "Boolean", this.FALSE, "false", false);
        }
        static ofElementOrNull(expression) {
            return this.from(expression, "", undefined, "null", false, "container");
        }
    }
    EShapeActionExpressions.NULL = () => null;
    EShapeActionExpressions.ZERO = () => 0;
    EShapeActionExpressions.ONE = () => 1;
    EShapeActionExpressions.ONE_HUNDRED = () => 100;
    EShapeActionExpressions.EMPTY = () => "";
    EShapeActionExpressions.TRUE = () => true;
    EShapeActionExpressions.FALSE = () => false;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class of action runtimes.
     */
    class EShapeActionRuntimeBase {
        constructor(reset) {
            this.reset = reset || EShapeRuntimeReset.NONE;
        }
        initialize(shape, runtime) {
            // DO NOTHING
        }
        execute(shape, runtime, time) {
            // DO NOTHING
        }
        onResize(shape, runtime) {
            // DO NOTHING
        }
        onFocus(shape, runtime) {
            // DO NOTHING
        }
        onBlur(shape, runtime) {
            // DO NOTHING
        }
        onClick(shape, runtime, e) {
            // DO NOTHING
        }
        onDblClick(shape, runtime, e, manager) {
            // DO NOTHING
        }
        onDowning(shape, runtime, e) {
            // DO NOTHING
        }
        onDown(shape, runtime, e) {
            // DO NOTHING
        }
        onMove(shape, runtime, e) {
            // DO NOTHING
        }
        onOver(shape, runtime, e) {
            // DO NOTHING
        }
        onOut(shape, runtime, e) {
            // DO NOTHING
        }
        onUp(shape, runtime, e) {
            // DO NOTHING
        }
        onUpOutside(shape, runtime, e) {
            // DO NOTHING
        }
        onPressed(shape, runtime, e) {
            // DO NOTHING
        }
        onUnpressed(shape, runtime, e) {
            // DO NOTHING
        }
        onKeyDown(shape, runtime, e) {
            // DO NOTHING
        }
        onKeyUp(shape, runtime, e) {
            // DO NOTHING
        }
        onRightClick(shape, runtime, e) {
            // DO NOTHING
        }
        onRightDowning(shape, runtime, e) {
            // DO NOTHING
        }
        onRightDown(shape, runtime, e) {
            // DO NOTHING
        }
        onRightUp(shape, runtime, e) {
            // DO NOTHING
        }
        onRightUpOutside(shape, runtime, e) {
            // DO NOTHING
        }
        onRightPressed(shape, runtime, e) {
            // DO NOTHING
        }
        onRightUnpressed(shape, runtime, e) {
            // DO NOTHING
        }
        onRender(shape, runtime, time, renderer) {
            // DO NOTHING
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeConditional extends EShapeActionRuntimeBase {
        constructor(value, reset) {
            super(reset);
            this.condition = EShapeActionExpressions.ofBoolean(value.condition);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeBlink extends EShapeActionRuntimeConditional {
        constructor(value, reset) {
            super(value, reset);
            this.interval = value.interval;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const interval = this.interval;
                const dinterval = interval << 1;
                const elapsed = time % dinterval;
                if (elapsed < interval) {
                    this.toOff(shape, runtime);
                    runtime.effect = time + (interval - elapsed);
                }
                else {
                    this.toOn(shape, runtime);
                    runtime.effect = time + (dinterval - elapsed);
                }
            }
        }
        toOn(shape, runtime) {
            //
        }
        toOff(shape, runtime) {
            //
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeBlinkBrighten extends EShapeActionRuntimeBlink {
        constructor(value) {
            super(value, EShapeRuntimeReset.COLOR);
        }
        toOn(shape, runtime) {
            const fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.brighten(fill.color, 0.5), fill.alpha);
            const stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.brighten(stroke.color, 0.5), stroke.alpha);
            const text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.brighten(text.color, 0.5), text.alpha);
            const outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.brighten(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeBlinkColorFill extends EShapeActionRuntimeBlink {
        constructor(value) {
            super(value, EShapeRuntimeReset.COLOR_FILL);
            this.color = value.color;
            this.alpha = value.alpha;
        }
        toOn(shape, runtime) {
            shape.fill.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeBlinkColorStroke extends EShapeActionRuntimeBlink {
        constructor(value) {
            super(value, EShapeRuntimeReset.COLOR_STROKE);
            this.color = value.color;
            this.alpha = value.alpha;
        }
        toOn(shape, runtime) {
            shape.stroke.set(undefined, this.color, this.alpha);
            runtime.written |= this.reset;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeBlinkDarken extends EShapeActionRuntimeBlink {
        constructor(value) {
            super(value, EShapeRuntimeReset.COLOR);
        }
        toOn(shape, runtime) {
            const fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, UtilRgb.darken(fill.color, 0.5), fill.alpha);
            const stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, UtilRgb.darken(stroke.color, 0.5), stroke.alpha);
            const text = EShapeActionBases.toBaseText(shape, runtime);
            shape.text.set(undefined, UtilRgb.darken(text.color, 0.5), text.alpha);
            const outline = EShapeActionBases.toBaseTextOutline(shape, runtime);
            shape.text.outline.set(undefined, UtilRgb.darken(outline.color, 0.5), outline.alpha);
            runtime.written |= this.reset;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeBlinkOpacity extends EShapeActionRuntimeBlink {
        constructor(value) {
            super(value, EShapeRuntimeReset.COLOR_FILL_AND_STROKE);
        }
        toOn(shape, runtime) {
            const fill = EShapeActionBases.toBaseFill(shape, runtime);
            shape.fill.set(undefined, fill.color, fill.alpha * 0.5);
            const stroke = EShapeActionBases.toBaseStroke(shape, runtime);
            shape.stroke.set(undefined, stroke.color, stroke.alpha * 0.5);
            runtime.written |= this.reset;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeBlinkVisibility extends EShapeActionRuntimeBlink {
        constructor(value) {
            super(value, EShapeRuntimeReset.VISIBILITY);
        }
        toOn(shape, runtime) {
            shape.visible = true;
            runtime.written |= this.reset;
        }
        toOff(shape, runtime) {
            shape.visible = false;
            runtime.written |= this.reset;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueBlinkType = {
        VISIBILITY: 0,
        BRIGHTEN: 1,
        DARKEN: 2,
        OPACITY: 3,
        COLOR_FILL: 4,
        COLOR_STROKE: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueBase {
        constructor(type, condition) {
            this.type = type;
            this.condition = condition;
        }
        isEquals(value) {
            return this.type === value.type && this.condition === value.condition;
        }
        toLabel() {
            return this.getTheme().toLabel(this);
        }
        getTheme() {
            var _a;
            return ((_a = EShapeActionValueBase.THEME) !== null && _a !== void 0 ? _a : (EShapeActionValueBase.THEME = DThemes.getInstance().get("EShapeActionValue")));
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueSubtyped extends EShapeActionValueBase {
        constructor(type, condition, subtype) {
            super(type, condition);
            this.subtype = subtype;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueSubtyped &&
                this.subtype === value.subtype);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueType = {
        SHOW_HIDE: 0,
        BLINK: 1,
        TRANSFORM: 2,
        OPEN: 3,
        /** @deprecated in favor of {@link EShapeActionValueMiscType}'s MISC */
        EMIT_EVENT: 4,
        /** @deprecated in favor of {@link EShapeActionValueType}'s CHANGE_COLOR */
        CHANGE_COLOR_LEGACY: 5,
        CHANGE_TEXT: 6,
        CHANGE_CURSOR: 7,
        MISC: 8,
        CHANGE_COLOR: 9,
        GESTURE: 10,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValues {
        static toResource(index, parsed, resources) {
            if (0 <= index && index < parsed.length) {
                const id = parsed[index];
                if (isNumber(id) && 0 <= id && id < resources.length) {
                    return resources[id];
                }
            }
            return "";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueBlink extends EShapeActionValueSubtyped {
        constructor(subtype, condition, interval, color, alpha) {
            super(EShapeActionValueType.BLINK, condition, subtype);
            this.interval = interval;
            this.color = color;
            this.alpha = alpha;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueBlink &&
                this.interval === value.interval &&
                this.color === value.color &&
                this.alpha === value.alpha);
        }
        toRuntime() {
            switch (this.subtype) {
                case EShapeActionValueBlinkType.BRIGHTEN:
                    return new EShapeActionRuntimeBlinkBrighten(this);
                case EShapeActionValueBlinkType.COLOR_FILL:
                    return new EShapeActionRuntimeBlinkColorFill(this);
                case EShapeActionValueBlinkType.COLOR_STROKE:
                    return new EShapeActionRuntimeBlinkColorStroke(this);
                case EShapeActionValueBlinkType.DARKEN:
                    return new EShapeActionRuntimeBlinkDarken(this);
                case EShapeActionValueBlinkType.OPACITY:
                    return new EShapeActionRuntimeBlinkOpacity(this);
                case EShapeActionValueBlinkType.VISIBILITY:
                    return new EShapeActionRuntimeBlinkVisibility(this);
            }
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${this.interval},${this.color},${this.alpha}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueBlink(serialized[2], condition, serialized[3], serialized[4], serialized[5]);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilAlpha {
        static blend(alphaA, alphaB, t) {
            const w = Math.max(0, Math.min(1, t));
            return Math.max(0, Math.min(1, alphaA * (1 - w) + alphaB * w));
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toReset = (type) => {
        return type << 3;
    };
    class EShapeActionRuntimeChangeColorBase extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, toReset(value.subtype));
        }
        set(shape, runtime, time, color, alpha, blend) {
            const reset = this.reset;
            if (color != null) {
                if (alpha != null) {
                    if (blend != null) {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            const base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            const base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            const base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            const base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, UtilRgb.blend(base.color, color, blend), UtilAlpha.blend(base.alpha, alpha, blend));
                        }
                    }
                    else {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            shape.fill.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            shape.stroke.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            shape.text.set(undefined, color, alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            shape.text.outline.set(undefined, color, alpha);
                        }
                    }
                }
                else {
                    if (blend != null) {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            const base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            const base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            const base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            const base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, UtilRgb.blend(base.color, color, blend), base.alpha);
                        }
                    }
                    else {
                        if (reset & EShapeRuntimeReset.COLOR_FILL) {
                            const base = EShapeActionBases.toBaseFill(shape, runtime);
                            shape.fill.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                            const base = EShapeActionBases.toBaseStroke(shape, runtime);
                            shape.stroke.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                            const base = EShapeActionBases.toBaseText(shape, runtime);
                            shape.text.set(undefined, color, base.alpha);
                        }
                        if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                            const base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                            shape.text.outline.set(undefined, color, base.alpha);
                        }
                    }
                }
                runtime.written |= reset;
            }
            else if (alpha != null) {
                if (blend != null) {
                    if (reset & EShapeRuntimeReset.COLOR_FILL) {
                        const base = EShapeActionBases.toBaseFill(shape, runtime);
                        shape.fill.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                        const base = EShapeActionBases.toBaseStroke(shape, runtime);
                        shape.stroke.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                        const base = EShapeActionBases.toBaseText(shape, runtime);
                        shape.text.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                        const base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                        shape.text.outline.set(undefined, base.color, UtilAlpha.blend(base.alpha, alpha, blend));
                    }
                }
                else {
                    if (reset & EShapeRuntimeReset.COLOR_FILL) {
                        const base = EShapeActionBases.toBaseFill(shape, runtime);
                        shape.fill.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                        const base = EShapeActionBases.toBaseStroke(shape, runtime);
                        shape.stroke.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                        const base = EShapeActionBases.toBaseText(shape, runtime);
                        shape.text.set(undefined, base.color, alpha);
                    }
                    if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                        const base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                        shape.text.outline.set(undefined, base.color, alpha);
                    }
                }
                runtime.written |= reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueChangeColorTarget = {
        COLOR_AND_ALPHA: 0,
        COLOR: 1,
        ALPHA: 2,
        CODE: 3,
        BRIGHTNESS: 4
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeChangeColor extends EShapeActionRuntimeChangeColorBase {
        constructor(value) {
            super(value);
            switch (value.target) {
                case EShapeActionValueChangeColorTarget.COLOR:
                    this.color = value.color;
                    this.alpha = null;
                    break;
                case EShapeActionValueChangeColorTarget.ALPHA:
                    this.color = null;
                    this.alpha = value.alpha;
                    break;
                default:
                    this.color = value.color;
                    this.alpha = value.alpha;
                    break;
            }
            this.blend = EShapeActionExpressions.ofNumberOrNull(value.blend);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const color = this.color;
                const alpha = this.alpha;
                const blend = this.blend(shape, time, EShapeActionEnvironment);
                this.set(shape, runtime, time, color, alpha, blend);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const FILL = 1;
    const STROKE = 2;
    const TEXT = 4;
    const TEXT_OUTLINE = 8;
    const EShapeActionValueChangeColorType = {
        NONE: 0,
        FILL,
        STROKE,
        TEXT,
        TEXT_OUTLINE,
        FILL_AND_STROKE: FILL | STROKE,
        ALL: FILL | STROKE | TEXT | TEXT_OUTLINE
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueChangeColorTypeLegacy = {
        FILL: 0,
        STROKE: 1,
        FILL_AND_STROKE: 2,
        TEXT: 3,
        TEXT_OUTLINE: 4,
        ALL: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueChangeColorTypes {
        static from(serialized) {
            if (serialized[0] === EShapeActionValueType.CHANGE_COLOR) {
                return serialized[2];
            }
            switch (serialized[2]) {
                case EShapeActionValueChangeColorTypeLegacy.FILL:
                    return EShapeActionValueChangeColorType.FILL;
                case EShapeActionValueChangeColorTypeLegacy.STROKE:
                    return EShapeActionValueChangeColorType.STROKE;
                case EShapeActionValueChangeColorTypeLegacy.FILL_AND_STROKE:
                    return EShapeActionValueChangeColorType.FILL_AND_STROKE;
                case EShapeActionValueChangeColorTypeLegacy.TEXT:
                    return EShapeActionValueChangeColorType.TEXT;
                case EShapeActionValueChangeColorTypeLegacy.TEXT_OUTLINE:
                    return EShapeActionValueChangeColorType.TEXT_OUTLINE;
                case EShapeActionValueChangeColorTypeLegacy.ALL:
                    return EShapeActionValueChangeColorType.ALL;
            }
        }
        static unpack(type) {
            const result = [];
            if (type & EShapeActionValueChangeColorType.FILL) {
                result.push(EShapeActionValueChangeColorType.FILL);
            }
            if (type & EShapeActionValueChangeColorType.STROKE) {
                result.push(EShapeActionValueChangeColorType.STROKE);
            }
            if (type & EShapeActionValueChangeColorType.TEXT) {
                result.push(EShapeActionValueChangeColorType.TEXT);
            }
            if (type & EShapeActionValueChangeColorType.TEXT_OUTLINE) {
                result.push(EShapeActionValueChangeColorType.TEXT_OUTLINE);
            }
            return result;
        }
        static pack(types) {
            let result = EShapeActionValueChangeColorType.NONE;
            for (let i = 0, imax = types.length; i < imax; ++i) {
                result |= types[i];
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueChangeColor extends EShapeActionValueSubtyped {
        constructor(subtype, condition, target, color, alpha, blend) {
            super(EShapeActionValueType.CHANGE_COLOR, condition, subtype);
            this.target = target;
            this.color = color;
            this.alpha = alpha;
            this.blend = blend;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueChangeColor &&
                this.target === value.target &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        }
        toRuntime() {
            return new EShapeActionRuntimeChangeColor(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const blendId = manager.addResource(this.blend);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${this.target},${this.color},${this.alpha},${blendId}]`);
        }
        static deserialize(serialized, manager) {
            const subtype = EShapeActionValueChangeColorTypes.from(serialized);
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColor(subtype, condition, serialized[3], serialized[4], serialized[5], blend);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeChangeColorBrightness extends EShapeActionRuntimeChangeColorBase {
        constructor(value) {
            super(value);
            this.brightness = EShapeActionExpressions.ofNumberOrNull(value.brightness);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const brightness = this.brightness(shape, time, EShapeActionEnvironment);
                this.set(shape, runtime, time, brightness);
            }
        }
        set(shape, runtime, time, brightness) {
            const reset = this.reset;
            if (brightness != null) {
                const toAdjusted = this.toAdjusted;
                if (reset & EShapeRuntimeReset.COLOR_FILL) {
                    const base = EShapeActionBases.toBaseFill(shape, runtime);
                    shape.fill.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_STROKE) {
                    const base = EShapeActionBases.toBaseStroke(shape, runtime);
                    shape.stroke.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_TEXT) {
                    const base = EShapeActionBases.toBaseText(shape, runtime);
                    shape.text.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                if (reset & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                    const base = EShapeActionBases.toBaseTextOutline(shape, runtime);
                    shape.text.outline.set(undefined, toAdjusted(base.color, brightness), base.alpha);
                }
                runtime.written |= reset;
            }
        }
        toAdjusted(color, brightness) {
            if (0 <= brightness) {
                return UtilRgb.brighten(color, +brightness);
            }
            else {
                return UtilRgb.darken(color, -brightness);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueChangeColorBrightness extends EShapeActionValueSubtyped {
        constructor(subtype, condition, brightness) {
            super(EShapeActionValueType.CHANGE_COLOR, condition, subtype);
            this.brightness = brightness;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueChangeColorBrightness &&
                this.brightness === value.brightness);
        }
        toRuntime() {
            return new EShapeActionRuntimeChangeColorBrightness(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const target = EShapeActionValueChangeColorTarget.BRIGHTNESS;
            const brightnessId = manager.addResource(this.brightness);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${target},${brightnessId}]`);
        }
        static deserialize(serialized, manager) {
            const subtype = EShapeActionValueChangeColorTypes.from(serialized);
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const brightness = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueChangeColorBrightness(subtype, condition, brightness);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeChangeColorCode extends EShapeActionRuntimeChangeColorBase {
        constructor(value) {
            super(value);
            this.color = EShapeActionExpressions.ofNumberOrNull(value.color);
            this.alpha = EShapeActionExpressions.ofNumberOrNull(value.alpha);
            this.blend = EShapeActionExpressions.ofNumberOrNull(value.blend);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const color = this.color(shape, time, EShapeActionEnvironment);
                const alpha = this.alpha(shape, time, EShapeActionEnvironment);
                const blend = this.blend(shape, time, EShapeActionEnvironment);
                this.set(shape, runtime, time, color, alpha, blend);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueChangeColorCode extends EShapeActionValueSubtyped {
        constructor(subtype, condition, color, alpha, blend) {
            super(EShapeActionValueType.CHANGE_COLOR, condition, subtype);
            this.color = color;
            this.alpha = alpha;
            this.blend = blend;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueChangeColorCode &&
                this.color === value.color &&
                this.alpha === value.alpha &&
                this.blend === value.blend);
        }
        toRuntime() {
            return new EShapeActionRuntimeChangeColorCode(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const target = EShapeActionValueChangeColorTarget.CODE;
            const colorId = manager.addResource(this.color);
            const alphaId = manager.addResource(this.alpha);
            const blendId = manager.addResource(this.blend);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${target},${colorId},${alphaId},${blendId}]`);
        }
        static deserialize(serialized, manager) {
            const subtype = EShapeActionValueChangeColorTypes.from(serialized);
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const color = EShapeActionValues.toResource(4, serialized, manager.resources);
            const alpha = EShapeActionValues.toResource(5, serialized, manager.resources);
            const blend = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueChangeColorCode(subtype, condition, color, alpha, blend);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeChangeCursor extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.CURSOR);
            this.name = EShapeActionExpressions.ofStringOrNull(value.name);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const name = this.name(shape, time, EShapeActionEnvironment);
                if (name != null) {
                    shape.cursor = name;
                    runtime.written |= this.reset;
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueChangeCursor extends EShapeActionValueBase {
        constructor(condition, name) {
            super(EShapeActionValueType.CHANGE_CURSOR, condition);
            this.name = name;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueChangeCursor &&
                this.name === value.name);
        }
        toRuntime() {
            return new EShapeActionRuntimeChangeCursor(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const nameId = manager.addResource(this.name);
            return manager.addResource(`[${this.type},${conditionId},${nameId}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueChangeCursor(condition, name);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeA {
        format(target, step, date) {
            return date.getHours() < 12 ? "AM" : "PM";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodea {
        format(target, step, date) {
            return date.getHours() < 12 ? "am" : "pm";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeD {
        format(target, step, date) {
            return String(date.getDate());
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNoded {
        format(target, step, date) {
            return `${target | 0}`;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodePrecision {
        constructor(precision) {
            if (precision != null) {
                this.precision = +precision.substring(1, precision.length);
            }
            else {
                this.precision = undefined;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodee extends FormatNodePrecision {
        format(target, step, date) {
            return target.toExponential(this.precision);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodef extends FormatNodePrecision {
        format(target, step, date) {
            return target.toFixed(this.precision);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodefsi extends FormatNodePrecision {
        format(target, step, date) {
            const abs = this.toAbs(target, step, date);
            if (abs < 1e-24) {
                return this.format_(target, 1, "");
            }
            else if (abs < 1e-21) {
                return this.format_(target, 1e24, "y");
            }
            else if (abs < 1e-18) {
                return this.format_(target, 1e21, "z");
            }
            else if (abs < 1e-15) {
                return this.format_(target, 1e18, "a");
            }
            else if (abs < 1e-12) {
                return this.format_(target, 1e15, "f");
            }
            else if (abs < 1e-9) {
                return this.format_(target, 1e12, "p");
            }
            else if (abs < 1e-6) {
                return this.format_(target, 1e9, "n");
            }
            else if (abs < 1e-3) {
                return this.format_(target, 1e6, "μ");
            }
            else if (abs < 1) {
                return this.format_(target, 1e3, "m");
            }
            else if (abs < 1e3) {
                return this.format_(target, 1, "");
            }
            else if (abs < 1e6) {
                return this.format_(target, 1e-3, "k");
            }
            else if (abs < 1e9) {
                return this.format_(target, 1e-6, "M");
            }
            else if (abs < 1e12) {
                return this.format_(target, 1e-9, "G");
            }
            else if (abs < 1e15) {
                return this.format_(target, 1e-12, "T");
            }
            else if (abs < 1e18) {
                return this.format_(target, 1e-15, "P");
            }
            else if (abs < 1e21) {
                return this.format_(target, 1e-18, "E");
            }
            else if (abs < 1e24) {
                return this.format_(target, 1e-21, "Z");
            }
            else {
                return this.format_(target, 1e-24, "Y");
            }
        }
        toAbs(target, step, date) {
            return Math.abs(target);
        }
        format_(target, unitInverse, postfix) {
            const value = target * unitInverse;
            return `${value.toFixed(this.precision)}${postfix}`;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeg extends FormatNodePrecision {
        format(target, step, date) {
            return target.toPrecision(this.precision);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeH {
        format(target, step, date) {
            return String(date.getHours());
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeh {
        format(target, step, date) {
            return String(date.getHours() % 12);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeM {
        format(target, step, date) {
            return String(date.getMonth() + 1);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodem {
        format(target, step, date) {
            return String(date.getMinutes());
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodemi {
        format(target, step, date) {
            return String(date.getMilliseconds());
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeP {
        format(target, step, date) {
            return `${(target * 100) | 0}%`;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodep {
        format(target, step, date) {
            return `${target | 0}%`;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodePadding {
        constructor(length, character, node) {
            this.length = length;
            this.character = character;
            this.node = node;
        }
        format(target, step, date) {
            return toPadded(this.node.format(target, step, date), this.length, this.character);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeParenthesis {
        constructor(node) {
            this.node = node;
        }
        format(target, step, date) {
            const result = this.node.format(target, step, date);
            if (0 < result.length && result[0] === "-") {
                return `(${result.substring(1, result.length)})`;
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodePlus {
        constructor(node) {
            this.node = node;
        }
        format(target, step, date) {
            const result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return `+${result}`;
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeRP {
        format(target, step, date) {
            return `${Math.round(target * 100)}%`;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNoderp {
        format(target, step, date) {
            return `${Math.round(target)}%`;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodesdt {
        constructor(Y, M, D, H, m, s, mi) {
            this.Y = Y;
            this.M = M;
            this.D = D;
            this.H = H;
            this.m = m;
            this.s = s;
            this.mi = mi;
        }
        format(target, step, date) {
            if (step < 1000) {
                return `${this.s.format(target, step, date)}.${this.mi.format(target, step, date)}`;
            }
            else if (step < 60000) {
                return `${this.m.format(target, step, date)}:${this.s.format(target, step, date)}`;
            }
            else if (step < 3600000) {
                return `${this.H.format(target, step, date)}:${this.m.format(target, step, date)}`;
            }
            else if (step < 86400000) {
                const M = this.M.format(target, step, date);
                const D = this.D.format(target, step, date);
                return `${M}/${D} ${this.H.format(target, step, date)}`;
            }
            else if (step < 2592000000) {
                return `${this.M.format(target, step, date)}/${this.D.format(target, step, date)}`;
            }
            else {
                return `${this.Y.format(target, step, date)}/${this.M.format(target, step, date)}`;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeSpace {
        constructor(node) {
            this.node = node;
        }
        format(target, step, date) {
            const result = this.node.format(target, step, date);
            if (0 < result.length && result[0] !== "-") {
                return ` ${result}`;
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodessi extends FormatNodefsi {
        toAbs(target, step, date) {
            return Math.abs(step);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeString {
        constructor(str) {
            this.str = str;
        }
        format(target, step, date) {
            return this.str;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodeY {
        format(target, step, date) {
            return String(date.getFullYear());
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodey {
        format(target, step, date) {
            return String(date.getFullYear() % 100);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodez {
        format(target, step, date) {
            const z = date.getTimezoneOffset();
            const tzs = z <= 0 ? "+" : "-";
            const tzh = toPadded(String(Math.floor(Math.abs(z) / 60)), 2, "0");
            const tzm = toPadded(String(Math.floor(Math.abs(z) % 60)), 2, "0");
            return `${tzs}${tzh}:${tzm}`;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNoderd {
        format(target, step, date) {
            return `${Math.round(target)}`;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class FormatNodes {
        format(target, step, date) {
            return String(date.getSeconds());
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    let REGEXP = undefined;
    const getRegExp = () => {
        let result = REGEXP;
        if (result) {
            result.lastIndex = 0;
        }
        else {
            result =
                /%(0|_|-|\+|\()?(\.\d+)?(Y(?:MD?)?|y(?:MD?)?|MD?|D|H(?:ms?)?|h(?:ms?)?|m(?:i|s)?|a|A|s(?:s?i|dt)?|z|%|f(?:si)?|e|g|d|r(?:d|p)|p|P|RP)/g;
            REGEXP = result;
        }
        return result;
    };
    const toModifiedDatetime = (modifier, length, node) => {
        switch (modifier) {
            case "_":
                return new FormatNodePadding(length, " ", node);
            case "-":
                return node;
            default:
                return new FormatNodePadding(length, "0", node);
        }
    };
    const toModifiedNumber = (modifier, node) => {
        switch (modifier) {
            case "_": // space for non-negative numbers
                return new FormatNodeSpace(node);
            case "+": // plus sign for non-negative numbers
                return new FormatNodePlus(node);
            case "(": // parenthesis for the negative numbers
                return new FormatNodeParenthesis(node);
            default:
                return node;
        }
    };
    const toParsed = (format) => {
        let previousIndex = 0;
        let isDateRequired = false;
        const result = [];
        const regExp = getRegExp();
        while (true) {
            const matched = regExp.exec(format);
            if (matched != null) {
                const index = matched.index;
                if (previousIndex < index) {
                    result.push(new FormatNodeString(format.substring(previousIndex, index)));
                }
                previousIndex = index + matched[0].length;
                const all = matched[0];
                const modifier = matched[1];
                const precision = matched[2];
                const specifier = matched[3];
                switch (specifier) {
                    case "Y": // full year
                        isDateRequired = true;
                        result.push(new FormatNodeY());
                        break;
                    case "YM":
                        isDateRequired = true;
                        result.push(new FormatNodeY(), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()));
                        break;
                    case "YMD":
                        isDateRequired = true;
                        result.push(new FormatNodeY(), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "y": // short year: [0, 99]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodey()));
                        break;
                    case "yM":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodey()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()));
                        break;
                    case "yMD":
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodey()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeM()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "M": // month: [1, 12]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeM()));
                        break;
                    case "MD":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeM()), new FormatNodeString("/"), toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "D": // day of the month: [1, 31]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeD()));
                        break;
                    case "H": // 24-hour clock: [0, 23]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeH()));
                        break;
                    case "Hm":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeH()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()));
                        break;
                    case "Hms":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeH()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "h": // 12-hour clock: [1, 12]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeh()));
                        break;
                    case "hm":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeh()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()));
                        break;
                    case "hms":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodeh()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodem()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "m": // minute [0, 59]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodem()));
                        break;
                    case "ms":
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodem()), new FormatNodeString(":"), toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "mi": // milliseconds [0, 999]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 3, new FormatNodemi()));
                        break;
                    case "a": // am or pm
                        isDateRequired = true;
                        result.push(new FormatNodea());
                        break;
                    case "A": // AM or PM
                        isDateRequired = true;
                        result.push(new FormatNodeA());
                        break;
                    case "s": // seconds: [0, 61]
                        isDateRequired = true;
                        result.push(toModifiedDatetime(modifier, 2, new FormatNodes()));
                        break;
                    case "sdt":
                        isDateRequired = true;
                        result.push(new FormatNodesdt(new FormatNodeY(), toModifiedDatetime(modifier, 2, new FormatNodeM()), toModifiedDatetime(modifier, 2, new FormatNodeD()), toModifiedDatetime(modifier, 2, new FormatNodeH()), toModifiedDatetime(modifier, 2, new FormatNodem()), toModifiedDatetime(modifier, 2, new FormatNodes()), toModifiedDatetime(modifier, 3, new FormatNodemi())));
                        break;
                    case "z": // time zone
                        isDateRequired = true;
                        result.push(new FormatNodez());
                        break;
                    case "%": // a % literal
                        result.push(new FormatNodeString("%"));
                        break;
                    case "f": // fixed point notation
                        result.push(toModifiedNumber(modifier, new FormatNodef(precision)));
                        break;
                    case "e": // exponent notation
                        result.push(toModifiedNumber(modifier, new FormatNodee(precision)));
                        break;
                    case "g": // %f or %e
                        result.push(toModifiedNumber(modifier, new FormatNodeg(precision)));
                        break;
                    case "rd": // rounded decimal notation
                        result.push(toModifiedNumber(modifier, new FormatNoderd()));
                        break;
                    case "d": // decimal notation
                        result.push(toModifiedNumber(modifier, new FormatNoded()));
                        break;
                    case "P": // percent notation (Multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNodeP()));
                        break;
                    case "p": // percent notation (Not multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNodep()));
                        break;
                    case "RP": // percent notation (Multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNodeRP()));
                        break;
                    case "rp": // percent notation (Not multiplied by 100)
                        result.push(toModifiedNumber(modifier, new FormatNoderp()));
                        break;
                    case "fsi": // fixed point notation with a SI prefix
                        result.push(toModifiedNumber(modifier, new FormatNodefsi(precision)));
                        break;
                    case "ssi": // Step-based fixed point notation with a SI prefix
                        result.push(toModifiedNumber(modifier, new FormatNodessi(precision)));
                        break;
                    default:
                        result.push(new FormatNodeString(all));
                        break;
                }
            }
            else {
                if (previousIndex < format.length) {
                    result.push(new FormatNodeString(format.substring(previousIndex, format.length)));
                }
                break;
            }
        }
        return {
            nodes: result,
            date: isDateRequired
        };
    };
    /**
     * A NumberFormatter implementation class.
     */
    class NumberFormatterImpl {
        constructor(format) {
            const parsed = toParsed(format);
            this.date = parsed.date;
            this.nodes = parsed.nodes;
        }
        format(target, step) {
            const nodes = this.nodes;
            let date = NumberFormatterImpl.DATE;
            if (date == null) {
                date = new Date();
                NumberFormatterImpl.DATE = date;
            }
            if (this.date) {
                date.setTime(target);
            }
            let result = "";
            for (let i = 0, imax = nodes.length; i < imax; ++i) {
                result += nodes[i].format(target, step, date);
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An number formatter utility class.
     */
    class NumberFormatters {
        /**
         * Creates a number formatter of the given format.
         * Please refer to {@link NumberFormatter} for format details.
         *
         * @return A created number formatter
         */
        static create(format) {
            return new NumberFormatterImpl(format);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeChangeTextNumber extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.TEXT);
            this.number = EShapeActionExpressions.ofNumber(value.value);
            this.formatters = new Map();
        }
        getFormatter(shape, runtime) {
            const formatters = this.formatters;
            const text = runtime.text.value;
            let result = formatters.get(text);
            if (result === undefined) {
                result = this.newFormatter(text);
                formatters.set(text, result);
            }
            return result;
        }
        newFormatter(format) {
            format = format.trim();
            if (0 < format.length) {
                return NumberFormatters.create(format);
            }
            return null;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const value = this.number(shape, time, EShapeActionEnvironment);
                const formatter = this.getFormatter(shape, runtime);
                shape.text.value = formatter != null ? formatter.format(value, 0) : String(value);
                runtime.written |= this.reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeChangeTextText extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.TEXT);
            this.text = EShapeActionExpressions.ofString(value.value);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                shape.text.value = this.text(shape, time, EShapeActionEnvironment);
                runtime.written |= this.reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueChangeTextType = {
        TEXT: 0,
        NUMBER: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueChangeText extends EShapeActionValueSubtyped {
        constructor(subtype, condition, value) {
            super(EShapeActionValueType.CHANGE_TEXT, condition, subtype);
            this.value = value;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueChangeText &&
                this.value === value.value);
        }
        toRuntime() {
            switch (this.subtype) {
                case EShapeActionValueChangeTextType.TEXT:
                    return new EShapeActionRuntimeChangeTextText(this);
                case EShapeActionValueChangeTextType.NUMBER:
                    return new EShapeActionRuntimeChangeTextNumber(this);
            }
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const valueId = manager.addResource(this.value);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${valueId}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const value = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueChangeText(serialized[2], condition, value);
        }
    }

    /**
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DDiagram} controller open type.
     */
    const DDiagramBaseControllerOpenType = {
        DIAGRAM: 0,
        PAGE: 1,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeDataMapperImpl {
        constructor(source) {
            this._sources = this.newSources(source);
        }
        map(value, destinations, initial) {
            const sources = this._sources;
            if (sources == null) {
                return false;
            }
            const valueId = value.id;
            const target = valueId.toLowerCase();
            const targetLength = target.length;
            if (targetLength !== valueId.length) {
                return false;
            }
            const first = sources[0];
            const firstLength = first.length;
            if (firstLength !== 0 && target.indexOf(first) !== 0) {
                return false;
            }
            const spans = EShapeDataMapperImpl.SPANS;
            spans[0] = 0;
            spans[1] = firstLength;
            const sourcesLength = sources.length;
            for (let i = 1; i < sourcesLength; ++i) {
                const ispan = i << 1;
                const source = sources[i];
                const sourceLength = source.length;
                if (sourceLength === 0) {
                    spans[ispan] = targetLength;
                    spans[ispan + 1] = targetLength;
                }
                else {
                    const index = target.indexOf(source, spans[ispan - 1]);
                    if (index < 0) {
                        return false;
                    }
                    spans[ispan] = index;
                    spans[ispan + 1] = index + sourceLength;
                }
            }
            // Update the ID
            if (destinations != null) {
                const destinationsLength = destinations.length;
                let id = "";
                for (let i = 0, imax = sourcesLength; i < imax; ++i) {
                    const id0 = i < destinationsLength ? destinations[i] : sources[i];
                    const ispan = i << 1;
                    const s0 = spans[ispan + 1];
                    const s1 = spans[ispan + 2];
                    const id1 = valueId.substring(s0, i + 1 < imax ? s1 : targetLength);
                    id += id0 + id1;
                }
                value.id = id;
            }
            // Update the initial value
            if (0 < initial.length) {
                value.initial = initial;
            }
            return true;
        }
        newSources(source) {
            if (source == null) {
                return null;
            }
            const trimmed = source.trim();
            if (trimmed.length <= 0) {
                return null;
            }
            return trimmed.toLowerCase().split(EShapeDataMapperImpl.WILDCARD);
        }
        static split(target) {
            if (target == null) {
                return null;
            }
            const trimmed = target.trim();
            if (trimmed.length <= 0) {
                return null;
            }
            return trimmed.split(this.WILDCARD);
        }
    }
    EShapeDataMapperImpl.WILDCARD = "*";
    EShapeDataMapperImpl.SPANS = [];

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeResourceManagerDeserialization {
        constructor(serialized, pieces, pieceData, mode, depth) {
            this.resources = serialized.resources;
            this.data = serialized.data || serialized.tags || serialized.resources;
            this.pieces = pieces;
            this.pieceData = pieceData;
            this.mode = mode;
            this.depth = depth;
            this._actions = new Map();
            this._fills = new Map();
            this._strokes = new Map();
            this._data = new Map();
            this._dataValues = new Map();
            this._dataMapping = new Map();
            this._dataMappers = new Map();
            this._dataDestinations = new Map();
            this._dataSystem = new Map();
            this._ranges = new Map();
            this._aligns = new Map();
            this._margins = new Map();
            this._texts = new Map();
            this._textOutlines = new Map();
            this._capabilities = new Map();
            this._extensions = new Map();
        }
        getAction(id) {
            return this._actions.get(id);
        }
        setAction(id, action) {
            this._actions.set(id, action);
        }
        getFill(id) {
            return this._fills.get(id);
        }
        setFill(id, fill) {
            this._fills.set(id, fill);
        }
        getStroke(id) {
            return this._strokes.get(id);
        }
        setStroke(id, stroke) {
            this._strokes.set(id, stroke);
        }
        getData(id) {
            return this._data.get(id);
        }
        setData(id, data) {
            this._data.set(id, data);
        }
        getDataValue(id) {
            return this._dataValues.get(id);
        }
        setDataValue(id, dataValue) {
            this._dataValues.set(id, dataValue);
        }
        getDataMapping(id) {
            return this._dataMapping.get(id);
        }
        setDataMapping(id, dataMapping) {
            this._dataMapping.set(id, dataMapping);
        }
        getDataMapper(source) {
            const dataMappers = this._dataMappers;
            let result = dataMappers.get(source);
            if (result === undefined) {
                result = new EShapeDataMapperImpl(source);
                dataMappers.set(source, result);
            }
            return result;
        }
        getDataDestination(destination) {
            const dataDestinations = this._dataDestinations;
            let result = dataDestinations.get(destination);
            if (result === undefined) {
                result = EShapeDataMapperImpl.split(destination);
                dataDestinations.set(destination, result);
            }
            return result;
        }
        getDataSystem(id) {
            return this._dataSystem.get(id);
        }
        setDataSystem(id, dataSystem) {
            this._dataSystem.set(id, dataSystem);
        }
        getRange(id) {
            return this._ranges.get(id);
        }
        setRange(id, range) {
            this._ranges.set(id, range);
        }
        getAlign(id) {
            return this._aligns.get(id);
        }
        setAlign(id, align) {
            this._aligns.set(id, align);
        }
        getMargin(id) {
            return this._margins.get(id);
        }
        setMargin(id, margin) {
            this._margins.set(id, margin);
        }
        getText(id) {
            return this._texts.get(id);
        }
        setText(id, text) {
            this._texts.set(id, text);
        }
        getTextOutline(id) {
            return this._textOutlines.get(id);
        }
        setTextOutline(id, textOutline) {
            this._textOutlines.set(id, textOutline);
        }
        getCapability(id) {
            return this._capabilities.get(id);
        }
        setCapability(id, capability) {
            this._capabilities.set(id, capability);
        }
        getExtension(id) {
            return this._extensions.get(id);
        }
        setExtension(id, extension) {
            this._extensions.set(id, extension);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeResourceManagerDeserializationMode = {
        VIEWER: 0,
        EDITOR_DATA_MAPPED: 1,
        EDITOR: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeAcceptorEdgeSide = {
        NONE: 0,
        TOP: 1,
        RIGHT: 2,
        BOTTOM: 4,
        LEFT: 8,
        ALL: 15
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeAcceptorEdgeType = {
        TAIL: 1,
        HEAD: 2,
        ALL: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeCircle extends EShapePrimitive {
        constructor(type = EShapeType.CIRCLE) {
            super(type);
        }
        clone() {
            return new EShapeCircle(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            if (super.containsAbsBBox(x, y, ax, ay)) {
                return hitTestCircle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        }
    }

    class EShapeEmbeddedAcceptorEdge extends EShapeCircle {
        constructor(type = EShapeType.EMBEDDED_ACCEPTOR_EDGE) {
            super(type);
            this._subtype = EShapeAcceptorEdgeType.HEAD;
            this._side = EShapeAcceptorEdgeSide.ALL;
            this._vvisible = true;
        }
        get subtype() {
            return this._subtype;
        }
        set subtype(subtype) {
            this._subtype = subtype;
        }
        get side() {
            return this._side;
        }
        set side(side) {
            this._side = side;
        }
        /**
         * True if visible in the viewer mode.
         */
        get vvisible() {
            return this._vvisible;
        }
        set vvisible(vvisible) {
            this._vvisible = vvisible;
        }
        clone() {
            return new EShapeEmbeddedAcceptorEdge(this.type).copy(this);
        }
        copy(source, part = EShapeCopyPart.ALL) {
            super.copy(source, part);
            if (source instanceof EShapeEmbeddedAcceptorEdge) {
                this._subtype = source.subtype;
                this._side = source.side;
                this._vvisible = source.vvisible;
            }
            return this;
        }
        serialize(manager) {
            const result = super.serialize(manager);
            result[15] = this._subtype | (this._side << 2) | (this._vvisible ? 1 << 6 : 0);
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeCapabilities {
        static get(type) {
            const capability = this.mappings[type];
            if (capability != null) {
                return capability;
            }
            return EShapeCapability.PRIMITIVE;
        }
        static contains(shape, target) {
            if (shape != null) {
                let capability = this.get(shape.type);
                const shapeCapability = shape.getCapability();
                if (shapeCapability != null) {
                    capability &= ~shapeCapability.removed;
                    capability |= shapeCapability.added;
                    capability &= ~shapeCapability.locked;
                }
                return (capability & target) === target;
            }
            return false;
        }
        static set(type, capability) {
            this.mappings[type] = capability;
        }
    }
    EShapeCapabilities.mappings = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toSizeNormalized = (size) => {
        const THRESHOLD = 0.001;
        if (Math.abs(size) < THRESHOLD) {
            return size < 0 ? -THRESHOLD : +THRESHOLD;
        }
        return size;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupSizeLayout {
        constructor(shape, bx, by) {
            this.shape = shape;
            // Base group size
            this.base = new pixi_js.Point(bx, by);
            // Base shape size
            const size = shape.size;
            this.shapeBase = new pixi_js.Point(size.x, size.y);
            // Transform
            this.transform = new pixi_js.Matrix();
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
            this.capable =
                EShapeCapabilities.contains(shape, EShapeCapability.POSITION) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.WIDTH) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.HEIGHT) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.ROTATION) &&
                    EShapeCapabilities.contains(shape, EShapeCapability.SKEW);
        }
        isCompatible(shape) {
            return this.shape === shape;
        }
        reset(shape, baseX, baseY) {
            this.base.set(baseX, baseY);
            // Base shape size
            const size = shape.size;
            this.shapeBase.copyFrom(size);
            // Transform
            shape.updateTransform();
            shape.transform.localTransform.copyTo(this.transform);
        }
        update(shape, baseX, baseY, pivotX, pivotY) {
            if (!this.capable) {
                return;
            }
            const sx = baseX / this.base.x;
            const sy = baseY / this.base.y;
            const childBase = this.shapeBase;
            const transform = EShapeGroupSizeLayout.WORK_TRANSFORM;
            transform
                .identity()
                .append(this.transform)
                .translate(-pivotX, -pivotY)
                .scale(sx, sy)
                .translate(+pivotX, +pivotY);
            shape.lock(EShapeLockPart.TRANSFORM_AND_UPLOADED);
            this.apply(shape, transform, EShapeCapability.ALL, childBase);
            shape.unlock(EShapeLockPart.TRANSFORM_CHILD, false);
            shape.unlock(EShapeLockPart.TRANSFORM_THIS |
                EShapeLockPart.TRANSFORM_PARENT |
                EShapeLockPart.UPLOADED, true);
        }
        apply(shape, localTransform, capability, size) {
            // Reconstruct the position, the rotation and the size
            const a = localTransform.a;
            const b = localTransform.b;
            const c = localTransform.c;
            const d = localTransform.d;
            const tx = localTransform.tx;
            const ty = localTransform.ty;
            // Transform
            const transform = shape.transform;
            // Capability
            const cposition = !!(capability & EShapeCapability.POSITION);
            const crotation = !!(capability & EShapeCapability.ROTATION);
            const cskew = !!(capability & EShapeCapability.SKEW);
            const cwidth = !!(capability & EShapeCapability.WIDTH);
            const cheight = !!(capability & EShapeCapability.HEIGHT);
            // Rotation and skew
            if (crotation || cskew) {
                // Rotation
                const rx = Math.atan2(-c, d); // rotation - skewX
                const ry = Math.atan2(+b, a); // rotation + skewY
                if (crotation) {
                    transform.rotation = (rx + ry) * 0.5; // Here, assumes `skewX` === `skewY`
                }
                // Skew
                if (cskew) {
                    const skew = (ry - rx) * 0.5;
                    transform.skew.set(skew, skew);
                }
            }
            // Position
            if (cposition) {
                // Assumes the pivot is invariant.
                // tx = position.x - (a * px + c * py)
                // ty = position.y - (b * px + d * py)
                //
                // Thus,
                // position.x = tx + (a * px + c * py)
                // position.y = ty + (b * px + d * py)
                const pivot = transform.pivot;
                const px = pivot.x;
                const py = pivot.y;
                transform.position.set(tx + (a * px + c * py), ty + (b * px + d * py));
            }
            // Scale
            if (size != null && (cwidth || cheight)) {
                const w = toSizeNormalized(size.x * Math.sqrt(a * a + b * b));
                const h = toSizeNormalized(size.y * Math.sqrt(c * c + d * d));
                const s = shape.size;
                if (cwidth && cheight) {
                    s.set(w, h);
                }
                else if (cwidth) {
                    s.x = w;
                }
                else {
                    s.y = h;
                }
            }
        }
    }
    EShapeGroupSizeLayout.WORK_TRANSFORM = new pixi_js.Matrix();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupSizeEditor {
        constructor(parent, x, y, isFittable) {
            this._workRectForCalcRect = new pixi_js.Rectangle();
            this._workRectForFit = new pixi_js.Rectangle();
            this._parent = parent;
            this._layouts = [];
            this._size = new pixi_js.Point(x, y);
            this._isFittable = isFittable;
        }
        init() {
            return this;
        }
        get x() {
            return this._size.x;
        }
        set x(x) {
            const size = this._size;
            if (size.x !== x) {
                const ox = size.x;
                size.x = x;
                this.onChange(ox, size.y);
            }
        }
        get y() {
            return this._size.y;
        }
        set y(y) {
            const size = this._size;
            if (size.y !== y) {
                const oy = size.y;
                size.y = y;
                this.onChange(size.x, oy);
            }
        }
        set(x, y) {
            let isChanged = false;
            const size = this._size;
            const ox = size.x;
            const oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        }
        clone() {
            const size = this._size;
            return new EShapeGroupSizeEditor(this._parent, size.x, size.y, this._isFittable);
        }
        copy() {
            // DO NOTHING
        }
        copyFrom(point) {
            const x = point.x;
            const y = point.y;
            const size = this._size;
            const ox = size.x;
            const oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        }
        copyTo(point) {
            return this._size.copyTo(point);
        }
        equals(point) {
            return this._size.equals(point);
        }
        fit() {
            if (this._isFittable) {
                this.doFit();
            }
            return this;
        }
        doFit() {
            const parent = this._parent;
            parent.lock(EShapeLockPart.TRANSFORM);
            // Calculate the rect
            const rect = this.calcRect(this._workRectForFit);
            // Set size
            const size = this._size;
            size.set(rect.width, rect.height);
            // Calculating new position & pivot
            //
            // cx := rect.x + rect.width * 0.5
            // cy := rect.y + rect.height * 0.5
            //
            // Since the local transform need to be unchanged:
            //
            // | a c tx |   | a c px' - (a * pvx' + c * pvy') |
            // | b d ty | = | b d py' - (b * pvx' + d * pvy') |
            // | 0 0 1  |   | 0 0 1                           |
            //
            // Here, (px', py') and (pvx', pvy') are the new position
            // and the new pivot, respectively.
            //
            // Setting the new pivot (pvx', pvy') to (cx, cy) leads to
            //
            // | a c tx |   | a c px' - (a * cx + c * cy) |
            // | b d ty | = | b d py' - (b * cx + d * cy) |
            // | 0 0 1  |   | 0 0 1                       |
            //
            // tx = px - (a * pvx + c * pvy) = px' - (a * cx + c * cy)
            // ty = py - (b * pvx + d * pvy) = py' - (b * cx + d * cy)
            //
            // Thus, the new position (px', py') is
            //
            // px' = px + (a * (cx - pvx) + c * (cy - pvy))
            // py' = py + (b * (cy - pvx) + d * (cy - pvy))
            parent.updateTransform();
            const transform = parent.transform;
            const cx = rect.x + rect.width * 0.5;
            const cy = rect.y + rect.height * 0.5;
            const position = transform.position;
            const localTransform = transform.localTransform;
            const a = localTransform.a;
            const b = localTransform.b;
            const c = localTransform.c;
            const d = localTransform.d;
            const pivot = transform.pivot;
            const pvx = pivot.x;
            const pvy = pivot.y;
            const dpvx = cx - pvx;
            const dpvy = cy - pvy;
            position.set(position.x + (a * dpvx + c * dpvy), position.y + (b * dpvx + d * dpvy));
            pivot.set(cx, cy);
            // Reset the data
            this.reset(parent.children, this._layouts, size);
            //
            parent.unlock(EShapeLockPart.TRANSFORM_CHILD | EShapeLockPart.TRANSFORM_THIS, true);
            parent.unlock(EShapeLockPart.TRANSFORM_PARENT, false);
        }
        reset(children, layouts, size) {
            for (let i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                const child = children[i];
                const layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.reset(child, size.x, size.y);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            if (children.length < layouts.length) {
                layouts.length = children.length;
            }
        }
        calcRect(result) {
            const parent = this._parent;
            const children = parent.children;
            if (children.length <= 0) {
                result.x = 0;
                result.y = 0;
                result.width = 0;
                result.height = 0;
            }
            else {
                const workRect = this._workRectForCalcRect;
                children[0].getBoundsLocal(false, result);
                for (let i = 1, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    child.getBoundsLocal(false, workRect);
                    result.enlarge(workRect);
                }
            }
            return result;
        }
        onChange(ox, oy) {
            const parent = this._parent;
            const size = this._size;
            const pivot = parent.transform.pivot;
            this.onChange_(parent.children, this._layouts, size.x, size.y, pivot.x, pivot.y, ox, oy);
            parent.onSizeChange();
        }
        onChange_(children, layouts, sx, sy, px, py, ox, oy) {
            for (let i = 0, imax = Math.min(layouts.length, children.length); i < imax; ++i) {
                const child = children[i];
                const layout = layouts[i];
                if (layout.isCompatible(child)) {
                    layout.update(child, sx, sy, px, py);
                }
                else {
                    layouts.length = i;
                    break;
                }
            }
            for (let i = layouts.length, imax = children.length; i < imax; ++i) {
                const child = children[i];
                const layout = this.newLayout(child, ox, oy);
                layout.update(child, sx, sy, px, py);
                layouts.push(layout);
            }
            if (layouts.length !== children.length) {
                layouts.length = children.length;
            }
        }
        newLayout(shape, ox, oy) {
            return shape.layout || new EShapeGroupSizeLayout(shape, ox, oy);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupSizeViewer {
        constructor(parent, x, y, bx, by) {
            this._parent = parent;
            this._x = x;
            this._y = y;
            this._base = new pixi_js.Point(bx, by);
        }
        get x() {
            return this._x;
        }
        set x(x) {
            if (this._x !== x) {
                this._x = x;
                this.onChange();
            }
        }
        get y() {
            return this._y;
        }
        set y(y) {
            if (this._y !== y) {
                this._y = y;
                this.onChange();
            }
        }
        get base() {
            return this._base;
        }
        init() {
            this._base.copyFrom(this);
            this.onChange();
            return this;
        }
        clone() {
            const base = this._base;
            return new EShapeGroupSizeViewer(this._parent, this._x, this._y, base.x, base.y);
        }
        set(x, y) {
            let isChanged = false;
            if (x != null && this._x !== x) {
                this._x = x;
                isChanged = true;
            }
            if (y != null && this._y !== y) {
                this._y = y;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        }
        copyFrom(p) {
            if (p instanceof EShapeGroupSizeViewer) {
                this._base.copyFrom(p.base);
            }
            if (this._x !== p.x || this._y !== p.y) {
                this._x = p.x;
                this._y = p.y;
                this.onChange();
            }
            return this;
        }
        copyTo(p) {
            if (p instanceof EShapeGroupSizeViewer) {
                this._base.copyTo(p.base);
            }
            p.set(this._x, this._y);
            return p;
        }
        equals(p) {
            return p.x === this._x && p.y === this._y;
        }
        fit() {
            return this;
        }
        onChange() {
            const base = this._base;
            this._parent.transform.scale.set(this._x / base.x, this._y / base.y);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupFillViewer {
        constructor() {
            // DO NOTHING
        }
        get enable() {
            return true;
        }
        set enable(enable) {
            // DO NOTHING
        }
        get color() {
            return 0xffffff;
        }
        set color(color) {
            // DO NOTHING
        }
        get alpha() {
            return 1.0;
        }
        set alpha(alpha) {
            // DO NOTHING
        }
        copy(target) {
            // DO NOTHING
        }
        set(enable, color, alpha) {
            // DO NOTHING
        }
        clone() {
            return new EShapeGroupFillViewer();
        }
        toObject() {
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        }
        serialize(manager) {
            return -1;
        }
        deserialize(target, manager) {
            // DO NOTHING
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupStrokeViewer {
        constructor() {
            // DO NOTHING
        }
        get enable() {
            return false;
        }
        set enable(enable) {
            // DO NOTHING
        }
        get color() {
            return 0xffffff;
        }
        set color(color) {
            // DO NOTHING
        }
        get alpha() {
            return 1.0;
        }
        set alpha(alpha) {
            // DO NOTHING
        }
        get width() {
            return 1.0;
        }
        set width(width) {
            // DO NOTHING
        }
        get align() {
            return 0.0;
        }
        set align(width) {
            // DO NOTHING
        }
        get side() {
            return EShapeStrokeSide.NONE;
        }
        set side(side) {
            // DO NOTHING
        }
        get style() {
            return EShapeStrokeStyle.NONE;
        }
        set style(style) {
            // DO NOTHING
        }
        copy(target) {
            // DO NOTHING
        }
        set(enable, color, alpha, width, align, side, style) {
            // DO NOTHING
        }
        clone() {
            return new EShapeGroupStrokeViewer();
        }
        toObject() {
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE,
                style: EShapeStrokeStyle.NONE
            };
        }
        serialize(manager) {
            return -1;
        }
        deserialize(target, manager) {
            //
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupViewer extends EShapeBase {
        constructor(mode, depth, type) {
            super(type);
            this._mode = mode;
            this._depth = depth;
            const data = this.newData();
            this.data = data;
            this.tag = data;
            this.size = this.newGroupSize(mode, depth);
            this.fill = this.newGroupFill();
            this.stroke = this.newGroupStroke();
            this.text = this.newGroupText();
        }
        get mode() {
            return this._mode;
        }
        get depth() {
            return this._depth;
        }
        newGroupSize(mode, depth) {
            const sizeX = EShapeDefaults.SIZE_X;
            const sizeY = EShapeDefaults.SIZE_Y;
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        }
        isGroupSizeFittable() {
            return true;
        }
        newData() {
            return new EShapeDataImpl();
        }
        newGroupFill() {
            return new EShapeGroupFillViewer();
        }
        newGroupStroke() {
            return new EShapeGroupStrokeViewer();
        }
        newGroupText() {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.TEXT_COLOR, EShapeDefaults.TEXT_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        }
        getBoundsSize() {
            const size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                return size.base;
            }
            else {
                return size;
            }
        }
        onChildTransformChange() {
            super.onChildTransformChange();
            this.size.fit();
        }
        get corner() {
            return EShapeCorner.NONE;
        }
        set corner(corner) {
            // DO NOTHING
        }
        get gradient() {
            return undefined;
        }
        set gradient(gradient) {
            // DO NOTHING
        }
        serializeGradient(manager) {
            return -1;
        }
        get radius() {
            return 0;
        }
        set radius(radius) {
            // DO NOTHING
        }
        get image() {
            return undefined;
        }
        set image(image) {
            // DO NOTHING
        }
        serializeImage(manager) {
            return -1;
        }
        get points() {
            return undefined;
        }
        set points(points) {
            // DO NOTHING
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            return false;
        }
    }

    class EShapeEmbedded extends EShapeGroupViewer {
        constructor(name, mode, depth, type = EShapeType.EMBEDDED) {
            super(mode, depth, type);
            this._name = name;
            this._depth = depth;
        }
        get name() {
            return this._name;
        }
        get edges() {
            var _a;
            return ((_a = this._edges) !== null && _a !== void 0 ? _a : (this._edges = this.newEdges()));
        }
        newEdges() {
            const result = new Map();
            const layers = this.children;
            if (layers != null) {
                const s = this.size;
                const sx = s.x;
                const sy = s.y;
                const sxh = sx * 0.5;
                const syh = sy * 0.5;
                for (let i = 0, imax = layers.length; i < imax; ++i) {
                    const layer = layers[i];
                    const lp = layer.transform.position;
                    const lpx = lp.x + sxh;
                    const lpy = lp.y + syh;
                    const children = layer.children;
                    for (let j = 0, jmax = children.length; j < jmax; ++j) {
                        const child = children[j];
                        if (child instanceof EShapeEmbeddedAcceptorEdge) {
                            child.transform.updateLocalTransform();
                            const clt = child.transform.localTransform;
                            result.set(child.id, {
                                type: child.subtype,
                                x: this.toEdgePosition(lpx, clt.tx, sxh, sx),
                                y: this.toEdgePosition(lpy, clt.ty, syh, sy),
                                normal: this.toEdgeNormal(-clt.c, -clt.d),
                                size: {
                                    x: 0,
                                    y: 0
                                },
                                side: child.side
                            });
                        }
                    }
                }
            }
            return result;
        }
        toEdgePosition(lp, cp, sh, s) {
            if (0.00001 < Math.abs(s)) {
                return (lp + cp - sh) / s;
            }
            return 0;
        }
        toEdgeNormal(x, y) {
            const d = x * x + y * y;
            if (0.00001 < d) {
                const f = 1 / d;
                return {
                    x: x * f,
                    y: y * f
                };
            }
            return {
                x: 0,
                y: -1
            };
        }
        isGroupSizeFittable() {
            return false;
        }
        newGroupSize(mode, depth) {
            const sizeX = EShapeDefaults.SIZE_X;
            const sizeY = EShapeDefaults.SIZE_Y;
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER && depth <= 0) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        }
        clone() {
            const result = this.newClone().copy(this);
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            return result;
        }
        newClone() {
            const constructor = this.constructor;
            return new constructor(this._name, this._mode, this._depth, this.type);
        }
        serializeChildren(manager) {
            return [];
        }
        serializeImage(manager) {
            return -1;
        }
        serializeGradient(manager) {
            return -1;
        }
        serialize(manager) {
            const result = super.serialize(manager);
            result[15] = manager.addPiece(this._name);
            return result;
        }
        addUuid(manager) {
            this.uuid = manager.addUuid(this.uuid);
        }
        updateUuid(manager) {
            this.uuid = manager.updateUuid(this.uuid);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeUuidMappingImpl {
        constructor(shapes) {
            this._shapes = shapes;
        }
        find(uuid) {
            return this.getUuidToShape().get(uuid);
        }
        getUuidToShape() {
            let result = this._uuidToShape;
            if (result == null) {
                result = this.newUuidToShape();
                this._uuidToShape = result;
            }
            return result;
        }
        newUuidToShape() {
            const result = new Map();
            this.fillUuidToShape(this._shapes, result);
            return result;
        }
        fillUuidToShape(shapes, result) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                result.set(shape.uuid, shape);
                if (!(shape instanceof EShapeEmbedded)) {
                    const children = shape.children;
                    if (0 < children.length) {
                        this.fillUuidToShape(children, result);
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserialize = (item, manager) => {
        const deserializer = EShapeDeserializers[item[0]] || EShapeDeserializers[EShapeType.NULL];
        if (deserializer != null) {
            const result = deserializer(item, manager);
            if (result != null) {
                return result;
            }
        }
        throw new Error("Missing shape deserializers");
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeAll = (serializeds, manager) => {
        const shapes = [];
        for (let i = 0, imax = serializeds.length; i < imax; ++i) {
            shapes.push(deserialize(serializeds[i], manager));
        }
        if (0 < shapes.length) {
            return Promise.all(shapes).then((resolved) => {
                callOnDeserialized(serializeds, resolved, new EShapeUuidMappingImpl(resolved), manager);
                return resolved;
            });
        }
        return null;
    };
    const callOnDeserialized = (serializeds, shapes, mapping, manager) => {
        for (let i = 0, imax = serializeds.length; i < imax; ++i) {
            const serialized = serializeds[i];
            const shape = shapes[i];
            const onDeserialized = EShapeOnDeserializeds[serialized[0]];
            if (onDeserialized) {
                onDeserialized(serialized, shape, mapping, manager);
            }
            callOnDeserialized(serialized[20], shape.children, mapping, manager);
        }
    };

    class EShapeEmbeddedDatum {
        constructor(name, width, height, layer) {
            this.name = name;
            this.width = width;
            this.height = height;
            this.layer = layer;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toEnum = (target, te) => {
        return isString(target) ? te[target] : target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeAcceptorImpl {
        constructor() {
            this._edges = new Map();
        }
        add(id, type, x, y, nx, ny, sx, sy, side) {
            this._edges.set(id, {
                type: toEnum(type, EShapeAcceptorEdgeType),
                x,
                y,
                normal: this.toNormal(x, y, nx, ny),
                size: {
                    x: sx !== null && sx !== void 0 ? sx : 0,
                    y: sy !== null && sy !== void 0 ? sy : 0
                },
                side: this.toSide(side)
            });
            return true;
        }
        toNormal(x, y, nx, ny) {
            if (nx != null && ny != null) {
                return {
                    x: nx,
                    y: ny
                };
            }
            else {
                const d = x * x + y * y;
                if (0.00001 < d) {
                    const m = 1 / Math.sqrt(d);
                    return {
                        x: x * m,
                        y: y * m
                    };
                }
                else {
                    return {
                        x: 0,
                        y: 0
                    };
                }
            }
        }
        toSide(side) {
            if (side == null) {
                return EShapeAcceptorEdgeSide.TOP;
            }
            else if (isNumber(side)) {
                return side;
            }
            else if (isString(side)) {
                return toEnum(side, EShapeAcceptorEdgeSide);
            }
            else {
                let result = EShapeAcceptorEdgeSide.NONE;
                for (let i = 0, imax = side.length; i < imax; ++i) {
                    result |= toEnum(side[i], EShapeAcceptorEdgeSide);
                }
                return result;
            }
        }
        remove(id) {
            const edges = this._edges;
            const result = edges.get(id);
            if (result != null) {
                edges.delete(id);
                return result;
            }
            return null;
        }
        size() {
            return this._edges.size;
        }
        get(shape, id) {
            return this._edges.get(id) || null;
        }
        each(shape, iteratee) {
            this._edges.forEach(iteratee);
            return this;
        }
        contains(id) {
            return this._edges.has(id);
        }
        clear() {
            const edges = this._edges;
            if (0 < edges.size) {
                edges.clear();
                return true;
            }
            return false;
        }
    }

    class EShapeEmbeddedAcceptor extends EShapeAcceptorImpl {
        get(shape, id) {
            const edges = this.getEdges(shape);
            if (edges != null) {
                const edge = edges.get(id);
                if (edge != null) {
                    return edge;
                }
            }
            return super.get(shape, id);
        }
        each(shape, iteratee) {
            const edges = this.getEdges(shape);
            if (edges != null) {
                edges.forEach((edge, id) => {
                    iteratee(edge, id);
                });
            }
            return super.each(shape, iteratee);
        }
        getEdges(shape) {
            if (shape instanceof EShapeEmbedded) {
                return shape.edges;
            }
            return null;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeAcceptors {
        static set(type, acceptor) {
            let acceptors = this._acceptors;
            if (acceptors == null) {
                acceptors = new Map();
                this._acceptors = acceptors;
            }
            acceptors.set(type, acceptor);
        }
        static get(type) {
            var _a;
            const acceptors = this._acceptors;
            if (acceptors != null) {
                const acceptor = acceptors.get(type);
                if (acceptor != null) {
                    return acceptor;
                }
            }
            const defaults = ((_a = this._defaults) !== null && _a !== void 0 ? _a : (this._defaults = new Map()));
            switch (type) {
                case EShapeType.EMBEDDED:
                    let embedded = defaults.get(type);
                    if (embedded == null) {
                        embedded = this.newDefaultEmbedded();
                        defaults.set(type, embedded);
                    }
                    return embedded;
                case EShapeType.EMBEDDED_ACCEPTOR_EDGE:
                    let edge = defaults.get(type);
                    if (edge == null) {
                        edge = this.newDefaultEmbeddedAcceptorEdge();
                        defaults.set(type, edge);
                    }
                    return edge;
                default:
                    let other = defaults.get(null);
                    if (other == null) {
                        other = this.newDefaultOther();
                        defaults.set(null, other);
                    }
                    return other;
            }
        }
        static newDefaultEmbedded() {
            return this.initDefault(new EShapeEmbeddedAcceptor());
        }
        static newDefaultEmbeddedAcceptorEdge() {
            const result = new EShapeAcceptorImpl();
            result.add("CENTER", EShapeAcceptorEdgeType.ALL, 0, 0, 0, 0);
            return result;
        }
        static newDefaultOther() {
            return this.initDefault(new EShapeAcceptorImpl());
        }
        static initDefault(result) {
            const s = 1 / Math.sqrt(2);
            result.add("TOP", EShapeAcceptorEdgeType.ALL, 0, -0.5, 0, -1);
            result.add("LEFT", EShapeAcceptorEdgeType.ALL, -0.5, 0, -1, 0);
            result.add("RIGHT", EShapeAcceptorEdgeType.ALL, 0.5, 0, 1, 0);
            result.add("BOTTOM", EShapeAcceptorEdgeType.ALL, 0, 0.5, 0, 1);
            result.add("CENTER", EShapeAcceptorEdgeType.ALL, 0, 0, 0, 0);
            result.add("TOP_LEFT", EShapeAcceptorEdgeType.ALL, -0.5, -0.5, -s, -s);
            result.add("TOP_RIGHT", EShapeAcceptorEdgeType.ALL, 0.5, -0.5, s, -s);
            result.add("BOTTOM_LEFT", EShapeAcceptorEdgeType.ALL, -0.5, 0.5, -s, s);
            result.add("BOTTOM_RIGHT", EShapeAcceptorEdgeType.ALL, 0.5, 0.5, s, s);
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectorEdgeAcceptorImpl {
        constructor(parent) {
            this._parent = parent;
            this._shape = null;
            this._edge = null;
            this._x = null;
            this._y = null;
        }
        get shape() {
            return this._shape;
        }
        set shape(shape) {
            this.set(shape);
        }
        get edge() {
            return this._edge;
        }
        set edge(edge) {
            this.set(undefined, edge);
        }
        get x() {
            return this._x;
        }
        set x(x) {
            this.set(undefined, undefined, x);
        }
        get y() {
            return this._y;
        }
        set y(y) {
            this.set(undefined, undefined, undefined, y);
        }
        copy(source) {
            return this.set(source.shape, source.edge, source.x, source.y);
        }
        set(shape, edge, x, y) {
            let isChanged = false;
            if (shape !== undefined && this._shape !== shape) {
                this._shape = shape;
                isChanged = true;
            }
            if (edge !== undefined && this._edge !== edge) {
                this._edge = edge;
                isChanged = true;
            }
            if (x !== undefined && this._x !== x) {
                this._x = x;
                isChanged = true;
            }
            if (y !== undefined && this._y !== y) {
                this._y = y;
                isChanged = true;
            }
            if (isChanged) {
                this._parent.onAcceptorChange();
            }
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectorEdgeImpl {
        constructor(parent, onChange) {
            this._parent = parent;
            this._onChange = onChange;
            this._acceptor = new EShapeConnectorEdgeAcceptorImpl(this);
            this._acceptorTransformNew = new pixi_js.Matrix();
            this._acceptorTransformOld = new pixi_js.Matrix();
            this._hasAcceptorTransformOld = false;
            this._local = new pixi_js.ObservablePoint(() => {
                this.onLocalChange();
            }, undefined);
            this._localIdRequired = 0;
            this._localId = 0;
            this._normal = new pixi_js.ObservablePoint(() => {
                this.onNormalChange();
            }, undefined);
            this._normalIdRequired = 0;
            this._normalId = 0;
            this._side = EShapeAcceptorEdgeSide.TOP;
            this._margin = 0;
            this._other = null;
            this._lockCount = 0;
            this._isAcceptorChanged = false;
            this._isLocalChanged = false;
            this._isNormalChanged = false;
            this._isOtherChanged = false;
        }
        lock() {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isAcceptorChanged = false;
                this._isLocalChanged = false;
                this._isNormalChanged = false;
                this._isOtherChanged = false;
            }
        }
        unlock() {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                let isChanged = false;
                if (this._isLocalChanged) {
                    this._localIdRequired += 1;
                    this._localId = this._localIdRequired;
                    isChanged = true;
                }
                if (this._isNormalChanged) {
                    this._normalIdRequired += 1;
                    this._normalId = this._normalIdRequired;
                    isChanged = true;
                }
                if (this._isOtherChanged) {
                    isChanged = true;
                }
                if (this._isAcceptorChanged) {
                    this._hasAcceptorTransformOld = false;
                    if (!this._isLocalChanged) {
                        this._localIdRequired += 1;
                    }
                    if (!this._isNormalChanged) {
                        this._normalIdRequired += 1;
                    }
                    if (this.doFit()) {
                        isChanged = false;
                    }
                }
                if (isChanged) {
                    this._onChange();
                }
            }
        }
        get parent() {
            return this._parent;
        }
        get acceptor() {
            return this._acceptor;
        }
        get local() {
            return this._local;
        }
        get localId() {
            return this._localId;
        }
        get normal() {
            return this._normal;
        }
        get normalId() {
            return this._normalId;
        }
        get side() {
            return this._side;
        }
        set side(side) {
            if (this._side !== side) {
                this._side = side;
                this.onOtherChange();
            }
        }
        get margin() {
            return this._margin;
        }
        set margin(margin) {
            if (this._margin !== margin) {
                this._margin = margin;
                this.onOtherChange();
            }
        }
        get other() {
            return this._other;
        }
        set other(other) {
            this._other = other;
        }
        set(acceptorShape, acceptorEdge, acceptorX, acceptorY, margin, x, y, nx, ny, side) {
            this.lock();
            this._acceptor.set(acceptorShape, acceptorEdge, acceptorX, acceptorY);
            const local = this._local;
            if (x != null && y != null) {
                local.set(x, y);
            }
            else if (x != null) {
                local.x = x;
            }
            else if (y != null) {
                local.y = y;
            }
            const normal = this._normal;
            if (nx != null && ny != null) {
                normal.set(nx, ny);
            }
            else if (nx != null) {
                normal.x = nx;
            }
            else if (ny != null) {
                normal.y = ny;
            }
            if (side != null) {
                this.side = side;
            }
            if (margin != null) {
                this.margin = margin;
            }
            this.unlock();
            return this;
        }
        copy(source) {
            this.lock();
            this._acceptor.copy(source.acceptor);
            this._local.copyFrom(source.local);
            this._normal.copyFrom(source.normal);
            this.side = source.side;
            this.margin = source.margin;
            this.unlock();
            return this;
        }
        serialize(manager) {
            const acceptor = this._acceptor;
            const shape = acceptor.shape;
            const shapeUuid = shape ? shape.uuid : null;
            const edge = acceptor.edge;
            const edgeId = edge != null ? manager.addResource(edge) : -1;
            const local = this._local;
            const normal = this._normal;
            const side = this._side;
            return manager.addResource(`[${shapeUuid},${edgeId},${local.x},${local.y},${this._margin},${normal.x},${normal.y},${acceptor.x},${acceptor.y},${side}]`);
        }
        deserialize(resourceId, mapping, manager) {
            var _a, _b, _c;
            const resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                let parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                let shape = null;
                const shapeUuid = parsed[0];
                if (shapeUuid != null) {
                    shape = mapping.find(shapeUuid) || null;
                }
                this.lock();
                const acceptor = this._acceptor;
                acceptor.shape = shape;
                const edgeId = parsed[1];
                acceptor.edge = 0 <= edgeId && edgeId < resources.length ? resources[edgeId] : null;
                acceptor.x = (_a = parsed[7]) !== null && _a !== void 0 ? _a : null;
                acceptor.y = (_b = parsed[8]) !== null && _b !== void 0 ? _b : null;
                this._local.set(parsed[2], parsed[3]);
                const normalX = parsed[5];
                const normalY = parsed[6];
                const normal = this._normal;
                if (normalX != null && normalY != null) {
                    normal.set(normalX, normalY);
                }
                else {
                    normal.set(1, 0);
                }
                this.side = (_c = parsed[9]) !== null && _c !== void 0 ? _c : EShapeAcceptorEdgeSide.TOP;
                this.margin = parsed[4] || 0;
                this.unlock();
                if (shape) {
                    shape.connector.add(this);
                }
            }
        }
        fit(forcibly) {
            if (forcibly) {
                this._localIdRequired += 1;
                this._normalIdRequired += 1;
            }
            this.doFit();
            return this;
        }
        doFit() {
            var _a, _b, _c;
            const localIdRequired = this._localIdRequired;
            const isLocalDirty = this._localId !== localIdRequired;
            const normalIdRequired = this._normalIdRequired;
            const isNormalDirty = this._normalId !== normalIdRequired;
            if (isLocalDirty || isNormalDirty) {
                this._localId = localIdRequired;
                this._normalId = normalIdRequired;
                const acceptor = this._acceptor;
                const acceptorShape = acceptor.shape;
                const acceptorEdge = acceptor.edge;
                if (acceptorShape != null && acceptorEdge != null) {
                    const edge = EShapeAcceptors.get(acceptorShape.type).get(acceptorShape, acceptorEdge);
                    if (edge) {
                        const oat = this._acceptorTransformOld;
                        const nat = this._acceptorTransformNew;
                        this.toAcceptorTransform(acceptorShape, nat);
                        const other = this._other;
                        const isOtherDangling = this._hasAcceptorTransformOld &&
                            other != null &&
                            other.acceptor.shape == null;
                        const work = ((_a = EShapeConnectorEdgeImpl.WORK_MATRIX) !== null && _a !== void 0 ? _a : (EShapeConnectorEdgeImpl.WORK_MATRIX = new pixi_js.Matrix()));
                        if (isOtherDangling) {
                            oat.copyTo(work).invert().prepend(nat);
                        }
                        this._acceptorTransformNew = oat;
                        this._acceptorTransformOld = nat;
                        this._hasAcceptorTransformOld = true;
                        this.lock();
                        if (isLocalDirty) {
                            const l = this._local;
                            const olx = l.x;
                            const oly = l.y;
                            const size = acceptorShape.size;
                            const pivot = acceptorShape.transform.pivot;
                            const x = pivot.x + size.x * ((_b = acceptor.x) !== null && _b !== void 0 ? _b : edge.x);
                            const y = pivot.y + size.y * ((_c = acceptor.y) !== null && _c !== void 0 ? _c : edge.y);
                            const nlx = nat.a * x + nat.c * y + nat.tx;
                            const nly = nat.b * x + nat.d * y + nat.ty;
                            l.set(nlx, nly);
                            if (isOtherDangling) {
                                const ol = other.local;
                                const oolx = ol.x;
                                const ooly = ol.y;
                                const nolx = work.a * oolx + work.c * ooly + work.tx;
                                const noly = work.b * oolx + work.d * ooly + work.ty;
                                const odx = oolx - olx;
                                const ody = ooly - oly;
                                const ndx = nolx - nlx;
                                const ndy = noly - nly;
                                const od = odx * odx + ody * ody;
                                const nd = ndx * ndx + ndy * ndy;
                                if (0.000001 < nd) {
                                    const f = Math.sqrt(od / nd);
                                    ol.set(nlx + ndx * f, nly + ndy * f);
                                }
                                else {
                                    ol.set(nolx, noly);
                                }
                            }
                        }
                        if (isNormalDirty) {
                            const en = edge.normal;
                            const enx = en.x;
                            const eny = en.y;
                            const nx = nat.a * enx + nat.c * eny;
                            const ny = nat.b * enx + nat.d * eny;
                            const sd = nx * nx + ny * ny;
                            const n = this._normal;
                            if (0.000001 < sd) {
                                const f = 1 / Math.sqrt(sd);
                                n.set(nx * f, ny * f);
                            }
                            else {
                                n.set(enx, eny);
                            }
                            if (isOtherDangling) {
                                const on = other.normal;
                                const oonx = on.x;
                                const oony = on.y;
                                const nonx = work.a * oonx + work.c * oony;
                                const nony = work.b * oonx + work.d * oony;
                                const osd = nonx * nonx + nony * nony;
                                if (0.000001 < osd) {
                                    const f = 1 / Math.sqrt(osd);
                                    on.set(nonx * f, nony * f);
                                }
                                else {
                                    on.set(oonx, oony);
                                }
                            }
                        }
                        const result = this._isLocalChanged || this._isNormalChanged;
                        this.unlock();
                        return result;
                    }
                }
            }
            return false;
        }
        toAcceptorTransform(shape, result) {
            shape.updateTransform();
            const parent = this._parent;
            const parentParent = parent.parent;
            if (parentParent instanceof EShapeBase) {
                parent.updateTransform();
                return result
                    .copyFrom(parentParent.transform.internalTransform)
                    .invert()
                    .append(shape.transform.internalTransform);
            }
            else {
                return result.copyFrom(shape.transform.internalTransform);
            }
        }
        onAcceptorChange() {
            if (0 < this._lockCount) {
                this._isLocalChanged = false;
                this._isNormalChanged = false;
                this._isAcceptorChanged = true;
                return;
            }
            this._hasAcceptorTransformOld = false;
            this.fit(true);
        }
        onLocalChange() {
            if (0 < this._lockCount) {
                this._isLocalChanged = true;
                return;
            }
            this._localIdRequired += 1;
            this._localId = this._localIdRequired;
            this._onChange();
        }
        onNormalChange() {
            if (0 < this._lockCount) {
                this._isNormalChanged = true;
                return;
            }
            this._normalIdRequired += 1;
            this._normalId = this._normalIdRequired;
            this._onChange();
        }
        onOtherChange() {
            if (0 < this._lockCount) {
                this._isOtherChanged = true;
                return;
            }
            this._onChange();
        }
        attach() {
            const shape = this._acceptor.shape;
            if (shape) {
                if (shape.connector.add(this)) {
                    this.onAcceptorChange();
                }
            }
            return this;
        }
        detach(exceptions) {
            const shape = this._acceptor.shape;
            if (shape != null && (exceptions == null || !exceptions.has(shape))) {
                if (shape.connector.remove(this)) {
                    this.onAcceptorChange();
                }
            }
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectorEdgeContainerImpl {
        constructor(parent, onChange) {
            this._parent = parent;
            this._lockCount = 0;
            this._isChanged = false;
            this._onChange = onChange;
            const onChangeBound = () => {
                this.onChange();
            };
            const tail = new EShapeConnectorEdgeImpl(parent, onChangeBound);
            const head = new EShapeConnectorEdgeImpl(parent, onChangeBound);
            tail.other = head;
            head.other = tail;
            this._tail = tail;
            this._head = head;
        }
        lock() {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isChanged = false;
            }
            return this;
        }
        unlock() {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isChanged) {
                    this._onChange();
                }
            }
            return this;
        }
        onChange() {
            if (0 < this._lockCount) {
                this._isChanged = true;
                return;
            }
            this._onChange();
        }
        get tail() {
            return this._tail;
        }
        get head() {
            return this._head;
        }
        copy(source) {
            this.lock();
            this._tail.copy(source.tail);
            this._head.copy(source.head);
            this.unlock();
            return this;
        }
        fit(forcibly) {
            this.lock();
            this._tail.fit(forcibly);
            this._head.fit(forcibly);
            this.unlock();
            return this;
        }
        serialize(manager) {
            const tailId = this._tail.serialize(manager);
            const headId = this._head.serialize(manager);
            return manager.addResource(`[${tailId},${headId}]`);
        }
        deserialize(resourceId, mapping, manager) {
            const resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                let parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.lock();
                this._tail.deserialize(parsed[0], mapping, manager);
                this._head.deserialize(parsed[1], mapping, manager);
                this.unlock();
            }
        }
        attach() {
            this.lock();
            const tail = this._tail;
            const head = this._head;
            tail.attach();
            head.attach();
            tail.fit(true);
            head.fit(true);
            this.unlock();
            return this;
        }
        detach(exceptions) {
            this.lock();
            this._tail.detach(exceptions);
            this._head.detach(exceptions);
            this.unlock();
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toIndexOf = (array, value) => {
        let i0 = 0;
        let i1 = array.length - 1;
        while (i0 <= i1) {
            const i2 = i0 + ((i1 - i0) >> 1);
            const v2 = array[i2];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return -1;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toPointsBoundary = (values, result) => {
        const valuesLength = values.length;
        if (2 <= valuesLength) {
            let xmin = values[0];
            let ymin = values[1];
            let xmax = xmin;
            let ymax = ymin;
            for (let i = 2, imax = values.length; i < imax; i += 2) {
                const x = values[i];
                const y = values[i + 1];
                xmin = Math.min(xmin, x);
                ymin = Math.min(ymin, y);
                xmax = Math.max(xmax, x);
                ymax = Math.max(ymax, y);
            }
            result[0] = xmin;
            result[1] = ymin;
            result[2] = xmax;
            result[3] = ymax;
        }
        else {
            result[0] = 0;
            result[1] = 0;
            result[2] = 0;
            result[3] = 0;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapePointsMarkerBase {
        constructor(parent) {
            this._parent = parent;
            this._lockCount = 0;
            this._isTypeChanged = false;
            this._isSizeChanged = false;
            this._isFillChanged = false;
            this._type = EShapePointsMarkerType.NONE;
            this._size = new pixi_js.ObservablePoint(() => {
                this.onSizeChange();
            }, undefined, EShapeDefaults.SIZE_X * 0.15, EShapeDefaults.SIZE_Y * 0.15);
            this._fill = this.newFill();
            this._transformId = 0;
        }
        newFill() {
            return new EShapeFillImpl(this, true, EShapeDefaults.FILL_COLOR, 1);
        }
        lock() {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        }
        unlock() {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isTypeChanged) {
                    this.onTypeChange();
                }
                else if (this._isSizeChanged) {
                    this.onSizeChange();
                }
                else if (this._isFillChanged) {
                    this.onFillChange();
                }
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        }
        get type() {
            return this._type;
        }
        set type(type) {
            if (this._type !== type) {
                this._type = type;
                this.onTypeChange();
            }
        }
        onTypeChange() {
            if (0 < this._lockCount) {
                this._isTypeChanged = true;
                return;
            }
            this._parent.onTypeChange();
        }
        get size() {
            return this._size;
        }
        onSizeChange() {
            if (0 < this._lockCount) {
                this._isSizeChanged = true;
                return;
            }
            this._parent.onSizeChange();
        }
        get transform() {
            return this.updateTransform();
        }
        updateTransform() {
            let result = this._transform;
            if (result == null) {
                result = new pixi_js.Matrix();
                this._transform = result;
            }
            const parentParent = this._parent.parent;
            const id = parentParent.id;
            if (this._transformId !== id) {
                this._transformId = id;
                const formatted = parentParent.formatted;
                if (2 <= formatted.length) {
                    this.toTransform(formatted.values, result);
                }
                else {
                    result.identity();
                }
            }
            return result;
        }
        toTransformMatrix(x0, y0, x1, y1, result) {
            const dx = x0 - x1;
            const dy = y0 - y1;
            const n = dx * dx + dy * dy;
            if (0.00001 < n) {
                const f = 1 / Math.sqrt(n);
                const nx = dx * f;
                const ny = dy * f;
                result.set(ny, -nx, -nx, -ny, x0, y0);
            }
            else {
                result.set(1, 0, 0, 1, x0, y0);
            }
            return result;
        }
        get fill() {
            return this._fill;
        }
        onFillChange() {
            if (0 < this._lockCount) {
                this._isFillChanged = true;
                return;
            }
            this._parent.onFillChange();
        }
        updateUploaded() {
            this.onFillChange();
        }
        copy(source) {
            const size = source.size;
            this.set(source.type, size.x, size.y);
            return this;
        }
        set(type, sizeX, sizeY) {
            this.lock();
            if (type != null) {
                this.type = type;
            }
            this.size.set(sizeX, sizeY);
            this.unlock();
            return this;
        }
        serialize(manager) {
            const size = this._size;
            const fillId = this._fill.serialize(manager);
            return manager.addResource(`[${this._type},${size.x},${size.y},${fillId}]`);
        }
        deserialize(resourceId, manager) {
            const resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                let parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.lock();
                this.type = parsed[0];
                this._size.set(parsed[1], parsed[2]);
                this._fill.deserialize(parsed[3], manager);
                this.unlock();
            }
        }
    }

    class EShapePointsMarkerHead extends EShapePointsMarkerBase {
        toTransform(values, result) {
            const valuesLength = values.length;
            if (4 <= valuesLength) {
                return this.toTransformMatrix(values[valuesLength - 2], values[valuesLength - 1], values[valuesLength - 4], values[valuesLength - 3], result);
            }
            else {
                result.identity();
            }
            return result;
        }
    }

    class EShapePointsMarkerTail extends EShapePointsMarkerBase {
        toTransform(values, result) {
            const valuesLength = values.length;
            if (4 <= valuesLength) {
                return this.toTransformMatrix(values[0], values[1], values[2], values[3], result);
            }
            else {
                result.identity();
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapePointsMarkerContainerImpl {
        constructor(parent) {
            this._parent = parent;
            this._lockCount = 0;
            this._isTypeChanged = false;
            this._isSizeChanged = false;
            this._isFillChanged = false;
            this._head = new EShapePointsMarkerHead(this);
            this._tail = new EShapePointsMarkerTail(this);
        }
        lock() {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        }
        unlock() {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isTypeChanged) {
                    this.onTypeChange();
                }
                else if (this._isSizeChanged) {
                    this.onSizeChange();
                }
                else if (this._isFillChanged) {
                    this.onFillChange();
                }
                this._isTypeChanged = false;
                this._isSizeChanged = false;
                this._isFillChanged = false;
            }
            return this;
        }
        get parent() {
            return this._parent;
        }
        get head() {
            return this._head;
        }
        get tail() {
            return this._tail;
        }
        onTypeChange() {
            if (0 < this._lockCount) {
                this._isTypeChanged = true;
                return;
            }
            this._parent.onMarkerTypeChange();
        }
        onSizeChange() {
            if (0 < this._lockCount) {
                this._isSizeChanged = true;
                return;
            }
            this._parent.onMarkerSizeChange();
        }
        onFillChange() {
            if (0 < this._lockCount) {
                this._isFillChanged = true;
                return;
            }
            this._parent.onMarkerFillChange();
        }
        copy(source) {
            this.lock();
            this._head.copy(source.head);
            this._tail.copy(source.tail);
            this.unlock();
            return this;
        }
        serialize(manager) {
            const headId = this._head.serialize(manager);
            const tailId = this._tail.serialize(manager);
            return manager.addResource(`[${headId},${tailId}]`);
        }
        deserialize(resourceId, manager) {
            const resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                let parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.lock();
                this._head.deserialize(parsed[0], manager);
                this._tail.deserialize(parsed[1], manager);
                this.unlock();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const PID = Math.PI * 2;
    const PIH = Math.PI * 0.5;
    const vdot = (x0, y0, x1, y1) => {
        return x0 * x1 + y0 * y1;
    };
    const vlen = (x0, y0) => {
        return Math.sqrt(vdot(x0, y0, x0, y0));
    };
    const vcross = (x0, y0, x1, y1) => {
        return x0 * y1 - y0 * x1;
    };
    const pnew = () => {
        return {
            center: [0, 0],
            axis1: [0, 0],
            axis2: [0, 0],
            angle: [0, 0, 0]
        };
    };
    const pset = (cx, cy, a1x, a1y, a2x, a2y, angle1, angle2, angle3, result) => {
        const c = result.center;
        c[0] = cx;
        c[1] = cy;
        const a1 = result.axis1;
        a1[0] = a1x;
        a1[1] = a1y;
        const a2 = result.axis2;
        a2[0] = a2x;
        a2[1] = a2y;
        const a = result.angle;
        a[0] = angle1;
        a[1] = angle2;
        a[2] = angle3;
        return result;
    };
    const pcopy = (source, result) => {
        const c = source.center;
        const a1 = source.axis1;
        const a2 = source.axis2;
        const a = source.angle;
        return pset(c[0], c[1], a1[0], a1[1], a2[0], a2[1], a[0], a[1], a[2], result);
    };
    const acopy$1 = (source, result) => {
        const sourceLength = source.length;
        for (let i = 0; i < sourceLength; ++i) {
            result[i] = source[i];
        }
        if (result.length !== sourceLength) {
            result.length = sourceLength;
        }
        return result;
    };
    /**
     * An utility class for spline curves based on the work of Cem Yuksel.
     * Pleaase refer to the paper `A class of C2 interpolating splines`.
     * http://www.cemyuksel.com/research/interpolating_splines/
     */
    class UtilCurve {
        static set(center1, angle10, angle11, axis11, axis12, center2, angle20, angle21, axis21, axis22, nsegment, isAdaptive, isEdge, result, resultIndex) {
            const a = Math.max(Math.abs(angle10 - angle11), Math.abs(angle20 - angle21));
            const n = isAdaptive ? Math.max(1, Math.round(nsegment * (a / PIH))) : nsegment;
            const imax = isEdge ? n + 1 : n;
            for (let i = 0; i < imax; ++i) {
                const t = i / n;
                const w0 = 1 - t;
                const w1 = t;
                const t1 = w0 * angle10 + w1 * angle11;
                const c1 = Math.cos(t1);
                const s1 = Math.sin(t1);
                const x1 = center1[0] + c1 * axis11[0] + s1 * axis12[0];
                const y1 = center1[1] + c1 * axis11[1] + s1 * axis12[1];
                const t2 = w0 * angle20 + w1 * angle21;
                const c2 = Math.cos(t2);
                const s2 = Math.sin(t2);
                const x2 = center2[0] + c2 * axis21[0] + s2 * axis22[0];
                const y2 = center2[1] + c2 * axis21[1] + s2 * axis22[1];
                const t3 = PIH * t;
                const c3 = Math.cos(t3);
                const s3 = Math.sin(t3);
                const cc3 = c3 * c3;
                const ss3 = s3 * s3;
                const x3 = cc3 * x1 + ss3 * x2;
                const y3 = cc3 * y1 + ss3 * y2;
                result[++resultIndex] = x3;
                result[++resultIndex] = y3;
            }
            return resultIndex;
        }
        /**
         * Calculate an interpolated points of the given control points.
         *
         * @param length A number of control points.
         * @param values An array of control points.
         * @param toParameter An interpolation method.
         * @param isClosed True if the line is closed.
         * @param nsegment The number of segments per 90 degree if isAdaptive is true.
         * If isAdaptive is false, the number of segments is fixed to the given number
         * regardless of arc angles.
         * @param isAdaptive True to adjust the number of segments adaptively.
         * @returns An interpolated points of the given control points.
         */
        static interpolate(length, values, segments, toParameter, isClosed, nsegment, isAdaptive, result) {
            const rvalues = result.values;
            const rsegments = result.segments;
            if (length <= 2) {
                acopy$1(values, rvalues);
                acopy$1(segments, rsegments);
                return result;
            }
            const c0 = this.WORK_P0 || pnew();
            let c1 = this.WORK_P1 || pnew();
            let c2 = this.WORK_P2 || pnew();
            this.WORK_P0 = c0;
            this.WORK_P1 = c1;
            this.WORK_P2 = c2;
            let rvaluesCount = -1;
            let rsegmentCount = -1;
            if (isClosed) {
                toParameter(0, length, values, c0);
                pcopy(c0, c1);
                for (let i = 1; i < length; ++i) {
                    toParameter(i, length, values, c2);
                    if (0 <= toIndexOf(segments, i)) {
                        const index = (i - 1) << 1;
                        rvalues[++rvaluesCount] = values[index + 0];
                        rvalues[++rvaluesCount] = values[index + 1];
                        rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                    }
                    else {
                        rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c2.center, c2.angle[0], c2.angle[1], c2.axis1, c2.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                    }
                    const c3 = c1;
                    c1 = c2;
                    c2 = c3;
                }
                if (0 <= toIndexOf(segments, 0)) {
                    const index = (length - 1) << 1;
                    rvalues[++rvaluesCount] = values[index + 0];
                    rvalues[++rvaluesCount] = values[index + 1];
                    rsegments.unshift(0);
                    rsegmentCount += 1;
                }
                else {
                    rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                }
            }
            else {
                toParameter(1, length, values, c0);
                if (0 <= toIndexOf(segments, 1)) {
                    rvalues[++rvaluesCount] = values[0];
                    rvalues[++rvaluesCount] = values[1];
                    rsegments[++rsegmentCount] = 1;
                }
                else {
                    rvaluesCount = this.set(c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, c0.center, c0.angle[0], c0.angle[1], c0.axis1, c0.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                }
                pcopy(c0, c1);
                for (let i = 2, imax = length - 1; i < imax; ++i) {
                    toParameter(i, length, values, c2);
                    if (0 <= toIndexOf(segments, i)) {
                        const index = (i - 1) << 1;
                        rvalues[++rvaluesCount] = values[index + 0];
                        rvalues[++rvaluesCount] = values[index + 1];
                        rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                    }
                    else {
                        rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c2.center, c2.angle[0], c2.angle[1], c2.axis1, c2.axis2, nsegment, isAdaptive, false, rvalues, rvaluesCount);
                    }
                    const c3 = c1;
                    c1 = c2;
                    c2 = c3;
                }
                if (0 <= toIndexOf(segments, length - 1)) {
                    const index = (length - 2) << 1;
                    rvalues[++rvaluesCount] = values[index + 0];
                    rvalues[++rvaluesCount] = values[index + 1];
                    rsegments[++rsegmentCount] = (rvaluesCount + 1) >> 1;
                }
                else {
                    rvaluesCount = this.set(c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, c1.center, c1.angle[1], c1.angle[2], c1.axis1, c1.axis2, nsegment, isAdaptive, true, rvalues, rvaluesCount);
                }
            }
            rvaluesCount += 1;
            if (rvalues.length !== rvaluesCount) {
                rvalues.length = rvaluesCount;
            }
            rsegmentCount += 1;
            if (rsegments.length !== rsegmentCount) {
                rsegments.length = rsegmentCount;
            }
            return result;
        }
    }
    UtilCurve.toCircle = (index, length, values, result) => {
        const index0 = 0 < index ? index - 1 : length - 1;
        const index1 = index;
        const index2 = index < length - 1 ? index + 1 : 0;
        const i0 = index0 << 1;
        const i1 = index1 << 1;
        const i2 = index2 << 1;
        const x0 = values[i0 + 0];
        const y0 = values[i0 + 1];
        const x1 = values[i1 + 0];
        const y1 = values[i1 + 1];
        const x2 = values[i2 + 0];
        const y2 = values[i2 + 1];
        const d01x = x1 - x0;
        const d01y = y1 - y0;
        const d12x = x2 - x1;
        const d12y = y2 - y1;
        const m1x = x0 + d01x * 0.5;
        const m1y = y0 + d01y * 0.5;
        const m2x = x1 + d12x * 0.5;
        const m2y = y1 + d12y * 0.5;
        const n1x = -d01y;
        const n1y = +d01x;
        const n2x = -d12y;
        const n2y = +d12x;
        let det = vcross(n1x, n1y, n2x, n2y);
        const threshold = 0.001;
        if (Math.abs(det) < threshold) {
            if (0 <= vdot(d01x, d01y, d12x, d12y) || length <= 2) {
                const a = 0.01;
                const s = Math.sin(a);
                const l1 = vlen(d01x, d01y);
                const l2 = vlen(d12x, d12y);
                return pset(x1, y1, 0, 0, d12x / s, d12y / s, (-a * l1) / l2, 0, a, result);
            }
            else {
                det = threshold;
            }
        }
        const s = (n2y * (m2x - m1x) + n2x * (m1y - m2y)) / det;
        const cx = m1x + s * n1x;
        const cy = m1y + s * n1y;
        const a1x = x1 - cx;
        const a1y = y1 - cy;
        const a2x = -a1y;
        const a2y = +a1x;
        const dc2x = x2 - cx;
        const dc2y = y2 - cy;
        let a2 = Math.atan2(vdot(a2x, a2y, dc2x, dc2y), vdot(a1x, a1y, dc2x, dc2y));
        const dc0x = x0 - cx;
        const dc0y = y0 - cy;
        let a1 = Math.atan2(vdot(a2x, a2y, dc0x, dc0y), vdot(a1x, a1y, dc0x, dc0y));
        if (0 < a1 * a2) {
            if (Math.abs(a1) < Math.abs(a2)) {
                if (0 < a2) {
                    a2 -= PID;
                }
                else {
                    a2 += PID;
                }
            }
            if (Math.abs(a2) < Math.abs(a1)) {
                if (0 < a1) {
                    a1 -= PID;
                }
                else {
                    a1 += PID;
                }
            }
        }
        return pset(cx, cy, a1x, a1y, a2x, a2y, a1, 0, a2, result);
    };
    UtilCurve.toEllipse = (index, length, values, result) => {
        const index0 = 0 < index ? index - 1 : length - 1;
        const index1 = index;
        const index2 = index < length - 1 ? index + 1 : 0;
        const i0 = index0 << 1;
        const i1 = index1 << 1;
        const i2 = index2 << 1;
        const x0 = values[i0 + 0];
        const y0 = values[i0 + 1];
        const x1 = values[i1 + 0];
        const y1 = values[i1 + 1];
        const x2 = values[i2 + 0];
        const y2 = values[i2 + 1];
        const d10x = x0 - x1;
        const d10y = y0 - y1;
        const d12x = x2 - x1;
        const d12y = y2 - y1;
        if (length <= 2) {
            const a = 0.01;
            const s = Math.sin(a);
            return pset(x1, y1, 0, 0, d12x / s, d12y / s, -a, 0, a, result);
        }
        const l0 = vlen(d10x, d10y);
        const l2 = vlen(d12x, d12y);
        const cos = vdot(d10x, d10y, d12x, d12y) / (l0 * l2);
        const amax = Math.acos(cos);
        let acurrent = amax * 0.5;
        let adelta = amax * 0.25;
        let a = 0;
        let b = 0;
        let c = 0;
        let d = 0;
        const lmax = Math.max(l0, l2);
        const lmin = Math.min(l0, l2);
        for (let i = 0; i < 16; ++i) {
            const a0 = acurrent * 0.5;
            const a1 = amax - a0;
            a = lmax * Math.sin(a0);
            b = lmax * Math.cos(a0);
            c = lmin * Math.sin(a1);
            d = lmin * Math.cos(a1);
            const v = (1 - d / b) * (1 - d / b) + (c * c) / (a * a);
            if (1 < v) {
                acurrent += adelta;
            }
            else {
                acurrent -= adelta;
            }
            adelta *= 0.5;
        }
        const beta = Math.asin(Math.min(c / a, 1));
        if (l0 < l2) {
            const e3x = d12x / l2;
            const e3y = d12y / l2;
            let n3x, n3y;
            if (0 < vcross(d10x, d10y, d12x, d12y)) {
                n3x = +e3y;
                n3y = -e3x;
            }
            else {
                n3x = -e3y;
                n3y = +e3x;
            }
            const we = -(b * b) / l2;
            const wn = -(b * a) / l2;
            const a1x = we * e3x + wn * n3x;
            const a1y = we * e3y + wn * n3y;
            const cx = x1 - a1x;
            const cy = y1 - a1y;
            const a2x = x2 - cx;
            const a2y = y2 - cy;
            return pset(cx, cy, a1x, a1y, a2x, a2y, -beta, 0, PIH, result);
        }
        else {
            const e0x = d10x / l0;
            const e0y = d10y / l0;
            let n3x, n3y;
            if (vcross(d10x, d10y, d12x, d12y) < 0) {
                n3x = +e0y;
                n3y = -e0x;
            }
            else {
                n3x = -e0y;
                n3y = +e0x;
            }
            const we = -(b * b) / l0;
            const wn = -(b * a) / l0;
            const a1x = we * e0x + wn * n3x;
            const a1y = we * e0y + wn * n3y;
            const cx = x1 - a1x;
            const cy = y1 - a1y;
            const a2x = x0 - cx;
            const a2y = y0 - cy;
            return pset(cx, cy, a1x, a1y, -a2x, -a2y, -PIH, 0, beta, result);
        }
    };
    UtilCurve.toHybrid = (index, length, values, result) => {
        const circle = UtilCurve.toCircle(index, length, values, result);
        const a0 = circle.angle[0];
        const a2 = circle.angle[2];
        const amin = Math.min(a0, a2);
        const amax = Math.max(a0, a2);
        if (amin < -PIH || PIH < amax) {
            return UtilCurve.toEllipse(index, length, values, result);
        }
        return circle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const eShapePointsFormatterCurve = (length, values, segments, style, result) => {
        UtilCurve.interpolate(length, values, segments, UtilCurve.toHybrid, !!(style & EShapePointsStyle.CLOSED), EShapeDefaults.CURVE_SEGMENT_COUNT, true, result);
        result.length = result.values.length >> 1;
        result.style = style;
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const acopy = (source, result) => {
        const sourceLength = source.length;
        for (let i = 0; i < sourceLength; ++i) {
            result[i] = source[i];
        }
        if (result.length !== sourceLength) {
            result.length = sourceLength;
        }
        return result;
    };
    const amix = (x0, y0, x1, y1, t, result) => {
        const u = 1 - t;
        result[0] = x0 * u + x1 * t;
        result[1] = y0 * u + y1 * t;
        return result;
    };
    const interpolate2 = (x0, y0, x1, y1, x2, y2, is0, is1, nsegment, rvalues, rvaluesCount) => {
        const v3 = [0, 0];
        const v4 = [0, 0];
        const v5 = [0, 0];
        for (let is = is0; is < is1; ++is) {
            const t = is / nsegment;
            amix(x0, y0, x1, y1, t, v3);
            amix(x1, y1, x2, y2, t, v4);
            amix(v3[0], v3[1], v4[0], v4[1], t, v5);
            rvalues[++rvaluesCount] = v5[0];
            rvalues[++rvaluesCount] = v5[1];
        }
        return rvaluesCount;
    };
    const interpolate1 = (length, values, segments, isClosed, nsegment, result) => {
        const rvalues = result.values;
        const rsegments = result.segments;
        if (length <= 2) {
            acopy(values, rvalues);
            acopy(segments, rsegments);
            return result;
        }
        let rvaluesCount = -1;
        let rsegmentsCount = -1;
        const ism = nsegment >> 1;
        if (isClosed) {
            let i = 0;
            for (; i + 2 < length; i += 2) {
                const j = i << 1;
                const s0 = 0 <= toIndexOf(segments, i + 1);
                const s1 = 0 <= toIndexOf(segments, i + 2);
                if (s0 && s1) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else if (s0) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], ism, nsegment, nsegment, rvalues, rvaluesCount);
                }
                else if (s1) {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], 0, ism, nsegment, rvalues, rvaluesCount);
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], 0, nsegment, nsegment, rvalues, rvaluesCount);
                }
            }
            if (i + 1 < length) {
                const j = i << 1;
                const s0 = 0 <= toIndexOf(segments, i + 1);
                const s1 = 0 <= toIndexOf(segments, 0);
                if (s0 && s1) {
                    rvalues[++rvaluesCount] = values[0];
                    rvalues[++rvaluesCount] = values[1];
                    rsegments.unshift(0);
                    rsegmentsCount += 1;
                }
                else if (s0) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[0], values[1], ism, nsegment, nsegment, rvalues, rvaluesCount);
                }
                else if (s1) {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[0], values[1], 0, ism, nsegment, rvalues, rvaluesCount);
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[0], values[1], 0, nsegment, nsegment, rvalues, rvaluesCount);
                }
            }
            else if (i < length) {
                const j = i << 1;
                rvalues[++rvaluesCount] = values[j + 0];
                rvalues[++rvaluesCount] = values[j + 1];
                if (0 <= toIndexOf(segments, 0)) {
                    rsegments.unshift(0);
                    rsegmentsCount += 1;
                }
            }
        }
        else {
            let i = 0;
            for (; i + 2 < length; i += 2) {
                const j = i << 1;
                const s0 = 0 <= toIndexOf(segments, i + 1);
                const s1 = 0 <= toIndexOf(segments, i + 2);
                if (s0 && s1) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else if (s0) {
                    rvalues[++rvaluesCount] = values[j + 0];
                    rvalues[++rvaluesCount] = values[j + 1];
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], ism, nsegment, nsegment, rvalues, rvaluesCount);
                }
                else if (s1) {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], 0, ism, nsegment, rvalues, rvaluesCount);
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
                else {
                    rvaluesCount = interpolate2(values[j + 0], values[j + 1], values[j + 2], values[j + 3], values[j + 4], values[j + 5], 0, nsegment, nsegment, rvalues, rvaluesCount);
                }
            }
            for (; i + 1 < length; ++i) {
                const j = i << 1;
                rvalues[++rvaluesCount] = values[j + 0];
                rvalues[++rvaluesCount] = values[j + 1];
                rvalues[++rvaluesCount] = values[j + 2];
                rvalues[++rvaluesCount] = values[j + 3];
                if (0 <= toIndexOf(segments, i + 1)) {
                    rsegments[++rsegmentsCount] = (rvaluesCount >> 1) + 1;
                }
            }
            for (; i < length; ++i) {
                const j = i << 1;
                rvalues[++rvaluesCount] = values[j + 0];
                rvalues[++rvaluesCount] = values[j + 1];
            }
        }
        rvaluesCount += 1;
        if (rvalues.length !== rvaluesCount) {
            rvalues.length = rvaluesCount;
        }
        rsegmentsCount += 1;
        if (rsegments.length !== rsegmentsCount) {
            rsegments.length = rsegmentsCount;
        }
        return result;
    };
    const eShapePointsFormatterCurveBezierQuadratic = (length, values, segments, style, result) => {
        interpolate1(length, values, segments, !!(style & EShapePointsStyle.CLOSED), EShapeDefaults.CURVE_SEGMENT_COUNT, result);
        result.length = result.values.length >> 1;
        result.style = style;
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapePointsFormatters {
        static set(id, datum) {
            if (this.data == null) {
                this.data = this.newData();
            }
            this.data.set(id, datum);
        }
        static get(index) {
            if (this.data == null) {
                this.data = this.newData();
            }
            return this.data.get(index);
        }
        static each(iteratee) {
            if (this.data == null) {
                this.data = this.newData();
            }
            this.data.forEach((datum, id) => {
                iteratee(id, datum);
            });
        }
        static find(style) {
            return this.get((style & EShapePointsStyle.FORMATTER_MASK) >> EShapePointsStyle.FORMATTER_SHIFT);
        }
        static newData() {
            const result = new Map();
            const theme = DThemes.get("EShapePointsFormatter");
            result.set(EShapePointsStyle.FORMATTER_CURVE_SPLINE, {
                label: theme.getCurveSplineLabel(),
                formatter: eShapePointsFormatterCurve
            });
            result.set(EShapePointsStyle.FORMATTER_CURVE_BEZIER_QUADRATIC, {
                label: theme.getCurveBezierQuadraticLabel(),
                formatter: eShapePointsFormatterCurveBezierQuadratic
            });
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLinePoints {
        constructor(parent) {
            this._parent = parent;
            this._valuesBaseLength = 0;
            this._values = [];
            this._segments = [];
            this._length = 0;
            this._plength = 0;
            const parentSize = parent.size;
            const parentSizeX = parentSize.x;
            const parentSizeY = parentSize.y;
            this._parentSizeBase = new pixi_js.Point(parentSizeX, parentSizeY);
            this._parentSizeFitted = new pixi_js.Point(parentSizeX, parentSizeY);
            this._id = 0;
            this._style = EShapePointsStyle.NONE;
            this._formattedId = -1;
        }
        get length() {
            return this._length;
        }
        get plength() {
            return this._plength;
        }
        toFitted(x, y) {
            this._valuesBase = undefined;
            this._parentSizeFitted.set(x, y);
            this._parentSizeBase.set(x, y);
        }
        onSizeChange() {
            this.fit();
        }
        fit() {
            const parent = this._parent;
            const psizef = this._parentSizeFitted;
            const psize = parent.size;
            const psizeX = psize.x;
            const psizeY = psize.y;
            const threshold = 0.00001;
            if (Math.abs(psizeX - psizef.x) <= threshold && Math.abs(psizeY - psizef.y) <= threshold) {
                return;
            }
            psizef.set(psizeX, psizeY);
            const psizeBase = this._parentSizeBase;
            const isValidX = threshold < Math.abs(psizeBase.x);
            const isValidY = threshold < Math.abs(psizeBase.y);
            if (!isValidX && !isValidY) {
                return;
            }
            const scaleX = isValidX ? psizeX / psizeBase.x : 1;
            const scaleY = isValidY ? psizeY / psizeBase.y : 1;
            // Values
            const values = this._values;
            let valuesBase = this._valuesBase;
            if (valuesBase == null) {
                valuesBase = [];
                this._valuesBase = valuesBase;
                for (let i = 0, imax = values.length; i < imax; i += 2) {
                    const x = values[i];
                    const y = values[i + 1];
                    values[i] = x * scaleX;
                    values[i + 1] = y * scaleY;
                    valuesBase.push(x, y);
                }
            }
            else {
                for (let i = 0, imax = values.length; i < imax; i += 2) {
                    values[i] = valuesBase[i] * scaleX;
                    values[i + 1] = valuesBase[i + 1] * scaleY;
                }
            }
            // Invalidate
            this._id += 1;
            if (this._formatter || this._style & EShapePointsStyle.FORMATTER_MASK) {
                const uploaded = parent.uploaded;
                if (uploaded && !uploaded.isCompatible(parent)) {
                    parent.toDirty();
                }
            }
        }
        get id() {
            this.fit();
            return this._id;
        }
        get values() {
            this.fit();
            return this._values;
        }
        set values(values) {
            this.set(values, undefined, undefined);
        }
        get segments() {
            return this._segments;
        }
        /**
         * Must be sorted in ascending order.
         */
        set segments(segments) {
            this.set(undefined, segments, undefined);
        }
        get style() {
            return this._style;
        }
        set style(style) {
            this.set(undefined, undefined, style);
        }
        get marker() {
            let result = this._marker;
            if (result == null) {
                result = this.newMarker();
                this._marker = result;
            }
            return result;
        }
        getMarker() {
            return this._marker;
        }
        newMarker() {
            return new EShapePointsMarkerContainerImpl(this);
        }
        onMarkerTypeChange() {
            const parent = this._parent;
            parent.uploaded = undefined;
            parent.toDirty();
        }
        onMarkerSizeChange() {
            this._parent.updateUploaded();
        }
        onMarkerFillChange() {
            this._parent.updateUploaded();
        }
        get formatter() {
            return this._formatter || null;
        }
        set formatter(formatter) {
            if (this._formatter !== formatter) {
                this._formattedId = -1;
                this._formatter = formatter;
                this.toDirty(true);
            }
        }
        get formatted() {
            var _a, _b;
            this.fit();
            const id = this._id;
            let result = this._formatted;
            if (this._formattedId !== id) {
                this._formattedId = id;
                const style = this._style;
                const formatter = (_a = this._formatter) !== null && _a !== void 0 ? _a : (_b = EShapePointsFormatters.find(style)) === null || _b === void 0 ? void 0 : _b.formatter;
                if (formatter != null) {
                    if (result == null) {
                        result = {
                            length: 0,
                            plength: 0,
                            values: [],
                            segments: [],
                            boundary: [0, 0, 0, 0],
                            style: EShapePointsStyle.NONE
                        };
                    }
                    const values = this._values;
                    const segments = this._segments;
                    const length = values.length >> 1;
                    formatter(length, values, segments, style, result);
                    if (result.plength < result.length) {
                        result.plength = result.length;
                    }
                    toPointsBoundary(result.values, result.boundary);
                }
                else {
                    result = undefined;
                }
                this._formatted = result;
            }
            return result || this;
        }
        toScaled(values, valuesBase, boundary, boundaryBase) {
            const size = this._parentSizeFitted;
            const sizeBase = this._parentSizeBase;
            const threshold = 0.00001;
            const hasSizeBaseX = threshold < Math.abs(sizeBase.x);
            const hasSizeBaseY = threshold < Math.abs(sizeBase.y);
            if (hasSizeBaseX || hasSizeBaseY) {
                const scaleX = hasSizeBaseX ? size.x / sizeBase.x : 1;
                const scaleY = hasSizeBaseY ? size.y / sizeBase.y : 1;
                for (let i = 0, imax = valuesBase.length; i < imax; i += 2) {
                    values[i] = valuesBase[i] * scaleX;
                    values[i + 1] = valuesBase[i + 1] * scaleY;
                }
                for (let i = 0, imax = boundaryBase.length; i < imax; i += 2) {
                    boundary[i] = boundaryBase[i] * scaleX;
                    boundary[i + 1] = boundaryBase[i + 1] * scaleY;
                }
            }
        }
        copy(source) {
            this.set(source.values, source.segments, source.style);
            const marker = source.getMarker();
            if (marker) {
                this.marker.copy(marker);
            }
            return this;
        }
        set(newValues, newSegments, newStyle) {
            let isDirty = false;
            let isUpdated = false;
            // Formatter
            const style = this._style;
            const styleFormatter = style & EShapePointsStyle.FORMATTER_MASK;
            const formatter = this._formatter;
            // Values
            if (newValues != null) {
                const values = this._values;
                const valuesBaseLength = this._valuesBaseLength;
                const newValuesLength = newValues.length;
                const iupdate = Math.min(newValuesLength, valuesBaseLength);
                const parentSize = this._parent.size;
                this.toFitted(parentSize.x, parentSize.y);
                if (values !== newValues) {
                    for (let i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (let i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesBaseLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            isDirty = true;
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                }
                else {
                    if (valuesBaseLength !== newValuesLength) {
                        this._valuesBaseLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            isDirty = true;
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                }
                const newLength = newValuesLength >> 1;
                this._length = newLength;
                if (this._plength < newLength) {
                    this._plength = newLength;
                }
            }
            // Segments
            if (newSegments != null) {
                const segments = this._segments;
                if (segments !== newSegments) {
                    const newSegmentsLength = newSegments.length;
                    const iupdate = Math.min(segments.length, newSegmentsLength);
                    for (let i = 0; i < iupdate; ++i) {
                        segments[i] = newSegments[i];
                    }
                    for (let i = iupdate; i < newSegmentsLength; ++i) {
                        segments.push(newSegments[i]);
                    }
                    if (segments.length !== newSegmentsLength) {
                        segments.length = newSegmentsLength;
                    }
                }
                if (formatter != null || styleFormatter) {
                    isDirty = true;
                }
                else {
                    isUpdated = true;
                }
            }
            // Style
            if (newStyle != null) {
                if (style !== newStyle) {
                    const newStyleFormatter = newStyle & EShapePointsStyle.FORMATTER_MASK;
                    if (styleFormatter !== newStyleFormatter) {
                        isDirty = true;
                    }
                    else {
                        if (formatter != null || styleFormatter) {
                            const styleClosed = style & EShapePointsStyle.CLOSED;
                            const newStyleClosed = newStyle & EShapePointsStyle.CLOSED;
                            if (styleClosed !== newStyleClosed) {
                                isDirty = true;
                            }
                            else {
                                isUpdated = true;
                            }
                        }
                        else {
                            isUpdated = true;
                        }
                    }
                    this._style = newStyle;
                }
            }
            //
            if (isUpdated || isDirty) {
                this.toDirty(isDirty);
            }
            return this;
        }
        toDirty(revalidate) {
            if (revalidate) {
                this._id += 1;
                const parent = this._parent;
                const uploaded = parent.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent)) {
                        parent.updateUploaded();
                    }
                    else {
                        parent.toDirty();
                    }
                }
                else {
                    parent.updateUploaded();
                }
            }
            else {
                this._id += 1;
                this._parent.updateUploaded();
            }
        }
        clone(parent) {
            return new EShapeLinePoints(parent).copy(this);
        }
        toPoints(transform) {
            const result = [];
            const values = this.values;
            for (let i = 0, imax = values.length; i < imax; i += 2) {
                const point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        }
        serialize(manager) {
            const values = JSON.stringify(this._values);
            const segments = JSON.stringify(this._segments);
            const style = this._style;
            let markerId = -1;
            const marker = this._marker;
            if (marker) {
                markerId = marker.serialize(manager);
            }
            return manager.addResource(`[${values},${segments},${style},${markerId}]`);
        }
        deserialize(resourceId, manager) {
            const resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                let parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.set(parsed[0], parsed[1], parsed[2]);
                const markerId = parsed[3];
                if (markerId != null && 0 <= markerId) {
                    this.marker.deserialize(markerId, manager);
                }
            }
        }
        calcHitPointAbs(x, y, ax, ay, threshold, toRange, tester, result) {
            const formatted = this.formatted;
            const length = formatted.length;
            if (2 <= length) {
                const values = formatted.values;
                const segments = formatted.segments;
                const style = formatted.style;
                let istart = 0;
                let iend = length;
                if (toRange) {
                    const work = EShapeLinePoints.WORK_RANGE;
                    toRange(x, y, threshold, values, work);
                    istart = work[0];
                    iend = work[1];
                }
                for (let i = istart, imax = Math.min(iend, length - 1); i < imax; ++i) {
                    if (toIndexOf(segments, i + 1) < 0) {
                        const iv = i << 1;
                        const p0x = values[iv + 0];
                        const p0y = values[iv + 1];
                        const p1x = values[iv + 2];
                        const p1y = values[iv + 3];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
                if (2 < length && length <= iend && style & EShapePointsStyle.CLOSED) {
                    if (toIndexOf(segments, 0) < 0) {
                        const i = length - 1;
                        const iv = i << 1;
                        const p0x = values[iv + 0];
                        const p0y = values[iv + 1];
                        const p1x = values[0];
                        const p1y = values[1];
                        if (tester(x, y, p0x, p0y, p1x, p1y, i, threshold, result)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
    }
    EShapeLinePoints.WORK_RANGE = [0, 0];

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectorBodyImpl {
        constructor(parent, onChange) {
            this._parent = parent;
            this._id = 0;
            this._values = [];
            this._lockCount = 0;
            this._isChanged = false;
            this._onChange = onChange;
        }
        lock() {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isChanged = false;
            }
        }
        unlock() {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isChanged) {
                    this.onChange();
                }
                this._isChanged = false;
            }
        }
        get id() {
            return this._id;
        }
        get values() {
            return this._values;
        }
        set values(newValues) {
            this.set(newValues);
        }
        set(newValues) {
            if (newValues != null) {
                this._id += 1;
                if (this._values !== newValues) {
                    const length = newValues.length;
                    const values = this._values;
                    for (let i = 0; i < length; ++i) {
                        values[i] = newValues[i];
                    }
                    values.length = length;
                }
                this.onChange();
            }
            return this;
        }
        copy(source) {
            return this.set(source.values);
        }
        serialize(manager) {
            return manager.addResource(JSON.stringify(this._values));
        }
        deserialize(resourceId, mapping, manager) {
            const resources = manager.resources;
            if (0 <= resourceId && resourceId < resources.length) {
                let parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                this.set(parsed);
            }
        }
        onChange() {
            if (0 < this._lockCount) {
                this._isChanged = true;
                return;
            }
            this._onChange();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectorLine extends EShapeLineBase {
        constructor(type = EShapeType.CONNECTOR_LINE) {
            super(type);
            this._tailLocalId = 0;
            this._tailNormalId = 0;
            this._tailMargin = 0;
            this._headLocalId = 0;
            this._headNormalId = 0;
            this._headMargin = 0;
            this._bodyId = 0;
            this._lockConnector = new EShapeLock();
            const sx = EShapeDefaults.SIZE_X;
            const sy = EShapeDefaults.SIZE_Y;
            const hx = sx * 0.5;
            const hy = sy * 0.5;
            this._points = new EShapeLinePoints(this).set([-hx, -hy, +hx, +hy]);
            const onChangeBound = () => {
                this.onChange();
            };
            this._edge = new EShapeConnectorEdgeContainerImpl(this, onChangeBound);
            this._body = new EShapeConnectorBodyImpl(this, onChangeBound);
        }
        lock(part) {
            if (part & EShapeLockPart.CONNECTOR) {
                this._lockConnector.lock();
            }
            super.lock(part);
            return this;
        }
        unlock(part, invoke) {
            super.unlock(part, invoke);
            if (part & EShapeLockPart.CONNECTOR) {
                if (this._lockConnector.unlock() && invoke) {
                    this.onChange();
                }
            }
            return this;
        }
        get points() {
            return this._points;
        }
        get edge() {
            return this._edge;
        }
        get body() {
            return this._body;
        }
        onAttach() {
            super.onAttach();
            this._edge.attach();
        }
        onDetach(exceptions) {
            this._edge.detach(exceptions);
            super.onDetach(exceptions);
        }
        onChange() {
            var _a;
            if (this._lockConnector.isLocked()) {
                return;
            }
            const edge = this._edge;
            const tail = edge.tail;
            const tailLocalId = tail.localId;
            const tailNormalId = tail.normalId;
            const tailMargin = tail.margin;
            const head = edge.head;
            const headLocalId = head.localId;
            const headNormalId = head.normalId;
            const headMargin = head.margin;
            const body = this._body;
            const bodyId = body.id;
            if (this._tailLocalId !== tailLocalId ||
                this._tailNormalId !== tailNormalId ||
                this._tailMargin !== tailMargin ||
                this._headLocalId !== headLocalId ||
                this._headNormalId !== headNormalId ||
                this._headMargin !== headMargin ||
                this._bodyId !== bodyId) {
                this._tailLocalId = tailLocalId;
                this._tailNormalId = tailNormalId;
                this._tailMargin = tailMargin;
                this._headLocalId = headLocalId;
                this._headNormalId = headNormalId;
                this._headMargin = headMargin;
                this._bodyId !== bodyId;
                const transform = this.transform;
                const transformPosition = transform.position;
                const px = transformPosition.x;
                const py = transformPosition.y;
                const points = this._points;
                const values = points.values;
                // Fill points
                this.fillPoints(tail, tailMargin, head, headMargin, body, px, py, values);
                // Center & size
                const boundary = ((_a = EShapeConnectorLine.WORK_BOUNDARY) !== null && _a !== void 0 ? _a : (EShapeConnectorLine.WORK_BOUNDARY = [0, 0, 0, 0]));
                toPointsBoundary(values, boundary);
                const cx = (boundary[2] + boundary[0]) * 0.5;
                const cy = (boundary[3] + boundary[1]) * 0.5;
                const sx = boundary[2] - boundary[0];
                const sy = boundary[3] - boundary[1];
                // Adjust values
                for (let i = 0, imax = values.length; i < imax; i += 2) {
                    values[i + 0] -= cx;
                    values[i + 1] -= cy;
                }
                this.lock(EShapeLockPart.TRANSFORM_AND_UPLOADED);
                transformPosition.set(px + cx, py + cy);
                transform.scale.set(1, 1);
                transform.rotation = 0;
                transform.skew.set(0, 0);
                points.toFitted(sx, sy);
                this.size.set(sx, sy);
                points.set(values);
                this.unlock(EShapeLockPart.TRANSFORM_AND_UPLOADED, true);
            }
        }
        fillPoints(tail, tailMargin, head, headMargin, body, px, py, values) {
            // Tail
            const threshold = 0.000001;
            const tailLocal = tail.local;
            const tailLocalX = tailLocal.x;
            const tailLocalY = tailLocal.y;
            const x0 = tailLocalX - px;
            const y0 = tailLocalY - py;
            // Head
            const headLocal = head.local;
            const headLocalX = headLocal.x;
            const headLocalY = headLocal.y;
            const x1 = headLocalX - px;
            const y1 = headLocalY - py;
            // Body
            const bodyValues = body.values;
            const bodyValuesLength = bodyValues.length;
            // Tail points
            values[0] = x0;
            values[1] = y0;
            // Body points
            if (0 < bodyValuesLength) {
                const cx = (x1 + x0) * 0.5;
                const cy = (y1 + y0) * 0.5;
                const dx = x1 - x0;
                const dy = y1 - y0;
                const a = Math.atan2(dy, dx);
                const c = Math.cos(a);
                const s = Math.sin(a);
                const l = Math.sqrt(dx * dx + dy * dy);
                for (let i = 0; i < bodyValuesLength; i += 2) {
                    const x = bodyValues[i + 0];
                    const y = bodyValues[i + 1];
                    values[i + 2] = cx + (c * x - s * y) * l;
                    values[i + 3] = cy + (c * y + s * x) * l;
                }
            }
            // Head points
            values[2 + bodyValuesLength] = x1;
            values[3 + bodyValuesLength] = y1;
            // Tail margin
            if (tailMargin !== 0) {
                const dx = values[2] - x0;
                const dy = values[3] - y0;
                const d = dx * dx + dy * dy;
                if (threshold < d) {
                    const f = tailMargin / Math.sqrt(dx * dx + dy * dy);
                    values[0] = x0 + dx * f;
                    values[1] = y0 + dy * f;
                }
            }
            // Head margin
            if (headMargin !== 0) {
                const dx = values[0 + bodyValuesLength] - x1;
                const dy = values[1 + bodyValuesLength] - y1;
                const d = dx * dx + dy * dy;
                if (threshold < d) {
                    const f = headMargin / Math.sqrt(dx * dx + dy * dy);
                    values[2 + bodyValuesLength] = x1 + dx * f;
                    values[3 + bodyValuesLength] = y1 + dy * f;
                }
            }
            // Remove the rest
            values.length = bodyValuesLength + 4;
        }
        copy(source, part = EShapeCopyPart.ALL) {
            this.lock(EShapeLockPart.ALL);
            super.copy(source, part);
            if (source instanceof EShapeConnectorLine) {
                this._edge.copy(source.edge);
                this._body.copy(source.body);
            }
            this.unlock(EShapeLockPart.ALL, true);
            return this;
        }
        clone() {
            const constructor = this.constructor;
            return new constructor(this.type).copy(this);
        }
        serialize(manager) {
            const result = super.serialize(manager);
            const edgeId = this._edge.serialize(manager);
            const bodyId = this._body.serialize(manager);
            const pointsId = this._points.serialize(manager);
            result[15] = manager.addResource(`[${edgeId},${pointsId},${bodyId}]`);
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectors {
        static isConnector(target) {
            return target instanceof EShapeConnectorLine;
        }
        static newMapping(sources, destinations, result) {
            var _a;
            if (result == null) {
                result = (_a = EShapeConnectors._MAPPING) !== null && _a !== void 0 ? _a : (EShapeConnectors._MAPPING = new Map());
                result.clear();
            }
            for (let i = 0, imax = sources.length; i < imax; ++i) {
                const fromChild = sources[i];
                const toChild = destinations[i];
                result.set(fromChild, toChild);
                this.newMapping(fromChild.children, toChild.children, result);
            }
            return result;
        }
        static moveAll(rootSources, rootDestinations, sources, destinations, mapping) {
            for (let i = 0, imax = sources.length; i < imax; ++i) {
                const source = sources[i];
                const destination = destinations[i];
                if (this.isConnector(source)) {
                    if (this.isConnector(destination)) {
                        const sourceEdge = source.edge;
                        const destEdge = destination.edge;
                        const sourceHead = sourceEdge.head;
                        const sourceHeadShape = sourceHead.acceptor.shape;
                        if (sourceHeadShape) {
                            if (mapping == null) {
                                mapping = this.newMapping(rootSources, rootDestinations);
                            }
                            const destHeadShape = mapping.get(sourceHeadShape);
                            if (destHeadShape) {
                                const destHead = destEdge.head;
                                destHead.detach();
                                destHead.set(destHeadShape);
                                destHead.attach();
                                destHeadShape.connector.remove(sourceHead);
                            }
                        }
                        const sourceTail = sourceEdge.tail;
                        const sourceTailShape = sourceTail.acceptor.shape;
                        if (sourceTailShape) {
                            if (mapping == null) {
                                mapping = this.newMapping(rootSources, rootDestinations);
                            }
                            const destTailShape = mapping.get(sourceTailShape);
                            if (destTailShape) {
                                const destTail = destEdge.tail;
                                destTail.detach();
                                destTail.set(destTailShape);
                                destTail.attach();
                                destTailShape.connector.remove(sourceTail);
                            }
                        }
                    }
                }
                mapping = this.moveAll(rootSources, rootDestinations, source.children, destination.children, mapping);
            }
            return mapping;
        }
        static move(from, to) {
            const fromChildren = from.children;
            const toChildren = to.children;
            this.moveAll(fromChildren, toChildren, fromChildren, toChildren);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicAtlasItem {
        constructor(id, width, height, strokeWidth, baseTexture) {
            this.id = id;
            this.ref = 0;
            const resolution = baseTexture.resolution;
            this.frame = new pixi_js.Rectangle(0, 0, width * resolution, height * resolution);
            this.texture = new pixi_js.Texture(baseTexture, new pixi_js.Rectangle(0, 0, 1, 1));
            this.width = width;
            this.height = height;
            this.strokeWidth = strokeWidth;
        }
        applyFrame() {
            const resolutionInverse = 1 / this.texture.baseTexture.resolution;
            this.texture.frame.x = this.frame.x * resolutionInverse;
            this.texture.frame.y = this.frame.y * resolutionInverse;
            this.texture.frame.width = this.width;
            this.texture.frame.height = this.height;
            this.texture.updateUvs();
            this.texture.emit("update", this);
        }
        destroy() {
            this.texture.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicAtlasItemEmpty extends DynamicAtlasItem {
        render(context) {
            // DO NOTHING
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicAtlasItemWhite extends DynamicAtlasItem {
        render(context) {
            const frame = this.frame;
            context.save();
            context.fillStyle = "#ffffff";
            context.fillRect(frame.x - 1, frame.y - 1, frame.width + 2, frame.height + 2);
            context.restore();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const MAXIMUM_TEXTURE_SIZE = 4096;
    class DynamicAtlas {
        constructor(resolution) {
            const canvas = (this._canvas = document.createElement("canvas"));
            canvas.width = canvas.height = 256;
            const baseTexture = pixi_js.BaseTexture.from(canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution
            });
            this._baseTexture = baseTexture;
            this._idToDatum = {};
            this._sortedData = [];
            this._predefined = {
                empty: new DynamicAtlasItemEmpty("empty", 10, 10, 0, baseTexture),
                white: new DynamicAtlasItemWhite("white", 10, 10, 0, baseTexture)
            };
            this._isDirty = true;
        }
        updateFrames(width, data) {
            const padding = 4;
            let x = padding;
            let y = padding;
            let maxRowHeight = 0;
            for (let i = 0, imax = data.length; i < imax; ++i) {
                const datum = data[i];
                if (width < x + datum.frame.width + padding) {
                    x = padding;
                    y += maxRowHeight + padding;
                    maxRowHeight = 0;
                }
                datum.frame.x = x | 0;
                datum.frame.y = y | 0;
                x += datum.frame.width + padding;
                maxRowHeight = Math.max(maxRowHeight, datum.frame.height);
            }
            const minHeight = y + maxRowHeight + padding;
            let result = 256;
            while (result < minHeight) {
                result <<= 1;
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result);
        }
        renderFrames(width, height, data) {
            const canvas = this._canvas;
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext("2d");
            if (context != null) {
                for (let i = 0, imax = data.length; i < imax; ++i) {
                    const datum = data[i];
                    datum.render(context);
                }
            }
        }
        applyFrames(data) {
            for (let i = 0, imax = data.length; i < imax; ++i) {
                const datum = data[i];
                datum.applyFrame();
            }
        }
        calcCanvasWidth(data) {
            let result = 512;
            for (let i = data.length - 1; 0 <= i; --i) {
                const datum = data[i];
                const size = Math.max(datum.frame.width, datum.frame.height);
                while (result < size) {
                    result <<= 1;
                }
            }
            return Math.min(MAXIMUM_TEXTURE_SIZE, result << 1);
        }
        cleanup(data) {
            data.sort(DynamicAtlas.ITEM_COMPARATOR);
            for (let i = data.length - 1; 0 <= i; --i) {
                const datum = data[i];
                if (0 < datum.ref) {
                    data.length = i + 1;
                    return;
                }
            }
            data.length = 0;
        }
        begin() {
            const data = this._sortedData;
            for (let i = 0, imax = data.length; i < imax; ++i) {
                const datum = data[i];
                datum.ref = 0;
            }
            this._isDirty = false;
        }
        end() {
            const idToDatum = this._idToDatum;
            const data = this._sortedData;
            for (let i = 0, imax = data.length; i < imax; ++i) {
                const datum = data[i];
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[datum.id];
                    this._isDirty = true;
                }
            }
        }
        repack(forcibly) {
            if (forcibly === true || this._isDirty) {
                this._isDirty = false;
                const data = this._sortedData;
                this.cleanup(data);
                const canvasWidth = this.calcCanvasWidth(data);
                const canvasHeight = this.updateFrames(canvasWidth, data);
                this.renderFrames(canvasWidth, canvasHeight, data);
                this._baseTexture.setRealSize(canvasWidth, canvasHeight);
                this.applyFrames(data);
            }
        }
        get(id) {
            const idToDatum = this._idToDatum;
            const datum = idToDatum[id];
            if (datum != null) {
                datum.ref += 1;
                return datum;
            }
            else {
                const predefined = this._predefined[id];
                if (predefined != null) {
                    this.set(id, predefined);
                    return predefined;
                }
            }
            return null;
        }
        contains(id) {
            return id in this._idToDatum;
        }
        set(id, item) {
            const result = this._idToDatum[id];
            item.ref += 1;
            this._idToDatum[id] = item;
            this._sortedData.push(item);
            this._isDirty = true;
            return result;
        }
        toDirty() {
            this._isDirty = true;
        }
        getDefaultTexture() {
            return this.get("white").texture;
        }
        getBaseTexture() {
            return this._baseTexture;
        }
        release(id) {
            const idToDatum = this._idToDatum;
            const datum = idToDatum[id];
            if (datum != null) {
                datum.ref -= 1;
                if (datum.ref <= 0) {
                    if (!(datum.id in this._predefined)) {
                        datum.destroy();
                    }
                    delete idToDatum[id];
                    this._isDirty = true;
                }
            }
        }
        destroy() {
            const baseTexture = this._baseTexture;
            if (baseTexture != null) {
                baseTexture.destroy();
            }
        }
    }
    DynamicAtlas.ITEM_COMPARATOR = (a, b) => {
        if (a.ref <= 0) {
            if (b.ref <= 0) {
                return 0;
            }
            else {
                return +1;
            }
        }
        else {
            if (b.ref <= 0) {
                return -1;
            }
        }
        if (a.frame.height < b.frame.height) {
            return -1;
        }
        else if (b.frame.height < a.frame.height) {
            return +1;
        }
        else {
            return a.frame.width - b.frame.width;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicAtlasItemFontAtlas extends DynamicAtlasItem {
        constructor(atlas, baseTexture) {
            super(atlas.id, atlas.width / baseTexture.resolution, atlas.height / baseTexture.resolution, 0, baseTexture);
            this.canvas = atlas.canvas;
        }
        render(context) {
            const canvas = this.canvas;
            if (canvas != null) {
                const frame = this.frame;
                context.drawImage(canvas, frame.x, frame.y, frame.width, frame.height);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicFontAtlasCharacterOrigin {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicFontAtlasCharacter {
        constructor(type, character, x, y, width, height, advance) {
            this.ref = 1;
            this.life = DynamicFontAtlasCharacter.LIFE;
            this.character = character;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.advance = advance;
            this.origin = new DynamicFontAtlasCharacterOrigin(0, 0);
            this.type = type;
        }
    }
    DynamicFontAtlasCharacter.LIFE = 10;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const RESERVED = 1;
    const NON_BREAKING = 2;
    const SPACE = 4;
    const SPACE_R = SPACE | RESERVED;
    const SPACE_NB = SPACE | NON_BREAKING;
    const SPACE_RNB = SPACE | RESERVED | NON_BREAKING;
    const LETTER = 8;
    const LETTER_R = LETTER | RESERVED;
    const LETTER_NB = LETTER | NON_BREAKING;
    const LETTER_RNB = LETTER | RESERVED | NON_BREAKING;
    const DynamicFontAtlasCharacterType = {
        RESERVED,
        NON_BREAKING,
        SPACE,
        SPACE_R,
        SPACE_NB,
        SPACE_RNB,
        LETTER,
        LETTER_R,
        LETTER_NB,
        LETTER_RNB
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicSDFFontAtlasFont {
        constructor(fontFamily) {
            this.id = DynamicSDFFontAtlasFont.toFontFamily(fontFamily);
            this.size = 32;
            this.italic = false;
            this.measured = false;
            this.ascent = 0;
            this.descent = 0;
        }
        static toFontFamily(fontFamily) {
            return fontFamily === "auto" ? DynamicSDFFontAtlasFont.getAutoFontFamily() : fontFamily;
        }
        static getAutoFontFamily() {
            if (DynamicSDFFontAtlasFont.FONT_FAMILY_AUTO == null) {
                DynamicSDFFontAtlasFont.FONT_FAMILY_AUTO = DThemes.getInstance()
                    .get("DBase")
                    .getFontFamilly();
            }
            return DynamicSDFFontAtlasFont.FONT_FAMILY_AUTO;
        }
    }
    DynamicSDFFontAtlasFont.FONT_FAMILY_AUTO = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const VERTEX_SHADER$2 = `
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
varying mediump vec2 vTextureCoord;
void main(void) {
	gl_Position = vec4(aVertexPosition, 0.0, 1.0);
	vTextureCoord = aTextureCoord;
}
`;
    const FRAGMENT_SHADER$2 = `
precision mediump float;

varying mediump vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform vec2 uSize;

float norm(vec2 v) {
	return dot(v, v);
}

float norm(vec2 p, vec2 dp) {
	vec2 xy = p + dp;
	vec2 uvi = vec2(1.0) / uSize;
	vec2 uv = xy * uvi;
	vec4 t0 = vec4(texture2D(uSampler, uv).a);
	vec4 t1 = vec4(
		texture2D(uSampler, uv + vec2(-uvi.x, 0.0   )).a,
		texture2D(uSampler, uv + vec2(0.0   , -uvi.y)).a,
		texture2D(uSampler, uv + vec2(+uvi.x, 0.0   )).a,
		texture2D(uSampler, uv + vec2(0.0   , +uvi.y)).a
	);
	vec4 t2 = vec4(0.5);
	vec4 t3 = min(t1,t0);
	vec4 t4 = max(t1,t0);

	vec4 w0 = (t2 - t0) / (t1 - t0);
	vec4 s0 = vec4(
		t3.x < 0.5 && 0.5 <= t4.x,
		t3.y < 0.5 && 0.5 <= t4.y,
		t3.z < 0.5 && 0.5 <= t4.z,
		t3.w < 0.5 && 0.5 <= t4.w
	);
	vec4 l0 = vec4(
		norm(dp + vec2(-w0.x, 0.0  )),
		norm(dp + vec2(0.0  , -w0.y)),
		norm(dp + vec2(+w0.z, 0.0  )),
		norm(dp + vec2(0.0  , +w0.w))
	);
	vec4 c0 = vec4(100.0);
	vec4 r0 = mix(c0, l0, s0);

	vec4 w1 = w0 * vec4(0.5);
	vec4 s1 = vec4(
		0.5 < s0.x && 0.5 < s0.y,
		0.5 < s0.y && 0.5 < s0.z,
		0.5 < s0.z && 0.5 < s0.w,
		0.5 < s0.w && 0.5 < s0.x
	);
	vec4 l1 = vec4(
		norm(dp + vec2(-w1.x, -w1.y)),
		norm(dp + vec2(+w1.z, -w1.y)),
		norm(dp + vec2(+w1.z, +w1.w)),
		norm(dp + vec2(-w1.x, +w1.w))
	);
	vec4 r1 = mix(c0, l1, s1);
	vec4 r2 = min(r0, r1);
	vec2 r3 = min(r2.xy, r2.zw);
	return min(r3.x, r3.y);
}

float normY(vec2 p, float dx) {
	float result = 100.0;
	for (float dy=-6.0; dy < 6.5; dy += 1.0) {
		result = min(result, norm(p, vec2(dx, dy)));
	}
	return result;
}

float normX(vec2 p) {
	float result = 100.0;
	for (float dx=-6.0; dx < 6.5; dx += 1.0) {
		result = min(result, normY(p, dx));
	}
	return result;
}

void main(void) {
	float t = texture2D(uSampler, vTextureCoord).a;
	float d = min( 6.0, sqrt(normX( vTextureCoord * uSize )) ) / 12.0;
	d = clamp( mix( 0.5 - d, 0.5 + d, step( 0.5, t ) ), 0.0, 1.0 ) * 255.0;
	float r = floor(d);
	d = (d - r) * 255.0;
	float g = floor(d);
	gl_FragColor = vec4(r * 0.00392156862745098, g * 0.00392156862745098, d - g, 1.0);
}
`;
    class DynamicSDFFontGenerator {
        constructor() {
            this._gl = null;
            this._texture = null;
            this._shaderProgram = null;
            this._vertexPositionAttribute = 0;
            this._textureCoordAttribute = 1;
            this._samplerUniform = null;
            this._sizeUniform = null;
            this._vb = null;
            this._uvb = null;
            const canvas = (this._canvas = document.createElement("canvas"));
            canvas.width = 64;
            canvas.height = 64;
            this._onLostBound = (e) => {
                e.preventDefault();
            };
            this._onRestoreBound = () => {
                this.restore();
            };
            this._onUnloadBound = () => {
                this.destroy();
            };
            canvas.addEventListener("webglcontextlost", this._onLostBound, false);
            canvas.addEventListener("webglcontextrestored", this._onRestoreBound, false);
            window.addEventListener("unload", this._onUnloadBound, false);
        }
        init() {
            const canvas = this._canvas;
            if (canvas != null && (this._gl == null || this._gl.isContextLost())) {
                const config = {
                    alpha: true,
                    antialias: false,
                    depth: false,
                    stencil: false,
                    premultipliedAlpha: false
                };
                const gl = canvas.getContext("webgl", config) ||
                    canvas.getContext("experimental-webgl", config);
                this._gl = gl;
                if (gl != null) {
                    gl.clearColor(1.0, 1.0, 1.0, 0.0);
                    this.makeVertexBuffer();
                    this.makeUvBuffer();
                    this.makeShaders();
                    this._texture = null;
                }
            }
            return this;
        }
        restore() {
            this.init();
        }
        getCanvas() {
            return this._canvas;
        }
        getShader(gl, code, type) {
            const shader = type
                ? gl.createShader(gl.FRAGMENT_SHADER)
                : gl.createShader(gl.VERTEX_SHADER);
            if (shader != null) {
                gl.shaderSource(shader, code);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console &&
                        console.error(`Failed to compile the shader: ${gl.getShaderInfoLog(shader)}`);
                    return null;
                }
            }
            return shader;
        }
        makeShaders() {
            const gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                const vertexShader = this.getShader(gl, VERTEX_SHADER$2, false);
                if (vertexShader != null) {
                    const fragmentShader = this.getShader(gl, FRAGMENT_SHADER$2, true);
                    if (fragmentShader != null) {
                        const shaderProgram = (this._shaderProgram = gl.createProgram());
                        if (shaderProgram != null) {
                            gl.attachShader(shaderProgram, vertexShader);
                            gl.attachShader(shaderProgram, fragmentShader);
                            gl.bindAttribLocation(shaderProgram, 0, "aVertexPosition");
                            gl.bindAttribLocation(shaderProgram, 1, "aTextureCoord");
                            gl.linkProgram(shaderProgram);
                            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                                console &&
                                    console.error(`Failed to link the program: ${gl.getError()}`);
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                return null;
                            }
                            else {
                                gl.deleteShader(vertexShader);
                                gl.deleteShader(fragmentShader);
                                gl.useProgram(shaderProgram);
                                this._samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
                                this._sizeUniform = gl.getUniformLocation(shaderProgram, "uSize");
                                gl.useProgram(null);
                                return shaderProgram;
                            }
                        }
                        else {
                            gl.deleteShader(vertexShader);
                            gl.deleteShader(fragmentShader);
                        }
                    }
                    else {
                        gl.deleteShader(vertexShader);
                    }
                }
            }
            return null;
        }
        destroyShaders() {
            const gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                const shaderProgram = this._shaderProgram;
                if (shaderProgram != null) {
                    this._shaderProgram = null;
                    gl.useProgram(null);
                    gl.deleteProgram(shaderProgram);
                }
            }
        }
        updateTexture(width, height, source) {
            const gl = this._gl;
            const canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                    gl.viewport(0, 0, width, height);
                }
                let texture = this._texture;
                if (texture == null) {
                    texture = this._texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                return texture;
            }
            return null;
        }
        destroyTexture() {
            const gl = this._gl;
            const texture = this._texture;
            if (gl != null && gl.isContextLost() !== true && texture != null) {
                this._texture = null;
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.deleteTexture(texture);
            }
        }
        makeVertexBuffer() {
            const gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                const vb = (this._vb = gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                const vertices = [-1.0, +1.0, +1.0, +1.0, -1.0, -1.0, +1.0, -1.0];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                return vb;
            }
            return null;
        }
        destroyVertexBuffer() {
            const gl = this._gl;
            const vb = this._vb;
            if (gl != null && gl.isContextLost() !== true && vb != null) {
                this._vb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(vb);
            }
        }
        makeUvBuffer() {
            const gl = this._gl;
            if (gl != null && gl.isContextLost() !== true) {
                const uvb = (this._uvb = gl.createBuffer());
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                const uvs = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvs), gl.STATIC_DRAW);
                return uvb;
            }
            return null;
        }
        destroyUvBuffer() {
            const gl = this._gl;
            const uvb = this._uvb;
            if (gl != null && gl.isContextLost() !== true && uvb != null) {
                this._uvb = null;
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(uvb);
            }
        }
        render() {
            const gl = this._gl;
            const canvas = this._canvas;
            const shaderProgram = this._shaderProgram;
            const vb = this._vb;
            const uvb = this._uvb;
            const texture = this._texture;
            if (gl != null &&
                gl.isContextLost() !== true &&
                canvas != null &&
                shaderProgram != null &&
                vb != null &&
                uvb != null &&
                texture != null) {
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.useProgram(shaderProgram);
                gl.bindBuffer(gl.ARRAY_BUFFER, vb);
                const vertexPositionAttribute = this._vertexPositionAttribute;
                gl.enableVertexAttribArray(vertexPositionAttribute);
                gl.vertexAttribPointer(vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, uvb);
                const textureCoordAttribute = this._textureCoordAttribute;
                gl.enableVertexAttribArray(textureCoordAttribute);
                gl.vertexAttribPointer(textureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.uniform1i(this._samplerUniform, 0);
                gl.uniform2f(this._sizeUniform, canvas.width, canvas.height);
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.useProgram(null);
            }
        }
        read(copyCanvas) {
            const gl = this._gl;
            const canvas = this._canvas;
            if (gl != null && gl.isContextLost() !== true && canvas != null) {
                const width = canvas.width;
                const height = canvas.height;
                copyCanvas.width = width;
                copyCanvas.height = height;
                const copyContext = copyCanvas.getContext("2d");
                if (copyContext != null) {
                    copyContext.drawImage(canvas, 0, 0);
                }
            }
        }
        destroy() {
            this.destroyVertexBuffer();
            this.destroyUvBuffer();
            this.destroyShaders();
            const canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
                canvas.removeEventListener("webglcontextlost", this._onLostBound, false);
                canvas.removeEventListener("webglcontextrestored", this._onRestoreBound, false);
                window.removeEventListener("unload", this._onUnloadBound, false);
            }
            const gl = this._gl;
            if (gl != null) {
                this._gl = null;
                const WebGLLoseContext = gl.getExtension("WEBGL_lose_context");
                if (WebGLLoseContext != null) {
                    WebGLLoseContext.loseContext();
                }
            }
        }
        static getInstance() {
            if (DynamicSDFFontGenerator._INSTANCE == null) {
                DynamicSDFFontGenerator._INSTANCE = new DynamicSDFFontGenerator();
            }
            return DynamicSDFFontGenerator._INSTANCE;
        }
    }
    DynamicSDFFontGenerator._INSTANCE = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilFont {
        static measure(context, font) {
            if (!font.measured) {
                if ("fontBoundingBoxAscent" in window.TextMetrics.prototype) {
                    const metrics = context.measureText(pixi_js.TextMetrics.METRICS_STRING);
                    font.ascent = metrics.fontBoundingBoxAscent;
                    font.descent = metrics.fontBoundingBoxDescent;
                }
                else {
                    const measured = pixi_js.TextMetrics.measureFont(font.id);
                    font.ascent = measured.ascent;
                    font.descent = measured.descent;
                }
                font.measured = true;
            }
        }
        static toSize(font) {
            this.setup(font);
            return parseFloat(window.getComputedStyle(this._span).fontSize);
        }
        static setup(font) {
            let span = this._span;
            if (span == null) {
                span = document.createElement("span");
                span.innerText = "|ÉqÅ";
                span.style.border = "none";
                span.style.margin = "0px";
                this._span = span;
            }
            let block = this._block;
            if (block == null) {
                block = document.createElement("div");
                block.style.display = "inline-block";
                block.style.width = "0px";
                block.style.height = "0px";
                block.style.border = "none";
                block.style.margin = "0px";
                block.style.verticalAlign = "baseline";
                this._block = block;
            }
            let div = this._div;
            if (div == null) {
                div = document.createElement("div");
                div.style.position = "absolute";
                div.style.padding = "0px";
                div.style.margin = "0px";
                div.style.visibility = "hidden";
                div.appendChild(span);
                div.appendChild(block);
                document.body.appendChild(div);
                this._div = div;
            }
            span.style.font = font;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicSDFFontAtlas {
        constructor(fontFamily) {
            this._id = `font-atlas:${fontFamily}`;
            this._generator = DynamicSDFFontGenerator.getInstance().init();
            this._canvas = document.createElement("canvas");
            this._font = new DynamicSDFFontAtlasFont(fontFamily);
            this._width = 1;
            this._height = 1;
            const characters = new Map();
            characters.set(Character.SPACE, this.newChar(Character.SPACE, DynamicFontAtlasCharacterType.SPACE_R));
            characters.set(Character.TAB, this.newChar(Character.SOFT_TAB, DynamicFontAtlasCharacterType.SPACE_R));
            characters.set(Character.DOTS, this.newChar(Character.DOTS, DynamicFontAtlasCharacterType.LETTER_RNB));
            for (let i = 0, imax = Character.ASCII.length; i < imax; ++i) {
                const ac = Character.ASCII[i];
                characters.set(ac, this.newChar(ac, DynamicFontAtlasCharacterType.LETTER_RNB));
            }
            this._characters = characters;
            this._isDirty = true;
            this._isTouched = false;
            this._life = DynamicFontAtlasCharacter.LIFE;
        }
        get id() {
            return this._id;
        }
        get font() {
            return this._font;
        }
        set font(font) {
            this._font.id = font.id;
            this._font.size = font.size;
            this._font.italic = font.italic;
        }
        get width() {
            return this._width;
        }
        get height() {
            return this._height;
        }
        get canvas() {
            return this._canvas;
        }
        get generator() {
            return this._generator;
        }
        get characters() {
            return this._characters;
        }
        begin() {
            this._isTouched = false;
            this._characters.forEach((character) => {
                if (!(character.type & DynamicFontAtlasCharacterType.RESERVED)) {
                    character.ref = 0;
                }
            });
        }
        end() {
            const characters = this._characters;
            if (this._isTouched) {
                this._life = DynamicFontAtlasCharacter.LIFE;
                characters.forEach((character, id) => {
                    if (character.ref <= 0 &&
                        !(character.type & DynamicFontAtlasCharacterType.RESERVED)) {
                        character.life -= 1;
                        if (character.life <= 0) {
                            characters.delete(id);
                            this._isDirty = true;
                        }
                    }
                });
            }
            else {
                this._life -= 1;
                if (this._life <= 0 && 0 < characters.size) {
                    characters.clear();
                    this._isDirty = true;
                }
            }
        }
        newChar(character, type) {
            return new DynamicFontAtlasCharacter(type, character, 0, 0, 1, 1, 0);
        }
        add(characters, nacharacters) {
            const cs = this._characters;
            for (let i = 0, imax = nacharacters.length; i < imax; ++i) {
                const nac = nacharacters[i];
                const data = cs.get(nac);
                if (data != null) {
                    data.ref += 1;
                    data.life = DynamicFontAtlasCharacter.LIFE;
                }
                else {
                    cs.set(nac, this.newChar(nac, DynamicFontAtlasCharacterType.LETTER));
                    this._isDirty = true;
                }
            }
            if (0 < characters.length) {
                this._isTouched = true;
            }
        }
        get(id) {
            return this._characters.get(id);
        }
        update() {
            if (this._isDirty) {
                const canvas = this._canvas;
                const generator = this._generator;
                if (canvas != null && generator != null) {
                    const context = canvas.getContext("2d");
                    if (context != null) {
                        this._isDirty = false;
                        const font = this._font;
                        const fontSize = font.size + 14;
                        const characters = this._characters;
                        const width = this.toPowerOf2(Math.ceil(Math.sqrt(characters.size)) * fontSize);
                        this._width = width;
                        const fontStyle = (font.italic ? "italic " : "") + (font.size + "px ") + font.id;
                        context.font = fontStyle;
                        context.textAlign = "left";
                        context.textBaseline = "alphabetic";
                        context.lineWidth = 0;
                        context.lineCap = "round";
                        context.lineJoin = "miter";
                        context.miterLimit = 10;
                        context.fillStyle = "#FFFFFF";
                        UtilFont.measure(context, font);
                        const offsetX = 7;
                        const offsetY = Math.round((fontSize - (font.ascent + font.descent)) * 0.5 + font.ascent);
                        let x = 0;
                        let y = 0;
                        characters.forEach((character) => {
                            const advance = context.measureText(character.character).width;
                            const characterWidth = Math.ceil(offsetX + advance + offsetX);
                            const characterHeight = fontSize;
                            if (width <= x + characterWidth) {
                                x = 0;
                                y += fontSize;
                            }
                            character.x = x;
                            character.y = y;
                            character.width = characterWidth;
                            character.height = characterHeight;
                            character.advance = advance;
                            character.origin.x = x + offsetX;
                            character.origin.y = y + offsetY;
                            x += characterWidth;
                        });
                        const height = (this._height = y + fontSize);
                        // Make a input canvas
                        // Here, we need to reset the context because
                        // context settings will be lost when we set the width/height.
                        canvas.width = width;
                        canvas.height = height;
                        context.font = fontStyle;
                        context.textAlign = "left";
                        context.textBaseline = "alphabetic";
                        context.lineWidth = 0;
                        context.lineCap = "round";
                        context.lineJoin = "miter";
                        context.miterLimit = 10;
                        context.fillStyle = "#FFFFFF";
                        context.clearRect(0, 0, width, height);
                        characters.forEach((character) => {
                            context.fillText(character.character, character.origin.x, character.origin.y);
                        });
                        // Convert to SDF font texture
                        generator.updateTexture(width, height, canvas);
                        generator.render();
                        generator.read(canvas);
                        return true;
                    }
                }
            }
            return false;
        }
        get length() {
            return this._characters.size;
        }
        toJson() {
            return {
                width: this._width,
                height: this._height,
                font: this._font,
                characters: this._characters
            };
        }
        toString() {
            return JSON.stringify(this.toJson());
        }
        destroy() {
            const generator = this._generator;
            if (generator != null) {
                this._generator = null;
            }
            const canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            this._characters.clear();
        }
        toPowerOf2(size) {
            let result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicSDFFontAtlases {
        constructor() {
            this._atlases = new Map();
        }
        begin() {
            this._atlases.forEach((atlas) => {
                atlas.begin();
            });
        }
        end() {
            const atlases = this._atlases;
            atlases.forEach((atlas, family) => {
                atlas.end();
                if (atlas.length <= 0) {
                    atlas.destroy();
                    atlases.delete(family);
                }
            });
        }
        add(family, characters, nacharacters) {
            const atlases = this._atlases;
            const atlas = atlases.get(family);
            if (atlas != null) {
                atlas.add(characters, nacharacters);
            }
            else {
                const newAtlas = new DynamicSDFFontAtlas(family);
                newAtlas.add(characters, nacharacters);
                atlases.set(family, newAtlas);
            }
        }
        get(family) {
            const atlas = this._atlases.get(family);
            if (atlas != null) {
                return atlas;
            }
            return null;
        }
        update(baseAtlas) {
            const baseTexture = baseAtlas.getBaseTexture();
            this._atlases.forEach((atlas) => {
                const atlasId = atlas.id;
                if (atlas.update()) {
                    const item = baseAtlas.get(atlasId);
                    if (item != null) {
                        const width = atlas.width;
                        const height = atlas.height;
                        const resolution = baseTexture.resolution;
                        item.frame.width = width;
                        item.frame.height = height;
                        item.width = width / resolution;
                        item.height = height / resolution;
                        baseAtlas.toDirty();
                    }
                    else {
                        baseAtlas.set(atlasId, new DynamicAtlasItemFontAtlas(atlas, baseTexture));
                    }
                }
                else {
                    if (!baseAtlas.contains(atlasId)) {
                        baseAtlas.set(atlasId, new DynamicAtlasItemFontAtlas(atlas, baseTexture));
                    }
                }
            });
        }
        destroy() {
            const atlases = this._atlases;
            atlases.forEach((atlas) => {
                atlas.destroy();
            });
            atlases.clear();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicAtlasItemImage extends DynamicAtlasItem {
        constructor(src, width, height, source, baseTexture) {
            super(src, width / baseTexture.resolution, height / baseTexture.resolution, 0, baseTexture);
            this.source = source;
        }
        render(context) {
            const frame = this.frame;
            const x = frame.x;
            const y = frame.y;
            const w = frame.width;
            const h = frame.height;
            const source = this.source;
            if (source instanceof ImageData) {
                context.putImageData(source, x, y);
                context.putImageData(source, x - 1, y, 0, 0, 1, h);
                context.putImageData(source, x, y - 1, 0, 0, w, 1);
                context.putImageData(source, x + w, y, w - 1, 0, 1, h);
                context.putImageData(source, x, y + h, 0, h - 1, w, 1);
            }
            else {
                context.drawImage(source, x, y, w, h);
                context.drawImage(source, 0, 0, 1, h, x - 1, y - 1, 1, h + 2);
                context.drawImage(source, 0, 0, w, 1, x, y - 1, w, 1);
                context.drawImage(source, w - 1, 0, 1, h, x + w, y - 1, 1, h + 2);
                context.drawImage(source, 0, h - 1, w, 1, x, y + h, w, 1);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeBufferUnit {
        constructor(texture, indexOffset) {
            this.texture = texture;
            this.indexOffset = indexOffset;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeBufferUnitBuilder {
        constructor() {
            this.index = 0;
            this.baseTexture = null;
            this.units = [];
        }
        begin() {
            this.index = 0;
            this.baseTexture = null;
        }
        push(texture, indexOffset) {
            if (this.index < this.units.length) {
                const unit = this.units[this.index];
                unit.texture = texture;
                unit.indexOffset = indexOffset;
            }
            else {
                this.units.push(new EShapeBufferUnit(texture, indexOffset));
            }
            this.index += 1;
        }
        end() {
            if (this.units.length !== this.index) {
                this.units.length = this.index;
            }
        }
        destroy() {
            this.units.length = 0;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeBuffer {
        constructor(ntriangles, renderer) {
            const nindices = ntriangles * 3;
            const nvertices = nindices;
            this.vertices = new Float32Array(nvertices * 2);
            this._vertexCapacity = nvertices;
            this._vertexCount = 0;
            this._vertexBuffer = null;
            this.steps = new Float32Array(nvertices * 6);
            this._stepBuffer = null;
            this.colors = new Float32Array(nvertices * 3);
            this._colorBuffer = null;
            this.uvs = new Float32Array(nvertices * 2);
            this._uvBuffer = null;
            const isIndicesShort = nvertices <= 65535;
            this.indices = isIndicesShort ? new Uint16Array(nindices) : new Uint32Array(nindices);
            this._indexCapacity = ntriangles;
            this._indexCount = 0;
            this.indexCountRequested = 0;
            this._indexBuffer = null;
            this._renderer = renderer;
            this._builder = new EShapeBufferUnitBuilder();
            this._geometry = null;
        }
        updateVertices() {
            const vertexBuffer = this._vertexBuffer;
            if (vertexBuffer) {
                vertexBuffer.update();
            }
        }
        updateSteps() {
            const stepBuffer = this._stepBuffer;
            if (stepBuffer) {
                stepBuffer.update();
            }
        }
        updateColors() {
            const colorBuffer = this._colorBuffer;
            if (colorBuffer) {
                colorBuffer.update();
            }
        }
        updateUvs() {
            const uvBuffer = this._uvBuffer;
            if (uvBuffer) {
                uvBuffer.update();
            }
        }
        updateIndices() {
            const indexBuffer = this._indexBuffer;
            if (indexBuffer) {
                indexBuffer.update();
            }
        }
        getGeometry() {
            let result = this._geometry;
            if (result == null) {
                this._vertexBuffer = new pixi_js.Buffer(this.vertices, false, false);
                this._stepBuffer = new pixi_js.Buffer(this.steps, false, false);
                this._colorBuffer = new pixi_js.Buffer(this.colors, false, false);
                this._uvBuffer = new pixi_js.Buffer(this.uvs, false, false);
                this._indexBuffer = new pixi_js.Buffer(this.indices, false, true);
                this._geometry = result = new pixi_js.Geometry()
                    .addIndex(this._indexBuffer)
                    .addAttribute("aPosition", this._vertexBuffer, 2)
                    .addAttribute("aStepA", this._stepBuffer, 2)
                    .addAttribute("aStepB", this._stepBuffer, 4)
                    .addAttribute("aColor", this._colorBuffer, 3)
                    .addAttribute("aUv", this._uvBuffer, 2);
            }
            return result;
        }
        upload() {
            this._renderer.geometry.bind(this.getGeometry());
        }
        render(shader) {
            const renderer = this._renderer;
            renderer.geometry.bind(this.getGeometry());
            const units = this._builder.units;
            const unitCount = units.length;
            if (0 < unitCount) {
                const type = pixi_js.DRAW_MODES.TRIANGLES;
                let unit0 = null;
                let unit1 = units[0];
                let ioffset0 = 0;
                let ioffset1 = unit1.indexOffset * 3;
                let vcount = 0;
                let texture = pixi_js.Texture.WHITE;
                for (let i = 0, imax = unitCount - 1; i < imax; ++i) {
                    unit0 = unit1;
                    unit1 = units[i + 1];
                    ioffset0 = ioffset1;
                    ioffset1 = unit1.indexOffset * 3;
                    vcount = ioffset1 - ioffset0;
                    texture = unit0.texture || pixi_js.Texture.WHITE;
                    if (0 < vcount && texture.valid) {
                        shader.uniforms.sampler = renderer.texture.bind(texture);
                        renderer.geometry.draw(type, vcount, ioffset0);
                    }
                }
                vcount = this._indexCount * 3 - ioffset1;
                texture = unit1.texture || pixi_js.Texture.WHITE;
                if (0 < vcount && texture.valid) {
                    shader.uniforms.sampler = renderer.texture.bind(texture);
                    renderer.geometry.draw(type, vcount, ioffset1);
                }
            }
        }
        update(iterator, antialiasWeight, noMoreThanOne) {
            const builder = this._builder;
            builder.begin();
            let vindex = 0;
            let iindex = 0;
            let shape = iterator.get();
            for (; shape != null; shape = iterator.next()) {
                let uploaded = shape.uploaded;
                if (uploaded == null) {
                    const creator = EShapeUploadeds[shape.type] || EShapeUploadeds[EShapeType.GROUP];
                    if (creator == null) {
                        break;
                    }
                    const newUploaded = creator(this, shape, vindex, iindex, antialiasWeight);
                    if (newUploaded == null) {
                        break;
                    }
                    uploaded = newUploaded;
                }
                else if (!uploaded.reinit(this, shape, vindex, iindex)) {
                    break;
                }
                uploaded.buildUnit(builder);
                vindex += uploaded.getVertexCount();
                iindex += uploaded.getIndexCount();
                if (noMoreThanOne) {
                    iterator.next();
                    break;
                }
            }
            builder.end();
            this._vertexCount = vindex;
            this._indexCount = iindex;
            return 0 < builder.units.length;
        }
        check(vindex, ioffset, vcount, icount) {
            this.indexCountRequested = icount;
            return vindex + vcount <= this._vertexCapacity && ioffset + icount <= this._indexCapacity;
        }
        destroy() {
            const geometry = this._geometry;
            if (geometry) {
                geometry.destroy();
            }
            this._builder.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DUMMY_SHAPES = [];
    class EShapeRendererIteratorDatum {
        constructor() {
            this.index = 0;
            this.shapes = DUMMY_SHAPES;
            this.current = null;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeRendererIterator {
        constructor() {
            this._index = -1;
            this._datum = new EShapeRendererIteratorDatum();
            this._data = [this._datum];
            this._current = null;
        }
        reset(shape, shapes) {
            this._index = 0;
            const datum = this._data[0];
            datum.index = -1;
            datum.shapes = shapes;
            datum.current = null;
            this._datum = datum;
            if (shape != null) {
                this._current = shape;
                return shape;
            }
            return this.next();
        }
        get() {
            return this._current;
        }
        next() {
            while (true) {
                const datum = this._datum;
                const shapeIndex = (datum.index += 1);
                const shapes = datum.shapes;
                const shape = shapeIndex < shapes.length
                    ? (datum.current = shapes[shapeIndex])
                    : (datum.current = null);
                if (shape != null) {
                    const children = shape.children;
                    if (0 < children.length) {
                        const dataIndex = (this._index += 1);
                        const data = this._data;
                        if (dataIndex < data.length) {
                            const newDatum = data[dataIndex];
                            newDatum.index = -1;
                            newDatum.shapes = children;
                            newDatum.current = null;
                            this._datum = newDatum;
                        }
                        else {
                            const newDatum = new EShapeRendererIteratorDatum();
                            data.push(newDatum);
                            newDatum.index = -1;
                            newDatum.shapes = children;
                            newDatum.current = null;
                            this._datum = newDatum;
                        }
                    }
                    else {
                        this._current = shape;
                        return shape;
                    }
                }
                else {
                    const dataIndex = (this._index -= 1);
                    const data = this._data;
                    if (0 <= dataIndex) {
                        const newDatum = data[dataIndex];
                        this._datum = newDatum;
                        return (this._current = newDatum.current);
                    }
                    else {
                        return (this._current = null);
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const VERTEX_SHADER$1 = `
attribute highp vec2 aPosition;
attribute highp vec2 aStepA;
attribute highp vec4 aStepB;
attribute highp vec3 aColor;
attribute highp vec2 aUv;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mediump float shapeScale;
uniform mediump float antialiasWeight;

varying mediump float vType;
varying mediump vec2 vStepA;
varying mediump vec4 vStepB;
varying mediump vec4 vColorFill;
varying mediump vec4 vColorStroke;
varying mediump vec2 vUv;

vec2 toInverse(in vec2 v) {
	return vec2(-v.y, v.x);
}

vec4 toGeneral(in float v) {
	vec4 c = vec4(1.0, 1.0/64.0, 1.0/64.0/64.0, 1.0/64.0/64.0/64.0) * v;
	c -= fract(c);
	c -= c.yzwx * vec4(64.0, 64.0, 64.0, 0.0);
	return c;
}

float toStrokeWidthScale(in float scale) {
	return (
		scale == 3.0 || scale == 7.0 ?
		shapeScale : (
			scale == 1.0 || scale == 5.0 ?
			min(1.0, shapeScale) : (
				scale == 2.0 || scale == 6.0 ?
				max(1.0, shapeScale) : 1.0
			)
		)
	);
}

vec2 toUnpackedF2x1024(in float v) {
	vec2 c = vec2(1.0, 1.0/1024.0) * v;
	c -= fract(c);
	c -= c.yx * vec2(1024.0, 0.0);
	c /= vec2(1023.0, 1023.0);
	return c;
}

vec3 toUnpackedF3x256(in float v) {
	vec3 c = vec3(1.0, 1.0/256.0, 1.0/256.0/256.0) * v;
	c -= fract(c);
	c -= c.yzx * vec3(256.0, 256.0, 0.0);
	c /= 255.0;
	return c;
}

vec2 toPosition012(in vec2 v) {
	return (projectionMatrix * translationMatrix * vec3(v, 1.0)).xy;
}

vec4 toStepB01(in vec4 sb) {
	return vec4(sb.xy, toUnpackedF2x1024(sb.z));
}

vec4 toStepB2(in vec4 sb, in float strokeWidth) {
	float x = min(0.4, 0.4 / 12.0 * sb.x * antialiasWeight);
	float w = clamp(strokeWidth, 0.0, 1.0) * 0.4;
	float p = w * sb.y + sb.z;
	float y = 0.5 - p;
	float z = 0.5 - p - w;
	return vec4(y, z, y - max(0.01, y - x), z - max(0.01, z - x));
}

vec2 toPosition3(in float type, in vec2 p, in float npacked, in float length, in float strokeWidth, out float shift) {
	vec3 t = vec3(1.0, 1.0/1024.0, 1.0/1024.0/1024.0) * npacked;
	t -= fract(t);
	t -= t.yzx * vec3(1024.0, 1024.0, 0.0);
	t *= vec3(1.0/511.5, 1.0/511.5, 1.0);
	t -= vec3(1.0, 1.0, 0.0);
	vec2 n0 = vec2(t.x, ((0.5 < t.z && t.z < 1.5) || 2.5 < t.z ? +1.0 : -1.0) * sqrt(max(0.0, 1.0 - t.x * t.x)));
	vec2 n1 = vec2(t.y, (1.5 < t.z ? +1.0 : -1.0) * sqrt(max(0.0, 1.0 - t.y * t.y)));

	vec2 n0i = toInverse(n0);
	vec2 n1i = toInverse(n1);
	float direction = sign(4.5 - type);

	// Offset
	float cross = dot(n0i, n1);
	bool bcross = 0.00001 < abs(cross);
	float crossi = (bcross ? 1.0 / cross : 0.0);
	float b = dot(n1 - n0, n0) * crossi;
	float offsetSize = direction * strokeWidth * 0.5;
	vec2 offset = n1 + n1i * b;

	// Miter
	vec2 pmiter = p + offsetSize * offset;
	float miterAngle0 = dot( n0i, offsetSize * offset - length * n0i );
	float miterAngle1 = dot( n1i, offsetSize * offset + length * n1i );
	float miterLength = dot( offset, offset );
	float miterSide = direction * cross;

	// Bevel
	vec2 n = (type == 4.0 || type == 6.0 ? n1 : n0);
	vec2 pbevel = p + offsetSize * n;

	//
	vec2 presult = (
		0.0 <= miterSide ?
		(miterAngle0 < 0.0 && 0.0 <= miterAngle1 && bcross ? pmiter : pbevel) :
		(miterLength < 6.0 && bcross ? pmiter : pbevel)
	);
	vec2 ni = (type == 4.0 || type == 6.0 ? n1i : n0i);
	shift = dot(ni, p - presult);
	return toPosition012(presult);
}

vec2 toStepA3(in float type, in float strokeWidth) {
	return vec2(type < 4.5 ? 1.0 : 0.0, strokeWidth);
}

vec4 toStepB3(in float shift, in float dash, in float strokeScaling, in float strokeWidthScale) {
	float l = aStepB.y + shift;
	float s = aStepA.x * (
		strokeScaling == 4.0 || strokeScaling == 5.0 ||
		strokeScaling == 6.0 || strokeScaling == 7.0 ?
		strokeWidthScale : 1.0
	);
	float lt = aStepB.z;
	return (dash < 0.5 ?
		vec4(l, 2.0 * abs(lt), 0.0, lt) :
		(dash < 3.5 ?
			(dash < 1.5 ?
				vec4(l, s, s, lt) :
				(2.5 < dash ?
					vec4(l, s, 2.0 * s, lt) :
					vec4(l, s, 0.5 * s, lt)
				)
			) :
			(dash < 4.5 ?
				vec4(l, 2.0 * s, s, lt) :
				(5.5 < dash ?
					vec4(l, 2.0 * s, 2.0 * s, lt) :
					vec4(l, 2.0 * s, 0.5 * s, lt)
				)
			)
		)
	);
}

void toColors(in vec3 source, out vec4 fillColor, out vec4 strokeColor) {
	vec2 a = toUnpackedF2x1024(source.z);
	fillColor.xyz = toUnpackedF3x256(source.x).zyx * a.x;
	fillColor.w = a.x;
	strokeColor.xyz = toUnpackedF3x256(source.y).zyx * a.y;
	strokeColor.w = a.y;
}

void main(void) {
	vec4 general = toGeneral(aStepA.y);
	float type = general.x;
	float strokeScaling = general.y;
	float strokeWidthScale = toStrokeWidthScale(strokeScaling);
	float strokeWidth = strokeWidthScale * aStepA.x;

	// Type 0, 1
	vec2 p012 = toPosition012(aPosition);
	vec2 sa012 = strokeWidth * general.zw;
	vec4 sb01 = toStepB01(aStepB);

	// Type 2
	vec4 sb2 = toStepB2(aStepB, strokeWidth);

	// Type 3 ~ 6
	float shift3 = 0.0;
	vec2 p3 = toPosition3(type, aPosition, aStepB.x, aStepB.w, strokeWidth, shift3);
	vec2 sa3 = toStepA3(type, strokeWidth);
	vec4 sb3 = toStepB3(shift3, general.z, strokeScaling, strokeWidthScale);

	//
	gl_Position = vec4((2.5 < type ? p3 : p012), 0.0, 1.0);
	vType = type;
	vStepA = (2.5 < type ? sa3 : sa012);
	vStepB = (1.5 < type ? (2.5 < type ? sb3 : sb2) : sb01);
	toColors(aColor, vColorFill, vColorStroke);
	vUv = aUv;
}`;
    const FRAGMENT_SHADER$1 = `
varying mediump float vType;
varying mediump vec2 vStepA;
varying mediump vec4 vStepB;
varying mediump vec4 vColorFill;
varying mediump vec4 vColorStroke;
varying mediump vec2 vUv;

uniform sampler2D sampler;
uniform mediump float antialiasWeight;

vec4 toColor0(in vec4 texture) {
	vec2 d = vStepB.xy;
	vec2 c = vStepB.zw;
	vec2 awd = antialiasWeight / d;
	vec2 swd = vStepA / d;
	vec2 one = vec2(1.0);
	vec2 zero = vec2(0.0);
	vec2 p0 = clamp(one - awd, zero, one);
	vec2 p1 = clamp(one - swd, zero, one);
	vec2 p2 = clamp(one - swd - awd, zero, one);
	vec2 s0 = smoothstep(p0, one, c);
	vec2 s1 = smoothstep(p2, p1, c);
	float s2 = max(s0.x, s0.y);
	float s3 = max(s1.x, s1.y);
	return texture * (
		vColorStroke * (s3 - s2) +
		vColorFill * (1.0 - s3)
	);
}

vec4 toColor1(in vec4 texture) {
	vec2 d = vStepB.xy;
	vec2 c = vStepB.zw;
	vec2 awd = antialiasWeight / d;
	vec2 swd = vStepA / d;
	vec2 one = vec2(1.0);
	vec2 zero = vec2(0.0);
	float s0 = smoothstep(length(c), length(c/clamp(one - awd, zero, one)), 1.0);
	float s1 = smoothstep(length(c/clamp(one - swd, zero, one)), length(c/clamp(one - swd - awd, zero, one)), 1.0);
	return texture * (
		vColorStroke * (s0 - s1) +
		vColorFill * s1
	);
}

vec4 toColor2(in vec4 texture) {
	vec2 p0 = vStepB.xy;
	vec2 p1 = vStepB.zw;
	vec2 d = vec2(dot(texture, vec4(1.0, 1.0/255.0, 1.0/255.0/255.0, 0.0)));
	vec2 s = smoothstep(p0 - p1, p0 + p1, d);
	return vColorStroke * (s.y - s.x) + vColorFill * s.x;
}

vec4 toColor3(in vec4 texture) {
	float l = vStepB.x;
	float lp0 = vStepB.y;
	float lp1 = vStepB.z;
	float lt = vStepB.w;
	float ld = antialiasWeight;
	float lm = mod(l, lp0 + lp1);
	float ls0 = (0.0 < lp1 ? smoothstep(0.0, ld, lm) - smoothstep(lp0, lp0 + ld, lm) : 1.0);
	float ls1 = (0.0 <= lt ? smoothstep(0.0, ld, l) - smoothstep(lt - ld, lt, l) : 1.0);

	float c = vStepA.x;
	float awd = antialiasWeight / vStepA.y;
	float p0 = clamp(awd, 0.0, 1.0);
	float p1 = clamp(1.0 - awd, 0.0, 1.0);
	float s0 = smoothstep(0.0, p0, c);
	float s1 = smoothstep(p1, 1.0, c);
	return texture * vColorStroke * (s0 - s1) * ls0 * ls1;
}

void main(void) {
	vec4 texture = texture2D(sampler, vUv);
	gl_FragColor = (vType < 1.5 ?
		(vType < 0.5 ?
			toColor0(texture) :
			toColor1(texture)
		) :
		(vType < 2.5 ?
			toColor2(texture) :
			toColor3(texture)
		)
	);
}`;
    class EShapeRenderer extends pixi_js.ObjectRenderer {
        constructor(renderer) {
            super(renderer);
            EShapeRenderer.SHADER =
                EShapeRenderer.SHADER || pixi_js.Shader.from(VERTEX_SHADER$1, FRAGMENT_SHADER$1);
            this._shader = EShapeRenderer.SHADER;
            this._iterator = new EShapeRendererIterator();
            this._bufferSizeMax = this.getBufferSizeMax(renderer);
        }
        getBufferSizeMax(renderer) {
            const context = renderer.context;
            const extensions = context.extensions;
            if (1 < context.webGLVersion || !!extensions.uint32ElementIndex) {
                return 1431655765; // 2^32 / 3
            }
            return 21845; // 2^16 / 3
        }
        updateAtlas(shape, atlas, fontAtlases, defaultTexture, baseTexture) {
            // Texture
            // Do not access the shape.image.source here.
            // It slows down the rendering speed significantly.
            const image = shape.image;
            if (image != null) {
                const textureItem = atlas.get(image.url);
                if (textureItem != null) {
                    shape.texture = textureItem.texture;
                }
                else {
                    const newTextureItem = new DynamicAtlasItemImage(image.url, image.width, image.height, image.source, baseTexture);
                    shape.texture = newTextureItem.texture;
                    atlas.set(newTextureItem.id, newTextureItem);
                }
            }
            else {
                shape.texture = defaultTexture;
            }
            // Font texture atlas
            const text = shape.text;
            const textCharacters = text.characters;
            if (0 < textCharacters.length) {
                fontAtlases.add(text.family, textCharacters, text.nacharacters);
            }
        }
        updateAtlases(shapes, atlas, fontAtlases, defaultTexture, baseTexture) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                this.updateAtlas(shape, atlas, fontAtlases, defaultTexture, baseTexture);
                const children = shape.children;
                for (let j = 0, jmax = children.length; j < jmax; ++j) {
                    const child = children[j];
                    this.updateAtlas(child, atlas, fontAtlases, defaultTexture, baseTexture);
                    this.updateAtlases(child.children, atlas, fontAtlases, defaultTexture, baseTexture);
                }
            }
        }
        updateFontAtlas(shape, atlas, fontAtlases, defaultTexture) {
            const text = shape.text;
            const fontAtlas = fontAtlases.get(text.family);
            if (fontAtlas != null) {
                const textureItem = atlas.get(fontAtlas.id);
                if (textureItem != null) {
                    text.atlas = fontAtlas;
                    text.texture = textureItem.texture;
                }
                else {
                    text.atlas = undefined;
                    text.texture = defaultTexture;
                }
            }
            else {
                text.atlas = undefined;
                text.texture = defaultTexture;
            }
        }
        updateFontAtlases(shapes, atlas, fontAtlases, defaultTexture) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                this.updateFontAtlas(shape, atlas, fontAtlases, defaultTexture);
                const children = shape.children;
                for (let j = 0, jmax = children.length; j < jmax; ++j) {
                    const child = children[j];
                    this.updateFontAtlas(child, atlas, fontAtlases, defaultTexture);
                    this.updateFontAtlases(child.children, atlas, fontAtlases, defaultTexture);
                }
            }
        }
        render_(container, shape, shapes, isDirty) {
            const renderer = this.renderer;
            const shader = this._shader;
            if (shader != null && (shape != null || 0 < shapes.length)) {
                const resolution = renderer.resolution;
                const buffers = container.getBuffers();
                const antialiasWeight = container.toAntialiasWeight(resolution);
                // Update textures
                if (isDirty) {
                    // Atlases
                    const atlas = container.getAtlas(resolution);
                    const fontAtlases = container.getFontAtlases();
                    atlas.begin();
                    fontAtlases.begin();
                    const defaultTexture = atlas.getDefaultTexture();
                    const baseTexture = atlas.getBaseTexture();
                    this.updateAtlases(shapes, atlas, fontAtlases, defaultTexture, baseTexture);
                    fontAtlases.end();
                    fontAtlases.update(atlas);
                    this.updateFontAtlases(shapes, atlas, fontAtlases, defaultTexture);
                    atlas.end();
                    atlas.repack();
                    // Update buffers
                    this.updateBuffers(shape, shapes, buffers, renderer, antialiasWeight);
                }
                // Render buffers
                shader.uniforms.shapeScale = container.toShapeScale();
                shader.uniforms.antialiasWeight = container.toPixelScale(resolution) * antialiasWeight;
                shader.uniforms.translationMatrix = container.worldTransform.toArray(true);
                renderer.shader.bind(shader, false);
                renderer.state.setBlendMode(pixi_js.utils.correctBlendMode(pixi_js.BLEND_MODES.NORMAL, true));
                const buffersLength = buffers.length;
                if (1 < buffersLength) {
                    for (let i = 0; i < buffersLength; ++i) {
                        buffers[i].upload();
                    }
                }
                for (let i = 0; i < buffersLength; ++i) {
                    buffers[i].render(shader);
                }
            }
        }
        updateBuffers(shape, shapes, buffers, renderer, antialiasWeight) {
            const iterator = this._iterator;
            iterator.reset(shape, shapes);
            let ib = 0;
            let bufferSize = 0;
            const bufferSizeBase = 5000;
            const bufferSizeMax = this._bufferSizeMax;
            while (iterator.get() != null) {
                let buffer = null;
                let noMoreThanOne = false;
                if (0 < bufferSize) {
                    buffer = new EShapeBuffer(bufferSize, renderer);
                    buffers.splice(ib, 0, buffer);
                    noMoreThanOne = true;
                }
                else if (ib < buffers.length) {
                    buffer = buffers[ib];
                    noMoreThanOne = false;
                }
                else {
                    buffer = new EShapeBuffer(bufferSizeBase, renderer);
                    buffers.push(buffer);
                    noMoreThanOne = false;
                }
                if (buffer.update(iterator, antialiasWeight, noMoreThanOne)) {
                    bufferSize = 0;
                    ib += 1;
                }
                else {
                    bufferSize = buffer.indexCountRequested;
                    if (bufferSize <= bufferSizeMax) {
                        bufferSize = Math.ceil(bufferSize / bufferSizeBase) * bufferSizeBase;
                        bufferSize = Math.min(bufferSize, bufferSizeMax);
                    }
                    else {
                        // No way to render
                        break;
                    }
                }
            }
            if (ib < buffers.length) {
                for (let jb = ib, ibmax = buffers.length; jb < ibmax; ++jb) {
                    buffers[jb].destroy();
                }
                buffers.length = ib;
            }
        }
    }
    EShapeRenderer.SHADER = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeContainer extends pixi_js.DisplayObject {
        constructor() {
            super();
            this._shapeRenderer = null;
            this.children = [];
            this._shape = null;
            this._childrenId = 0;
            this._childrenIdRendered = -1;
            this._atlas = null;
            this._fontAtlases = new DynamicSDFFontAtlases();
            this._pixelScale = 1;
            this._pixelScaleId = -2; // Since this._shapeScaleId starts from -1.
            this._shapeScale = 1;
            this._shapeScaleId = -1; // Since Transform._worldID starts from zero.
            this._work = new pixi_js.Point();
            this._buffers = [];
        }
        calculateBounds() {
            this._bounds.clear();
        }
        onChildTransformChange() {
            // DO NOTHING
        }
        toDirty() {
            return (this._childrenId += 1);
        }
        isDirty() {
            return this._childrenIdRendered < this._childrenId;
        }
        render(renderer) {
            if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
                return;
            }
            const childrenId = this._childrenId;
            const childrenIdRendered = this._childrenIdRendered;
            this._childrenIdRendered = childrenId;
            const isChildrenDirty = childrenIdRendered < childrenId;
            let shapeRenderer = this._shapeRenderer;
            if (shapeRenderer == null) {
                shapeRenderer = this._shapeRenderer = new EShapeRenderer(renderer);
            }
            renderer.batch.setObjectRenderer(shapeRenderer);
            const mask = this.mask;
            const shape = this._shape;
            const shapes = this.children;
            if (mask) {
                renderer.mask.push(this, mask);
                shapeRenderer.render_(this, shape, shapes, isChildrenDirty);
                renderer.mask.pop(this);
            }
            else {
                shapeRenderer.render_(this, shape, shapes, isChildrenDirty);
            }
        }
        containsPoint(point) {
            return false;
        }
        getFontAtlases() {
            return this._fontAtlases;
        }
        getAtlas(resolution) {
            let atlas = this._atlas;
            if (atlas == null) {
                atlas = new DynamicAtlas(resolution);
                this._atlas = atlas;
            }
            return atlas;
        }
        getBuffers() {
            return this._buffers;
        }
        toShapeScale() {
            this.updateTransform();
            const transform = this.transform;
            const worldID = transform._worldID;
            if (worldID !== this._shapeScaleId) {
                this._shapeScaleId = worldID;
                const worldTransform = transform.worldTransform;
                const a = worldTransform.a;
                const b = worldTransform.b;
                this._shapeScale = 1 / Math.sqrt(a * a + b * b);
            }
            return this._shapeScale;
        }
        getShapeScale() {
            return this._shapeScale;
        }
        toPixelScale(resolution) {
            const shapeScale = this.toShapeScale();
            const shapeScaleId = this._shapeScaleId;
            if (this._pixelScaleId !== shapeScaleId) {
                this._pixelScaleId = shapeScaleId;
                this._pixelScale = (1 / resolution) * shapeScale;
            }
            return this._pixelScale;
        }
        getPixelScale() {
            return this._pixelScale;
        }
        toAntialiasWeight(resolution) {
            return 1.25 / resolution;
        }
        hitTest(global, onHit) {
            const local = this._work;
            const children = this.children;
            for (let i = children.length - 1; 0 <= i; --i) {
                const child = children[i];
                if (child.visible) {
                    child.toLocal(global, undefined, local);
                    const result = child.contains(local.x, local.y);
                    if (result != null) {
                        if (onHit == null || onHit(result)) {
                            return result;
                        }
                    }
                }
            }
            return null;
        }
        hitTestBBox(global, onHit) {
            const local = this._work;
            const children = this.children;
            for (let i = children.length - 1; 0 <= i; --i) {
                const child = children[i];
                if (child.visible) {
                    child.toLocal(global, undefined, local);
                    if (child.containsBBox(local.x, local.y)) {
                        if (onHit == null || onHit(child)) {
                            return child;
                        }
                    }
                }
            }
            return null;
        }
        destroy() {
            // Buffer
            const buffers = this._buffers;
            if (buffers != null) {
                for (let i = 0, imax = buffers.length; i < imax; ++i) {
                    buffers[i].destroy();
                }
            }
            this._buffers.length = 0;
            // Shapes
            const children = this.children;
            for (let i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            // Atlas
            const atlas = this._atlas;
            if (atlas != null) {
                atlas.destroy();
            }
            // Font Atlas
            this._fontAtlases.destroy();
            //
            super.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeEmbeddedLayer extends EShapeGroupViewer {
        constructor(name, mode, depth, type = EShapeType.EMBEDDED_LAYER) {
            super(mode, depth, type);
            this._name = name;
        }
        get name() {
            return this._name;
        }
        newGroupFill() {
            return new EShapeFillImpl(this, false, 0xffffff, 1);
        }
        isGroupSizeFittable() {
            return false;
        }
        newGroupSize(mode, depth) {
            const sizeX = EShapeDefaults.SIZE_X;
            const sizeY = EShapeDefaults.SIZE_Y;
            return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
        }
        clone() {
            const result = this.newClone().copy(this);
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            result.onChildTransformChange();
            result.toDirty();
            const size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                const base = size.base;
                result.size.set(base.x, base.y).init().set(size.x, size.y);
            }
            else {
                result.size.init();
            }
            return result;
        }
        newClone() {
            const constructor = this.constructor;
            return new constructor(this._name, this._mode, this._depth, this.type);
        }
        serializeChildren(manager) {
            return [];
        }
        serializeImage(manager) {
            return -1;
        }
        serializeGradient(manager) {
            return -1;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramLayers {
        static toLayers(shape, indices) {
            const result = [];
            const layer = this.toLayer(shape);
            if (layer) {
                const container = layer.parent;
                if (container) {
                    const children = container.children;
                    const childrenLength = children.length;
                    for (let i = 0, imax = indices.length; i < imax; ++i) {
                        const index = indices[i];
                        if (0 <= index && index < childrenLength) {
                            result.push(children[index]);
                        }
                    }
                }
            }
            return result;
        }
        static toLayer(shape) {
            let parent = shape.parent;
            while (parent != null) {
                if (parent instanceof EShapeContainer) {
                    return parent;
                }
                if (parent instanceof EShapeEmbeddedLayer) {
                    return parent;
                }
                parent = parent.parent;
            }
            return null;
        }
        static show(target) {
            if (!target.visible) {
                target.visible = true;
                return true;
            }
            return false;
        }
        static showAll(targets) {
            let isChanged = false;
            for (let i = 0, imax = targets.length; i < imax; ++i) {
                const layer = targets[i];
                if (!layer.visible) {
                    layer.visible = true;
                    isChanged = true;
                }
            }
            return isChanged;
        }
        static hide(target) {
            if (target.visible) {
                target.visible = false;
                return true;
            }
            return false;
        }
        static hideAll(targets) {
            let isChanged = false;
            for (let i = 0, imax = targets.length; i < imax; ++i) {
                const layer = targets[i];
                if (layer.visible) {
                    layer.visible = false;
                    isChanged = true;
                }
            }
            return isChanged;
        }
        static bringToFront(target) {
            const parent = target.parent;
            if (parent) {
                return this.doBringToFront(target, parent.children, 0);
            }
            return false;
        }
        static bringAllToFront(targets) {
            const targetsLength = targets.length;
            if (0 < targetsLength) {
                const parent = targets[0].parent;
                if (parent) {
                    let isChanged = false;
                    const layers = parent.children;
                    for (let i = 0; i < targetsLength; ++i) {
                        const layer = targets[targetsLength - 1 - i];
                        if (this.doBringToFront(layer, layers, i)) {
                            isChanged = true;
                        }
                    }
                    return isChanged;
                }
            }
            return false;
        }
        static doBringToFront(target, layers, offset) {
            const layersLength = layers.length;
            const ito = layersLength - 1 - offset;
            for (let i = ito; 0 <= i; --i) {
                const child = layers[i];
                if (child === target) {
                    if (i !== ito) {
                        for (let j = i + 1; j <= ito; ++j) {
                            layers[j - 1] = layers[j];
                        }
                        layers[ito] = child;
                        return true;
                    }
                    return false;
                }
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const CTRL = 1;
    const SHIFT = 2;
    const ALT = 4;
    const AND = 8;
    const OR = 16;
    const UtilGestureModifier = {
        NONE: 0,
        CTRL,
        SHIFT,
        ALT,
        AND,
        OR,
        NOT_NONE: CTRL | SHIFT | ALT | OR
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilGestureModifiers {
        static from(e) {
            const oe = "data" in e ? e.data.originalEvent : e;
            return ((oe.ctrlKey ? UtilGestureModifier.CTRL : UtilGestureModifier.NONE) |
                (oe.altKey ? UtilGestureModifier.ALT : UtilGestureModifier.NONE) |
                (oe.shiftKey ? UtilGestureModifier.SHIFT : UtilGestureModifier.NONE));
        }
        static match(e, modifier) {
            if (modifier & UtilGestureModifier.OR) {
                return !!(UtilGestureModifiers.from(e) & modifier);
            }
            else {
                return UtilGestureModifiers.from(e) === modifier;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilPointerEvent {
        static get touchable() {
            return "ontouchstart" in document;
        }
        static get tap() {
            return "pointertap";
        }
        static get down() {
            return "pointerdown";
        }
        static get enter() {
            return "pointerenter";
        }
        static get leave() {
            return "pointerleave";
        }
        static get move() {
            return "pointermove";
        }
        static get out() {
            return "pointerout";
        }
        static get over() {
            return "pointerover";
        }
        static get up() {
            return "pointerup";
        }
        static get upoutside() {
            return "pointerupoutside";
        }
        static get cancel() {
            return "pointercancel";
        }
        static get righttap() {
            return "rightclick";
        }
        static get rightdown() {
            return "rightdown";
        }
        static get rightup() {
            return "rightup";
        }
        static get rightupoutside() {
            return "rightupoutside";
        }
        static toGlobal(e, interactionManager, result) {
            if ("touches" in e) {
                const touches = e.changedTouches;
                const touch = touches[touches.length - 1];
                if (touch != null) {
                    interactionManager.mapPositionToPoint(result, touch.clientX, touch.clientY);
                }
                else {
                    interactionManager.mapPositionToPoint(result, 0, 0);
                }
            }
            else {
                interactionManager.mapPositionToPoint(result, e.clientX, e.clientY);
            }
            return result;
        }
        static onDblClick(target, onDblClick) {
            target.addEventListener("dblclick", (e) => onDblClick(e, false));
            if (this.touchable) {
                let isDowned = 0;
                let downX = 0;
                let downY = 0;
                let clickTime = 0;
                target.addEventListener("touchstart", (e) => {
                    if (isDowned !== 0 && isDowned !== 2) {
                        isDowned = 0;
                        return;
                    }
                    const touches = e.touches;
                    const touchesLength = touches.length;
                    if (touchesLength <= 0) {
                        isDowned = 0;
                        return;
                    }
                    const touch = touches.item(touchesLength - 1);
                    if (touch == null) {
                        isDowned = 0;
                        return;
                    }
                    isDowned += 1;
                    downX = touch.clientX;
                    downY = touch.clientY;
                });
                target.addEventListener("touchend", (e) => {
                    if (isDowned !== 1 && isDowned !== 3) {
                        isDowned = 0;
                        return;
                    }
                    const touches = e.changedTouches;
                    const touchesLength = touches.length;
                    if (touchesLength <= 0) {
                        isDowned = 0;
                        return;
                    }
                    const touch = touches[touchesLength - 1];
                    if (touch == null) {
                        isDowned = 0;
                        return;
                    }
                    const dx = downX - touch.clientX;
                    const dy = downY - touch.clientY;
                    if (this.CLICK_DISTANCE_THRESHOLD <= Math.abs(dx) + Math.abs(dy)) {
                        isDowned = 0;
                        return;
                    }
                    if (isDowned === 1) {
                        clickTime = e.timeStamp;
                        isDowned = 2;
                    }
                    else {
                        const elapsedTime = e.timeStamp - clickTime;
                        if (elapsedTime < this.DBLCLICK_INTERVAL_THRESHOLD) {
                            isDowned = 0;
                            onDblClick(e, true);
                        }
                        else {
                            clickTime = e.timeStamp;
                            isDowned = 2;
                        }
                    }
                });
                target.addEventListener("touchcancel", () => {
                    isDowned = 0;
                });
            }
        }
        static contains(target, targetOrChild) {
            let current = targetOrChild;
            while (current != null && current !== target) {
                current = current.parent;
            }
            return current === target;
        }
    }
    UtilPointerEvent.CLICK_DISTANCE_THRESHOLD = 10;
    UtilPointerEvent.DBLCLICK_INTERVAL_THRESHOLD = 333;
    UtilPointerEvent.LONG_CLICK_THRESHOLD = 750;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilGestureData {
        constructor() {
            this.pointers = new Map();
            this.center = new pixi_js.Point();
            this.scale = 0;
            this.time = 0;
            this.distance = 0;
        }
        start(e) {
            const oe = e.data.originalEvent;
            if ("pointerId" in oe) {
                this.pointers.set(oe.pointerId, oe);
            }
            this.doUpdate(e);
        }
        isUpdatable(e) {
            const oe = e.data.originalEvent;
            if ("pointerId" in oe) {
                return this.pointers.has(oe.pointerId);
            }
            return true;
        }
        update(e) {
            const oe = e.data.originalEvent;
            if ("pointerId" in oe) {
                this.pointers.set(oe.pointerId, oe);
            }
            this.doUpdate(e);
        }
        end(e) {
            let result = true;
            const oe = e.data.originalEvent;
            if ("touches" in oe) {
                result = oe.touches.length <= 0;
            }
            else if ("pointerId" in oe) {
                const pointers = this.pointers;
                pointers.delete(oe.pointerId);
                result = pointers.size <= 0;
            }
            this.doUpdate(e);
            return result;
        }
        bind(e) {
            const interactionManager = this.interactionManager;
            if (interactionManager) {
                const onMove = this.onMove;
                if (onMove) {
                    interactionManager.on(UtilPointerEvent.move, onMove);
                }
                const onEnd = this.onEnd;
                if (onEnd) {
                    interactionManager.on(UtilPointerEvent.up, onEnd);
                    interactionManager.on(UtilPointerEvent.upoutside, onEnd);
                    interactionManager.on(UtilPointerEvent.cancel, onEnd);
                }
            }
        }
        unbind() {
            const interactionManager = this.interactionManager;
            if (interactionManager) {
                const onMove = this.onMove;
                if (onMove) {
                    interactionManager.off(UtilPointerEvent.move, onMove);
                }
                const onEnd = this.onEnd;
                if (onEnd) {
                    interactionManager.off(UtilPointerEvent.up, onEnd);
                    interactionManager.off(UtilPointerEvent.upoutside, onEnd);
                    interactionManager.off(UtilPointerEvent.cancel, onEnd);
                }
            }
        }
        doUpdate(e) {
            const interactionManager = this.interactionManager;
            const center = this.center;
            const oe = e.data.originalEvent;
            this.scale = 0;
            this.time = oe.timeStamp;
            if ("touches" in oe) {
                const touches = oe.touches;
                const touchesLength = touches.length;
                if (0 < touchesLength) {
                    // Update the center
                    let centerX = 0;
                    let centerY = 0;
                    for (let i = 0, imax = touches.length; i < imax; ++i) {
                        const touch = touches[i];
                        centerX += touch.clientX;
                        centerY += touch.clientY;
                    }
                    centerX /= touchesLength;
                    centerY /= touchesLength;
                    if (interactionManager) {
                        interactionManager.mapPositionToPoint(center, centerX, centerY);
                    }
                    else {
                        center.set(centerX, centerY);
                    }
                    if (1 < touchesLength) {
                        // Calculate the maximum distance from the center
                        let squareDistance = 0;
                        for (let i = 1, imax = touches.length; i < imax; ++i) {
                            const touch = touches[i];
                            const dx = touch.clientX - centerX;
                            const dy = touch.clientY - centerY;
                            squareDistance = Math.max(squareDistance, dx * dx + dy * dy);
                        }
                        this.scale = Math.sqrt(squareDistance);
                    }
                }
            }
            else if ("pointerId" in oe) {
                const pointers = this.pointers;
                const pointersSize = pointers.size;
                if (0 < pointersSize) {
                    // Update the center
                    let centerX = 0;
                    let centerY = 0;
                    pointers.forEach((pointer) => {
                        centerX += pointer.clientX;
                        centerY += pointer.clientY;
                    });
                    centerX /= pointersSize;
                    centerY /= pointersSize;
                    if (interactionManager) {
                        interactionManager.mapPositionToPoint(center, centerX, centerY);
                    }
                    else {
                        center.set(centerX, centerY);
                    }
                    if (1 < pointersSize) {
                        // Calculate the maximum distance from the center
                        let squareDistance = 0;
                        pointers.forEach((pointer) => {
                            const dx = pointer.clientX - centerX;
                            const dy = pointer.clientY - centerY;
                            squareDistance = Math.max(squareDistance, dx * dx + dy * dy);
                        });
                        this.scale = Math.sqrt(squareDistance);
                    }
                }
            }
            else {
                center.copyFrom(e.data.global);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DAnimationTimings {
        static LINEAR(t) {
            return t;
        }
        static ELASTIC(t) {
            return t * (3 * (1 - t) * (1 - t) + t * (3 * (1 - t) + t));
        }
        static QUAD_IN_OUT(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DAnimationBase extends pixi_js.utils.EventEmitter {
        constructor(options) {
            var _a, _b, _c;
            super();
            this._id = null;
            this._target = (_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : null;
            this._startTime = 0;
            this._duration = (_b = options === null || options === void 0 ? void 0 : options.duration) !== null && _b !== void 0 ? _b : 200;
            this._durationInverse = 1 / Math.max(1, this._duration);
            this._reverse = false;
            this._onTime = options === null || options === void 0 ? void 0 : options.onTime;
            this._onTimeBaseBound = () => {
                this.onTimeBase();
            };
            this._onStart = options === null || options === void 0 ? void 0 : options.onStart;
            this._onEnd = options === null || options === void 0 ? void 0 : options.onEnd;
            this._onStop = options === null || options === void 0 ? void 0 : options.onStop;
            this._timing = (_c = options === null || options === void 0 ? void 0 : options.timing) !== null && _c !== void 0 ? _c : DAnimationTimings.ELASTIC;
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        get target() {
            return this._target;
        }
        set target(target) {
            this._target = target;
        }
        get duration() {
            return this._duration;
        }
        set duration(duration) {
            this._duration = duration;
            this._durationInverse = 1 / Math.max(1, duration);
        }
        start(reverse = false) {
            this.stop();
            this._startTime = Date.now();
            this._reverse = reverse;
            this._id = window.setTimeout(this._onTimeBaseBound, 0);
            // onStart
            this.onStart(reverse);
            // onTime
            const duration = this._duration;
            const time = this.toTime(reverse ? duration : 0);
            this.onTime(time, reverse, 0);
        }
        onStart(isReverse) {
            const onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        }
        onTime(time, isReverse, elapsedTime) {
            const onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        }
        onEnd(isReverse) {
            const onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        }
        onStop(isReverse) {
            const onStop = this._onStop;
            if (onStop != null) {
                onStop(isReverse, this);
            }
            this.emit("stop", isReverse, this);
        }
        isStarted() {
            return this._id != null;
        }
        isReverse() {
            return this._reverse;
        }
        onTimeBase() {
            const id = this._id;
            if (id != null) {
                this._id = null;
                const elapsedTime = Date.now() - this._startTime;
                const duration = this._duration;
                const reverse = this._reverse;
                if (elapsedTime < duration) {
                    this._id = window.setTimeout(this._onTimeBaseBound, 0);
                    // OnTime
                    const time = this.toTime(reverse ? duration - elapsedTime : elapsedTime);
                    this.onTime(time, reverse, elapsedTime);
                }
                else {
                    // OnTime
                    const time = this.toTime(reverse ? 0 : duration);
                    this.onTime(time, reverse, elapsedTime);
                    // OnEnd
                    this.onEnd(reverse);
                }
            }
        }
        toTime(elapsedTime) {
            return this._timing(elapsedTime * this._durationInverse, this);
        }
        stop() {
            const id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
                // OnStop
                this.onStop(this._reverse);
            }
        }
        end() {
            const id = this._id;
            if (id != null) {
                this._id = null;
                window.clearTimeout(id);
                // OnTime
                const reverse = this._reverse;
                const elapsedTime = Date.now() - this._startTime;
                const duration = this._duration;
                const time = this.toTime(reverse ? 0 : duration);
                this.onTime(time, reverse, elapsedTime);
                // OnEnd
                this.onEnd(reverse);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilGestureEasingHistory {
        constructor(dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        }
        set(dx, dy, ds, dt) {
            this.dx = dx;
            this.dy = dy;
            this.ds = ds;
            this.dt = dt;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilGestureEasing {
        constructor(onMove, onEnd, options) {
            var _a;
            this._histories = [];
            this._historiesSorted = [];
            this._historyBegin = 0;
            this._historyEnd = -1;
            this._dx = 0;
            this._dy = 0;
            this._ds = 0;
            this._dt = 0;
            this._dtw = 0;
            this._t = 0;
            this._duration = 333 * ((_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : 1);
            this._animation = new DAnimationBase({
                onTime: (t) => {
                    this.onEase(t);
                },
                onEnd: () => {
                    this.onEaseEnd();
                },
                timing: DAnimationTimings.LINEAR,
                duration: this._duration
            });
            this._onMove = onMove;
            this._onEnd = onEnd;
        }
        onStart() {
            // History
            const histories = this._histories;
            for (let i = histories.length, imax = UtilGestureEasing.HISTORY_CAPACITY; i < imax; ++i) {
                histories.push(new UtilGestureEasingHistory(0, 0, 1, 0));
            }
            this._historyBegin = 0;
            this._historyEnd = -1;
            // Stop animation
            this._animation.stop();
        }
        onMove(dx, dy, ds, dt) {
            const capacity = UtilGestureEasing.HISTORY_CAPACITY;
            const oldHistoryEnd = this._historyEnd;
            const newHistoryEnd = (oldHistoryEnd + 1) % capacity;
            this._historyEnd = newHistoryEnd;
            const oldHistoryBegin = this._historyBegin;
            if (newHistoryEnd < oldHistoryEnd ||
                (0 <= oldHistoryEnd && oldHistoryEnd < oldHistoryBegin)) {
                this._historyBegin = (oldHistoryBegin + 1) % capacity;
            }
            this._histories[newHistoryEnd].set(dx, dy, ds, dt);
        }
        updateHistoriesSorted(dt) {
            const unsorted = this._histories;
            const sorted = this._historiesSorted;
            const begin = this._historyBegin;
            const end = this._historyEnd;
            const length = unsorted.length;
            const threshold = 160;
            if (end < 0) {
                sorted.length = 0;
                return dt;
            }
            else if (end < begin) {
                let total = dt;
                sorted.length = 0;
                for (let i = end; 0 <= i; --i) {
                    const history = unsorted[i];
                    if (total + history.dt < threshold) {
                        total += history.dt;
                        sorted.push(history);
                    }
                    else {
                        return total;
                    }
                }
                for (let i = length - 1; begin <= i; --i) {
                    const history = unsorted[i];
                    if (total + history.dt < threshold) {
                        total += history.dt;
                        sorted.push(history);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
            else {
                let total = dt;
                sorted.length = 0;
                for (let i = end; begin <= i; --i) {
                    const history = unsorted[i];
                    if (total + history.dt < threshold) {
                        total += history.dt;
                        sorted.push(history);
                    }
                    else {
                        return total;
                    }
                }
                return total;
            }
        }
        onEnd(ldt) {
            const d0 = this._duration;
            const d = d0 - ldt;
            if (d <= 0) {
                return this.onEaseEnd();
            }
            this.updateHistoriesSorted(ldt);
            const sorted = this._historiesSorted;
            const sortedLength = sorted.length;
            if (sortedLength <= 0) {
                return this.onEaseEnd();
            }
            let dx = 0;
            let dy = 0;
            let ds = 0;
            let dt = 0;
            for (let i = 0; i < sortedLength; ++i) {
                const history = sorted[i];
                dx += history.dx;
                dy += history.dy;
                ds += history.ds;
                dt += history.dt;
            }
            if (dt <= 0) {
                return this.onEaseEnd();
            }
            const w = 1 / sortedLength;
            dx *= w;
            dy *= w;
            ds *= w;
            dt *= w * (d0 / d); // Effectively, this lowers the velocity (dx, dy, ds) by d / d0.
            this._dx = dx;
            this._dy = dy;
            this._ds = ds;
            this._dt = dt;
            // Start animation
            const animation = this._animation;
            animation.duration = d;
            this._t = 0;
            this._dtw = d / dt;
            animation.start();
        }
        onEase(t) {
            const ot = this._t;
            this._t = t;
            // Note: Integral_{x=ot...t} (1-x) dx
            //       = [x (1 - 0.5 x)]_{x=ot...t}
            //       = t (1 - 0.5 t) - ot (1 - 0.5 ot)
            //       = t - ot - 0.5 t t + 0.5 ot ot
            //       = (t - ot) - 0.5 (t + ot) (t - ot)
            //       = (1 - 0.5 (t + ot)) * (t - ot)
            const w = (1 - 0.5 * (t + ot)) * (t - ot) * this._dtw;
            this._onMove(this._dx * w, this._dy * w, 1 + (this._ds - 1) * w, t);
        }
        onEaseEnd() {
            this._onEnd();
        }
        stop() {
            this._animation.stop();
        }
    }
    UtilGestureEasing.HISTORY_CAPACITY = 5;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilGestureTap {
        constructor(on, options) {
            if (on != null) {
                this._onTap = on.tap;
                this._onLongPress = on.longpress;
            }
            this._threshold = this.toThreshold(options);
            this._unused = [];
            this._used = new Map();
        }
        toThreshold(options) {
            var _a, _b;
            if (options != null) {
                const threshold = options.threshold;
                if (threshold != null) {
                    return {
                        distance: (_a = threshold.distance) !== null && _a !== void 0 ? _a : 10,
                        long: (_b = threshold.long) !== null && _b !== void 0 ? _b : 500
                    };
                }
            }
            return {
                distance: 10,
                long: 500
            };
        }
        newData(target) {
            const used = this._used;
            const result = used.get(target);
            if (result != null) {
                return result;
            }
            const poped = this._unused.pop();
            if (poped != null) {
                used.set(target, poped);
                return poped;
            }
            const created = new UtilGestureData();
            created.easing = undefined;
            created.onMove = this.newOnMove(created);
            created.onEnd = this.newOnEnd(created);
            used.set(target, created);
            return created;
        }
        deleteData(data) {
            const target = data.target;
            if (target) {
                if (this._used.delete(target)) {
                    const timeoutId = data.timeoutId;
                    if (timeoutId != null) {
                        data.timeoutId = undefined;
                        window.clearTimeout(timeoutId);
                    }
                    data.target = undefined;
                    data.pointers.clear();
                    this._unused.push(data);
                }
            }
        }
        newOnMove(data) {
            return (e) => {
                this.onMove(e, data);
            };
        }
        newOnEnd(data) {
            return (e) => {
                this.onEnd(e, data);
            };
        }
        onDown(target, e) {
            var _a;
            if (this._onTap == null && this._onLongPress == null) {
                return;
            }
            const layer = DApplications.getLayer(target);
            if (layer == null) {
                return;
            }
            e.stopPropagation();
            if (target.state.isGesturing) {
                (_a = this._used.get(target)) === null || _a === void 0 ? void 0 : _a.start(e);
            }
            else {
                const data = this.newData(target);
                data.target = target;
                data.distance = 0;
                target.state.isGesturing = true;
                // Interaction manager
                const interactionManager = layer.renderer.plugins.interaction;
                data.interactionManager = interactionManager;
                // Update the center
                data.start(e);
                // Event handler
                data.bind(e);
                // Long press
                this.start(target, data, e);
            }
        }
        onMove(e, data) {
            const target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            if (!data.isUpdatable(e)) {
                return;
            }
            // Update the center
            const center = data.center;
            const oldCenterX = center.x;
            const oldCenterY = center.y;
            data.update(e);
            const newCenterX = center.x;
            const newCenterY = center.y;
            // Calculate the position
            const dx = newCenterX - oldCenterX;
            const dy = newCenterY - oldCenterY;
            // Distance
            data.distance += Math.abs(dx) + Math.abs(dy);
        }
        onEnd(e, data) {
            const target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            if (!data.end(e)) {
                return;
            }
            // State
            target.state.isGesturing = false;
            // Remove event handlers
            const interactionManager = data.interactionManager;
            data.interactionManager = undefined;
            if (interactionManager) {
                const onMoveBound = data.onMove;
                if (onMoveBound) {
                    interactionManager.off(UtilPointerEvent.move, onMoveBound);
                }
                const onEndBound = data.onEnd;
                if (onEndBound) {
                    interactionManager.off(UtilPointerEvent.up, onEndBound);
                    interactionManager.off(UtilPointerEvent.cancel, onEndBound);
                }
            }
            // Tap
            this.end(target, data, e);
            // Delete this data
            this.deleteData(data);
        }
        onLongPress(target, data, e) {
            data.timeoutId = undefined;
            if (data.distance < this._threshold.distance) {
                data.distance = this._threshold.distance;
                const onLongPress = this._onLongPress;
                if (onLongPress != null) {
                    onLongPress(target, e);
                }
            }
        }
        start(target, data, e) {
            const thresholdLong = this._threshold.long;
            if (0 <= thresholdLong) {
                data.timeoutId = window.setTimeout(() => {
                    this.onLongPress(target, data, e);
                }, thresholdLong);
            }
        }
        end(target, data, e) {
            const timeoutId = data.timeoutId;
            if (timeoutId != null) {
                data.timeoutId = undefined;
                window.clearTimeout(timeoutId);
            }
            if (data.distance < this._threshold.distance) {
                const onTap = this._onTap;
                if (onTap) {
                    onTap(target, e);
                }
            }
        }
        stop(target) {
            const data = this._used.get(target);
            if (data != null) {
                this.deleteData(data);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilGesture {
        constructor(options) {
            var _a, _b, _c;
            const on = options.on;
            if (on) {
                this._onStart = on.start;
                this._onMove = on.move;
                this._onEnd = on.end;
                this._onStop = on.stop;
                const easing = on.easing;
                if (easing != null) {
                    this._onEasingStart = easing.start;
                    this._onEasingEnd = easing.end;
                }
            }
            this._modifier = (_a = options === null || options === void 0 ? void 0 : options.modifier) !== null && _a !== void 0 ? _a : UtilGestureModifier.NONE;
            const checker = options.checker;
            const defaultChecker = UtilGestureModifiers.match;
            this._checkerStart = (_b = checker === null || checker === void 0 ? void 0 : checker.start) !== null && _b !== void 0 ? _b : defaultChecker;
            this._checkerMove = (_c = checker === null || checker === void 0 ? void 0 : checker.move) !== null && _c !== void 0 ? _c : defaultChecker;
            this._easing = options.easing;
            this._touch = !!options.touch;
            this._unused = [];
            this._used = new Map();
            this._tap = new UtilGestureTap(options.on, options.tap);
            const bind = options.bind;
            if (bind != null) {
                this.bind(bind);
            }
        }
        newData(target) {
            const used = this._used;
            const result = used.get(target);
            if (result != null) {
                return result;
            }
            const poped = this._unused.pop();
            if (poped != null) {
                used.set(target, poped);
                return poped;
            }
            const created = new UtilGestureData();
            created.easing = this.newEasing(created);
            created.onMove = this.newOnMove(created);
            created.onEnd = this.newOnEnd(created);
            used.set(target, created);
            return created;
        }
        newEasing(data) {
            const easing = this._easing;
            if (easing == null || easing !== false) {
                const onEasingMoveBound = (dx, dy, ds, time) => {
                    this.onEasingMove(dx, dy, ds, time, data);
                };
                const onEasingEndBound = () => {
                    this.onEasingEnd(data);
                };
                return new UtilGestureEasing(onEasingMoveBound, onEasingEndBound, this.toEasingOptions(easing));
            }
            return undefined;
        }
        toEasingOptions(options) {
            return options == null || options === true ? undefined : options;
        }
        deleteData(data) {
            const target = data.target;
            if (target) {
                if (this._used.delete(target)) {
                    data.target = undefined;
                    data.pointers.clear();
                    this._unused.push(data);
                }
            }
        }
        bind(target) {
            target.on(UtilPointerEvent.down, (e) => {
                this.onDown(target, e);
            });
            return this;
        }
        isTouch(e) {
            const oe = e.data.originalEvent;
            if ("touches" in oe) {
                return true;
            }
            else if ("pointerId" in oe) {
                return oe.pointerType !== "mouse";
            }
            else {
                return false;
            }
        }
        onDown(target, e) {
            var _a;
            if (this._touch && !this.isTouch(e)) {
                return;
            }
            if (!this._checkerStart(e, this._modifier, target)) {
                return this._tap.onDown(target, e);
            }
            const layer = DApplications.getLayer(target);
            if (layer == null) {
                return;
            }
            e.stopPropagation();
            if (target.state.isGesturing) {
                (_a = this._used.get(target)) === null || _a === void 0 ? void 0 : _a.start(e);
            }
            else {
                // User-defined handler
                const onStart = this._onStart;
                if (onStart != null) {
                    onStart(target);
                }
                const data = this.newData(target);
                data.target = target;
                data.distance = 0;
                target.state.isGesturing = true;
                // Interaction manager
                const interactionManager = layer.renderer.plugins.interaction;
                data.interactionManager = interactionManager;
                // Update the center
                data.start(e);
                // Easing util
                const easing = data.easing;
                if (easing) {
                    easing.onStart();
                }
                // Event handler
                data.bind(e);
                // Tap
                this._tap.start(target, data, e);
            }
        }
        newOnMove(data) {
            return (e) => {
                this.onMove(e, data);
            };
        }
        newOnEnd(data) {
            return (e) => {
                this.onEnd(e, data);
            };
        }
        onMove(e, data) {
            const target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            if (!data.isUpdatable(e) || !this._checkerMove(e, this._modifier, target)) {
                return;
            }
            // Update the center
            const center = data.center;
            const oldCenterX = center.x;
            const oldCenterY = center.y;
            const oldScale = data.scale;
            const oldTime = data.time;
            data.update(e);
            const newCenterX = center.x;
            const newCenterY = center.y;
            const newScale = data.scale;
            const newTime = data.time;
            // Calculate the position
            const dx = newCenterX - oldCenterX;
            const dy = newCenterY - oldCenterY;
            const dt = newTime - oldTime;
            const epsilon = 0.00001;
            const ds = epsilon < oldScale && epsilon < newScale ? newScale / oldScale : 1;
            // Distance
            data.distance += Math.abs(dx) + Math.abs(dy);
            // Easing
            const easing = data.easing;
            if (easing) {
                easing.onMove(dx, dy, ds, dt);
            }
            // Call the user-defined handler
            const onMove = this._onMove;
            if (onMove != null) {
                if (dx !== 0 || dy !== 0 || ds !== 1) {
                    onMove(target, dx, dy, newCenterX, newCenterY, ds);
                }
            }
        }
        onEnd(e, data) {
            const target = data.target;
            if (target == null || !target.state.isGesturing) {
                return;
            }
            const oldTime = data.time;
            if (!data.end(e)) {
                return;
            }
            // State
            target.state.isGesturing = false;
            // Remove event handlers
            const interactionManager = data.interactionManager;
            data.interactionManager = undefined;
            if (interactionManager) {
                const onMoveBound = data.onMove;
                if (onMoveBound) {
                    interactionManager.off(UtilPointerEvent.move, onMoveBound);
                }
                const onEndBound = data.onEnd;
                if (onEndBound) {
                    interactionManager.off(UtilPointerEvent.up, onEndBound);
                    interactionManager.off(UtilPointerEvent.cancel, onEndBound);
                }
            }
            // Call the user-defined handler
            const onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(target);
            }
            // Tap
            this._tap.end(target, data, e);
            // Start the Easing
            const onEasingStart = this._onEasingStart;
            if (onEasingStart) {
                onEasingStart(data.target);
            }
            const easing = data.easing;
            if (easing) {
                easing.onEnd(data.time - oldTime);
            }
            else {
                this.deleteData(data);
                const onEasingEnd = this._onEasingEnd;
                if (onEasingEnd) {
                    onEasingEnd(data.target);
                }
            }
        }
        onEasingMove(dx, dy, ds, time, data) {
            const target = data.target;
            if (target == null) {
                return;
            }
            const onMove = this._onMove;
            if (onMove == null) {
                return;
            }
            if (dx === 0 && dy === 0 && ds === 1) {
                return;
            }
            const center = data.center;
            const x = center.x + dx;
            const y = center.y + dy;
            center.set(x, y);
            onMove(target, dx, dy, x, y, ds);
        }
        onEasingEnd(data) {
            const target = data.target;
            this.deleteData(data);
            if (target != null) {
                const onEasingEnd = this._onEasingEnd;
                if (onEasingEnd) {
                    onEasingEnd(target);
                }
            }
        }
        stop(target) {
            this._tap.stop(target);
            const data = this._used.get(target);
            if (data != null) {
                const easing = data.easing;
                if (easing != null) {
                    easing.stop();
                }
                this.deleteData(data);
                const onStop = this._onStop;
                if (onStop) {
                    onStop(target);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DRAG = 1;
    const PINCH = 2;
    const EShapeActionValueGestureOperationType = {
        NONE: 0,
        DRAG,
        PINCH,
        ALL: DRAG | PINCH
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeGestureLayer extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this._layers = new Map();
            this._operationType = value.operationType;
            this._scaleMin = value.scaleMin;
            this._scaleMax = value.scaleMax;
        }
        initialize(shape, runtime) {
            super.initialize(shape, runtime);
            const layers = this._layers;
            const layer = layers.get(shape);
            if (layer == null) {
                const newLayer = DDiagramLayers.toLayer(shape);
                if (newLayer != null) {
                    this._layers.set(shape, newLayer);
                }
            }
        }
        onDown(shape, runtime, e) {
            super.onDown(shape, runtime, e);
            if (e instanceof pixi_js.InteractionEvent) {
                const layer = this._layers.get(shape);
                const time = e.data.originalEvent.timeStamp;
                if (layer && this.condition(shape, time, EShapeActionEnvironment)) {
                    this.getGestureUtil().onDown(layer, e);
                }
            }
        }
        getGestureUtil() {
            var _a;
            return ((_a = EShapeActionRuntimeGestureLayer.GESTURE_UTIL) !== null && _a !== void 0 ? _a : (EShapeActionRuntimeGestureLayer.GESTURE_UTIL = this.newGestureUtil()));
        }
        newGestureUtil() {
            const work = new pixi_js.Point();
            return new UtilGesture({
                on: {
                    move: (target, dx, dy, x, y, ds) => {
                        this.onGestureMove(target, dx, dy, x, y, ds, work);
                    }
                }
            });
        }
        onGestureMove(layer, dx, dy, x, y, ds, work) {
            const parent = layer.parent;
            if (parent) {
                const transform = layer.transform;
                const gestureType = this._operationType;
                let isChanged = false;
                // Scale
                let scaleRatio = 1;
                if (gestureType & EShapeActionValueGestureOperationType.PINCH) {
                    const scale = transform.scale;
                    const oldScale = scale.y;
                    const newScale = Math.min(this._scaleMax, Math.max(this._scaleMin, oldScale * ds));
                    scaleRatio = newScale / oldScale;
                    scale.set(newScale, newScale);
                    isChanged = true;
                }
                // Position
                if (gestureType & EShapeActionValueGestureOperationType.DRAG) {
                    parent.toLocal(work.set(x, y), undefined, work);
                    const lx = work.x;
                    const ly = work.y;
                    const cx = x - dx;
                    const cy = y - dy;
                    parent.toLocal(work.set(cx, cy), undefined, work);
                    const lcx = work.x;
                    const lcy = work.y;
                    const position = transform.position;
                    const newX = (position.x - lcx) * scaleRatio + lx;
                    const newY = (position.y - lcy) * scaleRatio + ly;
                    position.set(newX, newY);
                    isChanged = true;
                }
                // Update
                if (isChanged) {
                    DApplications.update(layer);
                }
            }
        }
        toSize(layer, result) {
            if ("size" in layer) {
                result.copyFrom(layer.size);
            }
            else {
                result.set(layer.width, layer.height);
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeGestureShape extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this._operationType = value.operationType;
            this._scaleMin = value.scaleMin;
            this._scaleMax = value.scaleMax;
        }
        onDown(shape, runtime, e) {
            super.onDown(shape, runtime, e);
            if (e instanceof pixi_js.InteractionEvent) {
                if (this.condition(shape, e.data.originalEvent.timeStamp, EShapeActionEnvironment)) {
                    this.getGestureUtil().onDown(shape, e);
                }
            }
        }
        getGestureUtil() {
            var _a;
            return ((_a = EShapeActionRuntimeGestureShape.GESTURE_UTIL) !== null && _a !== void 0 ? _a : (EShapeActionRuntimeGestureShape.GESTURE_UTIL = this.newGestureUtil()));
        }
        newGestureUtil() {
            const work = new pixi_js.Point();
            return new UtilGesture({
                on: {
                    move: (target, dx, dy, x, y, ds) => {
                        this.onGestureMove(target, dx, dy, x, y, ds, work);
                    }
                }
            });
        }
        onGestureMove(target, dx, dy, x, y, ds, work) {
            const parent = target.parent;
            if (parent) {
                const transform = target.transform;
                const gestureType = this._operationType;
                let isChanged = false;
                // Scale
                let scaleRatio = 1;
                if (gestureType & EShapeActionValueGestureOperationType.PINCH) {
                    const scale = transform.scale;
                    const oldScale = scale.y;
                    const newScale = Math.min(this._scaleMax, Math.max(this._scaleMin, oldScale * ds));
                    scaleRatio = newScale / oldScale;
                    scale.set(newScale, newScale);
                    isChanged = true;
                }
                // Position
                if (gestureType & EShapeActionValueGestureOperationType.DRAG) {
                    parent.toLocal(work.set(x, y), undefined, work);
                    const lx = work.x;
                    const ly = work.y;
                    const cx = x - dx;
                    const cy = y - dy;
                    parent.toLocal(work.set(cx, cy), undefined, work);
                    const lcx = work.x;
                    const lcy = work.y;
                    const position = transform.position;
                    const newX = (position.x - lcx) * scaleRatio + lx;
                    const newY = (position.y - lcy) * scaleRatio + ly;
                    position.set(newX, newY);
                    isChanged = true;
                }
                // Update
                if (isChanged) {
                    DApplications.update(target);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueGestureType = {
        SHAPE: 0,
        LAYER: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueMiscType = {
        INPUT_TEXT: 0,
        INPUT_INTEGER: 1,
        INPUT_REAL: 2,
        EMIT_EVENT: 3,
        WRITE_BOTH: 4,
        WRITE_LOCAL: 5,
        WRITE_REMOTE: 6,
        HTML_ELEMENT: 7,
        HTML_ELEMENT_WITHOUT_POINTER_EVENTS: 8,
        /** @deprecated in favor of {@link EShapeActionValueShowHideType}'s LAYER */
        SHOW_HIDE_LAYER: 9,
        /** @deprecated in favor of {@link EShapeActionValueType}'s GESTURE */
        GESTURE_LAYER: 10,
        /** @deprecated in favor of {@link EShapeActionValueType}'s GESTURE */
        GESTURE: 11,
        EXECUTE: 12,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueGesture extends EShapeActionValueSubtyped {
        constructor(condition = "", subtype, operationType, scaleMin = 0.05, scaleMax = 20) {
            super(EShapeActionValueType.GESTURE, condition, subtype);
            this.operationType = operationType;
            this.scaleMin = scaleMin;
            this.scaleMax = scaleMax;
        }
        toRuntime() {
            switch (this.subtype) {
                case EShapeActionValueGestureType.SHAPE:
                    return new EShapeActionRuntimeGestureShape(this);
                case EShapeActionValueGestureType.LAYER:
                    return new EShapeActionRuntimeGestureLayer(this);
            }
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${this.operationType},${this.scaleMin},${this.scaleMax}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const subtype = this.toSubType(serialized);
            const operationType = serialized[3];
            const scaleMin = serialized[4];
            const scaleMax = serialized[5];
            return new EShapeActionValueGesture(condition, subtype, operationType, scaleMin, scaleMax);
        }
        static toSubType(serialized) {
            if (serialized[0] === EShapeActionValueType.MISC) {
                switch (serialized[2]) {
                    case EShapeActionValueMiscType.GESTURE:
                        return EShapeActionValueGestureType.SHAPE;
                    case EShapeActionValueMiscType.GESTURE_LAYER:
                        return EShapeActionValueGestureType.LAYER;
                }
            }
            else {
                return serialized[2];
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeLayerState = {
        INVISIBLE: "INVISIBLE", // Invisible initially when non-edit mode
        INTERACTIVE: "INTERACTIVE",
        DRAGGABLE: "DRAGGABLE",
        PINCHABLE: "PINCHABLE"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeEmbeddedLayerName = (target, manager) => {
        if (isString(target)) {
            return target;
        }
        else {
            const resources = manager.resources;
            if (0 <= target && target <= resources.length) {
                return resources[target];
            }
            return "";
        }
    };
    const deserializeEmbeddedLayer = (serialized, manager, width, height, creator) => {
        var _a, _b, _c;
        const name = deserializeEmbeddedLayerName(serialized[0], manager);
        const result = creator
            ? creator(name, manager)
            : new EShapeEmbeddedLayer(name, manager.mode, manager.depth);
        const visibility = serialized[1];
        const visible = visibility == null || !!(visibility & 0x2);
        if (!visible) {
            result.visible = false;
            result.state.add(EShapeLayerState.INVISIBLE);
        }
        const positionX = -0.5 * width + (serialized[2] || 0);
        const positionY = -0.5 * height + (serialized[3] || 0);
        result.transform.position.set(positionX, positionY);
        const sizeX = (_a = serialized[4]) !== null && _a !== void 0 ? _a : width;
        const sizeY = (_b = serialized[5]) !== null && _b !== void 0 ? _b : height;
        result.size.set(sizeX, sizeY);
        result.size.init();
        const fillId = serialized[6];
        if (fillId != null) {
            result.fill.deserialize(fillId, manager);
        }
        if (manager.mode === EShapeResourceManagerDeserializationMode.VIEWER) {
            const state = (_c = serialized[7]) !== null && _c !== void 0 ? _c : 1;
            const isInteractive = state & 0x1;
            const isDraggable = state & 0x2;
            const isPinchable = state & 0x4;
            if (isDraggable || isPinchable) {
                const gestureType = (isDraggable
                    ? EShapeActionValueGestureOperationType.DRAG
                    : EShapeActionValueGestureOperationType.NONE) |
                    (isPinchable
                        ? EShapeActionValueGestureOperationType.PINCH
                        : EShapeActionValueGestureOperationType.NONE);
                result.action.add(new EShapeActionValueGesture("", EShapeActionValueGestureType.LAYER, gestureType));
            }
            if (isInteractive || isDraggable || isPinchable) {
                result.interactive = true;
            }
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeEmbeddedLayerContainer {
        constructor(width, height) {
            this.children = [];
            this._width = width;
            this._height = height;
        }
        hasConnectors(shapes) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeConnectorLine) {
                    return true;
                }
                const children = shape.children;
                if (0 < children.length) {
                    if (this.hasConnectors(children)) {
                        return true;
                    }
                }
            }
            return false;
        }
        newHasConnectors() {
            const result = new Map();
            const layers = this.children;
            for (let i = 0, imax = layers.length; i < imax; ++i) {
                const layer = layers[i];
                result.set(layer, this.hasConnectors(layer.children));
            }
            return result;
        }
        copyTo(destination) {
            var _a;
            const hasConnectors = ((_a = this._hasConnectors) !== null && _a !== void 0 ? _a : (this._hasConnectors = this.newHasConnectors()));
            const layers = this.children;
            const children = destination.children;
            for (let i = 0, imax = layers.length; i < imax; ++i) {
                const layer = layers[i];
                const clone = layer.clone();
                clone.parent = destination;
                children.push(clone);
                if (hasConnectors.get(layer)) {
                    EShapeConnectors.move(layer, clone);
                }
            }
            destination.onChildTransformChange();
            destination.toDirty();
            destination.onAttach();
        }
        deserialize(serializedLayers, manager) {
            const serializedLayersLength = serializedLayers.length;
            if (0 < serializedLayersLength) {
                const width = this._width;
                const height = this._height;
                for (let i = 0; i < serializedLayersLength; ++i) {
                    this.children.push(deserializeEmbeddedLayer(serializedLayers[i], manager, width, height));
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagrams {
        static parse(target) {
            if (target != null && isString(target)) {
                try {
                    const parsed = JSON.parse(target);
                    if (parsed != null && isNumber(parsed.version) && isString(parsed.name)) {
                        if (isNumber(parsed.width) &&
                            isNumber(parsed.height) &&
                            isArray(parsed.items) &&
                            isArray(parsed.resources)) {
                            return parsed;
                        }
                        else if (isString(parsed.data)) {
                            return this.toSerialized(parsed);
                        }
                    }
                }
                catch (e) {
                    // DO NOTHING
                }
            }
            return null;
        }
        static toSimple(serialized) {
            return {
                version: serialized.version,
                id: serialized.id,
                name: serialized.name,
                label: serialized.label,
                category: serialized.category,
                summary: serialized.summary,
                description: serialized.description,
                thumbnail: serialized.thumbnail,
                data: JSON.stringify({
                    width: serialized.width,
                    height: serialized.height,
                    background: serialized.background,
                    tile: serialized.tile,
                    resources: serialized.resources,
                    data: serialized.data || serialized.tags,
                    pieces: serialized.pieces,
                    layers: serialized.layers,
                    items: serialized.items,
                    snap: serialized.snap
                })
            };
        }
        static toSerialized(target) {
            if (!("items" in target)) {
                const data = JSON.parse(target.data);
                const result = {
                    version: target.version,
                    id: target.id,
                    name: target.name,
                    label: target.label,
                    width: data.width,
                    height: data.height,
                    category: target.category,
                    summary: target.summary,
                    description: target.description,
                    background: data.background,
                    tile: data.tile,
                    resources: data.resources,
                    data: data.data || data.tags,
                    pieces: data.pieces,
                    layers: data.layers,
                    items: data.items,
                    snap: data.snap,
                    thumbnail: target.thumbnail
                };
                if (result.data == null) {
                    const tags = target.tags;
                    if (tags != null) {
                        result.data = JSON.parse(tags);
                    }
                }
                if (result.pieces == null) {
                    const pieces = target.pieces;
                    if (pieces != null) {
                        result.pieces = JSON.parse(pieces);
                    }
                }
                return result;
            }
            return target;
        }
        static newLayer(serialized, container, manager) {
            // Layers
            container.deserialize(serialized.layers, manager);
            // Items
            const serializedItems = serialized.items;
            const shapePromises = deserializeAll(serializedItems, manager);
            if (shapePromises != null) {
                return shapePromises.then((shapes) => {
                    const layers = container.children;
                    for (let i = 0, imax = shapes.length; i < imax; ++i) {
                        const serializedItem = serializedItems[i];
                        const shape = shapes[i];
                        const layer = layers[serializedItem[16]];
                        if (layer != null) {
                            shape.parent = layer;
                            shape.uploaded = undefined;
                            layer.children.push(shape);
                        }
                    }
                    for (let i = 0, imax = layers.length; i < imax; ++i) {
                        const layer = layers[i];
                        layer.onChildTransformChange();
                        layer.toDirty();
                        const children = layer.children;
                        for (let j = 0, jmax = children.length; j < jmax; ++j) {
                            children[j].onAttach();
                        }
                    }
                    return shapes;
                });
            }
            else {
                return Promise.resolve([]);
            }
        }
        static toPieceData(controller, pieces, mode) {
            const pieceToDatum = new Map();
            const pieceToPromise = new Map();
            const onFulfilled = () => {
                return pieceToDatum;
            };
            return this.toPieceData_(controller, pieces, pieceToDatum, pieceToPromise, mode, 0).then(onFulfilled, onFulfilled);
        }
        static toPieceData_(controller, pieces, pieceToDatum, pieceToPromise, mode, depth) {
            const promises = [];
            if (pieces && 0 < pieces.length && controller) {
                for (let i = 0, imax = pieces.length; i < imax; ++i) {
                    const piece = pieces[i];
                    const promise = pieceToPromise.get(piece);
                    if (promise != null) {
                        promises.push(promise);
                    }
                    else {
                        const newPromise = controller.piece.getByName(piece).then((found) => {
                            return this.toPieceData__(controller, piece, found, mode, depth + 1, pieceToDatum, pieceToPromise);
                        }, () => {
                            return null;
                        });
                        pieceToPromise.set(piece, newPromise);
                        promises.push(newPromise);
                    }
                }
            }
            return Promise.all(promises);
        }
        static toPieceData__(controller, name, serializedOrSimple, mode, depth, pieceToDatum, pieceToPromise) {
            const serialized = this.toSerialized(serializedOrSimple);
            const width = serialized.width;
            const height = serialized.height;
            const container = new EShapeEmbeddedLayerContainer(width, height);
            pieceToDatum.set(name, new EShapeEmbeddedDatum(name, width, height, container));
            const pieces = serialized.pieces;
            return this.toPieceData_(controller, pieces, pieceToDatum, pieceToPromise, mode, depth).then(() => {
                return this.newLayer(serialized, container, new EShapeResourceManagerDeserialization(serialized, pieces, pieceToDatum, mode, depth));
            });
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionOpenOpeners = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseBackground {
        constructor(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            const background = options === null || options === void 0 ? void 0 : options.background;
            if (background) {
                this._color = background.color;
                this._alpha = background.alpha;
            }
        }
        getTheme() {
            return this._theme;
        }
        setTheme(theme) {
            this._theme = theme;
        }
        getColor(state) {
            const color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    const result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBackgroundColor(state);
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                this.onChange();
            }
        }
        getAlpha(state) {
            const alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    const result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBackgroundAlpha(state);
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                this.onChange();
            }
        }
        onChange() {
            const callback = this._callback;
            if (callback != null) {
                callback();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const TOP = 1;
    const RIGHT = 2;
    const BOTTOM = 4;
    const LEFT = 8;
    /**
     * A border mask.
     * Borders on masked parts are not rendered.
     */
    const DBorderMask = {
        NONE: 0,
        TOP,
        RIGHT,
        BOTTOM,
        LEFT,
        TOP_RIGHT: TOP | RIGHT,
        TOP_BOTTOM: TOP | BOTTOM,
        TOP_LEFT: TOP | LEFT,
        RIGHT_BOTTOM: RIGHT | BOTTOM,
        RIGHT_LEFT: RIGHT | LEFT,
        BOTTOM_LEFT: BOTTOM | LEFT,
        NOT_TOP: RIGHT | BOTTOM | LEFT,
        NOT_RIGHT: TOP | BOTTOM | LEFT,
        NOT_BOTTOM: TOP | RIGHT | LEFT,
        NOT_LEFT: TOP | RIGHT | BOTTOM,
        ALL: TOP | RIGHT | BOTTOM | LEFT
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseBorder {
        constructor(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            const border = options === null || options === void 0 ? void 0 : options.border;
            if (border) {
                this._color = border.color;
                this._alpha = border.alpha;
                this._width = border.width;
                this._align = border.align;
                this._mask = toEnum(border.mask, DBorderMask);
            }
        }
        getTheme() {
            return this._theme;
        }
        setTheme(theme) {
            this._theme = theme;
        }
        getColor(state) {
            const color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    const result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getBorderColor(state);
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                this.onChange();
            }
        }
        getAlpha(state) {
            const alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    const result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getBorderAlpha(state);
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                this.onChange();
            }
        }
        getWidth(state) {
            const width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    const result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getBorderWidth(state);
        }
        get width() {
            return this._width;
        }
        set width(width) {
            if (this._width !== width) {
                this._width = width;
                this.onChange();
            }
        }
        getAlign(state) {
            const align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    const result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getBorderAlign(state);
        }
        get align() {
            return this._align;
        }
        set align(align) {
            if (this._align !== align) {
                this._align = align;
                this.onChange();
            }
        }
        getMask(state) {
            const mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    const result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getBorderMask(state);
        }
        get mask() {
            return this._mask;
        }
        set mask(mask) {
            if (this._mask !== mask) {
                this._mask = mask;
                this.onChange();
            }
        }
        onChange() {
            const callback = this._callback;
            if (callback != null) {
                callback();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const TOP_LEFT = 1;
    const TOP_RIGHT = 2;
    const BOTTOM_LEFT = 4;
    const BOTTOM_RIGHT = 8;
    /**
     * A corner mask.
     * Masked corners are rendered as if the corner radius is zero.
     */
    const DCornerMask = {
        NONE: 0,
        TOP_LEFT,
        TOP_RIGHT,
        BOTTOM_LEFT,
        BOTTOM_RIGHT,
        TOP: TOP_LEFT | TOP_RIGHT,
        BOTTOM: BOTTOM_LEFT | BOTTOM_RIGHT,
        LEFT: TOP_LEFT | BOTTOM_LEFT,
        RIGHT: TOP_RIGHT | BOTTOM_RIGHT,
        ALL: TOP_LEFT | TOP_RIGHT | BOTTOM_LEFT | BOTTOM_RIGHT
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseCorner {
        constructor(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            const corner = options === null || options === void 0 ? void 0 : options.corner;
            if (corner) {
                if (isNumber(corner)) {
                    this._radius = corner;
                    this._mask = undefined;
                }
                else {
                    this._radius = corner.radius;
                    this._mask = toEnum(corner.mask, DCornerMask);
                }
            }
        }
        getTheme() {
            return this._theme;
        }
        setTheme(theme) {
            this._theme = theme;
        }
        getRadius() {
            var _a;
            return (_a = this._radius) !== null && _a !== void 0 ? _a : this._theme.getCornerRadius();
        }
        get radius() {
            return this._radius;
        }
        set radius(radius) {
            if (this._radius !== radius) {
                this._radius = radius;
                const callback = this._callback;
                if (callback != null) {
                    callback();
                }
            }
        }
        getMask() {
            var _a;
            return (_a = this._mask) !== null && _a !== void 0 ? _a : this._theme.getCornerMask();
        }
        get mask() {
            return this._mask;
        }
        set mask(mask) {
            if (this._mask !== mask) {
                this._mask = mask;
                const callback = this._callback;
                if (callback != null) {
                    callback();
                }
            }
        }
        set(radius, mask) {
            let isChanged = false;
            if (this._radius !== radius) {
                this._radius = radius;
                isChanged = true;
            }
            if (this._mask !== mask) {
                this._mask = mask;
                isChanged = true;
            }
            const callback = this._callback;
            if (isChanged && callback != null) {
                callback();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const SELF = 1;
    const CHILDREN = 2;
    /**
     * DBase interactivity.
     * Mouse / touch events are triggered only on interactive objects.
     */
    const DBaseInteractive = {
        /**
         * Not interactive.
         */
        NONE: 0,
        /**
         * Interactive.
         */
        SELF,
        /**
         * Children are interactive.
         */
        CHILDREN,
        /**
         * Interactive.
         * And also children are interactive.
         */
        BOTH: SELF | CHILDREN
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseOutline {
        constructor(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            const outline = options === null || options === void 0 ? void 0 : options.outline;
            if (outline) {
                this._color = outline.color;
                this._alpha = outline.alpha;
                this._width = outline.width;
                this._offset = outline.offset;
                this._align = outline.align;
                this._mask = toEnum(outline.mask, DBorderMask);
            }
        }
        getTheme() {
            return this._theme;
        }
        setTheme(theme) {
            this._theme = theme;
        }
        getColor(state) {
            const color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    const result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getOutlineColor(state);
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                const callback = this._callback;
                if (callback != null) {
                    callback();
                }
            }
        }
        getAlpha(state) {
            const alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    const result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getOutlineAlpha(state);
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                const callback = this._callback;
                if (callback != null) {
                    callback();
                }
            }
        }
        getWidth(state) {
            const width = this._width;
            if (width !== undefined) {
                if (isFunction(width)) {
                    const result = width(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return width;
                }
            }
            return this._theme.getOutlineWidth(state);
        }
        get width() {
            return this._width;
        }
        set width(width) {
            if (this._width !== width) {
                this._width = width;
                const callback = this._callback;
                if (callback != null) {
                    callback();
                }
            }
        }
        getOffset(state) {
            const offset = this._offset;
            if (offset !== undefined) {
                if (isFunction(offset)) {
                    const result = offset(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return offset;
                }
            }
            return this._theme.getOutlineOffset(state);
        }
        get offset() {
            return this._offset;
        }
        set offset(offset) {
            if (this._offset !== offset) {
                this._offset = offset;
                const callback = this._callback;
                if (callback != null) {
                    callback();
                }
            }
        }
        getAlign(state) {
            const align = this._align;
            if (align !== undefined) {
                if (isFunction(align)) {
                    const result = align(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return align;
                }
            }
            return this._theme.getOutlineAlign(state);
        }
        get align() {
            return this._align;
        }
        set align(align) {
            if (this._align !== align) {
                this._align = align;
                const callback = this._callback;
                if (callback != null) {
                    callback();
                }
            }
        }
        getMask(state) {
            const mask = this._mask;
            if (mask !== undefined) {
                if (isFunction(mask)) {
                    const result = mask(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return mask;
                }
            }
            return this._theme.getOutlineMask(state);
        }
        get mask() {
            return this._mask;
        }
        set mask(mask) {
            if (this._mask !== mask) {
                this._mask = mask;
                const callback = this._callback;
                if (callback != null) {
                    callback();
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBasePadding {
        constructor(theme, options, callback) {
            this._theme = theme;
            this._callback = callback;
            const padding = options === null || options === void 0 ? void 0 : options.padding;
            if (padding != null) {
                if (isNumber(padding)) {
                    this._left = padding;
                    this._top = padding;
                    this._right = padding;
                    this._bottom = padding;
                }
                else {
                    this._left = padding.left;
                    this._top = padding.top;
                    this._right = padding.right;
                    this._bottom = padding.bottom;
                }
            }
        }
        getTheme() {
            return this._theme;
        }
        setTheme(theme) {
            this._theme = theme;
        }
        getCallback() {
            return this._callback;
        }
        getLeft() {
            var _a;
            return (_a = this._left) !== null && _a !== void 0 ? _a : this._theme.getPaddingLeft();
        }
        get left() {
            return this._left;
        }
        set left(left) {
            if (this._left !== left) {
                this._left = left;
                if (this._callback != null) {
                    this._callback();
                }
            }
        }
        getTop() {
            var _a;
            return (_a = this._top) !== null && _a !== void 0 ? _a : this._theme.getPaddingTop();
        }
        get top() {
            return this._top;
        }
        set top(top) {
            if (this._top !== top) {
                this._top = top;
                if (this._callback != null) {
                    this._callback();
                }
            }
        }
        getRight() {
            var _a;
            return (_a = this._right) !== null && _a !== void 0 ? _a : this._theme.getPaddingRight();
        }
        get right() {
            return this._right;
        }
        set right(right) {
            if (this._right !== right) {
                this._right = right;
                if (this._callback != null) {
                    this._callback();
                }
            }
        }
        getBottom() {
            var _a;
            return (_a = this._bottom) !== null && _a !== void 0 ? _a : this._theme.getPaddingBottom();
        }
        get bottom() {
            return this._bottom;
        }
        set bottom(bottom) {
            if (this._bottom !== bottom) {
                this._bottom = bottom;
                if (this._callback != null) {
                    this._callback();
                }
            }
        }
        set(top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
            if (this._callback != null) {
                this._callback();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBasePoint {
        constructor(point, onChange) {
            this._point = point;
            this._onChange = onChange;
        }
        get x() {
            return this._point.x;
        }
        set x(x) {
            const point = this._point;
            const oldX = point.x;
            if (oldX !== x) {
                point.x = x;
                const y = point.y;
                this._onChange(x, y, oldX, y);
            }
        }
        get y() {
            return this._point.y;
        }
        set y(y) {
            const point = this._point;
            const oldY = point.y;
            if (oldY !== y) {
                point.y = y;
                const x = point.x;
                this._onChange(x, y, x, oldY);
            }
        }
        set(x, y) {
            const point = this._point;
            const oldX = point.x;
            const oldY = point.y;
            if (oldX !== x || oldY !== y) {
                point.set(x, y);
                this._onChange(x, y, oldX, oldY);
            }
            return this;
        }
        copyFrom(target) {
            const x = target.x;
            const y = target.y;
            const point = this._point;
            const oldX = point.x;
            const oldY = point.y;
            if (oldX !== x || oldY !== y) {
                point.copyFrom(target);
                this._onChange(x, y, oldX, oldY);
            }
            return this;
        }
        copyTo(target) {
            return target.copyFrom(this._point);
        }
        copy() {
            // eslint-disable-next-line prefer-rest-params
            return this.copyFrom(arguments[0]);
        }
        clone(onChange) {
            return new DBasePoint(this._point, onChange || this._onChange);
        }
        equals(p) {
            return this._point.equals(p);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseMeshGeometry extends pixi_js.MeshGeometry {
        constructor(vertices, uvs, indices) {
            super(vertices, uvs, indices);
            this._width = 100;
            this._height = 100;
            this._cornerRadius = 0;
            this._cornerMask = DCornerMask.NONE;
            this._isDirty = true;
            this._resolution = 1;
            this._vertexBuffer = this.getBuffer("aVertexPosition");
            this._vertices = this._vertexBuffer.data;
            this._uvBuffer = this.getBuffer("aTextureCoord");
            this._uvs = this._uvBuffer.data;
            this._indexBuffer = this.getIndex();
            this._indices = this._indexBuffer.data;
        }
        get width() {
            return this._width;
        }
        set width(width) {
            if (this._width !== width) {
                this._width = width;
                this._isDirty = true;
            }
        }
        get height() {
            return this._height;
        }
        set height(height) {
            if (this._height !== height) {
                this._height = height;
                this._isDirty = true;
            }
        }
        get cornerRadius() {
            return this._cornerRadius;
        }
        set cornerRadius(borderSize) {
            if (this._cornerRadius !== borderSize) {
                this._cornerRadius = borderSize;
                this._isDirty = true;
            }
        }
        get cornerMask() {
            return this._cornerMask;
        }
        set cornerMask(cornerMask) {
            if (this._cornerMask !== cornerMask) {
                this._cornerMask = cornerMask;
                this._isDirty = true;
            }
        }
        getTables() {
            let result = DBaseMeshGeometry.TABLES;
            if (result == null) {
                result = this.newTables(DBaseMeshGeometry.N);
                DBaseMeshGeometry.TABLES = result;
            }
            return result;
        }
        newTables(n) {
            const dp = 1.0 / (n - 1);
            const da = 0.5 * dp;
            return [
                this.newTable(n, 1.0, da),
                this.newTable(n, 0.5, da),
                this.newTable(n, 0.0, da),
                this.newTable(n, 1.5, da)
            ];
        }
        newTable(n, a0, da) {
            const cos = [];
            const sin = [];
            const pi = Math.PI;
            for (let i = 0, a = a0; i < n; i += 1, a -= da) {
                const t = a * pi;
                const c = +Math.cos(t);
                const s = -Math.sin(t);
                cos.push(c);
                sin.push(s);
            }
            return {
                cos,
                sin
            };
        }
    }
    /** Note that this must be an odd number. */
    DBaseMeshGeometry.N = 5;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseBackgroundMeshGeometry extends DBaseMeshGeometry {
        constructor() {
            super(new Float32Array(16 * DBaseMeshGeometry.N), new Float32Array(16 * DBaseMeshGeometry.N), new Uint16Array(3 * (12 * DBaseMeshGeometry.N - 2)));
        }
        fillVertices(vertices, uvs, iv, iuv, n, x, y, r, dr, table) {
            const cos = table.cos;
            const sin = table.sin;
            const r1 = r + dr;
            for (let i = 0; i < n; ++i) {
                const c = cos[i];
                const s = sin[i];
                vertices[++iv] = x + c * r;
                vertices[++iv] = y + s * r;
                vertices[++iv] = x + c * r1;
                vertices[++iv] = y + s * r1;
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5;
                uvs[++iuv] = 0.5 * (1 + c);
                uvs[++iuv] = 0.5 * (1 + s);
            }
        }
        fillIndices(indices, ia, ii, n) {
            for (let i = 0; i < n; ++i) {
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 3;
                ia += 2;
            }
        }
        fillIndicesEnd(indices, ia, ii, n) {
            for (let i = 0, imax = n - 1; i < imax; ++i) {
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 2;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 3;
                ia += 2;
            }
            indices[++ii] = ia + 0;
            indices[++ii] = ia + 1;
            indices[++ii] = 0;
            indices[++ii] = 0;
            indices[++ii] = ia + 1;
            indices[++ii] = 1;
            ia += 2;
        }
        update(renderer) {
            const resolution = renderer.resolution;
            if (this._isDirty || this._resolution !== resolution) {
                this._isDirty = false;
                this._resolution = resolution;
                const vertices = this._vertices;
                const uvs = this._uvs;
                const indices = this._indices;
                const w = this._width;
                const h = this._height;
                const r = Math.min(0.5 * w, 0.5 * h, this._cornerRadius);
                const a = 0.5 / resolution;
                const x0 = 0;
                const x1 = r;
                const x2 = w - r;
                const x3 = w;
                const y0 = 0;
                const y1 = r;
                const y2 = h - r;
                const y3 = h;
                const cornerMask = this._cornerMask;
                const ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                const ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                const cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                const cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                let iv = -1;
                let iuv = -1;
                let ia = 0;
                let ii = -1;
                const n = DBaseMeshGeometry.N;
                const n4 = n << 2;
                const n2 = n << 1;
                const n6 = 6 * n;
                const tables = this.getTables();
                const tlt = tables[0];
                const ttr = tables[1];
                const trb = tables[2];
                const tbl = tables[3];
                // left -> top
                if (ctl) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x1, y1, r, a, tlt);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x0, y0, 0, a, tlt);
                }
                this.fillIndices(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // top -> right
                if (ctr) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x2, y1, r, a, ttr);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x3, y0, 0, a, ttr);
                }
                this.fillIndices(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // right -> bottom
                if (cbr) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x2, y2, r, a, trb);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x3, y3, 0, a, trb);
                }
                this.fillIndices(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // bottom -> left
                if (cbl) {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x1, y2, r, a, tbl);
                }
                else {
                    this.fillVertices(vertices, uvs, iv, iuv, n, x0, y3, 0, a, tbl);
                }
                this.fillIndicesEnd(indices, ia, ii, n);
                iv += n4;
                iuv += n4;
                ia += n2;
                ii += n6;
                // Center
                ia = 2;
                for (let i = 1, imax = 4 * n - 1; i < imax; i += 1, ia += 2) {
                    indices[++ii] = 0;
                    indices[++ii] = ia;
                    indices[++ii] = ia + 2;
                }
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseBackgroundMesh extends pixi_js.Mesh {
        constructor(texture) {
            super(new DBaseBackgroundMeshGeometry(), new pixi_js.MeshMaterial(texture));
            texture.on("update", () => {
                DApplications.update(this);
            });
        }
        // @ts-ignore
        get width() {
            return this.geometry.width;
        }
        set width(width) {
            this.geometry.width = width;
        }
        // @ts-ignore
        get height() {
            return this.geometry.height;
        }
        set height(height) {
            this.geometry.height = height;
        }
        get cornerRadius() {
            return this.geometry.cornerRadius;
        }
        set cornerRadius(cornerRadius) {
            this.geometry.cornerRadius = cornerRadius;
        }
        get cornerMask() {
            return this.geometry.cornerMask;
        }
        set cornerMask(cornerMask) {
            this.geometry.cornerMask = cornerMask;
        }
        _render(renderer) {
            this.geometry.update(renderer);
            super._render(renderer);
        }
    }

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseBackgroundSnippet {
        get(base, theme) {
            let result = this._mesh;
            if (result == null) {
                result = new DBaseBackgroundMesh(theme.getBackgroundTexture());
                result.parent = base;
                this._mesh = result;
            }
            return result;
        }
        hide() {
            const mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        }
        onReflow(base, width, height, theme, state, cornerRadius, cornerMask) {
            const background = base.background;
            const backgroundColor = background.getColor(state);
            if (backgroundColor != null) {
                const backgroundAlpha = background.getAlpha(state);
                if (0 < backgroundAlpha) {
                    const backgroundMesh = this.get(base, theme);
                    backgroundMesh.tint = backgroundColor;
                    backgroundMesh.alpha = backgroundAlpha;
                    backgroundMesh.width = width;
                    backgroundMesh.height = height;
                    backgroundMesh.cornerRadius = cornerRadius;
                    backgroundMesh.cornerMask = cornerMask;
                    backgroundMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        }
        render(renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        }
        updateTransform() {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseBorderMeshGeometry extends DBaseMeshGeometry {
        constructor() {
            super(new Float32Array(32 * DBaseMeshGeometry.N), new Float32Array(32 * DBaseMeshGeometry.N), new Uint16Array(4 * 18 * DBaseMeshGeometry.N));
            this._borderWidth = 0;
            this._borderMask = DBorderMask.NONE;
        }
        get borderWidth() {
            return this._borderWidth;
        }
        set borderWidth(borderWidth) {
            if (this._borderWidth !== borderWidth) {
                this._borderWidth = borderWidth;
                this._isDirty = true;
            }
        }
        get borderMask() {
            return this._borderMask;
        }
        set borderMask(borderMask) {
            if (this._borderMask !== borderMask) {
                this._borderMask = borderMask;
                this._isDirty = true;
            }
        }
        fillVertices(vertices, uvs, iv, iuv, n, x, y, r, dr, borderWidth, table) {
            const hw = 0.5 * borderWidth;
            const r1 = r - hw;
            const r2 = r + hw;
            const r0 = r1 - dr;
            const r3 = r2 + dr;
            const cos = table.cos;
            const sin = table.sin;
            if (r0 <= 0) {
                const c0 = cos[0] + cos[n - 1];
                const s0 = sin[0] + sin[n - 1];
                if (r1 <= 0) {
                    if (r <= 0) {
                        for (let i = 0; i < n; ++i) {
                            const c = cos[i];
                            const s = sin[i];
                            vertices[++iv] = x + c0 * r0;
                            vertices[++iv] = y + s0 * r0;
                            vertices[++iv] = x + c0 * r1;
                            vertices[++iv] = y + s0 * r1;
                            vertices[++iv] = x + c0 * r2;
                            vertices[++iv] = y + s0 * r2;
                            vertices[++iv] = x + c0 * r3;
                            vertices[++iv] = y + s0 * r3;
                            uvs[++iuv] = 0.5 * (1 + c);
                            uvs[++iuv] = 0.5 * (1 + s);
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5 * (1 + c);
                            uvs[++iuv] = 0.5 * (1 + s);
                        }
                    }
                    else {
                        for (let i = 0; i < n; ++i) {
                            const c = cos[i];
                            const s = sin[i];
                            vertices[++iv] = x + c0 * r0;
                            vertices[++iv] = y + s0 * r0;
                            vertices[++iv] = x + c0 * r1;
                            vertices[++iv] = y + s0 * r1;
                            vertices[++iv] = x + c * r2;
                            vertices[++iv] = y + s * r2;
                            vertices[++iv] = x + c * r3;
                            vertices[++iv] = y + s * r3;
                            uvs[++iuv] = 0.5 * (1 + c);
                            uvs[++iuv] = 0.5 * (1 + s);
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5;
                            uvs[++iuv] = 0.5 * (1 + c);
                            uvs[++iuv] = 0.5 * (1 + s);
                        }
                    }
                }
                else {
                    for (let i = 0; i < n; ++i) {
                        const c = cos[i];
                        const s = sin[i];
                        vertices[++iv] = x + c0 * r0;
                        vertices[++iv] = y + s0 * r0;
                        vertices[++iv] = x + c * r1;
                        vertices[++iv] = y + s * r1;
                        vertices[++iv] = x + c * r2;
                        vertices[++iv] = y + s * r2;
                        vertices[++iv] = x + c * r3;
                        vertices[++iv] = y + s * r3;
                        uvs[++iuv] = 0.5 * (1 + c);
                        uvs[++iuv] = 0.5 * (1 + s);
                        uvs[++iuv] = 0.5;
                        uvs[++iuv] = 0.5;
                        uvs[++iuv] = 0.5;
                        uvs[++iuv] = 0.5;
                        uvs[++iuv] = 0.5 * (1 + c);
                        uvs[++iuv] = 0.5 * (1 + s);
                    }
                }
            }
            else {
                for (let i = 0; i < n; ++i) {
                    const c = cos[i];
                    const s = sin[i];
                    vertices[++iv] = x + c * r0;
                    vertices[++iv] = y + s * r0;
                    vertices[++iv] = x + c * r1;
                    vertices[++iv] = y + s * r1;
                    vertices[++iv] = x + c * r2;
                    vertices[++iv] = y + s * r2;
                    vertices[++iv] = x + c * r3;
                    vertices[++iv] = y + s * r3;
                    uvs[++iuv] = 0.5 * (1 + c);
                    uvs[++iuv] = 0.5 * (1 + s);
                    uvs[++iuv] = 0.5;
                    uvs[++iuv] = 0.5;
                    uvs[++iuv] = 0.5;
                    uvs[++iuv] = 0.5;
                    uvs[++iuv] = 0.5 * (1 + c);
                    uvs[++iuv] = 0.5 * (1 + s);
                }
            }
        }
        fillIndices(indices, ia, ii, n, end, loop) {
            for (let i = 0, imax = n - 1; i < imax; ++i) {
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 5;
                ia += 1;
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 5;
                ia += 1;
                indices[++ii] = ia + 0;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 4;
                indices[++ii] = ia + 1;
                indices[++ii] = ia + 5;
                ia += 2;
            }
            if (end) {
                if (loop) {
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 0;
                    indices[++ii] = 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 1;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 1;
                    indices[++ii] = 1;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 2;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 2;
                    indices[++ii] = 2;
                    indices[++ii] = ia + 1;
                    indices[++ii] = 3;
                    ia += 2;
                }
                else {
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 5;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 5;
                    ia += 1;
                    indices[++ii] = ia + 0;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 4;
                    indices[++ii] = ia + 1;
                    indices[++ii] = ia + 5;
                    ia += 2;
                }
            }
            else {
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                ia += 1;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                ia += 1;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                indices[++ii] = ia;
                ia += 2;
            }
        }
        update(renderer) {
            const resolution = renderer.resolution;
            if (this._isDirty || this._resolution !== resolution) {
                this._isDirty = false;
                this._resolution = resolution;
                const vrtcs = this._vertices;
                const uvs = this._uvs;
                const indices = this._indices;
                const w = this._width;
                const h = this._height;
                const bw = this._borderWidth;
                const r = Math.min(0.5 * w, 0.5 * h, this._cornerRadius);
                const a = 0.5 / resolution;
                const x0 = 0;
                const x1 = r;
                const x2 = w - r;
                const x3 = w;
                const y0 = 0;
                const y1 = r;
                const y2 = h - r;
                const y3 = h;
                const borderMask = this._borderMask;
                const bt = !(borderMask & DBorderMask.TOP);
                const bb = !(borderMask & DBorderMask.BOTTOM);
                const bl = !(borderMask & DBorderMask.LEFT);
                const br = !(borderMask & DBorderMask.RIGHT);
                const cornerMask = this._cornerMask;
                const ctl = !(cornerMask & DCornerMask.TOP_LEFT);
                const ctr = !(cornerMask & DCornerMask.TOP_RIGHT);
                const cbl = !(cornerMask & DCornerMask.BOTTOM_LEFT);
                const cbr = !(cornerMask & DCornerMask.BOTTOM_RIGHT);
                // Vertices & UVs
                let iv = -1;
                let iuv = -1;
                let ia = 0;
                let ii = -1;
                const n = DBaseMeshGeometry.N;
                const n4 = n << 2;
                const n8 = n << 3;
                const n18 = 18 * n;
                const tables = this.getTables();
                const tlt = tables[0];
                const ttr = tables[1];
                const trb = tables[2];
                const tbl = tables[3];
                // left -> top
                if (ctl) {
                    if (bl || bt) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y1, r, a, bw, tlt);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y1, r, a, 0, tlt);
                    }
                }
                else {
                    if (bl || bt) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y0, 0, a, bw, tlt);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y0, 0, a, 0, tlt);
                    }
                }
                this.fillIndices(indices, ia, ii, n, bt, false);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                // top -> right
                if (ctr) {
                    if (bt || br) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y1, r, a, bw, ttr);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y1, r, a, 0, ttr);
                    }
                }
                else {
                    if (bt || br) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y0, 0, a, bw, ttr);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y0, 0, a, 0, ttr);
                    }
                }
                this.fillIndices(indices, ia, ii, n, br, false);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                // right -> bottom
                if (cbr) {
                    if (br || bb) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y2, r, a, bw, trb);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x2, y2, r, a, 0, trb);
                    }
                }
                else {
                    if (br || bb) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y3, 0, a, bw, trb);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x3, y3, 0, a, 0, trb);
                    }
                }
                this.fillIndices(indices, ia, ii, n, bb, false);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                // bottom -> left
                if (cbl) {
                    if (bb || bl) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y2, r, a, bw, tbl);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x1, y2, r, a, 0, tbl);
                    }
                }
                else {
                    if (bb || bl) {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y3, 0, a, bw, tbl);
                    }
                    else {
                        this.fillVertices(vrtcs, uvs, iv, iuv, n, x0, y3, 0, a, 0, tbl);
                    }
                }
                this.fillIndices(indices, ia, ii, n, bl, true);
                iv += n8;
                iuv += n8;
                ia += n4;
                ii += n18;
                this._vertexBuffer.update();
                this._uvBuffer.update();
                this._indexBuffer.update();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseBorderMesh extends pixi_js.Mesh {
        constructor(texture) {
            super(new DBaseBorderMeshGeometry(), new pixi_js.MeshMaterial(texture));
            texture.on("update", () => {
                DApplications.update(this);
            });
        }
        // @ts-ignore
        get width() {
            return this.geometry.width;
        }
        set width(width) {
            this.geometry.width = width;
        }
        // @ts-ignore
        get height() {
            return this.geometry.height;
        }
        set height(height) {
            this.geometry.height = height;
        }
        get cornerRadius() {
            return this.geometry.cornerRadius;
        }
        set cornerRadius(cornerRadius) {
            this.geometry.cornerRadius = cornerRadius;
        }
        get cornerMask() {
            return this.geometry.cornerMask;
        }
        set cornerMask(cornerMask) {
            this.geometry.cornerMask = cornerMask;
        }
        get borderWidth() {
            return this.geometry.borderWidth;
        }
        set borderWidth(borderWidth) {
            this.geometry.borderWidth = borderWidth;
        }
        get borderMask() {
            return this.geometry.borderMask;
        }
        set borderMask(borderMask) {
            this.geometry.borderMask = borderMask;
        }
        _render(renderer) {
            this.geometry.update(renderer);
            super._render(renderer);
        }
    }

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseBorderSnippet {
        get(base, theme) {
            let result = this._mesh;
            if (result == null) {
                result = new DBaseBorderMesh(theme.getBorderTexture());
                result.parent = base;
                this._mesh = result;
            }
            return result;
        }
        hide() {
            const mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        }
        onReflow(base, width, height, theme, state, cornerRadius, cornerMask) {
            const border = base.border;
            const borderColor = border.getColor(state);
            if (borderColor != null) {
                const borderAlpha = border.getAlpha(state);
                if (0 < borderAlpha) {
                    const borderWidth = border.getWidth(state);
                    const borderMask = border.getMask(state);
                    const borderMesh = this.get(base, theme);
                    const borderOffset = (border.getAlign(state) - 0.5) * borderWidth;
                    borderMesh.tint = borderColor;
                    borderMesh.alpha = borderAlpha;
                    borderMesh.x = -borderOffset;
                    borderMesh.y = -borderOffset;
                    borderMesh.width = width + borderOffset * 2;
                    borderMesh.height = height + borderOffset * 2;
                    borderMesh.cornerRadius = Math.max(0, cornerRadius + borderOffset);
                    borderMesh.cornerMask = cornerMask;
                    borderMesh.borderWidth = borderWidth;
                    borderMesh.borderMask = borderMask;
                    borderMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        }
        render(renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        }
        updateTransform() {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        }
    }

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseOutlineSnippet {
        get(base, theme) {
            let result = this._mesh;
            if (result == null) {
                result = new DBaseBorderMesh(theme.getBorderTexture());
                result.parent = base;
                this._mesh = result;
            }
            return result;
        }
        hide() {
            const mesh = this._mesh;
            if (mesh != null) {
                mesh.visible = false;
            }
        }
        onReflow(base, width, height, theme, state, cornerRadius, cornerMask) {
            const outline = base.outline;
            const outlineColor = outline.getColor(state);
            if (outlineColor != null) {
                const outlineAlpha = outline.getAlpha(state);
                if (0 < outlineAlpha) {
                    const outlineWidth = outline.getWidth(state);
                    const outlineMask = outline.getMask(state);
                    const outlineMesh = this.get(base, theme);
                    const outlineOffset = outline.getOffset(state) + (outline.getAlign(state) - 0.5) * outlineWidth;
                    outlineMesh.tint = outlineColor;
                    outlineMesh.alpha = outlineAlpha;
                    outlineMesh.x = -outlineOffset;
                    outlineMesh.y = -outlineOffset;
                    outlineMesh.width = width + outlineOffset * 2;
                    outlineMesh.height = height + outlineOffset * 2;
                    outlineMesh.cornerRadius = Math.max(0, cornerRadius + outlineOffset);
                    outlineMesh.cornerMask = cornerMask;
                    outlineMesh.borderWidth = outlineWidth;
                    outlineMesh.borderMask = outlineMask;
                    outlineMesh.visible = true;
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        }
        render(renderer) {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.render(renderer);
        }
        updateTransform() {
            var _a;
            (_a = this._mesh) === null || _a === void 0 ? void 0 : _a.updateTransform();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseReflowableImpl {
        constructor(base) {
            const background = new DBaseBackgroundSnippet();
            this._background = background;
            base.snippet.add(background, true);
            const border = new DBaseBorderSnippet();
            this._border = border;
            base.snippet.add(border, true);
            const outline = new DBaseOutlineSnippet();
            this._outline = outline;
            base.snippet.add(outline, false);
            base.reflowable.add(this);
        }
        onReflow(base, width, height) {
            const theme = base.theme;
            const state = base.state;
            const corner = base.corner;
            const cornerRadius = corner.getRadius();
            const cornerMask = corner.getMask();
            this._background.onReflow(base, width, height, theme, state, cornerRadius, cornerMask);
            this._border.onReflow(base, width, height, theme, state, cornerRadius, cornerMask);
            this._outline.onReflow(base, width, height, theme, state, cornerRadius, cornerMask);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const BEFORE = 1;
    const AFTER = 2;
    const DLayoutClearType = {
        NONE: 0,
        BEFORE,
        AFTER,
        BOTH: BEFORE | AFTER
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DScalarExpressionNodeType = {
        // Parensesis
        OPEN: 0,
        CLOSE: 1,
        PARENSESIS: 2,
        // Operations
        ADD_OR_PLUS: 3,
        SUB_OR_MINUS: 4,
        PLUS: 5,
        MINUS: 6,
        ADD: 7,
        SUB: 8,
        MUL: 9,
        DIV: 10,
        // Functions
        MIN: 11,
        MAX: 12,
        COMMA: 13,
        // Literals
        PARENT: 14,
        SELF: 15,
        PADDING: 16,
        CURRENT: 17,
        NUMBER: 18
    };
    /**
     * Parser and evaluator of the scalar expressions like `100% - 50s`.
     *
     * Literals
     *
     * * x%: 0.01 * x * parent value
     * * xs: 0.01 * x * self value
     * * xp: 0.01 * x * padding value
     * * xc: 0.01 * x * current value
     *
     * Operators
     *
     * * `+`
     * * `-`
     * * `*`
     * * `/`
     * * `(` and `)`
     *
     * Functions
     *
     * * min( a, b, ... )
     * * max( a, b, ... )
     *
     * Examples
     *
     * * `90%`: 0.9 * parent value
     * * `50s`: 0.5 * self value
     * * `90% - 50s`: 0.9 * parent value - 0.5 * self value
     * * `90% - (50s + 100) * 2`: 0.9 * parent value - ( 0.5 * self value + 100 ) * 2
     */
    class DScalarExpression {
        constructor(expression) {
            const nodes = this.toToken(expression);
            let i = 0;
            do {
                i = this.toParensesis(nodes, i);
            } while (i < nodes.length);
            this.toUnary(nodes);
            this.toArithmetic(nodes, DScalarExpressionNodeType.MUL, DScalarExpressionNodeType.DIV);
            this.toArithmetic(nodes, DScalarExpressionNodeType.ADD, DScalarExpressionNodeType.SUB);
            if (nodes.length === 1) {
                const node = nodes[0];
                if (!isNumber(node)) {
                    this._node = node;
                    return;
                }
            }
            throw new Error(`Failed to parse '${expression}'`);
        }
        toParensesis(nodes, ifrom) {
            let ito = nodes.length;
            for (let i = ifrom; i < ito; ++i) {
                const inode = nodes[i];
                if (inode === DScalarExpressionNodeType.OPEN) {
                    let istart = i;
                    let nodeType = DScalarExpressionNodeType.PARENSESIS;
                    if (0 < i) {
                        const nodeTypePrev = nodes[i - 1];
                        if (nodeTypePrev === DScalarExpressionNodeType.MIN ||
                            nodeTypePrev === DScalarExpressionNodeType.MAX) {
                            istart -= 1;
                            nodeType = nodeTypePrev;
                        }
                    }
                    for (let j = i + 1; j < ito; ++j) {
                        const jnode = nodes[j];
                        if (jnode === DScalarExpressionNodeType.CLOSE) {
                            nodes[istart] = [nodeType, this.toComma(nodes, i + 1, j)];
                            nodes.splice(istart + 1, j - istart);
                            return istart + 1;
                        }
                        else if (jnode === DScalarExpressionNodeType.OPEN) {
                            j = this.toParensesis(nodes, j) - 1;
                            ito = nodes.length;
                        }
                    }
                    throw new Error(`Malformed parensesis`);
                }
            }
            return ito;
        }
        toCommaOf(nodes, ifrom, ito) {
            const l = ito - ifrom;
            if (l <= 0) {
                return [DScalarExpressionNodeType.NUMBER, 0];
            }
            else if (l <= 1) {
                return nodes[ifrom];
            }
            else {
                const operand = [];
                for (let j = ifrom; j < ito; ++j) {
                    operand.push(nodes[j]);
                }
                return [DScalarExpressionNodeType.PARENSESIS, operand];
            }
        }
        toComma(nodes, ifrom, ito) {
            let result = null;
            let iprev = ifrom;
            for (let i = ifrom; i < ito; ++i) {
                const node = nodes[i];
                if (node === DScalarExpressionNodeType.COMMA) {
                    result = result || [];
                    result.push(this.toCommaOf(nodes, iprev, i));
                    iprev = i + 1;
                }
            }
            if (iprev < ito) {
                if (result == null) {
                    const operand = [];
                    for (let i = iprev; i < ito; ++i) {
                        operand.push(nodes[i]);
                    }
                    return operand;
                }
                else {
                    result.push(this.toCommaOf(nodes, iprev, ito));
                }
            }
            return result || [];
        }
        toUnaryNode(node) {
            if (!isNumber(node)) {
                if (node[0] === DScalarExpressionNodeType.PARENSESIS ||
                    node[0] === DScalarExpressionNodeType.MIN ||
                    node[0] === DScalarExpressionNodeType.MAX) {
                    this.toUnary(node[1]);
                }
            }
        }
        toUnary(nodes) {
            for (let i = 0, imax = nodes.length; i < imax; ++i) {
                const node = nodes[i];
                if (node === DScalarExpressionNodeType.ADD_OR_PLUS ||
                    node === DScalarExpressionNodeType.SUB_OR_MINUS) {
                    if (i <= 0 || isNumber(nodes[i - 1])) {
                        if (i + 1 < imax && !isNumber(nodes[i + 1])) {
                            const operand = nodes.splice(i + 1, 1)[0];
                            const type = node === DScalarExpressionNodeType.ADD_OR_PLUS
                                ? DScalarExpressionNodeType.PLUS
                                : DScalarExpressionNodeType.MINUS;
                            nodes[i] = [type, operand];
                            imax = nodes.length;
                            this.toUnaryNode(operand);
                        }
                        else {
                            throw new Error("Malformed unary operator");
                        }
                    }
                    else {
                        const type = node === DScalarExpressionNodeType.ADD_OR_PLUS
                            ? DScalarExpressionNodeType.ADD
                            : DScalarExpressionNodeType.SUB;
                        nodes[i] = type;
                    }
                }
                else {
                    this.toUnaryNode(node);
                    imax = nodes.length;
                }
            }
        }
        toArithmeticNode(node, operatorA, operatorB) {
            if (!isNumber(node)) {
                if (node[0] === DScalarExpressionNodeType.PARENSESIS ||
                    node[0] === DScalarExpressionNodeType.MIN ||
                    node[0] === DScalarExpressionNodeType.MAX) {
                    this.toArithmetic(node[1], operatorA, operatorB);
                }
                else if (node[0] === DScalarExpressionNodeType.PLUS ||
                    node[0] === DScalarExpressionNodeType.MINUS) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                }
                else if (node[0] === DScalarExpressionNodeType.ADD ||
                    node[0] === DScalarExpressionNodeType.SUB ||
                    node[0] === DScalarExpressionNodeType.MUL ||
                    node[0] === DScalarExpressionNodeType.DIV) {
                    this.toArithmeticNode(node[1], operatorA, operatorB);
                    this.toArithmeticNode(node[2], operatorA, operatorB);
                }
            }
        }
        toArithmetic(nodes, operatorA, operatorB) {
            for (let i = 0, imax = nodes.length; i < imax; ++i) {
                const node = nodes[i];
                if (node === operatorA || node === operatorB) {
                    if (0 < i && i + 1 < imax) {
                        const left = nodes[i - 1];
                        const right = nodes[i + 1];
                        if (!isNumber(left) && !isNumber(right)) {
                            nodes.splice(i, 2);
                            nodes[i - 1] = [node, left, right];
                            i -= 1;
                            imax = nodes.length;
                            this.toArithmeticNode(left, operatorA, operatorB);
                            this.toArithmeticNode(right, operatorA, operatorB);
                            continue;
                        }
                    }
                    throw new Error(`Malformed operands for the operator ${node}`);
                }
                else {
                    this.toArithmeticNode(node, operatorA, operatorB);
                    imax = nodes.length;
                }
            }
        }
        toToken(expression) {
            const tokens = [];
            while (true) {
                const matched = DScalarExpression.TOKEN_REGEX.exec(expression);
                if (matched != null) {
                    const token = matched[0];
                    const tokenTypeOperator = this.toTokenOperator(token);
                    if (tokenTypeOperator != null) {
                        tokens.push(tokenTypeOperator);
                    }
                    else {
                        const parsedToken = parseFloat(token);
                        if (parsedToken !== parsedToken) {
                            throw new Error(`Unexpected token '${token}' at ${matched.index} in '${expression}'`);
                        }
                        const tokenTypeLiteral = this.toTokenLiteral(token);
                        if (tokenTypeLiteral != null) {
                            tokens.push([tokenTypeLiteral, parsedToken * 0.01]);
                        }
                        else {
                            tokens.push([DScalarExpressionNodeType.NUMBER, parsedToken]);
                        }
                    }
                }
                else {
                    break;
                }
            }
            return tokens;
        }
        toTokenOperator(token) {
            switch (token) {
                case "+":
                    return DScalarExpressionNodeType.ADD_OR_PLUS;
                case "-":
                    return DScalarExpressionNodeType.SUB_OR_MINUS;
                case "*":
                    return DScalarExpressionNodeType.MUL;
                case "/":
                    return DScalarExpressionNodeType.DIV;
                case "(":
                    return DScalarExpressionNodeType.OPEN;
                case ")":
                    return DScalarExpressionNodeType.CLOSE;
                case ",":
                    return DScalarExpressionNodeType.COMMA;
                case "min":
                    return DScalarExpressionNodeType.MIN;
                case "max":
                    return DScalarExpressionNodeType.MAX;
            }
            return null;
        }
        toTokenLiteral(token) {
            const tokenLength = token.length;
            if (0 < tokenLength) {
                switch (token[tokenLength - 1]) {
                    case "%":
                        return DScalarExpressionNodeType.PARENT;
                    case "s":
                        return DScalarExpressionNodeType.SELF;
                    case "p":
                        return DScalarExpressionNodeType.PADDING;
                    case "c":
                        return DScalarExpressionNodeType.CURRENT;
                }
            }
            return null;
        }
        evaluate(node, parent, self, padding, current) {
            switch (node[0]) {
                case DScalarExpressionNodeType.PARENSESIS:
                    const nodes = node[1];
                    return this.evaluate(nodes[nodes.length - 1], parent, self, padding, current);
                // Unary operators
                case DScalarExpressionNodeType.PLUS:
                    return +this.evaluate(node[1], parent, self, padding, current);
                case DScalarExpressionNodeType.MINUS:
                    return -this.evaluate(node[1], parent, self, padding, current);
                // Four arithmetic operators
                case DScalarExpressionNodeType.ADD:
                    return (this.evaluate(node[1], parent, self, padding, current) +
                        this.evaluate(node[2], parent, self, padding, current));
                case DScalarExpressionNodeType.SUB:
                    return (this.evaluate(node[1], parent, self, padding, current) -
                        this.evaluate(node[2], parent, self, padding, current));
                case DScalarExpressionNodeType.MUL:
                    return (this.evaluate(node[1], parent, self, padding, current) *
                        this.evaluate(node[2], parent, self, padding, current));
                case DScalarExpressionNodeType.DIV:
                    return (this.evaluate(node[1], parent, self, padding, current) /
                        this.evaluate(node[2], parent, self, padding, current));
                // Functions
                case DScalarExpressionNodeType.MIN:
                    if (0 < node[1].length) {
                        const args = node[1];
                        let result = this.evaluate(args[0], parent, self, padding, current);
                        for (let i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.min(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                case DScalarExpressionNodeType.MAX:
                    if (0 < node[1].length) {
                        const args = node[1];
                        let result = this.evaluate(args[0], parent, self, padding, current);
                        for (let i = 1, imax = args.length; i < imax; ++i) {
                            result = Math.max(result, this.evaluate(args[i], parent, self, padding, current));
                        }
                        return result;
                    }
                    return 0;
                // Literals
                case DScalarExpressionNodeType.PARENT:
                    return node[1] * parent;
                case DScalarExpressionNodeType.SELF:
                    return node[1] * self;
                case DScalarExpressionNodeType.PADDING:
                    return node[1] * padding;
                case DScalarExpressionNodeType.CURRENT:
                    return node[1] * current;
                case DScalarExpressionNodeType.NUMBER:
                    return node[1];
            }
            return 0;
        }
        calculate(parent, self, padding, current) {
            return this.evaluate(this._node, parent, self, padding, current);
        }
    }
    DScalarExpression.TOKEN_REGEX = /(?:\+|-|\*|\/|\(|\)|min|max|,|(?:\d+(?:\.\d*)?[%psc]?))/g;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const POSITION_CENTER = (p, s) => (p - s) * 0.5;
    const POSITION_PADDING = (p, s, d) => d;
    const SIZE_MAXIMIZED = (p) => p;
    const SIZE_PADDING = (p, s, d) => p - d;
    class DScalarFunctions {
        static position(coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "center":
                    case "CENTER":
                        return POSITION_CENTER;
                    case "padding":
                    case "PADDING":
                        return POSITION_PADDING;
                }
                const scalarExpression = new DScalarExpression(coordinate);
                return (parent, self, padding, current) => {
                    return scalarExpression.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                const scalar = coordinate;
                return (parent, self, padding, current) => {
                    return scalar.calculate(parent, self, padding, current);
                };
            }
        }
        static size(coordinate) {
            if (coordinate == null || isNumber(coordinate)) {
                return null;
            }
            else if (isString(coordinate)) {
                switch (coordinate) {
                    case "100%":
                    case "maximized":
                    case "MAXIMIZED":
                        return SIZE_MAXIMIZED;
                    case "padding":
                    case "PADDING":
                        return SIZE_PADDING;
                }
                const scalarExpression = new DScalarExpression(coordinate);
                return (parent, self, padding, current) => {
                    return scalarExpression.calculate(parent, self, padding, current);
                };
            }
            else if (isFunction(coordinate)) {
                return coordinate;
            }
            else {
                const scalar = coordinate;
                return (parent, self, padding, current) => {
                    return scalar.calculate(parent, self, padding, current);
                };
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const setShortcutKeyAndWhich = (shortcut) => {
        const key = shortcut.key;
        if (key.length <= 1) {
            if (shortcut.shift) {
                shortcut.key = key.toUpperCase();
            }
            const code = key.charCodeAt(0);
            shortcut.which = 97 <= code && code <= 122 ? code - 32 : code;
        }
        else {
            switch (key) {
                case "enter":
                    shortcut.key = "Enter";
                    shortcut.which = 13;
                    break;
                case "space":
                    shortcut.key = " ";
                    shortcut.which = 32;
                    break;
                case "escape":
                    shortcut.key = "Escape";
                    shortcut.which = 27;
                    break;
                case "f1":
                    shortcut.key = "F1";
                    shortcut.which = 112;
                    break;
                case "f2":
                    shortcut.key = "F2";
                    shortcut.which = 113;
                    break;
                case "f3":
                    shortcut.key = "F3";
                    shortcut.which = 114;
                    break;
                case "f4":
                    shortcut.key = "F4";
                    shortcut.which = 115;
                    break;
                case "f5":
                    shortcut.key = "F5";
                    shortcut.which = 116;
                    break;
                case "f6":
                    shortcut.key = "F6";
                    shortcut.which = 117;
                    break;
                case "f7":
                    shortcut.key = "F7";
                    shortcut.which = 118;
                    break;
                case "f8":
                    shortcut.key = "F8";
                    shortcut.which = 119;
                    break;
                case "f9":
                    shortcut.key = "F9";
                    shortcut.which = 120;
                    break;
                case "f10":
                    shortcut.key = "F10";
                    shortcut.which = 121;
                    break;
                case "f11":
                    shortcut.key = "F11";
                    shortcut.which = 122;
                    break;
                case "f12":
                    shortcut.key = "F12";
                    shortcut.which = 123;
                    break;
                case "capslock":
                    shortcut.key = "CapsLock";
                    if (shortcut.shift) {
                        shortcut.which = 20;
                    }
                    else {
                        shortcut.which = 240;
                    }
                    break;
                case "arrowup":
                    shortcut.key = "ArrowUp";
                    shortcut.which = 38;
                    break;
                case "arrowdown":
                    shortcut.key = "ArrowDown";
                    shortcut.which = 40;
                    break;
                case "arrowleft":
                    shortcut.key = "ArrowLeft";
                    shortcut.which = 37;
                    break;
                case "arrowright":
                    shortcut.key = "ArrowRight";
                    shortcut.which = 39;
                    break;
                case "insert":
                    shortcut.key = "Insert";
                    shortcut.which = 45;
                    break;
                case "delete":
                    shortcut.key = "Delete";
                    shortcut.which = 46;
                    break;
                case "pageup":
                    shortcut.key = "PageUp";
                    shortcut.which = 33;
                    break;
                case "pagedown":
                    shortcut.key = "PageDown";
                    shortcut.which = 34;
                    break;
                case "backspace":
                    shortcut.key = "Backspace";
                    shortcut.which = 8;
                    break;
                case "colon":
                    shortcut.key = ":";
                    shortcut.which = 186;
                    break;
                case "semicolon":
                    shortcut.key = ";";
                    shortcut.which = 187;
                    break;
                case "pause":
                    shortcut.key = "Pause";
                    shortcut.which = 19;
                    break;
                case "scrolllock":
                    shortcut.key = "ScrollLock";
                    shortcut.which = 145;
                    break;
                case "tab":
                    shortcut.key = "Tab";
                    shortcut.which = 9;
                    break;
                case "plus":
                    shortcut.key = "+";
                    shortcut.which = 187;
                    break;
                case "minus":
                    shortcut.key = "-";
                    shortcut.which = 189;
                    break;
            }
        }
        return shortcut;
    };
    class UtilKeyboardEvent {
        static isActivateKey(e) {
            return e.key === "Space" || e.key === "Enter" || e.which === 32 || e.which === 13;
        }
        static isArrowUpKey(e) {
            return e.key === "ArrowUp" || e.which === 38;
        }
        static isArrowDownKey(e) {
            return e.key === "ArrowDown" || e.which === 40;
        }
        static isArrowLeftKey(e) {
            return e.key === "ArrowLeft" || e.which === 37;
        }
        static isArrowRightKey(e) {
            return e.key === "ArrowRight" || e.which === 39;
        }
        static isCancelKey(e) {
            return e.key === "Esc" || e.which === 27;
        }
        static isFocusKey(e) {
            return e.key === "Tab" || e.which === 9;
        }
        static isUndoKey(e) {
            return e.ctrlKey && (e.key === "z" || e.which === 90);
        }
        static isRedoKey(e) {
            return e.ctrlKey && (e.key === "y" || e.which === 89);
        }
        static isSaveKey(e) {
            return e.ctrlKey && !e.shiftKey && (e.key === "s" || e.which === 83);
        }
        static isSaveAsKey(e) {
            return e.ctrlKey && e.shiftKey && (e.key === "S" || e.which === 83);
        }
        static isDeleteKey(e) {
            return e.key === "Delete" || e.which === 46;
        }
        static isSelectAllKey(e) {
            return e.ctrlKey && !e.shiftKey && (e.key === "a" || e.which === 65);
        }
        static isOkKey(e) {
            return e.key === "Enter" || e.which === 13;
        }
        static getFocusDirection(e) {
            return e.shiftKey !== true;
        }
        static toShortcut(expressionOrShortcut) {
            if (!isString(expressionOrShortcut)) {
                return expressionOrShortcut;
            }
            else {
                const expression = expressionOrShortcut;
                const arrowIndex = expression.indexOf("->");
                let keyExpression;
                let event;
                if (0 <= arrowIndex) {
                    keyExpression = expression.substring(0, arrowIndex).trim().toLowerCase();
                    event = expression.substring(arrowIndex + 2).trim();
                }
                else {
                    keyExpression = expression.trim().toLowerCase();
                }
                let alt = false;
                let ctrl = false;
                let shift = false;
                let key = "a";
                const length = keyExpression.length;
                let i = 0;
                let j = 1;
                for (; j < length; ++j) {
                    const c = keyExpression.charAt(j);
                    if (c === "+") {
                        const part = keyExpression.substring(i, j);
                        switch (part) {
                            case "alt":
                                alt = true;
                                break;
                            case "ctrl":
                                ctrl = true;
                                break;
                            case "shift":
                                shift = true;
                                break;
                            default:
                                key = part;
                                break;
                        }
                        j += 1;
                        i = j;
                    }
                }
                if (i !== j) {
                    key = keyExpression.substring(i, j);
                }
                return setShortcutKeyAndWhich({
                    alt,
                    ctrl,
                    shift,
                    key,
                    which: 0,
                    event
                });
            }
        }
        static toString(shortcut) {
            const parts = [];
            if (shortcut.ctrl) {
                parts.push("Ctrl");
            }
            if (shortcut.shift) {
                parts.push("Shift");
            }
            if (shortcut.alt) {
                parts.push("Alt");
            }
            parts.push(shortcut.key.toUpperCase());
            return parts.join("+");
        }
        static on(target, expressionOrShortcut, handler) {
            const shortcut = this.toShortcut(expressionOrShortcut);
            document.body.addEventListener("keydown", (e) => {
                if (e.altKey === shortcut.alt &&
                    e.ctrlKey === shortcut.ctrl &&
                    e.shiftKey === shortcut.shift &&
                    (e.key === shortcut.key || e.which === shortcut.which)) {
                    if (target.state.isActionable) {
                        if (shortcut.event != null) {
                            target.emit(shortcut.event);
                        }
                        else if (handler != null) {
                            handler(e);
                        }
                    }
                    e.preventDefault();
                }
            });
        }
        static moveFocusVertically(e, target, picker) {
            if (target.state.isActionable) {
                const isBackward = UtilKeyboardEvent.isArrowUpKey(e);
                const isForward = UtilKeyboardEvent.isArrowDownKey(e);
                if (isBackward || isForward) {
                    return this.moveFocus(isForward, target, picker);
                }
            }
            return false;
        }
        static moveFocusHorizontally(e, target, picker) {
            if (target.state.isActionable) {
                const isBackward = UtilKeyboardEvent.isArrowLeftKey(e);
                const isForward = UtilKeyboardEvent.isArrowRightKey(e);
                if (isBackward || isForward) {
                    return this.moveFocus(isForward, target, picker);
                }
            }
            return false;
        }
        static moveFocus(direction, target, picker) {
            var _a;
            const layer = (_a = picker === null || picker === void 0 ? void 0 : picker.picked) !== null && _a !== void 0 ? _a : DApplications.getLayer(target);
            if (layer) {
                const focusController = layer.getFocusController();
                const focused = focusController.get();
                if (focused != null) {
                    const next = focusController.find(focused, false, focused.state.isFocusRoot || direction, direction, target);
                    if (next != null) {
                        focusController.focus(next);
                        return true;
                    }
                }
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseAuto {
        constructor() {
            this._isOn = false;
        }
        get isOff() {
            return !this._isOn;
        }
        get isOn() {
            return this._isOn;
        }
        toCoordinate(def) {
            return this._isOn ? "auto" : def;
        }
        /**
         * Update the auto settings by the given size.
         *
         * @param size a size
         * @returns True if the given size is "auto".
         */
        from(size) {
            if (size === "auto" || size === "AUTO") {
                this._isOn = true;
                return true;
            }
            this._isOn = false;
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseAutoSet {
        constructor() {
            this.width = new DBaseAuto();
            this.height = new DBaseAuto();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseSnippetContainer {
        constructor(parent) {
            this._parent = parent;
            this._befores = [];
            this._afters = [];
            this._renderable = true;
        }
        get renderable() {
            return this._renderable;
        }
        set renderable(renderable) {
            this._renderable = renderable;
        }
        add(snippet, phase) {
            const list = phase ? this._befores : this._afters;
            list.push(snippet);
            if ("parent" in snippet) {
                snippet.parent = this._parent;
            }
        }
        addAt(snippet, phase, index) {
            const list = phase ? this._befores : this._afters;
            if (index === 0) {
                list.unshift(snippet);
            }
            else if (0 < index && index < list.length) {
                list.splice(index, 0, snippet);
            }
            else {
                list.push(snippet);
            }
            if ("parent" in snippet) {
                snippet.parent = this._parent;
            }
        }
        remove(snippet, phase) {
            const list = phase ? this._befores : this._afters;
            const index = list.indexOf(snippet);
            if (0 <= index) {
                list.splice(index, 1);
                if ("parent" in snippet) {
                    snippet.parent = null;
                }
            }
        }
        render(renderer, phase) {
            if (this._renderable) {
                const list = phase ? this._befores : this._afters;
                for (let i = 0, imax = list.length; i < imax; ++i) {
                    list[i].render(renderer);
                }
            }
        }
        updateTransform() {
            const befores = this._befores;
            for (let i = 0, imax = befores.length; i < imax; ++i) {
                befores[i].updateTransform();
            }
            const afters = this._afters;
            for (let i = 0, imax = afters.length; i < imax; ++i) {
                afters[i].updateTransform();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseReflowableContainer {
        constructor() {
            this._list = [];
        }
        add(reflowable) {
            this._list.push(reflowable);
        }
        remove(reflowable) {
            const list = this._list;
            const index = list.indexOf(reflowable);
            if (0 <= index) {
                list.splice(index, 1);
            }
        }
        onReflow(base, width, height) {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].onReflow(base, width, height);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toTheme = (options) => {
        const theme = options === null || options === void 0 ? void 0 : options.theme;
        if (theme) {
            if (isString(theme)) {
                return DThemes.getInstance().get(theme);
            }
            return theme;
        }
    };
    const toShortcuts = (options) => {
        if (options) {
            const shortcut = options.shortcut;
            const shortcuts = options.shortcuts;
            if (shortcuts != null || shortcut != null) {
                const result = [];
                if (shortcut != null) {
                    result.push(UtilKeyboardEvent.toShortcut(shortcut));
                }
                if (shortcuts != null) {
                    for (let i = 0, imax = shortcuts.length; i < imax; ++i) {
                        result.push(UtilKeyboardEvent.toShortcut(shortcuts[i]));
                    }
                }
                return result;
            }
        }
        return undefined;
    };
    /**
     * A base class for UI classes.
     * See {@link DBaseEvents} for event details.
     */
    class DBase extends pixi_js.Container {
        constructor(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            super();
            // Transform
            const transform = this.transform;
            this._position = new DBasePoint(transform.position, (newX, newY, oldX, oldY) => {
                this.onMove(newX, newY, oldX, oldY);
            });
            this._scale = new DBasePoint(transform.scale, (newX, newY, oldX, oldY) => {
                this.onScale(newX, newY, oldX, oldY);
            });
            this._skew = new DBasePoint(transform.skew, (newX, newY, oldX, oldY) => {
                this.onSkew(newX, newY, oldX, oldY);
            });
            //
            this._options = options;
            const scalarSet = (this._scalarSet = {});
            this._auto = new DBaseAutoSet();
            this._isDirty = true;
            this._hasDirty = false;
            this._isHierarchyDirty = false;
            this._shadow = null;
            this.name = (_a = options === null || options === void 0 ? void 0 : options.name) !== null && _a !== void 0 ? _a : "";
            const theme = toTheme(options) || this.getThemeDefault();
            this._theme = theme;
            this._snippet = new DBaseSnippetContainer(this);
            this._reflowable = new DBaseReflowableContainer();
            this._clearType = toEnum((_b = options === null || options === void 0 ? void 0 : options.clear) !== null && _b !== void 0 ? _b : theme.getClearType(), DLayoutClearType);
            this._padding = this.newPadding(theme, options, () => {
                this.toDirty();
                this.toParentResized();
                this.toHierarchyDirty();
                DApplications.update(this);
            });
            const toDirtyAndUpdate = () => {
                this.toDirty();
                DApplications.update(this);
            };
            this._background = new DBaseBackground(theme, options, toDirtyAndUpdate);
            this._border = new DBaseBorder(theme, options, toDirtyAndUpdate);
            this._outline = new DBaseOutline(theme, options, toDirtyAndUpdate);
            this._corner = new DBaseCorner(theme, options, toDirtyAndUpdate);
            // X
            const position = transform.position;
            const x = (_c = options === null || options === void 0 ? void 0 : options.x) !== null && _c !== void 0 ? _c : theme.getX();
            if (isNumber(x)) {
                position.x = x;
            }
            else {
                position.x = 0;
                scalarSet.x = DScalarFunctions.position(x);
            }
            // Y
            const y = (_d = options === null || options === void 0 ? void 0 : options.y) !== null && _d !== void 0 ? _d : theme.getY();
            if (isNumber(y)) {
                position.y = y;
            }
            else {
                position.y = 0;
                scalarSet.y = DScalarFunctions.position(y);
            }
            // Width
            const width = (_e = options === null || options === void 0 ? void 0 : options.width) !== null && _e !== void 0 ? _e : theme.getWidth();
            if (!this._auto.width.from(width)) {
                if (isNumber(width)) {
                    this._width = width;
                }
                else {
                    this._width = 100;
                    scalarSet.width = DScalarFunctions.size(width);
                }
            }
            else {
                this._width = 100;
            }
            // Height
            const height = (_f = options === null || options === void 0 ? void 0 : options.height) !== null && _f !== void 0 ? _f : theme.getHeight();
            if (!this._auto.height.from(height)) {
                if (isNumber(height)) {
                    this._height = height;
                }
                else {
                    this._height = 100;
                    scalarSet.height = DScalarFunctions.size(height);
                }
            }
            else {
                this._height = 100;
            }
            // Visibility
            if (options != null) {
                const visible = options.visible;
                if (visible != null) {
                    this.visible = visible;
                }
            }
            // Renderability
            if (options != null) {
                const renderable = options.renderable;
                if (renderable != null) {
                    this.renderable = renderable;
                }
            }
            // State
            this._state = new DBaseStateSetImplObservable((newState, oldState) => {
                this.onStateChange(newState, oldState);
            });
            // Interactive
            const interactive = toEnum((_g = options === null || options === void 0 ? void 0 : options.interactive) !== null && _g !== void 0 ? _g : theme.getInteractive(), DBaseInteractive);
            this.interactive = !!(interactive & DBaseInteractive.SELF);
            this.interactiveChildren = !!(interactive & DBaseInteractive.CHILDREN);
            // Events
            if (options != null) {
                const on = options.on;
                if (on != null) {
                    for (const name in on) {
                        const handler = on[name];
                        if (handler) {
                            this.on(name, handler);
                        }
                    }
                }
            }
            // Title
            this._title = (_h = options === null || options === void 0 ? void 0 : options.title) !== null && _h !== void 0 ? _h : theme.getTitle();
            // Weight
            this._weight = (_j = options === null || options === void 0 ? void 0 : options.weight) !== null && _j !== void 0 ? _j : theme.getWeight();
            // Reflowable
            this.initReflowable();
            // Shadow
            this._onShadowUpdateBound = () => {
                DApplications.update(this);
            };
            let shadow;
            if (options != null) {
                shadow = options.shadow;
            }
            if (shadow === undefined) {
                shadow = theme.getShadow();
            }
            if (shadow) {
                if (isString(shadow)) {
                    switch (shadow) {
                        case "WEAK":
                            this.shadow = theme.newShadowWeak();
                            break;
                        case "DEFAULT":
                            this.shadow = theme.newShadow();
                            break;
                    }
                }
                else {
                    this.shadow = shadow;
                }
            }
            // Event handlers
            this.on(UtilPointerEvent.over, (e) => {
                this.onOver(e);
            });
            this.on(UtilPointerEvent.out, (e) => {
                this.onOut(e);
            });
            this.on(UtilPointerEvent.down, (e) => {
                this.onDown(e);
            });
            this.on(UtilPointerEvent.up, (e) => {
                this.onUp(e);
            });
            // Children change detection
            this.on("added", () => {
                this.toParentResized();
                if (this.isDirty() || this.hasDirty()) {
                    this.toParentHasDirty();
                }
                if (this._isHierarchyDirty) {
                    this.toParentHierarchyDirty();
                }
                const newParent = this.parent;
                if (newParent instanceof DBase) {
                    this.state.parent = newParent.state;
                }
                DApplications.update(this);
            });
            this.on("removed", () => {
                this.blur(true);
                this.state.parent = null;
                DApplications.update(this);
            });
            // Shortcut
            const shortcuts = toShortcuts(options);
            this._shortcuts = shortcuts;
            if (shortcuts != null) {
                const onShortcutBound = (e) => {
                    this.onShortcut(e);
                };
                for (let i = 0, imax = shortcuts.length; i < imax; ++i) {
                    UtilKeyboardEvent.on(this, shortcuts[i], onShortcutBound);
                }
            }
            // Other initialization
            this.init(options);
            // State Override
            theme.newState(this._state);
            if (options != null) {
                const state = options.state;
                if (state != null) {
                    const s = this._state;
                    if (isString(state)) {
                        s.add(state);
                    }
                    else if (isArray(state)) {
                        s.addAll(state);
                    }
                    else {
                        // Values
                        const values = state.values;
                        if (values != null) {
                            if (isString(values)) {
                                s.add(values);
                            }
                            else {
                                s.addAll(values);
                            }
                        }
                        // Blinker
                        const blinkers = state.blinkers;
                        if (blinkers != null) {
                            const b = s.blinker;
                            for (let i = 0, imax = blinkers.length; i < imax; ++i) {
                                const blinker = blinkers[i];
                                b.add(blinker.state, blinker.interval);
                            }
                        }
                        // Ticker
                        const tickers = state.tickers;
                        if (tickers != null) {
                            const t = s.ticker;
                            for (let i = 0, imax = tickers.length; i < imax; ++i) {
                                const ticker = tickers[i];
                                t.add(ticker.state, ticker.interval);
                            }
                        }
                    }
                }
            }
            // Parent
            if (options != null) {
                const parent = options.parent;
                if (parent != null) {
                    parent.addChild(this);
                }
            }
            // Children
            if (options != null) {
                const children = options.children;
                if (children != null) {
                    for (let i = 0, imax = children.length; i < imax; ++i) {
                        const child = children[i];
                        if (child != null) {
                            this.addChild(child);
                        }
                    }
                }
            }
            // Cursor
            let cursor;
            if (options != null) {
                cursor = options.cursor;
                this._cursor = cursor;
            }
            this.cursor = this.toCursor(cursor, this._state);
            // Done
            this.emit("init", this);
        }
        newPadding(theme, options, callback) {
            return new DBasePadding(theme, options, callback);
        }
        toCursor(cursor, state) {
            if (cursor) {
                if (isFunction(cursor)) {
                    const result = cursor(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else if (cursor !== undefined) {
                    return cursor;
                }
            }
            return this.theme.getCursor(state);
        }
        get snippet() {
            return this._snippet;
        }
        get reflowable() {
            return this._reflowable;
        }
        initReflowable() {
            new DBaseReflowableImpl(this);
        }
        onChildrenChange() {
            this.toHierarchyDirty();
            super.onChildrenChange();
        }
        onShortcut(e) {
            this.emit("shortcut", e, this);
        }
        init(options) {
            // OTHER INITIALIZATIONS BEFORE `parent.addChild( this )`
        }
        get weight() {
            return this._weight;
        }
        set weight(weight) {
            if (this._weight !== weight) {
                this._weight = weight;
                this.toHierarchyDirty();
                DApplications.update(this);
            }
        }
        onMove(newX, newY, oldX, oldY) {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child instanceof DBase) {
                    child.onParentMove(newX, newY, oldX, oldY);
                }
            }
            DApplications.update(this);
            this.emit("move", newX, newY, oldX, oldY, this);
        }
        resize(width, height) {
            const oldWidth = this._width;
            const oldHeight = this._height;
            const newWidth = width != null ? width : oldWidth;
            const newHeight = height != null ? height : oldHeight;
            const isWidthChanged = oldWidth !== newWidth;
            const isHeightChanged = oldHeight !== newHeight;
            if (isWidthChanged) {
                this._width = newWidth;
            }
            if (isHeightChanged) {
                this._height = newHeight;
            }
            const isChanged = isWidthChanged || isHeightChanged;
            if (isChanged) {
                this.onResize(newWidth, newHeight, oldWidth, oldHeight);
            }
            if (isWidthChanged) {
                const scalarSet = this._scalarSet;
                if (scalarSet.x != null) {
                    const position = this._position;
                    const parent = this.getParentOfSize();
                    if (parent) {
                        this._position.x = scalarSet.x(parent.width, newWidth, parent.padding.getLeft(), position.x);
                    }
                }
            }
            if (isHeightChanged) {
                const scalarSet = this._scalarSet;
                if (scalarSet.y != null) {
                    const position = this._position;
                    const parent = this.getParentOfSize();
                    if (parent) {
                        this._position.y = scalarSet.y(parent.height, newHeight, parent.padding.getTop(), position.y);
                    }
                }
            }
            return isChanged;
        }
        getClearType() {
            return this._clearType;
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            this.toDirty();
            this.toHierarchyDirty();
            const padding = this._padding;
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(newWidth, newHeight, padding);
                }
            }
            DApplications.update(this);
            this.emit("resize", newWidth, newHeight, oldWidth, oldHeight, this);
        }
        onScale(newX, newY, oldX, oldY) {
            DApplications.update(this);
            this.emit("scale", newX, newY, oldX, oldY, this);
        }
        onSkew(newX, newY, oldX, oldY) {
            DApplications.update(this);
            this.emit("skew", newX, newY, oldX, oldY, this);
        }
        get type() {
            return this.getType();
        }
        // @ts-ignore
        get x() {
            return this._position.x;
        }
        set x(x) {
            this.setX(x);
        }
        getX() {
            const scalarSet = this._scalarSet;
            if (scalarSet.x != null) {
                return scalarSet.x;
            }
            else {
                return this._position.x;
            }
        }
        setX(x) {
            const scalarSet = this._scalarSet;
            if (isNumber(x)) {
                const position = this._position;
                if (position.x !== x) {
                    scalarSet.x = undefined;
                    position.x = x;
                }
                else {
                    if (scalarSet.x !== undefined) {
                        scalarSet.x = undefined;
                        this.toParentResized();
                    }
                }
            }
            else {
                const scalar = DScalarFunctions.position(x);
                if (scalarSet.x !== scalar) {
                    scalarSet.x = scalar;
                    this.toParentResized();
                }
            }
        }
        // @ts-ignore
        get y() {
            return this._position.y;
        }
        set y(y) {
            this.setY(y);
        }
        getY() {
            const scalarSet = this._scalarSet;
            if (scalarSet.y != null) {
                return scalarSet.y;
            }
            else {
                return this._position.y;
            }
        }
        setY(y) {
            const scalarSet = this._scalarSet;
            if (isNumber(y)) {
                const position = this._position;
                if (position.y !== y) {
                    scalarSet.y = undefined;
                    position.y = y;
                }
                else {
                    if (scalarSet.y !== undefined) {
                        scalarSet.y = undefined;
                        this.toParentResized();
                    }
                }
            }
            else {
                const scalar = DScalarFunctions.position(y);
                if (scalarSet.y !== scalar) {
                    scalarSet.y = scalar;
                    this.toParentResized();
                }
            }
        }
        // @ts-ignore
        get width() {
            return this._width;
        }
        set width(width) {
            this.setWidth(width);
        }
        getWidth() {
            return this._auto.width.toCoordinate(this._scalarSet.width || this._width);
        }
        setWidth(width) {
            const auto = this._auto.width;
            const isOn = auto.isOn;
            const isAuto = auto.from(width);
            if (auto.isOn !== isOn) {
                this.toHierarchyDirty();
                DApplications.update(this);
            }
            if (!isAuto) {
                const scalarSet = this._scalarSet;
                if (isNumber(width)) {
                    const oldWidth = this._width;
                    if (oldWidth !== width) {
                        scalarSet.width = undefined;
                        this._width = width;
                        const height = this._height;
                        this.onResize(width, height, oldWidth, height);
                        if (scalarSet.x != null) {
                            const position = this._position;
                            const parent = this.getParentOfSize();
                            if (parent) {
                                position.x = scalarSet.x(parent.width, width, parent.padding.getLeft(), position.x);
                            }
                        }
                    }
                    else {
                        if (scalarSet.width !== undefined) {
                            scalarSet.width = undefined;
                            this.toParentResized();
                        }
                    }
                }
                else {
                    const scalar = DScalarFunctions.size(width);
                    if (scalarSet.width !== scalar) {
                        scalarSet.width = scalar;
                        this.toParentResized();
                    }
                }
            }
        }
        // @ts-ignore
        get height() {
            return this._height;
        }
        set height(height) {
            this.setHeight(height);
        }
        getHeight() {
            return this._auto.height.toCoordinate(this._scalarSet.height || this._height);
        }
        setHeight(height) {
            const auto = this._auto.height;
            const isOn = auto.isOn;
            const isAuto = auto.from(height);
            if (auto.isOn !== isOn) {
                this.toHierarchyDirty();
                DApplications.update(this);
            }
            if (!isAuto) {
                const scalarSet = this._scalarSet;
                if (isNumber(height)) {
                    const oldHeight = this._height;
                    if (oldHeight !== height) {
                        scalarSet.height = undefined;
                        this._height = height;
                        const width = this._width;
                        this.onResize(width, height, width, oldHeight);
                        if (scalarSet.y != null) {
                            const position = this._position;
                            const parent = this.getParentOfSize();
                            if (parent) {
                                position.y = scalarSet.y(parent.height, height, parent.padding.getTop(), position.y);
                            }
                        }
                    }
                    else {
                        if (scalarSet.height !== undefined) {
                            scalarSet.height = undefined;
                            this.toParentResized();
                        }
                    }
                }
                else {
                    const scalar = DScalarFunctions.size(height);
                    if (scalarSet.height !== scalar) {
                        scalarSet.height = scalar;
                        this.toParentResized();
                    }
                }
            }
        }
        // @ts-ignore
        get position() {
            return this._position;
        }
        // @ts-ignore
        get scale() {
            return this._scale;
        }
        // @ts-ignore
        get skew() {
            return this._skew;
        }
        get padding() {
            return this._padding;
        }
        get corner() {
            return this._corner;
        }
        get background() {
            return this._background;
        }
        get border() {
            return this._border;
        }
        get outline() {
            return this._outline;
        }
        get unsafe() {
            return this.transform;
        }
        get title() {
            return this._title;
        }
        set title(title) {
            if (this._title !== title) {
                this._title = title;
                if (this.state.isHovered) {
                    this.applyTitle();
                }
            }
        }
        applyTitle() {
            const layer = DApplications.getLayer(this);
            if (layer) {
                layer.view.title = this._title;
            }
        }
        show() {
            if (!this.visible) {
                this.visible = true;
                this.toParentHierarchyDirty();
                DApplications.update(this);
            }
            return this;
        }
        isShown() {
            return this.visible;
        }
        hide() {
            if (this.visible) {
                this.visible = false;
                this.toParentHierarchyDirty();
                this.blur(true);
                DApplications.update(this);
            }
            return this;
        }
        isHidden() {
            return !this.visible;
        }
        toDirty() {
            if (!this._isDirty) {
                this._isDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        }
        toHasDirty() {
            if (!this._hasDirty) {
                this._hasDirty = true;
                this.toParentHasDirty();
                return true;
            }
            return false;
        }
        toParentHasDirty() {
            const parent = this.parent;
            if (parent instanceof DBase) {
                parent.toHasDirty();
            }
        }
        toHierarchyDirty() {
            if (!this._isHierarchyDirty) {
                this._isHierarchyDirty = true;
                this.onHierarchyDirty();
                this.toParentHierarchyDirty();
                return true;
            }
            return false;
        }
        toParentHierarchyDirty() {
            const parent = this.parent;
            if (parent instanceof DBase) {
                parent.toHierarchyDirty();
            }
        }
        isHierarchyDirty() {
            return this._isHierarchyDirty;
        }
        onHierarchyDirty() {
            // DO NOTHING
        }
        isDirty() {
            return this._isDirty;
        }
        hasDirty() {
            return this._hasDirty;
        }
        setFocused(isFocused) {
            if (this.state.isFocused !== isFocused) {
                const layer = DApplications.getLayer(this);
                if (layer) {
                    layer.getFocusController().set(this, isFocused);
                }
            }
            return this;
        }
        focus() {
            return this.setFocused(true);
        }
        blur(recursively) {
            if (recursively) {
                const layer = DApplications.getLayer(this);
                if (layer) {
                    const focusController = layer.getFocusController();
                    const focused = focusController.get();
                    if (focused instanceof DBase) {
                        let current = focused;
                        while (current) {
                            if (current === this) {
                                focused.setFocused(false);
                                break;
                            }
                            current = current.parent;
                        }
                    }
                }
            }
            else {
                this.setFocused(false);
            }
            return this;
        }
        onStateChange(newState, oldState) {
            this.toDirty();
            DApplications.update(this);
            this.emit("statechange", newState, oldState, this);
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child instanceof DBase) {
                    child.state.onParentChange(newState, oldState);
                }
            }
            if (newState.isFocused) {
                if (!oldState.isFocused) {
                    this.onFocus();
                }
                if (newState.inDisabled && !oldState.inDisabled) {
                    setTimeout(() => {
                        this.blur();
                    }, 0);
                }
            }
            else if (oldState.isFocused) {
                this.onBlur();
            }
            this.cursor = this.toCursor(this._cursor, newState);
        }
        onChildFocus(focused) {
            const parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocus(focused);
            }
        }
        onFocus() {
            const parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildFocus(this);
            }
        }
        onChildBlur(blured) {
            const parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildBlur(blured);
            }
        }
        onBlur() {
            const parent = this.parent;
            if (parent instanceof DBase) {
                parent.onChildBlur(this);
            }
        }
        get state() {
            return this._state;
        }
        get options() {
            return this._options;
        }
        get theme() {
            return this._theme;
        }
        set theme(theme) {
            const result = this._theme;
            if (result !== theme) {
                this._theme = theme;
                this._padding.setTheme(theme);
                this._background.setTheme(theme);
                this._border.setTheme(theme);
                this._outline.setTheme(theme);
                this._corner.setTheme(theme);
                this.toDirty();
                DApplications.update(this);
            }
        }
        reflow() {
            const isDirty = this._isDirty;
            if (isDirty) {
                this.onReflow();
                this._isDirty = false;
            }
            const hasDirty = this._hasDirty;
            const isHierarchyDirty = this._isHierarchyDirty;
            if (hasDirty || isHierarchyDirty) {
                this._hasDirty = false;
                this._isHierarchyDirty = false;
                const children = this.children;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                    }
                }
            }
            if (isDirty || hasDirty || isHierarchyDirty) {
                this.onRefit();
            }
        }
        onRefit() {
            const auto = this._auto;
            const isWidthAuto = auto.width.isOn;
            const isHeightAuto = auto.height.isOn;
            if (isWidthAuto && isHeightAuto) {
                let width = 0;
                let height = 0;
                const children = this.children;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    if (child.visible) {
                        const rw = this.hasRefitableWidth(child);
                        const rh = this.hasRefitableHeight(child);
                        if (rw || rh) {
                            if (child instanceof DBase) {
                                if (rw) {
                                    width = Math.max(width, child.x + child.width);
                                }
                                if (rh) {
                                    height = Math.max(height, child.y + child.height);
                                }
                            }
                            else if (child instanceof pixi_js.Container) {
                                const bound = child.getLocalBounds(undefined, true);
                                if (rw) {
                                    width = Math.max(width, child.x + bound.x + bound.width);
                                }
                                if (rh) {
                                    height = Math.max(height, child.y + bound.y + bound.height);
                                }
                            }
                            else {
                                const bound = child.getLocalBounds();
                                if (rw) {
                                    width = Math.max(width, child.x + bound.x + bound.width);
                                }
                                if (rh) {
                                    height = Math.max(height, child.y + bound.y + bound.height);
                                }
                            }
                        }
                    }
                }
                const padding = this.padding;
                this.resize(width + padding.getRight(), height + padding.getBottom());
            }
            else if (isWidthAuto) {
                let width = 0;
                const children = this.children;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    if (child.visible && this.hasRefitableWidth(child)) {
                        if (child instanceof DBase) {
                            width = Math.max(width, child.x + child.width);
                        }
                        else if (child instanceof pixi_js.Container) {
                            const bound = child.getLocalBounds(undefined, true);
                            width = Math.max(width, child.x + bound.x + bound.width);
                        }
                        else {
                            const bound = child.getLocalBounds();
                            width = Math.max(width, child.x + bound.x + bound.width);
                        }
                    }
                }
                this.resize(width + this.padding.getRight(), undefined);
            }
            else if (isHeightAuto) {
                let height = 0;
                const children = this.children;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    if (child.visible && this.hasRefitableHeight(child)) {
                        if (child instanceof DBase) {
                            height = Math.max(height, child.y + child.height);
                        }
                        else if (child instanceof pixi_js.Container) {
                            const bound = child.getLocalBounds(undefined, true);
                            height = Math.max(height, child.y + bound.y + bound.height);
                        }
                        else {
                            const bound = child.getLocalBounds();
                            height = Math.max(height, child.y + bound.y + bound.height);
                        }
                    }
                }
                this.resize(undefined, height + this.padding.getBottom());
            }
        }
        isRefitable(target) {
            return target instanceof DBase;
        }
        /**
         * Returns true if the given target has a height that doesn't depend on its parent height.
         *
         * @param target a target
         * @returns true if the given target has a height that doesn't depend on its parent height.
         */
        hasRefitableHeight(target) {
            return (this.isRefitable(target) && !(target instanceof DBase && isFunction(target.getHeight())));
        }
        /**
         * Returns true if the given target has a width that doesn't depend on its parent width.
         *
         * @param target a target
         * @returns true if the given target has a width that doesn't depend on its parent width.
         */
        hasRefitableWidth(target) {
            return (this.isRefitable(target) && !(target instanceof DBase && isFunction(target.getWidth())));
        }
        onReflow() {
            this._reflowable.onReflow(this, this._width, this._height);
        }
        get shadow() {
            return this._shadow;
        }
        set shadow(shadow) {
            const previous = this._shadow;
            if (previous !== shadow) {
                const reflowable = this._reflowable;
                const snippet = this._snippet;
                const onShadowUpdateBound = this._onShadowUpdateBound;
                if (previous != null) {
                    previous.off("update", onShadowUpdateBound);
                    reflowable.remove(previous);
                    snippet.remove(previous, true);
                }
                this._shadow = shadow;
                if (shadow != null) {
                    shadow.on("update", onShadowUpdateBound);
                    reflowable.add(shadow);
                    snippet.addAt(shadow, true, 0);
                }
                DApplications.update(this);
            }
        }
        toParentResized() {
            const parent = this.getParentOfSize();
            if (parent) {
                this.onParentResize(parent.width, parent.height, parent.padding);
            }
        }
        getParentOfSize() {
            const parent = this.parent;
            if (parent instanceof DBase) {
                return parent;
            }
            else {
                return DApplications.getLayer(this);
            }
        }
        /**
         * Called when a parent resized.
         *
         * @param parentWidth a parent's local width
         * @param parentHeight a parent's local height
         */
        onParentResize(parentWidth, parentHeight, parentPadding) {
            const scalarSet = this._scalarSet;
            const position = this.transform.position;
            const x = position.x;
            const y = position.y;
            const width = this._width;
            const height = this._height;
            // Width & height
            const paddingWidth = parentPadding.getLeft() + parentPadding.getRight();
            const paddingHeight = parentPadding.getTop() + parentPadding.getBottom();
            const newWidth = scalarSet.width != null
                ? scalarSet.width(parentWidth, width, paddingWidth, width)
                : width;
            const newHeight = scalarSet.height != null
                ? scalarSet.height(parentHeight, height, paddingHeight, height)
                : height;
            this.resize(newWidth, newHeight);
            // X & Y
            const newX = scalarSet.x != null
                ? scalarSet.x(parentWidth, this._width, parentPadding.getLeft(), x)
                : x;
            const newY = scalarSet.y != null
                ? scalarSet.y(parentHeight, this._height, parentPadding.getTop(), y)
                : y;
            this.position.set(newX, newY);
        }
        /**
         * Called when a parent moved.
         *
         * @param newX a new parent's local x position
         * @param newY a new parent's local y position
         * @param oldX an old parent's local x position
         * @param oldY an old parent's local y position
         */
        onParentMove(newX, newY, oldX, oldY) {
            // DO NOTHING
        }
        // Wheel
        onWheel(e, deltas, global) {
            this.emit("wheel", e, deltas, global, this);
            return false;
        }
        // Keydown
        onKeyDown(e) {
            this.emit("keydown", e, this);
            return false;
        }
        onKeyUp(e) {
            this.emit("keyup", e, this);
            return false;
        }
        // Down
        isEventTarget(e) {
            const target = e.target;
            if (target === this) {
                return true;
            }
            else if (target != null && !(target instanceof DBase && target.interactive)) {
                let parent = target.parent;
                while (parent != null && !(parent instanceof DBase && parent.interactive)) {
                    parent = parent.parent;
                }
                return parent === this;
            }
            return false;
        }
        onDown(e) {
            if (this.isEventTarget(e)) {
                this.onDownThis(e);
            }
            this.emit("down", e, this);
        }
        onDownThis(e) {
            var _a;
            const oe = e.data.originalEvent;
            if ("touches" in oe) {
                const lastDownPoint = ((_a = this._lastDownPoint) !== null && _a !== void 0 ? _a : (this._lastDownPoint = new pixi_js.Point()));
                lastDownPoint.copyFrom(e.data.global);
            }
            else {
                this.focusOnClosest();
            }
        }
        onUp(e) {
            if (this.isEventTarget(e)) {
                this.onUpThis(e);
            }
            this.emit("up", e, this);
        }
        onUpThis(e) {
            const oe = e.data.originalEvent;
            if ("touches" in oe) {
                const lastDownPoint = this._lastDownPoint;
                if (lastDownPoint) {
                    const global = e.data.global;
                    const dx = Math.abs(global.x - lastDownPoint.x);
                    const dy = Math.abs(global.y - lastDownPoint.y);
                    const threshold = UtilPointerEvent.CLICK_DISTANCE_THRESHOLD;
                    if (dx < threshold && dy < threshold) {
                        this.focusOnClosest();
                    }
                }
            }
        }
        focusOnClosest() {
            const layer = DApplications.getLayer(this);
            if (layer) {
                const focusController = layer.getFocusController();
                focusController.focus(focusController.findParent(this));
            }
        }
        // Over
        onOver(e) {
            // Update the hover state
            this.state.isHovered = true;
            // Update the title
            if (e.target === this) {
                this.applyTitle();
            }
            // Event
            this.emit("over", e, this);
        }
        // Out
        onOut(e) {
            // Update the hover state
            this.state.isHovered = false;
            // Event
            this.emit("out", e, this);
        }
        // Double click
        onDblClick(e, interactionManager) {
            this.emit("dblclick", e, interactionManager, this);
            return false;
        }
        //
        render(renderer) {
            if (this.visible && 0 < this.worldAlpha && this.renderable) {
                const snippet = this._snippet;
                snippet.render(renderer, true);
                super.render(renderer);
                snippet.render(renderer, false);
            }
        }
        updateTransform() {
            super.updateTransform();
            this._snippet.updateTransform();
        }
        //
        getThemeDefault() {
            return DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "DBase";
        }
        //
        _calculateBounds() {
            this._bounds.addFrame(this.transform, 0, 0, this._width, this._height);
            super._calculateBounds();
        }
        containsPoint(point) {
            return (this.containsGlobalPoint(point) ||
                this.containsLocalPoint(this.worldTransform.applyInverse(point, DBase.WORK_CONTAINS_POINT)));
        }
        containsGlobalPoint(point) {
            return false;
        }
        containsLocalPoint(point) {
            const x = point.x;
            const y = point.y;
            const w = this._width;
            const h = this._height;
            return 0 <= x && x <= w && 0 <= y && y <= h;
        }
        /**
         * Returns a clipping rect.
         *
         * @param result a clipping rect
         */
        getClippingRect(target, result) {
            result.x = 0;
            result.y = 0;
            result.width = this._width;
            result.height = this._height;
        }
        destroy() {
            // Layout
            const scalarSet = this._scalarSet;
            scalarSet.x = null;
            scalarSet.y = null;
            scalarSet.width = null;
            scalarSet.height = null;
            // Shadow
            const shadow = this._shadow;
            if (shadow) {
                this._shadow = null;
                shadow.destroy();
            }
            // Children
            const children = this.children;
            for (let i = children.length - 1; 0 <= i; --i) {
                children[i].destroy();
            }
            children.length = 0;
            //
            super.destroy();
        }
    }
    DBase.WORK_CONTAINS_POINT = new pixi_js.Point();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseOverflowMask extends pixi_js.Graphics {
        constructor(parent) {
            super();
            this.parent = parent;
            this._isInitialized = false;
            this._width = 0;
            this._height = 0;
            this._cornderRadius = 0;
            this._cornerMask = DCornerMask.NONE;
        }
        render(renderer) {
            this.updateTransform();
            super.render(renderer);
        }
        onReflow(base, width, height) {
            const corner = base.corner;
            const cornerRadius = Math.max(0, corner.getRadius() - 0.5);
            const cornerMask = corner.getMask();
            if (this._isInitialized &&
                this._width === width &&
                this._height === height &&
                this._cornderRadius === cornerRadius &&
                this._cornerMask === cornerMask) {
                return;
            }
            this._isInitialized = true;
            this._width = width;
            this._height = height;
            this._cornderRadius = cornerRadius;
            this._cornerMask = cornerMask;
            const x = 0;
            const y = 0;
            const tl = cornerMask & DCornerMask.TOP_LEFT ? 0 : cornerRadius;
            const tr = cornerMask & DCornerMask.TOP_RIGHT ? 0 : cornerRadius;
            const bl = cornerMask & DCornerMask.BOTTOM_LEFT ? 0 : cornerRadius;
            const br = cornerMask & DCornerMask.BOTTOM_RIGHT ? 0 : cornerRadius;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.lineStyle(0, 0, 0, 0, false);
            if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
                this.drawRect(x, y, width, height);
            }
            else {
                this.moveTo(x + tl, y);
                if (0 < tr) {
                    this.arcTo(x + width, y, x + width, y + height, tr);
                }
                else {
                    this.lineTo(x + width, y);
                }
                if (0 < br) {
                    this.arcTo(x + width, y + height, x, y + height, br);
                }
                else {
                    this.lineTo(x + width, y + height);
                }
                if (0 < bl) {
                    this.arcTo(x, y + height, x, y, bl);
                }
                else {
                    this.lineTo(x, y + height);
                }
                if (0 < tl) {
                    this.arcTo(x, y, x + width, y, tl);
                }
                else {
                    this.lineTo(x, y);
                }
            }
            this.endFill();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const UtilGestureMode = {
        OFF: 0,
        ON: 1,
        TOUCH: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DViewGestureImpl {
        constructor(owner, toTarget, parent, constraint, theme, options) {
            var _a, _b;
            this._owner = owner;
            this._parent = parent;
            this._constraint = constraint;
            const mode = toEnum((_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : theme.getGestureMode(), UtilGestureMode);
            const modifier = toEnum((_b = options === null || options === void 0 ? void 0 : options.modifier) !== null && _b !== void 0 ? _b : theme.getGestureModifier(), UtilGestureModifier);
            if (mode === UtilGestureMode.ON || mode === UtilGestureMode.TOUCH) {
                const work = new pixi_js.Point();
                this._gestureUtil = new UtilGesture({
                    touch: mode === UtilGestureMode.TOUCH,
                    modifier,
                    checker: options && options.checker,
                    easing: {
                        duration: options === null || options === void 0 ? void 0 : options.duration
                    },
                    on: {
                        start: (target) => {
                            this.onStart(target);
                        },
                        move: (target, dx, dy, x, y, ds) => {
                            this.onGestureMove(toTarget(owner), dx, dy, x, y, ds, work);
                        },
                        easing: {
                            end: (target) => {
                                this.onEnd(target);
                            }
                        },
                        stop: (target) => {
                            this.onStop(target);
                        },
                        tap: (target, e) => {
                            this.onTap(target, e);
                        },
                        longpress: (target, e) => {
                            this.onLongPress(target, e);
                        }
                    }
                });
            }
        }
        onStart(target) {
            const parent = this._parent;
            parent.stop();
            parent.emit("gesturestart", target, parent);
        }
        onEnd(target) {
            const parent = this._parent;
            parent.emit("gestureend", target, parent);
        }
        onStop(target) {
            const parent = this._parent;
            parent.emit("gesturestop", target, parent);
        }
        onTap(target, e) {
            const parent = this._parent;
            parent.emit("gesturetap", target, e, parent);
        }
        onLongPress(target, e) {
            const parent = this._parent;
            parent.emit("gesturelongpress", target, e, parent);
        }
        onGestureMove(target, dx, dy, x, y, ds, work) {
            if (target != null) {
                // Scale
                const parent = this._parent;
                const oldScale = target.scale;
                const oldScaleX = oldScale.x;
                const oldScaleY = oldScale.y;
                let newScaleX = parent.toNormalizedScale(oldScaleX * ds);
                let newScaleY = parent.toNormalizedScale(oldScaleY * ds);
                const scaleRatioX = newScaleX / oldScaleX;
                const scaleRatioY = newScaleY / oldScaleY;
                const scaleRatio = ds < 1 ? Math.max(scaleRatioX, scaleRatioY) : Math.min(scaleRatioX, scaleRatioY);
                newScaleX = scaleRatio * oldScaleX;
                newScaleY = scaleRatio * oldScaleY;
                // Position
                const targetParent = target.parent;
                if (targetParent != null) {
                    targetParent.toLocal(work.set(x, y), undefined, work);
                    x = work.x;
                    y = work.y;
                }
                const cx = x - dx;
                const cy = y - dy;
                const position = target.position;
                const newX = (position.x - cx) * scaleRatio + x;
                const newY = (position.y - cy) * scaleRatio + y;
                // Update
                this._constraint(target, newX, newY, newScaleX, newScaleY);
            }
        }
        stop() {
            var _a;
            (_a = this._gestureUtil) === null || _a === void 0 ? void 0 : _a.stop(this._owner);
        }
        onDown(e) {
            var _a;
            (_a = this._gestureUtil) === null || _a === void 0 ? void 0 : _a.onDown(this._owner, e);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DViewTransformImpl {
        constructor(owner, toTarget, parent, constraint, duration) {
            this._owner = owner;
            this._toTarget = toTarget;
            this._constraint = constraint;
            this._newScaleX = 1;
            this._newScaleY = 1;
            this._newX = 0;
            this._newY = 0;
            this._oldScaleX = 1;
            this._oldScaleY = 1;
            this._oldX = 0;
            this._oldY = 0;
            this._isStarted = false;
            this._animation = new DAnimationBase({
                onStart: () => {
                    this.onStart();
                },
                onTime: (time) => {
                    this.onTime(time);
                },
                onEnd: () => {
                    this.onEnd();
                },
                onStop: () => {
                    this.onStop();
                },
                duration
            });
            this._parent = parent;
            this._duration = duration;
        }
        onStart() {
            const parent = this._parent;
            parent.emit("transformstart", this._owner, parent);
        }
        onTime(time) {
            const w0 = 1 - time;
            const w1 = time;
            const scaleX = this._oldScaleX * w0 + this._newScaleX * w1;
            const scaleY = this._oldScaleY * w0 + this._newScaleY * w1;
            const x = this._oldX * w0 + this._newX * w1;
            const y = this._oldY * w0 + this._newY * w1;
            const target = this._toTarget(this._owner);
            if (target != null) {
                this._constraint(target, x, y, scaleX, scaleY);
            }
        }
        onEnd() {
            const parent = this._parent;
            parent.emit("transformend", this._owner, parent);
        }
        onStop() {
            const parent = this._parent;
            parent.emit("transformstop", this._owner, parent);
        }
        start(target, x, y, scaleX, scaleY, duration, stop) {
            const parent = this._parent;
            if (stop !== false) {
                parent.stop();
            }
            if (duration == null) {
                duration = this._duration;
            }
            if (duration <= 0) {
                this.onStart();
                this._constraint(target, x, y, scaleX, scaleY);
                this.onEnd();
            }
            else {
                const position = target.position;
                const scale = target.scale;
                this._oldX = position.x;
                this._oldY = position.y;
                this._oldScaleX = scale.x;
                this._oldScaleY = scale.y;
                this._newX = x;
                this._newY = y;
                this._newScaleX = scaleX;
                this._newScaleY = scaleY;
                this._animation.duration = duration;
                this._animation.start();
            }
        }
        stop() {
            this._animation.stop();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DViewImpl extends pixi_js.utils.EventEmitter {
        constructor(parent, toTarget, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
            super();
            this._parent = parent;
            this._toTarget = toTarget;
            this._constraint = (options && options.constraint) || DViewImpl.CONSTRAINT;
            this._workRect = new pixi_js.Rectangle();
            // Theme
            const theme = this.toTheme(options) || this.getThemeDefault();
            // Zoom
            const zoom = options === null || options === void 0 ? void 0 : options.zoom;
            this._zoomPoint = new pixi_js.Point();
            this._zoomMin = (_a = zoom === null || zoom === void 0 ? void 0 : zoom.min) !== null && _a !== void 0 ? _a : theme.getZoomMin();
            this._zoomMax = (_b = zoom === null || zoom === void 0 ? void 0 : zoom.max) !== null && _b !== void 0 ? _b : theme.getZoomMax();
            this._zoomKeepRatio = (_c = zoom === null || zoom === void 0 ? void 0 : zoom.keepRatio) !== null && _c !== void 0 ? _c : theme.getZoomKeepRatio();
            // Zoom: Wheel
            const wheelZoom = zoom === null || zoom === void 0 ? void 0 : zoom.wheel;
            this._isWheelZoomEnabled = (_d = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.enable) !== null && _d !== void 0 ? _d : theme.isWheelZoomEnabled();
            this._wheelZoomSpeed = (_e = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.speed) !== null && _e !== void 0 ? _e : theme.getWheelZoomSpeed();
            this._wheelZoomModifier = toEnum((_f = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.modifier) !== null && _f !== void 0 ? _f : theme.getWheelZoomModifier(), UtilGestureModifier);
            this._wheelZoomChecker = (_g = wheelZoom === null || wheelZoom === void 0 ? void 0 : wheelZoom.checker) !== null && _g !== void 0 ? _g : UtilGestureModifiers.match;
            // Zoom: Dbl click
            const dblClickZoom = zoom === null || zoom === void 0 ? void 0 : zoom.dblclick;
            this._isDblClickZoomEnabled = (_h = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.enable) !== null && _h !== void 0 ? _h : theme.isDblClickZoomEnabled();
            this._dblClickZoomSpeed = (_j = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.amount) !== null && _j !== void 0 ? _j : theme.getDblClickZoomSpeed();
            this._dblClickZoomModifier = toEnum((_k = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.modifier) !== null && _k !== void 0 ? _k : theme.getDblClickZoomModifier(), UtilGestureModifier);
            this._dblClickZoomChecker = (_l = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.checker) !== null && _l !== void 0 ? _l : UtilGestureModifiers.match;
            this._dblclickZoomDuration = (_m = dblClickZoom === null || dblClickZoom === void 0 ? void 0 : dblClickZoom.duration) !== null && _m !== void 0 ? _m : theme.getDblClickZoomDuration();
            // Translation: Wheel
            const wheelTranslation = (_o = options === null || options === void 0 ? void 0 : options.translation) === null || _o === void 0 ? void 0 : _o.wheel;
            this._isWheelTranslationEnabled =
                (_p = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.enable) !== null && _p !== void 0 ? _p : theme.isWheelTranslationEnabled();
            this._wheelTranslationSpeed = (_q = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.speed) !== null && _q !== void 0 ? _q : theme.getWheelTranslationSpeed();
            this._wheelTranslationModifier = toEnum((_r = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.modifier) !== null && _r !== void 0 ? _r : theme.getWheelTranslationModifier(), UtilGestureModifier);
            this._wheelTranslationChecker = (_s = wheelTranslation === null || wheelTranslation === void 0 ? void 0 : wheelTranslation.checker) !== null && _s !== void 0 ? _s : UtilGestureModifiers.match;
            // Gesture
            this._gesture = new DViewGestureImpl(parent, toTarget, this, this._constraint, theme, options === null || options === void 0 ? void 0 : options.gesture);
            // Transform
            this._transform = new DViewTransformImpl(parent, toTarget, this, this._constraint, this._dblclickZoomDuration);
            // Events
            if (options != null) {
                const on = options.on;
                if (on != null) {
                    for (const name in on) {
                        const handler = on[name];
                        if (handler) {
                            this.on(name, handler);
                        }
                    }
                }
            }
        }
        get gesture() {
            return this._gesture;
        }
        stop() {
            this._gesture.stop();
            this._transform.stop();
        }
        reset(duration, stop) {
            const parent = this._parent;
            const target = this._toTarget(parent);
            if (target) {
                const padding = parent.padding;
                const pl = padding.getLeft();
                const pt = padding.getTop();
                const pr = padding.getRight();
                const pb = padding.getBottom();
                const w = parent.width;
                const h = parent.height;
                const sw = w - pl - pr;
                const sh = h - pt - pb;
                const trect = target.getLocalBounds(this._workRect);
                const tx = trect.x;
                const ty = trect.y;
                const tw = trect.width;
                const th = trect.height;
                const ntx = pl + (sw - tw) * 0.5 - tx;
                const nty = pt + (sh - th) * 0.5 - ty;
                this._transform.start(target, ntx, nty, 1, 1, duration, stop);
            }
        }
        fit(duration, stop) {
            const parent = this._parent;
            const target = this._toTarget(parent);
            if (target) {
                const padding = parent.padding;
                const pl = padding.getLeft();
                const pt = padding.getTop();
                const pr = padding.getRight();
                const pb = padding.getBottom();
                const w = parent.width;
                const h = parent.height;
                const sw = w - pl - pr;
                const sh = h - pt - pb;
                const trect = target.getLocalBounds(this._workRect);
                const tx = trect.x;
                const ty = trect.y;
                const tw = trect.width;
                const th = trect.height;
                let ntsx = sw / tw;
                let ntsy = sh / th;
                if (this._zoomKeepRatio) {
                    const nts = this.toNormalizedScale(Math.min(ntsx, ntsy));
                    ntsx = nts;
                    ntsy = nts;
                }
                else {
                    ntsx = this.toNormalizedScale(ntsx);
                    ntsy = this.toNormalizedScale(ntsy);
                }
                const ntx = pl + (sw - tw * ntsx) * 0.5 - tx * ntsx;
                const nty = pt + (sh - th * ntsy) * 0.5 - ty * ntsy;
                this._transform.start(target, ntx, nty, ntsx, ntsy, duration, stop);
            }
        }
        zoomIn(duration, stop) {
            const target = this._toTarget(this._parent);
            if (target) {
                const factor = this._dblClickZoomSpeed;
                const targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        }
        zoomOut(duration, stop) {
            const target = this._toTarget(this._parent);
            if (target) {
                const factor = 1 / this._dblClickZoomSpeed;
                const targetScale = target.scale;
                this.zoom(targetScale.x * factor, targetScale.y * factor, duration, stop);
            }
        }
        zoomAt(x, y, scaleX, scaleY, duration, stop) {
            const target = this._toTarget(this._parent);
            if (target) {
                // Scale
                const oldScaleX = target.scale.x;
                const oldScaleY = target.scale.y;
                const newScaleX = this.toNormalizedScale(scaleX);
                const newScaleY = this.toNormalizedScale(scaleY);
                const scaleRatioX = newScaleX / oldScaleX;
                const scaleRatioY = newScaleY / oldScaleY;
                // Position
                const newX = (target.position.x - x) * scaleRatioX + x;
                const newY = (target.position.y - y) * scaleRatioY + y;
                // Start
                this._transform.start(target, newX, newY, newScaleX, newScaleY, duration, stop);
            }
        }
        zoomAtGlobal(x, y, scaleX, scaleY, duration, stop) {
            const local = this._zoomPoint;
            local.set(x, y);
            this.toLocal(local, local);
            this.zoomAt(local.x, local.y, scaleX, scaleY, duration, stop);
        }
        zoom(scaleX, scaleY, duration, stop) {
            const parent = this._parent;
            this.zoomAt(parent.width * 0.5, parent.height * 0.5, scaleX, scaleY, duration, stop);
        }
        get scale() {
            const target = this._toTarget(this._parent);
            if (target) {
                return target.scale;
            }
            return new pixi_js.Point(1, 1);
        }
        set scale(scale) {
            const target = this._toTarget(this._parent);
            if (target) {
                const newScaleX = this.toNormalizedScale(scale.x);
                const newScaleY = this.toNormalizedScale(scale.y);
                const targetPosition = target.position;
                this._constraint(target, targetPosition.x, targetPosition.y, newScaleX, newScaleY);
            }
        }
        moveTo(x, y, duration, stop) {
            const target = this._toTarget(this._parent);
            if (target) {
                const targetScale = target.scale;
                this._transform.start(target, x, y, targetScale.x, targetScale.y, duration, stop);
            }
        }
        get position() {
            const target = this._toTarget(this._parent);
            if (target) {
                return target.position;
            }
            return new pixi_js.Point(0, 0);
        }
        set position(position) {
            const target = this._toTarget(this._parent);
            if (target) {
                const targetScale = target.scale;
                this._constraint(target, position.x, position.y, targetScale.x, targetScale.y);
            }
        }
        transform(x, y, scaleX, scaleY, duration, stop) {
            const target = this._toTarget(this._parent);
            if (target) {
                this._transform.start(target, x, y, scaleX, scaleY, duration, stop);
            }
        }
        toLocal(global, local, skipUpdate) {
            return this._parent.toLocal(global, undefined, local, skipUpdate);
        }
        toGlobal(local, global, skipUpdate) {
            return this._parent.toGlobal(local, global, skipUpdate);
        }
        toNormalizedScale(scale) {
            return Math.min(this._zoomMax, Math.max(this._zoomMin, scale));
        }
        onWheel(e, deltas, global) {
            if (this._isWheelZoomEnabled &&
                this._wheelZoomChecker(e, this._wheelZoomModifier, this._parent)) {
                if (deltas.deltaY !== 0) {
                    const target = this._toTarget(this._parent);
                    if (target) {
                        const speed = deltas.lowest * this._wheelZoomSpeed;
                        const factor = 1 + deltas.deltaY * speed;
                        const targetScale = target.scale;
                        this.zoomAtGlobal(global.x, global.y, targetScale.x * factor, targetScale.y * factor, 0);
                        return true;
                    }
                }
            }
            if (this._isWheelTranslationEnabled &&
                this._wheelTranslationChecker(e, this._wheelTranslationModifier, this._parent)) {
                const target = this._toTarget(this._parent);
                if (target) {
                    this.stop();
                    this.emit("wheeltranslationstart", this._parent, this);
                    const speed = deltas.lowest * this._wheelTranslationSpeed;
                    const targetPosition = target.position;
                    const newX = targetPosition.x - deltas.deltaX * speed;
                    const newY = targetPosition.y + deltas.deltaY * speed;
                    const targetScale = target.scale;
                    this._constraint(target, newX, newY, targetScale.x, targetScale.y);
                    this.emit("wheeltranslationend", this._parent, this);
                    return true;
                }
            }
            return false;
        }
        onDown(e) {
            this._gesture.onDown(e);
        }
        onDblClick(e, interactionManager) {
            if (this._isDblClickZoomEnabled &&
                this._dblClickZoomChecker(e, this._dblClickZoomModifier, this._parent)) {
                const target = this._toTarget(this._parent);
                if (target) {
                    const global = this._zoomPoint;
                    UtilPointerEvent.toGlobal(e, interactionManager, global);
                    const factor = this._dblClickZoomSpeed;
                    const targetScale = target.scale;
                    this.zoomAtGlobal(global.x, global.y, targetScale.x * factor, targetScale.y * factor, this._dblclickZoomDuration);
                    return true;
                }
            }
            return false;
        }
        toTheme(options) {
            if (options && options.theme) {
                const theme = options.theme;
                if (isString(theme)) {
                    return DThemes.getInstance().get(theme);
                }
                else {
                    return theme;
                }
            }
            return null;
        }
        getThemeDefault() {
            return DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "DView";
        }
    }
    DViewImpl.CONSTRAINT = (target, x, y, scaleX, scaleY) => {
        target.scale.set(scaleX, scaleY);
        target.position.set(x, y);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A canvas container.
     */
    class DCanvasContainer extends DBase {
        init(options) {
            var _a;
            super.init(options);
            this._canvas = null;
            const theme = this.theme;
            this._view = new DViewImpl(this, () => this._canvas, options === null || options === void 0 ? void 0 : options.view);
            // Canvas
            const canvas = options === null || options === void 0 ? void 0 : options.canvas;
            if (canvas) {
                this.canvas = canvas;
            }
            // Overflow mask
            const mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : theme.isOverflowMaskEnabled();
            if (mask) {
                this.mask = this.getOverflowMask();
            }
        }
        getType() {
            return "DCanvasContainer";
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
            this.updateContentSize(newWidth, newHeight, oldWidth, oldHeight);
        }
        get canvas() {
            return this._canvas;
        }
        set canvas(canvas) {
            const previous = this._canvas;
            if (previous != null) {
                this._canvas = null;
                this.removeChild(previous);
                this.emit("unset", previous, this);
                previous.destroy();
            }
            this._canvas = canvas;
            if (canvas != null) {
                this.addChild(canvas);
                this._view.reset(0);
                this.emit("set", canvas, this);
            }
            else {
                DApplications.update(this);
            }
        }
        getOverflowMask() {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this._reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        }
        updateContentSize(newWidth, newHeight, oldWidth, oldHeight) {
            const canvas = this._canvas;
            if (canvas != null) {
                const canvasX = canvas.x + (newWidth - oldWidth) * 0.5;
                const canvasY = canvas.y + (newHeight - oldHeight) * 0.5;
                canvas.position.set(canvasX, canvasY);
            }
        }
        get view() {
            return this._view;
        }
        onWheel(e, deltas, global) {
            const vresult = this._view.onWheel(e, deltas, global);
            const sresult = super.onWheel(e, deltas, global);
            return vresult || sresult;
        }
        onDblClick(e, interactionManager, skipView) {
            if (skipView !== true) {
                const vresult = this._view.onDblClick(e, interactionManager);
                const sresult = super.onDblClick(e, interactionManager);
                return vresult || sresult;
            }
            else {
                return super.onDblClick(e, interactionManager);
            }
        }
        onDown(e, skipView) {
            if (skipView !== true) {
                this._view.onDown(e);
            }
            super.onDown(e);
        }
        destroy() {
            // Overflow mask
            const overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            super.destroy();
        }
    }

    class UtilExtractorCanvas {
        constructor(width, height) {
            const element = document.createElement("canvas");
            this._element = element;
            const context = this._element.getContext("2d", {
                willReadFrequently: true
            });
            this._context = context;
            element.width = width;
            element.height = height;
        }
        get element() {
            const result = this._element;
            if (result != null) {
                return result;
            }
            throw new Error("No Element Available");
        }
        getElement() {
            return this._element;
        }
        get canvas() {
            return this.element;
        }
        get context() {
            const result = this._context;
            if (result != null) {
                return result;
            }
            throw new Error("No Context Available");
        }
        getContext() {
            return this._context;
        }
        get resolution() {
            return 1;
        }
        get width() {
            const element = this._element;
            if (element != null) {
                return element.width;
            }
            return 0;
        }
        set width(width) {
            const element = this._element;
            if (element != null) {
                element.width = width;
            }
        }
        get height() {
            const element = this._element;
            if (element != null) {
                return element.height;
            }
            return 0;
        }
        set height(height) {
            const element = this._element;
            if (element != null) {
                element.height = height;
            }
        }
        clear() {
            const element = this._element;
            const context = this._context;
            if (element != null && context != null) {
                context.setTransform(1, 0, 0, 1, 0, 0);
                context.clearRect(0, 0, element.width, element.height);
            }
        }
        resize(width, height) {
            const element = this._element;
            if (element != null) {
                element.width = width;
                element.height = height;
            }
        }
        destroy() {
            this._context = null;
            this._element = null;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilExtractor {
        static toTexture(target, resolution, clear, skipUpdateTransform) {
            const scale = target.transform.scale;
            const width = Math.max(1, Math.ceil(target.width * scale.x));
            const height = Math.max(1, Math.ceil(target.height * scale.y));
            const result = pixi_js.RenderTexture.create({
                width,
                height,
                scaleMode: pixi_js.SCALE_MODES.LINEAR,
                resolution
            });
            const matrix = new pixi_js.Matrix(undefined, undefined, undefined, undefined, -target.position.x, -target.position.y);
            const layer = DApplications.getLayer(target);
            if (layer) {
                layer.renderer.render(target, result, clear, matrix, skipUpdateTransform);
            }
            return result;
        }
        static toPixels(renderTexture, renderer) {
            const baseTexture = renderTexture.baseTexture;
            const realWidth = baseTexture.realWidth;
            const realHeight = baseTexture.realHeight;
            const resolution = renderTexture.resolution;
            const frame = renderTexture.frame;
            const x0 = Math.floor(frame.x * resolution);
            const y0 = Math.floor(frame.y * resolution);
            const x1 = Math.floor((frame.x + frame.width) * resolution);
            const y1 = Math.floor((frame.y + frame.height) * resolution);
            const width = Math.min(x1 - x0, realWidth);
            const height = Math.min(y1 - y0, realHeight);
            const pixels = new Uint8Array(4 * width * height);
            if (0 < width && 0 < height) {
                const oldRenderTexture = renderer.renderTexture.current;
                renderer.renderTexture.bind(renderTexture);
                const gl = renderer.gl;
                gl.readPixels(x0, y0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                renderer.renderTexture.bind(oldRenderTexture);
            }
            return {
                width,
                height,
                array: pixels
            };
        }
        static toCanvas(pixels, scale, ignorePremutipliedAlpha, result) {
            const width = pixels.width;
            const height = pixels.height;
            const array = pixels.array;
            if (result == null) {
                result = new UtilExtractorCanvas(width, height);
            }
            else {
                result.resize(width, height);
            }
            if (width <= 0 || height <= 0) {
                return result;
            }
            const context = result.getContext();
            const element = result.getElement();
            if (context == null || element == null) {
                return result;
            }
            const imageData = context.getImageData(0, 0, width, height);
            if (ignorePremutipliedAlpha) {
                imageData.data.set(array);
            }
            else {
                pixi_js.Extract.arrayPostDivide(array, imageData.data);
            }
            context.putImageData(imageData, 0, 0);
            // Scale down
            if (scale != null && scale !== 1) {
                context.scale(scale, scale);
                context.drawImage(element, 0, 0);
                const scaledWidth = Math.floor(width * scale);
                const scaledHeight = Math.floor(height * scale);
                const scaledImageData = context.getImageData(0, 0, scaledWidth, scaledHeight);
                result.resize(scaledWidth, scaledHeight);
                context.putImageData(scaledImageData, 0, 0);
            }
            return result;
        }
        static toBase64(canvas, format, quality) {
            return canvas.toDataURL(format, quality);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilFileDownloader {
        /**
         * Downloads a file of the given name and URL.
         *
         * @param filename a file name
         * @param url a file URL
         */
        static downloadUrl(filename, url) {
            const a = document.createElement("a");
            if ("download" in a) {
                a.href = url;
                a.setAttribute("download", filename);
                a.style.display = "none";
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                }, 66);
            }
            else {
                if (!window.open(url)) {
                    location.href = url;
                }
            }
        }
        /**
         * Downloads a file of the given name with the given contents.
         *
         * @param filename a file name
         * @param contents file contents
         * @param insertBom false to stop the BOM insertion
         */
        static download(filename, contents, insertBom) {
            const blob = new Blob(insertBom !== false ? ["\ufeff", contents] : [contents], {
                type: "text/plain"
            });
            const navigator = window.navigator;
            if ("msSaveBlob" in navigator) {
                // IE10 and 11
                navigator.msSaveBlob(blob, filename);
            }
            else {
                this.downloadUrl(filename, URL.createObjectURL(blob));
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toResolution = (options) => {
        var _a;
        const target = options.target;
        const resolution = options.resolution;
        if (resolution != null) {
            if (isNumber(resolution)) {
                return resolution;
            }
            else {
                const scale = target.transform.scale;
                const size = Math.max(target.width * scale.x, target.height * scale.y);
                return Math.min(1, resolution.size / size);
            }
        }
        else {
            return (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1;
        }
    };
    const toScale = (pixels, options) => {
        const scale = options.scale;
        if (scale != null) {
            if (isNumber(scale)) {
                return scale;
            }
            else {
                const size = scale.size;
                return Math.min(1, size / pixels.width, size / pixels.height);
            }
        }
    };
    const toRenderer = (options) => {
        const renderer = options.renderer;
        if (renderer) {
            return renderer;
        }
        const application = options.application;
        if (application) {
            return application.getLayerBase().renderer;
        }
        const layer = options.layer || DApplications.getLayer(options.target);
        if (layer) {
            return layer.renderer;
        }
        throw new Error("No renderer / application / layer found.");
    };
    class UtilExtract {
        static texture(options) {
            var _a;
            const target = options.target;
            const resolution = toResolution(options);
            const skipUpdateTransform = (_a = options.transform) === null || _a === void 0 ? void 0 : _a.update;
            return UtilExtractor.toTexture(target, resolution, options.clear, skipUpdateTransform);
        }
        /**
         * Extracts pixels from the target.
         * This method internally creates one render texture and use that to extract pixels from the target.
         * To free the allocated render texture, please call {@link destroy()}.
         *
         * @param options an extraction options
         * @returns extracted pixels
         */
        static pixels(options) {
            var _a;
            const renderer = toRenderer(options);
            // Create a render texture
            const target = options.target;
            const scale = target.transform.scale;
            const width = Math.ceil(target.width * scale.x);
            const height = Math.ceil(target.height * scale.y);
            if (width <= 0 || height <= 0) {
                return {
                    width,
                    height,
                    array: new Uint8Array(0)
                };
            }
            const resolution = toResolution(options);
            let renderTexture = UtilExtract.WORK_RENDER_TEXTURE;
            if (renderTexture == null) {
                renderTexture = pixi_js.RenderTexture.create({
                    width,
                    height,
                    scaleMode: pixi_js.SCALE_MODES.LINEAR,
                    resolution
                });
                UtilExtract.WORK_RENDER_TEXTURE = renderTexture;
            }
            else {
                const baseTexture = renderTexture.baseTexture;
                const baseTextureWidth = baseTexture.width;
                const baseTextureHeight = baseTexture.height;
                const isWidthDirty = baseTextureWidth < width;
                const isHeightDirty = baseTextureHeight < height;
                const isResolutionDirty = renderTexture.resolution !== resolution;
                if (isResolutionDirty || isWidthDirty || isHeightDirty) {
                    if (isResolutionDirty) {
                        baseTexture.resolution = resolution;
                    }
                    renderTexture.resize(Math.max(width, baseTextureWidth), Math.max(height, baseTextureHeight), true);
                }
            }
            // Render to the render texture
            const frame = renderTexture.frame;
            if (frame.x !== 0 || frame.y !== 0 || frame.width !== width || frame.height !== height) {
                frame.x = 0;
                frame.y = 0;
                frame.width = width;
                frame.height = height;
                renderTexture.frame = frame;
            }
            const targetPosition = target.position;
            const matrix = new pixi_js.Matrix(1, 0, 0, 1, -targetPosition.x, -targetPosition.y);
            renderer.render(target, renderTexture, options.clear, matrix, (_a = options.transform) === null || _a === void 0 ? void 0 : _a.update);
            // Extract pixels
            return UtilExtractor.toPixels(renderTexture, renderer);
        }
        static canvas(options) {
            var _a, _b;
            const pixels = this.pixels(options);
            const ignorePremutipliedAlpha = (_b = (_a = options.alpha) === null || _a === void 0 ? void 0 : _a.premultiplied) === null || _b === void 0 ? void 0 : _b.ignore;
            const scale = toScale(pixels, options);
            return UtilExtractor.toCanvas(pixels, scale, ignorePremutipliedAlpha);
        }
        /**
         * Extracts Base64 data URL from the target.
         * This method internally creates a render texture and a canvas render target.
         * They are used to extract pixels from the target.
         * To free the allocated render texture and canvas render target, please call {@link destroy()}.
         *
         * @param options an extraction options
         * @returns extracted Base64 data URL
         */
        static base64(options) {
            var _a, _b, _c;
            const pixels = this.pixels(options);
            const ignorePremutipliedAlpha = (_b = (_a = options.alpha) === null || _a === void 0 ? void 0 : _a.premultiplied) === null || _b === void 0 ? void 0 : _b.ignore;
            const scale = toScale(pixels, options);
            const canvas = ((_c = this.WORK_CANVAS) !== null && _c !== void 0 ? _c : (this.WORK_CANVAS = new UtilExtractorCanvas(pixels.width, pixels.height)));
            UtilExtractor.toCanvas(pixels, scale, ignorePremutipliedAlpha, canvas);
            const element = canvas.getElement();
            if (element != null) {
                return UtilExtractor.toBase64(element, options.format, options.quality);
            }
            return "data:,";
        }
        static file(options) {
            UtilFileDownloader.downloadUrl(options.filename, this.base64(options));
        }
        /**
         * Clears all the memories.
         */
        static destroy() {
            const texture = this.WORK_RENDER_TEXTURE;
            if (texture != null) {
                this.WORK_RENDER_TEXTURE = undefined;
                texture.destroy(true);
            }
            const canvas = this.WORK_CANVAS;
            if (canvas != null) {
                this.WORK_CANVAS = undefined;
                canvas.destroy();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramSnapshot extends pixi_js.utils.EventEmitter {
        constructor(parent, options) {
            super();
            this._parent = parent;
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        createAsUrl(sizeOrOptions) {
            if (sizeOrOptions == null || isNumber(sizeOrOptions)) {
                return this.create({
                    size: sizeOrOptions,
                    extractor: (canvas) => {
                        return UtilExtract.base64({ target: canvas });
                    }
                });
            }
            else {
                return this.create({
                    size: sizeOrOptions.size,
                    cleanup: sizeOrOptions.cleanup,
                    extractor: (canvas) => {
                        return UtilExtract.base64({ target: canvas });
                    }
                });
            }
        }
        createAsFile(sizeOrFilenameOrOptions, filename) {
            if (isString(sizeOrFilenameOrOptions)) {
                this.create({
                    extractor: (canvas) => {
                        UtilExtract.file({ target: canvas, filename: sizeOrFilenameOrOptions });
                    }
                });
            }
            else if (sizeOrFilenameOrOptions === null || isNumber(sizeOrFilenameOrOptions)) {
                this.create({
                    size: sizeOrFilenameOrOptions,
                    extractor: (canvas) => {
                        UtilExtract.file({ target: canvas, filename: filename });
                    }
                });
            }
            else {
                this.create({
                    size: sizeOrFilenameOrOptions.size,
                    cleanup: sizeOrFilenameOrOptions.cleanup,
                    extractor: (canvas) => {
                        UtilExtract.file({
                            target: canvas,
                            filename: sizeOrFilenameOrOptions.filename
                        });
                    }
                });
            }
        }
        toScale(size, canvas) {
            if (size == null) {
                return 1;
            }
            return size / DApplications.getResolution(canvas) / Math.max(canvas.width, canvas.height);
        }
        toCleanupSnap(options) {
            if (options == null) {
                return true;
            }
            const cleanup = options.cleanup;
            if (cleanup == null || cleanup === true) {
                return true;
            }
            return cleanup !== false && cleanup.snap !== false;
        }
        toCleanupBackground(options) {
            if (options == null) {
                return false;
            }
            const cleanup = options.cleanup;
            if (cleanup == null || cleanup === false) {
                return false;
            }
            return cleanup === true || cleanup.background === true;
        }
        toCleanupReflow(options) {
            if (options == null) {
                return true;
            }
            const cleanup = options.cleanup;
            if (cleanup == null || cleanup === true) {
                return true;
            }
            return cleanup !== false && cleanup.reflow !== false;
        }
        create(options) {
            const parent = this._parent;
            const canvas = parent.canvas;
            if (canvas) {
                const view = parent.view;
                const viewPosition = view.position;
                const viewScale = view.scale;
                const oldPositionX = viewPosition.x;
                const oldPositionY = viewPosition.y;
                const oldScaleX = viewScale.x;
                const oldScaleY = viewScale.y;
                const newScale = this.toScale(options.size, canvas);
                view.transform(0, 0, newScale, newScale, 0);
                // Turns off the snap grid and targets
                let container;
                if (this.toCleanupSnap(options) && "snap" in canvas) {
                    const snap = canvas.snap;
                    if (snap != null) {
                        container = snap.container;
                        if (container.renderable) {
                            container.renderable = false;
                        }
                        else {
                            container = undefined;
                        }
                    }
                }
                // Turns off the canvas snippets
                let snippet;
                if (this.toCleanupBackground(options)) {
                    snippet = canvas.snippet;
                    if (snippet.renderable) {
                        snippet.renderable = false;
                    }
                    else {
                        snippet = undefined;
                    }
                }
                // Refit & reflow
                const reflow = this.toCleanupReflow(options);
                if (reflow) {
                    const layer = DApplications.getLayer(canvas);
                    if (layer) {
                        layer.reflow();
                    }
                }
                // Extracts
                this.emit("taking", canvas, this);
                const result = options.extractor(canvas);
                this.emit("took", canvas, null, this);
                // Turn on the canvas snippets
                if (snippet) {
                    snippet.renderable = true;
                }
                // Turn on the snap grid and targets
                if (container != null) {
                    container.renderable = true;
                }
                view.transform(oldPositionX, oldPositionY, oldScaleX, oldScaleY, 0);
                return result;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramBase extends DCanvasContainer {
        constructor(options) {
            var _a;
            super(options);
            this._serialized = null;
            this._tileFactory = options === null || options === void 0 ? void 0 : options.tile;
            this._controller = options === null || options === void 0 ? void 0 : options.controller;
            this._isAmbient = (_a = options === null || options === void 0 ? void 0 : options.ambient) !== null && _a !== void 0 ? _a : this.theme.isAmbient();
            this._snapshot = new DDiagramSnapshot(this, options === null || options === void 0 ? void 0 : options.snapshot);
            this._mode = this.toMode(options);
        }
        get snapshot() {
            return this._snapshot;
        }
        get controller() {
            return this._controller || null;
        }
        set(serialized) {
            const oldSerialized = this._serialized;
            if (oldSerialized !== serialized) {
                if (oldSerialized) {
                    this._serialized = null;
                    const canvas = this.canvas;
                    if (canvas) {
                        this.canvas = null;
                    }
                    this.onUnset();
                }
                this._serialized = serialized;
                if (serialized) {
                    const canvas = this.newCanvas(serialized);
                    const pieces = serialized.pieces;
                    const mode = this._mode;
                    const result = DDiagrams.toPieceData(this._controller, pieces, mode).then((pieceData) => {
                        return this.newLayer(serialized, canvas, mode, pieces, pieceData);
                    });
                    this.onSet(serialized, canvas);
                    this.canvas = canvas;
                    return result;
                }
                else {
                    return Promise.resolve(null);
                }
            }
            else {
                return Promise.resolve(this.canvas);
            }
        }
        onSet(serialized, canvas) {
            // DO NOTHING
        }
        newLayer(serialized, canvas, mode, pieces, pieceData) {
            const manager = new EShapeResourceManagerDeserialization(serialized, pieces, pieceData, mode, 0);
            const result = DDiagrams.newLayer(serialized, canvas.layer, manager).then((shapes) => {
                return this.initLayer(canvas, shapes);
            });
            if (this._isAmbient) {
                const background = this.toCanvasBaseBackgroundOptions(serialized, this.theme, false);
                this.background.color = background.color;
                this.background.alpha = background.alpha;
            }
            return result;
        }
        initLayer(canvas, shapes, mapper) {
            canvas.layer.init();
            canvas.initialize(shapes, mapper);
            DApplications.update(this);
            this.emit("ready", this);
            return canvas;
        }
        toCanvasBaseOptions(serialized) {
            var _a;
            const theme = this.theme;
            const isAmbient = this._isAmbient;
            return {
                name: serialized.name,
                label: serialized.label,
                width: serialized.width,
                height: serialized.height,
                category: serialized.category,
                summary: serialized.summary,
                description: serialized.description,
                background: this.toCanvasBaseBackgroundOptions(serialized, theme, isAmbient),
                border: isAmbient ? { color: null } : undefined,
                outline: isAmbient ? { color: null } : undefined,
                shadow: isAmbient ? null : theme.getCanvasShadow(),
                tile: {
                    factory: this._tileFactory,
                    mapping: (_a = serialized.tile) === null || _a === void 0 ? void 0 : _a.mapping
                },
                ambient: isAmbient
            };
        }
        toCanvasBaseBackgroundOptions(serialized, theme, isAmbient) {
            var _a, _b;
            if (isAmbient) {
                return {
                    color: null
                };
            }
            const background = serialized.background;
            return {
                color: (_a = background === null || background === void 0 ? void 0 : background.color) !== null && _a !== void 0 ? _a : theme.getCanvasBackgroundColor(),
                alpha: (_b = background === null || background === void 0 ? void 0 : background.alpha) !== null && _b !== void 0 ? _b : theme.getCanvasBackgroundAlpha()
            };
        }
        onUnset() {
            // DO NOTHING
        }
        get() {
            return this._serialized;
        }
        get layer() {
            const canvas = this.canvas;
            if (canvas) {
                return canvas.layer.active;
            }
            return null;
        }
        getType() {
            return "DDiagramBase";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DCanvas extends DBase {
        getType() {
            return "DCanvas";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasEditorBackground {
        constructor(target, base) {
            this._target = target;
            this._base = base;
        }
        getTheme() {
            return this._target.getTheme();
        }
        setTheme(theme) {
            this._target.setTheme(theme);
        }
        getBaseColor() {
            return this._base;
        }
        setBaseColor(baseColor) {
            this._base = baseColor;
        }
        getColor(state) {
            const target = this._target;
            const base = this._base;
            const color = target.getColor(state);
            if (base != null) {
                if (color != null) {
                    return UtilRgb.blend(base, color, target.getAlpha(state));
                }
                return base;
            }
            return color;
        }
        get color() {
            return this._target.color;
        }
        set color(color) {
            this._target.color = color;
        }
        getAlpha(state) {
            const base = this._base;
            if (base != null) {
                return 1;
            }
            return this._target.getAlpha(state);
        }
        get alpha() {
            return this._target.alpha;
        }
        set alpha(alpha) {
            this._target.alpha = alpha;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasTileMappingPointImpl extends pixi_js.ObservablePoint {
        get lon() {
            return this.x;
        }
        set lon(lon) {
            this.x = lon;
        }
        get lat() {
            return this.y;
        }
        set lat(lat) {
            this.y = lat;
        }
        toObject() {
            return {
                lon: this.x,
                lat: this.y
            };
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasTileMappingImpl {
        constructor(cb, mappingOrEnable, lon0, lat0, lon1, lat1) {
            this._cb = cb;
            if (mappingOrEnable === true || mappingOrEnable === false) {
                this._enable = mappingOrEnable;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, lon0, lat0);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, lon1, lat1);
            }
            else if (mappingOrEnable != null) {
                this._enable = mappingOrEnable.enable;
                const from = mappingOrEnable.from;
                const to = mappingOrEnable.to;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, from.lon, from.lat);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, to.lon, to.lat);
            }
            else {
                this._enable = false;
                this._from = new DDiagramCanvasTileMappingPointImpl(cb, null, -180, +85.05112877980659);
                this._to = new DDiagramCanvasTileMappingPointImpl(cb, null, +180, -85.05112877980659);
            }
        }
        get enable() {
            return this._enable;
        }
        set enable(enable) {
            if (this._enable !== enable) {
                this._enable = enable;
                this._cb();
            }
        }
        get from() {
            return this._from;
        }
        get to() {
            return this._to;
        }
        serialize() {
            return {
                enable: this._enable,
                from: this._from.toObject(),
                to: this._to.toObject()
            };
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasTile {
        constructor(canvas, options) {
            this._canvas = canvas;
            this._factory = options === null || options === void 0 ? void 0 : options.factory;
            this._mapping = new DDiagramCanvasTileMappingImpl(() => {
                this.onMappingChange();
            }, options === null || options === void 0 ? void 0 : options.mapping);
        }
        init() {
            this.onMappingChange();
        }
        onMappingChange() {
            const factory = this._factory;
            if (factory) {
                const mapping = this._mapping;
                if (mapping.enable) {
                    const pyramid = this._pyramid;
                    if (pyramid) {
                        pyramid.mapping = mapping;
                    }
                    else {
                        this._pyramid = factory(this._canvas).fit();
                    }
                }
                else {
                    const pyramid = this._pyramid;
                    if (pyramid) {
                        this._pyramid = undefined;
                        pyramid.destroy();
                    }
                }
            }
        }
        get pyramid() {
            return this._pyramid;
        }
        get factory() {
            return this._factory;
        }
        get mapping() {
            return this._mapping;
        }
        serialize() {
            return {
                mapping: this._mapping.serialize()
            };
        }
        destroy() {
            const pyramid = this._pyramid;
            if (pyramid != null) {
                this._pyramid = undefined;
                pyramid.destroy();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeRuntimeImpl {
        constructor(shape) {
            const transform = shape.transform;
            const position = transform.position;
            this.x = position.x;
            this.y = position.y;
            const size = shape.size;
            this.sizeX = size.x;
            this.sizeY = size.y;
            this.rotation = transform.rotation;
            this.actions = [];
            this.fill = shape.fill.toObject();
            this.stroke = shape.stroke.toObject();
            this.text = shape.text.toObject();
            this.cursor = shape.cursor;
            this.reset = EShapeRuntimeReset.NONE;
            this.written = EShapeRuntimeReset.NONE;
            this.effect = -1;
            this.isStateChanged = false;
            this.interactive = false;
        }
        initialize(shape) {
            shape.lock(EShapeLockPart.UPLOADED);
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].initialize(shape, this);
            }
            shape.unlock(EShapeLockPart.UPLOADED, true);
        }
        isActionable() {
            return 0 < this.actions.length;
        }
        onResize(shape) {
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onResize(shape, this);
            }
        }
        onClick(shape, e) {
            // State
            const state = shape.state;
            if (state.isActionable) {
                state.isClicked = true;
            }
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onClick(shape, this, e);
            }
        }
        onDblClick(shape, e, interactionManager) {
            // State
            const state = shape.state;
            if (state.isActionable) {
                state.isDblClicked = true;
            }
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onDblClick(shape, this, e, interactionManager);
            }
            // Done
            return false;
        }
        onOver(shape, e) {
            const state = shape.state;
            if (!state.isHovered) {
                // State
                state.isHovered = true;
                // Actions
                const actions = this.actions;
                for (let i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onOver(shape, this, e);
                }
            }
        }
        onOut(shape, e) {
            const state = shape.state;
            if (state.isHovered) {
                // State
                shape.state.isHovered = false;
                // Actions
                const actions = this.actions;
                for (let i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onOut(shape, this, e);
                }
            }
        }
        onDown(shape, e) {
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onDowning(shape, this, e);
            }
            const state = shape.state;
            if (!state.isDown) {
                if (!state.isPressed) {
                    // State
                    state.addAll(EShapeState.DOWN, DBaseState.PRESSED);
                    // Focus
                    const layer = DApplications.getLayer(shape);
                    if (layer) {
                        // Focus
                        const focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (let i = 0, imax = actions.length; i < imax; ++i) {
                        const action = actions[i];
                        action.onDown(shape, this, e);
                        action.onPressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isDown = true;
                    // Focus
                    const layer = DApplications.getLayer(shape);
                    if (layer) {
                        const focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (let i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onDown(shape, this, e);
                    }
                }
            }
        }
        onUp(shape, e) {
            const state = shape.state;
            if (!state.isUp) {
                if (state.isPressed) {
                    // State
                    state.set(EShapeState.UP, DBaseState.PRESSED);
                    // Actions
                    const actions = this.actions;
                    for (let i = 0, imax = actions.length; i < imax; ++i) {
                        const action = actions[i];
                        action.onUp(shape, this, e);
                        action.onUnpressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isUp = true;
                    // Actions
                    const actions = this.actions;
                    for (let i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onUp(shape, this, e);
                    }
                }
            }
        }
        onUpOutside(shape, e) {
            const state = shape.state;
            if (state.isPressed) {
                // State
                state.set(EShapeState.UP_OUTSIDE, DBaseState.PRESSED);
                // Actions
                const actions = this.actions;
                for (let i = 0, imax = actions.length; i < imax; ++i) {
                    const action = actions[i];
                    action.onUpOutside(shape, this, e);
                    action.onUnpressed(shape, this, e);
                }
            }
            else {
                // State
                state.isUpOutside = true;
                // Actions
                const actions = this.actions;
                for (let i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onUpOutside(shape, this, e);
                }
            }
        }
        onMove(shape, e) {
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onMove(shape, this, e);
            }
        }
        onKeyDown(shape, e) {
            // State
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onDown(shape, e);
            }
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onKeyDown(shape, this, e);
            }
            // Done
            return false;
        }
        onKeyUp(shape, e) {
            // State
            if (UtilKeyboardEvent.isActivateKey(e)) {
                const state = shape.state;
                if (state.isPressed) {
                    const wasUp = state.isUp;
                    this.onUp(shape, e);
                    if (!wasUp && state.isUp) {
                        this.onClick(shape, e);
                    }
                }
            }
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onKeyUp(shape, this, e);
            }
            // Done
            return false;
        }
        onStateChange(shape, newState, oldState) {
            this.isStateChanged = true;
            DApplications.update(shape);
            if (newState.isFocused) {
                if (!oldState.isFocused) {
                    this.onFocus(shape);
                }
            }
            else if (oldState.isFocused) {
                this.onBlur(shape);
            }
        }
        onFocus(shape) {
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onFocus(shape, this);
            }
        }
        onBlur(shape) {
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onBlur(shape, this);
            }
        }
        onRightClick(shape, e) {
            // State
            const state = shape.state;
            if (state.isActionable) {
                state.isRightClicked = true;
            }
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRightClick(shape, this, e);
            }
        }
        onRightDown(shape, e) {
            // Actions
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRightDowning(shape, this, e);
            }
            const state = shape.state;
            if (!state.isRightDown) {
                if (state.isRightPressed) {
                    // State
                    state.addAll(EShapeState.RIGHT_DOWN, EShapeState.RIGHT_PRESSED);
                    // Focus
                    const layer = DApplications.getLayer(shape);
                    if (layer) {
                        // Focus
                        const focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (let i = 0, imax = actions.length; i < imax; ++i) {
                        const action = actions[i];
                        action.onRightDown(shape, this, e);
                        action.onRightPressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isRightDown = false;
                    // Focus
                    const layer = DApplications.getLayer(shape);
                    if (layer) {
                        const focusController = layer.getFocusController();
                        focusController.focus(focusController.findParent(shape));
                    }
                    // Actions
                    for (let i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onRightDown(shape, this, e);
                    }
                }
            }
        }
        onRightUp(shape, e) {
            const state = shape.state;
            if (!state.isRightUp) {
                if (state.isRightPressed) {
                    // State
                    state.set(EShapeState.RIGHT_UP, EShapeState.RIGHT_PRESSED);
                    // Actions
                    const actions = this.actions;
                    for (let i = 0, imax = actions.length; i < imax; ++i) {
                        const action = actions[i];
                        action.onRightUp(shape, this, e);
                        action.onRightUnpressed(shape, this, e);
                    }
                }
                else {
                    // State
                    state.isRightUp = true;
                    // Actions
                    const actions = this.actions;
                    for (let i = 0, imax = actions.length; i < imax; ++i) {
                        actions[i].onRightUp(shape, this, e);
                    }
                }
            }
        }
        onRightUpOutside(shape, e) {
            const state = shape.state;
            if (state.isRightPressed) {
                // State
                state.set(EShapeState.RIGHT_UP_OUTSIDE, EShapeState.RIGHT_PRESSED);
                // Actions
                const actions = this.actions;
                for (let i = 0, imax = actions.length; i < imax; ++i) {
                    const action = actions[i];
                    action.onRightUpOutside(shape, this, e);
                    action.onRightUnpressed(shape, this, e);
                }
            }
            else {
                // State
                state.isRightUpOutside = true;
                // Actions
                const actions = this.actions;
                for (let i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].onRightUpOutside(shape, this, e);
                }
            }
        }
        update(shape, time) {
            const data = shape.data;
            const effect = this.effect;
            const isEffectTimeUp = 0 <= effect && effect <= time;
            if (data.isChanged || this.isStateChanged || isEffectTimeUp) {
                this.isStateChanged = false;
                data.isChanged = false;
                if (isEffectTimeUp) {
                    this.effect = -1;
                }
                shape.lock(EShapeLockPart.UPLOADED);
                this.onUpdate(shape, time);
                shape.unlock(EShapeLockPart.UPLOADED, true);
                const wasStateChanged = this.isStateChanged;
                shape.state.removeAll(EShapeRuntimeImpl.TRANSIENT_STATES);
                this.isStateChanged = wasStateChanged;
            }
        }
        onRender(shape, time, renderer) {
            const actions = this.actions;
            for (let i = 0, imax = actions.length; i < imax; ++i) {
                actions[i].onRender(shape, this, time, renderer);
            }
            this.update(shape, time);
        }
        onUpdate(shape, time) {
            const actions = this.actions;
            if (0 < actions.length) {
                this.written = EShapeRuntimeReset.NONE;
                for (let i = 0, imax = actions.length; i < imax; ++i) {
                    actions[i].execute(shape, this, time);
                }
                this.doReset(shape);
            }
        }
        doReset(shape) {
            const target = ~this.written & this.reset;
            if (target !== EShapeRuntimeReset.NONE) {
                if (target & EShapeRuntimeReset.POSITION_X) {
                    shape.transform.position.x = this.x;
                }
                if (target & EShapeRuntimeReset.POSITION_Y) {
                    shape.transform.position.y = this.y;
                }
                if (target & EShapeRuntimeReset.VISIBILITY) {
                    shape.visible = true;
                }
                if (target & EShapeRuntimeReset.COLOR_FILL) {
                    const fill = this.fill;
                    shape.fill.set(undefined, fill.color, fill.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_STROKE) {
                    const stroke = this.stroke;
                    shape.stroke.set(undefined, stroke.color, stroke.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT) {
                    const text = this.text;
                    shape.text.set(undefined, text.color, text.alpha);
                }
                if (target & EShapeRuntimeReset.COLOR_TEXT_OUTLINE) {
                    const outline = this.text.outline;
                    shape.text.outline.set(undefined, outline.color, outline.alpha);
                }
                if (target & EShapeRuntimeReset.HEIGHT) {
                    shape.size.y = this.sizeY;
                }
                if (target & EShapeRuntimeReset.WIDTH) {
                    shape.size.x = this.sizeX;
                }
                if (target & EShapeRuntimeReset.ROTATION) {
                    shape.transform.rotation = this.rotation;
                }
                if (target & EShapeRuntimeReset.TEXT) {
                    shape.text.value = this.text.value;
                }
                if (target & EShapeRuntimeReset.CURSOR) {
                    shape.cursor = this.cursor;
                }
            }
        }
    }
    EShapeRuntimeImpl.TRANSIENT_STATES = [
        EShapeState.CLICKED,
        EShapeState.DBL_CLICKED,
        EShapeState.DOWN,
        EShapeState.UP,
        EShapeState.UP_OUTSIDE,
        EShapeState.RIGHT_CLICKED,
        EShapeState.RIGHT_DOWN,
        EShapeState.RIGHT_UP,
        EShapeState.RIGHT_UP_OUTSIDE,
        EShapeState.ACTIVATED,
        EShapeState.DEACTIVATED
    ];

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeRectangle extends EShapePrimitive {
        constructor(type = EShapeType.RECTANGLE) {
            super(type);
        }
        clone() {
            return new EShapeRectangle(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            if (super.containsAbsBBox(x, y, ax, ay)) {
                return hitTestRectangle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeRectanglePivoted extends EShapeRectangle {
        constructor(type = EShapeType.RECTANGLE_PIVOTED) {
            super(type);
        }
        toHitTestData(x, y) {
            const result = super.toHitTestData(x, y);
            result.x -= result.width;
            result.y -= result.height;
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramLayer extends EShapeContainer {
        constructor(name) {
            super();
            this.name = name;
            this.interactive = false;
            this.reference = 0;
            const shape = this.newShape();
            shape.parent = this;
            this._shape = shape;
            this.interactives = [];
        }
        get width() {
            return this._shape.size.x;
        }
        set width(width) {
            this._shape.size.x = width;
        }
        get height() {
            return this._shape.size.y;
        }
        set height(height) {
            this._shape.size.y = height;
        }
        get background() {
            return this._shape.fill;
        }
        get state() {
            return this._shape.state;
        }
        newShape() {
            const result = new EShapeRectanglePivoted();
            result.fill.set(false, 0xffffff, 1);
            result.stroke.set(false);
            result.state.add(EShapeLayerState.INTERACTIVE);
            return result;
        }
        initialize(actionables) {
            const interactives = this.interactives;
            const shape = this._shape;
            const isInteractive = shape.state.is(EShapeLayerState.INTERACTIVE);
            const isDraggable = shape.state.is(EShapeLayerState.DRAGGABLE);
            const isPinchable = shape.state.is(EShapeLayerState.PINCHABLE);
            if (isDraggable || isPinchable) {
                const runtime = new EShapeRuntimeImpl(shape);
                shape.runtime = runtime;
                const gestureType = (isDraggable
                    ? EShapeActionValueGestureOperationType.DRAG
                    : EShapeActionValueGestureOperationType.NONE) |
                    (isPinchable
                        ? EShapeActionValueGestureOperationType.PINCH
                        : EShapeActionValueGestureOperationType.NONE);
                runtime.actions.push(new EShapeActionValueGesture("", EShapeActionValueGestureType.LAYER, gestureType).toRuntime());
                actionables.push(shape);
                runtime.initialize(shape);
            }
            if (isInteractive || isDraggable || isPinchable) {
                shape.interactive = true;
                interactives.push(shape);
            }
            this.doInitialize(this.children, interactives);
        }
        doInitialize(shapes, interactives) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const runtime = shape.runtime;
                if (runtime) {
                    // Interactives
                    if (shape.interactive || runtime.interactive) {
                        interactives.push(shape);
                    }
                    else {
                        const cursor = shape.cursor;
                        if (cursor != null && 0 < cursor.length) {
                            interactives.push(shape);
                        }
                    }
                }
                // Children
                const children = shape.children;
                if (0 < children.length) {
                    this.doInitialize(children, interactives);
                }
            }
        }
        update(time) {
            this.doUpdate(this.children, time);
        }
        doUpdate(shapes, time) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                shape.update(time);
                // Children
                const children = shape.children;
                if (0 < children.length) {
                    this.doUpdate(children, time);
                }
            }
        }
        hitTestInteractives(global) {
            const local = this._work;
            const interactives = this.interactives;
            for (let i = interactives.length - 1; 0 <= i; --i) {
                const interactive = interactives[i];
                if (interactive.visible) {
                    interactive.toLocal(global, undefined, local);
                    if (interactive.contains(local.x, local.y) != null) {
                        return interactive;
                    }
                }
            }
            return null;
        }
        addUuid(manager) {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
        }
        updateUuid(manager) {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
        }
        destroy() {
            if (!this._destroyed) {
                const children = this.children;
                for (let i = children.length - 1; 0 <= i; --i) {
                    children[i].destroy();
                }
                children.length = 0;
                super.destroy();
            }
        }
        serialize(layer, manager, items) {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const shape = children[i];
                const item = shape.serialize(manager);
                item[16] = layer;
                items.push(item);
            }
            const shape = this._shape;
            const nameId = manager.addResource(this.name || "");
            const visible = (this.visible ? 1 : 0) | (shape.state.is(EShapeLayerState.INVISIBLE) ? 0 : 2);
            const position = this.position;
            const size = shape.size;
            const fill = shape.fill.serialize(manager);
            const isInteractive = shape.state.is(EShapeLayerState.INTERACTIVE) ? 1 : 0;
            const isDraggable = shape.state.is(EShapeLayerState.DRAGGABLE) ? 2 : 0;
            const isPinchable = shape.state.is(EShapeLayerState.PINCHABLE) ? 4 : 0;
            return [
                nameId,
                visible,
                position.x,
                position.y,
                size.x,
                size.y,
                fill,
                isInteractive | isDraggable | isPinchable
            ];
        }
        static deserialize(serialized, manager, width, height) {
            var _a, _b, _c;
            const result = new DDiagramLayer(this.deserializeName(serialized[0], manager));
            const shape = result._shape;
            const visibility = serialized[1];
            if (visibility != null) {
                const isEditorMode = manager.mode !== EShapeResourceManagerDeserializationMode.VIEWER;
                if (isEditorMode && !(visibility & 0x1)) {
                    result.visible = false;
                }
                if (!(visibility & 0x2)) {
                    shape.state.add(EShapeLayerState.INVISIBLE);
                    if (!isEditorMode) {
                        result.visible = false;
                    }
                }
            }
            const positionX = serialized[2];
            const positionY = serialized[3];
            result.position.set(positionX, positionY);
            const sizeX = (_a = serialized[4]) !== null && _a !== void 0 ? _a : width;
            const sizeY = (_b = serialized[5]) !== null && _b !== void 0 ? _b : height;
            shape.size.set(sizeX, sizeY);
            const fillId = serialized[6];
            if (fillId != null) {
                shape.fill.deserialize(fillId, manager);
            }
            const state = (_c = serialized[7]) !== null && _c !== void 0 ? _c : 1;
            shape.state.set(EShapeLayerState.INTERACTIVE, !!(state & 0x1));
            shape.state.set(EShapeLayerState.DRAGGABLE, !!(state & 0x2));
            shape.state.set(EShapeLayerState.PINCHABLE, !!(state & 0x4));
            return result;
        }
        static deserializeName(target, manager) {
            if (isString(target)) {
                return target;
            }
            else {
                const resources = manager.resources;
                if (0 <= target && target <= resources.length) {
                    return resources[target];
                }
                return "";
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramLayerContainer extends pixi_js.Container {
        constructor(width, height) {
            super();
            this._active = null;
            this._width = width;
            this._height = height;
            this.interactive = false;
            this.interactiveChildren = false;
        }
        init() {
            if (this._active == null) {
                const children = this.children;
                const childrenLength = children.length;
                if (0 < childrenLength) {
                    this._active = children[childrenLength - 1];
                }
            }
        }
        get active() {
            return this._active;
        }
        set active(layer) {
            if (this._active !== layer && (layer == null || 0 <= this.children.indexOf(layer))) {
                this._active = layer;
                this.onLayerChange();
            }
        }
        create(name, activate) {
            const result = new DDiagramLayer(name);
            this.attach(result, activate);
            return result;
        }
        /**
         * Adds the specified layer and activates it if the `activate` is true.
         *
         * @param layer
         * @param activate
         */
        attach(layer, activate) {
            this.addChild(layer);
            if (activate === true) {
                this._active = layer;
            }
            this.onLayerChange();
            DApplications.update(this);
        }
        attachAt(layer, index, activate) {
            this.addChildAt(layer, index);
            if (activate === true) {
                this._active = layer;
            }
            this.onLayerChange();
            DApplications.update(this);
        }
        /**
         * Removes the specified layer from this container and activates the specified layer.
         * This method does not destroy the secified layer.
         *
         * @param layer
         */
        detach(layer, active) {
            const children = this.children;
            const index = children.indexOf(layer);
            if (0 <= index) {
                this._active = active;
                children.splice(index, 1);
                layer.parent = undefined;
                this.onLayerChange();
                DApplications.update(this);
            }
        }
        /**
         * Removes the specified layer and activate the next layer.
         * This method does not destroy the specified layer.
         *
         * @param layer
         * @param activateNext
         */
        delete(layer, activateNext) {
            const children = this.children;
            const index = children.indexOf(layer);
            if (0 <= index) {
                children.splice(index, 1);
                layer.parent = undefined;
                if (this._active === layer) {
                    if (activateNext === true) {
                        if (index < children.length) {
                            this._active = children[index];
                        }
                        else if (0 < children.length) {
                            this._active = children[index - 1];
                        }
                        else {
                            this._active = null;
                        }
                    }
                    else {
                        this._active = null;
                    }
                }
                this.onLayerChange();
                DApplications.update(this);
            }
            return index;
        }
        get(index) {
            const child = this.children[index];
            if (child != null) {
                return child;
            }
            return null;
        }
        clear() {
            const children = this.children;
            if (0 < children.length) {
                for (let i = children.length - 1; 0 <= i; --i) {
                    const child = children[i];
                    child.parent = null;
                    child.destroy();
                }
                children.length = 0;
                this.onLayerChange();
                DApplications.update(this);
            }
        }
        destroy() {
            if (!this._destroyed) {
                this.clear();
                super.destroy();
            }
        }
        size() {
            return this.children.length;
        }
        onLayerChange() {
            this.emit("change", this);
        }
        serialize(manager, items) {
            const result = [];
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].addUuid(manager);
            }
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].updateUuid(manager);
            }
            for (let i = 0, imax = children.length; i < imax; ++i) {
                result.push(children[i].serialize(i, manager, items));
            }
            return result;
        }
        deserialize(serializedLayers, manager) {
            const serializedLayersLength = serializedLayers.length;
            if (0 < serializedLayersLength) {
                const width = this._width;
                const height = this._height;
                for (let i = 0; i < serializedLayersLength; ++i) {
                    this.addChild(DDiagramLayer.deserialize(serializedLayers[i], manager, width, height));
                }
                this.onLayerChange();
                DApplications.update(this);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasBase extends DCanvas {
        constructor(options) {
            var _a, _b, _c, _d;
            super(options);
            // Background
            const theme = this.theme;
            if (!this.isAmbient(theme, options)) {
                this._background = new DDiagramCanvasEditorBackground(this._background, this.toBackgroundBase(theme, options));
            }
            // Layer
            const layer = new DDiagramLayerContainer(this.width, this.height);
            this._layer = layer;
            this.addChild(layer);
            // Label, Category, Summary and Description
            if (options != null) {
                this._label = (_a = options.label) !== null && _a !== void 0 ? _a : "";
                this._category = (_b = options.category) !== null && _b !== void 0 ? _b : null;
                this._summary = (_c = options.summary) !== null && _c !== void 0 ? _c : "";
                this._description = (_d = options.description) !== null && _d !== void 0 ? _d : "";
            }
            else {
                this._label = "";
                this._category = null;
                this._summary = "";
                this._description = "";
            }
            // Tile
            const tile = new DDiagramCanvasTile(this, options === null || options === void 0 ? void 0 : options.tile);
            this._tile = tile;
            tile.init();
            // Local bounds limit
            this._localBoundsLimit = theme.getLocalBoundsLimit();
        }
        isAmbient(theme, options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.ambient) !== null && _a !== void 0 ? _a : theme.isAmbient();
        }
        toBackgroundBase(theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.background) === null || _a === void 0 ? void 0 : _a.base) !== null && _b !== void 0 ? _b : theme.getBackgroundBase();
        }
        get label() {
            return this._label;
        }
        set label(label) {
            this._label = label;
        }
        get category() {
            return this._category;
        }
        set category(category) {
            this._category = category;
        }
        get summary() {
            return this._summary;
        }
        set summary(summary) {
            this._summary = summary;
        }
        get description() {
            return this._description;
        }
        set description(description) {
            this._description = description;
        }
        get tile() {
            return this._tile;
        }
        get layer() {
            return this._layer;
        }
        initialize(shapes, mapper) {
            // DO NOTHING
        }
        destroy() {
            if (!this._destroyed) {
                this.onDestroy();
                super.destroy();
            }
        }
        onDestroy() {
            this._tile.destroy();
            this._layer.destroy();
        }
        hitTest(global, onHit) {
            const layers = this._layer.children;
            for (let i = layers.length - 1; 0 <= i; --i) {
                const layer = layers[i];
                if (layer.visible) {
                    const shape = layer.hitTest(global, onHit);
                    if (shape != null) {
                        return shape;
                    }
                }
            }
            return null;
        }
        getLocalBounds(result) {
            var _a, _b;
            var _c;
            if (result == null) {
                result = ((_a = (_c = this)._localBoundsRect) !== null && _a !== void 0 ? _a : (_c._localBoundsRect = new pixi_js.Rectangle()));
            }
            result.x = 0;
            result.y = 0;
            result.width = this.width;
            result.height = this.height;
            const limit = this._localBoundsLimit;
            if (limit === 0) {
                return result;
            }
            const layers = this.layer.children;
            const layersLength = layers.length;
            const work = ((_b = DDiagramCanvasBase.WORK_LOCAL_BOUNDS) !== null && _b !== void 0 ? _b : (DDiagramCanvasBase.WORK_LOCAL_BOUNDS = new pixi_js.Rectangle()));
            if (0 < limit) {
                let shapeCount = 0;
                for (let i = 0; i < layersLength; ++i) {
                    const layer = layers[i];
                    const p = layer.transform.position;
                    work.x = p.x;
                    work.y = p.y;
                    work.width = layer.width;
                    work.height = layer.height;
                    result.enlarge(work);
                    shapeCount += layer.children.length;
                }
                if (limit < shapeCount) {
                    return result;
                }
                for (let i = 0; i < layersLength; ++i) {
                    const layer = layers[i];
                    const p = layer.transform.position;
                    const px = p.x;
                    const py = p.y;
                    const shapes = layer.children;
                    for (let j = 0, jmax = shapes.length; j < jmax; ++j) {
                        const shape = shapes[j];
                        shape.getBoundsInternal(true, work);
                        work.x += px;
                        work.y += py;
                        result.enlarge(work);
                    }
                }
            }
            else {
                for (let i = 0; i < layersLength; ++i) {
                    const layer = layers[i];
                    const p = layer.transform.position;
                    const px = p.x;
                    const py = p.y;
                    work.x = px;
                    work.y = py;
                    work.width = layer.width;
                    work.height = layer.height;
                    result.enlarge(work);
                    const shapes = layer.children;
                    for (let j = 0, jmax = shapes.length; j < jmax; ++j) {
                        const shape = shapes[j];
                        shape.getBoundsInternal(true, work);
                        work.x += px;
                        work.y += py;
                        result.enlarge(work);
                    }
                }
            }
            return result;
        }
        getType() {
            return "DDiagramCanvasBase";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeRuntimes = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasDataImpl {
        get private() {
            let result = this._private;
            if (result == null) {
                result = this.newPrivate();
                this._private = result;
            }
            return result;
        }
        newPrivate() {
            return new EShapeDataScopedImpl();
        }
        get protected() {
            let result = this._protected;
            if (result == null) {
                result = this.newProtected();
                this._protected = result;
            }
            return result;
        }
        newProtected() {
            return new EShapeDataScopedImpl();
        }
        get extended() {
            let result = this._extended;
            if (result == null) {
                result = this.newExtended();
                this._extended = result;
            }
            return result;
        }
        newExtended() {
            return new EShapeDataScopedImpl();
        }
        get ids() {
            const data = this._data;
            if (data == null) {
                return [];
            }
            const result = [];
            data.forEach((value, id) => {
                result.push(id);
            });
            return result;
        }
        each(iteratee) {
            const data = this._data;
            if (data == null) {
                return null;
            }
            let result = null;
            data.forEach((value, id) => {
                if (result == null) {
                    if (iteratee(id) === false) {
                        result = id;
                    }
                }
            });
            return result;
        }
        add(id, value) {
            var _a;
            const data = ((_a = this._data) !== null && _a !== void 0 ? _a : (this._data = new Map()));
            const list = data.get(id);
            if (list == null) {
                data.set(id, [value]);
            }
            else {
                list.push(value);
            }
        }
        set(id, value, time, state, from, to) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                const datumValue = datum[i];
                const range = datumValue.range;
                // Range
                range.set(from, to);
                // Time
                if (time !== undefined) {
                    datumValue.time = time;
                }
                // State
                if (state !== undefined) {
                    datumValue.state = state;
                }
                // Value
                if (value !== undefined) {
                    datumValue.value = value;
                }
            }
            return true;
        }
        get(id) {
            const data = this._data;
            if (data == null) {
                return null;
            }
            const datum = data.get(id);
            if (datum == null) {
                return null;
            }
            return datum;
        }
        clear(id) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                datum[i].clear();
            }
            return true;
        }
        toDirty(id) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                datum[i].toDirty();
            }
            return true;
        }
        setAll(id, values, times, states, from, to) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                const datumValue = datum[i];
                const range = datumValue.range;
                // Range
                range.set(from, to);
                // Time
                if (times !== undefined) {
                    datumValue.times = times;
                }
                // State
                if (states !== undefined) {
                    datumValue.states = states;
                }
                // Value
                if (values !== undefined) {
                    datumValue.values = values;
                }
            }
            return true;
        }
        setValue(id, value) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                datum[i].value = value;
            }
            return true;
        }
        setValues(id, values) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                datum[i].values = values;
            }
            return true;
        }
        setTime(id, time) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                datum[i].time = time;
            }
            return true;
        }
        setTimes(id, times) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                datum[i].times = times;
            }
            return true;
        }
        setState(id, state) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                datum[i].state = state;
            }
            return true;
        }
        setStates(id, states) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                datum[i].states = states;
            }
            return true;
        }
        setRange(id, from, to) {
            const data = this._data;
            if (data == null) {
                return false;
            }
            const datum = data.get(id);
            if (datum == null) {
                return false;
            }
            const size = datum.length;
            if (size <= 0) {
                return false;
            }
            for (let i = 0; i < size; ++i) {
                const range = datum[i].range;
                if (from !== undefined) {
                    if (from !== null) {
                        range.type |= EShapeDataValueRangeType.FROM;
                        range.from = from;
                    }
                    else {
                        range.type &= ~EShapeDataValueRangeType.FROM;
                    }
                }
                if (to !== undefined) {
                    if (to !== null) {
                        range.type |= EShapeDataValueRangeType.TO;
                        range.to = to;
                    }
                    else {
                        range.type &= ~EShapeDataValueRangeType.TO;
                    }
                }
            }
            return true;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasBaseShapeImpl {
        constructor(canvas) {
            this._canvas = canvas;
        }
        each(iteratee, ignoreCapability) {
            const canvas = this._canvas;
            const layers = canvas.layer.children;
            for (let i = 0, imax = layers.length; i < imax; ++i) {
                if (this.each_(layers[i].children, iteratee, ignoreCapability) === false) {
                    break;
                }
            }
            return this;
        }
        each_(shapes, iteratee, ignoreCapability) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (iteratee(shape) === false) {
                    return false;
                }
                if (ignoreCapability || EShapeCapabilities.contains(shape, EShapeCapability.CHILDREN)) {
                    const children = shape.children;
                    if (0 < children.length) {
                        if (this.each_(children, iteratee, ignoreCapability) === false) {
                            return false;
                        }
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasShapeImpl extends DDiagramCanvasBaseShapeImpl {
        constructor(canvas) {
            super(canvas);
            this._data = new Map();
        }
        add(id, shape) {
            const data = this._data;
            const shapes = data.get(id);
            if (shapes == null) {
                data.set(id, [shape]);
            }
            else {
                shapes.push(shape);
            }
        }
        get(id) {
            const shapes = this._data.get(id);
            if (shapes && 0 < shapes.length) {
                return shapes[0];
            }
            return null;
        }
        getAll(id) {
            return this._data.get(id) || [];
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramTicker {
        constructor(parent, interval) {
            this._parent = parent;
            this._values = [];
            this._interval = interval;
            this._onTimeBound = () => {
                this.onTime();
            };
        }
        add(value) {
            this._values.push(value);
        }
        start() {
            if (this._timeoutId == null) {
                this.onTime();
            }
        }
        getInterval() {
            const now = Date.now();
            const interval = this._interval;
            return Math.max(0, interval - (now % interval));
        }
        onTime() {
            const values = this._values;
            if (0 < values.length) {
                const t = Date.now() / this._interval;
                for (let i = 0, imax = values.length; i < imax; ++i) {
                    values[i].value = t;
                }
                DApplications.update(this._parent);
            }
            this._timeoutId = window.setTimeout(this._onTimeBound, this.getInterval());
        }
        stop() {
            const timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
                this._timeoutId = undefined;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasTickerImpl {
        constructor(parent) {
            this._parent = parent;
            this._data = new Map();
        }
        add(interval) {
            const data = this._data;
            const normalized = this.toNormalized(interval);
            const ticker = data.get(normalized);
            if (ticker != null) {
                return ticker;
            }
            const newTicker = new DDiagramTicker(this._parent, normalized);
            data.set(normalized, newTicker);
            return newTicker;
        }
        toNormalized(interval) {
            return isNumber(interval) ? Math.max(1, Math.round(interval)) : 1000;
        }
        start() {
            this._data.forEach((ticker) => {
                ticker.start();
            });
        }
        stop() {
            this._data.forEach((ticker) => {
                ticker.stop();
            });
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeDataValueExtensions {
        static add(extension) {
            var _a, _b, _c;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._idToDatum) !== null && _b !== void 0 ? _b : (this._idToDatum = new Map())).set(extension.id, extension);
            ((_c = this._data) !== null && _c !== void 0 ? _c : (this._data = [])).push(extension);
        }
        static get(type) {
            const typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        }
        static getById(id) {
            const idToDatum = this._idToDatum;
            if (idToDatum != null) {
                return idToDatum.get(id);
            }
        }
        static each(iteratee) {
            const data = this._data;
            if (data != null) {
                for (let i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        }
    }

    class EShapeActionRuntimes {
        static add(type, runtime) {
            let typeToRuntimes = this._typeToRuntimes;
            if (typeToRuntimes == null) {
                typeToRuntimes = new Map();
                this._typeToRuntimes = typeToRuntimes;
            }
            let runtimes = typeToRuntimes.get(type);
            if (runtimes == null) {
                runtimes = [runtime];
                typeToRuntimes.set(type, runtimes);
            }
            else {
                runtimes.push(runtime);
            }
        }
        static get(type) {
            const typeToRuntimes = this._typeToRuntimes;
            if (typeToRuntimes != null) {
                return typeToRuntimes.get(type);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const INITIAL_ZERO = "0";
    const INITIAL_ARRAY = "[]";
    const INITIAL_STRING = '""';
    const INITIAL_OBJECT = "{}";
    const INITIAL_FALSE = "false";
    const INITIALIZER_ZERO = () => {
        return 0;
    };
    const INITIALIZER_ARRAY = () => {
        return [];
    };
    const INITIALIZER_STRING = () => {
        return "";
    };
    const INITIALIZER_OBJECT = () => {
        return {};
    };
    const INITIALIZER_FALSE = () => {
        return false;
    };
    class DDiagramCanvas extends DDiagramCanvasBase {
        constructor(options) {
            super(options);
            this._data = new DDiagramCanvasDataImpl();
            this._shape = new DDiagramCanvasShapeImpl(this);
            this._ticker = new DDiagramCanvasTickerImpl(this);
            this._actionables = [];
            this._downeds = new Set();
            this._updateBound = () => {
                DApplications.update(this);
            };
        }
        get data() {
            return this._data;
        }
        get shape() {
            return this._shape;
        }
        get ticker() {
            return this._ticker;
        }
        initialize(shapes, mapper) {
            const actionables = this._actionables;
            const data = this._data;
            this.initialize_(shapes, null, null, mapper, new Map(), new Map(), new Map(), this._ticker, this._shape, data, actionables);
            const layers = this._layer.children;
            const layersLength = layers.length;
            for (let i = 0; i < layersLength; ++i) {
                layers[i].initialize(actionables);
            }
            EShapeActionEnvironment.isInitializing = true;
            const time = Date.now();
            for (let i = 0; i < layersLength; ++i) {
                layers[i].update(time);
            }
            EShapeActionEnvironment.isInitializing = false;
            data.extended.each((id) => {
                const extension = EShapeDataValueExtensions.getById(id);
                if (extension) {
                    const start = extension.start;
                    if (start) {
                        start(this);
                    }
                }
            });
            this._ticker.start();
        }
        initialize_(shapes, dataShape, containerShape, mapper, formatters, initializers, actionValueToRuntime, canvasTicker, canvasShape, canvasData, actionables) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                // ID
                const id = shape.id;
                if (0 < id.length) {
                    canvasShape.add(id, shape);
                }
                // Data
                this.initData(shape, dataShape, containerShape, mapper, formatters, initializers, canvasTicker, canvasData);
                // Runtime
                const runtime = new (EShapeRuntimes[shape.type] || EShapeRuntimeImpl)(shape);
                shape.runtime = runtime;
                // Action
                this.initActions(shape, runtime, actionValueToRuntime);
                // Init the runtime
                runtime.initialize(shape);
                // Shortcut
                const shortcut = shape.shortcut;
                if (shortcut != null) {
                    UtilKeyboardEvent.on(shape, shortcut, (e) => {
                        runtime.onClick(shape, e);
                    });
                }
                // Actionables
                if (runtime.isActionable()) {
                    actionables.push(shape);
                }
                // Children
                const children = shape.children;
                if (0 < children.length) {
                    let newDataShape = dataShape;
                    let newContainerShape = containerShape;
                    if (shape instanceof EShapeEmbedded) {
                        if (newDataShape == null) {
                            newDataShape = shape;
                        }
                        newContainerShape = shape;
                    }
                    this.initialize_(children, newDataShape, newContainerShape, mapper, formatters, initializers, actionValueToRuntime, canvasTicker, canvasShape, canvasData, actionables);
                }
            }
        }
        initData(shape, dataShape, containerShape, mapper, formatters, initializers, canvasTicker, canvasData) {
            const data = shape.data;
            for (let i = 0, imax = data.size(); i < imax; ++i) {
                const value = data.get(i);
                if (value == null) {
                    continue;
                }
                switch (value.type) {
                    case EShapeDataValueType.BOOLEAN:
                    case EShapeDataValueType.BOOLEAN_ARRAY:
                    case EShapeDataValueType.NUMBER:
                    case EShapeDataValueType.NUMBER_ARRAY:
                    case EShapeDataValueType.STRING:
                    case EShapeDataValueType.STRING_ARRAY:
                    case EShapeDataValueType.OBJECT:
                    case EShapeDataValueType.OBJECT_ARRAY:
                        this.initDataValue(value, shape, dataShape, containerShape, mapper, formatters, initializers, canvasData);
                        break;
                    case EShapeDataValueType.TICKER:
                        this.initDataTicker(value, initializers, canvasTicker);
                        break;
                    default:
                        this.initDataExtension(value, canvasData);
                        break;
                }
            }
        }
        initDataValue(value, shape, dataShape, containerShape, mapper, formatters, initializers, canvasData) {
            // Mapping
            if (value.scope === EShapeDataValueScope.PRIVATE) {
                const id = value.id;
                if (0 < id.length) {
                    if (containerShape) {
                        containerShape.data.private.add(id, value);
                    }
                    else {
                        canvasData.private.add(id, value);
                    }
                }
            }
            else if (value.scope === EShapeDataValueScope.PROTECTED) {
                const id = value.id;
                if (0 < id.length) {
                    canvasData.protected.add(id, value);
                }
            }
            else {
                if (mapper) {
                    mapper(value, dataShape || shape);
                }
                const id = value.id;
                if (0 < id.length) {
                    canvasData.add(id, value);
                }
            }
            // Format
            const format = value.format;
            const initial = value.initial;
            let formatToFormatter = formatters.get(value.type);
            if (formatToFormatter == null) {
                formatToFormatter = new Map();
                formatters.set(value.type, formatToFormatter);
            }
            const oldFormatter = formatToFormatter.get(format);
            if (oldFormatter != null) {
                value.formatter = oldFormatter;
            }
            else if (0 < format.length) {
                const newFormatter = this.calcFormatter(value, format, initial);
                formatToFormatter.set(format, newFormatter);
                value.formatter = newFormatter;
            }
            // Initial
            let initialToInitializer = initializers.get(value.type);
            if (initialToInitializer == null) {
                initialToInitializer = new Map();
                initializers.set(value.type, initialToInitializer);
            }
            const oldInitializer = initialToInitializer.get(initial);
            if (oldInitializer != null) {
                value.value = oldInitializer();
            }
            else {
                const newInitializer = this.calcInitial(value, initial);
                initialToInitializer.set(initial, newInitializer);
                value.value = newInitializer();
            }
        }
        initDataTicker(value, initializers, canvasTicker) {
            const initial = value.initial;
            let initialToInitializer = initializers.get(value.type);
            if (initialToInitializer == null) {
                initialToInitializer = new Map();
                initializers.set(value.type, initialToInitializer);
            }
            const oldInitializer = initialToInitializer.get(initial);
            if (oldInitializer !== undefined) {
                value.value = 0;
                canvasTicker.add(oldInitializer()).add(value);
            }
            else {
                const newInitializer = this.calcInitial(value, initial);
                initialToInitializer.set(initial, newInitializer);
                value.value = 0;
                canvasTicker.add(newInitializer()).add(value);
            }
        }
        initDataExtension(value, canvasData) {
            const extension = EShapeDataValueExtensions.get(value.type);
            if (extension) {
                canvasData.extended.add(extension.id, value);
                value.value = extension.initial;
            }
        }
        initActions(shape, shapeRuntime, valueToRuntime) {
            const values = shape.action.values;
            const runtimes = shapeRuntime.actions;
            const typeRuntimes = EShapeActionRuntimes.get(shape.type);
            if (typeRuntimes != null) {
                for (let i = 0, imax = typeRuntimes.length; i < imax; ++i) {
                    const typeRuntime = typeRuntimes[i];
                    runtimes.push(typeRuntime);
                    shapeRuntime.reset |= typeRuntime.reset;
                }
            }
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                let runtime = valueToRuntime.get(value);
                if (runtime == null) {
                    runtime = value.toRuntime();
                    if (runtime != null) {
                        valueToRuntime.set(value, runtime);
                        runtimes.push(runtime);
                        shapeRuntime.reset |= runtime.reset;
                    }
                }
                else {
                    runtimes.push(runtime);
                    shapeRuntime.reset |= runtime.reset;
                }
            }
        }
        calcFormatter(value, format, initial) {
            const def = this.toInitial(value);
            try {
                return Function("value", 
                /* eslint-disable prettier/prettier */
                `try {` +
                    `return (${format});` +
                    `} catch( e1 ) {` +
                    `try {` +
                    `return (${0 < initial.length ? initial : def});` +
                    `} catch( e2 ) {` +
                    `return ${def};` +
                    `}` +
                    `}`
                /* eslint-enable prettier/prettier */
                );
            }
            catch (e) {
                return this.toInitializer(value);
            }
        }
        calcInitial(value, initial) {
            if (initial.length <= 0) {
                return this.toInitializer(value);
            }
            try {
                return Function(
                /* eslint-disable prettier/prettier */
                `try {` +
                    `return (${initial});` +
                    `} catch( e ) {` +
                    `return ${this.toInitial(value)};` +
                    `}`
                /* eslint-enable prettier/prettier */
                );
            }
            catch (e) {
                return this.toInitializer(value);
            }
        }
        toInitial(value) {
            const valueType = value.type;
            switch (valueType) {
                case EShapeDataValueType.BOOLEAN:
                    return INITIAL_FALSE;
                case EShapeDataValueType.BOOLEAN_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.NUMBER:
                    return INITIAL_ZERO;
                case EShapeDataValueType.NUMBER_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.STRING:
                    return INITIAL_STRING;
                case EShapeDataValueType.STRING_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.OBJECT:
                    return INITIAL_OBJECT;
                case EShapeDataValueType.OBJECT_ARRAY:
                    return INITIAL_ARRAY;
                case EShapeDataValueType.TICKER:
                    return INITIAL_ZERO;
                default:
                    return INITIAL_ZERO;
            }
        }
        toInitializer(value) {
            const valueType = value.type;
            switch (valueType) {
                case EShapeDataValueType.BOOLEAN:
                    return INITIALIZER_FALSE;
                case EShapeDataValueType.BOOLEAN_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.NUMBER:
                    return INITIALIZER_ZERO;
                case EShapeDataValueType.NUMBER_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.STRING:
                    return INITIALIZER_STRING;
                case EShapeDataValueType.STRING_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.OBJECT:
                    return INITIALIZER_OBJECT;
                case EShapeDataValueType.OBJECT_ARRAY:
                    return INITIALIZER_ARRAY;
                case EShapeDataValueType.TICKER:
                    return INITIALIZER_ZERO;
                default:
                    return INITIALIZER_ZERO;
            }
        }
        onDestroy() {
            this._data.extended.each((id) => {
                const extension = EShapeDataValueExtensions.getById(id);
                if (extension) {
                    const stop = extension.stop;
                    if (stop) {
                        stop(this);
                    }
                }
            });
            this._ticker.stop();
            super.onDestroy();
        }
        hitTestInteractives(global) {
            const layers = this._layer.children;
            for (let i = layers.length - 1; 0 <= i; --i) {
                const layer = layers[i];
                if (layer.visible) {
                    const result = layer.hitTestInteractives(global);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        }
        onShapeMove(e) {
            const found = this.hitTestInteractives(e.data.global);
            // Cursor
            this.cursor = this._cursor = this.toShapeCursor(found);
            // TItle
            const layer = DApplications.getLayer(this);
            if (layer) {
                const title = this.toShapeTitle(found);
                const view = layer.view;
                if (view.title !== title) {
                    view.title = title;
                }
            }
            const overed = this._overed;
            this._overed = found;
            if (found === overed) {
                if (found != null) {
                    const runtime = found.runtime;
                    if (runtime) {
                        runtime.onMove(found, e);
                    }
                }
            }
            else {
                this.onShapeOut(e, overed, found);
                this.onShapeOver(e, found);
            }
            return found != null;
        }
        toShapeCursor(target) {
            if (target != null) {
                let current = target;
                while (true) {
                    const cursor = current.cursor;
                    if (cursor != null && 0 < cursor.length) {
                        return cursor;
                    }
                    const parent = current.parent;
                    if (parent instanceof EShapeBase) {
                        current = parent;
                    }
                    else {
                        break;
                    }
                }
            }
            return "auto";
        }
        toShapeTitle(target) {
            if (target != null) {
                let current = target;
                while (true) {
                    const title = current.title;
                    if (title != null && 0 < title.length) {
                        return title;
                    }
                    const parent = current.parent;
                    if (parent instanceof EShapeBase) {
                        current = parent;
                    }
                    else {
                        break;
                    }
                }
            }
            return "";
        }
        onShapeOut(e, target, except) {
            while (target != null && target !== except && target instanceof EShapeBase) {
                const runtime = target.runtime;
                if (runtime) {
                    runtime.onOut(target, e);
                }
                target = target.parent;
            }
        }
        onShapeOver(e, target, except) {
            while (target != null && target !== except && target instanceof EShapeBase) {
                const runtime = target.runtime;
                if (runtime) {
                    runtime.onOver(target, e);
                }
                target = target.parent;
            }
        }
        onShapeDown(e) {
            const found = this.hitTestInteractives(e.data.global);
            this._downed = found;
            if (found) {
                this._downeds.add(found);
                let target = found;
                while (true) {
                    const runtime = target.runtime;
                    if (runtime) {
                        runtime.onDown(target, e);
                    }
                    const parent = target.parent;
                    if (parent instanceof EShapeBase) {
                        target = parent;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        }
        onShapeUp(e) {
            const downeds = this._downeds;
            const found = this.hitTestInteractives(e.data.global);
            if (found) {
                downeds.delete(found);
                let target = found;
                while (true) {
                    const runtime = target.runtime;
                    if (runtime) {
                        runtime.onUp(target, e);
                    }
                    const parent = target.parent;
                    if (parent instanceof EShapeBase) {
                        target = parent;
                    }
                    else {
                        break;
                    }
                }
            }
            this.onShapeCancel(e);
            return found != null;
        }
        onShapeCancel(e) {
            const downeds = this._downeds;
            if (0 < downeds.size) {
                downeds.forEach((downed) => {
                    let target = downed;
                    while (true) {
                        const runtime = target.runtime;
                        if (runtime) {
                            runtime.onUpOutside(target, e);
                        }
                        const parent = target.parent;
                        if (parent instanceof EShapeBase) {
                            target = parent;
                        }
                        else {
                            break;
                        }
                    }
                });
                downeds.clear();
                return true;
            }
            return false;
        }
        onShapeClick(e) {
            const found = this.hitTestInteractives(e.data.global);
            if (found && this._downed === found) {
                let target = found;
                while (true) {
                    const runtime = target.runtime;
                    if (runtime) {
                        runtime.onClick(target, e);
                    }
                    const parent = target.parent;
                    if (parent instanceof EShapeBase) {
                        target = parent;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        }
        onShapeDblClick(e, interactionManager) {
            var _a;
            const global = ((_a = DDiagramCanvas.WORK_DBLCLICK) !== null && _a !== void 0 ? _a : (DDiagramCanvas.WORK_DBLCLICK = new pixi_js.Point()));
            UtilPointerEvent.toGlobal(e, interactionManager, global);
            const found = this.hitTestInteractives(global);
            if (found) {
                let target = found;
                while (true) {
                    const runtime = target.runtime;
                    if (runtime) {
                        runtime.onDblClick(target, e, interactionManager);
                    }
                    const parent = target.parent;
                    if (parent instanceof EShapeBase) {
                        target = parent;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        }
        onShapeRightClick(e) {
            const found = this.hitTestInteractives(e.data.global);
            if (found && this._downed === found) {
                let target = found;
                while (true) {
                    const runtime = target.runtime;
                    if (runtime) {
                        runtime.onRightClick(target, e);
                    }
                    const parent = target.parent;
                    if (parent instanceof EShapeBase) {
                        target = parent;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        }
        onShapeRightDown(e) {
            const found = this.hitTestInteractives(e.data.global);
            this._downed = found;
            if (found) {
                this._downeds.add(found);
                let target = found;
                while (true) {
                    const runtime = target.runtime;
                    if (runtime) {
                        runtime.onRightDown(target, e);
                    }
                    const parent = target.parent;
                    if (parent instanceof EShapeBase) {
                        target = parent;
                    }
                    else {
                        break;
                    }
                }
                return true;
            }
            return false;
        }
        onShapeRightUp(e) {
            const downeds = this._downeds;
            const found = this.hitTestInteractives(e.data.global);
            if (found) {
                downeds.delete(found);
                let target = found;
                while (true) {
                    const runtime = target.runtime;
                    if (runtime) {
                        runtime.onRightUp(target, e);
                    }
                    const parent = target.parent;
                    if (parent instanceof EShapeBase) {
                        target = parent;
                    }
                    else {
                        break;
                    }
                }
            }
            this.onShapeRightCancel(e);
            return found != null;
        }
        onShapeRightCancel(e) {
            const downeds = this._downeds;
            if (0 < downeds.size) {
                downeds.forEach((downed) => {
                    let target = downed;
                    while (true) {
                        const runtime = target.runtime;
                        if (runtime) {
                            runtime.onRightUpOutside(target, e);
                        }
                        const parent = target.parent;
                        if (parent instanceof EShapeBase) {
                            target = parent;
                        }
                        else {
                            break;
                        }
                    }
                });
                downeds.clear();
                return true;
            }
            return false;
        }
        update() {
            const actionables = this._actionables;
            if (0 < actionables.length) {
                let effect = -1;
                const time = Date.now();
                for (let i = 0, imax = actionables.length; i < imax; ++i) {
                    const actionable = actionables[i];
                    actionable.update(time);
                    const runtime = actionable.runtime;
                    if (runtime) {
                        const runtimeEffect = runtime.effect;
                        if (0 <= runtimeEffect && time < runtimeEffect) {
                            effect = effect < 0 ? runtimeEffect : Math.min(effect, runtimeEffect);
                        }
                    }
                }
                if (0 <= effect) {
                    window.setTimeout(this._updateBound, effect - Date.now());
                }
            }
        }
        onRender(renderer) {
            const actionables = this._actionables;
            if (0 < actionables.length) {
                let effect = -1;
                const time = Date.now();
                for (let i = 0, imax = actionables.length; i < imax; ++i) {
                    const actionable = actionables[i];
                    actionable.onRender(time, renderer);
                    const runtime = actionable.runtime;
                    if (runtime) {
                        const runtimeEffect = runtime.effect;
                        if (0 <= runtimeEffect && time < runtimeEffect) {
                            effect = effect < 0 ? runtimeEffect : Math.min(effect, runtimeEffect);
                        }
                    }
                }
                if (0 <= effect) {
                    window.setTimeout(this._updateBound, effect - Date.now());
                }
            }
        }
        getType() {
            return "DDiagramCanvas";
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A shape helper class for diagrams.
     */
    class DDiagramShape extends pixi_js.utils.EventEmitter {
        constructor(diagram) {
            super();
            this._diagram = diagram;
            this._updateBound = () => {
                DApplications.update(diagram);
            };
        }
        update() {
            const canvas = this._diagram.canvas;
            if (canvas) {
                canvas.update();
            }
        }
        get(id) {
            const canvas = this._diagram.canvas;
            if (canvas) {
                return canvas.shape.get(id);
            }
            return null;
        }
        getAll(id) {
            const canvas = this._diagram.canvas;
            if (canvas) {
                return canvas.shape.getAll(id);
            }
            return [];
        }
        each(iteratee, reverse = false) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                const layers = canvas.layer.children;
                if (!reverse) {
                    for (let i = 0, imax = layers.length; i < imax; ++i) {
                        const layer = layers[i];
                        const children = layer.children;
                        for (let j = 0, jmax = children.length; j < jmax; ++j) {
                            const child = children[j];
                            if (iteratee(child) === false) {
                                return child;
                            }
                        }
                    }
                }
                else {
                    for (let i = layers.length - 1; 0 <= i; --i) {
                        const layer = layers[i];
                        const children = layer.children;
                        for (let j = children.length - 1; 0 <= j; --j) {
                            const child = children[j];
                            if (iteratee(child) === false) {
                                return child;
                            }
                        }
                    }
                }
            }
            return null;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramDataPrivateImpl {
        constructor(diagram) {
            this._diagram = diagram;
        }
        get ids() {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.ids;
            }
            return [];
        }
        set(id, value, time, state, from, to) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.set(id, value, time, state, from, to);
            }
            return false;
        }
        toDirty(id) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.toDirty(id);
            }
            return false;
        }
        each(iteratee) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.private.each(iteratee);
            }
            return null;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramDataProtectedImpl {
        constructor(diagram) {
            this._diagram = diagram;
        }
        get ids() {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.ids;
            }
            return [];
        }
        set(id, value, time, state, from, to) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.set(id, value, time, state, from, to);
            }
            return false;
        }
        toDirty(id) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.toDirty(id);
            }
            return false;
        }
        each(iteratee) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.protected.each(iteratee);
            }
            return null;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramDataRemoteImpl {
        constructor(options) {
            this._controller = options && options.controller;
        }
        set(id, value) {
            const controller = this._controller;
            if (controller) {
                controller.write(id, value);
                return true;
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramDataExtendedImpl {
        constructor(diagram) {
            this._diagram = diagram;
        }
        get ids() {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.ids;
            }
            return [];
        }
        set(id, value, time, state, from, to) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.set(id, value, time, state, from, to);
            }
            return false;
        }
        toDirty(id) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.toDirty(id);
            }
            return false;
        }
        each(iteratee) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.extended.each(iteratee);
            }
            return null;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A data helper class for diagrams.
     */
    class DDiagramDataImpl {
        constructor(diagram, options) {
            this._diagram = diagram;
            this._mapper = (options && options.mapper) || null;
            this._remote = new DDiagramDataRemoteImpl(options && options.remote);
            this._private = new DDiagramDataPrivateImpl(diagram);
            this._protected = new DDiagramDataProtectedImpl(diagram);
            this._extended = new DDiagramDataExtendedImpl(diagram);
        }
        update() {
            // DO NOTHING
        }
        get mapper() {
            return this._mapper;
        }
        set mapper(mapper) {
            this._mapper = mapper;
        }
        get remote() {
            return this._remote;
        }
        get private() {
            return this._private;
        }
        get protected() {
            return this._protected;
        }
        get extended() {
            return this._extended;
        }
        get ids() {
            const canvas = this._diagram.canvas;
            if (canvas) {
                return canvas.data.ids;
            }
            return [];
        }
        each(iteratee) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.each(iteratee);
            }
            return null;
        }
        set(id, value, time, state, from, to) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.set(id, value, time, state, from, to);
            }
            return false;
        }
        get(id) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.get(id);
            }
            return null;
        }
        clear(id) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.clear(id);
            }
            return false;
        }
        toDirty(id) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.toDirty(id);
            }
            return false;
        }
        setAll(id, values, times, states, from, to) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setAll(id, values, times, states, from, to);
            }
            return false;
        }
        setValue(id, value) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setValue(id, value);
            }
            return false;
        }
        setValues(id, values) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setValues(id, values);
            }
            return false;
        }
        setTime(id, time) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setTime(id, time);
            }
            return false;
        }
        setTimes(id, times) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setTimes(id, times);
            }
            return false;
        }
        setState(id, state) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setState(id, state);
            }
            return false;
        }
        setStates(id, states) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setStates(id, states);
            }
            return false;
        }
        setRange(id, from, to) {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                return canvas.data.setRange(id, from, to);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagram extends DDiagramBase {
        constructor(options) {
            super(options);
            // Event handlers
            this.on(UtilPointerEvent.move, (e) => {
                this.onShapeMove(e);
            });
            this.on(UtilPointerEvent.up, (e) => {
                this.onShapeUp(e);
            });
            this.on(UtilPointerEvent.upoutside, (e) => {
                this.onShapeCancel(e);
            });
            this.on(UtilPointerEvent.cancel, (e) => {
                this.onShapeCancel(e);
            });
            this.on(UtilPointerEvent.tap, (e) => {
                this.onShapeClick(e);
            });
            this.on(UtilPointerEvent.righttap, (e) => {
                this.onShapeRightClick(e);
            });
            this.on(UtilPointerEvent.rightdown, (e) => {
                this.onShapeRightDown(e);
            });
            this.on(UtilPointerEvent.rightup, (e) => {
                this.onShapeRightUp(e);
            });
            this.on(UtilPointerEvent.rightupoutside, (e) => {
                this.onShapeRightCancel(e);
            });
            // Data
            const data = new DDiagramDataImpl(this, options && (options.data || options.tag));
            this.data = data;
            this.tag = data;
            // Shape
            this.shape = new DDiagramShape(this);
        }
        initLayer(canvas, shapes, mapper) {
            return super.initLayer(canvas, shapes, mapper || this.data.mapper);
        }
        toMode(options) {
            return EShapeResourceManagerDeserializationMode.VIEWER;
        }
        newCanvas(serialized) {
            return new DDiagramCanvas(this.toCanvasOptions(serialized));
        }
        toCanvasOptions(serialized) {
            return this.toCanvasBaseOptions(serialized);
        }
        onDown(e) {
            const canvas = this.canvas;
            if (canvas) {
                const target = e.target;
                if (target === this || target === canvas) {
                    super.onDown(e, canvas.onShapeDown(e));
                }
                else {
                    super.onDown(e);
                }
            }
            else {
                super.onDown(e);
            }
        }
        onShapeMove(e) {
            const canvas = this.canvas;
            if (canvas) {
                const target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeMove(e);
                }
            }
        }
        onShapeUp(e) {
            const canvas = this.canvas;
            if (canvas) {
                const target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeUp(e);
                }
            }
        }
        onShapeCancel(e) {
            const canvas = this.canvas;
            if (canvas) {
                const target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeCancel(e);
                }
            }
        }
        onShapeClick(e) {
            const canvas = this.canvas;
            if (canvas) {
                const target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeClick(e);
                }
            }
        }
        onShapeRightClick(e) {
            const canvas = this.canvas;
            if (canvas) {
                const target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightClick(e);
                }
            }
        }
        onShapeRightDown(e) {
            const canvas = this.canvas;
            if (canvas) {
                const target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightDown(e);
                }
            }
        }
        onShapeRightUp(e) {
            const canvas = this.canvas;
            if (canvas) {
                const target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightUp(e);
                }
            }
        }
        onShapeRightCancel(e) {
            const canvas = this.canvas;
            if (canvas) {
                const target = e.target;
                if (target === this || target === canvas) {
                    canvas.onShapeRightCancel(e);
                }
            }
        }
        onDblClick(e, manager) {
            const canvas = this.canvas;
            if (canvas) {
                return super.onDblClick(e, manager, canvas.onShapeDblClick(e, manager));
            }
            else {
                return super.onDblClick(e, manager);
            }
        }
        onPrerender(renderer) {
            const canvas = this._canvas;
            if (canvas) {
                canvas.onRender(renderer);
            }
        }
        render(newRenderer) {
            var _a;
            const oldRenderer = this._rendererBound;
            if (oldRenderer !== newRenderer) {
                const onPrerenderBound = ((_a = this._onPrerenderBound) !== null && _a !== void 0 ? _a : (this._onPrerenderBound = (r) => {
                    this.onPrerender(r);
                }));
                if (oldRenderer != null) {
                    oldRenderer.off("prerender", onPrerenderBound);
                }
                this._rendererBound = newRenderer;
                if (newRenderer != null) {
                    newRenderer.on("prerender", onPrerenderBound);
                    const canvas = this._canvas;
                    if (canvas != null) {
                        // Request the update to call `canvas.onRender(Renderer)`
                        DApplications.update(this);
                    }
                }
            }
            super.render(newRenderer);
        }
        destroy() {
            // Renderer
            const renderer = this._rendererBound;
            if (renderer != null) {
                this._rendererBound = undefined;
                const onPrerenderBound = this._onPrerenderBound;
                if (onPrerenderBound != null) {
                    renderer.off("prerender", onPrerenderBound);
                }
            }
            super.destroy();
        }
        getType() {
            return "DDiagram";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActions {
        static isDiagram(target) {
            return target instanceof DDiagram;
        }
        static isEmbedded(target) {
            return target instanceof EShapeEmbedded;
        }
        static toDiagram(shape) {
            let current = shape;
            while (current != null) {
                if (this.isDiagram(current)) {
                    return current;
                }
                current = current.parent;
            }
            return null;
        }
        static open(shape, type, target, inNewWindow, environment) {
            const opener = EShapeActionOpenOpeners[type];
            if (opener != null) {
                const diagram = this.toDiagram(shape);
                if (diagram) {
                    opener(target, inNewWindow, shape, diagram, environment);
                }
            }
            else if (isString(target)) {
                switch (type) {
                    case DDiagramBaseControllerOpenType.DIAGRAM:
                        const diagram = this.toDiagram(shape);
                        if (diagram) {
                            const controller = diagram.controller;
                            if (controller) {
                                controller.getByName(target).then((found) => {
                                    diagram.set(DDiagrams.toSerialized(found));
                                });
                            }
                        }
                        break;
                    case DDiagramBaseControllerOpenType.PAGE:
                        if (inNewWindow) {
                            window.open(target);
                        }
                        else {
                            window.location.href = target;
                        }
                        break;
                }
            }
        }
        static writeLocal(shape, id, value, time, state = EShapeDataValueState.FOUND) {
            var _a;
            let current = shape;
            while (current != null) {
                if (this.isDiagram(current)) {
                    if (current.data.private.set(id, value, time, state)) {
                        DApplications.update(current);
                        return true;
                    }
                    else if (current.data.protected.set(id, value, time, state)) {
                        DApplications.update(current);
                        return true;
                    }
                    else {
                        if (current.data.set(id, value, time, state)) {
                            DApplications.update(current);
                            return true;
                        }
                    }
                    return false;
                }
                else if (this.isEmbedded(current)) {
                    if ((_a = current.data.getPrivate()) === null || _a === void 0 ? void 0 : _a.set(id, value, time, state)) {
                        DApplications.update(current);
                        return true;
                    }
                }
                current = current.parent;
            }
            return false;
        }
        static writeRemote(shape, id, value) {
            const diagram = this.toDiagram(shape);
            if (diagram) {
                return diagram.data.remote.set(id, value);
            }
            return false;
        }
        static emit(shape, name, value, time) {
            const diagram = EShapeActions.toDiagram(shape);
            if (time === undefined) {
                shape.emit(name, shape);
                if (diagram) {
                    diagram.shape.emit(name, shape);
                }
            }
            else {
                shape.emit(name, value, time, shape);
                if (diagram) {
                    diagram.shape.emit(name, value, time, shape);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeEmitEvent extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this.name = EShapeActionExpressions.ofStringOrNull(value.name);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const name = this.name(shape, time, EShapeActionEnvironment);
                if (name != null) {
                    EShapeActions.emit(shape, name);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueEmitEvent extends EShapeActionValueBase {
        constructor(condition, name) {
            super(EShapeActionValueType.EMIT_EVENT, condition);
            this.name = name;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueEmitEvent &&
                this.name === value.name);
        }
        toRuntime() {
            return new EShapeActionRuntimeEmitEvent(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const nameId = manager.addResource(this.name);
            return manager.addResource(`[${this.type},${conditionId},${nameId}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const name = EShapeActionValues.toResource(2, serialized, manager.resources);
            return new EShapeActionValueEmitEvent(condition, name);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscEmitEvent extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this.target = EShapeActionExpressions.ofStringOrNull(value.target);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const target = this.target(shape, time, EShapeActionEnvironment);
                if (target != null) {
                    EShapeActions.emit(shape, target);
                }
            }
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DHtmlElementState = {
        NO_POINTER_EVENTS: "NO_POINTER_EVENTS"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilHtmlElementClipperExImpl {
        constructor(container) {
            const SVG_XMLNS = "http://www.w3.org/2000/svg";
            const element = document.createElementNS(SVG_XMLNS, "svg");
            element.setAttribute("style", "position: absolute;");
            element.setAttribute("width", "0px");
            element.setAttribute("height", "0px");
            const defs = document.createElementNS(SVG_XMLNS, "defs");
            const clipPath = document.createElementNS(SVG_XMLNS, "clipPath");
            const clipPathId = `clipper_ex_${Math.random().toString(32).substring(2)}`;
            clipPath.setAttribute("id", clipPathId);
            clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
            const path = document.createElementNS(SVG_XMLNS, "path");
            this._path = path;
            this._pathD = "";
            path.setAttribute("clip-rule", "evenodd");
            clipPath.appendChild(path);
            defs.appendChild(clipPath);
            element.appendChild(defs);
            this._id = clipPathId;
            container.appendChild(element);
        }
        get id() {
            return this._id;
        }
        update(elementRect, elementMatrix, clipperExRects) {
            const d = this.toD(elementRect, elementMatrix, clipperExRects);
            if (this._pathD != d) {
                this._path.setAttribute("d", d);
                this._pathD = d;
            }
        }
        toD(elementRect, elementMatrix, clipperExRects) {
            var _a, _b;
            if (elementRect == null) {
                return "";
            }
            const w = elementRect.width;
            const h = elementRect.height;
            const threshold = 0.0001;
            if (w < threshold || h < threshold) {
                return "";
            }
            const clipperExRectsSize = clipperExRects.size;
            if (clipperExRectsSize <= 0) {
                return "M0,0 h1 v1 h-1z";
            }
            const matrix = ((_a = UtilHtmlElementClipperExImpl.WORK_MATRIX) !== null && _a !== void 0 ? _a : (UtilHtmlElementClipperExImpl.WORK_MATRIX = new pixi_js.Matrix()));
            if (elementMatrix != null) {
                matrix.copyFrom(elementMatrix);
                matrix.invert();
            }
            else {
                matrix.identity();
            }
            matrix.translate(-elementRect.x, -elementRect.y);
            matrix.scale(1 / w, 1 / h);
            let xmin = -1;
            let xmax = +2;
            let ymin = -1;
            let ymax = +2;
            let result = "";
            const a = matrix.a;
            const b = matrix.b;
            const c = matrix.c;
            const d = matrix.d;
            const tx = matrix.tx;
            const ty = matrix.ty;
            const rects = ((_b = UtilHtmlElementClipperExImpl.WORK_RECTS) !== null && _b !== void 0 ? _b : (UtilHtmlElementClipperExImpl.WORK_RECTS = []));
            const rectsLength = this.toRects(clipperExRects, rects);
            const precision = 5;
            for (let i = 0; i < rectsLength; i += 4) {
                const x0 = rects[i + 0];
                const y0 = rects[i + 1];
                const x1 = rects[i + 2];
                const y1 = rects[i + 3];
                const x2 = a * x0 + c * y0 + tx;
                const y2 = b * x0 + d * y0 + ty;
                const x3 = a * x1 + c * y0 + tx;
                const y3 = b * x1 + d * y0 + ty;
                const x4 = a * x1 + c * y1 + tx;
                const y4 = b * x1 + d * y1 + ty;
                const x5 = a * x0 + c * y1 + tx;
                const y5 = b * x0 + d * y1 + ty;
                xmin = Math.min(xmin, x2, x3, x4, x5);
                xmax = Math.max(xmax, x2, x3, x4, x5);
                ymin = Math.min(ymin, y2, y3, y4, y5);
                ymax = Math.max(ymax, y2, y3, y4, y5);
                const x2s = x2.toFixed(precision);
                const y2s = y2.toFixed(precision);
                const x3s = x3.toFixed(precision);
                const y3s = y3.toFixed(precision);
                const x4s = x4.toFixed(precision);
                const y4s = y4.toFixed(precision);
                const x5s = x5.toFixed(precision);
                const y5s = y5.toFixed(precision);
                result += ` M${x2s},${y2s} L${x3s},${y3s} L${x4s},${y4s} L${x5s},${y5s}Z`;
            }
            return `M${xmin},${ymin} L${xmax},${ymin} L${xmax},${ymax} L${xmin},${ymax}Z` + result;
        }
        toRects(clipperExRects, result) {
            const data = clipperExRects.data;
            const size = clipperExRects.size;
            // Copy all rectangles
            let imax = size << 2;
            for (let i = 0; i < imax; i += 4) {
                const x0 = data[i + 0];
                const y0 = data[i + 1];
                const x1 = data[i + 2];
                const y1 = data[i + 3];
                if (x0 < x1) {
                    result[i + 0] = x0;
                    result[i + 2] = x1;
                }
                else {
                    result[i + 0] = x1;
                    result[i + 2] = x0;
                }
                if (y0 < y1) {
                    result[i + 1] = y0;
                    result[i + 3] = y1;
                }
                else {
                    result[i + 1] = y1;
                    result[i + 3] = y0;
                }
            }
            // Subdivide all rectangles if they have intersections
            for (let i = 4; i < imax; i += 4) {
                let x0 = result[i + 0];
                let y0 = result[i + 1];
                let x1 = result[i + 2];
                let y1 = result[i + 3];
                for (let j = 0; j < i; j += 4) {
                    const x2 = result[j + 0];
                    const y2 = result[j + 1];
                    const x3 = result[j + 2];
                    const y3 = result[j + 3];
                    // Check if there are intersections along the X axis.
                    // Here, ix represents which edges of the i-th rectangle are in the j-th rectangle as follows:
                    //
                    // * 0: No edge is in the j-th rectangle,
                    // * 1: The left edge is in the j-th rectangle,
                    // * 2: The right edge is in the j-th rectangle, and
                    // * 3: Both edges are in the j-th rectangle.
                    //
                    // The same spplies to the variable jx.
                    let ix = 0;
                    let jx = 0;
                    if (x0 <= x2) {
                        if (x1 <= x3) {
                            if (x1 <= x2) {
                                // x0--x1
                                //         x2--x3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                // x0----x1
                                //    x2----x3
                                ix = 2;
                                jx = 1;
                            }
                        }
                        else {
                            // x0--------x1
                            //    x2--x3
                            jx = 3;
                        }
                    }
                    else {
                        if (x1 <= x3) {
                            //    x0--x1
                            // x2--------x3
                            ix = 3;
                        }
                        else {
                            if (x3 <= x0) {
                                //         x0--x1
                                // x2--x3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                //    x0----x1
                                // x2----x3
                                ix = 1;
                                jx = 2;
                            }
                        }
                    }
                    // Check if there are intersections along the Y axis.
                    //
                    // * 0: No edge is in a rectangle,
                    // * 1: The bottom edge is in a rectangle,
                    // * 2: The top edge is in a rectangle, and
                    // * 3: Both edges are in a rectangle.
                    let iy = 0;
                    let jy = 0;
                    if (y0 <= y2) {
                        if (y1 <= y3) {
                            if (y1 <= y2) {
                                // y0--y1
                                //         y2--y3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                // y0----y1
                                //    y2----y3
                                iy = 2;
                                jy = 1;
                            }
                        }
                        else {
                            // y0--------y1
                            //    y2--y3
                            jy = 3;
                        }
                    }
                    else {
                        if (y1 <= y3) {
                            //    y0--y1
                            // y2--------y3
                            iy = 3;
                        }
                        else {
                            if (y3 <= y0) {
                                //         y0--y1
                                // y2--y3
                                // In this case, there is no intersection.
                                continue;
                            }
                            else {
                                //    y0----y1
                                // y2----y3
                                iy = 1;
                                jy = 2;
                            }
                        }
                    }
                    // Count number of i-th rectangle vertices in j-th rectangle.
                    let ic = 0;
                    if (ix === 0 || iy === 0) {
                        ic = 0;
                    }
                    else if (ix === 1 || ix === 2) {
                        if (iy === 3) {
                            ic = 2;
                        }
                        else {
                            ic = 1;
                        }
                    }
                    else {
                        if (iy === 3) {
                            ic = 4;
                        }
                        else {
                            ic = 2;
                        }
                    }
                    // If all the vertices of the i-th rectangle are in j-th rectangle, remove the i-th rectangle.
                    if (ic === 4) {
                        if (i + 4 < imax) {
                            result[i + 0] = result[imax + 0];
                            result[i + 1] = result[imax + 1];
                            result[i + 2] = result[imax + 2];
                            result[i + 3] = result[imax + 3];
                        }
                        i -= 4;
                        imax -= 4;
                        break;
                    }
                    // Count number of j-th rectangle vertices in i-th rectangle.
                    let jc = 0;
                    if (jx === 0 || jy === 0) {
                        jc = 0;
                    }
                    else if (jx === 1 || jx === 2) {
                        if (jy === 3) {
                            jc = 2;
                        }
                        else {
                            jc = 1;
                        }
                    }
                    else {
                        if (jy === 3) {
                            jc = 4;
                        }
                        else {
                            jc = 2;
                        }
                    }
                    // If all the vertices of the j-th rectangle are in the i-th rectangle, remove the j-th rectangle.
                    if (jc === 4) {
                        for (let k = j + 4; k < imax; k += 4) {
                            result[k - 4] = result[k + 0];
                            result[k - 3] = result[k + 1];
                            result[k - 2] = result[k + 2];
                            result[k - 1] = result[k + 3];
                        }
                        i -= 4;
                        imax -= 4;
                        j -= 4;
                        continue;
                    }
                    // Other cases
                    if (ic === 0) {
                        if (jc === 0) {
                            for (let k = imax - 4; j < k; k -= 4) {
                                result[k + 4] = result[k + 0];
                                result[k + 5] = result[k + 1];
                                result[k + 6] = result[k + 2];
                                result[k + 7] = result[k + 3];
                            }
                            if (jx === 0) {
                                //      +-----+      y1
                                // +----|     |----+ y3
                                // | i  |  j  |    |
                                // +----|     |----+ y2
                                //      +-----+      y0
                                // x0   x2    x3   x1
                                result[j + 3] = y0;
                                result[j + 4] = x2;
                                result[j + 5] = y1;
                                result[j + 6] = x3;
                                result[j + 7] = y3;
                            }
                            else {
                                //      +-----+      y1
                                // +----|     |----+ y3
                                // | j  |  i  |    |
                                // +----|     |----+ y2
                                //      +-----+      y0
                                // x2   x0    x1   x3
                                result[j + 2] = x0;
                                result[j + 4] = x1;
                                result[j + 5] = y2;
                                result[j + 6] = x3;
                                result[j + 7] = y3;
                            }
                            i += 4;
                            imax += 4;
                            j += 4;
                        }
                        else if (jc === 2) {
                            if (jx === 1) {
                                // +---------+
                                // |         |-----+
                                // |    i    |  j  |
                                // |         |-----+
                                // +---------+
                                result[j + 0] = x1;
                            }
                            else if (jx === 2) {
                                //       +---------+
                                // +-----|         |
                                // |  j  |    i    |
                                // +-----|         |
                                //       +---------+
                                result[j + 2] = x0;
                            }
                            else if (jy === 1) {
                                //   +-----+
                                //   |  j  |
                                // +---------+
                                // |         |
                                // |    i    |
                                // |         |
                                // +---------+
                                result[j + 1] = y1;
                            }
                            else if (jy === 2) {
                                // +---------+
                                // |         |
                                // |    i    |
                                // |         |
                                // +---------+
                                //   |  j  |
                                //   +-----+
                                result[j + 3] = y0;
                            }
                        }
                    }
                    else if (ic === 1) {
                        for (let k = imax - 4; j < k; k -= 4) {
                            result[k + 4] = result[k + 0];
                            result[k + 5] = result[k + 1];
                            result[k + 6] = result[k + 2];
                            result[k + 7] = result[k + 3];
                        }
                        if (jx === 1) {
                            if (jy === 1) {
                                //         +---------+
                                //         |         |
                                //         |    j    |
                                // +---------+       |
                                // |         |-------+
                                // |    i    |
                                // |         |
                                // +---------+
                                result[j + 0] = x1;
                                result[j + 4] = x2;
                                result[j + 5] = y1;
                                result[j + 6] = x1;
                                result[j + 7] = y3;
                            }
                            else {
                                // +---------+
                                // |         |
                                // |    i    |
                                // |       +---------+
                                // +-------|         |
                                //         |    j    |
                                //         |         |
                                //         +---------+
                                result[j + 0] = x1;
                                result[j + 4] = x2;
                                result[j + 5] = y2;
                                result[j + 6] = x1;
                                result[j + 7] = y0;
                            }
                        }
                        else {
                            if (jy === 1) {
                                // +---------+
                                // |         |
                                // |    j    |
                                // |         |-------+
                                // +---------+       |
                                //         |    i    |
                                //         |         |
                                //         +---------+
                                result[j + 2] = x0;
                                result[j + 4] = x0;
                                result[j + 5] = y1;
                                result[j + 6] = x3;
                                result[j + 7] = y3;
                            }
                            else {
                                //         +---------+
                                //         |         |
                                //         |    i    |
                                // +---------+       |
                                // |         |-------+
                                // |    j    |
                                // |         |
                                // +---------+
                                result[j + 2] = x0;
                                result[j + 4] = x0;
                                result[j + 5] = y2;
                                result[j + 6] = x3;
                                result[j + 7] = y0;
                            }
                        }
                        i += 4;
                        imax += 4;
                        j += 4;
                    }
                    else if (ic === 2) {
                        if (ix === 1) {
                            // +---------+
                            // |         |-----+
                            // |    j    |  i  |
                            // |         |-----+
                            // +---------+
                            result[i + 0] = x3;
                            x0 = x3;
                        }
                        else if (ix === 2) {
                            //       +---------+
                            // +-----|         |
                            // |  i  |    j    |
                            // +-----|         |
                            //       +---------+
                            result[i + 2] = x2;
                            x1 = x2;
                        }
                        else if (iy === 1) {
                            //   +-----+
                            //   |  i  |
                            // +---------+
                            // |         |
                            // |    j    |
                            // |         |
                            // +---------+
                            result[i + 1] = y3;
                            y0 = y3;
                        }
                        else if (iy === 2) {
                            // +---------+
                            // |         |
                            // |    j    |
                            // |         |
                            // +---------+
                            //   |  i  |
                            //   +-----+
                            result[i + 3] = y2;
                            y1 = y2;
                        }
                    }
                }
            }
            return imax;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilHtmlElementClipperExRectsImpl {
        constructor() {
            this._data = [];
            this._size = 0;
            this._index = 0;
            this._isDirty = true;
        }
        get data() {
            return this._data;
        }
        get size() {
            return this._size;
        }
        isDirty() {
            return this._isDirty;
        }
        toClean() {
            this._isDirty = false;
        }
        begin() {
            this._index = 0;
            return this;
        }
        end() {
            const index = this._index;
            this._size = index;
            const data = this._data;
            const newDataLength = index << 2;
            if (data.length !== newDataLength) {
                data.length = newDataLength;
                this._isDirty = true;
            }
            return this;
        }
        add(x0, y0, x1, y1) {
            const index = this._index << 2;
            this._index += 1;
            const data = this._data;
            if (index < data.length) {
                if (data[index + 0] !== x0 ||
                    data[index + 1] !== y0 ||
                    data[index + 2] !== x1 ||
                    data[index + 3] !== y1) {
                    data[index + 0] = x0;
                    data[index + 1] = y0;
                    data[index + 2] = x1;
                    data[index + 3] = y1;
                    this._isDirty = true;
                }
            }
            else {
                data.push(x0, y0, x1, y1);
                this._isDirty = true;
            }
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DHtmlElement} option when to show a HTML element
     */
    const UtilHtmlElementWhen = {
        /**
         * Shows a HTML element when clicked.
         */
        CLICKED: 0,
        /**
         * Shows a HTML element when double clicked.
         */
        DOUBLE_CLICKED: 1,
        /**
         * Shows a HTML element when focused.
         * And also shows when clicked if focused.
         */
        FOCUSED: 2,
        /**
         * Always shows a HTML element.
         */
        ALWAYS: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilHtmlElement {
        constructor(target, operation, theme, options) {
            this._target = target;
            this._operation = operation;
            const data = this.toData(theme, options);
            this._data = data;
            this._isElementShown = false;
            this._onElementFocusBound = (e) => {
                this.onElementFocus(e);
            };
            this._onBeforeFocusBound = (e) => {
                this.onBeforeFocus(e);
            };
            this._onAfterFocusBound = (e) => {
                this.onAfterFocus(e);
            };
            this._isStarted = false;
            this._wasStarted = false;
            this._doSelectBound = () => {
                this.doSelect();
            };
            this._isStartRequested = this._data.when === UtilHtmlElementWhen.ALWAYS;
            this._onPostRenderBound = () => {
                this.updateElement(this._rendererBound);
            };
        }
        toData(theme, options) {
            var _a, _b;
            return {
                element: this.toElementData(theme, options === null || options === void 0 ? void 0 : options.element),
                clipper: this.toClipperData(theme, options === null || options === void 0 ? void 0 : options.clipper),
                before: this.toBeforeData(theme, options === null || options === void 0 ? void 0 : options.before),
                after: this.toAfterData(theme, options === null || options === void 0 ? void 0 : options.after),
                when: toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : theme.getWhen(), UtilHtmlElementWhen),
                select: (_b = options === null || options === void 0 ? void 0 : options.select) !== null && _b !== void 0 ? _b : theme.getSelect()
            };
        }
        toElementData(theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getElementCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newElementStyler(theme)
            };
        }
        newElementStyler(theme) {
            return (target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx) => {
                return theme.setElementStyle(target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
            };
        }
        toClipperData(theme, options) {
            var _a, _b, _c;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getClipperCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newClipperStyler(theme),
                extended: (_c = options === null || options === void 0 ? void 0 : options.extended) !== null && _c !== void 0 ? _c : theme.isClipperExEnabled()
            };
        }
        newClipperStyler(theme) {
            return (target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx) => {
                return theme.setClipperStyle(target, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
            };
        }
        toBeforeData(theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getBeforeCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newBeforeStyler(theme)
            };
        }
        newBeforeStyler(theme) {
            return (target) => {
                theme.setBeforeStyle(target);
            };
        }
        toAfterData(theme, options) {
            var _a, _b;
            return {
                creator: (_a = options === null || options === void 0 ? void 0 : options.creator) !== null && _a !== void 0 ? _a : theme.getAfterCreator(),
                styler: (_b = options === null || options === void 0 ? void 0 : options.styler) !== null && _b !== void 0 ? _b : this.newAfterStyler(theme)
            };
        }
        newAfterStyler(theme) {
            return (target) => {
                theme.setAfterStyle(target);
            };
        }
        get element() {
            var _a;
            return (_a = this._element) !== null && _a !== void 0 ? _a : null;
        }
        get when() {
            return this._data.when;
        }
        onDowning(e) {
            this._wasStarted = this._isStarted;
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                    this.start();
                    break;
                case UtilHtmlElementWhen.FOCUSED:
                    if (this._target.state.isFocused) {
                        this.start();
                    }
                    break;
            }
        }
        onDown(e) {
            if (!this._wasStarted && this._isStarted) {
                if ("data" in e) {
                    e.data.originalEvent.preventDefault();
                }
                else {
                    e.preventDefault();
                }
            }
        }
        onDblClick(e, interactionManager) {
            switch (this.when) {
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                    this.start();
                    break;
            }
        }
        onFocus() {
            var _a;
            switch (this.when) {
                case UtilHtmlElementWhen.FOCUSED:
                    this.start();
                    break;
                default:
                    (_a = this._element) === null || _a === void 0 ? void 0 : _a.focus();
                    break;
            }
        }
        onBlur() {
            var _a;
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                case UtilHtmlElementWhen.FOCUSED:
                    this.onEndByBlur();
                    this.cancel();
                    break;
                default:
                    (_a = this._element) === null || _a === void 0 ? void 0 : _a.blur();
                    break;
            }
        }
        isStartable() {
            switch (this.when) {
                case UtilHtmlElementWhen.CLICKED:
                case UtilHtmlElementWhen.DOUBLE_CLICKED:
                case UtilHtmlElementWhen.FOCUSED:
                    return this._target.state.isActionable;
                default:
                    return true;
            }
        }
        start() {
            if (!this._isStarted && this.isStartable()) {
                this._isStarted = true;
                if (this._target.worldVisible) {
                    this.doStart();
                }
                else {
                    this._isStartRequested = true;
                }
                DApplications.update(this._target);
            }
        }
        isShown() {
            return this._isElementShown;
        }
        onRender(renderer) {
            if (this._isStartRequested ||
                (!this._isElementShown && this.when === UtilHtmlElementWhen.ALWAYS)) {
                this._isStartRequested = false;
                this.doStart(renderer);
            }
            if (this._isStarted) {
                this._isStarted = false;
            }
        }
        getElementRect(resolution) {
            const point = this._point || new pixi_js.Point(0, 0);
            this._point = point;
            const result = this._elementRectResult || new pixi_js.Rectangle();
            this._elementRectResult = result;
            return this._operation.getElementRect(resolution, point, result);
        }
        getElementMatrix() {
            return this._operation.getElementMatrix();
        }
        getClipperRect(resolution) {
            const point = this._point || new pixi_js.Point(0, 0);
            this._point = point;
            const result = this._clipperRectResult || new pixi_js.Rectangle();
            this._clipperRectResult = result;
            return this._operation.getClipperRect(resolution, point, result);
        }
        fillClipperExRects(resolution, result) {
            const operation = this._operation;
            if (operation.getClipperExRects) {
                operation.getClipperExRects(result);
            }
            return result.isDirty();
        }
        doStart(renderer) {
            var _a, _b;
            if (!this._isElementShown) {
                this._isElementShown = true;
                const rendererBound = this._rendererBound;
                if (rendererBound != null) {
                    this._rendererBound = undefined;
                    rendererBound.off("postrender", this._onPostRenderBound);
                }
                const target = this._target;
                if (renderer == null) {
                    renderer = (_a = DApplications.getLayer(target)) === null || _a === void 0 ? void 0 : _a.renderer;
                }
                if (renderer) {
                    this._rendererBound = renderer;
                    renderer.on("postrender", this._onPostRenderBound);
                }
                this.onStart();
                const clipper = this.getClipper();
                if (clipper) {
                    const before = this.getBefore(clipper);
                    const element = this.getElement(clipper);
                    const after = this.getAfter(clipper);
                    const clipperEx = this.getClipperEx(clipper);
                    if (element) {
                        const resolution = (_b = renderer === null || renderer === void 0 ? void 0 : renderer.resolution) !== null && _b !== void 0 ? _b : DApplications.getResolution(target);
                        const elementRect = this.getElementRect(resolution);
                        const elementMatrix = this.getElementMatrix();
                        const clipperRect = this.toClipperRectAdjusted(elementRect, elementMatrix, this.getClipperRect(resolution));
                        const state = target.state;
                        const padding = this._operation.getPadding();
                        const options = this._data;
                        options.clipper.styler(clipper, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        options.element.styler(element, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        if (before) {
                            options.before.styler(before);
                        }
                        if (after) {
                            options.after.styler(after);
                        }
                        this.onElementAttached(element, before, after);
                        if (clipperEx) {
                            const clipperExRects = this.getClipperExRects();
                            if (clipperExRects) {
                                if (this.fillClipperExRects(resolution, clipperExRects)) {
                                    clipperEx.update(elementRect, elementMatrix, clipperExRects);
                                    clipperExRects.toClean();
                                }
                            }
                        }
                        // Show HTML elements
                        clipper.style.display = "";
                        if (state.isFocused) {
                            this.toElementFocused(element);
                        }
                        clipper.scrollTop = 0;
                        clipper.scrollLeft = 0;
                        // Select the element if required.
                        // Note that a selecting without the setTimeout causes a key stroke drop on Microsoft Edge.
                        if (this._data.select) {
                            setTimeout(this._doSelectBound, 0);
                        }
                    }
                }
            }
        }
        toElementFocused(element) {
            element.focus({
                preventScroll: true
            });
        }
        onStart() {
            this._operation.onStart();
        }
        doSelect() {
            const element = this._element;
            if (element) {
                if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                    // The following does not work on mobile devices.
                    // I think selecting texts on a tap is annoying.
                    // Therefore, I leave this untouched.
                    element.select();
                }
            }
        }
        cancel() {
            var _a;
            if (this._isElementShown) {
                this._isElementShown = false;
                const rendererBound = this._rendererBound;
                if (rendererBound != null) {
                    this._rendererBound = undefined;
                    rendererBound.off("postrender", this._onPostRenderBound);
                }
                this.onCancel();
                const target = this._target;
                const layer = DApplications.getLayer(target);
                if (layer) {
                    const view = layer.view;
                    switch (this.when) {
                        case UtilHtmlElementWhen.CLICKED:
                        case UtilHtmlElementWhen.DOUBLE_CLICKED:
                        case UtilHtmlElementWhen.FOCUSED:
                            if (document.activeElement === this._element) {
                                view.focus();
                            }
                            break;
                    }
                    const state = target.state;
                    const interactionManager = layer.renderer.plugins.interaction;
                    if (this._operation.containsPoint(interactionManager.mouse.global) &&
                        !state.isHovered) {
                        state.isHovered = true;
                        view.style.cursor = (_a = target.cursor) !== null && _a !== void 0 ? _a : "";
                    }
                    layer.update();
                }
                const element = this._element;
                if (element != null) {
                    this.onElementDetached(element, this._before, this._after);
                }
                const clipper = this._clipper;
                if (clipper != null) {
                    clipper.style.display = "none";
                }
            }
        }
        onCancel() {
            this._operation.onCancel();
        }
        onElementAttached(element, before, after) {
            before === null || before === void 0 ? void 0 : before.addEventListener("focus", this._onBeforeFocusBound);
            after === null || after === void 0 ? void 0 : after.addEventListener("focus", this._onAfterFocusBound);
            element.addEventListener("focus", this._onElementFocusBound, true);
        }
        onElementDetached(element, before, after) {
            before === null || before === void 0 ? void 0 : before.removeEventListener("focus", this._onBeforeFocusBound);
            after === null || after === void 0 ? void 0 : after.removeEventListener("focus", this._onAfterFocusBound);
            element.removeEventListener("focus", this._onElementFocusBound, true);
        }
        getClipper() {
            let result = this._clipper;
            if (result == null) {
                const layer = DApplications.getLayer(this._target);
                result = layer ? this._data.clipper.creator(layer.getElementContainer()) : null;
                this._clipper = result;
            }
            return result;
        }
        getClipperEx(clipper) {
            let result = this._clipperEx;
            if (result === undefined) {
                const clipperExRects = this.getClipperExRects();
                if (clipperExRects != null) {
                    result = new UtilHtmlElementClipperExImpl(clipper);
                }
                else {
                    result = null;
                }
                this._clipperEx = result;
            }
            return result;
        }
        getClipperExRects() {
            let result = this._clipperExRects;
            if (result === undefined) {
                if (this._data.clipper.extended) {
                    result = new UtilHtmlElementClipperExRectsImpl();
                }
                else {
                    result = null;
                }
                this._clipperExRects = result;
            }
            return result;
        }
        getElement(clipper) {
            let result = this._element;
            if (result == null) {
                result = this._data.element.creator(clipper);
                this._element = result;
            }
            return result;
        }
        getBefore(clipper) {
            let result = this._before;
            if (result == null) {
                result = this._data.before.creator(clipper);
                this._before = result;
            }
            return result;
        }
        getAfter(clipper) {
            let result = this._after;
            if (result == null) {
                result = this._data.after.creator(clipper);
                this._after = result;
            }
            return result;
        }
        onBeforeFocus(e) {
            const target = this._target;
            const layer = DApplications.getLayer(target);
            if (layer) {
                const focusController = layer.getFocusController();
                const focusable = focusController.find(target, false, false, false);
                layer.view.focus();
                focusController.focus(focusable);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        }
        onAfterFocus(e) {
            const target = this._target;
            const layer = DApplications.getLayer(target);
            if (layer) {
                const focusController = layer.getFocusController();
                const focusable = focusController.find(target, false, false, true);
                layer.view.focus();
                focusController.focus(focusable);
                e.preventDefault();
                e.stopImmediatePropagation();
            }
        }
        onElementFocus(e) {
            if (this.when === UtilHtmlElementWhen.ALWAYS) {
                const target = this._target;
                if (!target.state.isFocused) {
                    target.focus();
                }
            }
        }
        onEndByBlur() {
            this.onEnd();
        }
        onEnd() {
            this._operation.onEnd();
        }
        end() {
            this.onEnd();
            this.cancel();
        }
        select() {
            if (this._isElementShown && this._data.select) {
                this.doSelect();
            }
            return this;
        }
        toClipperRectAdjusted(elementRect, elementMatrix, clipperRect) {
            if (clipperRect && elementRect && elementMatrix == null) {
                const ex0 = elementRect.x;
                const ey0 = elementRect.y;
                const ex1 = ex0 + elementRect.width;
                const ey1 = ey0 + elementRect.height;
                const cx0 = clipperRect.x;
                const cy0 = clipperRect.y;
                const cx1 = cx0 + clipperRect.width;
                const cy1 = cy0 + clipperRect.height;
                const ncx0 = Math.min(Math.max(cx0, ex0), cx1);
                const ncx1 = Math.min(Math.max(cx0, ex1), cx1);
                const ncy0 = Math.min(Math.max(cy0, ey0), cy1);
                const ncy1 = Math.min(Math.max(cy0, ey1), cy1);
                clipperRect.x = ncx0;
                clipperRect.y = ncy0;
                clipperRect.width = ncx1 - ncx0;
                clipperRect.height = ncy1 - ncy0;
            }
            return clipperRect;
        }
        updateElement(renderer) {
            if (this._isElementShown) {
                const target = this._target;
                if (target.worldVisible) {
                    const element = this._element;
                    const clipper = this._clipper;
                    const clipperEx = this._clipperEx;
                    if (element && clipper) {
                        const resolution = renderer.resolution;
                        const elementRect = this.getElementRect(resolution);
                        const elementMatrix = this.getElementMatrix();
                        const clipperRect = this.toClipperRectAdjusted(elementRect, elementMatrix, this.getClipperRect(resolution));
                        const state = target.state;
                        const padding = this._operation.getPadding();
                        const options = this._data;
                        options.clipper.styler(clipper, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        options.element.styler(element, state, padding, elementRect, elementMatrix, clipperRect, clipperEx);
                        if (clipperEx) {
                            const clipperExRects = this.getClipperExRects();
                            if (clipperExRects) {
                                if (this.fillClipperExRects(resolution, clipperExRects)) {
                                    clipperEx.update(elementRect, elementMatrix, clipperExRects);
                                    clipperExRects.toClean();
                                }
                            }
                        }
                    }
                }
                else {
                    switch (this.when) {
                        case UtilHtmlElementWhen.ALWAYS:
                            const clipper = this._clipper;
                            if (clipper) {
                                clipper.style.display = "none";
                            }
                            break;
                        default:
                            this.cancel();
                            break;
                    }
                }
            }
        }
        static getClipperRect(parent, target, resolution, point, result) {
            let isFirst = true;
            let x0 = 0;
            let y0 = 0;
            let x1 = 0;
            let y1 = 0;
            let current = parent;
            while (current instanceof DBase) {
                current.getClippingRect(target, result);
                point.set(result.x, result.y);
                current.toGlobal(point, point, false);
                const cx0 = ((point.x * resolution) | 0) / resolution;
                const cy0 = ((point.y * resolution) | 0) / resolution;
                point.set(result.x + result.width, result.y + result.height);
                current.toGlobal(point, point, true);
                const cx1 = point.x;
                const cy1 = point.y;
                const dx0 = Math.min(cx0, cx1);
                const dy0 = Math.min(cy0, cy1);
                const dx1 = Math.max(cx0, cx1);
                const dy1 = Math.max(cy0, cy1);
                if (isFirst) {
                    isFirst = false;
                    x0 = dx0;
                    y0 = dy0;
                    x1 = dx1;
                    y1 = dy1;
                }
                else {
                    x0 = Math.min(Math.max(x0, dx0), dx1);
                    y0 = Math.min(Math.max(y0, dy0), dy1);
                    x1 = Math.min(Math.max(x1, dx0), dx1);
                    y1 = Math.min(Math.max(y1, dy0), dy1);
                }
                current = current.parent;
            }
            if (isFirst) {
                return null;
            }
            result.x = x0;
            result.y = y0;
            result.width = x1 - x0;
            result.height = y1 - y0;
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    let _isShapeClipperExLoaded = false;
    const loadShapeClipperEx = () => {
        _isShapeClipperExLoaded = true;
    };
    const isShapeClipperExLoaded = () => {
        return _isShapeClipperExLoaded;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscHtmlElementBase extends EShapeActionRuntimeBase {
        constructor(value) {
            super();
            this.condition = EShapeActionExpressions.ofString(value.condition);
            this.utils = new Map();
        }
        getUtil(shape, runtime) {
            const utils = this.utils;
            let result = utils.get(shape);
            if (result == null) {
                result = this.newUtil(shape, runtime);
                utils.set(shape, result);
            }
            return result;
        }
        newUtil(shape, runtime) {
            return new UtilHtmlElement(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DHtmlElement"), this.newUtilOptions(shape, runtime));
        }
        newOperation(shape, runtime) {
            return {
                getElementRect: (resolution, work, result) => {
                    return this.getElementRect(shape, runtime, resolution, work, result);
                },
                getElementMatrix: () => {
                    return this.getElementMatrix(shape, runtime);
                },
                getClipperRect: (resolution, work, result) => {
                    return this.getClipperToRect(shape, runtime, resolution, work, result);
                },
                getClipperExRects: (result) => {
                    this.getClipperExRects(shape, result);
                },
                getPadding: () => {
                    return this.getPadding(shape, runtime);
                },
                containsPoint: (point) => {
                    return this.containsPoint(shape, runtime, point);
                },
                onStart: () => {
                    // DO NOTHING
                },
                onCancel: () => {
                    // DO NOTHING
                },
                onEnd: () => {
                    // DO NOTHING
                }
            };
        }
        newUtilOptions(shape, runtime) {
            return {
                element: {
                    creator: this.newElementCreator(shape, runtime)
                },
                when: this.toWhen(shape, runtime),
                clipper: {
                    extended: isShapeClipperExLoaded()
                }
            };
        }
        toWhen(shape, runtime) {
            const value = this.condition(shape, Date.now(), EShapeActionEnvironment);
            if (value != null && value in UtilHtmlElementWhen) {
                return UtilHtmlElementWhen[value];
            }
            return undefined;
        }
        containsPoint(shape, runtime, point) {
            var _a;
            if (shape.visible) {
                const local = ((_a = EShapeActionRuntimeMiscHtmlElementBase.WORK) !== null && _a !== void 0 ? _a : (EShapeActionRuntimeMiscHtmlElementBase.WORK = new pixi_js.Point()));
                shape.toLocal(point, undefined, local);
                return shape.contains(local.x, local.y) != null;
            }
            return false;
        }
        getPadding(shape, runtime) {
            return null;
        }
        getElementRect(shape, runtime, resolution, point, result) {
            const pivot = shape.transform.pivot;
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            result.x = -0.5 * sizeX + pivot.x;
            result.y = -0.5 * sizeY + pivot.y;
            result.width = sizeX;
            result.height = sizeY;
            return result;
        }
        getElementMatrix(shape, runtime) {
            shape.updateTransform();
            return shape.transform.worldTransform;
        }
        getClipperToRect(shape, runtime, resolution, point, result) {
            const diagram = EShapeActions.toDiagram(shape);
            return UtilHtmlElement.getClipperRect(diagram, shape, resolution, point, result);
        }
        getClipperExRects(shape, result) {
            result.begin();
            const target = shape.root.parent;
            if (target instanceof DDiagramLayer) {
                const layerContainer = target.parent;
                if (layerContainer != null) {
                    const layers = layerContainer.children;
                    const index = layers.indexOf(target);
                    if (0 <= index) {
                        for (let i = index + 1, imax = layers.length; i < imax; ++i) {
                            const layer = layers[i];
                            if (layer.visible) {
                                const w = layer.width;
                                const h = layer.height;
                                const t = layer.transform.worldTransform;
                                const a = t.a;
                                const b = t.b;
                                const c = t.c;
                                const d = t.d;
                                const tx = t.tx;
                                const ty = t.ty;
                                result.add(tx, ty, a * w + c * h + tx, b * w + d * h + ty);
                            }
                        }
                    }
                }
            }
            result.end();
        }
        onRender(shape, runtime, time, renderer) {
            this.getUtil(shape, runtime).onRender(renderer);
        }
        onFocus(shape, runtime) {
            this.getUtil(shape, runtime).onFocus();
        }
        onBlur(shape, runtime) {
            this.getUtil(shape, runtime).onBlur();
        }
        onDowning(shape, runtime, e) {
            this.getUtil(shape, runtime).onDowning(e);
        }
        onDown(shape, runtime, e) {
            this.getUtil(shape, runtime).onDown(e);
        }
        onDblClick(shape, runtime, e, interactionManager) {
            this.getUtil(shape, runtime).onDblClick(e, interactionManager);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscHtmlElement extends EShapeActionRuntimeMiscHtmlElementBase {
        constructor(value) {
            super(value);
            this.elementCreator = EShapeActionExpressions.ofElementOrNull(value.value);
            this.noPointerEvent =
                value.subtype === EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS;
        }
        newUtil(shape, runtime) {
            if (this.noPointerEvent) {
                shape.state.add(DHtmlElementState.NO_POINTER_EVENTS);
            }
            return super.newUtil(shape, runtime);
        }
        newElementCreator(shape, runtime) {
            const elementCreator = this.elementCreator;
            if (elementCreator) {
                return (container) => {
                    return elementCreator(shape, Date.now(), EShapeActionEnvironment, container);
                };
            }
            return undefined;
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilInput extends UtilHtmlElement {
        constructor(target, operation, theme, options) {
            var _a, _b, _c, _d, _e, _f;
            super(target, operation, theme, options);
            this._operation = operation;
            this._onInputKeyDownBound = (e) => {
                this.onInputKeyDown(e);
            };
            this._onInputChangeBound = () => {
                this.onInputChange();
            };
            this._onInputInputBound = (e) => {
                this.onInputInput(e);
            };
            this._description = (_a = options === null || options === void 0 ? void 0 : options.description) !== null && _a !== void 0 ? _a : "";
            const editing = options === null || options === void 0 ? void 0 : options.editing;
            this._editingFormatter =
                (_d = (_b = editing === null || editing === void 0 ? void 0 : editing.formatter) !== null && _b !== void 0 ? _b : (_c = options === null || options === void 0 ? void 0 : options.text) === null || _c === void 0 ? void 0 : _c.formatter) !== null && _d !== void 0 ? _d : theme.getEditingFormatter();
            this._editingUnformatter = (_e = editing === null || editing === void 0 ? void 0 : editing.unformatter) !== null && _e !== void 0 ? _e : theme.getEditingUnformatter();
            this._editingValidator = (_f = editing === null || editing === void 0 ? void 0 : editing.validator) !== null && _f !== void 0 ? _f : theme.getEditingValidator();
        }
        onEnd() {
            super.onEnd();
            this.onInputChange();
        }
        onElementAttached(element, before, after) {
            element.value = this.fromValue(this._operation.getValue());
            element.addEventListener("change", this._onInputChangeBound);
            element.addEventListener("input", this._onInputInputBound);
            super.onElementAttached(element, before, after);
        }
        onElementDetached(element, before, after) {
            super.onElementDetached(element, before, after);
            element.removeEventListener("change", this._onInputChangeBound);
            element.removeEventListener("input", this._onInputInputBound);
        }
        onInputKeyDown(e) {
            if (UtilKeyboardEvent.isOkKey(e)) {
                this.end();
                this._operation.onEnter();
            }
            else if (UtilKeyboardEvent.isCancelKey(e)) {
                this.cancel();
            }
        }
        toElementFocused(element) {
            super.toElementFocused(element);
            element.scrollTop = 0;
            element.scrollLeft = 0;
        }
        onInputChange() {
            if (this.isShown()) {
                const element = this.element;
                if (element != null) {
                    const operation = this._operation;
                    const newValue = this.toValue(element.value);
                    const oldValue = operation.getValue();
                    if (oldValue !== newValue) {
                        operation.onValueChange(newValue, oldValue);
                    }
                }
            }
        }
        toValue(valueAsString) {
            return this._editingUnformatter(valueAsString, this);
        }
        fromValue(value) {
            if (value !== undefined) {
                return this._editingFormatter(value, this);
            }
            return "";
        }
        onInputInput(e) {
            const target = e.target;
            if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
                this._operation.onValueInput(this.toValue(target.value));
            }
        }
        validate() {
            const value = this._operation.getValue();
            if (value !== undefined) {
                const result = this._editingValidator(value, this);
                if (this._editingValidationResult !== result) {
                    this._editingValidationResult = result;
                    const state = this._target.state;
                    state.isInvalid = result != null;
                    if (state.isHovered) {
                        this._operation.applyTitle();
                    }
                }
                return result;
            }
            return null;
        }
        applyTitle() {
            const editingValidationResult = this._editingValidationResult;
            if (isString(editingValidationResult)) {
                const layer = DApplications.getLayer(this._target);
                if (layer) {
                    layer.view.title = editingValidationResult;
                }
                return true;
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilInputInput extends UtilInput {
        onElementAttached(element, before, after) {
            element.addEventListener("keydown", this._onInputKeyDownBound);
            super.onElementAttached(element, before, after);
        }
        onElementDetached(element, before, after) {
            element.removeEventListener("keydown", this._onInputKeyDownBound);
            super.onElementDetached(element, before, after);
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilInputNumber extends UtilInputInput {
        constructor(target, operation, theme, options) {
            var _a, _b, _c;
            super(target, operation, theme, options);
            this._step = (_a = options === null || options === void 0 ? void 0 : options.step) !== null && _a !== void 0 ? _a : theme.getStep();
            this._min = (_b = options === null || options === void 0 ? void 0 : options.min) !== null && _b !== void 0 ? _b : theme.getMin();
            this._max = (_c = options === null || options === void 0 ? void 0 : options.max) !== null && _c !== void 0 ? _c : theme.getMax();
        }
        get step() {
            return this._step;
        }
        set step(step) {
            if (this._step !== step) {
                this._step = step;
                this.onStepChange();
            }
        }
        get min() {
            return this._min;
        }
        set min(min) {
            if (this._min !== min) {
                this._min = min;
                this.onMinChange();
            }
        }
        get max() {
            return this._max;
        }
        set max(max) {
            if (this._max !== max) {
                this._max = max;
                this.onMaxChange();
            }
        }
        toValue(valueAsString) {
            const result = super.toValue(valueAsString);
            if (result === result /* NaN Check */) {
                const min = this._min;
                if (min != null && result < min) {
                    return min;
                }
                const max = this._max;
                if (max != null && max < result) {
                    return max;
                }
                return result;
            }
            return 0;
        }
        fromValue(value) {
            if (value !== undefined) {
                return this._editingFormatter(value, this);
            }
            return "0";
        }
        onStepChange() {
            if (this.isShown()) {
                const element = this.element;
                if (element) {
                    this.updateStep(element);
                }
            }
        }
        onMinChange() {
            if (this.isShown()) {
                const element = this.element;
                if (element) {
                    this.updateMin(element);
                }
            }
        }
        onMaxChange() {
            if (this.isShown()) {
                const element = this.element;
                if (element) {
                    this.updateMax(element);
                }
            }
        }
        updateStep(input) {
            const step = this.step;
            if (step != null) {
                input.step = `${step}`;
            }
            else {
                input.step = "any";
            }
        }
        updateMin(input) {
            const min = this.min;
            if (min != null) {
                input.min = `${min}`;
            }
            else {
                input.removeAttribute("min");
            }
        }
        updateMax(input) {
            const max = this.max;
            if (max != null) {
                input.max = `${max}`;
            }
            else {
                input.removeAttribute("max");
            }
        }
        onElementAttached(element, before, after) {
            element.type = "number";
            super.onElementAttached(element, before, after);
            this.updateStep(element);
            this.updateMin(element);
            this.updateMax(element);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueOnInputAction = {
        EMIT_EVENT: 0,
        WRITE_BOTH: 1,
        WRITE_LOCAL: 2,
        WRITE_REMOTE: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueOnInputActions {
        static execute(shape, action, target, value, time) {
            switch (action) {
                case EShapeActionValueOnInputAction.EMIT_EVENT:
                    shape.emit(target, shape, value);
                    EShapeActions.emit(shape, target, value, time);
                    break;
                case EShapeActionValueOnInputAction.WRITE_LOCAL:
                    EShapeActions.writeLocal(shape, target, value, time);
                    break;
                case EShapeActionValueOnInputAction.WRITE_REMOTE:
                    EShapeActions.writeRemote(shape, target, value);
                    break;
                case EShapeActionValueOnInputAction.WRITE_BOTH:
                    EShapeActions.writeLocal(shape, target, value, time);
                    EShapeActions.writeRemote(shape, target, value);
                    break;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscInput extends EShapeActionRuntimeMiscHtmlElementBase {
        constructor(value) {
            super(value);
            this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            this.onInputAction = value.onInputAction;
        }
        newOperation(shape, runtime) {
            return {
                getElementRect: (resolution, work, result) => {
                    return this.getElementRect(shape, runtime, resolution, work, result);
                },
                getElementMatrix: () => {
                    return this.getElementMatrix(shape, runtime);
                },
                getClipperRect: (resolution, work, result) => {
                    return this.getClipperToRect(shape, runtime, resolution, work, result);
                },
                getClipperExRects: (result) => {
                    this.getClipperExRects(shape, result);
                },
                getPadding: () => {
                    return this.getPadding(shape, runtime);
                },
                containsPoint: (point) => {
                    return this.containsPoint(shape, runtime, point);
                },
                onStart: () => {
                    shape.text.enable = false;
                },
                onCancel: () => {
                    shape.text.enable = true;
                },
                onEnd: () => {
                    // DO NOTHING
                },
                getValue: () => {
                    return this.getUtil(shape, runtime).toValue(shape.text.value);
                },
                onValueInput: (newValue) => {
                    // DO NOTHING
                },
                onValueChange: (newValue, oldValue) => {
                    this.onValueChange(shape, runtime, newValue, oldValue);
                },
                onEnter: () => {
                    // DO NOTHING
                },
                applyTitle: () => {
                    // DO NOTHING
                }
            };
        }
        newElementCreator(shape, runtime) {
            return undefined;
        }
        getPadding(shape, runtime) {
            return shape.text.padding;
        }
        onValueChange(shape, runtime, newValue, oldValue) {
            shape.text.value = this.getUtil(shape, runtime).fromValue(newValue);
            const now = Date.now();
            const target = this.target(shape, now, EShapeActionEnvironment);
            if (target != null) {
                EShapeActionValueOnInputActions.execute(shape, this.onInputAction, target, newValue, now);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscInputInput extends EShapeActionRuntimeMiscInput {
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscInputNumber extends EShapeActionRuntimeMiscInputInput {
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscInputInteger extends EShapeActionRuntimeMiscInputNumber {
        newUtil(shape, runtime) {
            return new UtilInputNumber(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputInteger"), this.newUtilOptions(shape, runtime));
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscInputReal extends EShapeActionRuntimeMiscInputNumber {
        newUtil(shape, runtime) {
            return new UtilInputNumber(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputReal"), this.newUtilOptions(shape, runtime));
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilInputText extends UtilInputInput {
        onElementAttached(element, before, after) {
            element.type = "text";
            super.onElementAttached(element, before, after);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscInputText extends EShapeActionRuntimeMiscInputInput {
        newUtil(shape, runtime) {
            return new UtilInputText(shape, this.newOperation(shape, runtime), DThemes.getInstance().get("DInputText"), this.newUtilOptions(shape, runtime));
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscWrite extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            this.value = EShapeActionExpressions.ofUnknown(value.value);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const target = this.target(shape, time, EShapeActionEnvironment);
                if (target != null) {
                    this.write(shape, target, this.value(shape, time, EShapeActionEnvironment), time);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscWriteBoth extends EShapeActionRuntimeMiscWrite {
        write(shape, target, value, time) {
            EShapeActions.writeLocal(shape, target, value, time);
            EShapeActions.writeRemote(shape, target, value);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscWriteLocal extends EShapeActionRuntimeMiscWrite {
        write(shape, target, value, time) {
            EShapeActions.writeLocal(shape, target, value, time);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscWriteRemote extends EShapeActionRuntimeMiscWrite {
        write(shape, target, value, time) {
            EShapeActions.writeRemote(shape, target, value);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueMisc extends EShapeActionValueSubtyped {
        constructor(subtype, condition, target, onInputAction, value) {
            super(EShapeActionValueType.MISC, condition, subtype);
            this.target = target;
            this.onInputAction = onInputAction;
            this.value = value;
        }
        toRuntime() {
            switch (this.subtype) {
                case EShapeActionValueMiscType.INPUT_TEXT:
                    return new EShapeActionRuntimeMiscInputText(this);
                case EShapeActionValueMiscType.INPUT_INTEGER:
                    return new EShapeActionRuntimeMiscInputInteger(this);
                case EShapeActionValueMiscType.INPUT_REAL:
                    return new EShapeActionRuntimeMiscInputReal(this);
                case EShapeActionValueMiscType.EMIT_EVENT:
                    return new EShapeActionRuntimeMiscEmitEvent(this);
                case EShapeActionValueMiscType.WRITE_BOTH:
                    return new EShapeActionRuntimeMiscWriteBoth(this);
                case EShapeActionValueMiscType.WRITE_LOCAL:
                    return new EShapeActionRuntimeMiscWriteLocal(this);
                case EShapeActionValueMiscType.WRITE_REMOTE:
                    return new EShapeActionRuntimeMiscWriteRemote(this);
                case EShapeActionValueMiscType.HTML_ELEMENT:
                case EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                    return new EShapeActionRuntimeMiscHtmlElement(this);
            }
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const targetId = manager.addResource(this.target);
            const valueId = manager.addResource(this.value);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${targetId},${this.onInputAction},${valueId}]`);
        }
        static deserialize(serialized, manager) {
            const resources = manager.resources;
            const condition = EShapeActionValues.toResource(1, serialized, resources);
            const target = EShapeActionValues.toResource(3, serialized, resources);
            const value = EShapeActionValues.toResource(5, serialized, resources);
            return new EShapeActionValueMisc(serialized[2], condition, target, serialized[4], value);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscExecute extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this.target = EShapeActionExpressions.ofUnknown(value.target);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                this.target(shape, time, EShapeActionEnvironment);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueMiscExecute extends EShapeActionValueSubtyped {
        constructor(condition, target) {
            super(EShapeActionValueType.MISC, condition, EShapeActionValueMiscType.EXECUTE);
            this.target = target;
        }
        toRuntime() {
            return new EShapeActionRuntimeMiscExecute(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const targetId = manager.addResource(this.target);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${targetId}]`);
        }
        static deserialize(serialized, manager) {
            const resources = manager.resources;
            const condition = EShapeActionValues.toResource(1, serialized, resources);
            const target = EShapeActionValues.toResource(3, serialized, resources);
            return new EShapeActionValueMiscExecute(condition, target);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionMiscExtensions {
        static add(extension) {
            var _a, _b;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._data) !== null && _b !== void 0 ? _b : (this._data = [])).push(extension);
        }
        static get(type) {
            const typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        }
        static each(iteratee) {
            const data = this._data;
            if (data != null) {
                for (let i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeMiscExtension extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this.argument = EShapeActionExpressions.ofUnknown(value.argument);
            this.extension = EShapeActionMiscExtensions.get(value.subtype);
        }
        execute(shape, runtime, time) {
            const extension = this.extension;
            if (extension != null && this.condition(shape, time, EShapeActionEnvironment)) {
                const diagram = EShapeActions.toDiagram(shape);
                if (diagram != null) {
                    extension.executor(this.argument(shape, time, EShapeActionEnvironment), shape, diagram, EShapeActionEnvironment);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueMiscExtension extends EShapeActionValueSubtyped {
        constructor(subtype, condition, argument) {
            super(EShapeActionValueType.MISC, condition, subtype);
            this.argument = argument;
        }
        toRuntime() {
            return new EShapeActionRuntimeMiscExtension(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const argumentId = manager.addResource(this.argument);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${argumentId}]`);
        }
        static deserialize(serialized, manager) {
            const resources = manager.resources;
            const condition = EShapeActionValues.toResource(1, serialized, resources);
            const argument = EShapeActionValues.toResource(3, serialized, resources);
            return new EShapeActionValueMiscExtension(serialized[2], condition, argument);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpen extends EShapeActionRuntimeConditional {
        constructor(value, subtype) {
            super(value, EShapeRuntimeReset.NONE);
            this.subtype = subtype;
            this.target = EShapeActionExpressions.ofUnknown(value.target);
            this.inNewWindow = value.inNewWindow;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const target = this.target(shape, time, EShapeActionEnvironment);
                if (target != null) {
                    EShapeActions.open(shape, this.subtype, target, this.inNewWindow, EShapeActionEnvironment);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueOpenType = {
        /** @deprecated in favor of {@link DIAGRAM} */
        DIAGRAM_LEGACY: 0,
        /** @deprecated in favor of {@link PAGE} */
        PAGE_LEGACY: 1,
        /** @deprecated in favor of {@link PAGE} */
        PAGE_INPLACE_LEGACY: 2,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_TEXT: 3,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_INTEGER: 4,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_REAL: 5,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_BOOLEAN: 6,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_DATE: 7,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_TIME: 8,
        /** @deprecated in favor of {@link DIALOG} */
        DIALOG_DATETIME: 9,
        DIAGRAM: 10,
        PAGE: 11,
        DIALOG: 12,
        EXTENSION: DDiagramBaseControllerOpenType.EXTENSION
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueOpen extends EShapeActionValueSubtyped {
        constructor(subtype, condition, target, inNewWindow) {
            super(EShapeActionValueType.OPEN, condition, subtype);
            this.target = target;
            this.inNewWindow = inNewWindow;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueOpen &&
                this.target === value.target &&
                this.inNewWindow === value.inNewWindow);
        }
        toRuntime() {
            switch (this.subtype) {
                case EShapeActionValueOpenType.DIAGRAM:
                    return new EShapeActionRuntimeOpen(this, DDiagramBaseControllerOpenType.DIAGRAM);
                case EShapeActionValueOpenType.PAGE:
                    return new EShapeActionRuntimeOpen(this, DDiagramBaseControllerOpenType.PAGE);
            }
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const targetId = manager.addResource(this.target);
            const inNewWindow = this.inNewWindow ? 1 : 0;
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${targetId},${inNewWindow}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const target = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueOpen(this.toSubType(serialized), condition, target, this.inNewWindow(serialized));
        }
        static toSubType(serialized) {
            switch (serialized[2]) {
                case EShapeActionValueOpenType.DIAGRAM_LEGACY:
                    return EShapeActionValueOpenType.DIAGRAM;
                case EShapeActionValueOpenType.PAGE_LEGACY:
                    return EShapeActionValueOpenType.PAGE;
                case EShapeActionValueOpenType.PAGE_INPLACE_LEGACY:
                    return EShapeActionValueOpenType.PAGE;
                case EShapeActionValueOpenType.DIAGRAM:
                    return EShapeActionValueOpenType.DIAGRAM;
                case EShapeActionValueOpenType.PAGE:
                    return EShapeActionValueOpenType.PAGE;
            }
            return EShapeActionValueOpenType.DIAGRAM;
        }
        static inNewWindow(serialized) {
            switch (serialized[2]) {
                case EShapeActionValueOpenType.DIAGRAM_LEGACY:
                    return false;
                case EShapeActionValueOpenType.PAGE_LEGACY:
                    return true;
                case EShapeActionValueOpenType.PAGE_INPLACE_LEGACY:
                    return false;
                case EShapeActionValueOpenType.DIAGRAM:
                case EShapeActionValueOpenType.PAGE:
                    return !!serialized[4];
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const UtilAttachAlign = {
        TOP: 0,
        TOP_LEFT: 1,
        TOP_CENTER: 2,
        TOP_RIGHT: 3,
        LEFT: 4,
        LEFT_TOP: 5,
        LEFT_MIDDLE: 6,
        LEFT_BOTTOM: 7,
        RIGHT: 8,
        RIGHT_TOP: 9,
        RIGHT_MIDDLE: 10,
        RIGHT_BOTTOM: 11,
        BOTTOM: 12,
        BOTTOM_LEFT: 13,
        BOTTOM_CENTER: 14,
        BOTTOM_RIGHT: 15,
        OVER: 16,
        NONE: 17
    };
    class UtilAttach {
        static attach(target, bounds, offsetX, offsetY, clippingWidth, clippingHeight, align) {
            if (align === UtilAttachAlign.NONE) {
                return;
            }
            const width = target.width;
            const height = target.height;
            let x = 0;
            switch (align) {
                case UtilAttachAlign.LEFT:
                case UtilAttachAlign.LEFT_TOP:
                case UtilAttachAlign.LEFT_MIDDLE:
                case UtilAttachAlign.LEFT_BOTTOM:
                    x = bounds.left - width - offsetX;
                    if (x < offsetX) {
                        x = bounds.right + offsetX;
                        if (clippingWidth - offsetX < x + width) {
                            x = offsetX;
                        }
                    }
                    break;
                case UtilAttachAlign.RIGHT:
                case UtilAttachAlign.RIGHT_TOP:
                case UtilAttachAlign.RIGHT_MIDDLE:
                case UtilAttachAlign.RIGHT_BOTTOM:
                    x = bounds.right + offsetX;
                    if (clippingWidth - offsetX < x + width) {
                        x = bounds.left - width - offsetX;
                        if (x < offsetX) {
                            x = clippingWidth - width - offsetX;
                        }
                    }
                    break;
                case UtilAttachAlign.TOP:
                case UtilAttachAlign.TOP_LEFT:
                case UtilAttachAlign.BOTTOM:
                case UtilAttachAlign.BOTTOM_LEFT:
                    x = this.adjust(bounds.left, width, offsetX, clippingWidth);
                    break;
                case UtilAttachAlign.TOP_RIGHT:
                case UtilAttachAlign.BOTTOM_RIGHT:
                    x = this.adjust(bounds.right - width, width, offsetX, clippingWidth);
                    break;
                case UtilAttachAlign.TOP_CENTER:
                case UtilAttachAlign.BOTTOM_CENTER:
                case UtilAttachAlign.OVER:
                    x = this.adjust((bounds.left + bounds.right - width) * 0.5, width, offsetX, clippingWidth);
                    break;
            }
            let y = 0;
            switch (align) {
                case UtilAttachAlign.LEFT:
                case UtilAttachAlign.LEFT_TOP:
                case UtilAttachAlign.RIGHT:
                case UtilAttachAlign.RIGHT_TOP:
                    y = this.adjust(bounds.top, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.LEFT_MIDDLE:
                case UtilAttachAlign.RIGHT_MIDDLE:
                case UtilAttachAlign.OVER:
                    y = this.adjust((bounds.top + bounds.bottom - height) * 0.5, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.LEFT_BOTTOM:
                case UtilAttachAlign.RIGHT_BOTTOM:
                    y = this.adjust(bounds.bottom, height, offsetY, clippingHeight);
                    break;
                case UtilAttachAlign.TOP:
                case UtilAttachAlign.TOP_LEFT:
                case UtilAttachAlign.TOP_RIGHT:
                case UtilAttachAlign.TOP_CENTER:
                    y = bounds.top - height - offsetY;
                    if (y < offsetY) {
                        y = bounds.bottom + offsetY;
                        if (clippingHeight < y + height) {
                            y = offsetY;
                        }
                    }
                    break;
                case UtilAttachAlign.BOTTOM:
                case UtilAttachAlign.BOTTOM_LEFT:
                case UtilAttachAlign.BOTTOM_RIGHT:
                case UtilAttachAlign.BOTTOM_CENTER:
                    y = bounds.bottom + offsetY;
                    if (clippingHeight - offsetY < y + height) {
                        y = bounds.top - height - offsetY;
                        if (y < offsetY) {
                            y = clippingHeight - height - offsetY;
                        }
                    }
                    break;
            }
            target.position.set(x, y);
        }
        static adjust(position, size, offset, clippingSize) {
            if (position < offset) {
                if (clippingSize - offset < position + size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return offset;
                }
            }
            else if (clippingSize - offset < position + size) {
                if (clippingSize < size) {
                    return (clippingSize - size) * 0.5;
                }
                else {
                    return clippingSize - size - offset;
                }
            }
            return position;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DDialogCloseOn = {
        NONE: 0,
        ESC: 1,
        CLICK_OUTSIDE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DDialogGestureMode = {
        DIRTY: 0,
        CLEAN: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogGestureImpl {
        constructor(parent, options) {
            var _a;
            this._parent = parent;
            this._options = options;
            if (options.enable) {
                this._util = this.newUtil();
            }
            this._mode = toEnum((_a = options.mode) !== null && _a !== void 0 ? _a : DDialogGestureMode.DIRTY, DDialogGestureMode);
            this._isEnabled = true;
            this._isDirty = false;
        }
        get parent() {
            return this._parent;
        }
        get mode() {
            return this._mode;
        }
        set mode(mode) {
            this._mode = mode;
        }
        get constraint() {
            var _a, _b;
            let result = this._constraint;
            if (result == null) {
                result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.constraint) !== null && _b !== void 0 ? _b : this.newConstraint();
                this._constraint = result;
            }
            return result;
        }
        set constraint(constraint) {
            this._constraint = constraint;
        }
        newConstraint() {
            return (target, layer, x, y) => {
                this.toConstrained(target, layer, x, y);
            };
        }
        isDirty() {
            return this._isDirty;
        }
        isClean() {
            return !this._isDirty;
        }
        toClean() {
            if (this._isDirty) {
                this._isDirty = false;
            }
        }
        newUtil() {
            const p = new pixi_js.Point();
            const parent = this._parent;
            const position = parent.position;
            return new UtilGesture({
                bind: parent,
                checker: {
                    start: (e) => {
                        // Are children clicked?
                        if (e.target !== parent) {
                            return false;
                        }
                        // Is clicked outside?
                        p.copyFrom(e.data.global);
                        parent.toLocal(p, undefined, p, true);
                        const x = p.x;
                        const y = p.y;
                        if (x < 0 || y < 0 || parent.width < x || parent.height < y) {
                            return false;
                        }
                        // Ok
                        return true;
                    }
                },
                on: {
                    start: () => {
                        p.copyFrom(position);
                    },
                    move: (target, dx, dy) => {
                        p.set(p.x + dx, p.y + dy);
                        if (!this._isDirty) {
                            this._isDirty = true;
                            parent.setX(position.x);
                            parent.setY(position.y);
                        }
                        const layer = parent.layer;
                        if (layer != null) {
                            this.constraint(parent, layer, p.x, p.y);
                        }
                    }
                }
            });
        }
        toConstrained(target, layer, x, y) {
            var _a;
            const position = target.position;
            if (layer) {
                const bounds = target.getBounds(false, ((_a = DDialogGestureImpl.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DDialogGestureImpl.WORK_BOUNDS = new pixi_js.Rectangle())));
                const obx = bounds.x + x - position.x;
                const oby = bounds.y + y - position.y;
                const nbx = Math.min(Math.max(0, obx), layer.width - bounds.width);
                const nby = Math.min(Math.max(0, oby), layer.height - bounds.height);
                position.set(x + nbx - obx, y + nby - oby);
            }
            else {
                position.set(x, y);
            }
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DDialog} mode options.
     */
    const DDialogMode = {
        MODAL: 0,
        MODELESS: 1,
        MENU: 2
    };

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DDialogState = {
        MODAL: "MODAL",
        MODELESS: "MODELESS",
        MENU: "MENU"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilClickOutside {
        static apply(target, onClick) {
            target.on(UtilPointerEvent.down, (e) => {
                if (e.target === target) {
                    const point = this.point;
                    point.copyFrom(e.data.global);
                    target.toLocal(point, undefined, point, true);
                    const x = point.x;
                    const y = point.y;
                    if (x < 0 || y < 0 || target.width < x || target.height < y) {
                        // If dialogs / menus are being rendered on the overlay layer, closing them before
                        // the default pointerdown event handler causes the base layer to lose its focus.
                        // Therefore, onClick needed to be delayed.
                        setTimeout(() => {
                            onClick(e);
                        }, 0);
                    }
                }
            });
        }
    }
    UtilClickOutside.point = new pixi_js.Point();

    class UtilOverlay {
        constructor(options) {
            this._layer = null;
            this._application = (options === null || options === void 0 ? void 0 : options.parent) == null ? DApplications.last() : null;
        }
        get picked() {
            return this._layer;
        }
        pick(owner, opener) {
            let layer = this._layer;
            if (layer == null) {
                layer = DApplications.getLayerOverlay(owner);
                if (layer == null && opener != null) {
                    layer = DApplications.getLayerOverlay(opener);
                }
                if (layer == null) {
                    const application = this._application;
                    if (application) {
                        layer = application.getLayerOverlay();
                    }
                    else {
                        layer = DApplications.last().getLayerOverlay();
                    }
                }
                this._layer = layer;
            }
            return layer;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog class.
     *
     * If multiple application instances are there, better to set the constructor
     * option `parent` to an `application.stage` so that the dialog picks a right
     * application. `DDialog` searches applications in a following order:
     *
     * * To begin, `DDialog` tries to find applications which it belongs to.
     * * If `DDialog` can't find applications, then `DDialog` tries to find applications which openers belong to.
     * * If openers are not given, `DDialog` assumes the last created application at the very moment `DDialog` is instantiated is the one it belongs to.
     */
    class DDialog extends DBase {
        init(options) {
            var _a, _b, _c;
            super.init(options);
            this._onPrerenderBound = () => {
                this.onPrerender();
            };
            this._layer = null;
            // Mode
            const theme = this.theme;
            const mode = toEnum((_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : theme.getMode(), DDialogMode);
            this._mode = mode;
            // Always On Top
            this._alwaysOnTop = (_b = options === null || options === void 0 ? void 0 : options.alwaysOnTop) !== null && _b !== void 0 ? _b : theme.isAlwaysOnTop();
            // Sticky
            this._sticky = (_c = options === null || options === void 0 ? void 0 : options.sticky) !== null && _c !== void 0 ? _c : theme.isSticky(mode);
            // Close On
            const closeOn = this.toCloseOn(mode, theme, options);
            this._closeOn = closeOn;
            // Align
            this._align = this.toAlign(mode, theme, options);
            // Overlay
            this._overlay = new UtilOverlay();
            // Gesture
            this._gesture = new DDialogGestureImpl(this, this.toGestureOptions(mode, theme, options));
            // Visibility
            this.visible = false;
            // State
            switch (mode) {
                case DDialogMode.MODAL:
                    this.state.addAll(DBaseState.FOCUS_ROOT, DDialogState.MODAL);
                    break;
                case DDialogMode.MODELESS:
                    this.state.add(DDialogState.MODELESS);
                    break;
                case DDialogMode.MENU:
                    this.state.addAll(DBaseState.FOCUS_ROOT, DDialogState.MENU);
                    break;
            }
            // Outside-click handling
            if (closeOn & DDialogCloseOn.CLICK_OUTSIDE) {
                UtilClickOutside.apply(this, () => {
                    this.onCloseOn();
                });
            }
        }
        toCloseOn(mode, theme, options) {
            const closeOn = options === null || options === void 0 ? void 0 : options.closeOn;
            if (closeOn == null) {
                return theme.closeOn(mode);
            }
            else if (isArray(closeOn)) {
                let result = DDialogCloseOn.NONE;
                for (let i = 0, imax = closeOn.length; i < imax; ++i) {
                    result |= DDialogCloseOn[closeOn[i]];
                }
                return result;
            }
            else if (isString(closeOn)) {
                return DDialogCloseOn[closeOn];
            }
            return closeOn;
        }
        toAlign(mode, theme, options) {
            const align = options === null || options === void 0 ? void 0 : options.align;
            if (align === null) {
                return null;
            }
            else if (align === undefined) {
                return theme.getAlign(mode);
            }
            else {
                return toEnum(align, UtilAttachAlign);
            }
        }
        get mode() {
            return this._mode;
        }
        get align() {
            return this._align;
        }
        set algin(align) {
            this._align = align;
        }
        get alwaysOnTop() {
            return this._alwaysOnTop;
        }
        set alwaysOnTop(alwaysOnTop) {
            this._alwaysOnTop = alwaysOnTop;
        }
        get gesture() {
            return this._gesture;
        }
        get layer() {
            return this._layer;
        }
        toGestureOptions(mode, theme, options) {
            const gesture = options === null || options === void 0 ? void 0 : options.gesture;
            if (gesture === true) {
                return {
                    enable: true,
                    mode: theme.getGestureMode(mode)
                };
            }
            else if (gesture === false) {
                return {
                    enable: false,
                    mode: theme.getGestureMode(mode)
                };
            }
            else if (gesture != null) {
                if (gesture.enable === undefined) {
                    gesture.enable = theme.isGestureEnabled(mode);
                }
                if (gesture.mode === undefined) {
                    gesture.mode = theme.getGestureMode(mode);
                }
                return gesture;
            }
            return {
                enable: theme.isGestureEnabled(mode),
                mode: theme.getGestureMode(mode)
            };
        }
        onParentResize(parentWidth, parentHeight, parentPadding) {
            if (this.isOpened()) {
                const layer = this._layer;
                if (layer != null) {
                    const gesture = this._gesture;
                    if (gesture.isDirty()) {
                        const position = this.position;
                        gesture.constraint(this, layer, position.x, position.y);
                    }
                }
            }
            super.onParentResize(parentWidth, parentHeight, parentPadding);
        }
        getAnimation() {
            var _a, _b;
            let result = this._animation;
            if (result === undefined) {
                result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.animation) !== null && _b !== void 0 ? _b : this.theme.newAnimation(this._mode);
                if (result) {
                    result.target = this;
                    result.on("end", (isReverse) => {
                        this.onAnimationEnd(isReverse);
                    });
                }
                this._animation = result;
            }
            return result;
        }
        onAnimationEnd(isReverse) {
            if (isReverse) {
                if (this._mode === DDialogMode.MODELESS) {
                    this.hide();
                }
                else {
                    const parent = this.parent;
                    if (parent) {
                        parent.removeChild(this);
                    }
                }
            }
            else {
                const layer = DApplications.getLayer(this);
                if (layer) {
                    const focusController = layer.getFocusController();
                    this._focused = focusController.get();
                    focusController.focus(this.findFirstFocusable(focusController) || this);
                }
            }
        }
        findFirstFocusable(focusController) {
            return focusController.find(this, false, true, true);
        }
        /**
         * Opens a dialog.
         *
         * @param opener An opener of a dialog.
         * The dialog position is determined based on a position and a size of the opener.
         * If the opener is undefined, the dialog is placed at the center of the screen.
         *
         * @returns a value of this dialog
         */
        open(opener) {
            let result = this._promise;
            if (result == null) {
                result = new Promise((resolve, reject) => {
                    this._resolve = resolve;
                    this._reject = reject;
                });
                this._promise = result;
                this._opener = opener;
                // Attach to a layer
                let layer = null;
                switch (this._mode) {
                    case DDialogMode.MODAL:
                    case DDialogMode.MENU:
                        layer = this._overlay.pick(this, opener);
                        layer.stage.addChild(this);
                        break;
                    case DDialogMode.MODELESS:
                        layer = DApplications.getLayer(this);
                        this.show();
                        break;
                }
                this._layer = layer;
                // Position & size
                const gesture = this._gesture;
                if (gesture.mode === DDialogGestureMode.CLEAN) {
                    gesture.toClean();
                }
                if (layer != null) {
                    if (gesture.isClean()) {
                        const renderer = layer.renderer;
                        const onPrerenderBound = this._onPrerenderBound;
                        if (this._sticky) {
                            renderer.on("prerender", onPrerenderBound);
                        }
                        else {
                            renderer.once("prerender", onPrerenderBound);
                        }
                    }
                    else {
                        const position = this.position;
                        gesture.constraint(this, layer, position.x, position.y);
                    }
                }
                // Bring To Front
                this.bringToFront();
                // Done
                this.onOpen();
            }
            return result;
        }
        onChildFocus(focused) {
            super.onChildFocus(focused);
            this.bringToFront();
        }
        onFocus() {
            super.onFocus();
            this.bringToFront();
        }
        bringToFront() {
            const parent = this.parent;
            if (parent == null) {
                return;
            }
            const children = parent.children;
            const childrenLength = children.length;
            let index = childrenLength - 1;
            for (; 0 <= index; --index) {
                if (children[index] === this) {
                    break;
                }
            }
            if (index < 0) {
                return;
            }
            for (let i = index + 1; i < childrenLength; ++i) {
                children[i - 1] = children[i];
            }
            children[childrenLength - 1] = this;
            children.sort((a, b) => {
                return ((a instanceof DDialog ? (a._alwaysOnTop ? 2 : 1) : 0) -
                    (b instanceof DDialog ? (b._alwaysOnTop ? 2 : 1) : 0));
            });
        }
        onPrerender() {
            var _a;
            const layer = this._layer;
            if (layer == null) {
                return;
            }
            const align = this._align;
            if (align === UtilAttachAlign.NONE) {
                return;
            }
            const opener = this._opener;
            if (align != null && opener != null) {
                const mode = this._mode;
                const bounds = opener.getBounds(false, ((_a = DDialog.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DDialog.WORK_BOUNDS = new pixi_js.Rectangle())));
                const theme = this.theme;
                UtilAttach.attach(this, bounds, theme.getOffsetX(mode), theme.getOffsetY(mode), layer.width, layer.height, align);
            }
            else {
                this.position.set((layer.width - this.width) * 0.5, (layer.height - this.height) * 0.5);
            }
        }
        onOpen() {
            this.emit("open", this);
            // Animation
            const animation = this.getAnimation();
            if (animation) {
                animation.start();
            }
            else if (this._mode === DDialogMode.MENU) {
                this.visible = true;
                this.onAnimationEnd(false);
            }
        }
        isOpened() {
            return this._promise != null;
        }
        close() {
            this.doReject();
        }
        doResolve(value) {
            const resolve = this._resolve;
            if (resolve) {
                this._promise = undefined;
                this._resolve = undefined;
                this._reject = undefined;
                this.onClose();
                resolve(value);
            }
        }
        doReject(reason) {
            const reject = this._reject;
            if (reject) {
                this._promise = undefined;
                this._resolve = undefined;
                this._reject = undefined;
                this.onClose();
                reject(reason);
            }
        }
        onClose() {
            // Focus
            const layer = this._layer;
            const focused = this._focused;
            if (focused != null) {
                this._focused = null;
                if (layer) {
                    const focusedLayer = DApplications.getLayer(focused);
                    if (focusedLayer != null && layer !== focusedLayer) {
                        focusedLayer.view.focus();
                    }
                    layer.getFocusController().focus(focused);
                }
                else {
                    this.blur(true);
                }
            }
            else {
                this.blur(true);
            }
            // Remove the prerender event handler and forget the layer
            if (layer) {
                layer.renderer.off("prerender", this._onPrerenderBound);
                this._layer = null;
            }
            // Forget the opener
            this._opener = null;
            // Animation
            const animation = this.getAnimation();
            if (animation) {
                animation.start(true);
            }
            else {
                this.visible = false;
                this.onAnimationEnd(true);
            }
            // Always On Top
            if (this._alwaysOnTop) {
                const parent = this.parent;
                if (parent != null) {
                    parent.off("childAdded", this._onParentChildAddedBound);
                }
            }
            this.emit("close", this);
        }
        onKeyDown(e) {
            if (this._closeOn & DDialogCloseOn.ESC) {
                if (UtilKeyboardEvent.isCancelKey(e)) {
                    this.onCloseOn();
                }
            }
            return super.onKeyDown(e);
        }
        onCloseOn() {
            this.close();
        }
        containsGlobalPoint(point) {
            switch (this._mode) {
                case DDialogMode.MODAL:
                case DDialogMode.MENU:
                    return true;
                case DDialogMode.MODELESS:
                    return super.containsGlobalPoint(point);
            }
        }
        getType() {
            return "DDialog";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DLayoutDirection = {
        VERTICAL: 0,
        HORIZONTAL: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DLayoutSpace extends DBase {
        constructor(options) {
            super(options);
            this.visible = false;
        }
        getType() {
            return "DLayoutSpace";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const isVisible = (child) => {
        return child instanceof DBase && (child.visible || child instanceof DLayoutSpace);
    };
    const toMultiplicity = (theme, options) => {
        if (options) {
            const row = options.row;
            if (row != null) {
                return row;
            }
            const column = options.column;
            if (column != null) {
                return column;
            }
        }
        return theme.getMultiplicity();
    };
    const toMargin = (theme, options) => {
        var _a, _b;
        const margin = options === null || options === void 0 ? void 0 : options.margin;
        if (margin != null) {
            if (isNumber(margin)) {
                return {
                    horizontal: margin,
                    vertical: margin
                };
            }
            else {
                const themeMargin = theme.getMargin();
                return {
                    horizontal: (_a = margin.horizontal) !== null && _a !== void 0 ? _a : themeMargin,
                    vertical: (_b = margin.vertical) !== null && _b !== void 0 ? _b : themeMargin
                };
            }
        }
        else {
            const themeMargin = theme.getMargin();
            return {
                horizontal: themeMargin,
                vertical: themeMargin
            };
        }
    };
    const toDirection = (theme, options) => {
        const direction = options === null || options === void 0 ? void 0 : options.direction;
        if (direction != null) {
            if (isString(direction)) {
                return DLayoutDirection[direction];
            }
            else {
                return direction;
            }
        }
        return theme.getDirection();
    };
    const toCornerAdjust = (theme, options) => {
        const corner = options === null || options === void 0 ? void 0 : options.corner;
        if (corner != null && !isNumber(corner)) {
            const adjust = corner.adjust;
            if (adjust != null) {
                return adjust;
            }
        }
        return theme.getCornerAdjust();
    };
    const toReverse = (theme, options) => {
        var _a;
        return (_a = options === null || options === void 0 ? void 0 : options.reverse) !== null && _a !== void 0 ? _a : theme.getReverse();
    };
    class DLayout extends DBase {
        init(options) {
            super.init(options);
            const theme = this.theme;
            this._margin = toMargin(theme, options);
            this._direction = toDirection(theme, options);
            this._cornerAdjust = toCornerAdjust(theme, options);
            this._multiplicity = toMultiplicity(theme, options);
            this._reverse = toReverse(theme, options);
        }
        get margin() {
            return this._margin;
        }
        get multiplicity() {
            return this._multiplicity;
        }
        getWeightTotal() {
            const children = this.children;
            let result = 0;
            const multiplicity = this._multiplicity;
            const reverse = this._reverse;
            for (let i = 0, imax = children.length; i < imax;) {
                let weight = -1;
                let j = 0;
                for (; j < multiplicity && i + j < imax; ++j) {
                    const child = children[reverse ? imax - 1 - (i + j) : i + j];
                    if (isVisible(child)) {
                        const clearType = child.getClearType();
                        if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                            break;
                        }
                        else {
                            weight = Math.max(weight, child.weight);
                            if (clearType && DLayoutClearType.AFTER) {
                                j += 1;
                                break;
                            }
                        }
                    }
                    else {
                        i += 1;
                        j -= 1;
                    }
                }
                i += j;
                if (0 <= weight) {
                    result += weight;
                }
            }
            return result;
        }
        getSpaceLeft(baseSize, margin) {
            const children = this.children;
            const multiplicity = this._multiplicity;
            const reverse = this._reverse;
            if (this._direction === DLayoutDirection.VERTICAL) {
                let result = baseSize;
                let marginNext = 0;
                for (let i = 0, imax = children.length; i < imax;) {
                    let height = 0;
                    let weight = -1;
                    let j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        const child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            const clearType = child.getClearType();
                            if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    height = Math.max(height, child.height + marginNext);
                                }
                                else {
                                    height = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= height;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
            else {
                let result = baseSize;
                let marginNext = 0;
                for (let i = 0, imax = children.length; i < imax;) {
                    let width = 0;
                    let weight = -1;
                    let j = 0;
                    for (; j < multiplicity && i + j < imax; ++j) {
                        const child = children[reverse ? imax - 1 - (i + j) : i + j];
                        if (isVisible(child)) {
                            const clearType = child.getClearType();
                            if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                break;
                            }
                            else {
                                weight = Math.max(weight, child.weight);
                                if (weight < 0) {
                                    width = Math.max(width, child.width + marginNext);
                                }
                                else {
                                    width = marginNext;
                                }
                                if (clearType & DLayoutClearType.AFTER) {
                                    j += 1;
                                    break;
                                }
                            }
                        }
                        else {
                            i += 1;
                            j -= 1;
                        }
                    }
                    i += j;
                    result -= width;
                    marginNext = margin;
                }
                return Math.max(0, result);
            }
        }
        calcSpaceLeft(isOn, size, padding, margin) {
            return isOn ? 0 : this.getSpaceLeft(size - padding, margin);
        }
        onRefit() {
            const children = this.children;
            const padding = this._padding;
            const paddingTop = padding.getTop();
            const paddingBottom = padding.getBottom();
            const paddingLeft = padding.getLeft();
            const paddingRight = padding.getRight();
            const margin = this._margin;
            const marginVertical = margin.vertical;
            const marginHorizontal = margin.horizontal;
            const weightTotal = this.getWeightTotal();
            const multiplicity = this._multiplicity;
            const reverse = this._reverse;
            const auto = this._auto;
            let cornerAdjustWork = null;
            if (this._cornerAdjust) {
                const requiredSize = 4 + (children.length << 1);
                if (DLayout.CORNER_ADJUST_WORK == null ||
                    DLayout.CORNER_ADJUST_WORK.length < requiredSize) {
                    DLayout.CORNER_ADJUST_WORK = new Float32Array(requiredSize);
                }
                cornerAdjustWork = DLayout.CORNER_ADJUST_WORK;
                cornerAdjustWork[0] = -2;
                cornerAdjustWork[1] = -2;
                cornerAdjustWork[requiredSize - 2] = -3;
                cornerAdjustWork[requiredSize - 1] = -3;
            }
            if (this._direction === DLayoutDirection.VERTICAL) {
                let irow = 0;
                let y = paddingTop - marginVertical;
                if (0 < weightTotal) {
                    const weightTotalInverse = 1 / weightTotal;
                    const spaceLeft = this.calcSpaceLeft(auto.height.isOn, this.height, paddingTop + paddingBottom, marginVertical);
                    for (let i = 0, imax = children.length; i < imax;) {
                        let x = paddingLeft - marginHorizontal;
                        let height = 0;
                        let j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            const child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                const clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    const weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            const k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            const k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    const k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (let i = 0, imax = children.length; i < imax; ++i) {
                            const child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                const i1 = 2 + (i << 1);
                                const icolumn1 = cornerAdjustWork[i1 + 0];
                                const irow1 = cornerAdjustWork[i1 + 1];
                                const clearType = child.getClearType();
                                let icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    const i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                let icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    const i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                const ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
                else {
                    for (let i = 0, imax = children.length; i < imax;) {
                        let x = paddingLeft - marginHorizontal;
                        let height = 0;
                        let j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            const child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                const clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    const weight = child.weight;
                                    if (0 <= weight) {
                                        child.height = 0;
                                    }
                                    x += marginHorizontal + child.width;
                                    height = Math.max(height, child.height);
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            const k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            const k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = j;
                                            cornerAdjustWork[k + 1] = irow;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    const k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = j - 1;
                                    cornerAdjustWork[k + 1] = irow;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        y += marginVertical + height;
                        i += j;
                        irow += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (let i = 0, imax = children.length; i < imax; ++i) {
                            const child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                const i1 = 2 + (i << 1);
                                const icolumn1 = cornerAdjustWork[i1 + 0];
                                const irow1 = cornerAdjustWork[i1 + 1];
                                const clearType = child.getClearType();
                                let icolumn0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    const i0 = this.findRowIndexPrevious(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        icolumn0 = cornerAdjustWork[i0];
                                    }
                                }
                                let icolumn2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    const i2 = this.findRowIndexNext(i1, irow1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        icolumn2 = cornerAdjustWork[i2];
                                    }
                                }
                                const ncolumn = this.countColumn(i1, irow1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskColumn(icolumn0, icolumn1, icolumn2, ncolumn);
                            }
                        }
                    }
                }
            }
            else {
                let icolumn = 0;
                let x = paddingLeft - marginHorizontal;
                if (0 < weightTotal) {
                    const weightTotalInverse = 1 / weightTotal;
                    const spaceLeft = this.calcSpaceLeft(auto.width.isOn, this.width, paddingLeft + paddingRight, marginHorizontal);
                    for (let i = 0, imax = children.length; i < imax;) {
                        let y = paddingTop - marginVertical;
                        let width = 0;
                        let j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            const child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                const clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    const weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = spaceLeft * (weight * weightTotalInverse);
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            const k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            const k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    const k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (let i = 0, imax = children.length; i < imax; ++i) {
                            const child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                const i1 = 2 + (i << 1);
                                const icolumn1 = cornerAdjustWork[i1 + 0];
                                const irow1 = cornerAdjustWork[i1 + 1];
                                const clearType = child.getClearType();
                                let irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    const i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                let irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    const i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                const nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
                else {
                    for (let i = 0, imax = children.length; i < imax;) {
                        let y = paddingTop - marginVertical;
                        let width = 0;
                        let j = 0;
                        for (; j < multiplicity && i + j < imax; ++j) {
                            const child = children[reverse ? imax - 1 - (i + j) : i + j];
                            if (isVisible(child)) {
                                const clearType = child.getClearType();
                                if (j !== 0 && clearType & DLayoutClearType.BEFORE) {
                                    break;
                                }
                                else {
                                    child.position.set(marginHorizontal + x, marginVertical + y);
                                    const weight = child.weight;
                                    if (0 <= weight) {
                                        child.width = 0;
                                    }
                                    width = Math.max(width, child.width);
                                    y += marginVertical + child.height;
                                    if (clearType & DLayoutClearType.AFTER) {
                                        if (cornerAdjustWork != null) {
                                            const k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                        j += 1;
                                        break;
                                    }
                                    else {
                                        if (cornerAdjustWork != null) {
                                            const k = (i + j + 1) << 1;
                                            cornerAdjustWork[k + 0] = icolumn;
                                            cornerAdjustWork[k + 1] = j;
                                        }
                                    }
                                }
                            }
                            else {
                                if (cornerAdjustWork != null) {
                                    const k = (i + j + 1) << 1;
                                    cornerAdjustWork[k + 0] = icolumn;
                                    cornerAdjustWork[k + 1] = j - 1;
                                }
                                i += 1;
                                j -= 1;
                            }
                        }
                        x += marginHorizontal + width;
                        i += j;
                        icolumn += 1;
                    }
                    if (cornerAdjustWork != null) {
                        for (let i = 0, imax = children.length; i < imax; ++i) {
                            const child = children[reverse ? imax - 1 - i : i];
                            if (isVisible(child)) {
                                const i1 = 2 + (i << 1);
                                const icolumn1 = cornerAdjustWork[i1 + 0];
                                const irow1 = cornerAdjustWork[i1 + 1];
                                const clearType = child.getClearType();
                                let irow0 = -2;
                                if (!(clearType & DLayoutClearType.BEFORE)) {
                                    const i0 = this.findColumnIndexPrevious(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeAfter(children, i0)) {
                                        irow0 = cornerAdjustWork[i0 + 1];
                                    }
                                }
                                let irow2 = -2;
                                if (!(clearType & DLayoutClearType.AFTER)) {
                                    const i2 = this.findColumnIndexNext(i1, icolumn1, cornerAdjustWork);
                                    if (!this.hasClearTypeBefore(children, i2)) {
                                        irow2 = cornerAdjustWork[i2 + 1];
                                    }
                                }
                                const nrow = this.countRow(i1, icolumn1, cornerAdjustWork);
                                child.corner.mask = this.toCornerMaskRow(irow0, irow1, irow2, nrow);
                            }
                        }
                    }
                }
            }
            super.onRefit();
        }
        hasClearTypeBefore(children, index) {
            return this.hasClearType(children, index, DLayoutClearType.BEFORE);
        }
        hasClearTypeAfter(children, index) {
            return this.hasClearType(children, index, DLayoutClearType.AFTER);
        }
        hasClearType(children, index, clearType) {
            if (2 <= index) {
                const i = (index - 2) >> 1;
                if (0 <= i && i < children.length) {
                    const child = children[i];
                    if (child instanceof DBase) {
                        return !!(child.getClearType() & clearType);
                    }
                }
            }
            return false;
        }
        findColumnIndexPrevious(istart, icolumn, cornerAdjustWork) {
            for (let i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i] !== icolumn) {
                    return i;
                }
            }
            return 0;
        }
        findColumnIndexNext(istart, icolumn, cornerAdjustWork) {
            for (let i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                const icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    for (let j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j] !== icolumn2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        }
        countRow(istart, icolumn, cornerAdjustWork) {
            for (let i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                const icolumn2 = cornerAdjustWork[i];
                if (icolumn2 !== icolumn) {
                    return cornerAdjustWork[i - 2 + 1] + 1;
                }
            }
            return 0;
        }
        findRowIndexPrevious(istart, irow, cornerAdjustWork) {
            for (let i = istart - 2; 0 <= i; i -= 2) {
                if (cornerAdjustWork[i + 1] !== irow) {
                    return i;
                }
            }
            return 0;
        }
        findRowIndexNext(istart, irow, cornerAdjustWork) {
            for (let i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                const irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    for (let j = i + 2; j < imax; j += 2) {
                        if (cornerAdjustWork[j + 1] !== irow2) {
                            return j - 2;
                        }
                    }
                    return i;
                }
            }
            return cornerAdjustWork.length - 2;
        }
        countColumn(istart, irow, cornerAdjustWork) {
            for (let i = istart + 2, imax = cornerAdjustWork.length; i < imax; i += 2) {
                const irow2 = cornerAdjustWork[i + 1];
                if (irow2 !== irow) {
                    return cornerAdjustWork[i - 2 + 0] + 1;
                }
            }
            return 0;
        }
        toCornerMaskColumn(i0, i1, i2, n) {
            let result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & ~result;
        }
        toCornerMaskRow(i0, i1, i2, n) {
            let result = DCornerMask.NONE;
            if (i0 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_LEFT;
            }
            if (i2 + 1 < i1 && i1 === 0) {
                result |= DCornerMask.TOP_RIGHT;
            }
            if (i0 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_LEFT;
            }
            if (i2 < i1 && i1 + 1 === n) {
                result |= DCornerMask.BOTTOM_RIGHT;
            }
            return DCornerMask.ALL & ~result;
        }
        addSpace(options) {
            return this.addChild(new DLayoutSpace(options));
        }
        getType() {
            return "DLayout";
        }
    }
    DLayout.CORNER_ADJUST_WORK = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DLayoutVertical extends DLayout {
        getType() {
            return "DLayoutVertical";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogLayeredContent extends DLayoutVertical {
        getType() {
            return "DDialogLayeredContent";
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DButtonBase} option when to activate a button.
     */
    const DButtonBaseWhen = {
        /** Activates when clicked */
        CLICKED: 0,
        /** Activates when double clicked */
        DOUBLE_CLICKED: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DAlignWith = {
        TEXT: 0,
        PADDING: 1,
        BORDER: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DAlignHorizontal = {
        LEFT: 0,
        CENTER: 1,
        RIGHT: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DAlignVertical = {
        TOP: 0,
        MIDDLE: 1,
        BOTTOM: 2
    };

    class DImagePieceLayouterPart {
        constructor() {
            this._pieces = [];
            this._bounds = [];
            this._size = 0;
            this._margin = 0;
        }
        clear() {
            this._pieces.length = 0;
            this._bounds.length = 0;
            this._size = 0;
            this._margin = 0;
            this._text = undefined;
        }
        set(text) {
            this._text = text;
        }
        get size() {
            return this._size - (this._text === null ? this._margin : 0);
        }
    }

    class DImagePieceLayouterPartBottom extends DImagePieceLayouterPart {
        add(image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size += margin + bound.height;
            this._margin = margin;
        }
        execute(pbottom, height) {
            const pieces = this._pieces;
            const bounds = this._bounds;
            let y = height - pbottom;
            if (this._text !== undefined) {
                let margin = 0;
                for (let i = 0, imax = pieces.length; i < imax; ++i) {
                    const piece = pieces[i];
                    const bound = bounds[i];
                    const object = piece.object;
                    y -= margin + bound.height;
                    object.y = y - bound.y;
                    margin = piece.margin.horizontal;
                }
            }
            else {
                for (let i = 0, imax = pieces.length; i < imax; ++i) {
                    const piece = pieces[i];
                    const bound = bounds[i];
                    const object = piece.object;
                    y -= piece.margin.horizontal + bound.height;
                    object.y = y - bound.y;
                }
            }
        }
    }

    class DImagePieceLayouterPartCenter extends DImagePieceLayouterPart {
        add(image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size = Math.max(this.size, bound.width);
        }
        execute(pleft, pright, width) {
            const c = pleft + (width - pleft - pright) * 0.5;
            const pieces = this._pieces;
            const bounds = this._bounds;
            for (let i = 0, imax = pieces.length; i < imax; ++i) {
                const piece = pieces[i];
                const bound = bounds[i];
                const object = piece.object;
                object.x = c - bound.x - bound.width * 0.5;
            }
        }
    }

    class DImagePieceLayouterPartLeft extends DImagePieceLayouterPart {
        add(image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size += margin + bound.width;
            this._margin = margin;
        }
        execute(pleft) {
            const pieces = this._pieces;
            const bounds = this._bounds;
            let x = pleft;
            if (this._text !== undefined) {
                for (let i = 0, imax = pieces.length; i < imax; ++i) {
                    const piece = pieces[i];
                    const bound = bounds[i];
                    const object = piece.object;
                    object.x = x - bound.x;
                    x += bound.width + piece.margin.horizontal;
                }
            }
            else {
                for (let i = 0, imax = pieces.length; i < imax; ++i) {
                    const piece = pieces[i];
                    const bound = bounds[i];
                    const object = piece.object;
                    x += piece.margin.horizontal;
                    object.x = x - bound.x;
                    x += bound.width;
                }
            }
        }
    }

    class DImagePieceLayouterPartMiddle extends DImagePieceLayouterPart {
        add(image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size = Math.max(this.size, bound.height);
        }
        execute(ptop, pbottom, height) {
            const c = ptop + (height - ptop - pbottom) * 0.5;
            const pieces = this._pieces;
            const bounds = this._bounds;
            for (let i = 0, imax = pieces.length; i < imax; ++i) {
                const piece = pieces[i];
                const bound = bounds[i];
                const object = piece.object;
                object.y = c - bound.y - bound.height * 0.5;
            }
        }
    }

    class DImagePieceLayouterPartRight extends DImagePieceLayouterPart {
        add(image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size += margin + bound.width;
            this._margin = margin;
        }
        execute(pright, width) {
            const pieces = this._pieces;
            const bounds = this._bounds;
            let x = width - pright;
            if (this._text !== undefined) {
                let margin = 0;
                for (let i = 0, imax = pieces.length; i < imax; ++i) {
                    const piece = pieces[i];
                    const bound = bounds[i];
                    const object = piece.object;
                    x -= margin + bound.width;
                    object.x = x - bound.x;
                    margin = piece.margin.horizontal;
                }
            }
            else {
                for (let i = 0, imax = pieces.length; i < imax; ++i) {
                    const piece = pieces[i];
                    const bound = bounds[i];
                    const object = piece.object;
                    x -= piece.margin.horizontal + bound.width;
                    object.x = x - bound.x;
                }
            }
        }
    }

    class DImagePieceLayouterPartTop extends DImagePieceLayouterPart {
        add(image, bound, margin) {
            this._pieces.push(image);
            this._bounds.push(bound);
            this._size += margin + bound.height;
            this._margin = margin;
        }
        execute(ptop) {
            const pieces = this._pieces;
            const bounds = this._bounds;
            let y = ptop;
            if (this._text !== undefined) {
                let margin = 0;
                for (let i = 0, imax = pieces.length; i < imax; ++i) {
                    const piece = pieces[i];
                    const bound = bounds[i];
                    const object = piece.object;
                    object.y = margin + y - bound.y;
                    y += bound.height;
                    margin = piece.margin.vertical;
                }
            }
            else {
                for (let i = 0, imax = pieces.length; i < imax; ++i) {
                    const piece = pieces[i];
                    const bound = bounds[i];
                    const object = piece.object;
                    y += piece.margin.vertical;
                    object.y = y - bound.y;
                    y += bound.height;
                }
            }
        }
    }

    class DImagePieceLayouterPartContainer {
        constructor() {
            this.left = new DImagePieceLayouterPartLeft();
            this.center = new DImagePieceLayouterPartCenter();
            this.right = new DImagePieceLayouterPartRight();
            this.top = new DImagePieceLayouterPartTop();
            this.middle = new DImagePieceLayouterPartMiddle();
            this.bottom = new DImagePieceLayouterPartBottom();
        }
        clear() {
            this.left.clear();
            this.center.clear();
            this.right.clear();
            this.top.clear();
            this.middle.clear();
            this.bottom.clear();
            this.text = undefined;
        }
        add(image) {
            const object = image.object;
            if (object != null) {
                const bound = object.getLocalBounds();
                const margin = image.margin;
                const align = image.align;
                switch (align.horizontal) {
                    case DAlignHorizontal.LEFT:
                        this.left.add(image, bound, margin.horizontal);
                        break;
                    case DAlignHorizontal.CENTER:
                        this.center.add(image, bound, margin.horizontal);
                        break;
                    case DAlignHorizontal.RIGHT:
                        this.right.add(image, bound, margin.horizontal);
                        break;
                }
                switch (align.vertical) {
                    case DAlignVertical.TOP:
                        this.top.add(image, bound, margin.vertical);
                        break;
                    case DAlignVertical.MIDDLE:
                        this.middle.add(image, bound, margin.vertical);
                        break;
                    case DAlignVertical.BOTTOM:
                        this.bottom.add(image, bound, margin.vertical);
                        break;
                }
            }
        }
        set(text) {
            this.left.set(text);
            this.center.set(text);
            this.right.set(text);
            this.top.set(text);
            this.middle.set(text);
            this.bottom.set(text);
            this.text = text;
        }
        get width() {
            const text = this.text;
            const left = this.left;
            const leftSize = left.size;
            const center = this.center;
            const centerSize = center.size;
            const right = this.right;
            const rightSize = right.size;
            if (text !== undefined) {
                if (text !== null) {
                    return Math.max(leftSize + text.width + rightSize, centerSize);
                }
                else {
                    return Math.max(leftSize + rightSize, centerSize);
                }
            }
            else {
                return Math.max(leftSize, rightSize, centerSize);
            }
        }
        get height() {
            const text = this.text;
            const top = this.top;
            const topSize = top.size;
            const middle = this.middle;
            const middleSize = middle.size;
            const bottom = this.bottom;
            const bottomSize = bottom.size;
            if (text !== undefined) {
                if (text !== null) {
                    return Math.max(topSize + text.height + bottomSize, middleSize);
                }
                else {
                    return Math.max(topSize + bottomSize, middleSize);
                }
            }
            else {
                return Math.max(topSize, bottomSize, middleSize);
            }
        }
        execute(pleft, ptop, pright, pbottom, textAlign, width, height) {
            const left = this.left;
            const center = this.center;
            const right = this.right;
            const top = this.top;
            const middle = this.middle;
            const bottom = this.bottom;
            const text = this.text;
            if (text !== undefined) {
                const leftSize = left.size;
                const rightSize = right.size;
                const topSize = top.size;
                const bottomSize = bottom.size;
                let textX = 0;
                let textWidth = 0;
                let textHeight = 0;
                if (text != null) {
                    text.setClippingDelta(leftSize + rightSize, topSize + bottomSize);
                    textWidth = text.width;
                    textHeight = text.height;
                }
                switch (textAlign.horizontal) {
                    case DAlignHorizontal.LEFT:
                        textX = pleft + leftSize;
                        break;
                    case DAlignHorizontal.CENTER:
                        textX =
                            pleft +
                                (width - pleft - pright - (leftSize + textWidth + rightSize)) * 0.5 +
                                leftSize;
                        break;
                    case DAlignHorizontal.RIGHT:
                        textX = width - pright - rightSize - textWidth;
                        break;
                }
                let textY = 0;
                switch (textAlign.vertical) {
                    case DAlignVertical.TOP:
                        textY = ptop + topSize;
                        break;
                    case DAlignVertical.MIDDLE:
                        textY =
                            ptop +
                                (height - ptop - pbottom - (topSize + textHeight + bottomSize)) * 0.5 +
                                topSize;
                        break;
                    case DAlignVertical.BOTTOM:
                        textY = height - pbottom - bottomSize - textHeight;
                        break;
                }
                if (text != null) {
                    text.position.set(textX, textY);
                }
                left.execute(textX - leftSize);
                center.execute(0, 0, textX * 2 + textWidth);
                right.execute(0, textX + textWidth + rightSize);
                top.execute(textY - topSize);
                middle.execute(0, 0, textY * 2 + textHeight);
                bottom.execute(0, textY + textHeight + bottomSize);
            }
            else {
                left.execute(pleft);
                center.execute(pleft, pright, width);
                right.execute(pright, width);
                top.execute(ptop);
                middle.execute(ptop, pbottom, height);
                bottom.execute(pbottom, height);
            }
        }
    }

    class DImagePieceLayouter {
        constructor() {
            this.text = new DImagePieceLayouterPartContainer();
            this.padding = new DImagePieceLayouterPartContainer();
            this.border = new DImagePieceLayouterPartContainer();
        }
        clear() {
            this.text.clear();
            this.padding.clear();
            this.border.clear();
        }
        add(image) {
            const object = image.object;
            if (object) {
                switch (image.align.with) {
                    case DAlignWith.TEXT:
                        this.text.add(image);
                        break;
                    case DAlignWith.PADDING:
                        this.padding.add(image);
                        break;
                    case DAlignWith.BORDER:
                        this.border.add(image);
                        break;
                }
            }
        }
        set(text) {
            this.text.set(text);
        }
        execute(padding, textAlign, width, height) {
            const pleft = padding.getLeft();
            const ptop = padding.getTop();
            const pright = padding.getRight();
            const pbottom = padding.getBottom();
            if (width == null) {
                width = pleft + this.width + pright;
            }
            if (height == null) {
                height = ptop + this.height + pbottom;
            }
            this.border.execute(0, 0, 0, 0, textAlign, width, height);
            this.padding.execute(pleft, ptop, pright, pbottom, textAlign, width, height);
            this.text.execute(pleft, ptop, pright, pbottom, textAlign, width, height);
        }
        get width() {
            return Math.max(this.border.width, this.padding.width, this.text.width);
        }
        get height() {
            return Math.max(this.border.height, this.padding.height, this.text.height);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBaseOverflowMaskSimple extends pixi_js.Graphics {
        constructor(parent) {
            super();
            this.parent = parent;
            this._isInitialized = false;
            this._width = this.width;
            this._height = this.height;
        }
        render(renderer) {
            this.updateTransform();
            super.render(renderer);
        }
        onReflow(base, width, height) {
            if (this._isInitialized && this._width === width && this._height === height) {
                return;
            }
            this._isInitialized = true;
            this._width = width;
            this._height = height;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.drawRect(0, 0, width, height);
            this.endFill();
        }
    }

    class DDynamicTextMeasureResultCharacter {
        constructor(x, y, character, wrappable) {
            this.x = x;
            this.y = y;
            this.character = character;
            this.wrappable = wrappable;
        }
        set(x, y, character, isWrappable) {
            this.x = x;
            this.y = y;
            this.character = character;
            this.wrappable = isWrappable;
        }
    }

    class DDynamicTextMeasureResult {
        constructor() {
            this.count = 0;
            this.countPerLine = 0;
            this.width = 0;
            this.height = 0;
            this.characters = [];
            this.scale = 1;
            this.scaled = false;
            this.clipped = false;
            this.x = 0;
            this.y = 0;
        }
        start(lineHeight, fontHeight) {
            this.count = 0;
            this.countPerLine = 0;
            this.width = 0;
            this.height = 0;
            this.scale = 1;
            this.scaled = false;
            this.clipped = false;
            this.x = 0;
            this.y = 0.5 * (lineHeight - fontHeight);
        }
        isPushable(width, character) {
            const x = this.x + character.advance;
            if (width < x) {
                if (character.type & DynamicFontAtlasCharacterType.SPACE) {
                    return true;
                }
                else {
                    return false;
                }
            }
            return true;
        }
        isPushableAtNewLine(height, lineHeight, fontHeight) {
            return this.y + 1.5 * lineHeight + 0.5 * fontHeight <= height;
        }
        push(character, isWrappable) {
            const x = this.x;
            this.x += character.advance;
            const y = this.y;
            const count = this.count;
            const characters = this.characters;
            if (count < characters.length) {
                characters[count].set(x, y, character, isWrappable);
            }
            else {
                characters.push(new DDynamicTextMeasureResultCharacter(x, y, character, isWrappable));
            }
            this.count += 1;
            this.countPerLine += 1;
        }
        newLine(lineHeight) {
            this.width = Math.max(this.width, this.x);
            this.x = 0;
            this.y += lineHeight;
            this.countPerLine = 0;
        }
        wordWrap(lineHeight) {
            const countPerLine = this.countPerLine;
            const characters = this.characters;
            if (0 < countPerLine) {
                const count = this.count;
                for (let i = count - 1, imin = count - countPerLine; imin < i; --i) {
                    let character = characters[i];
                    if (character.wrappable) {
                        let x = character.character.advance;
                        const y = character.y + lineHeight;
                        character.x = 0;
                        character.y = y;
                        for (let j = i + 1; j < count; ++j) {
                            character = characters[j];
                            character.x = x;
                            character.y = y;
                            x += character.character.advance;
                        }
                        this.x = x;
                        this.y = y;
                        this.countPerLine = count - i;
                        return true;
                    }
                }
                const last = characters[count - 1];
                last.x = 0;
                last.y = last.y + lineHeight;
                this.x = last.character.advance;
                this.y = last.y;
                this.countPerLine = 1;
                return false;
            }
            return false;
        }
        pop() {
            const countPerLine = this.countPerLine;
            const characters = this.characters;
            if (0 < countPerLine) {
                const character = characters[this.count - 1];
                this.x -= character.character.advance;
                this.count -= 1;
                this.countPerLine -= 1;
                return true;
            }
            return false;
        }
        fit(width, height) {
            const w = this.width;
            const h = this.height;
            if (1e-4 < w && width < w) {
                if (1e-4 < h && height < h) {
                    this.scale = Math.min(width / w, height / h);
                    this.scaled = true;
                }
                else {
                    this.scale = width / w;
                    this.scaled = true;
                }
            }
            else if (1e-4 < h && height < h) {
                this.scale = height / h;
                this.scaled = true;
            }
        }
        end(lineHeight, fontHeight) {
            this.newLine(lineHeight);
            this.y -= 0.5 * (lineHeight - fontHeight);
            this.height = this.y;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilCharacterIterator {
        constructor() {
            this.target = "";
            this.position = 0;
        }
        init(target) {
            this.target = target;
            this.position = 0;
        }
        hasNext() {
            return this.position < this.target.length;
        }
        findNextBreak(target, istart) {
            const iend = target.length;
            for (let i = istart; i < iend; ++i) {
                const code = target.charCodeAt(i);
                if (!this.isLowSurrogate(code) && !this.isVariationSelector(code)) {
                    return i;
                }
            }
            return iend;
        }
        isHighSurrogate(code) {
            return 0xd800 <= code && code <= 0xdbff;
        }
        isLowSurrogate(code) {
            return 0xdc00 <= code && code <= 0xdfff;
        }
        isVariationSelector(code) {
            return 0xfe00 <= code && code <= 0xfe0f;
        }
        next() {
            const target = this.target;
            const position = this.position;
            const nextBreak = this.findNextBreak(target, position + 1);
            const result = target.substring(position, nextBreak);
            this.position = nextBreak;
            return result;
        }
        /**
         * Closes this iterator.
         *
         * @returns true if closed.
         */
        close() {
            const length = this.target.length;
            if (this.position < length) {
                this.position = length;
                return true;
            }
            return false;
        }
        static from(target) {
            if (UtilCharacterIterator._instance == null) {
                UtilCharacterIterator._instance = new UtilCharacterIterator();
            }
            const instance = UtilCharacterIterator._instance;
            instance.init(target);
            return instance;
        }
    }
    UtilCharacterIterator._instance = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DDynamicTextStyleWordWrap = {
        NONE: 0,
        NORMAL: 1,
        BREAK_ALL: 2
    };

    class DDynamicTextMeasure {
        static measure(text, atlas, modifier) {
            const result = DDynamicTextMeasure.RESULT || new DDynamicTextMeasureResult();
            DDynamicTextMeasure.RESULT = result;
            if (atlas != null) {
                const itr = UtilCharacterIterator.from(text);
                const fh = atlas.font.height;
                const lh = modifier.lineHeight;
                const cf = modifier.fitting;
                const cc = !cf && modifier.clipping;
                const cw = modifier.width;
                const ch = modifier.height;
                const cp = !cf && modifier.wordWrap;
                result.start(lh, fh);
                switch (cp) {
                    case DDynamicTextStyleWordWrap.BREAK_ALL:
                        if (cc) {
                            this.measure1(itr, cw, ch, fh, lh, atlas, result);
                        }
                        else {
                            this.measure2(itr, cw, lh, atlas, result);
                        }
                        break;
                    case DDynamicTextStyleWordWrap.NORMAL:
                        const lb = this.newLineBreaker(text);
                        if (lb) {
                            if (cc) {
                                this.measure1a(lb, itr, cw, ch, fh, lh, atlas, result);
                            }
                            else {
                                this.measure2a(lb, itr, cw, lh, atlas, result);
                            }
                        }
                        else {
                            if (cc) {
                                this.measure1b(itr, cw, ch, fh, lh, atlas, result);
                            }
                            else {
                                this.measure2b(itr, cw, lh, atlas, result);
                            }
                        }
                        break;
                    default:
                        if (cc) {
                            this.measure3(itr, cw, ch, fh, lh, atlas, result);
                        }
                        else {
                            this.measure4(itr, lh, atlas, result);
                        }
                        break;
                }
                result.end(lh, fh);
                if (cf) {
                    result.fit(cw, ch);
                }
            }
            else {
                result.start(0, 0);
                result.end(0, 0);
            }
            return result;
        }
        static measure1a(lineBreaker, iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            let lineBreak = lineBreaker.next();
            while (iterator.hasNext()) {
                const characterPosition = iterator.position;
                const character = iterator.next();
                if (character === Character.NEW_LINE) {
                    if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                        result.newLine(lineHeight);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                    }
                }
                else {
                    const a = atlas.get(character);
                    if (a == null)
                        continue;
                    lineBreak = this.advance(characterPosition, lineBreak, lineBreaker);
                    const isWrappable = this.isWrappable1(characterPosition, lineBreak);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                            result.push(a, isWrappable);
                            result.wordWrap(lineHeight);
                        }
                        else {
                            this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                        }
                    }
                }
            }
        }
        static measure1b(iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                const character = iterator.next();
                if (character === Character.NEW_LINE) {
                    if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                        result.newLine(lineHeight);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                    }
                }
                else {
                    const a = atlas.get(character);
                    if (a == null)
                        continue;
                    const isWrappable = this.isWrappable2(result, a);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                            result.push(a, isWrappable);
                            result.wordWrap(lineHeight);
                        }
                        else {
                            this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                        }
                    }
                }
            }
        }
        static measure1(iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                const character = iterator.next();
                if (character === Character.NEW_LINE) {
                    if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                        result.newLine(lineHeight);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                    }
                }
                else {
                    const a = atlas.get(character);
                    if (a == null)
                        continue;
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, true);
                    }
                    else {
                        if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                            result.newLine(lineHeight);
                            result.push(a, true);
                        }
                        else {
                            this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                        }
                    }
                }
            }
        }
        static measure2a(lineBreaker, iterator, clippingWidth, lineHeight, atlas, result) {
            let lineBreak = lineBreaker.next();
            while (iterator.hasNext()) {
                const characterPosition = iterator.position;
                const character = iterator.next();
                if (character === Character.NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    const a = atlas.get(character);
                    if (a == null)
                        continue;
                    lineBreak = this.advance(characterPosition, lineBreak, lineBreaker);
                    const isWrappable = this.isWrappable1(characterPosition, lineBreak);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        result.push(a, isWrappable);
                        result.wordWrap(lineHeight);
                    }
                }
            }
        }
        static measure2b(iterator, clippingWidth, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                const character = iterator.next();
                if (character === Character.NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    const a = atlas.get(character);
                    if (a == null)
                        continue;
                    const isWrappable = this.isWrappable2(result, a);
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, isWrappable);
                    }
                    else {
                        result.push(a, isWrappable);
                        result.wordWrap(lineHeight);
                    }
                }
            }
        }
        static measure2(iterator, clippingWidth, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                const character = iterator.next();
                if (character === Character.NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    const a = atlas.get(character);
                    if (a == null)
                        continue;
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, false);
                    }
                    else {
                        result.newLine(lineHeight);
                        result.push(a, false);
                    }
                }
            }
        }
        static measure3(iterator, clippingWidth, clippingHeight, fontHeight, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                const character = iterator.next();
                if (character === Character.NEW_LINE) {
                    if (result.isPushableAtNewLine(clippingHeight, lineHeight, fontHeight)) {
                        result.newLine(lineHeight);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, true);
                    }
                }
                else {
                    const a = atlas.get(character);
                    if (a == null)
                        continue;
                    if (result.isPushable(clippingWidth, a)) {
                        result.push(a, false);
                    }
                    else {
                        this.measure5(iterator, clippingWidth, lineHeight, atlas, result, false);
                    }
                }
            }
        }
        static measure4(iterator, lineHeight, atlas, result) {
            while (iterator.hasNext()) {
                const character = iterator.next();
                if (character === Character.NEW_LINE) {
                    result.newLine(lineHeight);
                }
                else {
                    const a = atlas.get(character);
                    if (a == null)
                        continue;
                    result.push(a, false);
                }
            }
        }
        static measure5(iterator, clippingWidth, lineHeight, atlas, result, close) {
            result.clipped = true;
            const dots = atlas.get(Character.DOTS);
            if (dots != null) {
                while (!result.isPushable(clippingWidth, dots)) {
                    if (!result.pop()) {
                        break;
                    }
                }
                if (result.isPushable(clippingWidth, dots)) {
                    result.push(dots, false);
                }
            }
            if (close) {
                iterator.close();
            }
            else {
                while (iterator.hasNext()) {
                    if (iterator.next() === Character.NEW_LINE) {
                        result.newLine(lineHeight);
                        break;
                    }
                }
            }
        }
        static isWrappable2(result, character) {
            if (result.countPerLine <= 0) {
                return false;
            }
            const last = result.characters[result.count - 1];
            const lastType = last.character.type;
            const type = character.type;
            if (lastType & DynamicFontAtlasCharacterType.SPACE) {
                if (type & DynamicFontAtlasCharacterType.SPACE) {
                    return false;
                }
                else {
                    if (lastType & DynamicFontAtlasCharacterType.NON_BREAKING) {
                        return false;
                    }
                    else {
                        return true;
                    }
                }
            }
            else {
                if (type & DynamicFontAtlasCharacterType.SPACE) {
                    return false;
                }
                else {
                    if (lastType & DynamicFontAtlasCharacterType.NON_BREAKING) {
                        if (type & DynamicFontAtlasCharacterType.NON_BREAKING) {
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    else {
                        return true;
                    }
                }
            }
        }
        static advance(position, lineBreak, lineBreaker) {
            if (lineBreak.done) {
                return lineBreak;
            }
            if (position <= lineBreak.value.end) {
                return lineBreak;
            }
            lineBreak = lineBreaker.next();
            return lineBreak;
        }
        static isWrappable1(position, lineBreak) {
            if (lineBreak.done) {
                return false;
            }
            const value = lineBreak.value;
            return value.start === position || value.end === position;
        }
        static newLineBreaker(target) {
            if ("css-line-break" in window) {
                const cssLineBreak = window["css-line-break"];
                return cssLineBreak.LineBreaker(target, {
                    lineBreak: "strict",
                    wordBreak: "normal"
                });
            }
            return null;
        }
    }
    DDynamicTextMeasure.RESULT = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDynamicTextGeometry extends pixi_js.MeshGeometry {
        constructor() {
            var _a, _b, _c;
            super(((_a = DDynamicTextGeometry.VERTICES) !== null && _a !== void 0 ? _a : (DDynamicTextGeometry.VERTICES = new Float32Array(0))), ((_b = DDynamicTextGeometry.UVS) !== null && _b !== void 0 ? _b : (DDynamicTextGeometry.UVS = new Float32Array(0))), ((_c = DDynamicTextGeometry.INDICES) !== null && _c !== void 0 ? _c : (DDynamicTextGeometry.INDICES = new Uint16Array(0))));
            this.width = 0;
            this.height = 0;
            this.scale = 1;
            this.scaled = false;
            this.clipped = false;
            this.vertexBuffer = this.getBuffer("aVertexPosition");
            this.vertices = DDynamicTextGeometry.VERTICES;
            this.uvBuffer = this.getBuffer("aTextureCoord");
            this.uvs = DDynamicTextGeometry.UVS;
            this.indexBuffer = this.getIndex();
            this.indices = DDynamicTextGeometry.INDICES;
            this.nchars = 0;
        }
        update(text, atlas, modifier) {
            const result = DDynamicTextMeasure.measure(text, atlas, modifier);
            const resultCount = result.count;
            let nchars = ((resultCount >> 3) + (resultCount & 0x7 ? 1 : 0)) << 3;
            if (this.nchars < nchars) {
                this.nchars = nchars;
                const nvertex = nchars << 3;
                this.vertices = new Float32Array(nvertex);
                this.uvs = new Float32Array(nvertex);
                this.vertexBuffer.data = this.vertices;
                this.uvBuffer.data = this.uvs;
                const nindex = (nchars << 2) + (nchars << 1);
                this.indices = new Uint16Array(nindex);
                this.indexBuffer.data = this.indices;
                this.initIndices(this.indices);
                this.indexBuffer.update();
            }
            else {
                nchars = this.nchars;
            }
            if (nchars <= 0) {
                return;
            }
            const vertices = this.vertices;
            const uvs = this.uvs;
            if (atlas != null) {
                const characters = result.characters;
                const scale = result.scale;
                const fw = 1 / atlas.width;
                const fh = 1 / atlas.height;
                for (let i = 0; i < resultCount; ++i) {
                    const character = characters[i];
                    const cx = character.x;
                    const cy = character.y;
                    const cc = character.character;
                    this.fill(vertices, uvs, i, cx, cy, scale, cc, fw, fh);
                }
                for (let i = resultCount; i < nchars; ++i) {
                    this.fillBlank(vertices, uvs, i);
                }
                this.width = result.width * scale;
                this.height = result.height * scale;
                this.scale = scale;
                this.scaled = result.scaled;
                this.clipped = result.clipped;
            }
            else {
                for (let i = 0; i < nchars; ++i) {
                    this.fillBlank(vertices, uvs, i);
                }
                this.width = 0;
                this.height = 0;
                this.scale = 1;
                this.scaled = false;
                this.clipped = false;
            }
            this.vertexBuffer.update();
            this.uvBuffer.update();
        }
        fill(vertices, uvs, index, x, y, scale, character, fw, fh) {
            const cx = character.x;
            const cy = character.y;
            const cw = character.width;
            const ch = character.height;
            const cox = character.origin.x;
            const x0 = (x + (cx - cox)) * scale;
            const y0 = y * scale;
            const x1 = x0 + cw * scale;
            const y1 = y0 + ch * scale;
            const iv = index << 3;
            vertices[iv + 0] = x0;
            vertices[iv + 1] = y0;
            vertices[iv + 2] = x1;
            vertices[iv + 3] = y0;
            vertices[iv + 4] = x1;
            vertices[iv + 5] = y1;
            vertices[iv + 6] = x0;
            vertices[iv + 7] = y1;
            const u0 = cx * fw;
            const v0 = cy * fh;
            const u1 = (cx + cw) * fw;
            const v1 = (cy + ch) * fh;
            uvs[iv + 0] = u0;
            uvs[iv + 1] = v0;
            uvs[iv + 2] = u1;
            uvs[iv + 3] = v0;
            uvs[iv + 4] = u1;
            uvs[iv + 5] = v1;
            uvs[iv + 6] = u0;
            uvs[iv + 7] = v1;
        }
        fillBlank(vertices, uvs, index) {
            const iv = index << 3;
            vertices[iv + 0] = 0;
            vertices[iv + 1] = 0;
            vertices[iv + 2] = 0;
            vertices[iv + 3] = 0;
            vertices[iv + 4] = 0;
            vertices[iv + 5] = 0;
            vertices[iv + 6] = 0;
            vertices[iv + 7] = 0;
            uvs[iv + 0] = 0;
            uvs[iv + 1] = 0;
            uvs[iv + 2] = 0;
            uvs[iv + 3] = 0;
            uvs[iv + 4] = 0;
            uvs[iv + 5] = 0;
            uvs[iv + 6] = 0;
            uvs[iv + 7] = 0;
        }
        initIndices(indices) {
            for (let iv = 0, ivmax = this.nchars << 2, ii = 0; iv < ivmax; iv += 4, ii += 6) {
                indices[ii] = iv;
                indices[ii + 1] = iv + 1;
                indices[ii + 2] = iv + 3;
                indices[ii + 3] = iv + 1;
                indices[ii + 4] = iv + 2;
                indices[ii + 5] = iv + 3;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDynamicText extends pixi_js.Mesh {
        constructor(style) {
            super(new DDynamicTextGeometry(), new pixi_js.MeshMaterial(pixi_js.Texture.EMPTY));
            this._style = style;
            style.on("change", () => {
                this.onStyleChange();
            });
            this._text = "";
            this._textApproved = "";
            this._isDirty = true;
            this._isGeometryDirty = true;
            this._atlas = null;
            this._atlasRevisionUpdated = 0;
            this._width = 0;
            this._height = 0;
            this._modifier = {
                clipping: false,
                fitting: false,
                wordWrap: DDynamicTextStyleWordWrap.NONE,
                width: 0,
                height: 0,
                lineHeight: 0,
                delta: {
                    width: 0,
                    height: 0
                }
            };
        }
        onStyleChange() {
            this._isDirty = true;
            this._isGeometryDirty = true;
            this._atlas = null;
            this.update_();
        }
        update_() {
            const layer = DApplications.getLayer(this);
            if (layer) {
                if (this._isDirty) {
                    this._isDirty = false;
                    const text = this._text;
                    const textApproved = this._textApproved;
                    this._textApproved = text;
                    const style = this._style;
                    const fontId = style.fontId;
                    const fontIdApproved = style.fontIdApproved;
                    const fontIdFontSize = style.fontIdFontSize;
                    const fill = style.fill;
                    const fillApproved = style.fillApproved;
                    style.approve();
                    const atlases = layer.getDynamicFontAtlases();
                    if (text !== textApproved || fontId !== fontIdApproved || fill !== fillApproved) {
                        atlases.add(fontId, fontIdFontSize, fill, text);
                        atlases.remove(fontIdApproved, fillApproved, textApproved);
                    }
                }
            }
        }
        get text() {
            return this._text;
        }
        set text(text) {
            if (this._text !== text) {
                this._text = text;
                if (!this._style.unfit()) {
                    this._isDirty = true;
                    this._isGeometryDirty = true;
                    this.update_();
                }
            }
        }
        // @ts-ignore
        get width() {
            this.update();
            return Math.abs(this.scale.x) * this.geometry.width;
        }
        set width(width) {
            this.update();
            const geometryWidth = this.geometry.width;
            if (+1e-4 < geometryWidth) {
                const newScale = width / geometryWidth;
                this.scale.x = 0 <= this.scale.x ? +newScale : -newScale;
            }
        }
        // @ts-ignore
        get height() {
            this.update();
            return Math.abs(this.scale.y) * this.geometry.height;
        }
        set height(height) {
            this.update();
            const geometryHeight = this.geometry.height;
            if (+1e-4 < geometryHeight) {
                const newScale = height / geometryHeight;
                this.scale.y = 0 <= this.scale.y ? +newScale : -newScale;
            }
        }
        get clipped() {
            return this.geometry.clipped;
        }
        get style() {
            return this._style;
        }
        update() {
            this.update_();
            const style = this._style;
            let atlas = this._atlas;
            if (atlas == null) {
                const layer = DApplications.getLayer(this);
                if (layer) {
                    atlas = layer.getDynamicFontAtlases().get(style.fontId, style.fill);
                    if (atlas != null) {
                        this._atlasRevisionUpdated = atlas.getRevisionUpdate();
                        this._atlas = atlas;
                        this.texture = atlas.texture;
                        this._isGeometryDirty = true;
                    }
                }
            }
            else {
                const revisionUpdate = atlas.getRevisionUpdate();
                if (revisionUpdate !== this._atlasRevisionUpdated) {
                    this._atlasRevisionUpdated = revisionUpdate;
                    this._isGeometryDirty = true;
                }
            }
            const modifier = this._modifier;
            if (this.updateClipping(style, modifier)) {
                this._isGeometryDirty = true;
            }
            if (this._isGeometryDirty) {
                this._isGeometryDirty = false;
                const geometry = this.geometry;
                geometry.update(this._text, atlas, modifier);
                if (modifier.fitting && !style.isFontFitted && geometry.scaled) {
                    const oldScale = geometry.scale;
                    const oldFontSize = style.fontSize;
                    const newFontId = style.toFontId(Math.ceil(oldFontSize * oldScale * 1000) / 1000);
                    const newFontSize = UtilFont.toSize(newFontId);
                    const newScale = newFontSize / oldFontSize;
                    const newLineHeight = style.lineHeight * newScale;
                    if (style.fit(newFontSize, newLineHeight)) {
                        setTimeout(() => {
                            DApplications.update(this);
                        }, 0);
                    }
                }
            }
        }
        updateClipping(style, modifier) {
            let isChanged = false;
            const styleClipping = style.clipping;
            if (modifier.clipping !== styleClipping) {
                modifier.clipping = styleClipping;
                isChanged = true;
            }
            const styleFitting = style.fitting;
            if (modifier.fitting !== styleFitting) {
                modifier.fitting = styleFitting;
                isChanged = true;
            }
            const styleWordWrap = style.wordWrap;
            if (modifier.wordWrap !== styleWordWrap) {
                modifier.wordWrap = styleWordWrap;
                isChanged = true;
            }
            const styleLineHeight = styleFitting ? style.lineHeightFitted : style.lineHeight;
            if (modifier.lineHeight !== styleLineHeight) {
                modifier.lineHeight = styleLineHeight;
                isChanged = true;
            }
            if (styleClipping || styleFitting || styleWordWrap) {
                const parent = this.parent;
                if (parent instanceof DBase) {
                    const padding = parent.padding;
                    const width = parent.width - padding.getLeft() - padding.getRight() - modifier.delta.width;
                    if (modifier.width !== width) {
                        modifier.width = width;
                        isChanged = true;
                    }
                    const height = parent.height - padding.getTop() - padding.getBottom() - modifier.delta.height;
                    if (modifier.height !== height) {
                        modifier.height = height;
                        isChanged = true;
                    }
                }
            }
            return isChanged;
        }
        setClippingDelta(width, height) {
            const delta = this._modifier.delta;
            delta.width = width;
            delta.height = height;
        }
        _calculateBounds() {
            this.update();
            const geometry = this.geometry;
            this._bounds.addFrame(this.transform, 0, 0, geometry.width, geometry.height);
        }
        _render(renderer) {
            this.update();
            super._render(renderer);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDynamicTextStyle extends pixi_js.utils.EventEmitter {
        constructor(parent, theme, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            super();
            this._id = 0;
            this._idApproved = -1;
            if (options) {
                this._fontFamily = (_a = options.fontFamily) !== null && _a !== void 0 ? _a : theme.getFontFamilly();
                this._fontSize = (_b = options.fontSize) !== null && _b !== void 0 ? _b : theme.getFontSize();
                this._fontStyle = (_c = options.fontStyle) !== null && _c !== void 0 ? _c : theme.getFontStyle();
                this._fontVariant = (_d = options.fontVariant) !== null && _d !== void 0 ? _d : theme.getFontVariant();
                this._fontWeight = (_e = options.fontWeight) !== null && _e !== void 0 ? _e : theme.getFontWeight();
                this._clipping = (_f = options.clipping) !== null && _f !== void 0 ? _f : theme.getTextStyleClipping();
                this._fitting = (_g = options.fitting) !== null && _g !== void 0 ? _g : theme.getTextStyleFitting();
                this._wordWrap = toEnum((_h = options.wordWrap) !== null && _h !== void 0 ? _h : theme.getTextStyleWordWrap(), DDynamicTextStyleWordWrap);
                this._lineHeight = (_j = options.lineHeight) !== null && _j !== void 0 ? _j : theme.getLineHeight();
            }
            else {
                this._fontFamily = theme.getFontFamilly();
                this._fontSize = theme.getFontSize();
                this._fontStyle = theme.getFontStyle();
                this._fontVariant = theme.getFontVariant();
                this._fontWeight = theme.getFontWeight();
                this._clipping = theme.getTextStyleClipping();
                this._fitting = theme.getTextStyleFitting();
                this._wordWrap = theme.getTextStyleWordWrap();
                this._lineHeight = theme.getLineHeight();
            }
            this._fill = theme.getColor(parent.state);
            this._fontSizeFitted = this._fontSize;
            this._lineHeightFitted = this._lineHeight;
            this._isFontFitted = false;
            this._fontIdFontSize = this._fontSize;
            this._fontIdId = -1;
            this._fontId = "";
            this._fontIdApproved = "";
            this._fillApproved = 0x000000;
        }
        get id() {
            return this._id;
        }
        get idApproved() {
            return this._idApproved;
        }
        get fontId() {
            this.update();
            return this._fontId;
        }
        get fontIdFontSize() {
            this.update();
            return this._fontSizeFitted;
        }
        get fontIdApproved() {
            return this._fontIdApproved;
        }
        get fill() {
            return this._fill;
        }
        set fill(fill) {
            if (this._fill !== fill) {
                this._fill = fill;
                this.onChange();
            }
        }
        onChange() {
            this._id += 1;
            this.emit("change", this);
        }
        get fillApproved() {
            return this._fillApproved;
        }
        approve() {
            this.update();
            this._idApproved = this._id;
            this._fontIdApproved = this._fontId;
            this._fillApproved = this._fill;
        }
        get fontFamily() {
            return this._fontFamily;
        }
        set fontFamily(fontFamily) {
            if (this._fontFamily !== fontFamily) {
                this._fontFamily = fontFamily;
                this.onChange();
            }
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(fontSize) {
            if (this._fontSize !== fontSize) {
                this._fontSize = fontSize;
                this._fontSizeFitted = fontSize;
                this._lineHeightFitted = this._lineHeight;
                this._isFontFitted = false;
                this.onChange();
            }
        }
        get fontSizeFitted() {
            return this._fontSizeFitted;
        }
        get isFontFitted() {
            return this._isFontFitted;
        }
        get fontStyle() {
            return this._fontStyle;
        }
        set fontStyle(fontStyle) {
            if (this._fontStyle !== fontStyle) {
                this._fontStyle = fontStyle;
                this.onChange();
            }
        }
        get fontVariant() {
            return this._fontVariant;
        }
        set fontVariant(fontVariant) {
            if (this._fontVariant !== fontVariant) {
                this._fontVariant = fontVariant;
                this.onChange();
            }
        }
        get fontWeight() {
            return this._fontWeight;
        }
        set fontWeight(fontWeight) {
            if (this._fontWeight !== fontWeight) {
                this._fontWeight = fontWeight;
                this.onChange();
            }
        }
        update() {
            if (this._fontIdId !== this._id) {
                this._fontIdId = this._id;
                const fontIdFontSize = this._fitting ? this._fontSizeFitted : this._fontSize;
                this._fontIdFontSize = fontIdFontSize;
                this._fontId = this.toFontId(fontIdFontSize);
            }
        }
        toFontId(fontSize) {
            return `${this._fontStyle} ${this._fontVariant} ${this._fontWeight} ${fontSize}px ${this._fontFamily}`;
        }
        get clipping() {
            return this._clipping;
        }
        set clipping(clipping) {
            if (this._clipping !== clipping) {
                this._clipping = clipping;
                this.onChange();
            }
        }
        get fitting() {
            return this._fitting;
        }
        set fitting(fitting) {
            if (this._fitting !== fitting) {
                this._fitting = fitting;
                this.onChange();
            }
        }
        get wordWrap() {
            return this._wordWrap;
        }
        set wordWrap(wordWrap) {
            if (this._wordWrap !== wordWrap) {
                this._wordWrap = wordWrap;
                this.onChange();
            }
        }
        get lineHeight() {
            return this._lineHeight;
        }
        set lineHeight(lineHeight) {
            if (this._lineHeight !== lineHeight) {
                this._lineHeight = lineHeight;
                this._fontSizeFitted = this._fontSize;
                this._lineHeightFitted = lineHeight;
                this._isFontFitted = false;
                this.onChange();
            }
        }
        get lineHeightFitted() {
            return this._lineHeightFitted;
        }
        set lineHeightFitted(lineHeightFitted) {
            if (this._lineHeightFitted !== lineHeightFitted) {
                this._lineHeightFitted = lineHeightFitted;
                this.onChange();
            }
        }
        fit(fontSize, lineHeight) {
            let isChanged = false;
            if (fontSize < this._fontSizeFitted) {
                this._fontSizeFitted = fontSize;
                isChanged = true;
            }
            if (this._lineHeightFitted !== lineHeight) {
                this._lineHeightFitted = lineHeight;
                isChanged = true;
            }
            if (this._isFontFitted !== true) {
                this._isFontFitted = true;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return isChanged;
        }
        unfit() {
            let isChanged = false;
            if (this._isFontFitted !== false) {
                this._isFontFitted = false;
                isChanged = true;
            }
            if (this._fontSizeFitted !== this._fontSize) {
                this._fontSizeFitted = this._fontSize;
                isChanged = true;
            }
            if (this._lineHeightFitted !== this._lineHeight) {
                this._lineHeightFitted = this._lineHeight;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return isChanged;
        }
    }

    class DTextPieceAlignImpl {
        constructor(parent, theme, options) {
            var _a, _b;
            this._parent = parent;
            this._vertical = toEnum((_a = options === null || options === void 0 ? void 0 : options.vertical) !== null && _a !== void 0 ? _a : theme.getTextAlignVertical(), DAlignVertical);
            this._horizontal = toEnum((_b = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _b !== void 0 ? _b : theme.getTextAlignHorizontal(), DAlignHorizontal);
        }
        get vertical() {
            return this._vertical;
        }
        set vertical(vertical) {
            vertical = toEnum(vertical, DAlignVertical);
            if (this._vertical !== vertical) {
                this._vertical = vertical;
                this.onChange();
            }
        }
        get horizontal() {
            return this._horizontal;
        }
        set horizontal(horizontal) {
            horizontal = toEnum(horizontal, DAlignHorizontal);
            if (this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                this.onChange();
            }
        }
        set(vertical, horizontal) {
            let isChanged = false;
            if (vertical != null) {
                vertical = toEnum(vertical, DAlignVertical);
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    isChanged = true;
                }
            }
            if (horizontal != null) {
                horizontal = toEnum(horizontal, DAlignHorizontal);
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    isChanged = true;
                }
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        }
        onChange() {
            const parent = this._parent;
            parent.toDirty();
            DApplications.update(parent);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTextPieceStyleImpl {
        constructor(parent, style) {
            this._parent = parent;
            this._style = style;
        }
        get fontFamily() {
            return this._style.fontFamily;
        }
        set fontFamily(fontFamily) {
            const style = this._style;
            if (style.fontFamily !== fontFamily) {
                style.fontFamily = fontFamily;
                this.onChange();
            }
        }
        get fontSize() {
            return this._style.fontSize;
        }
        set fontSize(fontSize) {
            const style = this._style;
            if (style.fontSize !== fontSize) {
                style.fontSize = fontSize;
                this.onChange();
            }
        }
        get fontStyle() {
            return this._style.fontStyle;
        }
        set fontStyle(fontStyle) {
            const style = this._style;
            if (style.fontStyle !== fontStyle) {
                style.fontStyle = fontStyle;
                this.onChange();
            }
        }
        get fontVariant() {
            return this._style.fontVariant;
        }
        set fontVariant(fontVariant) {
            const style = this._style;
            if (style.fontVariant !== fontVariant) {
                style.fontVariant = fontVariant;
                this.onChange();
            }
        }
        get fontWeight() {
            return this._style.fontWeight;
        }
        set fontWeight(fontWeight) {
            const style = this._style;
            if (style.fontWeight !== fontWeight) {
                style.fontWeight = fontWeight;
                this.onChange();
            }
        }
        get clipping() {
            return this._style.clipping;
        }
        set clipping(clipping) {
            const style = this._style;
            if (style.clipping !== clipping) {
                style.clipping = clipping;
                this.onChange();
            }
        }
        get fitting() {
            return this._style.fitting;
        }
        set fitting(fitting) {
            const style = this._style;
            if (style.fitting !== fitting) {
                style.fitting = fitting;
                this.onChange();
            }
        }
        get wordWrap() {
            return this._style.wordWrap;
        }
        set wordWrap(wordWrap) {
            wordWrap = toEnum(wordWrap, DDynamicTextStyleWordWrap);
            const style = this._style;
            if (style.wordWrap !== wordWrap) {
                style.wordWrap = wordWrap;
                this.onChange();
            }
        }
        get lineHeight() {
            return this._style.lineHeight;
        }
        set lineHeight(lineHeight) {
            const style = this._style;
            if (style.lineHeight !== lineHeight) {
                style.lineHeight = lineHeight;
                this.onChange();
            }
        }
        onChange() {
            DApplications.update(this._parent);
        }
    }

    class DTextPieceImpl extends pixi_js.utils.EventEmitter {
        constructor(parent, theme, options) {
            var _a, _b;
            super();
            this._parent = parent;
            this._theme = theme;
            this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : theme.newTextValue();
            this._computed = this.newComputed();
            this._color = options === null || options === void 0 ? void 0 : options.color;
            this._alpha = options === null || options === void 0 ? void 0 : options.alpha;
            const dstyle = new DDynamicTextStyle(parent, theme, options === null || options === void 0 ? void 0 : options.style);
            this._dstyle = dstyle;
            this._style = new DTextPieceStyleImpl(parent, dstyle);
            this._align = new DTextPieceAlignImpl(parent, theme, options === null || options === void 0 ? void 0 : options.align);
            this._formatter = (_b = options === null || options === void 0 ? void 0 : options.formatter) !== null && _b !== void 0 ? _b : theme.getTextFormatter();
            this._isVisible = true;
            this.onComputedChange();
            if (this.updateObject()) {
                parent.toDirty();
                DApplications.update(parent);
            }
        }
        get value() {
            return this._value;
        }
        set value(value) {
            if (this._value !== value) {
                this._value = value;
                this.onValueChange();
            }
        }
        getValue() {
            return this._value;
        }
        setValue(value, forcibly) {
            if (forcibly || this._value !== value) {
                this._value = value;
                this.onValueChange(forcibly);
            }
        }
        onValueChange(forcibly) {
            const newComputed = this.newComputed();
            if (forcibly || this._computed !== newComputed) {
                this._computed = newComputed;
                this.onComputedChange();
                if (this.updateObject()) {
                    const parent = this._parent;
                    parent.toDirty();
                    DApplications.update(parent);
                }
            }
        }
        compute(forcibly) {
            this.onValueChange(forcibly);
        }
        get computed() {
            return this._computed;
        }
        get formatter() {
            return this._formatter;
        }
        set formatter(formatter) {
            if (this._formatter !== formatter) {
                this._formatter = formatter;
                this.onValueChange(true);
            }
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                this.onColorChange();
            }
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                this.onColorChange();
            }
        }
        onColorChange() {
            const object = this._object;
            if (object != null) {
                const parent = this._parent;
                const state = parent.state;
                const color = this.newColor(state);
                const alpha = this.newAlpha(state);
                const style = object.style;
                if (style.fill !== color || object.alpha !== alpha) {
                    style.fill = color;
                    object.alpha = alpha;
                    DApplications.update(parent);
                }
            }
        }
        get align() {
            return this._align;
        }
        get style() {
            return this._style;
        }
        get object() {
            return this._object;
        }
        update(layouter) {
            // Compute a value
            const newComputed = this.newComputed();
            if (this._computed !== newComputed) {
                this._computed = newComputed;
                this.onComputedChange();
                this.updateObject();
            }
            const object = this._object;
            if (object != null) {
                // Update the color
                const state = this._parent.state;
                object.style.fill = this.newColor(state);
                object.alpha = this.newAlpha(state);
                // Layout
                layouter.set(object);
            }
            else {
                // Layout
                layouter.set(null);
            }
        }
        updateObject() {
            const computed = this._computed;
            if (computed !== undefined) {
                const formatted = this._formatter(computed, this._parent);
                const object = this._object;
                if (object == null) {
                    if (0 < formatted.length) {
                        const newObject = this.newObject();
                        newObject.visible = this._isVisible;
                        this._object = newObject;
                        const parent = this._parent;
                        parent.addChild(newObject);
                        const overflowMask = parent.getOverflowMask();
                        if (overflowMask) {
                            newObject.mask = overflowMask;
                        }
                        newObject.text = formatted;
                        return true;
                    }
                }
                else if (object.text !== formatted) {
                    object.text = formatted;
                    return true;
                }
            }
            else {
                const object = this._object;
                if (object != null && object.text !== "") {
                    object.text = "";
                    return true;
                }
            }
            return false;
        }
        newComputed() {
            const value = this._value;
            if (value !== undefined) {
                if (isFunction(value)) {
                    const result = value(this._parent.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return value;
                }
            }
            return this._theme.getTextValue(this._parent.state);
        }
        newColor(state) {
            const color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    const result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getColor(state);
        }
        newAlpha(state) {
            const alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    const result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getAlpha(state);
        }
        newObject() {
            return new DDynamicText(this._dstyle);
        }
        get visible() {
            const object = this._object;
            if (object != null) {
                return object.visible;
            }
            return this._isVisible;
        }
        set visible(visible) {
            const object = this._object;
            if (object != null) {
                object.visible = visible;
            }
            this._isVisible = visible;
        }
        show() {
            this.visible = true;
            return this;
        }
        hide() {
            this.visible = false;
            return this;
        }
        isShown() {
            return this.visible;
        }
        onComputedChange() {
            this.emit("change", this);
        }
        destroy() {
            const object = this._object;
            if (object) {
                this._object = undefined;
                object.destroy();
            }
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class for UI classes with a text support.
     * See {@link DTextBaseEvents} for event defaults.
     */
    class DTextBase extends DBase {
        init(options) {
            super.init(options);
            this.getText();
        }
        getOverflowMask() {
            let result = this._overflowMask;
            if (result === undefined) {
                result = this.newOverflowMask();
                this._overflowMask = result;
            }
            return null;
        }
        newOverflowMask() {
            var _a, _b;
            if ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.mask) !== null && _b !== void 0 ? _b : this.theme.isOverflowMaskEnabled()) {
                const result = new DBaseOverflowMaskSimple(this);
                this._reflowable.add(result);
                this.toDirty();
                return result;
            }
            else {
                return null;
            }
        }
        get text() {
            var _a;
            return ((_a = this._text) !== null && _a !== void 0 ? _a : (this._text = this.newText()));
        }
        getText() {
            var _a;
            return ((_a = this._text) !== null && _a !== void 0 ? _a : (this._text = this.newText()));
        }
        newText() {
            var _a;
            return new DTextPieceImpl(this, this.theme, (_a = this._options) === null || _a === void 0 ? void 0 : _a.text);
        }
        set text(text) {
            this.text.value = text;
        }
        onReflow() {
            super.onReflow();
            this.onReflowTextAndImage();
        }
        getLayouter() {
            var _a;
            return ((_a = DTextBase.LAYOUTER) !== null && _a !== void 0 ? _a : (DTextBase.LAYOUTER = new DImagePieceLayouter()));
        }
        onReflowTextAndImage() {
            const layouter = this.getLayouter();
            const text = this.getText();
            text.update(layouter);
            const auto = this._auto;
            layouter.execute(this._padding, text.align, auto.width.isOn ? null : this.width, auto.height.isOn ? null : this.height);
            layouter.clear();
        }
        isRefitable(target) {
            if (super.isRefitable(target)) {
                return true;
            }
            if (target != null) {
                const text = this._text;
                if (text != null && target === text.object) {
                    return true;
                }
            }
            return false;
        }
        applyTitle() {
            const object = this.text.object;
            if (this._title.length <= 0 && object != null && object.clipped) {
                const layer = DApplications.getLayer(this);
                if (layer) {
                    layer.view.title = object.text;
                }
            }
            else {
                super.applyTitle();
            }
        }
        getType() {
            return "DTextBase";
        }
        destroy() {
            // Text
            const text = this._text;
            if (text) {
                text.destroy();
            }
            // Overflow mask
            const overflowMask = this._overflowMask;
            if (overflowMask) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            super.destroy();
        }
    }

    class DImageBaseThemeWrapperOther {
        constructor(theme) {
            this._theme = theme;
        }
        getImageAlignHorizontal() {
            return this._theme.getImageAlignHorizontal();
        }
        getImageAlignVertical() {
            return this._theme.getImageAlignVertical();
        }
        getImageAlignWith() {
            return this._theme.getImageAlignWith();
        }
        getImageMarginHorizontal() {
            return this._theme.getImageMarginHorizontal();
        }
        getImageMarginVertial() {
            return this._theme.getImageMarginVertial();
        }
        getImageTintColor(state) {
            return this._theme.getImageTintColor(state);
        }
        getImageTintAlpha(state) {
            return this._theme.getImageTintAlpha(state);
        }
        getImageRotation(state) {
            return this._theme.getImageRotation(state);
        }
        getImageSource(state) {
            return null;
        }
    }

    class DImageBaseThemeWrapperSecondary {
        constructor(theme) {
            this._theme = theme;
        }
        getImageAlignHorizontal() {
            return this._theme.getSecondaryImageAlignHorizontal();
        }
        getImageAlignVertical() {
            return this._theme.getSecondaryImageAlignVertical();
        }
        getImageAlignWith() {
            return this._theme.getSecondaryImageAlignWith();
        }
        getImageMarginHorizontal() {
            return this._theme.getSecondaryImageMarginHorizontal();
        }
        getImageMarginVertial() {
            return this._theme.getSecondaryImageMarginVertial();
        }
        getImageTintColor(state) {
            return this._theme.getSecondaryImageTintColor(state);
        }
        getImageTintAlpha(state) {
            return this._theme.getSecondaryImageTintAlpha(state);
        }
        getImageRotation(state) {
            return this._theme.getSecondaryImageRotation(state);
        }
        getImageSource(state) {
            var _a, _b, _c;
            return (_c = (_b = (_a = this._theme).getSecondaryImageSource) === null || _b === void 0 ? void 0 : _b.call(_a, state)) !== null && _c !== void 0 ? _c : null;
        }
    }

    class DImageBaseThemeWrapperTertiary {
        constructor(theme) {
            this._theme = theme;
        }
        getImageAlignHorizontal() {
            return this._theme.getTertiaryImageAlignHorizontal();
        }
        getImageAlignVertical() {
            return this._theme.getTertiaryImageAlignVertical();
        }
        getImageAlignWith() {
            return this._theme.getTertiaryImageAlignWith();
        }
        getImageMarginHorizontal() {
            return this._theme.getTertiaryImageMarginHorizontal();
        }
        getImageMarginVertial() {
            return this._theme.getTertiaryImageMarginVertial();
        }
        getImageTintColor(state) {
            return this._theme.getTertiaryImageTintColor(state);
        }
        getImageTintAlpha(state) {
            return this._theme.getTertiaryImageTintAlpha(state);
        }
        getImageRotation(state) {
            return this._theme.getTertiaryImageRotation(state);
        }
        getImageSource(state) {
            var _a, _b, _c;
            return (_c = (_b = (_a = this._theme).getTertiaryImageSource) === null || _b === void 0 ? void 0 : _b.call(_a, state)) !== null && _c !== void 0 ? _c : null;
        }
    }

    class DImagePieceTintImpl {
        constructor(parent, theme, options) {
            this._parent = parent;
            if (options != null) {
                this._color = options.color;
                this._alpha = options.alpha;
            }
            this._theme = theme;
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                this.onChange();
            }
        }
        getColor(state) {
            const color = this._color;
            if (color !== undefined) {
                if (isFunction(color)) {
                    const result = color(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return color;
                }
            }
            return this._theme.getImageTintColor(state);
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                this.onChange();
            }
        }
        getAlpha(state) {
            const alpha = this._alpha;
            if (alpha !== undefined) {
                if (isFunction(alpha)) {
                    const result = alpha(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return alpha;
                }
            }
            return this._theme.getImageTintAlpha(state);
        }
        set(color, alpha) {
            let isChanged = false;
            if (color != null && this._color !== color) {
                this._color = color;
                isChanged = true;
            }
            if (alpha != null && this._alpha !== alpha) {
                this._alpha = alpha;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        }
        onChange() {
            this._parent.updateTint();
            DApplications.update(this._parent);
        }
    }

    class DImagePieceMarginImpl {
        constructor(parent, theme, options) {
            var _a, _b;
            this._parent = parent;
            this._vertical = (_a = options === null || options === void 0 ? void 0 : options.vertical) !== null && _a !== void 0 ? _a : theme.getImageMarginVertial();
            this._horizontal = (_b = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _b !== void 0 ? _b : theme.getImageMarginHorizontal();
        }
        get vertical() {
            return this._vertical;
        }
        set vertical(vertical) {
            if (this._vertical !== vertical) {
                this._vertical = vertical;
                this.onChange();
            }
        }
        get horizontal() {
            return this._horizontal;
        }
        set horizontal(horizontal) {
            if (this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                this.onChange();
            }
        }
        set(vertical, horizontal) {
            let isChanged = false;
            if (vertical != null && this._vertical !== vertical) {
                this._vertical = vertical;
                isChanged = true;
            }
            if (horizontal != null && this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        }
        onChange() {
            this._parent.onUpdate();
        }
    }

    class DImagePieceAlignImpl {
        constructor(parent, theme, options) {
            var _a, _b, _c;
            this._parent = parent;
            this._with = toEnum((_a = options === null || options === void 0 ? void 0 : options.with) !== null && _a !== void 0 ? _a : theme.getImageAlignWith(), DAlignWith);
            this._vertical = toEnum((_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getImageAlignVertical(), DAlignVertical);
            this._horizontal = toEnum((_c = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _c !== void 0 ? _c : theme.getImageAlignHorizontal(), DAlignHorizontal);
        }
        get with() {
            return this._with;
        }
        set with(w) {
            w = toEnum(w, DAlignWith);
            if (this._with !== w) {
                this._with = w;
                this.onChange();
            }
        }
        get vertical() {
            return this._vertical;
        }
        set vertical(vertical) {
            vertical = toEnum(vertical, DAlignVertical);
            if (this._vertical !== vertical) {
                this._vertical = vertical;
                this.onChange();
            }
        }
        get horizontal() {
            return this._horizontal;
        }
        set horizontal(horizontal) {
            horizontal = toEnum(horizontal, DAlignHorizontal);
            if (this._horizontal !== horizontal) {
                this._horizontal = horizontal;
                this.onChange();
            }
        }
        set(w, vertical, horizontal) {
            let isChanged = false;
            if (w != null) {
                w = toEnum(w, DAlignWith);
                if (this._with !== w) {
                    this._with = w;
                    isChanged = true;
                }
            }
            if (vertical != null) {
                vertical = toEnum(vertical, DAlignVertical);
                if (this._vertical !== vertical) {
                    this._vertical = vertical;
                    isChanged = true;
                }
            }
            if (horizontal != null) {
                horizontal = toEnum(horizontal, DAlignHorizontal);
                if (this._horizontal !== horizontal) {
                    this._horizontal = horizontal;
                    isChanged = true;
                }
            }
            if (isChanged) {
                this.onChange();
            }
            return this;
        }
        onChange() {
            this._parent.onUpdate();
        }
    }

    class DImagePieceImpl {
        constructor(parent, theme, options) {
            this._parent = parent;
            this._theme = theme;
            this._object = null;
            this._align = new DImagePieceAlignImpl(this, theme, options === null || options === void 0 ? void 0 : options.align);
            this._margin = new DImagePieceMarginImpl(this, theme, options === null || options === void 0 ? void 0 : options.margin);
            this._tint = new DImagePieceTintImpl(this, theme, options === null || options === void 0 ? void 0 : options.tint);
            this._rotation = options === null || options === void 0 ? void 0 : options.rotation;
            this._source = options === null || options === void 0 ? void 0 : options.source;
            this._computed = null;
            this._onUpdateBound = () => {
                this.onUpdate();
            };
        }
        get object() {
            return this._object;
        }
        get align() {
            return this._align;
        }
        get margin() {
            return this._margin;
        }
        get tint() {
            return this._tint;
        }
        get source() {
            return this._source;
        }
        set source(source) {
            if (this._source !== source) {
                this._source = source;
                if (this.updateSource()) {
                    this.onUpdate();
                }
            }
        }
        get rotation() {
            return this._rotation;
        }
        set rotation(rotation) {
            if (this._rotation !== rotation) {
                this._rotation = rotation;
                if (this.updateRotation()) {
                    DApplications.update(this._parent);
                }
            }
        }
        computeSource() {
            const source = this._source;
            if (source !== undefined) {
                if (isFunction(source)) {
                    const result = source(this._parent.state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return source;
                }
            }
            return this._theme.getImageSource(this._parent.state);
        }
        onStateChange(newState, oldState) {
            this.updateTint();
            this.updateRotation();
        }
        isTintAware(target) {
            return target != null && "tint" in target;
        }
        /**
         * Updates the tint.
         *
         * @returns True if the tint is changed.
         */
        updateTint() {
            const object = this._object;
            if (object) {
                if (this.isTintAware(object)) {
                    const state = this._parent.state;
                    const color = this._tint.getColor(state);
                    if (color != null) {
                        let result = false;
                        if (object.tint !== color) {
                            object.tint = color;
                            result = true;
                        }
                        const alpha = this._tint.getAlpha(state);
                        if (object.alpha !== alpha) {
                            object.alpha = alpha;
                            result = true;
                        }
                        if (!object.visible) {
                            object.visible = true;
                            result = true;
                        }
                        return result;
                    }
                    else if (object.visible) {
                        object.visible = false;
                        return true;
                    }
                }
            }
            return false;
        }
        toRotation(theme, state) {
            const rotation = this._rotation;
            if (rotation != null) {
                if (isFunction(rotation)) {
                    const result = rotation(state);
                    if (result !== undefined) {
                        return result;
                    }
                }
                else {
                    return rotation;
                }
            }
            return theme.getImageRotation(state);
        }
        updateRotation() {
            const object = this._object;
            if (object) {
                const theme = this._theme;
                const state = this._parent.state;
                const rotation = this.toRotation(theme, state);
                if (rotation != null) {
                    const transform = object.transform;
                    if (transform.rotation !== rotation) {
                        transform.rotation = rotation;
                        return true;
                    }
                }
            }
            return false;
        }
        /**
         * Updates the computed source.
         *
         * @returns True if the computed source is changed
         */
        updateSource() {
            const newComputed = this.computeSource();
            const oldComputed = this._computed;
            if (newComputed !== oldComputed) {
                this._computed = newComputed;
                const parent = this._parent;
                const oldObject = this._object;
                const onUpdateBound = this._onUpdateBound;
                if (newComputed instanceof pixi_js.Texture) {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", onUpdateBound);
                        if (oldObject instanceof pixi_js.Sprite) {
                            oldObject.texture = newComputed;
                            newComputed.on("update", onUpdateBound);
                        }
                    }
                    else {
                        if (oldObject != null) {
                            parent.removeChild(oldObject);
                        }
                        const newObject = new pixi_js.Sprite(newComputed);
                        newObject.anchor.set(0.5, 0.5);
                        const overflowMask = parent.getOverflowMask();
                        if (overflowMask) {
                            newObject.mask = overflowMask;
                        }
                        newComputed.on("update", onUpdateBound);
                        parent.addChild(newObject);
                        this._object = newObject;
                    }
                }
                else {
                    if (oldComputed instanceof pixi_js.Texture) {
                        oldComputed.off("update", onUpdateBound);
                        if (oldObject != null) {
                            parent.removeChild(oldObject);
                            oldObject.destroy();
                        }
                    }
                    else if (oldObject != null) {
                        parent.removeChild(oldObject);
                    }
                    if (newComputed != null) {
                        const overflowMask = parent.getOverflowMask();
                        if (overflowMask) {
                            newComputed.mask = overflowMask;
                        }
                        parent.addChild(newComputed);
                    }
                    this._object = newComputed;
                }
                return true;
            }
            return false;
        }
        isRefitable(target) {
            return target != null && target === this._object;
        }
        destroy() {
            this.source = null;
        }
        onUpdate() {
            this._parent.toDirty();
            DApplications.update(this._parent);
        }
    }

    class DImagePieceContainerImpl {
        constructor(parent, theme, options) {
            this._parent = parent;
            this._theme = theme;
            const pieces = [];
            this._pieces = pieces;
            if (options != null) {
                const images = options.images;
                if (images != null) {
                    pieces.push(this.newImage(theme, 0 < images.length ? images[0] : undefined));
                    if (theme.getSecondaryImageSource != null || 1 < images.length) {
                        pieces.push(this.newImage(new DImageBaseThemeWrapperSecondary(theme), images[1]));
                    }
                    if (theme.getTertiaryImageSource != null || 2 < images.length) {
                        pieces.push(this.newImage(new DImageBaseThemeWrapperTertiary(theme), images[2]));
                    }
                    if (3 < images.length) {
                        const other = new DImageBaseThemeWrapperOther(theme);
                        for (let i = 3, imax = images.length; i < imax; ++i) {
                            pieces.push(this.newImage(other, images[i]));
                        }
                    }
                }
                else {
                    pieces.push(this.newImage(theme, options.image));
                    if (theme.getSecondaryImageSource != null) {
                        pieces.push(this.newImage(new DImageBaseThemeWrapperSecondary(theme)));
                    }
                    if (theme.getTertiaryImageSource != null) {
                        pieces.push(this.newImage(new DImageBaseThemeWrapperTertiary(theme)));
                    }
                }
            }
            else {
                pieces.push(this.newImage(theme));
                if (theme.getSecondaryImageSource != null) {
                    pieces.push(this.newImage(new DImageBaseThemeWrapperSecondary(theme)));
                }
                if (theme.getTertiaryImageSource != null) {
                    pieces.push(this.newImage(new DImageBaseThemeWrapperTertiary(theme)));
                }
            }
        }
        newImage(theme, options) {
            return new DImagePieceImpl(this._parent, theme, options);
        }
        onStateChange(newState, oldState) {
            const pieces = this._pieces;
            for (let i = 0, imax = pieces.length; i < imax; ++i) {
                pieces[i].onStateChange(newState, oldState);
            }
        }
        isRefitable(target) {
            const pieces = this._pieces;
            for (let i = 0, imax = pieces.length; i < imax; ++i) {
                if (pieces[i].isRefitable(target)) {
                    return true;
                }
            }
            return false;
        }
        update(layouter) {
            const pieces = this._pieces;
            for (let i = 0, imax = pieces.length; i < imax; ++i) {
                const piece = pieces[i];
                piece.updateSource();
                piece.updateTint();
                piece.updateRotation();
                layouter.add(piece);
            }
        }
        get object() {
            return this._pieces[0].object;
        }
        get align() {
            return this._pieces[0].align;
        }
        get margin() {
            return this._pieces[0].margin;
        }
        get tint() {
            return this._pieces[0].tint;
        }
        get source() {
            return this._pieces[0].source;
        }
        set source(source) {
            this._pieces[0].source = source;
        }
        get rotation() {
            return this._pieces[0].rotation;
        }
        set rotation(rotation) {
            this._pieces[0].rotation = rotation;
        }
        add(options) {
            const result = this.newImage(this._theme, options);
            this._pieces.push(result);
            return result;
        }
        get(index) {
            const pieces = this._pieces;
            if (0 <= index && index < pieces.length) {
                return pieces[index];
            }
            return null;
        }
        remove(index) {
            const pieces = this._pieces;
            if (0 <= index && index < pieces.length) {
                pieces[index].destroy();
                return true;
            }
            return false;
        }
        size() {
            return this._pieces.length;
        }
        destroy() {
            const pieces = this._pieces;
            for (let i = 0, imax = pieces.length; i < imax; ++i) {
                pieces[i].destroy();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class for UI classes with an image support.
     * See {@link DImageBaseEvents} for event details.
     */
    class DImageBase extends DTextBase {
        init(options) {
            this.getImage();
            super.init(options);
        }
        get image() {
            var _a;
            return ((_a = this._image) !== null && _a !== void 0 ? _a : (this._image = this.newImage()));
        }
        getImage() {
            var _a;
            return ((_a = this._image) !== null && _a !== void 0 ? _a : (this._image = this.newImage()));
        }
        newImage() {
            return new DImagePieceContainerImpl(this, this.theme, this.options);
        }
        set image(imageSource) {
            const image = this.image.get(0);
            if (image != null) {
                image.source = imageSource;
            }
        }
        onStateChange(newState, oldState) {
            super.onStateChange(newState, oldState);
            this.getImage().onStateChange(newState, oldState);
        }
        onReflowTextAndImage() {
            const layouter = this.getLayouter();
            this.getImage().update(layouter);
            const text = this.getText();
            text.update(layouter);
            const auto = this._auto;
            layouter.execute(this._padding, text.align, auto.width.isOn ? null : this.width, auto.height.isOn ? null : this.height);
            layouter.clear();
        }
        isRefitable(target) {
            if (super.isRefitable(target)) {
                return true;
            }
            if (this.getImage().isRefitable(target)) {
                return true;
            }
            return false;
        }
        getType() {
            return "DImageBase";
        }
        destroy() {
            const image = this._image;
            if (image != null) {
                image.destroy();
            }
            super.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A base class for button classes.
     * See {@link DButtonBaseEvents} for event details.
     */
    class DButtonBase extends DImageBase {
        init(options) {
            var _a, _b;
            super.init(options);
            const theme = this.theme;
            this._isToggle = (_a = options === null || options === void 0 ? void 0 : options.toggle) !== null && _a !== void 0 ? _a : theme.isToggle();
            this._when = toEnum((_b = options === null || options === void 0 ? void 0 : options.when) !== null && _b !== void 0 ? _b : theme.getWhen(), DButtonBaseWhen);
            // Event handlers
            this.on(UtilPointerEvent.tap, (e) => {
                this.onClick(e);
            });
            this.initOnPress();
            // Group
            const group = options === null || options === void 0 ? void 0 : options.group;
            if (group) {
                group.add(this);
            }
        }
        onShortcut(e) {
            if (this.state.isActionable) {
                this.activate(e);
            }
            super.onShortcut(e);
        }
        get isToggle() {
            return !!this._isToggle;
        }
        get isGrouped() {
            return !!this._isGrouped;
        }
        set isGrouped(isGrouped) {
            this._isGrouped = isGrouped;
        }
        initOnPress() {
            let interactionManager = null;
            const onUp = () => {
                this.state.isPressed = false;
                if (interactionManager != null) {
                    interactionManager.off(UtilPointerEvent.up, onUp);
                    interactionManager.off(UtilPointerEvent.upoutside, onUp);
                    interactionManager.off(UtilPointerEvent.cancel, onUp);
                    interactionManager = null;
                }
            };
            this.on(UtilPointerEvent.down, () => {
                if (this.state.isActionable) {
                    this.state.isPressed = true;
                    const layer = DApplications.getLayer(this);
                    if (layer) {
                        interactionManager = layer.renderer.plugins.interaction;
                        if (interactionManager != null) {
                            interactionManager.on(UtilPointerEvent.up, onUp);
                            interactionManager.on(UtilPointerEvent.upoutside, onUp);
                            interactionManager.on(UtilPointerEvent.cancel, onUp);
                        }
                    }
                }
            });
        }
        getType() {
            return "DButton";
        }
        onClick(e) {
            if (this._when === DButtonBaseWhen.CLICKED && this.state.isActionable) {
                this.activate(e);
            }
        }
        onDblClick(e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED && this.state.isActionable) {
                this.activate(e);
            }
            return super.onDblClick(e, interactionManager);
        }
        activate(e) {
            if (this._isToggle) {
                if (this._isGrouped) {
                    if (!this.state.isActive) {
                        this.onToggleStart(e);
                        this.onToggleEnd(e);
                    }
                }
                else {
                    this.onToggleStart(e);
                    this.onToggleEnd(e);
                }
            }
            else {
                this.onActivate(e);
            }
        }
        onActivate(e) {
            this.emit("active", this);
        }
        onInactivate(e) {
            this.emit("inactive", this);
        }
        toggle() {
            if (this.state.isActionable) {
                if (this._isToggle) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
            }
        }
        onToggleStart(e) {
            this.state.isActive = !this.state.isActive;
        }
        onToggleEnd(e) {
            if (this.state.isActive) {
                this.onActivate(e);
            }
            else {
                this.onInactivate(e);
            }
        }
        onActivateKeyDown(e) {
            if (this.state.isActionable) {
                if (this._isToggle) {
                    this.onToggleStart(e);
                }
                else {
                    this.state.isPressed = true;
                }
            }
        }
        onActivateKeyUp(e) {
            if (this.state.isActionable) {
                if (this._isToggle) {
                    this.onToggleEnd(e);
                }
                else {
                    if (this.state.isPressed) {
                        this.onActivate(e);
                    }
                    this.state.isPressed = false;
                }
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return super.onKeyDown(e);
        }
        onKeyUp(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return super.onKeyUp(e);
        }
        onStateChange(newState, oldState) {
            super.onStateChange(newState, oldState);
            if (newState.isPressed) {
                if (!oldState.isPressed) {
                    this.onPress();
                }
            }
            else if (oldState.isPressed) {
                this.onUnpress();
            }
        }
        onPress() {
            this.emit("press", this);
        }
        onUnpress() {
            this.emit("unpress", this);
        }
        destroy() {
            var _a, _b;
            (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.group) === null || _b === void 0 ? void 0 : _b.remove(this);
            super.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A button class.
     */
    class DButton extends DButtonBase {
        getType() {
            return "DButton";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonPrimary extends DButton {
        getType() {
            return "DButtonPrimary";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DLayoutHorizontal extends DLayout {
        getType() {
            return "DLayoutHorizontal";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogLayeredFooter extends DLayoutHorizontal {
        constructor(parent, options) {
            super(options);
            this._parent = parent;
        }
        init(options) {
            super.init(options);
            const children = this.newChildren();
            if (0 < children.length) {
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    if (child != null) {
                        this.addChild(child);
                    }
                }
            }
        }
        newChildren() {
            return [this.buttonSpaceLeft, this.buttonCancel, this.buttonOk, this.buttonSpaceRight];
        }
        get buttonSpaceLeft() {
            let result = this._buttonSpaceLeft;
            if (result === undefined) {
                result = this.newButtonSpaceLeft();
                this._buttonSpaceLeft = result;
            }
            return result;
        }
        newButtonSpaceLeft() {
            var _a, _b, _c, _d;
            if ((_d = (_c = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.space) === null || _c === void 0 ? void 0 : _c.left) !== null && _d !== void 0 ? _d : this.theme.isButtonSpaceLeftEnabled()) {
                return new DLayoutSpace({
                    weight: 1
                });
            }
            return null;
        }
        get buttonSpaceRight() {
            let result = this._buttonSpaceRight;
            if (result === undefined) {
                result = this.newButtonSpaceRight();
                this._buttonSpaceRight = result;
            }
            return result;
        }
        newButtonSpaceRight() {
            var _a, _b, _c, _d;
            if ((_d = (_c = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.space) === null || _c === void 0 ? void 0 : _c.right) !== null && _d !== void 0 ? _d : this.theme.isButtonSpaceRightEnabled()) {
                return new DLayoutSpace({
                    weight: 1
                });
            }
            return null;
        }
        get buttonCancel() {
            let result = this._buttonCancel;
            if (result === undefined) {
                result = this.newButtonCancel();
                this._buttonCancel = result;
            }
            return result;
        }
        newButtonCancel() {
            var _a, _b;
            let cancel = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.cancel;
            if (cancel === undefined) {
                cancel = this.theme.getButtonCancel();
            }
            if (cancel != null) {
                return new DButtonPrimary({
                    text: {
                        value: cancel
                    },
                    on: {
                        active: () => {
                            this._parent.cancel();
                        }
                    }
                });
            }
            return null;
        }
        get buttonOk() {
            let result = this._buttonOk;
            if (result === undefined) {
                result = this.newButtonOk();
                this._buttonOk = result;
            }
            return result;
        }
        newButtonOk() {
            var _a, _b;
            let ok = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.ok;
            if (ok === undefined) {
                ok = this.theme.getButtonOk();
            }
            if (ok != null) {
                if (this.buttonCancel != null) {
                    return new DButton({
                        text: {
                            value: ok
                        },
                        on: {
                            active: () => {
                                this._parent.ok();
                            }
                        }
                    });
                }
                else {
                    return new DButtonPrimary({
                        text: {
                            value: ok
                        },
                        on: {
                            active: () => {
                                this._parent.ok();
                            }
                        }
                    });
                }
            }
            return null;
        }
        getType() {
            return "DDialogLayeredFooter";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonAmbient extends DButton {
        getType() {
            return "DButtonAmbient";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogLayeredHeaderButtonClose extends DButtonAmbient {
        getType() {
            return "DDialogLayeredHeaderButtonClose";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogLayeredHeaderSeparator extends DImageBase {
        getType() {
            return "DDialogLayeredHeaderSeparator";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogLayeredHeader extends DImageBase {
        constructor(parent, options) {
            super(options);
            this._parent = parent;
            const separator = this.separator;
            if (separator) {
                this.addChild(separator);
            }
            const buttonClose = this.buttonClose;
            if (buttonClose) {
                this.addChild(buttonClose);
                buttonClose.on("active", () => {
                    this._parent.cancel();
                });
            }
        }
        get buttonClose() {
            let result = this._buttonClose;
            if (result === undefined) {
                result = this.newButtonClose();
                this._buttonClose = result;
            }
            return result;
        }
        newButtonClose() {
            var _a, _b;
            if (((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.close) !== false) {
                return new DDialogLayeredHeaderButtonClose();
            }
            return null;
        }
        get separator() {
            let result = this._separator;
            if (result === undefined) {
                result = this.newSeparator();
                this._separator = result;
            }
            return result;
        }
        newSeparator() {
            var _a;
            if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.separator) !== false) {
                return new DDialogLayeredHeaderSeparator();
            }
            return null;
        }
        getType() {
            return "DDialogLayeredHeader";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog with a header, a content and a footer.
     */
    class DDialogLayered extends DDialog {
        init(options) {
            super.init(options);
            this.addChild(this.layout);
        }
        get layout() {
            let result = this._layout;
            if (result == null) {
                result = this.newLayout();
                this._layout = result;
            }
            return result;
        }
        newLayout() {
            return new DLayoutVertical(this.toLayoutOptions(this.theme, this._options));
        }
        toLayoutOptions(theme, options) {
            var _a, _b;
            const result = (_b = (_a = options === null || options === void 0 ? void 0 : options.layout) !== null && _a !== void 0 ? _a : theme.getLayout()) !== null && _b !== void 0 ? _b : this.newLayoutOptions(theme, options);
            if (result.children === undefined) {
                result.children = this.newLayoutChildren(theme, options);
            }
            return result;
        }
        newLayoutOptions(theme, options) {
            return {
                width: "padding",
                height: "auto",
                margin: 0
            };
        }
        newLayoutChildren(theme, options) {
            return [this.header, this.content, this.footer];
        }
        get header() {
            let result = this._header;
            if (result === undefined) {
                result = this.newHeader();
                this._header = result;
            }
            return result;
        }
        newHeader() {
            const options = this.toHeaderOptions(this.theme, this._options);
            if (options !== null) {
                return new DDialogLayeredHeader(this, options);
            }
            return null;
        }
        toHeaderOptions(theme, options) {
            if (options) {
                const result = options.header;
                if (result !== undefined) {
                    return result;
                }
            }
            return theme.getHeader();
        }
        get content() {
            let result = this._content;
            if (result == null) {
                result = this.newContent();
                this._content = result;
            }
            return result;
        }
        newContent() {
            return new DDialogLayeredContent(this.toContentOptions(this.theme, this._options));
        }
        toContentOptions(theme, options) {
            var _a, _b;
            const result = (_b = (_a = options === null || options === void 0 ? void 0 : options.content) !== null && _a !== void 0 ? _a : theme.getContent()) !== null && _b !== void 0 ? _b : {};
            if (result.children === undefined) {
                result.children = this.newContentChildren(theme, options);
            }
            return result;
        }
        newContentChildren(theme, options) {
            return [];
        }
        get footer() {
            let result = this._footer;
            if (result === undefined) {
                result = this.newFooter();
                this._footer = result;
            }
            return result;
        }
        newFooter() {
            const options = this.toFooterOptions(this.theme, this._options);
            if (options !== null) {
                return new DDialogLayeredFooter(this, options);
            }
            return null;
        }
        toFooterOptions(theme, options) {
            if (options) {
                const result = options.footer;
                if (result !== undefined) {
                    return result;
                }
            }
            return theme.getFooter();
        }
        findFirstFocusable(focusController) {
            return focusController.find(this.content, false, true, true);
        }
        ok() {
            this.onOk(this.getResolvedValue());
        }
        onOk(value) {
            this.doResolve(value);
            this.emit("ok", value, this);
        }
        cancel() {
            this.onCancel(this.getRejectReason());
        }
        onCancel(reason) {
            this.doReject(reason);
            this.emit("cancel", reason, this);
        }
        getRejectReason() {
            return undefined;
        }
        getType() {
            return "DDialogLayered";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogInput extends DDialogLayered {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.inputLayout);
            return result;
        }
        toInputMargin(theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.input) === null || _a === void 0 ? void 0 : _a.margin) !== null && _b !== void 0 ? _b : theme.getInputMargin();
        }
        get inputLayout() {
            let result = this._inputLayout;
            if (result == null) {
                result = this.newInputLayout();
                this._inputLayout = result;
            }
            return result;
        }
        newInputLayout() {
            const margin = this.toInputMargin(this.theme, this._options);
            return new DLayoutHorizontal({
                width: "padding",
                height: "auto",
                margin: 0,
                children: [
                    new DLayoutSpace({ width: margin }),
                    this.input,
                    new DLayoutSpace({ width: margin })
                ]
            });
        }
        get input() {
            let result = this._input;
            if (result == null) {
                const options = this._options;
                result = this.newInput(options === null || options === void 0 ? void 0 : options.input);
                this._input = result;
            }
            return result;
        }
        get value() {
            return this.input.value;
        }
        set value(value) {
            this.input.value = value;
        }
        getResolvedValue() {
            return this.input.value;
        }
        getType() {
            return "DDialogInput";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonGroup extends pixi_js.utils.EventEmitter {
        constructor(options) {
            super();
            this._buttons = [];
            this._active = null;
            this._onActiveBound = (button) => {
                this.active = button;
            };
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
            // Done
            this.emit("init", this);
        }
        add(button) {
            const buttons = this._buttons;
            const index = buttons.indexOf(button);
            if (index < 0) {
                this._buttons.push(button);
                button.isGrouped = true;
                const isEnabled = this._isEnabled;
                if (isEnabled != null) {
                    button.state.isEnabled = isEnabled;
                }
                button.on("active", this._onActiveBound);
                if (button.state.isActive) {
                    this.active = button;
                }
            }
        }
        get active() {
            return this._active;
        }
        set active(newActive) {
            if ((newActive == null || newActive.isToggle) && this._active !== newActive) {
                const oldActive = this._active;
                this._active = newActive;
                const buttons = this._buttons;
                for (let i = 0, imax = buttons.length; i < imax; ++i) {
                    const button = buttons[i];
                    if (button !== newActive && button.isToggle && button.state.isActive) {
                        button.toggle();
                    }
                }
                this.emit("active", newActive, oldActive, this);
            }
        }
        remove(button) {
            const buttons = this._buttons;
            const index = buttons.indexOf(button);
            if (0 <= index) {
                buttons.splice(index, 1);
                button.isGrouped = false;
                button.off("active", this._onActiveBound);
                if (this._active === button) {
                    this.active = null;
                }
            }
        }
        contains(button) {
            const buttons = this._buttons;
            const index = buttons.indexOf(button);
            return 0 <= index;
        }
        clear() {
            const buttons = this._buttons;
            for (let i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].isGrouped = false;
            }
            buttons.length = 0;
            this.active = null;
        }
        size() {
            return this._buttons.length;
        }
        each(iteratee) {
            const buttons = this._buttons;
            for (let i = 0, imax = buttons.length; i < imax; ++i) {
                const button = buttons[i];
                if (iteratee(button) === false) {
                    break;
                }
            }
        }
        disable() {
            const buttons = this._buttons;
            for (let i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].state.isDisabled = true;
            }
            this._isEnabled = false;
        }
        enable() {
            const buttons = this._buttons;
            for (let i = 0, imax = buttons.length; i < imax; ++i) {
                buttons[i].state.isDisabled = false;
            }
            this._isEnabled = true;
        }
        destroy() {
            this.clear();
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputBooleanButtonOff extends DButton {
        getType() {
            return "DInputBooleanButtonOff";
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputBooleanButtonOn extends DButton {
        getType() {
            return "DInputBooleanButtonOn";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputBoolean extends DLayoutHorizontal {
        constructor(options) {
            super(options);
            this._lockCount = 0;
            this.addChild(this.getButtonOff());
            this.addChild(this.getButtonOn());
            const value = options === null || options === void 0 ? void 0 : options.value;
            if (value != null) {
                this.value = value;
            }
            this.getButtonGroup().on("active", () => {
                if (this._lockCount <= 0) {
                    const newValue = this.value;
                    this.emit("change", newValue, !newValue, this);
                }
            });
        }
        getButtonGroup() {
            let result = this._buttonGroup;
            if (result == null) {
                result = this.newButtonGroup();
                this._buttonGroup = result;
            }
            return result;
        }
        newButtonGroup() {
            return new DButtonGroup();
        }
        getButtonOn() {
            let result = this._buttonOn;
            if (result == null) {
                result = this.newButtonOn();
                this._buttonOn = result;
            }
            return result;
        }
        newButtonOn() {
            return new DInputBooleanButtonOn({
                weight: 1,
                group: this.getButtonGroup()
            });
        }
        getButtonOff() {
            let result = this._buttonOff;
            if (result == null) {
                result = this.newButtonOff();
                this._buttonOff = result;
            }
            return result;
        }
        newButtonOff() {
            return new DInputBooleanButtonOff({
                weight: 1,
                group: this.getButtonGroup(),
                state: DBaseState.ACTIVE
            });
        }
        get value() {
            return this.getButtonOn().state.isActive;
        }
        set value(value) {
            if (this.value !== value) {
                this._lockCount += 1;
                try {
                    if (value) {
                        this.getButtonOn().activate();
                    }
                    else {
                        this.getButtonOff().activate();
                    }
                }
                catch (e) {
                    // DO NOTHING
                }
                this._lockCount -= 1;
            }
        }
        getType() {
            return "DInputBoolean";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogInputBoolean extends DDialogInput {
        newInput(options) {
            return new DInputBoolean(this.toInputOptions(options));
        }
        toInputOptions(options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        }
        getType() {
            return "DDialogInputBoolean";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpenDialog extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            this.onInputAction = value.onInputAction;
            this.isOpened = false;
            this.step = EShapeActionExpressions.ofNumberOrNull(value.step);
            this.min = EShapeActionExpressions.ofNumberOrNull(value.min);
            this.max = EShapeActionExpressions.ofNumberOrNull(value.max);
        }
        execute(shape, runtime, time) {
            if (!this.isOpened) {
                if (this.condition(shape, time, EShapeActionEnvironment)) {
                    const target = this.target(shape, time, EShapeActionEnvironment);
                    if (target != null) {
                        const initial = this.initial(shape, time, EShapeActionEnvironment);
                        const step = this.step(shape, time, EShapeActionEnvironment);
                        const min = this.min(shape, time, EShapeActionEnvironment);
                        const max = this.max(shape, time, EShapeActionEnvironment);
                        this.isOpened = true;
                        setTimeout(() => {
                            this.open(shape, target, initial, step, min, max).then((value) => {
                                this.isOpened = false;
                                EShapeActionValueOnInputActions.execute(shape, this.onInputAction, target, value, time);
                            }, () => {
                                this.isOpened = false;
                            });
                        }, 0);
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpenDialogBoolean extends EShapeActionRuntimeOpenDialog {
        constructor(value) {
            super(value);
            this.initial = EShapeActionExpressions.ofBooleanOrFalse(value.initial);
        }
        open(shape, target, initial, step, min, max) {
            let dialog = EShapeActionRuntimeOpenDialogBoolean.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputBoolean({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogBoolean.DIALOG = dialog;
            }
            else {
                const header = dialog.header;
                if (header) {
                    header.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open(shape);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DHtmlElement extends DImageBase {
        getUtil() {
            let result = this._util;
            if (result == null) {
                result = this.newUtil();
                this._util = result;
            }
            return result;
        }
        newUtil() {
            return new UtilHtmlElement(this, this.newOperation(), this.theme, this._options);
        }
        newOperation() {
            return {
                getElementRect: (resolution, work, result) => {
                    return this.getElementRect(resolution, work, result);
                },
                getElementMatrix: () => {
                    return null;
                },
                getClipperRect: (resolution, work, result) => {
                    return this.getClipperRect(resolution, work, result);
                },
                getPadding: () => {
                    return this.padding;
                },
                containsPoint: (point) => {
                    return this.containsPoint(point);
                },
                onStart: () => {
                    // DO NOTHING
                },
                onCancel: () => {
                    // DO NOTHING
                },
                onEnd: () => {
                    // DO NOTHING
                }
            };
        }
        get element() {
            return this.getUtil().element;
        }
        onDownThis(e) {
            const util = this.getUtil();
            util.onDowning(e);
            super.onDownThis(e);
            util.onDown(e);
        }
        onDblClick(e, interactionManager) {
            this.getUtil().onDblClick(e, interactionManager);
            return super.onDblClick(e, interactionManager);
        }
        onFocus() {
            super.onFocus();
            this.getUtil().onFocus();
        }
        onBlur() {
            super.onBlur();
            this.getUtil().onBlur();
        }
        start() {
            this.getUtil().start();
        }
        render(renderer) {
            this.getUtil().onRender(renderer);
            super.render(renderer);
        }
        /**
         * Please note that this method does not update transforms.
         *
         * @param resolution
         */
        getElementRect(resolution, point, result) {
            point.set(0, 0);
            this.toGlobal(point, point, false);
            result.x = point.x;
            result.y = point.y;
            point.set(this.width, this.height);
            this.toGlobal(point, point, true);
            result.width = point.x - result.x;
            result.height = point.y - result.y;
            return result;
        }
        getClipperRect(resolution, point, result) {
            return UtilHtmlElement.getClipperRect(this.parent, this, resolution, point, result);
        }
        cancel() {
            this.getUtil().cancel();
        }
        end() {
            this.getUtil().end();
        }
        select() {
            this.getUtil().select();
            return this;
        }
        onActivateKeyDown(e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        }
        onActivateKeyUp(e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.start();
                }
                this.state.isPressed = false;
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return super.onKeyDown(e);
        }
        onKeyUp(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return super.onKeyUp(e);
        }
        getType() {
            return "DHtmlElement";
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInput extends DHtmlElement {
        newOperation() {
            return {
                getElementRect: (resolution, work, result) => {
                    return this.getElementRect(resolution, work, result);
                },
                getElementMatrix: () => {
                    return null;
                },
                getClipperRect: (resolution, work, result) => {
                    return this.getClipperRect(resolution, work, result);
                },
                getPadding: () => {
                    return this.padding;
                },
                containsPoint: (point) => {
                    return this.containsPoint(point);
                },
                onStart: () => {
                    this.text.hide();
                },
                onCancel: () => {
                    this.text.show();
                },
                onEnd: () => {
                    // DO NOTHING
                },
                getValue: () => {
                    return this.text.computed;
                },
                onValueInput: (newValue) => {
                    this.onValueInput(newValue);
                },
                onValueChange: (newValue, oldValue) => {
                    this.text = newValue;
                    this.onValueChange(newValue, oldValue);
                },
                onEnter: () => {
                    this.onEnter();
                },
                applyTitle: () => {
                    this.applyTitle();
                }
            };
        }
        get value() {
            return this.text.computed;
        }
        set value(value) {
            this.text = value;
        }
        newText() {
            const result = super.newText();
            result.on("change", () => {
                this.validate();
            });
            return result;
        }
        onValueChange(newValue, oldValue) {
            this.emit("change", newValue, oldValue, this);
        }
        onValueInput(newValue) {
            this.emit("input", newValue, this);
        }
        onEnter() {
            this.emit("enter", this);
        }
        validate() {
            return this.getUtil().validate();
        }
        applyTitle() {
            if (!this.getUtil().applyTitle()) {
                super.applyTitle();
            }
        }
        getType() {
            return "DInput";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputInput extends DInput {
        getType() {
            return "DInputInput";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputNumber extends DInputInput {
        newUtil() {
            return new UtilInputNumber(this, this.newOperation(), this.theme, this._options);
        }
        get step() {
            return this.getUtil().step;
        }
        set step(step) {
            this.getUtil().step = step;
        }
        get min() {
            return this.getUtil().min;
        }
        set min(min) {
            this.getUtil().min = min;
        }
        get max() {
            return this.getUtil().max;
        }
        set max(max) {
            this.getUtil().max = max;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputInteger extends DInputNumber {
        getType() {
            return "DInputInteger";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogInputInteger extends DDialogInput {
        newInput(options) {
            const result = new DInputInteger(this.toInputOptions(options));
            result.on("enter", () => {
                this.ok();
            });
            return result;
        }
        toInputOptions(options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        }
        getType() {
            return "DDialogInputInteger";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpenDialogInteger extends EShapeActionRuntimeOpenDialog {
        constructor(value) {
            super(value);
            this.initial = EShapeActionExpressions.ofNumber(value.initial);
        }
        open(shape, target, initial, step, min, max) {
            let dialog = EShapeActionRuntimeOpenDialogInteger.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputInteger({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    },
                    input: {
                        step,
                        min,
                        max,
                        text: {
                            value: initial
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogInteger.DIALOG = dialog;
            }
            else {
                const header = dialog.header;
                if (header) {
                    header.text = target;
                }
                const input = dialog.input;
                input.step = step;
                input.min = min;
                input.max = max;
                dialog.value = initial;
            }
            return dialog.open(shape);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputReal extends DInputNumber {
        getType() {
            return "DInputReal";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogInputReal extends DDialogInput {
        newInput(options) {
            const result = new DInputReal(this.toInputOptions(options));
            result.on("enter", () => {
                this.ok();
            });
            return result;
        }
        toInputOptions(options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        }
        getType() {
            return "DDialogInputReal";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpenDialogReal extends EShapeActionRuntimeOpenDialog {
        constructor(value) {
            super(value);
            this.initial = EShapeActionExpressions.ofNumber(value.initial);
        }
        open(shape, target, initial, step, min, max) {
            let dialog = EShapeActionRuntimeOpenDialogReal.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputReal({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    },
                    input: {
                        step,
                        min,
                        max,
                        text: {
                            value: initial
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogReal.DIALOG = dialog;
            }
            else {
                const header = dialog.header;
                if (header) {
                    header.text = target;
                }
                const input = dialog.input;
                input.step = step;
                input.min = min;
                input.max = max;
                dialog.value = initial;
            }
            return dialog.open(shape);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputText extends DInputInput {
        newUtil() {
            return new UtilInputText(this, this.newOperation(), this.theme, this._options);
        }
        getType() {
            return "DInputText";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogInputText extends DDialogInput {
        newInput(options) {
            const result = new DInputText(this.toInputOptions(options));
            result.on("enter", () => {
                this.ok();
            });
            return result;
        }
        toInputOptions(options) {
            if (options) {
                if (options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            return {
                weight: 1
            };
        }
        getType() {
            return "DDialogInputText";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpenDialogText extends EShapeActionRuntimeOpenDialog {
        constructor(value) {
            super(value);
            this.initial = EShapeActionExpressions.ofString(value.initial);
        }
        open(shape, target, initial, step, min, max) {
            let dialog = EShapeActionRuntimeOpenDialogText.DIALOG;
            if (dialog == null) {
                dialog = new DDialogInputText({
                    header: {
                        text: {
                            value: target
                        },
                        button: {
                            close: false
                        }
                    }
                });
                EShapeActionRuntimeOpenDialogText.DIALOG = dialog;
            }
            else {
                const header = dialog.header;
                if (header) {
                    header.text = target;
                }
            }
            dialog.value = initial;
            return dialog.open(shape);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogFittedContent extends DDialogLayeredContent {
        getType() {
            return "DDialogFittedContent";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dialog with a header, a content and a footer.
     * Unlike {@link DDialogLayered}, the width is determined by the content width.
     */
    class DDialogFitted extends DDialogLayered {
        newLayoutOptions(theme, options) {
            return {
                width: "auto",
                height: "auto",
                margin: 0
            };
        }
        newContent() {
            return new DDialogFittedContent(this.toContentOptions(this.theme, this._options));
        }
        getType() {
            return "DDialogFitted";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetimeButtonBack extends DButtonAmbient {
        getType() {
            return "DPickerDatetimeButtonBack";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetimeButtonDate extends DButtonAmbient {
        getType() {
            return "DPickerDatetimeButtonDate";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetimeButtonNext extends DButtonAmbient {
        getType() {
            return "DPickerDatetimeButtonNext";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DText extends DTextBase {
        getType() {
            return "DText";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetimeLabel extends DText {
        getType() {
            return "DPickerDatetimeLabel";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetimeLabelDate extends DText {
        getType() {
            return "DPickerDatetimeLabelDate";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetimeSpace extends DBase {
        constructor(options) {
            super(options);
            this.renderable = false;
        }
        getType() {
            return "DPickerDatetimeSpace";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DATE = 1;
    const HOURS = 2;
    const MINUTES = 4;
    const SECONDS = 8;
    const DPickerDatetimeMask = {
        NONE: 0,
        DATE,
        HOURS,
        MINUTES,
        SECONDS,
        TIME: HOURS | MINUTES | SECONDS,
        ALL: DATE | HOURS | MINUTES | SECONDS
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetimeMasks {
        static from(themeOrThemeName, options) {
            const mask = options === null || options === void 0 ? void 0 : options.mask;
            if (mask == null) {
                if (isString(themeOrThemeName)) {
                    const theme = DThemes.getInstance().get(themeOrThemeName);
                    if (theme != null) {
                        return theme.getMask();
                    }
                }
                else if (themeOrThemeName != null) {
                    return themeOrThemeName.getMask();
                }
                return DPickerDatetimeMask.NONE;
            }
            else if (isString(mask)) {
                return DPickerDatetimeMask[mask];
            }
            else if (isNumber(mask)) {
                return mask;
            }
            let result = DPickerDatetimeMask.NONE;
            for (let i = 0, imax = mask.length; i < imax; ++i) {
                result |= DPickerDatetimeMask[mask[i]];
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerTimeBound {
        constructor(options, onChange) {
            var _a, _b;
            this._date = (_a = options === null || options === void 0 ? void 0 : options.date) !== null && _a !== void 0 ? _a : null;
            this._inclusive = (_b = options === null || options === void 0 ? void 0 : options.inclusive) !== null && _b !== void 0 ? _b : false;
            this._onChange = onChange;
        }
        get date() {
            return this._date;
        }
        set date(date) {
            if (this._date !== date) {
                this._date = date;
                this._onChange();
            }
        }
        get inclusive() {
            return this._inclusive;
        }
        set inclusive(inclusive) {
            if (this._inclusive !== inclusive) {
                this._inclusive = inclusive;
                this._onChange();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerTimeBoundHours {
        constructor(parent) {
            this._parent = parent;
        }
        min(date) {
            const parent = this._parent;
            const lower = parent.lower;
            const lowerDate = lower.date;
            const constant = parent.constant;
            if (lowerDate != null) {
                const mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.hour.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.hour.min;
                    }
                }
                const lowerDateHours = lowerDate.getHours();
                if (lower.inclusive) {
                    return lowerDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (lowerDate.getMinutes() < constant.minute.max) {
                            return lowerDateHours;
                        }
                    }
                    return lowerDateHours + 1;
                }
            }
            return constant.hour.min;
        }
        max(date) {
            const parent = this._parent;
            const upper = parent.upper;
            const upperDate = upper.date;
            const constant = parent.constant;
            if (upperDate != null) {
                const mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.hour.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.hour.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.hour.max;
                    }
                }
                const upperDateHours = upperDate.getHours();
                if (upper.inclusive) {
                    return upperDateHours;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateHours;
                        }
                    }
                    if (mask & DPickerDatetimeMask.MINUTES) {
                        if (constant.minute.min < upperDate.getMinutes()) {
                            return upperDateHours;
                        }
                    }
                    return upperDateHours - 1;
                }
            }
            return constant.hour.max;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerTimeBoundMinutes {
        constructor(parent) {
            this._parent = parent;
        }
        min(date) {
            const parent = this._parent;
            const lower = parent.lower;
            const lowerDate = lower.date;
            const constant = parent.constant;
            if (lowerDate != null) {
                const mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.minute.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.minute.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.minute.min;
                    }
                }
                const lowerDateMinutes = lowerDate.getMinutes();
                if (lower.inclusive) {
                    return lowerDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (lowerDate.getSeconds() < constant.second.max) {
                            return lowerDateMinutes;
                        }
                    }
                    return lowerDateMinutes + 1;
                }
            }
            return constant.minute.min;
        }
        max(date) {
            const parent = this._parent;
            const upper = parent.upper;
            const upperDate = upper.date;
            const constant = parent.constant;
            if (upperDate != null) {
                const mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.minute.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.minute.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.minute.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.minute.max;
                    }
                }
                const upperDateMinutes = upperDate.getMinutes();
                if (upper.inclusive) {
                    return upperDateMinutes;
                }
                else {
                    if (mask & DPickerDatetimeMask.SECONDS) {
                        if (constant.second.min < upperDate.getSeconds()) {
                            return upperDateMinutes;
                        }
                    }
                    return upperDateMinutes - 1;
                }
            }
            return constant.minute.max;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerTimeBoundSeconds {
        constructor(parent) {
            this._parent = parent;
        }
        min(date) {
            const parent = this._parent;
            const lower = parent.lower;
            const lowerDate = lower.date;
            const constant = parent.constant;
            if (lowerDate != null) {
                const mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (lowerDate.getFullYear() < date.getFullYear()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getMonth() < date.getMonth()) {
                        return constant.second.min;
                    }
                    if (lowerDate.getDate() < date.getDate()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (lowerDate.getHours() < date.getHours()) {
                        return constant.second.min;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (lowerDate.getMinutes() < date.getMinutes()) {
                        return constant.second.min;
                    }
                }
                return lowerDate.getSeconds() + (lower.inclusive ? 0 : 1);
            }
            return constant.second.min;
        }
        max(date) {
            const parent = this._parent;
            const upper = parent.upper;
            const upperDate = upper.date;
            const constant = parent.constant;
            if (upperDate != null) {
                const mask = parent.mask;
                if (mask & DPickerDatetimeMask.DATE) {
                    if (date.getFullYear() < upperDate.getFullYear()) {
                        return constant.second.max;
                    }
                    if (date.getMonth() < upperDate.getMonth()) {
                        return constant.second.max;
                    }
                    if (date.getDate() < upperDate.getDate()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.HOURS) {
                    if (date.getHours() < upperDate.getHours()) {
                        return constant.second.max;
                    }
                }
                if (mask & DPickerDatetimeMask.MINUTES) {
                    if (date.getMinutes() < upperDate.getMinutes()) {
                        return constant.second.max;
                    }
                }
                return upperDate.getSeconds() - (upper.inclusive ? 0 : 1);
            }
            return constant.second.max;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerTimeBounds {
        constructor(options, onChange) {
            this.constant = this.newConstant();
            this.lower = new DPickerTimeBound(options && options.lower, onChange);
            this.upper = new DPickerTimeBound(options && options.upper, onChange);
            this.mask = DPickerDatetimeMask.ALL;
            this.hours = new DPickerTimeBoundHours(this);
            this.minutes = new DPickerTimeBoundMinutes(this);
            this.seconds = new DPickerTimeBoundSeconds(this);
        }
        newConstant() {
            return {
                second: {
                    min: 0,
                    max: 59
                },
                minute: {
                    min: 0,
                    max: 59
                },
                hour: {
                    min: 0,
                    max: 23
                }
            };
        }
        adjust(date) {
            const result = this.test(date);
            if (result < 0) {
                const lower = this.lower;
                const lowerDate = lower.date;
                if (lowerDate) {
                    date.setTime(lowerDate.getTime());
                    if (!lower.inclusive) {
                        const mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(lowerDate.getSeconds() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(lowerDate.getMinutes() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(lowerDate.getHours() + 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(lowerDate.getDate() + 1);
                        }
                    }
                    return true;
                }
            }
            else if (0 < result) {
                const upper = this.upper;
                const upperDate = upper.date;
                if (upperDate) {
                    date.setTime(upperDate.getTime());
                    if (!upper.inclusive) {
                        const mask = this.mask;
                        if (mask & DPickerDatetimeMask.SECONDS) {
                            date.setSeconds(upperDate.getSeconds() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.MINUTES) {
                            date.setMinutes(upperDate.getMinutes() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.HOURS) {
                            date.setHours(upperDate.getHours() - 1);
                        }
                        else if (mask & DPickerDatetimeMask.DATE) {
                            date.setDate(upperDate.getDate() - 1);
                        }
                    }
                    return true;
                }
            }
            return false;
        }
        compare(a, b) {
            const mask = this.mask;
            if (mask & DPickerDatetimeMask.DATE) {
                const ay = a.getFullYear();
                const by = b.getFullYear();
                if (ay !== by) {
                    return ay < by ? -1 : +1;
                }
                const am = a.getMonth();
                const bm = b.getMonth();
                if (am !== bm) {
                    return am < bm ? -1 : +1;
                }
                const ad = a.getDate();
                const bd = b.getDate();
                if (ad !== bd) {
                    return ad < bd ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.HOURS) {
                const ah = a.getHours();
                const bh = b.getHours();
                if (ah !== bh) {
                    return ah < bh ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                const am = a.getMinutes();
                const bm = b.getMinutes();
                if (am !== bm) {
                    return am < bm ? -1 : +1;
                }
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                const ad = a.getSeconds();
                const bd = b.getSeconds();
                if (ad !== bd) {
                    return ad < bd ? -1 : +1;
                }
            }
            return 0;
        }
        test(date) {
            // Lower bound
            const lower = this.lower;
            const lowerDate = lower.date;
            if (lowerDate != null) {
                const result = this.compare(lowerDate, date);
                if (lower.inclusive) {
                    return result <= 0 ? 0 : -1;
                }
                else {
                    return result < 0 ? 0 : -1;
                }
            }
            // Upper bound
            const upper = this.upper;
            const upperDate = upper.date;
            if (upperDate != null) {
                const result = this.compare(date, upperDate);
                if (upper.inclusive) {
                    return result <= 0 ? 0 : +1;
                }
                else {
                    return result < 0 ? 0 : +1;
                }
            }
            return 0;
        }
        contains(date) {
            return this.test(date) === 0;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toBoundOptions = (options, defaultDate, defaultInclusive) => {
        if (options) {
            const date = options.date;
            const inclusive = options.inclusive;
            return {
                date: date !== undefined ? date : defaultDate,
                inclusive: inclusive !== undefined ? inclusive : defaultInclusive
            };
        }
        return {
            date: defaultDate,
            inclusive: defaultInclusive
        };
    };
    const toBoundsOptions = (theme, options) => {
        if (options) {
            return {
                lower: toBoundOptions(options.lower, theme.getLowerBound(), theme.isLowerBoundInclusive()),
                upper: toBoundOptions(options.upper, theme.getUpperBound(), theme.isUpperBoundInclusive())
            };
        }
        return {
            lower: {
                date: theme.getLowerBound(),
                inclusive: theme.isLowerBoundInclusive()
            },
            upper: {
                date: theme.getUpperBound(),
                inclusive: theme.isUpperBoundInclusive()
            }
        };
    };
    class DPickerTime extends DBase {
        constructor(options) {
            super(options);
            this.onNewChange();
        }
        init(options) {
            var _a;
            super.init(options);
            const theme = this.theme;
            this._dateCurrent = new Date();
            const dateCurrentTime = this._dateCurrent.getTime();
            this._dateNew = new Date(dateCurrentTime);
            this._dateBounds = new DPickerTimeBounds(toBoundsOptions(theme, options === null || options === void 0 ? void 0 : options.bounds), () => {
                this.onNewChange();
            });
            const margin = (_a = options === null || options === void 0 ? void 0 : options.margin) !== null && _a !== void 0 ? _a : theme.getMargin();
            new DLayoutVertical({
                parent: this,
                x: "padding",
                y: "padding",
                width: "auto",
                height: "auto",
                margin,
                children: this.newChildren(theme, options, margin)
            });
        }
        get current() {
            return this._dateCurrent;
        }
        set current(dateCurrent) {
            if (this._dateCurrent.getTime() !== dateCurrent.getTime()) {
                this._dateCurrent = dateCurrent;
            }
        }
        get new() {
            return this._dateNew;
        }
        set new(dateNew) {
            if (this._dateNew.getTime() !== dateNew.getTime()) {
                this._dateNew = dateNew;
                this.onNewChange();
            }
        }
        get bounds() {
            return this._dateBounds;
        }
        hasHours() {
            return this._inputHours != null;
        }
        hasMinutes() {
            return this._inputMinutes != null;
        }
        hasSeconds() {
            return this._inputSeconds != null;
        }
        reset() {
            const currentTime = this._dateCurrent.getTime();
            this._dateNew.setTime(currentTime);
            this.onReset();
        }
        onReset() {
            this.onNewChange();
        }
        onNewChange() {
            const dateNew = this._dateNew;
            const dateBounds = this._dateBounds;
            dateBounds.adjust(this._dateNew);
            const inputHours = this._inputHours;
            if (inputHours) {
                const hours = dateBounds.hours;
                inputHours.value = dateNew.getHours();
                inputHours.min = hours.min(dateNew);
                inputHours.max = hours.max(dateNew);
            }
            const inputMinutes = this._inputMinutes;
            if (inputMinutes) {
                const minutes = dateBounds.minutes;
                inputMinutes.value = dateNew.getMinutes();
                inputMinutes.min = minutes.min(dateNew);
                inputMinutes.max = minutes.max(dateNew);
            }
            const inputSeconds = this._inputSeconds;
            if (inputSeconds) {
                const seconds = dateBounds.seconds;
                inputSeconds.value = dateNew.getSeconds();
                inputSeconds.min = seconds.min(dateNew);
                inputSeconds.max = seconds.max(dateNew);
            }
        }
        newChildren(theme, options, margin) {
            const mask = DPickerDatetimeMasks.from(theme, options);
            this._dateBounds.mask = mask;
            this._inputHours =
                mask & DPickerDatetimeMask.HOURS ? this.newInputHours(theme, options) : null;
            this._inputMinutes =
                mask & DPickerDatetimeMask.MINUTES ? this.newInputMinutes(theme, options) : null;
            this._inputSeconds =
                mask & DPickerDatetimeMask.SECONDS ? this.newInputSeconds(theme, options) : null;
            return [
                this.newTimeLayout(this._inputHours, this._inputMinutes, this._inputSeconds, margin)
            ];
        }
        newTimeLayout(hours, minutes, seconds, margin) {
            const children = this.newTimeLayoutChildren(hours, minutes, seconds);
            if (0 < children.length) {
                return new DLayoutHorizontal({
                    width: this.getTimeLayoutWidth(),
                    height: this.getTimeLayoutHeight(),
                    margin,
                    children
                });
            }
            return null;
        }
        getTimeLayoutWidth() {
            return "auto";
        }
        getTimeLayoutHeight() {
            return "auto";
        }
        newTimeLayoutChildren(hours, minutes, seconds) {
            const result = [];
            if (hours != null) {
                result.push(hours);
            }
            if (minutes != null) {
                if (0 < result.length) {
                    result.push(this.newMinuteSeparator());
                }
                result.push(minutes);
            }
            if (seconds != null) {
                if (0 < result.length) {
                    result.push(this.newSecondSeparator());
                }
                result.push(seconds);
            }
            return result;
        }
        newMinuteSeparator() {
            return new DText({
                width: "auto",
                text: {
                    value: this.getMinuteSeparator()
                }
            });
        }
        getMinuteSeparator() {
            return ":";
        }
        newSecondSeparator() {
            return new DText({
                width: "auto",
                text: {
                    value: this.getSecondSeparator()
                }
            });
        }
        getSecondSeparator() {
            return ":";
        }
        adjustInputOptions(theme, options, max) {
            if (options.step == null) {
                options.step = 1;
            }
            if (options.min == null) {
                options.min = 0;
            }
            if (options.max == null) {
                options.max = max;
            }
            return options;
        }
        newInputHours(theme, options) {
            var _a;
            const inputOptions = (_a = options === null || options === void 0 ? void 0 : options.hours) !== null && _a !== void 0 ? _a : theme.getHoursOptions();
            const max = this._dateBounds.constant.hour.max;
            const input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", (value) => {
                this.onHoursChange(value);
            });
            return input;
        }
        onHoursChange(value) {
            const dateNew = this._dateNew;
            dateNew.setHours(value);
            this.onNewChange();
        }
        newInputMinutes(theme, options) {
            const inputOptions = (options === null || options === void 0 ? void 0 : options.minutes) || theme.getMinutesOptions();
            const max = this._dateBounds.constant.minute.max;
            const input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", (value) => {
                this.onMinutesChange(value);
            });
            return input;
        }
        onMinutesChange(value) {
            const dateNew = this._dateNew;
            dateNew.setMinutes(value);
            this.onNewChange();
        }
        newInputSeconds(theme, options) {
            const inputOptions = (options === null || options === void 0 ? void 0 : options.seconds) || theme.getSecondsOptions();
            const max = this._dateBounds.constant.second.max;
            const input = new DInputInteger(this.adjustInputOptions(theme, inputOptions, max));
            input.on("change", (value) => {
                this.onSecondsChange(value);
            });
            return input;
        }
        onSecondsChange(value) {
            this._dateNew.setSeconds(value);
        }
        getType() {
            return "DPickerTime";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetime extends DPickerTime {
        init(options) {
            super.init(options);
            this._datePage = new Date(this._dateCurrent.getTime());
        }
        newChildren(theme, options, margin) {
            var _a, _b;
            this._dateButtons = this.newDateButtons(theme, options);
            this._dateDecorator = (_b = (_a = options === null || options === void 0 ? void 0 : options.date) === null || _a === void 0 ? void 0 : _a.decorator) !== null && _b !== void 0 ? _b : theme.getDateDecorator();
            this._label = this.newLabel(theme, options);
            const result = super.newChildren(theme, options, margin);
            result.unshift(new DLayoutHorizontal({
                width: "100%",
                height: "auto",
                children: [
                    this.newBackButton(theme, options),
                    this._label,
                    this.newNextButton(theme, options)
                ]
            }), new DLayoutHorizontal({
                width: "auto",
                height: "auto",
                margin,
                children: this.newDateLabels(theme, options)
            }), new DLayoutVertical({
                width: "auto",
                height: "auto",
                margin,
                column: 7,
                children: this._dateButtons
            }));
            return result;
        }
        get page() {
            return this._datePage;
        }
        set page(datePage) {
            if (this._datePage.getTime() !== datePage.getTime()) {
                this._datePage = datePage;
                this.onPageChange();
            }
        }
        onReset() {
            this._datePage.setTime(this._dateCurrent.getTime());
            super.onReset();
        }
        next() {
            const work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() + 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChange();
        }
        back() {
            const work = this._datePage;
            work.setFullYear(work.getFullYear(), work.getMonth() - 1, 1);
            work.setHours(0, 0, 0, 0);
            this.onPageChange();
        }
        onNewChange() {
            this._dateBounds.adjust(this._datePage);
            super.onNewChange();
            this.onPageChange();
        }
        onPageChange() {
            const buttons = this._dateButtons;
            const bounds = this._dateBounds;
            const datePage = this._datePage;
            const dateNew = this._dateNew;
            const tmp = new Date(datePage.getTime());
            tmp.setDate(1);
            tmp.setHours(0, 0, 0, 0);
            // Spaces
            const theme = this.theme;
            const spaceCount = (tmp.getDay() - theme.getDayStart() + 7) % 7;
            for (let i = 0; i < spaceCount; ++i) {
                buttons[i].show();
            }
            for (let i = spaceCount; i < 7; ++i) {
                buttons[i].hide();
            }
            // Date buttons
            const dateDecorator = this._dateDecorator;
            tmp.setFullYear(tmp.getFullYear(), tmp.getMonth() + 1, 0);
            const dateCount = tmp.getDate();
            const dateNewDate = dateNew.getFullYear() === tmp.getFullYear() && dateNew.getMonth() === tmp.getMonth()
                ? dateNew.getDate()
                : 0;
            for (let i = 0; i < dateCount; ++i) {
                tmp.setDate(i + 1);
                const button = buttons[i + 7];
                button.state.isActive = dateNewDate === i + 1;
                button.state.isDisabled = !bounds.contains(tmp);
                button.show();
                dateDecorator(tmp, button);
            }
            for (let i = dateCount; i < 31; ++i) {
                const button = buttons[i + 7];
                button.state.isActive = false;
                button.hide();
            }
            // Label
            tmp.setTime(datePage.getTime());
            this._label.text = tmp;
        }
        adjustInputOptions(theme, options, max) {
            if (options.weight == null) {
                options.weight = 1;
            }
            return super.adjustInputOptions(theme, options, max);
        }
        getTimeLayoutWidth() {
            return "100%";
        }
        toLabelOptions(theme, options) {
            const result = (options && options.label) || {};
            if (result.weight === undefined) {
                result.weight = 1;
            }
            if (result.padding === undefined) {
                result.padding = 0;
            }
            const labelText = (result.text = result.text || {});
            const labelTextAlign = (labelText.align = labelText.align || {});
            if (labelTextAlign.horizontal === undefined) {
                labelTextAlign.horizontal = "CENTER";
            }
            if (labelText.formatter === undefined) {
                labelText.formatter = theme.getLabelFormatter();
            }
            return result;
        }
        newLabel(theme, options) {
            return new DPickerDatetimeLabel(this.toLabelOptions(theme, options));
        }
        newBackButton(theme, options) {
            let buttonOptions = options === null || options === void 0 ? void 0 : options.back;
            if (buttonOptions === undefined) {
                buttonOptions = theme.getBackButtonOptions();
            }
            if (buttonOptions != null) {
                const button = new DPickerDatetimeButtonBack(buttonOptions);
                button.on("active", () => {
                    this.back();
                });
                return button;
            }
            return null;
        }
        newNextButton(theme, options) {
            let buttonOptions = options === null || options === void 0 ? void 0 : options.next;
            if (buttonOptions === undefined) {
                buttonOptions = theme.getNextButtonOptions();
            }
            if (buttonOptions != null) {
                const button = new DPickerDatetimeButtonNext(buttonOptions);
                button.on("active", () => {
                    this.next();
                });
                return button;
            }
            return null;
        }
        newDateLabels(theme, options) {
            const dateLabels = theme.getDayLabels();
            const dayStart = theme.getDayStart();
            const result = [];
            for (let i = 0; i < 7; ++i) {
                const label = dateLabels[(dayStart + i) % 7];
                result.push(this.newDateLabel(theme, options, label));
            }
            return result;
        }
        newDateLabel(theme, options, label) {
            return new DPickerDatetimeLabelDate({
                text: {
                    value: label
                }
            });
        }
        newDateButtons(theme, options) {
            const result = [];
            for (let i = 0; i < 7; ++i) {
                result.push(this.newSpace(theme, options));
            }
            for (let i = 1; i <= 31; ++i) {
                result.push(this.newDateButton(theme, options, i));
            }
            return result;
        }
        newSpace(theme, options) {
            return new DPickerDatetimeSpace();
        }
        newDateButton(theme, options, date) {
            return new DPickerDatetimeButtonDate({
                text: {
                    value: String(date)
                },
                on: {
                    active: () => {
                        this.onDateButtonClicked(date);
                    }
                }
            });
        }
        onDateButtonClicked(date) {
            const dateNew = this._dateNew;
            if (dateNew.getDate() !== date) {
                const datePage = this._datePage;
                dateNew.setFullYear(datePage.getFullYear());
                dateNew.setMonth(datePage.getMonth());
                dateNew.setDate(date);
                this.onNewChange();
            }
        }
        getType() {
            return "DPickerDatetime";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogDatetime extends DDialogFitted {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.picker);
            return result;
        }
        get current() {
            return this.picker.current;
        }
        set current(dateCurrent) {
            this.picker.current = dateCurrent;
        }
        get new() {
            return this.picker.new;
        }
        set new(value) {
            this.picker.new = value;
        }
        get page() {
            return this.picker.new;
        }
        set page(page) {
            this.picker.page = page;
        }
        get picker() {
            var _a;
            let result = this._picker;
            if (result == null) {
                result = new DPickerDatetime((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                this._picker = result;
            }
            return result;
        }
        getResolvedValue() {
            return this.picker.new;
        }
        getType() {
            return "DDialogDatetime";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpenDialogDatetime extends EShapeActionRuntimeOpenDialog {
        constructor(value) {
            super(value);
            this.initial = EShapeActionExpressions.ofUnknown(value.initial);
        }
        open(shape, target, initial, step, min, max) {
            let dialog = EShapeActionRuntimeOpenDialogDatetime.DIALOG;
            if (dialog == null) {
                dialog = new DDialogDatetime();
                EShapeActionRuntimeOpenDialogDatetime.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open(shape).then((value) => {
                return value.toISOString();
            });
        }
        toDate(value) {
            if (isString(value) || isNumber(value)) {
                return new Date(value);
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogTime extends DDialogFitted {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.picker);
            return result;
        }
        get current() {
            return this.picker.current;
        }
        set current(dateCurrent) {
            this.picker.current = dateCurrent;
        }
        get new() {
            return this.picker.new;
        }
        set new(dateNew) {
            this.picker.new = dateNew;
        }
        get picker() {
            var _a;
            let result = this._picker;
            if (result == null) {
                result = new DPickerTime((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                this._picker = result;
            }
            return result;
        }
        getResolvedValue() {
            return this.picker.new;
        }
        getType() {
            return "DDialogTime";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const isNaN$1 = (target) => {
        return target !== target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpenDialogTime extends EShapeActionRuntimeOpenDialog {
        constructor(value) {
            super(value);
            this.initial = EShapeActionExpressions.ofUnknown(value.initial);
        }
        open(shape, target, initial, step, min, max) {
            let dialog = EShapeActionRuntimeOpenDialogTime.DIALOG;
            if (dialog == null) {
                dialog = new DDialogTime();
                EShapeActionRuntimeOpenDialogTime.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open(shape).then((value) => {
                return this.getFormatter().format(value.getTime(), 0);
            });
        }
        toDate(value) {
            if (isNumber(value)) {
                return new Date(value);
            }
            else if (isString(value)) {
                const result = new Date();
                const pattern = this.getPattern();
                const matched = pattern.exec(value);
                if (matched != null) {
                    const hours = this.toHours(matched[1]);
                    if (hours != null) {
                        result.setHours(hours);
                    }
                    const minutes = this.toMinutes(matched[2]);
                    if (minutes != null) {
                        result.setMinutes(minutes);
                    }
                    const seconds = this.toSeconds(matched[3]);
                    if (seconds != null) {
                        result.setSeconds(seconds);
                    }
                    const milliseconds = this.toMilliseconds(matched[4]);
                    if (milliseconds != null) {
                        result.setMilliseconds(milliseconds);
                    }
                }
                return result;
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        }
        toHours(value) {
            return this.toNumber(value, 0, 23);
        }
        toMinutes(value) {
            return this.toNumber(value, 0, 59);
        }
        toSeconds(value) {
            return this.toNumber(value, 0, 59);
        }
        toMilliseconds(value) {
            const result = this.toNumber(value, 0, 999);
            if (result != null) {
                const length = value.length;
                if (length === 1) {
                    return result * 100;
                }
                else if (length === 2) {
                    return result * 10;
                }
                else {
                    return result;
                }
            }
            return result;
        }
        toNumber(value, min, max) {
            if (value != null) {
                const num = +value;
                if (!isNaN$1(num)) {
                    return Math.min(max, Math.max(min, num));
                }
            }
            return null;
        }
        getPattern() {
            let result = EShapeActionRuntimeOpenDialogTime.PATTERN;
            if (result == null) {
                result = this.newPattern();
                EShapeActionRuntimeOpenDialogTime.PATTERN = result;
            }
            return result;
        }
        newPattern() {
            return /^\s*(?:(\d+)(?::(\d+)(?::(\d+))?)?)?(?:\.(\d+))?\s*$/;
        }
        getFormatter() {
            let result = EShapeActionRuntimeOpenDialogTime.FORMATTER;
            if (result == null) {
                result = this.newFormatter();
                EShapeActionRuntimeOpenDialogTime.FORMATTER = result;
            }
            return result;
        }
        newFormatter() {
            return NumberFormatters.create("%Hm");
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDate extends DPickerDatetime {
        getType() {
            return "DPickerDate";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogDate extends DDialogFitted {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.picker);
            return result;
        }
        get current() {
            return this.picker.current;
        }
        set current(dateCurrent) {
            this.picker.current = dateCurrent;
        }
        get new() {
            return this.picker.new;
        }
        set new(value) {
            this.picker.new = value;
        }
        get page() {
            return this.picker.new;
        }
        set page(page) {
            this.picker.page = page;
        }
        get picker() {
            var _a;
            let result = this._picker;
            if (result == null) {
                result = new DPickerDate((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                this._picker = result;
            }
            return result;
        }
        getResolvedValue() {
            return this.picker.new;
        }
        getType() {
            return "DDialogDate";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpenDialogDate extends EShapeActionRuntimeOpenDialog {
        constructor(value) {
            super(value);
            this.initial = EShapeActionExpressions.ofUnknown(value.initial);
        }
        open(shape, target, initial, step, min, max) {
            let dialog = EShapeActionRuntimeOpenDialogDate.DIALOG;
            if (dialog == null) {
                dialog = new DDialogDate();
                EShapeActionRuntimeOpenDialogDate.DIALOG = dialog;
            }
            dialog.new = dialog.current = this.toDate(initial);
            return dialog.open(shape).then((value) => {
                return this.getFormatter().format(value.getTime(), 0);
            });
        }
        toDate(value) {
            if (isString(value) || isNumber(value)) {
                return new Date(value);
            }
            else if (value instanceof Date) {
                return value;
            }
            else {
                return new Date();
            }
        }
        getFormatter() {
            let result = EShapeActionRuntimeOpenDialogDate.FORMATTER;
            if (result == null) {
                result = this.newFormatter();
                EShapeActionRuntimeOpenDialogDate.FORMATTER = result;
            }
            return result;
        }
        newFormatter() {
            return NumberFormatters.create("%Y-%M-%D");
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueOpenDialogType = {
        TEXT: 0,
        INTEGER: 1,
        REAL: 2,
        BOOLEAN: 3,
        DATE: 4,
        TIME: 5,
        DATETIME: 6,
        EXTENSION: 1000
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueOpenDialog extends EShapeActionValueSubtyped {
        constructor(condition, target, onInputAction, initial, step, min, max, dialogType) {
            super(EShapeActionValueType.OPEN, condition, EShapeActionValueOpenType.DIALOG);
            this.target = target;
            this.onInputAction = onInputAction;
            this.initial = initial;
            this.step = step;
            this.min = min;
            this.max = max;
            this.dialogType = dialogType;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueOpenDialog &&
                this.target === value.target &&
                this.dialogType === value.dialogType &&
                this.onInputAction === value.onInputAction &&
                this.initial === value.initial &&
                this.step === value.step &&
                this.min === value.min &&
                this.max === value.max);
        }
        toRuntime() {
            switch (this.dialogType) {
                case EShapeActionValueOpenDialogType.TEXT:
                    return new EShapeActionRuntimeOpenDialogText(this);
                case EShapeActionValueOpenDialogType.INTEGER:
                    return new EShapeActionRuntimeOpenDialogInteger(this);
                case EShapeActionValueOpenDialogType.REAL:
                    return new EShapeActionRuntimeOpenDialogReal(this);
                case EShapeActionValueOpenDialogType.BOOLEAN:
                    return new EShapeActionRuntimeOpenDialogBoolean(this);
                case EShapeActionValueOpenDialogType.DATE:
                    return new EShapeActionRuntimeOpenDialogDate(this);
                case EShapeActionValueOpenDialogType.TIME:
                    return new EShapeActionRuntimeOpenDialogTime(this);
                case EShapeActionValueOpenDialogType.DATETIME:
                    return new EShapeActionRuntimeOpenDialogDatetime(this);
            }
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const targetId = manager.addResource(this.target);
            const initialId = manager.addResource(this.initial);
            const stepId = manager.addResource(this.step);
            const minId = manager.addResource(this.min);
            const maxId = manager.addResource(this.max);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${targetId},${this.onInputAction},${initialId},${this.dialogType},${stepId},${minId},${maxId}]`);
        }
        static deserialize(serialized, manager) {
            const resources = manager.resources;
            const condition = EShapeActionValues.toResource(1, serialized, resources);
            const target = EShapeActionValues.toResource(3, serialized, resources);
            const initial = EShapeActionValues.toResource(5, serialized, resources);
            const step = EShapeActionValues.toResource(7, serialized, resources);
            const min = EShapeActionValues.toResource(8, serialized, resources);
            const max = EShapeActionValues.toResource(9, serialized, resources);
            return new EShapeActionValueOpenDialog(condition, target, serialized[4], initial, step, min, max, this.toDialogType(serialized));
        }
        static toDialogType(serialized) {
            if (serialized[2] === EShapeActionValueOpenType.DIALOG) {
                return serialized[6];
            }
            else {
                switch (serialized[2]) {
                    case EShapeActionValueOpenType.DIALOG_TEXT:
                        return EShapeActionValueOpenDialogType.TEXT;
                    case EShapeActionValueOpenType.DIALOG_INTEGER:
                        return EShapeActionValueOpenDialogType.INTEGER;
                    case EShapeActionValueOpenType.DIALOG_REAL:
                        return EShapeActionValueOpenDialogType.REAL;
                    case EShapeActionValueOpenType.DIALOG_BOOLEAN:
                        return EShapeActionValueOpenDialogType.BOOLEAN;
                    case EShapeActionValueOpenType.DIALOG_DATE:
                        return EShapeActionValueOpenDialogType.DATE;
                    case EShapeActionValueOpenType.DIALOG_TIME:
                        return EShapeActionValueOpenDialogType.TIME;
                    case EShapeActionValueOpenType.DIALOG_DATETIME:
                        return EShapeActionValueOpenDialogType.DATETIME;
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionOpenDialogExtensions {
        static add(extension) {
            var _a, _b;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._data) !== null && _b !== void 0 ? _b : (this._data = [])).push(extension);
        }
        static get(type) {
            const typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        }
        static each(iteratee) {
            const data = this._data;
            if (data != null) {
                for (let i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeOpenDialogExtension extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this.target = EShapeActionExpressions.ofStringOrNull(value.target);
            this.argument = EShapeActionExpressions.ofUnknown(value.argument);
            const extension = EShapeActionOpenDialogExtensions.get(value.dialogType);
            if (extension) {
                this.opener = extension.opener;
            }
        }
        execute(shape, runtime, time) {
            const opener = this.opener;
            if (opener) {
                if (this.condition(shape, time, EShapeActionEnvironment)) {
                    const target = this.target(shape, time, EShapeActionEnvironment);
                    if (target != null) {
                        const diagram = EShapeActions.toDiagram(shape);
                        if (diagram != null) {
                            const argument = this.argument(shape, time, EShapeActionEnvironment);
                            setTimeout(() => {
                                opener(target, argument, shape, diagram, EShapeActionEnvironment);
                            }, 0);
                        }
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueOpenDialogExtension extends EShapeActionValueSubtyped {
        constructor(condition, target, argument, dialogType) {
            super(EShapeActionValueType.OPEN, condition, EShapeActionValueOpenType.DIALOG);
            this.target = target;
            this.argument = argument;
            this.dialogType = dialogType;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueOpenDialogExtension &&
                this.target === value.target &&
                this.argument === value.argument &&
                this.dialogType === value.dialogType);
        }
        toRuntime() {
            return new EShapeActionRuntimeOpenDialogExtension(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const targetId = manager.addResource(this.target);
            const argumentId = manager.addResource(this.argument);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${targetId},0,-1,${this.dialogType},${argumentId}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const target = EShapeActionValues.toResource(3, serialized, manager.resources);
            const argument = EShapeActionValues.toResource(7, serialized, manager.resources);
            return new EShapeActionValueOpenDialogExtension(condition, target, argument, serialized[6]);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionOpenExtensions {
        static add(extension) {
            var _a, _b;
            ((_a = this._typeToDatum) !== null && _a !== void 0 ? _a : (this._typeToDatum = new Map())).set(extension.type, extension);
            ((_b = this._data) !== null && _b !== void 0 ? _b : (this._data = [])).push(extension);
            EShapeActionOpenOpeners[extension.type] = extension.opener;
        }
        static get(type) {
            const typeToDatum = this._typeToDatum;
            if (typeToDatum != null) {
                return typeToDatum.get(type);
            }
        }
        static each(iteratee) {
            const data = this._data;
            if (data != null) {
                for (let i = 0, imax = data.length; i < imax; ++i) {
                    iteratee(data[i]);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueOpenExtension extends EShapeActionValueSubtyped {
        constructor(subtype, condition, target, inNewWindow) {
            super(EShapeActionValueType.OPEN, condition, subtype);
            this.target = target;
            this.inNewWindow = inNewWindow;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueOpenExtension &&
                this.target === value.target &&
                this.inNewWindow === value.inNewWindow);
        }
        toRuntime() {
            return new EShapeActionRuntimeOpen(this, this.subtype);
        }
        toLabel() {
            const typeLabel = this.getTheme().toTypeLabel(this.type);
            const datum = EShapeActionOpenExtensions.get(this.subtype);
            return `${typeLabel}: ${datum != null ? datum.label : "Unknown"}`;
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const targetId = manager.addResource(this.target);
            const inNewWindow = this.inNewWindow ? 1 : 0;
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${targetId},${inNewWindow}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const target = EShapeActionValues.toResource(3, serialized, manager.resources);
            return new EShapeActionValueOpenExtension(serialized[2], condition, target, !!serialized[4]);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueShowHideType = {
        /** @deprecated in favor of {@link SHAPE} */
        SHAPE_SHOW: 0,
        /** @deprecated in favor of {@link SHAPE} */
        SHAPE_HIDE: 1,
        SHAPE: 2,
        LAYER: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * @deprecated in favor of {@link EShapeActionRuntimeShowHideShape}.
     */
    class EShapeActionRuntimeShowHide extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.VISIBILITY);
            this.visibility = value.subtype === EShapeActionValueShowHideType.SHAPE_SHOW;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                shape.visible = this.visibility;
                runtime.written |= this.reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * @deprecated in favor of {@link EShapeActionValueShowHideShape}.
     */
    class EShapeActionValueShowHide extends EShapeActionValueSubtyped {
        constructor(subtype, condition) {
            super(EShapeActionValueType.SHOW_HIDE, condition, subtype);
        }
        toRuntime() {
            return new EShapeActionRuntimeShowHide(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueShowHide(serialized[2], condition);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeShowHideLayer extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.NONE);
            this._data = new Map();
            this._layers = value.layers;
            this._bringToFront = value.bringToFront;
        }
        initialize(shape, runtime) {
            super.initialize(shape, runtime);
            let data = this._data.get(shape);
            if (data == null) {
                data = this.newData(shape);
                if (data != null) {
                    this._data.set(shape, data);
                }
            }
        }
        execute(shape, runtime, time) {
            const data = this._data.get(shape);
            if (data) {
                const newCondition = this.condition(shape, time, EShapeActionEnvironment);
                if (data.condition !== newCondition) {
                    data.condition = newCondition;
                    const layers = data.layers;
                    if (newCondition) {
                        if (data.bringToFront) {
                            DDiagramLayers.bringAllToFront(layers);
                            DDiagramLayers.showAll(layers);
                        }
                        else {
                            DDiagramLayers.showAll(layers);
                        }
                    }
                    else {
                        DDiagramLayers.hideAll(layers);
                    }
                }
            }
        }
        newData(shape) {
            const layers = DDiagramLayers.toLayers(shape, this._layers);
            if (0 < layers.length) {
                return {
                    layers: layers,
                    bringToFront: this._bringToFront,
                    condition: null
                };
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueShowHideLayer extends EShapeActionValueSubtyped {
        constructor(condition, layers, bringToFront) {
            super(EShapeActionValueType.SHOW_HIDE, condition, EShapeActionValueShowHideType.LAYER);
            this.layers = layers;
            this.bringToFront = bringToFront;
        }
        toRuntime() {
            return new EShapeActionRuntimeShowHideLayer(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const layersId = this.serializeLayers(manager);
            const bringToFrontId = this.bringToFront ? 1 : 0;
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${layersId},${bringToFrontId}]`);
        }
        serializeLayers(manager) {
            const layers = this.layers;
            let result = "[";
            let delimiter = "";
            for (let i = 0, imax = layers.length; i < imax; ++i) {
                result += delimiter + layers[i];
                delimiter = ",";
            }
            result += "]";
            return manager.addResource(result);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const layers = this.deserializeLayers(serialized[3], manager);
            const bringToFront = !!serialized[4];
            return new EShapeActionValueShowHideLayer(condition, layers, bringToFront);
        }
        static deserializeLayers(target, manager) {
            const resources = manager.resources;
            const resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                return JSON.parse(resources[target]);
            }
            return [];
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeShowHideShape extends EShapeActionRuntimeConditional {
        constructor(value) {
            super(value, EShapeRuntimeReset.VISIBILITY);
        }
        initialize(shape, runtime) {
            super.initialize(shape, runtime);
        }
        execute(shape, runtime, time) {
            shape.visible = this.condition(shape, time, EShapeActionEnvironment);
            runtime.written |= this.reset;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueShowHideShape extends EShapeActionValueSubtyped {
        constructor(condition) {
            super(EShapeActionValueType.SHOW_HIDE, condition, EShapeActionValueShowHideType.SHAPE);
        }
        toRuntime() {
            return new EShapeActionRuntimeShowHideShape(this);
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            return new EShapeActionValueShowHideShape(condition);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformMove extends EShapeActionRuntimeConditional {
        constructor(value, reset) {
            super(value, reset);
            this.amount = EShapeActionExpressions.ofNumber(value.amount);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformMoveAbsoluteX extends EShapeActionRuntimeTransformMove {
        constructor(value) {
            super(value, EShapeRuntimeReset.POSITION_X);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const amount = this.amount(shape, time, EShapeActionEnvironment);
                shape.transform.position.x = amount;
                runtime.written |= this.reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformMoveAbsoluteY extends EShapeActionRuntimeTransformMove {
        constructor(value) {
            super(value, EShapeRuntimeReset.POSITION_Y);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const amount = this.amount(shape, time, EShapeActionEnvironment);
                shape.transform.position.y = amount;
                runtime.written |= this.reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformMoveForwardOrBackward extends EShapeActionRuntimeTransformMove {
        constructor(value) {
            super(value, EShapeRuntimeReset.POSITION);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const amount = this.amount(shape, time, EShapeActionEnvironment);
                const transform = shape.transform;
                const position = transform.position;
                const writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                const writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                const oldPositionX = writtenPositionX ? position.x : runtime.x;
                const oldPositionY = writtenPositionY ? position.y : runtime.y;
                shape.updateTransform();
                const localTransform = transform.localTransform;
                position.set(oldPositionX - localTransform.c * amount, oldPositionY - localTransform.d * amount);
                runtime.written |= this.reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformMoveLeftOrRight extends EShapeActionRuntimeTransformMove {
        constructor(value) {
            super(value, EShapeRuntimeReset.POSITION);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const amount = this.amount(shape, time, EShapeActionEnvironment);
                const transform = shape.transform;
                const position = transform.position;
                const writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                const writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                const oldPositionX = writtenPositionX ? position.x : runtime.x;
                const oldPositionY = writtenPositionY ? position.y : runtime.y;
                shape.updateTransform();
                const localTransform = transform.localTransform;
                position.set(oldPositionX + localTransform.a * amount, oldPositionY + localTransform.b * amount);
                runtime.written |= this.reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformMoveRelativeX extends EShapeActionRuntimeTransformMove {
        constructor(value) {
            super(value, EShapeRuntimeReset.POSITION_X);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const amount = this.amount(shape, time, EShapeActionEnvironment);
                const writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
                const position = shape.transform.position;
                const oldPositionX = writtenPositionX ? position.x : runtime.x;
                position.x = oldPositionX + amount;
                runtime.written |= this.reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformMoveRelativeY extends EShapeActionRuntimeTransformMove {
        constructor(action) {
            super(action, EShapeRuntimeReset.POSITION_Y);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const amount = this.amount(shape, time, EShapeActionEnvironment);
                const writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
                const position = shape.transform.position;
                const oldPositionY = writtenPositionY ? position.y : runtime.y;
                position.y = oldPositionY + amount;
                runtime.written |= this.reset;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueOpetyped extends EShapeActionValueSubtyped {
        constructor(type, condition, subtype, opetype) {
            super(type, condition, subtype);
            this.opetype = opetype;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueOpetyped &&
                this.opetype === value.opetype);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueTransformMoveType = {
        RELATIVE_X: 0,
        RELATIVE_Y: 1,
        ABSOLUTE_X: 2,
        ABSOLUTE_Y: 3,
        FORWARD_OR_BACKWARD: 4,
        LEFT_OR_RIGHT: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueTransformType = {
        RESIZE: 0,
        MOVE: 1,
        ROTATE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueTransformMove extends EShapeActionValueOpetyped {
        constructor(opetype, condition, amount) {
            super(EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.MOVE, opetype);
            this.amount = amount;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueTransformMove &&
                this.amount === value.amount);
        }
        toRuntime() {
            switch (this.opetype) {
                case EShapeActionValueTransformMoveType.ABSOLUTE_X:
                    return new EShapeActionRuntimeTransformMoveAbsoluteX(this);
                case EShapeActionValueTransformMoveType.ABSOLUTE_Y:
                    return new EShapeActionRuntimeTransformMoveAbsoluteY(this);
                case EShapeActionValueTransformMoveType.FORWARD_OR_BACKWARD:
                    return new EShapeActionRuntimeTransformMoveForwardOrBackward(this);
                case EShapeActionValueTransformMoveType.LEFT_OR_RIGHT:
                    return new EShapeActionRuntimeTransformMoveLeftOrRight(this);
                case EShapeActionValueTransformMoveType.RELATIVE_X:
                    return new EShapeActionRuntimeTransformMoveRelativeX(this);
                case EShapeActionValueTransformMoveType.RELATIVE_Y:
                    return new EShapeActionRuntimeTransformMoveRelativeY(this);
            }
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const amountId = manager.addResource(this.amount);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${this.opetype},${amountId}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const amount = EShapeActionValues.toResource(4, serialized, manager.resources);
            return new EShapeActionValueTransformMove(serialized[3], condition, amount);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueTransformResizeType = {
        RELATIVE_SIZE: 0,
        RELATIVE_HEIGHT: 1,
        RELATIVE_WIDTH: 2,
        ABSOLUTE_SIZE: 3,
        ABSOLUTE_HEIGHT: 4,
        ABSOLUTE_WIDTH: 5
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformResize extends EShapeActionRuntimeConditional {
        constructor(value, reset) {
            super(value, reset);
            switch (value.opetype) {
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    this.size = EShapeActionExpressions.ofNumberOrOne(value.amount);
                    break;
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    this.size = EShapeActionExpressions.ofNumberOrOneHundred(value.amount);
                    break;
                default:
                    this.size = EShapeActionExpressions.ONE;
            }
        }
        adjustPosition(shape, runtime, dsx, dsy, originX, originY) {
            const dx = (-0.5 + originX) * dsx;
            const dy = (-0.5 + originY) * dsy;
            shape.updateTransform();
            const transform = shape.transform;
            const position = transform.position;
            const localTransform = transform.localTransform;
            const writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
            const writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
            const oldPositionX = writtenPositionX ? position.x : runtime.x;
            const oldPositionY = writtenPositionY ? position.y : runtime.y;
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * localTransform.a + dy * localTransform.c, oldPositionY + dx * localTransform.b + dy * localTransform.d);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformResizeHeightAbsolute extends EShapeActionRuntimeTransformResize {
        constructor(value) {
            super(value, EShapeRuntimeReset.HEIGHT | EShapeRuntimeReset.POSITION);
            this.origin = value.originY;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const sizeAbsolute = this.size(shape, time, EShapeActionEnvironment);
                const size = shape.size;
                const writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                const oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.y = toSizeNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformResizeHeightRelative extends EShapeActionRuntimeTransformResize {
        constructor(value) {
            super(value, EShapeRuntimeReset.HEIGHT | EShapeRuntimeReset.POSITION);
            this.origin = value.originY;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const sizeRelative = this.size(shape, time, EShapeActionEnvironment);
                const size = shape.size;
                const writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                const oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.y = toSizeNormalized(oldSizeY * sizeRelative);
                runtime.written |= EShapeRuntimeReset.HEIGHT;
                this.adjustPosition(shape, runtime, 0, oldSizeY - size.y, 0.5, this.origin);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformResizeSizeAbsolute extends EShapeActionRuntimeTransformResize {
        constructor(value) {
            super(value, EShapeRuntimeReset.SIZE | EShapeRuntimeReset.POSITION);
            this.originX = value.originX;
            this.originY = value.originY;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const sizeAbsolute = toSizeNormalized(this.size(shape, time, EShapeActionEnvironment));
                const size = shape.size;
                const writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                const writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                const oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                const oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.set(sizeAbsolute, sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformResizeSizeRelative extends EShapeActionRuntimeTransformResize {
        constructor(value) {
            super(value, EShapeRuntimeReset.SIZE | EShapeRuntimeReset.POSITION);
            this.originX = value.originX;
            this.originY = value.originY;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const sizeRelative = this.size(shape, time, EShapeActionEnvironment);
                const size = shape.size;
                const writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                const writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
                const oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                const oldSizeY = writtenHeight ? size.y : runtime.sizeY;
                size.set(toSizeNormalized(oldSizeX * sizeRelative), toSizeNormalized(oldSizeY * sizeRelative));
                runtime.written |= EShapeRuntimeReset.SIZE;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, oldSizeY - size.y, this.originX, this.originY);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformResizeWidthAbsolute extends EShapeActionRuntimeTransformResize {
        constructor(value) {
            super(value, EShapeRuntimeReset.WIDTH | EShapeRuntimeReset.POSITION);
            this.origin = value.originX;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const sizeAbsolute = this.size(shape, time, EShapeActionEnvironment);
                const size = shape.size;
                const writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                const oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                size.x = toSizeNormalized(sizeAbsolute);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformResizeWidthRelative extends EShapeActionRuntimeTransformResize {
        constructor(value) {
            super(value, EShapeRuntimeReset.WIDTH | EShapeRuntimeReset.POSITION);
            this.origin = value.originX;
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const sizeRelative = this.size(shape, time, EShapeActionEnvironment);
                const size = shape.size;
                const writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
                const oldSizeX = writtenWidth ? size.x : runtime.sizeX;
                size.x = toSizeNormalized(oldSizeX * sizeRelative);
                runtime.written |= EShapeRuntimeReset.WIDTH;
                this.adjustPosition(shape, runtime, oldSizeX - size.x, 0, this.origin, 0.5);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueTransformResize extends EShapeActionValueOpetyped {
        constructor(opetype, condition, originX, originY, amount) {
            super(EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.RESIZE, opetype);
            this.originX = originX;
            this.originY = originY;
            this.amount = amount;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueTransformResize &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        }
        toRuntime() {
            switch (this.opetype) {
                case EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthAbsolute(this);
                case EShapeActionValueTransformResizeType.ABSOLUTE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeAbsolute(this);
                case EShapeActionValueTransformResizeType.RELATIVE_HEIGHT:
                    return new EShapeActionRuntimeTransformResizeHeightRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_WIDTH:
                    return new EShapeActionRuntimeTransformResizeWidthRelative(this);
                case EShapeActionValueTransformResizeType.RELATIVE_SIZE:
                    return new EShapeActionRuntimeTransformResizeSizeRelative(this);
            }
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const amountId = manager.addResource(this.amount);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${this.opetype},${this.originX},${this.originY},${amountId}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformResize(serialized[3], condition, serialized[4], serialized[5], amount);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformRotate extends EShapeActionRuntimeConditional {
        constructor(value, reset) {
            super(value, reset);
            this.originX = value.originX;
            this.originY = value.originY;
            this.amount = EShapeActionExpressions.ofNumber(`(${value.amount}) * (Math.PI / 180)`);
        }
        adjustPosition(shape, runtime, oldRotation, newRotation, originX, originY) {
            const writtenWidth = !!(runtime.written & EShapeRuntimeReset.WIDTH);
            const writtenHeight = !!(runtime.written & EShapeRuntimeReset.HEIGHT);
            const dx = (-0.5 + originX) * (writtenWidth ? shape.size.x : runtime.sizeX);
            const dy = (-0.5 + originY) * (writtenHeight ? shape.size.y : runtime.sizeY);
            const s = Math.sin(oldRotation) - Math.sin(newRotation);
            const c = Math.cos(oldRotation) - Math.cos(newRotation);
            const position = shape.transform.position;
            const writtenPositionX = !!(runtime.written & EShapeRuntimeReset.POSITION_X);
            const writtenPositionY = !!(runtime.written & EShapeRuntimeReset.POSITION_Y);
            const oldPositionX = writtenPositionX ? position.x : runtime.x;
            const oldPositionY = writtenPositionY ? position.y : runtime.y;
            runtime.written |= EShapeRuntimeReset.POSITION;
            position.set(oldPositionX + dx * c - dy * s, oldPositionY + dx * s + dy * c);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformRotateAbsolute extends EShapeActionRuntimeTransformRotate {
        constructor(value) {
            super(value, EShapeRuntimeReset.ROTATION | EShapeRuntimeReset.POSITION);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const amount = this.amount(shape, time, EShapeActionEnvironment);
                const transform = shape.transform;
                const writtenRotation = !!(runtime.written & EShapeRuntimeReset.ROTATION);
                const oldRotation = writtenRotation ? transform.rotation : runtime.rotation;
                transform.rotation = amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, amount, this.originX, this.originY);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionRuntimeTransformRotateRelative extends EShapeActionRuntimeTransformRotate {
        constructor(value) {
            super(value, EShapeRuntimeReset.ROTATION | EShapeRuntimeReset.POSITION);
        }
        execute(shape, runtime, time) {
            if (this.condition(shape, time, EShapeActionEnvironment)) {
                const amount = this.amount(shape, time, EShapeActionEnvironment);
                const transform = shape.transform;
                const writtenRotation = !!(runtime.written & EShapeRuntimeReset.ROTATION);
                const oldRotation = writtenRotation ? transform.rotation : runtime.rotation;
                transform.rotation = oldRotation + amount;
                runtime.written |= EShapeRuntimeReset.ROTATION;
                this.adjustPosition(shape, runtime, oldRotation, transform.rotation, this.originX, this.originY);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueTransformRotateType = {
        RELATIVE: 0,
        ABSOLUTE: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueTransformRotate extends EShapeActionValueOpetyped {
        constructor(opetype, condition, originX, originY, amount) {
            super(EShapeActionValueType.TRANSFORM, condition, EShapeActionValueTransformType.ROTATE, opetype);
            this.originX = originX;
            this.originY = originY;
            this.amount = amount;
        }
        isEquals(value) {
            return (super.isEquals(value) &&
                value instanceof EShapeActionValueTransformRotate &&
                this.originX === value.originX &&
                this.originY === value.originY &&
                this.amount === value.amount);
        }
        toRuntime() {
            switch (this.opetype) {
                case EShapeActionValueTransformRotateType.ABSOLUTE:
                    return new EShapeActionRuntimeTransformRotateAbsolute(this);
                case EShapeActionValueTransformRotateType.RELATIVE:
                    return new EShapeActionRuntimeTransformRotateRelative(this);
            }
        }
        serialize(manager) {
            const conditionId = manager.addResource(this.condition);
            const amountId = manager.addResource(this.amount);
            return manager.addResource(`[${this.type},${conditionId},${this.subtype},${this.opetype},${this.originX},${this.originY},${amountId}]`);
        }
        static deserialize(serialized, manager) {
            const condition = EShapeActionValues.toResource(1, serialized, manager.resources);
            const amount = EShapeActionValues.toResource(6, serialized, manager.resources);
            return new EShapeActionValueTransformRotate(serialized[3], condition, serialized[4], serialized[5], amount);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeActionValue = (serialized, manager) => {
        switch (serialized[0]) {
            case EShapeActionValueType.SHOW_HIDE:
                switch (serialized[2]) {
                    case EShapeActionValueShowHideType.SHAPE_SHOW:
                    case EShapeActionValueShowHideType.SHAPE_HIDE:
                        return EShapeActionValueShowHide.deserialize(serialized, manager);
                    case EShapeActionValueShowHideType.SHAPE:
                        return EShapeActionValueShowHideShape.deserialize(serialized, manager);
                    case EShapeActionValueShowHideType.LAYER:
                        return EShapeActionValueShowHideLayer.deserialize(serialized, manager);
                }
                break;
            case EShapeActionValueType.BLINK:
                return EShapeActionValueBlink.deserialize(serialized, manager);
            case EShapeActionValueType.CHANGE_COLOR:
            case EShapeActionValueType.CHANGE_COLOR_LEGACY:
                switch (serialized[3]) {
                    case EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA:
                    case EShapeActionValueChangeColorTarget.COLOR:
                    case EShapeActionValueChangeColorTarget.ALPHA:
                        return EShapeActionValueChangeColor.deserialize(serialized, manager);
                    case EShapeActionValueChangeColorTarget.CODE:
                        return EShapeActionValueChangeColorCode.deserialize(serialized, manager);
                    case EShapeActionValueChangeColorTarget.BRIGHTNESS:
                        return EShapeActionValueChangeColorBrightness.deserialize(serialized, manager);
                }
                break;
            case EShapeActionValueType.CHANGE_TEXT:
                return EShapeActionValueChangeText.deserialize(serialized, manager);
            case EShapeActionValueType.CHANGE_CURSOR:
                return EShapeActionValueChangeCursor.deserialize(serialized, manager);
            case EShapeActionValueType.EMIT_EVENT:
                return EShapeActionValueEmitEvent.deserialize(serialized, manager);
            case EShapeActionValueType.OPEN:
                switch (serialized[2]) {
                    case EShapeActionValueOpenType.DIALOG_TEXT:
                    case EShapeActionValueOpenType.DIALOG_INTEGER:
                    case EShapeActionValueOpenType.DIALOG_REAL:
                    case EShapeActionValueOpenType.DIALOG_BOOLEAN:
                    case EShapeActionValueOpenType.DIALOG_DATE:
                    case EShapeActionValueOpenType.DIALOG_TIME:
                    case EShapeActionValueOpenType.DIALOG_DATETIME:
                    case EShapeActionValueOpenType.DIALOG:
                        if (EShapeActionValueOpenDialogType.EXTENSION <= serialized[6]) {
                            return EShapeActionValueOpenDialogExtension.deserialize(serialized, manager);
                        }
                        return EShapeActionValueOpenDialog.deserialize(serialized, manager);
                    case EShapeActionValueOpenType.DIAGRAM_LEGACY:
                    case EShapeActionValueOpenType.PAGE_LEGACY:
                    case EShapeActionValueOpenType.PAGE_INPLACE_LEGACY:
                    case EShapeActionValueOpenType.DIAGRAM:
                    case EShapeActionValueOpenType.PAGE:
                        return EShapeActionValueOpen.deserialize(serialized, manager);
                    default:
                        if (EShapeActionValueOpenType.EXTENSION <= serialized[2]) {
                            return EShapeActionValueOpenExtension.deserialize(serialized, manager);
                        }
                        break;
                }
                break;
            case EShapeActionValueType.TRANSFORM:
                switch (serialized[2]) {
                    case EShapeActionValueTransformType.MOVE:
                        return EShapeActionValueTransformMove.deserialize(serialized, manager);
                    case EShapeActionValueTransformType.RESIZE:
                        return EShapeActionValueTransformResize.deserialize(serialized, manager);
                    case EShapeActionValueTransformType.ROTATE:
                        return EShapeActionValueTransformRotate.deserialize(serialized, manager);
                }
                break;
            case EShapeActionValueType.GESTURE:
                return EShapeActionValueGesture.deserialize(serialized, manager);
            case EShapeActionValueType.MISC:
                switch (serialized[2]) {
                    case EShapeActionValueMiscType.GESTURE:
                        return EShapeActionValueGesture.deserialize(serialized, manager);
                    case EShapeActionValueMiscType.SHOW_HIDE_LAYER:
                        return EShapeActionValueShowHideLayer.deserialize(serialized, manager);
                    case EShapeActionValueMiscType.GESTURE_LAYER:
                        return EShapeActionValueGesture.deserialize(serialized, manager);
                    case EShapeActionValueMiscType.EXECUTE:
                        return EShapeActionValueMiscExecute.deserialize(serialized, manager);
                    default:
                        if (EShapeActionValueMiscType.EXTENSION <= serialized[2]) {
                            return EShapeActionValueMiscExtension.deserialize(serialized, manager);
                        }
                        else {
                            return EShapeActionValueMisc.deserialize(serialized, manager);
                        }
                }
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EShapeActionValueDeserializers = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toSerialized = (resource) => {
        try {
            const parsed = JSON.parse(resource);
            if (isArray(parsed) && 2 <= parsed.length) {
                return parsed;
            }
            return null;
        }
        catch (e) {
            return null;
        }
    };
    const deserializeActionValues = (indices, manager, result) => {
        const action = result.action;
        const resources = manager.resources;
        for (let i = 0, imax = indices.length; i < imax; ++i) {
            const index = indices[i];
            const saved = manager.getAction(index);
            if (saved != null) {
                action.add(saved);
            }
            else {
                const resource = resources[index];
                if (resource != null) {
                    const serialized = toSerialized(resource);
                    if (serialized != null && 0 < serialized.length) {
                        const type = serialized[0];
                        const deserializer = EShapeActionValueType.EXTENSION <= type
                            ? EShapeActionValueDeserializers[type]
                            : deserializeActionValue;
                        if (deserializer != null) {
                            const deserialized = deserializer(serialized, manager);
                            if (deserialized != null) {
                                manager.setAction(index, deserialized);
                                action.add(deserialized);
                            }
                        }
                    }
                }
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const parse = (target) => {
        try {
            return JSON.parse(target);
        }
        catch (e) {
            return null;
        }
    };
    const toGradientLike = (target) => {
        const parsed = parse(target);
        if (parsed == null || parsed.length < 7) {
            return undefined;
        }
        else {
            const direction = parsed[0];
            const points = [];
            for (let i = 1, imax = parsed.length; i < imax; i += 3) {
                points.push({
                    color: parsed[i + 0],
                    alpha: parsed[i + 1],
                    position: parsed[i + 2]
                });
            }
            return {
                points,
                direction
            };
        }
    };
    const deserializeGradient = (index, manager, result) => {
        const resources = manager.resources;
        if (0 <= index && index < resources.length) {
            const serialized = resources[index];
            if (isString(serialized)) {
                result.gradient = toGradientLike(serialized);
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const imageElementCache = {};
    const toImageElement = (dataUrl) => {
        const cachedImageElement = imageElementCache[dataUrl];
        if (cachedImageElement != null) {
            if ("url" in cachedImageElement) {
                return Promise.resolve(cachedImageElement);
            }
            else {
                return cachedImageElement;
            }
        }
        else {
            const result = new Promise((resolve, reject) => {
                const imageElement = document.createElement("img");
                imageElement.onload = () => {
                    const resolved = {
                        url: dataUrl,
                        width: imageElement.width,
                        height: imageElement.height,
                        source: imageElement
                    };
                    imageElementCache[dataUrl] = resolved;
                    resolve(resolved);
                };
                imageElement.onabort = imageElement.onerror = () => {
                    reject();
                };
                imageElement.src = dataUrl;
            });
            imageElementCache[dataUrl] = result;
            return result;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeChildren = (serializeds, manager, result) => {
        if (0 < serializeds.length) {
            const deserializeds = [];
            for (let i = 0, imax = serializeds.length; i < imax; ++i) {
                deserializeds.push(deserialize(serializeds[i], manager));
            }
            return Promise.all(deserializeds).then((children) => {
                result.children = children;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    children[i].parent = result;
                }
                result.onChildTransformChange();
                result.toDirty();
                return result;
            });
        }
        return null;
    };
    const deserializeImage$1 = (index, manager, result) => {
        const resources = manager.resources;
        if (0 <= index && index < resources.length) {
            const imageSrc = resources[index];
            if (isString(imageSrc)) {
                return toImageElement(imageSrc).then((imageElement) => {
                    result.image = imageElement;
                    return result;
                });
            }
        }
        return null;
    };
    const deserializeBase = (item, manager, result) => {
        const resources = manager.resources;
        result.id = resources[item[1]] || "";
        const transform = result.transform;
        transform.position.set(item[2], item[3]);
        transform.rotation = item[6];
        transform.skew.set(item[7], item[7]);
        transform.pivot.set(item[21], item[22]);
        result.size.set(toSizeNormalized(item[4]), toSizeNormalized(item[5]));
        result.fill.deserialize(item[8], manager);
        result.stroke.deserialize(item[9], manager);
        const item10 = item[10];
        result.cursor = 0 <= item10 ? resources[item10] : undefined;
        result.text.deserialize(item[11], manager);
        result.data.deserialize(item[12], manager);
        result.radius = item[13];
        result.corner = item[14];
        const item23 = item[23];
        result.interactive = !!(item23 & 1);
        const state = result.state;
        state.isFocusable = !(item23 & 2);
        state.isActive = !!(item23 & 4);
        const item24 = item[24];
        result.shortcut = 0 <= item24 ? resources[item24] : undefined;
        const item25 = item[25];
        result.title = 0 <= item25 ? resources[item25] : undefined;
        const item26 = item[26];
        result.uuid = item26 != null ? item26 : 0;
        const item27 = item[27];
        const item28 = item[28];
        const item29 = item[29];
        const hasItem27 = item27 != null && item27 !== EShapeCapability.NONE;
        const hasItem28 = item28 != null && item28 !== EShapeCapability.NONE;
        const hasItem29 = item29 != null && item29 !== EShapeCapability.NONE;
        if (hasItem27 || hasItem28 || hasItem29) {
            result.capability.set(item27, item28, item29);
        }
        const children = deserializeChildren(item[20], manager, result);
        deserializeActionValues(item[17], manager, result);
        deserializeGradient(item[19], manager, result);
        const image = deserializeImage$1(item[18], manager, result);
        if (children != null) {
            if (image != null) {
                return Promise.all([children, image]).then(() => {
                    return result;
                });
            }
            else {
                return children;
            }
        }
        else {
            if (image != null) {
                return image;
            }
            else {
                return result;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeBar = (item, manager, shape) => {
        shape = shape || new EShapeBar();
        const result = deserializeBase(item, manager, shape);
        shape.points.deserialize(item[15], manager);
        const style = shape.points.style;
        const mask = EShapePointsStyle.NON_SCALING_MASK |
            EShapePointsStyle.DOTTED_MASK |
            EShapePointsStyle.DASHED_MASK;
        const deprecated = style & mask;
        if (deprecated) {
            shape.points.style &= ~mask;
            shape.stroke.style |= deprecated;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeBar = () => {
        EShapeUploadeds[EShapeType.BAR] = createBarUploaded;
        EShapeDeserializers[EShapeType.BAR] = deserializeBar;
    };

    const RECTANGLE_ROUNDED_VERTEX_COUNT = 44;
    const RECTANGLE_ROUNDED_INDEX_COUNT = 24;
    const RECTANGLE_ROUNDED_WORLD_SIZE = [
        0, 0, 0, 0, 0
    ];
    const RECTANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    const buildRectangleRoundedIndex = (indices, voffset, ioffset) => {
        // c0   c1        c4   c5
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        // c2   c3        c6   c7
        //
        // c8   c9       c12   c13
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        //c10   c11      c14   c15
        let ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 15;
        //     16  17  23  24
        //      |---|  |---|
        //      |   |  |   |
        // 18--19--20  25--26--27
        //  |       |  |       |
        //  |       |  |       |
        // 21------22  28------29
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 22;
        indices[++ii] = voffset + 23;
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 24;
        indices[++ii] = voffset + 26;
        indices[++ii] = voffset + 25;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 28;
        indices[++ii] = voffset + 28;
        indices[++ii] = voffset + 27;
        indices[++ii] = voffset + 29;
        // 30------31  37------38
        //  |       |  |       |
        //  |       |  |       |
        // 32--33--34  39--40--41
        //      |   |  |   |
        //      |---|  |---|
        //     35  36  42  43
        indices[++ii] = voffset + 30;
        indices[++ii] = voffset + 31;
        indices[++ii] = voffset + 32;
        indices[++ii] = voffset + 32;
        indices[++ii] = voffset + 31;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 33;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 35;
        indices[++ii] = voffset + 35;
        indices[++ii] = voffset + 34;
        indices[++ii] = voffset + 36;
        indices[++ii] = voffset + 37;
        indices[++ii] = voffset + 38;
        indices[++ii] = voffset + 39;
        indices[++ii] = voffset + 39;
        indices[++ii] = voffset + 38;
        indices[++ii] = voffset + 41;
        indices[++ii] = voffset + 39;
        indices[++ii] = voffset + 40;
        indices[++ii] = voffset + 42;
        indices[++ii] = voffset + 42;
        indices[++ii] = voffset + 40;
        indices[++ii] = voffset + 43;
    };
    const buildRectangleRoundedVertex = (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) => {
        // b0      b1      b2
        // |-------|-------|
        // |       |       |
        // b3------b4------b5
        // |       |       |
        // |-------|-------|
        // b6      b7      b8
        const s = strokeAlign * strokeWidth;
        const sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        const sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        const ax = Math.abs(sx);
        const ay = Math.abs(sy);
        const a = radius * Math.min(ax, ay);
        const rx = a / ax;
        const ry = a / ay;
        const work = RECTANGLE_ROUNDED_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        const b0x = work.x;
        const b0y = work.y;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        const b1x = work.x;
        const b1y = work.y;
        work.set(originX - sx, originY);
        internalTransform.apply(work, work);
        const b3x = work.x;
        const b3y = work.y;
        const d01x = b1x - b0x;
        const d01y = b1y - b0y;
        const d03x = b3x - b0x;
        const d03y = b3y - b0y;
        const b2x = b1x + d01x;
        const b2y = b1y + d01y;
        const b4x = b3x + d01x;
        const b4y = b3y + d01y;
        const b5x = b2x + d03x;
        const b5y = b2y + d03y;
        const b6x = b3x + d03x;
        const b6y = b3y + d03y;
        const b7x = b6x + d01x;
        const b7y = b6y + d01y;
        const b8x = b7x + d01x;
        const b8y = b7y + d01y;
        const r01x = rx * d01x;
        const r01y = rx * d01y;
        const r03x = ry * d03x;
        const r03y = ry * d03y;
        // c0   c1        c4   c5
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        // c2   c3        c6   c7
        //
        // c8   c9       c12   c13
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        //c10   c11      c14   c15
        const c0x = b0x;
        const c0y = b0y;
        const c1x = c0x + r01x;
        const c1y = c0y + r01y;
        const c2x = c0x + r03x;
        const c2y = c0y + r03y;
        const c3x = c2x + r01x;
        const c3y = c2y + r01y;
        let iv = voffset * 2 - 1;
        vertices[++iv] = c0x;
        vertices[++iv] = c0y;
        vertices[++iv] = c1x;
        vertices[++iv] = c1y;
        vertices[++iv] = c2x;
        vertices[++iv] = c2y;
        vertices[++iv] = c3x;
        vertices[++iv] = c3y;
        const c5x = b2x;
        const c5y = b2y;
        const c4x = b2x - r01x;
        const c4y = b2y - r01y;
        const c6x = c4x + r03x;
        const c6y = c4y + r03y;
        const c7x = c6x + r01x;
        const c7y = c6y + r01y;
        vertices[++iv] = c4x;
        vertices[++iv] = c4y;
        vertices[++iv] = c5x;
        vertices[++iv] = c5y;
        vertices[++iv] = c6x;
        vertices[++iv] = c6y;
        vertices[++iv] = c7x;
        vertices[++iv] = c7y;
        const c10x = b6x;
        const c10y = b6y;
        const c8x = c10x - r03x;
        const c8y = c10y - r03y;
        const c11x = c10x + r01x;
        const c11y = c10y + r01y;
        const c9x = c8x + r01x;
        const c9y = c8y + r01y;
        vertices[++iv] = c8x;
        vertices[++iv] = c8y;
        vertices[++iv] = c9x;
        vertices[++iv] = c9y;
        vertices[++iv] = c10x;
        vertices[++iv] = c10y;
        vertices[++iv] = c11x;
        vertices[++iv] = c11y;
        const c15x = b8x;
        const c15y = b8y;
        const c14x = c15x - r01x;
        const c14y = c15y - r01y;
        const c13x = c15x - r03x;
        const c13y = c15y - r03y;
        const c12x = c13x - r01x;
        const c12y = c13y - r01y;
        vertices[++iv] = c12x;
        vertices[++iv] = c12y;
        vertices[++iv] = c13x;
        vertices[++iv] = c13y;
        vertices[++iv] = c14x;
        vertices[++iv] = c14y;
        vertices[++iv] = c15x;
        vertices[++iv] = c15y;
        //     16  17  23  24
        //      |---|  |---|
        //      |   |  |   |
        // 18--19--20  25--26--27
        //  |       |  |       |
        //  |       |  |       |
        // 21------22  28------29
        const c16x = c1x;
        const c16y = c1y;
        const c17x = b1x;
        const c17y = b1y;
        const c18x = c2x;
        const c18y = c2y;
        const c19x = c3x;
        const c19y = c3y;
        const c20x = c17x + r03x;
        const c20y = c17y + r03y;
        const c21x = b3x;
        const c21y = b3y;
        const c22x = b4x;
        const c22y = b4y;
        vertices[++iv] = c16x;
        vertices[++iv] = c16y;
        vertices[++iv] = c17x;
        vertices[++iv] = c17y;
        vertices[++iv] = c18x;
        vertices[++iv] = c18y;
        vertices[++iv] = c19x;
        vertices[++iv] = c19y;
        vertices[++iv] = c20x;
        vertices[++iv] = c20y;
        vertices[++iv] = c21x;
        vertices[++iv] = c21y;
        vertices[++iv] = c22x;
        vertices[++iv] = c22y;
        const c23x = c17x;
        const c23y = c17y;
        const c24x = c4x;
        const c24y = c4y;
        const c25x = c20x;
        const c25y = c20y;
        const c26x = c6x;
        const c26y = c6y;
        const c27x = c7x;
        const c27y = c7y;
        const c28x = c22x;
        const c28y = c22y;
        const c29x = b5x;
        const c29y = b5y;
        vertices[++iv] = c23x;
        vertices[++iv] = c23y;
        vertices[++iv] = c24x;
        vertices[++iv] = c24y;
        vertices[++iv] = c25x;
        vertices[++iv] = c25y;
        vertices[++iv] = c26x;
        vertices[++iv] = c26y;
        vertices[++iv] = c27x;
        vertices[++iv] = c27y;
        vertices[++iv] = c28x;
        vertices[++iv] = c28y;
        vertices[++iv] = c29x;
        vertices[++iv] = c29y;
        // 30------31  37------38
        //  |       |  |       |
        //  |       |  |       |
        // 32--33--34  39--40--41
        //      |   |  |   |
        //      |---|  |---|
        //     35  36  42  43
        const c30x = c21x;
        const c30y = c21y;
        const c31x = c22x;
        const c31y = c22y;
        const c32x = c8x;
        const c32y = c8y;
        const c33x = c9x;
        const c33y = c9y;
        const c34x = b7x - r03x;
        const c34y = b7y - r03y;
        const c35x = c11x;
        const c35y = c11y;
        const c36x = b7x;
        const c36y = b7y;
        vertices[++iv] = c30x;
        vertices[++iv] = c30y;
        vertices[++iv] = c31x;
        vertices[++iv] = c31y;
        vertices[++iv] = c32x;
        vertices[++iv] = c32y;
        vertices[++iv] = c33x;
        vertices[++iv] = c33y;
        vertices[++iv] = c34x;
        vertices[++iv] = c34y;
        vertices[++iv] = c35x;
        vertices[++iv] = c35y;
        vertices[++iv] = c36x;
        vertices[++iv] = c36y;
        const c37x = c31x;
        const c37y = c31y;
        const c38x = c29x;
        const c38y = c29y;
        const c39x = c34x;
        const c39y = c34y;
        const c40x = c12x;
        const c40y = c12y;
        const c41x = c13x;
        const c41y = c13y;
        const c42x = c36x;
        const c42y = c36y;
        const c43x = c14x;
        const c43y = c14y;
        vertices[++iv] = c37x;
        vertices[++iv] = c37y;
        vertices[++iv] = c38x;
        vertices[++iv] = c38y;
        vertices[++iv] = c39x;
        vertices[++iv] = c39y;
        vertices[++iv] = c40x;
        vertices[++iv] = c40y;
        vertices[++iv] = c41x;
        vertices[++iv] = c41y;
        vertices[++iv] = c42x;
        vertices[++iv] = c42y;
        vertices[++iv] = c43x;
        vertices[++iv] = c43y;
        // World size
        worldSize[0] = ax;
        worldSize[1] = ay;
        worldSize[2] = a;
        worldSize[3] = rx;
        worldSize[4] = ry;
    };
    const buildRectangleRoundedStep = (steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, worldSize) => {
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const ax = worldSize[0];
        const ay = worldSize[1];
        const a = worldSize[2];
        const wt = strokeSide & EShapeStrokeSide.TOP ? 1 : 0;
        const wr = strokeSide & EShapeStrokeSide.RIGHT ? 1 : 0;
        const wb = strokeSide & EShapeStrokeSide.BOTTOM ? 1 : 0;
        const wl = strokeSide & EShapeStrokeSide.LEFT ? 1 : 0;
        const elt0 = toPackedI4x64(0, scaleInvariant, wl, wt);
        const ert0 = toPackedI4x64(0, scaleInvariant, wr, wt);
        const elb0 = toPackedI4x64(0, scaleInvariant, wl, wb);
        const erb0 = toPackedI4x64(0, scaleInvariant, wr, wb);
        const elt1 = toPackedI4x64(1, scaleInvariant, wl, wt);
        const ert1 = toPackedI4x64(1, scaleInvariant, wr, wt);
        const elb1 = toPackedI4x64(1, scaleInvariant, wl, wb);
        const erb1 = toPackedI4x64(1, scaleInvariant, wr, wb);
        const rxi = 1 - worldSize[3];
        const ryi = 1 - worldSize[4];
        const c11 = toPackedF2x1024(1, 1);
        const c01 = toPackedF2x1024(0, 1);
        const c10 = toPackedF2x1024(1, 0);
        const c00 = toPackedF2x1024(0, 0);
        const cx1 = toPackedF2x1024(rxi, 1);
        const c1y = toPackedF2x1024(1, ryi);
        const cxy = toPackedF2x1024(rxi, ryi);
        const c0y = toPackedF2x1024(0, ryi);
        // c0   c1        c4   c5
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        // c2   c3        c6   c7
        //
        // c8   c9       c12   c13
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        //c10   c11      c14   c15
        let is = voffset * 6 - 1;
        if (corner & EShapeCorner.TOP_LEFT) {
            steps[++is] = strokeWidth;
            steps[++is] = elt1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c01;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c10;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c00;
            steps[++is] = 0;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = elt0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cx1;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c1y;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elt0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cxy;
            steps[++is] = 0;
        }
        if (corner & EShapeCorner.TOP_RIGHT) {
            steps[++is] = strokeWidth;
            steps[++is] = ert1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c01;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c00;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c10;
            steps[++is] = 0;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = ert0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cx1;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cxy;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = ert0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c1y;
            steps[++is] = 0;
        }
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            steps[++is] = strokeWidth;
            steps[++is] = elb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c10;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c00;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c01;
            steps[++is] = 0;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = elb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c1y;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cxy;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c11;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = elb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cx1;
            steps[++is] = 0;
        }
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            steps[++is] = strokeWidth;
            steps[++is] = erb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c00;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c10;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c01;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb1;
            steps[++is] = a;
            steps[++is] = a;
            steps[++is] = c11;
            steps[++is] = 0;
        }
        else {
            steps[++is] = strokeWidth;
            steps[++is] = erb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cxy;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c1y;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = cx1;
            steps[++is] = 0;
            steps[++is] = strokeWidth;
            steps[++is] = erb0;
            steps[++is] = ax;
            steps[++is] = ay;
            steps[++is] = c11;
            steps[++is] = 0;
        }
        //     16  17  23  24
        //      |---|  |---|
        //      |   |  |   |
        // 18--19--20  25--26--27
        //  |       |  |       |
        //  |       |  |       |
        // 21------22  28------29
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cx1;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c1y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cxy;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c0y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cx1;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c0y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cxy;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c1y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        // 30------31  37------38
        //  |       |  |       |
        //  |       |  |       |
        // 32--33--34  39--40--41
        //      |   |  |   |
        //      |---|  |---|
        //     35  36  42  43
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c1y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cxy;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c0y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cx1;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c0y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cxy;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c1y;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb0;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = cx1;
        steps[++is] = 0;
    };
    const buildRectangleRoundedUv = (uvs, voffset, textureUvs, worldSize) => {
        // b0      b1      b2
        // |-------|-------|
        // |       |       |
        // b3------b4------b5
        // |       |       |
        // |-------|-------|
        // b6      b7      b8
        const b0x = textureUvs.x0;
        const b0y = textureUvs.y0;
        const b2x = textureUvs.x1;
        const b2y = textureUvs.y1;
        const b8x = textureUvs.x2;
        const b8y = textureUvs.y2;
        const b6x = textureUvs.x3;
        const b6y = textureUvs.y3;
        const b1x = (b0x + b2x) * 0.5;
        const b1y = (b0y + b2y) * 0.5;
        const b3x = (b0x + b6x) * 0.5;
        const b3y = (b0y + b6y) * 0.5;
        const d01x = b1x - b0x;
        const d01y = b1y - b0y;
        const d03x = b3x - b0x;
        const d03y = b3y - b0y;
        const b4x = b3x + d01x;
        const b4y = b3y + d01y;
        const b5x = b2x + d03x;
        const b5y = b2y + d03y;
        const b7x = b6x + d01x;
        const b7y = b6y + d01y;
        const rx = worldSize[3];
        const ry = worldSize[4];
        const r01x = rx * d01x;
        const r01y = rx * d01y;
        const r03x = ry * d03x;
        const r03y = ry * d03y;
        // c0   c1        c4   c5
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        // c2   c3        c6   c7
        //
        // c8   c9       c12   c13
        //  |---|          |---|
        //  |   |          |   |
        //  |---|          |---|
        //c10   c11      c14   c15
        const c0x = b0x;
        const c0y = b0y;
        const c1x = c0x + r01x;
        const c1y = c0y + r01y;
        const c2x = c0x + r03x;
        const c2y = c0y + r03y;
        const c3x = c2x + r01x;
        const c3y = c2y + r01y;
        let iuv = voffset * 2 - 1;
        uvs[++iuv] = c0x;
        uvs[++iuv] = c0y;
        uvs[++iuv] = c1x;
        uvs[++iuv] = c1y;
        uvs[++iuv] = c2x;
        uvs[++iuv] = c2y;
        uvs[++iuv] = c3x;
        uvs[++iuv] = c3y;
        const c5x = b2x;
        const c5y = b2y;
        const c4x = b2x - r01x;
        const c4y = b2y - r01y;
        const c6x = c4x + r03x;
        const c6y = c4y + r03y;
        const c7x = c6x + r01x;
        const c7y = c6y + r01y;
        uvs[++iuv] = c4x;
        uvs[++iuv] = c4y;
        uvs[++iuv] = c5x;
        uvs[++iuv] = c5y;
        uvs[++iuv] = c6x;
        uvs[++iuv] = c6y;
        uvs[++iuv] = c7x;
        uvs[++iuv] = c7y;
        const c10x = b6x;
        const c10y = b6y;
        const c8x = c10x - r03x;
        const c8y = c10y - r03y;
        const c11x = c10x + r01x;
        const c11y = c10y + r01y;
        const c9x = c8x + r01x;
        const c9y = c8y + r01y;
        uvs[++iuv] = c8x;
        uvs[++iuv] = c8y;
        uvs[++iuv] = c9x;
        uvs[++iuv] = c9y;
        uvs[++iuv] = c10x;
        uvs[++iuv] = c10y;
        uvs[++iuv] = c11x;
        uvs[++iuv] = c11y;
        const c15x = b8x;
        const c15y = b8y;
        const c14x = c15x - r01x;
        const c14y = c15y - r01y;
        const c13x = c15x - r03x;
        const c13y = c15y - r03y;
        const c12x = c13x - r01x;
        const c12y = c13y - r01y;
        uvs[++iuv] = c12x;
        uvs[++iuv] = c12y;
        uvs[++iuv] = c13x;
        uvs[++iuv] = c13y;
        uvs[++iuv] = c14x;
        uvs[++iuv] = c14y;
        uvs[++iuv] = c15x;
        uvs[++iuv] = c15y;
        //     16  17  23  24
        //      |---|  |---|
        //      |   |  |   |
        // 18--19--20  25--26--27
        //  |       |  |       |
        //  |       |  |       |
        // 21------22  28------29
        const c16x = c1x;
        const c16y = c1y;
        const c17x = b1x;
        const c17y = b1y;
        const c18x = c2x;
        const c18y = c2y;
        const c19x = c3x;
        const c19y = c3y;
        const c20x = c17x + r03x;
        const c20y = c17y + r03y;
        const c21x = b3x;
        const c21y = b3y;
        const c22x = b4x;
        const c22y = b4y;
        uvs[++iuv] = c16x;
        uvs[++iuv] = c16y;
        uvs[++iuv] = c17x;
        uvs[++iuv] = c17y;
        uvs[++iuv] = c18x;
        uvs[++iuv] = c18y;
        uvs[++iuv] = c19x;
        uvs[++iuv] = c19y;
        uvs[++iuv] = c20x;
        uvs[++iuv] = c20y;
        uvs[++iuv] = c21x;
        uvs[++iuv] = c21y;
        uvs[++iuv] = c22x;
        uvs[++iuv] = c22y;
        const c23x = c17x;
        const c23y = c17y;
        const c24x = c4x;
        const c24y = c4y;
        const c25x = c20x;
        const c25y = c20y;
        const c26x = c6x;
        const c26y = c6y;
        const c27x = c7x;
        const c27y = c7y;
        const c28x = c22x;
        const c28y = c22y;
        const c29x = b5x;
        const c29y = b5y;
        uvs[++iuv] = c23x;
        uvs[++iuv] = c23y;
        uvs[++iuv] = c24x;
        uvs[++iuv] = c24y;
        uvs[++iuv] = c25x;
        uvs[++iuv] = c25y;
        uvs[++iuv] = c26x;
        uvs[++iuv] = c26y;
        uvs[++iuv] = c27x;
        uvs[++iuv] = c27y;
        uvs[++iuv] = c28x;
        uvs[++iuv] = c28y;
        uvs[++iuv] = c29x;
        uvs[++iuv] = c29y;
        // 30------31  37------38
        //  |       |  |       |
        //  |       |  |       |
        // 32--33--34  39--40--41
        //      |   |  |   |
        //      |---|  |---|
        //     35  36  42  43
        const c30x = c21x;
        const c30y = c21y;
        const c31x = c22x;
        const c31y = c22y;
        const c32x = c8x;
        const c32y = c8y;
        const c33x = c9x;
        const c33y = c9y;
        const c34x = b7x - r03x;
        const c34y = b7y - r03y;
        const c35x = c11x;
        const c35y = c11y;
        const c36x = b7x;
        const c36y = b7y;
        uvs[++iuv] = c30x;
        uvs[++iuv] = c30y;
        uvs[++iuv] = c31x;
        uvs[++iuv] = c31y;
        uvs[++iuv] = c32x;
        uvs[++iuv] = c32y;
        uvs[++iuv] = c33x;
        uvs[++iuv] = c33y;
        uvs[++iuv] = c34x;
        uvs[++iuv] = c34y;
        uvs[++iuv] = c35x;
        uvs[++iuv] = c35y;
        uvs[++iuv] = c36x;
        uvs[++iuv] = c36y;
        const c37x = c31x;
        const c37y = c31y;
        const c38x = c29x;
        const c38y = c29y;
        const c39x = c34x;
        const c39y = c34y;
        const c40x = c12x;
        const c40y = c12y;
        const c41x = c13x;
        const c41y = c13y;
        const c42x = c36x;
        const c42y = c36y;
        const c43x = c14x;
        const c43y = c14y;
        uvs[++iuv] = c37x;
        uvs[++iuv] = c37y;
        uvs[++iuv] = c38x;
        uvs[++iuv] = c38y;
        uvs[++iuv] = c39x;
        uvs[++iuv] = c39y;
        uvs[++iuv] = c40x;
        uvs[++iuv] = c40y;
        uvs[++iuv] = c41x;
        uvs[++iuv] = c41y;
        uvs[++iuv] = c42x;
        uvs[++iuv] = c42y;
        uvs[++iuv] = c43x;
        uvs[++iuv] = c43y;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderRectangleRounded extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, RECTANGLE_ROUNDED_VERTEX_COUNT, RECTANGLE_ROUNDED_INDEX_COUNT);
            this.radius = 0;
            this.corner = 0;
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        }
        updateVertexStepAndUv(buffer, shape) {
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const radius = shape.radius;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeSide = stroke.side;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            const corner = shape.corner;
            const isCornerChanged = corner !== this.corner;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isSizeChanged || isStrokeChanged;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isCornerChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                const voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                // Steps
                if (isNotInited || isVertexChanged || isCornerChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleRoundedStep(buffer.steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                }
                // UVs
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleRoundedUv(buffer.uvs, voffset, toTextureUvs(texture), RECTANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createRectangleRoundedUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = RECTANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        const icount = RECTANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderRectangleRounded(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset + RECTANGLE_ROUNDED_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createButtonUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        return createRectangleRoundedUploaded(buffer, shape, voffset, ioffset, antialiasWeight);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const hitTestRectangleRounded_ = (x, y, ax, ay, r, corner) => {
        const bx0 = -ax + r;
        if (x <= bx0) {
            const by0 = -ay + r;
            if (y <= by0 && corner & EShapeCorner.TOP_LEFT) {
                // Top-left corner
                const dx = x - bx0;
                const dy = y - by0;
                return dx * dx + dy * dy <= r * r;
            }
            else {
                const by1 = +ay - r;
                if (by1 <= y && corner & EShapeCorner.BOTTOM_LEFT) {
                    // Bottom-left corner
                    const dx = x - bx0;
                    const dy = y - by1;
                    return dx * dx + dy * dy <= r * r;
                }
                else {
                    // Middle-left box
                    return -ax <= x;
                }
            }
        }
        else {
            const bx1 = +ax - r;
            if (bx1 <= x) {
                const by0 = -ay + r;
                if (y <= by0 && corner & EShapeCorner.TOP_RIGHT) {
                    // Top-right corner
                    const dx = x - bx1;
                    const dy = y - by0;
                    return dx * dx + dy * dy <= r * r;
                }
                else {
                    const by1 = +ay - r;
                    if (by1 <= y && corner & EShapeCorner.BOTTOM_RIGHT) {
                        // Bottom-right corner
                        const dx = x - bx1;
                        const dy = y - by1;
                        return dx * dx + dy * dy <= r * r;
                    }
                    else {
                        // Middle-right box
                        return x <= +ax;
                    }
                }
            }
            else {
                return -ay <= y && y <= +ay;
            }
        }
    };
    const hitTestRectangleRounded = (shape, x, y, ax, ay, sw, ss) => {
        const fill = shape.fill;
        if (fill.enable || 0 < sw) {
            const r = shape.radius * Math.min(ax, ay);
            const corner = shape.corner;
            if (hitTestRectangleRounded_(x, y, ax, ay, r, corner)) {
                if (fill.enable) {
                    return true;
                }
                else {
                    const s = sw * ss;
                    const wx = Math.max(0.0, ax - s);
                    const wy = Math.max(0.0, ay - s);
                    const wr = Math.max(0.0, r - s);
                    if (!hitTestRectangleRounded_(x, y, wx, wy, wr, corner)) {
                        const strokeSide = shape.stroke.side;
                        if (strokeSide === EShapeStrokeSide.ALL) {
                            return true;
                        }
                        else {
                            if (x <= -wx + wr) {
                                const hasLeftSide = !!(strokeSide & EShapeStrokeSide.LEFT);
                                if (y <= -wy + wr) {
                                    const hasTopSide = !!(strokeSide & EShapeStrokeSide.TOP);
                                    if (hasTopSide && hasLeftSide) {
                                        return true;
                                    }
                                    else if (hasTopSide) {
                                        return -wx <= y;
                                    }
                                    else if (hasLeftSide) {
                                        return x <= -wx;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else if (+wy - wr <= y) {
                                    const hasBottomSide = !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                    if (hasBottomSide && hasLeftSide) {
                                        return true;
                                    }
                                    else if (hasBottomSide) {
                                        return +wx <= y;
                                    }
                                    else if (hasLeftSide) {
                                        return x <= -wx;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else {
                                    return hasLeftSide;
                                }
                            }
                            else if (+wx - wr <= x) {
                                const hasRightSide = !!(strokeSide & EShapeStrokeSide.RIGHT);
                                if (y <= -wy + wr) {
                                    const hasTopSide = !!(strokeSide & EShapeStrokeSide.TOP);
                                    if (hasTopSide && hasRightSide) {
                                        return true;
                                    }
                                    else if (hasTopSide) {
                                        return -wx <= y;
                                    }
                                    else if (hasRightSide) {
                                        return +wx <= x;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else if (+wy - wr <= y) {
                                    const hasBottomSide = !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                    if (hasBottomSide && hasRightSide) {
                                        return true;
                                    }
                                    else if (hasBottomSide) {
                                        return +wx <= y;
                                    }
                                    else if (hasRightSide) {
                                        return +wx <= x;
                                    }
                                    else {
                                        return false;
                                    }
                                }
                                else {
                                    return hasRightSide;
                                }
                            }
                            else {
                                if (y <= -wy + wr) {
                                    return !!(strokeSide & EShapeStrokeSide.TOP);
                                }
                                else if (+wy - wr <= y) {
                                    return !!(strokeSide & EShapeStrokeSide.BOTTOM);
                                }
                                else {
                                    return false;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeRectangleRounded extends EShapePrimitive {
        constructor(type = EShapeType.RECTANGLE_ROUNDED) {
            super(type);
        }
        clone() {
            return new EShapeRectangleRounded(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            if (super.containsAbsBBox(x, y, ax, ay)) {
                return hitTestRectangleRounded(this, x, y, ax, ay, sw, ss);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeButton extends EShapeRectangleRounded {
        constructor(type = EShapeType.BUTTON) {
            super(type);
            this._isToggle = false;
            this._isGrouped = false;
        }
        get isToggle() {
            return this._isToggle;
        }
        set isToggle(isToggle) {
            this._isToggle = isToggle;
        }
        /**
         * All the sibling buttons whose `isGrouped` is true is considered to to be grouped.
         */
        get isGrouped() {
            return this._isGrouped;
        }
        set isGrouped(isGrouped) {
            this._isGrouped = isGrouped;
        }
        copy(source, part) {
            super.copy(source, part);
            if (source instanceof EShapeButton) {
                this._isToggle = source.isToggle;
                this._isGrouped = source.isGrouped;
            }
            return this;
        }
        clone() {
            return new EShapeButton(this.type).copy(this);
        }
        serialize(manager) {
            const result = super.serialize(manager);
            const isToggle = this._isToggle ? 1 : 0;
            const isGrouped = this._isGrouped ? 2 : 0;
            result[15] = manager.addResource(`[${isToggle | isGrouped}]`);
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeButton = (item, manager, shape) => {
        shape = shape || new EShapeButton();
        const resources = manager.resources;
        const resourceId = item[15];
        if (0 <= resourceId && resourceId < resources.length) {
            let parsed = manager.getExtension(resourceId);
            if (parsed == null) {
                parsed = JSON.parse(resources[resourceId]);
                manager.setExtension(resourceId, parsed);
            }
            shape.isToggle = !!(parsed[0] & 1);
            shape.isGrouped = !!(parsed[0] & 2);
        }
        return deserializeBase(item, manager, shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeButtonRuntimeAction extends EShapeActionRuntimeBase {
        constructor(runtime) {
            super(EShapeRuntimeReset.COLOR_FILL_AND_STROKE |
                EShapeRuntimeReset.COLOR_TEXT |
                EShapeRuntimeReset.COLOR_TEXT_OUTLINE |
                EShapeRuntimeReset.CURSOR);
            const fill = runtime.fill;
            const fillColor = fill.color;
            const fillColorOnHovered = this.toOnHovered(fillColor);
            const fillColorOnPressed = fillColorOnHovered * 2;
            this._fillColor = fillColor;
            this._fillColorDisabled = UtilRgb.toGrayscale(fillColor);
            this._fillColorPressed = UtilRgb.darken(fillColor, fillColorOnPressed);
            this._fillColorHovered = UtilRgb.darken(fillColor, fillColorOnHovered);
            const fillAlpha = fill.alpha;
            this._fillAlpha = fillAlpha;
            this._fillAlphaDisabled = fillAlpha * 0.5;
            const stroke = runtime.stroke;
            const strokeColor = stroke.color;
            const strokeColorOnHovered = this.toOnHovered(strokeColor);
            const strokeColorOnPressed = strokeColorOnHovered * 2;
            this._strokeColor = strokeColor;
            this._strokeColorDisabled = UtilRgb.toGrayscale(strokeColor);
            this._strokeColorPressed = UtilRgb.darken(strokeColor, strokeColorOnPressed);
            this._strokeColorHovered = UtilRgb.darken(strokeColor, strokeColorOnHovered);
            const strokeAlpha = stroke.alpha;
            this._strokeAlpha = strokeAlpha;
            this._strokeAlphaDisabled = strokeAlpha * 0.5;
            const text = runtime.text;
            const textColor = text.color;
            this._textColor = textColor;
            this._textColorDisabled = UtilRgb.toGrayscale(textColor);
            const textAlpha = text.alpha;
            this._textAlpha = textAlpha;
            this._textAlphaDisabled = textAlpha * 0.5;
            const textOutline = text.outline;
            const textOutlineColor = textOutline.color;
            this._textOutlineColor = textOutlineColor;
            this._textOutlineColorDisabled = UtilRgb.toGrayscale(textOutlineColor);
            const textOutlineAlpha = textOutline.alpha;
            this._textOutlineAlpha = textOutlineAlpha;
            this._textOutlineAlphaDisabled = textOutlineAlpha * 0.5;
        }
        toOnHovered(color) {
            const luma = UtilRgb.toLuma(color);
            if (128 <= luma) {
                const t = (luma - 128) / 127;
                return +0.15 * (1 - t) + t * 0.03;
            }
            else {
                const t = (127 - luma) / 127;
                return -0.15 * (1 - t) - t * 0.175;
            }
        }
        execute(shape, runtime, time) {
            const state = shape.state;
            shape.fill.set(undefined, this.getFillColor(state), this.getFillAlpha(state));
            shape.stroke.set(undefined, this.getStrokeColor(state), this.getStrokeAlpha(state));
            shape.text.set(undefined, this.getTextColor(state), this.getTextAlpha(state));
            shape.text.outline.set(undefined, this.getTextOutlineColor(state), this.getTextOutlineAlpha(state));
            shape.cursor = this.getCursor(state);
            runtime.written |= this.reset;
        }
        getFillColor(state) {
            if (state.inDisabled) {
                return this._fillColorDisabled;
            }
            else if (state.isPressed || state.isActive) {
                return this._fillColorPressed;
            }
            else if (state.isFocused || state.isHovered) {
                return this._fillColorHovered;
            }
            else {
                return this._fillColor;
            }
        }
        getFillAlpha(state) {
            if (state.inDisabled) {
                return this._fillAlphaDisabled;
            }
            else {
                return this._fillAlpha;
            }
        }
        getStrokeColor(state) {
            if (state.inDisabled) {
                return this._strokeColorDisabled;
            }
            else if (state.isPressed || state.isActive) {
                return this._strokeColorPressed;
            }
            else if (state.isFocused || state.isHovered) {
                return this._strokeColorHovered;
            }
            else {
                return this._strokeColor;
            }
        }
        getStrokeAlpha(state) {
            if (state.inDisabled) {
                return this._strokeAlphaDisabled;
            }
            else {
                return this._strokeAlpha;
            }
        }
        getTextColor(state) {
            if (state.inDisabled) {
                return this._textColorDisabled;
            }
            else {
                return this._textColor;
            }
        }
        getTextAlpha(state) {
            if (state.inDisabled) {
                return this._textAlphaDisabled;
            }
            else {
                return this._textAlpha;
            }
        }
        getTextOutlineColor(state) {
            if (state.inDisabled) {
                return this._textOutlineColorDisabled;
            }
            else {
                return this._textOutlineColor;
            }
        }
        getTextOutlineAlpha(state) {
            if (state.inDisabled) {
                return this._textOutlineAlphaDisabled;
            }
            else {
                return this._textOutlineAlpha;
            }
        }
        getCursor(state) {
            if (state.isActionable) {
                return "pointer";
            }
            return "";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeButtonRuntimeActionToggle extends EShapeActionRuntimeBase {
        constructor(runtime) {
            super(EShapeRuntimeReset.COLOR_FILL_AND_STROKE |
                EShapeRuntimeReset.COLOR_TEXT |
                EShapeRuntimeReset.COLOR_TEXT_OUTLINE |
                EShapeRuntimeReset.CURSOR);
            const fill = runtime.fill;
            const fillColorActive = fill.color;
            this._fillColorActive = fillColorActive;
            const fillColorActiveOnHovered = this.toOnHovered(fillColorActive);
            const fillColorActiveOnPressed = fillColorActiveOnHovered * 2;
            this._fillColorActivePressed = UtilRgb.darken(fillColorActive, fillColorActiveOnPressed);
            this._fillColorActiveHovered = UtilRgb.darken(fillColorActive, fillColorActiveOnHovered);
            const fillColor = 0xe7e5e7;
            this._fillColor = fillColor;
            const fillColorOnHovered = this.toOnHovered(fillColor);
            const fillColorOnPressed = fillColorOnHovered * 2;
            this._fillColorPressed = UtilRgb.darken(fillColor, fillColorOnPressed);
            this._fillColorHovered = UtilRgb.darken(fillColor, fillColorOnHovered);
            const fillAlpha = fill.alpha;
            this._fillAlpha = fillAlpha;
            this._fillAlphaDisabled = fillAlpha * 0.5;
            const stroke = runtime.stroke;
            const strokeColorActive = stroke.color;
            this._strokeColorActive = strokeColorActive;
            const strokeColorActiveOnHovered = this.toOnHovered(strokeColorActive);
            const strokeColorActiveOnPressed = strokeColorActiveOnHovered * 2;
            this._strokeColorActivePressed = UtilRgb.darken(strokeColorActive, strokeColorActiveOnPressed);
            this._strokeColorActiveHovered = UtilRgb.darken(strokeColorActive, strokeColorActiveOnHovered);
            const strokeColor = 0xe7e5e7;
            this._strokeColor = strokeColor;
            const strokeColorOnHovered = this.toOnHovered(strokeColor);
            const strokeColorOnPressed = strokeColorOnHovered * 2;
            this._strokeColorPressed = UtilRgb.darken(strokeColor, strokeColorOnPressed);
            this._strokeColorGrayscaleHovered = UtilRgb.darken(strokeColor, strokeColorOnHovered);
            const strokeAlpha = stroke.alpha;
            this._strokeAlpha = strokeAlpha;
            this._strokeAlphaDisabled = strokeAlpha * 0.5;
            const text = runtime.text;
            const textColor = text.color;
            this._textColorActive = textColor;
            this._textColorDisabled = UtilRgb.toGrayscale(textColor);
            this._textColor = 0x4f4f4f;
            const textAlpha = text.alpha;
            this._textAlpha = textAlpha;
            this._textAlphaDisabled = textAlpha * 0.5;
            const textOutline = text.outline;
            const textOutlineColor = textOutline.color;
            this._textOutlineColor = textOutlineColor;
            this._textOutlineColorDisabled = UtilRgb.toGrayscale(textOutlineColor);
            const textOutlineAlpha = textOutline.alpha;
            this._textOutlineAlpha = textOutlineAlpha;
            this._textOutlineAlphaDisabled = textOutlineAlpha * 0.5;
        }
        toOnHovered(color) {
            const luma = UtilRgb.toLuma(color);
            if (128 <= luma) {
                const t = (luma - 128) / 127;
                return +0.15 * (1 - t) + t * 0.03;
            }
            else {
                const t = (127 - luma) / 127;
                return -0.15 * (1 - t) - t * 0.175;
            }
        }
        execute(shape, runtime, time) {
            const state = shape.state;
            shape.fill.set(undefined, this.getFillColor(state), this.getFillAlpha(state));
            shape.stroke.set(undefined, this.getStrokeColor(state), this.getStrokeAlpha(state));
            shape.text.set(undefined, this.getTextColor(state), this.getTextAlpha(state));
            shape.text.outline.set(undefined, this.getTextOutlineColor(state), this.getTextOutlineAlpha(state));
            shape.cursor = this.getCursor(state);
            runtime.written |= this.reset;
        }
        getFillColor(state) {
            if (state.inDisabled) {
                return this._fillColor;
            }
            else if (state.isActive) {
                if (state.isPressed) {
                    return this._fillColorActivePressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._fillColorActiveHovered;
                }
                else {
                    return this._fillColorActive;
                }
            }
            else {
                if (state.isPressed) {
                    return this._fillColorPressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._fillColorHovered;
                }
                else {
                    return this._fillColor;
                }
            }
        }
        getFillAlpha(state) {
            if (state.inDisabled) {
                return this._fillAlphaDisabled;
            }
            else {
                return this._fillAlpha;
            }
        }
        getStrokeColor(state) {
            if (state.inDisabled) {
                return this._strokeColor;
            }
            else if (state.isActive) {
                if (state.isPressed) {
                    return this._strokeColorActivePressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._strokeColorActiveHovered;
                }
                else {
                    return this._strokeColorActive;
                }
            }
            else {
                if (state.isPressed) {
                    return this._strokeColorPressed;
                }
                else if (state.isFocused || state.isHovered) {
                    return this._strokeColorGrayscaleHovered;
                }
                else {
                    return this._strokeColor;
                }
            }
        }
        getStrokeAlpha(state) {
            if (state.inDisabled) {
                return this._strokeAlphaDisabled;
            }
            else {
                return this._strokeAlpha;
            }
        }
        getTextColor(state) {
            if (state.inDisabled) {
                return this._textColorDisabled;
            }
            else if (state.isActive) {
                return this._textColorActive;
            }
            else {
                return this._textColor;
            }
        }
        getTextAlpha(state) {
            if (state.inDisabled) {
                return this._textAlphaDisabled;
            }
            else {
                return this._textAlpha;
            }
        }
        getTextOutlineColor(state) {
            if (state.inDisabled) {
                return this._textOutlineColorDisabled;
            }
            else {
                return this._textOutlineColor;
            }
        }
        getTextOutlineAlpha(state) {
            if (state.inDisabled) {
                return this._textOutlineAlphaDisabled;
            }
            else {
                return this._textOutlineAlpha;
            }
        }
        getCursor(state) {
            if (state.isActionable) {
                return "pointer";
            }
            return "";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeButtonRuntime extends EShapeRuntimeImpl {
        constructor(shape) {
            super(shape);
            if (shape instanceof EShapeButton) {
                this._isToggle = shape.isToggle;
                this._isGrouped = shape.isGrouped;
            }
        }
        isActionable() {
            return true;
        }
        initialize(shape) {
            this.actions.unshift(this._isToggle
                ? new EShapeButtonRuntimeActionToggle(this)
                : new EShapeButtonRuntimeAction(this));
            super.initialize(shape);
        }
        onClick(shape, e) {
            const state = shape.state;
            const wasClicked = state.isClicked;
            state.lock();
            super.onClick(shape, e);
            if (!wasClicked && state.isClicked) {
                if (this._isToggle) {
                    state.isActive = !state.isActive;
                }
                else {
                    if (!state.isActive) {
                        state.isActivated = true;
                    }
                }
            }
            state.unlock();
        }
        onStateChange(shape, newState, oldState) {
            super.onStateChange(shape, newState, oldState);
            if (this._isToggle && this._isGrouped && newState.is(EShapeState.ACTIVATED)) {
                this.onActivated(shape);
            }
        }
        onActivated(shape) {
            // Deactivate other group buttons
            const parent = shape.parent;
            if (parent != null) {
                const children = parent.children;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    if (child !== shape &&
                        child instanceof EShapeButton &&
                        child.isToggle &&
                        child.isGrouped) {
                        child.state.isActive = false;
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeButton = () => {
        EShapeUploadeds[EShapeType.BUTTON] = createButtonUploaded;
        EShapeDeserializers[EShapeType.BUTTON] = deserializeButton;
        EShapeRuntimes[EShapeType.BUTTON] = EShapeButtonRuntime;
        EShapeCapabilities.set(EShapeType.BUTTON, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    const CIRCLE_VERTEX_COUNT = 9;
    const CIRCLE_INDEX_COUNT = 8;
    const CIRCLE_WORLD_SIZE = [0, 0];
    const CIRCLE_WORK_POINT = new pixi_js.Point();
    const buildCircleIndex = (indices, voffset, ioffset) => {
        let ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 7;
    };
    const buildCircleVertex = (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) => {
        // Calculate the transformed positions
        //
        //  0       1       2
        // |-------|-------|
        // |3      |4      |5
        // |-------|-------|
        // |6      |7      |8
        // |-------|-------|
        //
        const work = CIRCLE_WORK_POINT;
        const s = strokeAlign * strokeWidth;
        const sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        const sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        work.set(-sx + originX, -sy + originY);
        internalTransform.apply(work, work);
        const x0 = work.x;
        const y0 = work.y;
        work.set(0 + originX, -sy + originY);
        internalTransform.apply(work, work);
        const x1 = work.x;
        const y1 = work.y;
        const dx = x1 - x0;
        const dy = y1 - y0;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        const x4 = work.x;
        const y4 = work.y;
        const x7 = x4 + (x4 - x1);
        const y7 = y4 + (y4 - y1);
        const x3 = x4 - dx;
        const y3 = y4 - dy;
        // Vertices
        let iv = voffset * 2 - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1 + dx;
        vertices[++iv] = y1 + dy;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x4 + dx;
        vertices[++iv] = y4 + dy;
        vertices[++iv] = x7 - dx;
        vertices[++iv] = y7 - dy;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x7 + dx;
        vertices[++iv] = y7 + dy;
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x3, y3);
    };
    const buildCircleStep = (steps, voffset, strokeWidth, strokeStyle, worldSize) => {
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const ax = worldSize[0];
        const ay = worldSize[1];
        const e = toPackedI4x64(1, scaleInvariant, 1, 1);
        const c11 = toPackedF2x1024(1, 1);
        const c01 = toPackedF2x1024(0, 1);
        const c10 = toPackedF2x1024(1, 0);
        const c00 = toPackedF2x1024(0, 0);
        let is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
    };
    const buildCircleUv = (uvs, voffset, textureUvs) => {
        const x0 = textureUvs.x0;
        const x1 = textureUvs.x1;
        const x2 = textureUvs.x2;
        const x3 = textureUvs.x3;
        const y0 = textureUvs.y0;
        const y1 = textureUvs.y1;
        const y2 = textureUvs.y2;
        const y3 = textureUvs.y3;
        // UVs
        let iuv = voffset * 2 - 1;
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = 0.5 * (x0 + x1);
        uvs[++iuv] = 0.5 * (y0 + y1);
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = 0.5 * (x0 + x3);
        uvs[++iuv] = 0.5 * (y0 + y3);
        uvs[++iuv] = 0.5 * (x0 + x2);
        uvs[++iuv] = 0.5 * (y0 + y2);
        uvs[++iuv] = 0.5 * (x1 + x2);
        uvs[++iuv] = 0.5 * (y1 + y2);
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = 0.5 * (x3 + x2);
        uvs[++iuv] = 0.5 * (y3 + y2);
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderCircle extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, CIRCLE_VERTEX_COUNT, CIRCLE_INDEX_COUNT);
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            const voffset = this.vertexOffset;
            buildCircleIndex(buffer.indices, voffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        }
        updateVertexAndStep(buffer, shape) {
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited || isSizeChanged || isTransformChanged || isStrokeChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                buildCircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, CIRCLE_WORLD_SIZE);
                buildCircleStep(buffer.steps, this.vertexOffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
            }
        }
        updateUv(buffer, shape) {
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                const textureUvs = toTextureUvs(texture);
                buildCircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createCircleUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = CIRCLE_VERTEX_COUNT + tvcount;
        const icount = CIRCLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderCircle(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + CIRCLE_VERTEX_COUNT, ioffset + CIRCLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeCircle = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeCircle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeCircle = () => {
        EShapeUploadeds[EShapeType.CIRCLE] = createCircleUploaded;
        EShapeDeserializers[EShapeType.CIRCLE] = deserializeCircle;
    };

    const toVectorLength = (v) => {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };

    const LINE_FMIN = 0.00001;
    const LINE_NPREV = [0, 1];
    const LINE_NNEXT = [0, 1];
    const toPointCount = (points) => {
        if (points) {
            return points.formatted.plength;
        }
        return 0;
    };
    const toLinePointCount = (points) => {
        const pointCount = toPointCount(points);
        return ((pointCount >> 4) + (0 < (pointCount & 0xf) ? 1 : 0)) << 4;
    };
    const toLineVertexCount = (pointCount, isClosed) => {
        if (isClosed) {
            return (pointCount << 2) + 2;
        }
        else {
            return pointCount << 2;
        }
    };
    const toLineIndexCount = (pointCount, isClosed) => {
        return toLineVertexCount(pointCount, isClosed) - 2;
    };
    const buildLineIndex = (indices, voffset, ioffset, icount) => {
        let ii = ioffset * 3 - 1;
        const iimax = (ioffset + icount) * 3 - 1;
        let io = voffset;
        for (; ii < iimax;) {
            indices[++ii] = io + 0;
            indices[++ii] = io + 2;
            indices[++ii] = io + 1;
            indices[++ii] = io + 1;
            indices[++ii] = io + 2;
            indices[++ii] = io + 3;
            io += 2;
        }
    };
    const buildLineUv = (uvs, steps, voffset, vcount, textureUvs, length) => {
        const lengthInverse = 1 / Math.max(LINE_FMIN, length);
        const x0 = textureUvs.x0;
        const x1 = textureUvs.x1;
        const x2 = textureUvs.x2;
        const x3 = textureUvs.x3;
        const y0 = textureUvs.y0;
        const y1 = textureUvs.y1;
        const y2 = textureUvs.y2;
        const y3 = textureUvs.y3;
        const dx01 = x1 - x0;
        const dy01 = y1 - y0;
        const dx32 = x2 - x3;
        const dy32 = y2 - y3;
        let iuv = (voffset << 1) - 1;
        const iuvmax = ((voffset + vcount) << 1) - 1;
        let is = voffset * 6 - 9;
        for (; iuv < iuvmax;) {
            const r = steps[(is += 12)] * lengthInverse;
            uvs[++iuv] = x0 + r * dx01;
            uvs[++iuv] = y0 + r * dy01;
            uvs[++iuv] = x3 + r * dx32;
            uvs[++iuv] = y3 + r * dy32;
        }
    };
    let TRANSFORMED_POINT_VALUES;
    const buildLineVertexStep = (vertices, steps, voffset, vcount, pointCount, pointsClosed, pointValues, pointSegments, strokeWidth, strokeStyle, internalTransform) => {
        let transformedPointValues = TRANSFORMED_POINT_VALUES;
        if (transformedPointValues == null) {
            transformedPointValues = [];
            TRANSFORMED_POINT_VALUES = transformedPointValues;
        }
        const a = internalTransform.a;
        const b = internalTransform.b;
        const c = internalTransform.c;
        const d = internalTransform.d;
        const tx = internalTransform.tx;
        const ty = internalTransform.ty;
        for (let i = 0; i < pointCount; ++i) {
            const iv = i << 1;
            const x = pointValues[iv];
            const y = pointValues[iv + 1];
            transformedPointValues[iv] = a * x + c * y + tx;
            transformedPointValues[iv + 1] = b * x + d * y + ty;
        }
        return buildTransformedLineVertexStep(vertices, steps, voffset, vcount, pointCount, pointsClosed, transformedPointValues, pointSegments, strokeWidth, strokeStyle);
    };
    const fillTransformedLineVertexStep = (iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, llo, e0, e1) => {
        const d = toNormalPacked(nprev, nnext);
        const l = Math.min(lprev, lnext);
        vertices[++iv] = px;
        vertices[++iv] = py;
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = d;
        steps[++is] = llo;
        steps[++is] = llo;
        steps[++is] = l;
        vertices[++iv] = px;
        vertices[++iv] = py;
        steps[++is] = strokeWidth;
        steps[++is] = e1;
        steps[++is] = d;
        steps[++is] = llo;
        steps[++is] = llo;
        steps[++is] = l;
    };
    const buildTransformedLineVertexStep = (vertices, steps, voffset, vcount, lineVertexCount, lineIsClosed, lineVertices, lineSegments, strokeWidth, strokeStyle) => {
        const lineSegmentsLength = lineSegments.length;
        if (0 < lineSegmentsLength) {
            if (lineIsClosed) {
                let lmax = 0;
                let lprev = 0;
                let ivoffset = voffset;
                let iseg = 0;
                let iprevseg = lineSegments[0];
                for (let i = 1; i < lineSegmentsLength; ++i) {
                    iseg = lineSegments[i];
                    if (2 <= iseg - iprevseg) {
                        lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, -1, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                        lmax = Math.max(lmax, lprev);
                        ivoffset += toLineVertexCount(iseg - iprevseg, false);
                    }
                    iprevseg = iseg;
                }
                // Last
                iseg = lineSegments[0] + lineVertexCount;
                if (2 <= iseg - iprevseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg - iprevseg, false);
                }
                else {
                    buildTransformedLineEmptyVertexStep(vertices, steps, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                }
                return lmax;
            }
            else {
                let lmax = 0;
                let lprev = 0;
                let ivoffset = voffset;
                // First
                let iseg = lineSegments[0];
                if (2 <= iseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, -1, lineVertices, 0, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg, false);
                }
                // Middle
                let iprevseg = iseg;
                for (let i = 1; i < lineSegmentsLength; ++i) {
                    iseg = lineSegments[i];
                    if (2 <= iseg - iprevseg) {
                        lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, -1, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                        lmax = Math.max(lmax, lprev);
                        ivoffset += toLineVertexCount(iseg - iprevseg, false);
                    }
                    iprevseg = iseg;
                }
                // Last
                iseg = lineVertexCount;
                if (2 <= iseg - iprevseg) {
                    lprev = buildTransformedLineOpenSegmentVertexStep(vertices, steps, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                    lmax = Math.max(lmax, lprev);
                    ivoffset += toLineVertexCount(iseg - iprevseg, false);
                }
                else {
                    buildTransformedLineEmptyVertexStep(vertices, steps, ivoffset, voffset + vcount - ivoffset, lineVertices, iprevseg, iseg, lineVertexCount, strokeWidth, strokeStyle, lprev);
                }
                return lmax;
            }
        }
        else {
            if (lineIsClosed) {
                return buildTransformedLineClosedSegmentVertexStep(vertices, steps, voffset, vcount, lineVertices, 0, lineVertexCount, lineVertexCount, strokeWidth, strokeStyle);
            }
            else {
                return buildTransformedLineOpenSegmentVertexStep(vertices, steps, voffset, vcount, lineVertices, 0, lineVertexCount, lineVertexCount, strokeWidth, strokeStyle, 0);
            }
        }
    };
    const buildTransformedLineEmptyVertexStep = (vertices, steps, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle, length) => {
        if (0 <= vcount) {
            const scaleInvariant = toScaleInvariant(strokeStyle);
            const dash = toDash(strokeStyle);
            const e3 = toPackedI4x64(3, scaleInvariant, dash, 0);
            const e5 = toPackedI4x64(5, scaleInvariant, dash, 0);
            let iv = (voffset << 1) - 1;
            let is = voffset * 6 - 1;
            const ivmax = ((voffset + vcount) << 1) - 1;
            const ifirst = lineVertexFrom % lineVertexCount << 1;
            const px = lineVertices[ifirst];
            const py = lineVertices[ifirst + 1];
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = e3;
                steps[++is] = 0;
                steps[++is] = length;
                steps[++is] = length;
                steps[++is] = 0;
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = e5;
                steps[++is] = 0;
                steps[++is] = length;
                steps[++is] = length;
                steps[++is] = 0;
            }
        }
        return 0;
    };
    const buildTransformedLineOpenSegmentVertexStep = (vertices, steps, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle, length) => {
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const dash = toDash(strokeStyle);
        const e3 = toPackedI4x64(3, scaleInvariant, dash, 0);
        const e4 = toPackedI4x64(4, scaleInvariant, dash, 0);
        const e5 = toPackedI4x64(5, scaleInvariant, dash, 0);
        const e6 = toPackedI4x64(6, scaleInvariant, dash, 0);
        // First segment
        const ifirst = lineVertexFrom % lineVertexCount << 1;
        let px = lineVertices[ifirst];
        let py = lineVertices[ifirst + 1];
        const isecond = (lineVertexFrom + 1) % lineVertexCount << 1;
        let pnextx = lineVertices[isecond];
        let pnexty = lineVertices[isecond + 1];
        let pprevx = px - (pnextx - px);
        let pprevy = py - (pnexty - py);
        const nprev = LINE_NPREV;
        const nnext = LINE_NNEXT;
        toVector(pprevx, pprevy, px, py, nprev);
        toVector(px, py, pnextx, pnexty, nnext);
        let lprev = toVectorLength(nprev);
        let lnext = lprev;
        toNormal(nprev, lprev);
        toNormal(nnext, lnext);
        let iv = (voffset << 1) - 1;
        let is = voffset * 6 - 1;
        let l = 0;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, length, e3, e5);
        iv += 4;
        is += 12;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e4, e6);
        iv += 4;
        is += 12;
        // Middle segments
        for (let i = lineVertexFrom + 1, imax = lineVertexTo - 1; i < imax; ++i) {
            pprevx = px;
            pprevy = py;
            px = pnextx;
            py = pnexty;
            nprev[0] = nnext[0];
            nprev[1] = nnext[1];
            lprev = lnext;
            const imiddle = (i + 1) % lineVertexCount << 1;
            pnextx = lineVertices[imiddle];
            pnexty = lineVertices[imiddle + 1];
            toVector(px, py, pnextx, pnexty, nnext);
            lnext = toVectorLength(nnext);
            toNormal(nnext, lnext);
            l += lprev;
            fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e3, e5);
            iv += 4;
            is += 12;
            fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e4, e6);
            iv += 4;
            is += 12;
        }
        // Last segment
        pprevx = px;
        pprevy = py;
        px = pnextx;
        py = pnexty;
        nprev[0] = nnext[0];
        nprev[1] = nnext[1];
        lprev = lnext;
        pnextx = px + (px - pprevx);
        pnexty = py + (py - pprevy);
        toVector(px, py, pnextx, pnexty, nnext);
        toNormal(nnext, lnext);
        l += lprev;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e3, e5);
        iv += 4;
        is += 12;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e4, e6);
        iv += 4;
        is += 12;
        // Total length
        const is0 = voffset * 6 - 1;
        for (let i = is0, imax = is0 + 12; i < imax; i += 6) {
            steps[i + 5] = length;
        }
        for (let i = is0 + 12; i < is; i += 6) {
            steps[i + 5] = l;
        }
        // Fill the rest
        if (0 <= vcount) {
            const d = toNormalPacked(nprev, nnext);
            const ivmax = ((voffset + vcount) << 1) - 1;
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = e3;
                steps[++is] = d;
                steps[++is] = l;
                steps[++is] = l;
                steps[++is] = 0;
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = 0;
                steps[++is] = e5;
                steps[++is] = d;
                steps[++is] = l;
                steps[++is] = l;
                steps[++is] = 0;
            }
        }
        return l;
    };
    const buildTransformedLineClosedSegmentVertexStep = (vertices, steps, voffset, vcount, lineVertices, lineVertexFrom, lineVertexTo, lineVertexCount, strokeWidth, strokeStyle) => {
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const dash = toDash(strokeStyle);
        const e3 = toPackedI4x64(3, scaleInvariant, dash, 0);
        const e4 = toPackedI4x64(4, scaleInvariant, dash, 0);
        const e5 = toPackedI4x64(5, scaleInvariant, dash, 0);
        const e6 = toPackedI4x64(6, scaleInvariant, dash, 0);
        const ilast = (lineVertexTo - 1) % lineVertexCount << 1;
        let pprevx = 0;
        let pprevy = 0;
        let px = lineVertices[ilast];
        let py = lineVertices[ilast + 1];
        const ifirst = lineVertexFrom % lineVertexCount << 1;
        let pnextx = lineVertices[ifirst];
        let pnexty = lineVertices[ifirst + 1];
        const nprev = LINE_NPREV;
        const nnext = LINE_NNEXT;
        toVector(pprevx, pprevy, px, py, nprev);
        toVector(px, py, pnextx, pnexty, nnext);
        let lprev = toVectorLength(nprev);
        let lnext = toVectorLength(nnext);
        toNormal(nprev, lprev);
        toNormal(nnext, lnext);
        let l = 0;
        let iv = (voffset << 1) - 1;
        let is = voffset * 6 - 1;
        for (let i = lineVertexFrom; i < lineVertexTo; ++i) {
            pprevx = px;
            pprevy = py;
            px = pnextx;
            py = pnexty;
            nprev[0] = nnext[0];
            nprev[1] = nnext[1];
            lprev = lnext;
            const imiddle = (i + 1) % lineVertexCount << 1;
            pnextx = lineVertices[imiddle];
            pnexty = lineVertices[imiddle + 1];
            toVector(px, py, pnextx, pnexty, nnext);
            lnext = toVectorLength(nnext);
            toNormal(nnext, lnext);
            l += lprev;
            fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e3, e5);
            iv += 4;
            is += 12;
            fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e4, e6);
            iv += 4;
            is += 12;
        }
        // Last segment
        pprevx = px;
        pprevy = py;
        px = pnextx;
        py = pnexty;
        nprev[0] = nnext[0];
        nprev[1] = nnext[1];
        lprev = lnext;
        const isecond = (lineVertexFrom + 1) % lineVertexCount << 1;
        pnextx = lineVertices[isecond];
        pnexty = lineVertices[isecond + 1];
        toVector(px, py, pnextx, pnexty, nnext);
        lnext = toVectorLength(nnext);
        toNormal(nnext, lnext);
        l += lprev;
        fillTransformedLineVertexStep(iv, vertices, is, steps, px, py, strokeWidth, nprev, nnext, lprev, lnext, l, e3, e5);
        iv += 4;
        is += 12;
        // Total length
        for (let i = voffset * 6 - 1; i < is; i += 6) {
            steps[i + 5] = -l;
        }
        // Fill the rest
        if (0 <= vcount) {
            const d = toNormalPacked(nprev, nnext);
            const ivmax = ((voffset + vcount) << 1) - 1;
            for (; iv < ivmax;) {
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = strokeWidth;
                steps[++is] = e3;
                steps[++is] = d;
                steps[++is] = l;
                steps[++is] = -l;
                steps[++is] = 0;
                vertices[++iv] = px;
                vertices[++iv] = py;
                steps[++is] = strokeWidth;
                steps[++is] = e5;
                steps[++is] = d;
                steps[++is] = l;
                steps[++is] = -l;
                steps[++is] = 0;
            }
        }
        return l;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderLine extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset, vertexCount, indexCount) {
            super(buffer, vertexOffset, indexOffset, vertexCount, indexCount);
            this.pointId = -1;
            this.pointCount = 0;
            this.pointsClosed = false;
            this.length = 1;
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            buildLineIndex(buffer.indices, this.vertexOffset, this.indexOffset, this.indexCount);
            this.inited |= BuilderFlag.INDEX;
        }
        reinit(buffer, shape, vertexOffset, indexOffset) {
            const pointCount = toLinePointCount(shape.points);
            const vertexCount = toLineVertexCount(pointCount, true);
            const indexCount = toLineIndexCount(pointCount, true);
            if (this.buffer !== buffer ||
                this.vertexOffset !== vertexOffset ||
                this.indexOffset !== indexOffset ||
                this.vertexCount !== vertexCount ||
                this.indexCount !== indexCount) {
                if (buffer.check(vertexOffset, indexOffset, vertexCount, indexCount)) {
                    this.inited = BuilderFlag.NONE;
                    this.buffer = buffer;
                    this.vertexOffset = vertexOffset;
                    this.indexOffset = indexOffset;
                    this.vertexCount = vertexCount;
                    this.indexCount = indexCount;
                    this.init();
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        }
        isCompatible(shape) {
            const vcount = toLineVertexCount(toLinePointCount(shape.points), true);
            return vcount === this.vertexCount;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateLineVertexStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateLineUv(buffer, shape);
        }
        updateLineVertexStep(buffer, shape) {
            const points = shape.points;
            if (points) {
                const pointId = points.id;
                const formatted = points.formatted;
                const pointCount = formatted.length;
                const pointsClosed = !!(formatted.style & EShapePointsStyle.CLOSED);
                const isPointChanged = pointId !== this.pointId ||
                    pointCount !== this.pointCount ||
                    pointsClosed !== this.pointsClosed;
                const stroke = shape.stroke;
                const strokeWidth = stroke.enable ? stroke.width : 0;
                const strokeStyle = stroke.style;
                const isStrokeWidthChanged = this.strokeWidth !== strokeWidth || this.strokeStyle !== strokeStyle;
                const transformLocalId = toTransformLocalId(shape);
                const isTransformChanged = this.transformLocalId !== transformLocalId;
                const isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
                if (isNotInited || isPointChanged || isTransformChanged || isStrokeWidthChanged) {
                    this.inited |= BuilderFlag.VERTEX_AND_STEP;
                    this.pointId = pointId;
                    this.pointCount = pointCount;
                    this.pointsClosed = pointsClosed;
                    this.strokeWidth = strokeWidth;
                    this.strokeStyle = strokeStyle;
                    this.transformLocalId = transformLocalId;
                    if (isPointChanged) {
                        // Invalidate the UV buffer
                        this.inited &= ~BuilderFlag.UV;
                    }
                    buffer.updateVertices();
                    buffer.updateSteps();
                    this.length = buildLineVertexStep(buffer.vertices, buffer.steps, this.vertexOffset, this.vertexCount, this.pointCount, this.pointsClosed, formatted.values, formatted.segments, strokeWidth, strokeStyle, shape.transform.internalTransform);
                }
            }
        }
        updateLineUv(buffer, shape) {
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildLineUv(buffer.uvs, buffer.steps, this.vertexOffset, this.vertexCount, toTextureUvs(texture), this.length);
            }
        }
    }

    const TRIANGLE_VERTEX_COUNT = 7;
    const TRIANGLE_INDEX_COUNT = 3;
    const TRIANGLE_WORLD_SIZE = [0, 0, 0];
    const TRIANGLE_WORK_POINT = new pixi_js.Point();
    const buildTriangleIndex = (indices, voffset, ioffset) => {
        // Indices
        let ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
    };
    const buildTriangleVertex = (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) => {
        const s = strokeAlign * strokeWidth;
        const sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        const sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        const sz = Math.sqrt(sx * sx + 4 * sy * sy);
        const sw = (2 * sx * sy) / (sx + sz);
        const work = TRIANGLE_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        const x0 = work.x;
        const y0 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        const tx = work.x;
        const ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        const dx = tx - x0;
        const dy = ty - y0;
        const x1 = work.x + dx;
        const y1 = work.y + dy;
        const x2 = tx + (tx - work.x) + dx;
        const y2 = ty + (ty - work.y) + dy;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        const x3 = work.x;
        const y3 = work.y;
        // World size
        const xb = tx + dx;
        const yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x3, y3);
        worldSize[1] = toLength(x1, y1, xb, yb);
        worldSize[2] = toLength(x0, y0, tx, ty);
        // Vertices
        let iv = (voffset << 1) - 1;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
    };
    const buildTriangleStep = (steps, voffset, strokeWidth, strokeStyle, worldSize) => {
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const s = worldSize[0];
        const e = toPackedI4x64(0, scaleInvariant, 1, 1);
        const c00 = toPackedF2x1024(0, 0);
        const c10 = toPackedF2x1024(1, 0);
        const c01 = toPackedF2x1024(0, 1);
        // 000
        let is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c00;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 010
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c01;
        steps[++is] = 0;
        // 010
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c01;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
    };
    const buildTriangleUv = (uvs, textureUvs, voffset, worldSize) => {
        const x0 = textureUvs.x0;
        const x1 = textureUvs.x1;
        const x2 = textureUvs.x2;
        const x3 = textureUvs.x3;
        const y0 = textureUvs.y0;
        const y1 = textureUvs.y1;
        const y2 = textureUvs.y2;
        const y3 = textureUvs.y3;
        const x4 = 0.5 * (x0 + x1);
        const y4 = 0.5 * (y0 + y1);
        const c = 1 - (0.5 * worldSize[0]) / worldSize[2];
        const x5 = x4 + c * (x3 - x0);
        const y5 = y4 + c * (y3 - y0);
        let iuv = (voffset << 1) - 1;
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerBase extends BuilderBase {
        updateColor(buffer, shape) {
            let colorFill = 0xffffff;
            let alphaFill = 1;
            const points = shape.points;
            if (points != null) {
                const container = points.getMarker();
                if (container != null) {
                    const marker = this.toMarker(container);
                    const fill = marker.fill;
                    colorFill = fill.color;
                    alphaFill = shape.visible && fill.enable ? fill.alpha : 0;
                }
            }
            const stroke = shape.stroke;
            const colorStroke = stroke.color;
            const alphaStroke = shape.visible && stroke.enable && 0 < stroke.width ? stroke.alpha : 0;
            const isNotInited = !(this.inited & BuilderFlag.COLOR);
            if (isNotInited ||
                colorFill !== this.colorFill ||
                alphaFill !== this.alphaFill ||
                colorStroke !== this.colorStroke ||
                alphaStroke !== this.alphaStroke) {
                this.inited |= BuilderFlag.COLOR;
                this.colorFill = colorFill;
                this.alphaFill = alphaFill;
                this.colorStroke = colorStroke;
                this.alphaStroke = alphaStroke;
                buffer.updateColors();
                buildColor(colorFill, alphaFill, colorStroke, alphaStroke, this.vertexOffset, this.vertexCount, buffer.colors);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerTriangle extends BuilderMarkerBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, TRIANGLE_VERTEX_COUNT, TRIANGLE_INDEX_COUNT);
            this.pointId = -1;
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            buildTriangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        }
        updateVertexStepAndUv(buffer, shape) {
            var _a;
            const points = shape.points;
            if (points == null) {
                return;
            }
            const container = points.getMarker();
            if (container == null) {
                return;
            }
            const marker = this.toMarker(container);
            const size = marker.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isSizeChanged || isStrokeChanged;
            const pointId = points.id;
            const isPointChanged = pointId !== this.pointId;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isTextureChanged ||
                isPointChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                this.pointId = pointId;
                const voffset = this.vertexOffset;
                const internalTransform = ((_a = BuilderMarkerTriangle.WORK) !== null && _a !== void 0 ? _a : (BuilderMarkerTriangle.WORK = new pixi_js.Matrix()));
                internalTransform.copyFrom(marker.transform).prepend(shape.transform.internalTransform);
                buffer.updateVertices();
                buildTriangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildTriangleStep(buffer.steps, voffset, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleUv(buffer.uvs, toTextureUvs(texture), voffset, TRIANGLE_WORLD_SIZE);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerTriangleHead extends BuilderMarkerTriangle {
        toMarker(container) {
            return container.head;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerTriangleTail extends BuilderMarkerTriangle {
        toMarker(container) {
            return container.tail;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerCircle extends BuilderMarkerBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, CIRCLE_VERTEX_COUNT, CIRCLE_INDEX_COUNT);
            this.pointId = -1;
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            const vertexOffset = this.vertexOffset;
            buildCircleIndex(buffer.indices, vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        }
        updateVertexAndStep(buffer, shape) {
            var _a;
            const points = shape.points;
            if (points == null) {
                return;
            }
            const container = points.getMarker();
            if (container == null) {
                return;
            }
            const marker = this.toMarker(container);
            const size = marker.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const pointId = points.id;
            const isPointChanged = pointId !== this.pointId;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited ||
                isSizeChanged ||
                isTransformChanged ||
                isStrokeChanged ||
                isPointChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.pointId = pointId;
                // Buffer
                const internalTransform = ((_a = BuilderMarkerCircle.WORK) !== null && _a !== void 0 ? _a : (BuilderMarkerCircle.WORK = new pixi_js.Matrix()));
                internalTransform.copyFrom(marker.transform).prepend(shape.transform.internalTransform);
                buffer.updateVertices();
                buffer.updateSteps();
                buildCircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                buildCircleStep(buffer.steps, this.vertexOffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
            }
        }
        updateUv(buffer, shape) {
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                const textureUvs = toTextureUvs(texture);
                buildCircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerCircleHead extends BuilderMarkerCircle {
        toMarker(container) {
            return container.head;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerCircleTail extends BuilderMarkerCircle {
        toMarker(container) {
            return container.tail;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderNull {
        constructor(buffer, vertexOffset, indexOffset) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = 0;
            this.indexCount = 0;
            this.texture = null;
        }
        init() {
            return this;
        }
        reinit(buffer, shape, vertexOffset, indexOffset) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            return true;
        }
        isCompatible(shape) {
            return true;
        }
        update(shape) {
            this.texture = toTexture(shape);
        }
        buildUnit(builder) {
            const texture = this.texture || pixi_js.Texture.WHITE;
            const baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                const indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        }
    }

    const RECTANGLE_VERTEX_COUNT = 16;
    const RECTANGLE_INDEX_COUNT = 8;
    const RECTANGLE_WORLD_SIZE = [0, 0];
    const RECTANGLE_WORK_POINT = new pixi_js.Point();
    const buildRectangleIndex = (indices, voffset, ioffset) => {
        // c0     c1   c4     c5
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c2     c3   c6     c7
        //
        // c8     c9   c12   c13
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c10   c11   c14   c15
        let ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 15;
    };
    const buildRectangleVertex = (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) => {
        // b0      b1      b2
        // |-------|-------|
        // |       |       |
        // b3------b4------b5
        // |       |       |
        // |-------|-------|
        // b6      b7      b8
        const s = strokeAlign * strokeWidth;
        const sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        const sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        const work = RECTANGLE_WORK_POINT;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        const b0x = work.x;
        const b0y = work.y;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        const b1x = work.x;
        const b1y = work.y;
        work.set(originX - sx, originY);
        internalTransform.apply(work, work);
        const b3x = work.x;
        const b3y = work.y;
        const d01x = b1x - b0x;
        const d01y = b1y - b0y;
        const d03x = b3x - b0x;
        const d03y = b3y - b0y;
        const b2x = b1x + d01x;
        const b2y = b1y + d01y;
        const b4x = b3x + d01x;
        const b4y = b3y + d01y;
        const b5x = b2x + d03x;
        const b5y = b2y + d03y;
        const b6x = b3x + d03x;
        const b6y = b3y + d03y;
        const b7x = b6x + d01x;
        const b7y = b6y + d01y;
        const b8x = b7x + d01x;
        const b8y = b7y + d01y;
        // c0     c1   c4     c5
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c2     c3   c6     c7
        //
        // c8     c9   c12   c13
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c10   c11   c14   c15
        let iv = (voffset << 1) - 1;
        vertices[++iv] = b0x;
        vertices[++iv] = b0y;
        vertices[++iv] = b1x;
        vertices[++iv] = b1y;
        vertices[++iv] = b3x;
        vertices[++iv] = b3y;
        vertices[++iv] = b4x;
        vertices[++iv] = b4y;
        vertices[++iv] = b1x;
        vertices[++iv] = b1y;
        vertices[++iv] = b2x;
        vertices[++iv] = b2y;
        vertices[++iv] = b4x;
        vertices[++iv] = b4y;
        vertices[++iv] = b5x;
        vertices[++iv] = b5y;
        vertices[++iv] = b3x;
        vertices[++iv] = b3y;
        vertices[++iv] = b4x;
        vertices[++iv] = b4y;
        vertices[++iv] = b6x;
        vertices[++iv] = b6y;
        vertices[++iv] = b7x;
        vertices[++iv] = b7y;
        vertices[++iv] = b4x;
        vertices[++iv] = b4y;
        vertices[++iv] = b5x;
        vertices[++iv] = b5y;
        vertices[++iv] = b7x;
        vertices[++iv] = b7y;
        vertices[++iv] = b8x;
        vertices[++iv] = b8y;
        // World size
        worldSize[0] = toLength(b0x, b0y, b1x, b1y);
        worldSize[1] = toLength(b0x, b0y, b3x, b3y);
    };
    const buildRectangleStep = (voffset, steps, strokeWidth, strokeSide, strokeStyle, worldSize) => {
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const ax = worldSize[0];
        const ay = worldSize[1];
        const wt = strokeSide & EShapeStrokeSide.TOP ? 1 : 0;
        const wr = strokeSide & EShapeStrokeSide.RIGHT ? 1 : 0;
        const wb = strokeSide & EShapeStrokeSide.BOTTOM ? 1 : 0;
        const wl = strokeSide & EShapeStrokeSide.LEFT ? 1 : 0;
        const elt = toPackedI4x64(0, scaleInvariant, wl, wt);
        const ert = toPackedI4x64(0, scaleInvariant, wr, wt);
        const elb = toPackedI4x64(0, scaleInvariant, wl, wb);
        const erb = toPackedI4x64(0, scaleInvariant, wr, wb);
        const c11 = toPackedF2x1024(1, 1);
        const c01 = toPackedF2x1024(0, 1);
        const c00 = toPackedF2x1024(0, 0);
        const c10 = toPackedF2x1024(1, 0);
        // c0     c1   c4     c5
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c2     c3   c6     c7
        //
        // c8     c9   c12   c13
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c10   c11   c14   c15
        let is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = elt;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elt;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        //
        steps[++is] = strokeWidth;
        steps[++is] = ert;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = ert;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        //
        steps[++is] = strokeWidth;
        steps[++is] = elb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = elb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        //
        steps[++is] = strokeWidth;
        steps[++is] = erb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = erb;
        steps[++is] = ax;
        steps[++is] = ay;
        steps[++is] = c11;
        steps[++is] = 0;
    };
    const buildRectangleUv = (uvs, voffset, textureUvs) => {
        // b0      b1      b2
        // |-------|-------|
        // |       |       |
        // b3------b4------b5
        // |       |       |
        // |-------|-------|
        // b6      b7      b8
        const b0x = textureUvs.x0;
        const b0y = textureUvs.y0;
        const b2x = textureUvs.x1;
        const b2y = textureUvs.y1;
        const b8x = textureUvs.x2;
        const b8y = textureUvs.y2;
        const b6x = textureUvs.x3;
        const b6y = textureUvs.y3;
        const b1x = (b0x + b2x) * 0.5;
        const b1y = (b0y + b2y) * 0.5;
        const b3x = (b0x + b6x) * 0.5;
        const b3y = (b0y + b6y) * 0.5;
        const d01x = b1x - b0x;
        const d01y = b1y - b0y;
        const d03x = b3x - b0x;
        const d03y = b3y - b0y;
        const b4x = b3x + d01x;
        const b4y = b3y + d01y;
        const b5x = b2x + d03x;
        const b5y = b2y + d03y;
        const b7x = b6x + d01x;
        const b7y = b6y + d01y;
        // c0     c1   c4     c5
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c2     c3   c6     c7
        //
        // c8     c9   c12   c13
        //  |-----|     |-----|
        //  |     |     |     |
        //  |-----|     |-----|
        // c10   c11   c14   c15
        let iuv = (voffset << 1) - 1;
        uvs[++iuv] = b0x;
        uvs[++iuv] = b0y;
        uvs[++iuv] = b1x;
        uvs[++iuv] = b1y;
        uvs[++iuv] = b3x;
        uvs[++iuv] = b3y;
        uvs[++iuv] = b4x;
        uvs[++iuv] = b4y;
        uvs[++iuv] = b1x;
        uvs[++iuv] = b1y;
        uvs[++iuv] = b2x;
        uvs[++iuv] = b2y;
        uvs[++iuv] = b4x;
        uvs[++iuv] = b4y;
        uvs[++iuv] = b5x;
        uvs[++iuv] = b5y;
        uvs[++iuv] = b3x;
        uvs[++iuv] = b3y;
        uvs[++iuv] = b4x;
        uvs[++iuv] = b4y;
        uvs[++iuv] = b6x;
        uvs[++iuv] = b6y;
        uvs[++iuv] = b7x;
        uvs[++iuv] = b7y;
        uvs[++iuv] = b4x;
        uvs[++iuv] = b4y;
        uvs[++iuv] = b5x;
        uvs[++iuv] = b5y;
        uvs[++iuv] = b7x;
        uvs[++iuv] = b7y;
        uvs[++iuv] = b8x;
        uvs[++iuv] = b8y;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerRectangle extends BuilderMarkerBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, RECTANGLE_VERTEX_COUNT, RECTANGLE_INDEX_COUNT);
            this.pointId = -1;
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        }
        updateVertexStepAndUv(buffer, shape) {
            var _a;
            const points = shape.points;
            if (points == null) {
                return;
            }
            const container = points.getMarker();
            if (container == null) {
                return;
            }
            const marker = this.toMarker(container);
            const size = marker.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeSide = stroke.side;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isSizeChanged || isStrokeChanged;
            const pointId = points.id;
            const isPointChanged = pointId !== this.pointId;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isTextureChanged ||
                isPointChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                const voffset = this.vertexOffset;
                const internalTransform = ((_a = BuilderMarkerRectangle.WORK) !== null && _a !== void 0 ? _a : (BuilderMarkerRectangle.WORK = new pixi_js.Matrix()));
                internalTransform.copyFrom(marker.transform).prepend(shape.transform.internalTransform);
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, toTextureUvs(texture));
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerRectangleTail extends BuilderMarkerRectangle {
        toMarker(container) {
            return container.tail;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderMarkerRectangleHead extends BuilderMarkerRectangle {
        toMarker(container) {
            return container.head;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toMarkerVertexCount = (type) => {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return 0;
            case EShapePointsMarkerType.CIRCLE:
                return CIRCLE_VERTEX_COUNT;
            case EShapePointsMarkerType.TRIANGLE:
                return TRIANGLE_VERTEX_COUNT;
            case EShapePointsMarkerType.RECTANGLE:
                return RECTANGLE_VERTEX_COUNT;
        }
        return 0;
    };
    const toMarkerIndexCount = (type) => {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return 0;
            case EShapePointsMarkerType.CIRCLE:
                return CIRCLE_INDEX_COUNT;
            case EShapePointsMarkerType.TRIANGLE:
                return TRIANGLE_INDEX_COUNT;
            case EShapePointsMarkerType.RECTANGLE:
                return RECTANGLE_INDEX_COUNT;
        }
        return 0;
    };
    const toBuilderMarkerHead = (type, buffer, vertexOffset, indexOffset) => {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return new BuilderNull(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.CIRCLE:
                return new BuilderMarkerCircleHead(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.TRIANGLE:
                return new BuilderMarkerTriangleHead(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.RECTANGLE:
                return new BuilderMarkerRectangleHead(buffer, vertexOffset, indexOffset);
        }
        return new BuilderNull(buffer, vertexOffset, indexOffset);
    };
    const toBuilderMarkerTail = (type, buffer, vertexOffset, indexOffset) => {
        switch (type) {
            case EShapePointsMarkerType.NONE:
                return new BuilderNull(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.CIRCLE:
                return new BuilderMarkerCircleTail(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.TRIANGLE:
                return new BuilderMarkerTriangleTail(buffer, vertexOffset, indexOffset);
            case EShapePointsMarkerType.RECTANGLE:
                return new BuilderMarkerRectangleTail(buffer, vertexOffset, indexOffset);
        }
        return new BuilderNull(buffer, vertexOffset, indexOffset);
    };
    const createLineUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        // Line
        const points = shape.points;
        const pointCount = toLinePointCount(points);
        const lvcount = toLineVertexCount(pointCount, true);
        const licount = toLineIndexCount(pointCount, true);
        // Markers
        let mttype = EShapePointsMarkerType.NONE;
        let mhtype = EShapePointsMarkerType.NONE;
        if (points && points instanceof EShapeLinePoints) {
            const marker = points.getMarker();
            if (marker) {
                mttype = marker.tail.type;
                mhtype = marker.head.type;
            }
        }
        const mtvcount = toMarkerVertexCount(mttype);
        const mticount = toMarkerIndexCount(mttype);
        const mtvoffset = voffset + lvcount;
        const mtioffset = ioffset + licount;
        const mhvcount = toMarkerVertexCount(mhtype);
        const mhicount = toMarkerIndexCount(mhtype);
        const mhvoffset = mtvoffset + mtvcount;
        const mhioffset = mtioffset + mticount;
        // Text
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const tvoffset = mhvoffset + mhvcount;
        const tioffset = mhioffset + mhicount;
        // Uploaded
        const vcount = lvcount + mhvcount + mtvcount + tvcount;
        const icount = licount + mhicount + mticount + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderLine(buffer, voffset, ioffset, lvcount, licount),
                toBuilderMarkerTail(mttype, buffer, mtvoffset, mtioffset),
                toBuilderMarkerHead(mhtype, buffer, mhvoffset, mhioffset),
                new BuilderText(buffer, tvoffset, tioffset, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectorElbowPointsFiller {
        constructor(x, y, values) {
            this._threshold = 0.000001;
            this._x = x;
            this._y = y;
            this._z = 0;
            this._values = values;
            values[0] = x;
            values[1] = y;
            this.index = 0;
        }
        get x() {
            return this._x;
        }
        set x(x) {
            if (this._z === 0 || this._threshold < Math.abs(this._x - x)) {
                this._x = x;
                const index = this.index;
                const values = this._values;
                if (this._z === 1) {
                    values[index + 0] = this._x;
                    values[index + 1] = this._y;
                }
                else {
                    values[index + 2] = this._x;
                    values[index + 3] = this._y;
                    this.index += 2;
                    this._z = 1;
                }
            }
        }
        get y() {
            return this._y;
        }
        set y(y) {
            if (this._z === 0 || this._threshold < Math.abs(this._y - y)) {
                this._y = y;
                const index = this.index;
                const values = this._values;
                if (this._z === 2) {
                    values[index + 0] = this._x;
                    values[index + 1] = this._y;
                }
                else {
                    values[index + 2] = this._x;
                    values[index + 3] = this._y;
                    this.index += 2;
                    this._z = 2;
                }
            }
        }
        toSide(x, y) {
            // y = +x => 0 = x - y
            // y = -x => 0 = x + y
            if (0 <= x - y) {
                if (0 <= x + y) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            else {
                if (0 <= x + y) {
                    return 2;
                }
                else {
                    return 3;
                }
            }
        }
        toAxis(dx, dy, nx, ny, side) {
            // When (nx, ny) === (0, 0), treat as if side === EShapeAcceptorEdgeSide.ALL.
            const anx = Math.abs(nx);
            const any = Math.abs(ny);
            const threshold = this._threshold;
            if (anx < threshold && any < threshold) {
                if (Math.abs(dx) < Math.abs(dy)) {
                    if (0 <= dy) {
                        return 2; // Bottom
                    }
                    else {
                        return 0; // Top
                    }
                }
                else {
                    if (0 <= dx) {
                        return 1; // Right
                    }
                    else {
                        return 3; // Left
                    }
                }
            }
            let d = null;
            let result = 0;
            const dd = dx * dx + dy * dy;
            if (this._threshold < dd) {
                const f = 1 / Math.sqrt(dd);
                const fx = dx * f;
                const fy = dy * f;
                const d0 = +nx * fx + ny * fy;
                const d1 = -ny * fx + nx * fy;
                const d2 = -d0;
                const d3 = -d1;
                if (side & EShapeAcceptorEdgeSide.TOP) {
                    if (d == null || d < d0) {
                        d = d0;
                        result = this.toSide(nx, ny);
                    }
                }
                if (side & EShapeAcceptorEdgeSide.RIGHT) {
                    if (d == null || d < d1) {
                        d = d1;
                        result = this.toSide(-ny, nx);
                    }
                }
                if (side & EShapeAcceptorEdgeSide.BOTTOM) {
                    if (d == null || d < d2) {
                        d = d2;
                        result = this.toSide(-nx, -ny);
                    }
                }
                if (side & EShapeAcceptorEdgeSide.LEFT) {
                    if (d == null || d < d3) {
                        d = d3;
                        result = this.toSide(ny, -nx);
                    }
                }
            }
            return result;
        }
        toTailAxis(x, y, nx, ny, side) {
            return this.toAxis(x - this.x, y - this.y, nx, ny, side);
        }
        tail(x, y, nx, ny, sxh, syh, margin, side) {
            switch (this.toTailAxis(x, y, nx, ny, side)) {
                case 0:
                    if (this.y - margin <= y) {
                        this.y -= Math.max(margin, syh);
                        this.x = x;
                    }
                    else {
                        this.y = y;
                    }
                    break;
                case 1:
                    if (x <= this.x + margin) {
                        this.x += Math.max(margin, sxh);
                        this.y = y;
                    }
                    else {
                        this.x = x;
                    }
                    break;
                case 2:
                    if (y <= this.y + margin) {
                        this.y += Math.max(margin, sxh);
                        this.x = x;
                    }
                    else {
                        this.y = y;
                    }
                    break;
                case 3:
                    if (this.x - margin <= x) {
                        this.x -= Math.max(margin, sxh);
                        this.y = y;
                    }
                    else {
                        this.x = x;
                    }
                    break;
            }
        }
        middle(x, y) {
            const dx = x - this._x;
            const dy = y - this._y;
            if (Math.abs(dx) < Math.abs(dy)) {
                this.y = y;
            }
            else {
                this.x = x;
            }
        }
        toHeadAxis(x, y, nx, ny, side) {
            return this.toAxis(this.x - x, this.y - y, nx, ny, side);
        }
        head(x, y, nx, ny, sxh, syh, margin, side) {
            switch (this.toHeadAxis(x, y, nx, ny, side)) {
                case 0:
                    if (y - margin <= this.y) {
                        this.y = y - Math.max(margin, syh);
                    }
                    this.x = x;
                    this.y = y;
                    break;
                case 1:
                    if (this.x <= x + margin) {
                        this.x = x + Math.max(margin, sxh);
                    }
                    this.y = y;
                    this.x = x;
                    break;
                case 2:
                    if (this.y <= y + margin) {
                        this.y = y + Math.max(margin, syh);
                    }
                    this.x = x;
                    this.y = y;
                    break;
                case 3:
                    if (x - margin <= this.x) {
                        this.x = x - Math.max(margin, sxh);
                    }
                    this.y = y;
                    this.x = x;
                    break;
            }
        }
        margin(tail, head) {
            const values = this._values;
            // Tail
            let index = this.index;
            if (tail !== 0 && 2 <= index) {
                const x0 = values[0];
                const y0 = values[1];
                const dx = values[2] - x0;
                const dy = values[3] - y0;
                const d = dx * dx + dy * dy;
                const threshold = this._threshold;
                if (threshold < d) {
                    const f = tail / Math.sqrt(dx * dx + dy * dy);
                    if (threshold < Math.abs(f - 1)) {
                        values[0] = x0 + dx * f;
                        values[1] = y0 + dy * f;
                    }
                    else {
                        this.index -= 2;
                    }
                }
            }
            // Head
            index = this.index;
            if (head !== 0 && 2 <= index) {
                const x1 = values[index + 0];
                const y1 = values[index + 1];
                const dx = values[index - 2] - x1;
                const dy = values[index - 1] - y1;
                const d = dx * dx + dy * dy;
                const threshold = this._threshold;
                if (threshold < d) {
                    const f = head / Math.sqrt(dx * dx + dy * dy);
                    if (threshold < Math.abs(f - 1)) {
                        values[index + 0] = x1 + dx * f;
                        values[index + 1] = y1 + dy * f;
                    }
                    else {
                        this.index -= 2;
                    }
                }
            }
            // Remote the rest
            values.length = this.index + 2;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectorElbow extends EShapeConnectorLine {
        constructor(type = EShapeType.CONNECTOR_ELBOW) {
            super(type);
        }
        fillPoints(tail, tailMargin, head, headMargin, body, px, py, values) {
            // Tail
            const tailLocal = tail.local;
            const tailLocalX = tailLocal.x;
            const tailLocalY = tailLocal.y;
            const tailNormal = tail.normal;
            const tailNormalX = tailNormal.x;
            const tailNormalY = tailNormal.y;
            const tailSide = tail.side;
            // Head
            const headLocal = head.local;
            const headLocalX = headLocal.x;
            const headLocalY = headLocal.y;
            const headNormal = head.normal;
            const headNormalX = headNormal.x;
            const headNormalY = headNormal.y;
            const headSide = head.side;
            // Body
            const bodyValues = body.values;
            const bodyValuesLength = bodyValues.length;
            // Values
            const x0 = tailLocalX - px;
            const y0 = tailLocalY - py;
            const x1 = headLocalX - px;
            const y1 = headLocalY - py;
            const cx = (x1 + x0) * 0.5;
            const cy = (y1 + y0) * 0.5;
            const dx = x1 - x0;
            const dy = y1 - y0;
            const sxh = 0.5 * EShapeDefaults.SIZE_X;
            const syh = 0.5 * EShapeDefaults.SIZE_Y;
            const threshold = 0.000001;
            if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) {
                values[0] = x0;
                values[1] = y0;
                values[2] = x1;
                values[3] = y1;
                values.length = 4;
            }
            else {
                const filler = new EShapeConnectorElbowPointsFiller(x0, y0, values);
                if (0 < bodyValuesLength) {
                    const a = Math.atan2(dy, dx);
                    const l = Math.sqrt(dx * dx + dy * dy);
                    const c = Math.cos(a) * l;
                    const s = Math.sin(a) * l;
                    const x3 = bodyValues[0];
                    const y3 = bodyValues[1];
                    const x4 = cx + c * x3 - s * y3;
                    const y4 = cy + c * y3 + s * x3;
                    filler.tail(x4, y4, tailNormalX, tailNormalY, sxh, syh, tailMargin, tailSide);
                    for (let i = 2; i < bodyValuesLength; i += 2) {
                        const x = bodyValues[i + 0];
                        const y = bodyValues[i + 1];
                        const x5 = cx + c * x - s * y;
                        const y5 = cy + c * y + s * x;
                        filler.middle(x5, y5);
                    }
                    filler.head(x1, y1, headNormalX, headNormalY, sxh, syh, headMargin, headSide);
                }
                else {
                    filler.tail(cx, cy, tailNormalX, tailNormalY, sxh, syh, tailMargin, tailSide);
                    filler.head(x1, y1, headNormalX, headNormalY, sxh, syh, headMargin, headSide);
                }
                filler.margin(tailMargin, headMargin);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeConnectorElbow = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeConnectorElbow());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeConnectorBodies {
        static from(values, tailMargin, headMargin) {
            const result = [];
            const length = values.length;
            if (4 < length) {
                const threshold = 0.000001;
                let x0 = values[0];
                let y0 = values[1];
                if (tailMargin !== 0) {
                    const ex = x0 - values[2];
                    const ey = y0 - values[3];
                    const n = ex * ex + ey * ey;
                    if (threshold < n) {
                        const f = tailMargin / Math.sqrt(n);
                        x0 += ex * f;
                        y0 += ey * f;
                    }
                }
                let x1 = values[length - 2];
                let y1 = values[length - 1];
                if (headMargin !== 0) {
                    const ex = x1 - values[length - 4];
                    const ey = y1 - values[length - 3];
                    const n = ex * ex + ey * ey;
                    if (threshold < n) {
                        const f = headMargin / Math.sqrt(n);
                        x1 += ex * f;
                        y1 += ey * f;
                    }
                }
                const cx = (x1 + x0) * 0.5;
                const cy = (y1 + y0) * 0.5;
                const dx = x1 - x0;
                const dy = y1 - y0;
                const a = Math.atan2(dy, dx);
                const c = Math.cos(a);
                const s = Math.sin(a);
                const l = dx * dx + dy * dy;
                const m = threshold < l ? 1 / Math.sqrt(l) : 1;
                for (let i = 2, imax = length - 2; i < imax; i += 2) {
                    const x = values[i + 0] - cx;
                    const y = values[i + 1] - cy;
                    result.push((c * x + s * y) * m, (c * y - s * x) * m);
                }
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeConnectorLine = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeConnectorLine());
    };
    const onDeserializedConnectorLine = (item, shape, mapping, manager) => {
        if (shape instanceof EShapeConnectorLine) {
            const resources = manager.resources;
            const resourceId = item[15];
            if (0 <= resourceId && resourceId < resources.length) {
                let parsed = manager.getExtension(resourceId);
                if (parsed == null) {
                    parsed = JSON.parse(resources[resourceId]);
                    manager.setExtension(resourceId, parsed);
                }
                // Lock
                shape.lock(EShapeLockPart.CONNECTOR);
                // Points
                const points = shape.points;
                points.deserialize(parsed[1], manager);
                // Edge
                const edge = shape.edge;
                edge.deserialize(parsed[0], mapping, manager);
                // Body
                const body = shape.body;
                const bodyId = parsed[2];
                if (bodyId != null) {
                    body.deserialize(bodyId, mapping, manager);
                }
                else {
                    // The following is for backward compatibility.
                    body.set(EShapeConnectorBodies.from(points.values, edge.tail.margin, edge.head.margin));
                }
                // Unlock
                shape.unlock(EShapeLockPart.CONNECTOR, true);
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeConnectorElbow = () => {
        EShapeUploadeds[EShapeType.CONNECTOR_ELBOW] = createLineUploaded;
        EShapeDeserializers[EShapeType.CONNECTOR_ELBOW] = deserializeConnectorElbow;
        EShapeOnDeserializeds[EShapeType.CONNECTOR_ELBOW] = onDeserializedConnectorLine;
        EShapeCapabilities.set(EShapeType.CONNECTOR_ELBOW, EShapeCapability.CONNECTOR);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeConnectorLine = () => {
        EShapeUploadeds[EShapeType.CONNECTOR_LINE] = createLineUploaded;
        EShapeDeserializers[EShapeType.CONNECTOR_LINE] = deserializeConnectorLine;
        EShapeOnDeserializeds[EShapeType.CONNECTOR_LINE] = onDeserializedConnectorLine;
        EShapeCapabilities.set(EShapeType.CONNECTOR_LINE, EShapeCapability.CONNECTOR);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderRectanglePivoted extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, RECTANGLE_VERTEX_COUNT, RECTANGLE_INDEX_COUNT);
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        }
        updateVertexStepAndUv(buffer, shape) {
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeSide = stroke.side;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isSizeChanged || isStrokeChanged;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                const voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0.5 * sizeX, 0.5 * sizeY, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, toTextureUvs(texture));
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createRectanglePivotedUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = RECTANGLE_VERTEX_COUNT + tvcount;
        const icount = RECTANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderRectanglePivoted(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + RECTANGLE_VERTEX_COUNT, ioffset + RECTANGLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createGroupUploaded = (buffer, shape, voffset, ioffset) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = tvcount;
        const icount = ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderText(buffer, voffset, ioffset, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const create = (name, width, height, container, manager, item, shape) => {
        const mode = manager.mode;
        const depth = manager.depth;
        shape = shape || new EShapeEmbedded(name, mode, depth);
        const result = deserializeBase(item, manager, shape);
        const shapeSize = shape.size;
        const sizeX = shapeSize.x;
        const sizeY = shapeSize.y;
        shape.size.set(width, height);
        container.copyTo(shape);
        shape.size.init();
        shape.size.set(sizeX, sizeY);
        if (mode === EShapeResourceManagerDeserializationMode.EDITOR) {
            if (0 < depth) {
                applyDataMappings(shape, manager);
            }
        }
        else {
            applyDataMappings(shape, manager);
        }
        return result;
    };
    const createMissing = (name, manager, item, shape) => {
        const mode = manager.mode;
        const depth = manager.depth;
        shape = shape || new EShapeEmbedded(name, mode, depth);
        const result = deserializeBase(item, manager, shape);
        const size = shape.size;
        const sizeX = size.x;
        const sizeY = size.y;
        const children = shape.children;
        const layer = new EShapeEmbeddedLayer("missing", mode, depth);
        const px = 0.5 * sizeX;
        const py = 0.5 * sizeX;
        layer.transform.position.set(-px, -py);
        layer.size.set(sizeX, sizeY);
        layer.size.init();
        layer.parent = shape;
        const rectangle = new EShapeRectangle();
        rectangle.stroke.color = 0xff0000;
        rectangle.transform.position.set(px, py);
        rectangle.size.copyFrom(shape.size);
        rectangle.attach(layer);
        children.push(layer);
        shape.onChildTransformChange();
        shape.toDirty();
        shape.onAttach();
        shape.size.init();
        if (mode === EShapeResourceManagerDeserializationMode.EDITOR) {
            if (0 < depth) {
                applyDataMappings(shape, manager);
            }
        }
        else {
            applyDataMappings(shape, manager);
        }
        return result;
    };
    const applyDataMappings = (shape, manager) => {
        const mapping = shape.data.getMapping();
        if (mapping != null) {
            const values = mapping.values;
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                const source = value[0];
                const mapper = manager.getDataMapper(source);
                if (mapper != null) {
                    const children = shape.children;
                    const destination = manager.getDataDestination(value[1]);
                    const initial = value[2];
                    applyDataMapping(children, mapper, destination, initial);
                }
            }
        }
    };
    const applyDataMapping = (targets, mapper, destination, initial) => {
        for (let i = 0, imax = targets.length; i < imax; ++i) {
            const target = targets[i];
            const targetData = target.data;
            for (let j = 0, jmax = targetData.size(); j < jmax; ++j) {
                const targetDatum = targetData.get(j);
                if (targetDatum && targetDatum.scope !== EShapeDataValueScope.PRIVATE) {
                    mapper.map(targetDatum, destination, initial);
                }
            }
            // Children
            const children = target.children;
            if (0 < children.length) {
                applyDataMapping(children, mapper, destination, initial);
            }
        }
    };
    const deserializeEmbedded = (item, manager, creator) => {
        const pieces = manager.pieces;
        const pieceId = item[15];
        if (pieces && 0 <= pieceId && pieceId < pieces.length) {
            const pieceData = manager.pieceData;
            if (pieceData) {
                const piece = pieces[pieceId];
                const pieceDatum = pieceData.get(piece);
                const shape = creator && creator(piece, manager);
                if (pieceDatum) {
                    return create(piece, pieceDatum.width, pieceDatum.height, pieceDatum.layer, manager, item, shape);
                }
                else {
                    return createMissing(piece, manager, item, shape);
                }
            }
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toSubtype = (target) => {
        const result = EShapeAcceptorEdgeType.ALL & target;
        if (result !== 0) {
            return result;
        }
        return EShapeAcceptorEdgeType.HEAD;
    };
    const toSide = (target) => {
        return (EShapeAcceptorEdgeSide.ALL & (target >> 2));
    };
    const toVvisible = (target) => {
        return 0 < (0x1 & (target >> 6));
    };
    const deserializeEmbeddedAcceptorEdge = (item, manager, shape) => {
        shape !== null && shape !== void 0 ? shape : (shape = new EShapeEmbeddedAcceptorEdge());
        const item15 = item[15];
        shape.subtype = toSubtype(item15);
        shape.side = toSide(item15);
        shape.vvisible = toVvisible(item15);
        const result = deserializeBase(item, manager, shape);
        if (shape.vvisible === false) {
            if (manager.mode === EShapeResourceManagerDeserializationMode.VIEWER) {
                shape.visible = false;
            }
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeEmbedded = () => {
        // Embedded
        EShapeUploadeds[EShapeType.EMBEDDED] = createGroupUploaded;
        EShapeDeserializers[EShapeType.EMBEDDED] = deserializeEmbedded;
        EShapeCapabilities.set(EShapeType.EMBEDDED, EShapeCapability.EMBEDDED);
        // Embedded layer
        EShapeUploadeds[EShapeType.EMBEDDED_LAYER] = createRectanglePivotedUploaded;
        // Embedded acceptor edge
        EShapeUploadeds[EShapeType.EMBEDDED_ACCEPTOR_EDGE] = createCircleUploaded;
        EShapeDeserializers[EShapeType.EMBEDDED_ACCEPTOR_EDGE] = deserializeEmbeddedAcceptorEdge;
        EShapeCapabilities.set(EShapeType.EMBEDDED_ACCEPTOR_EDGE, EShapeCapability.EMBEDDED_ACCEPTOR_EDGE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupFillEditor {
        constructor(parent) {
            this._parent = parent;
        }
        get enable() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].fill.enable;
            }
            return true;
        }
        set enable(enable) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.enable = enable;
            }
        }
        get color() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].fill.color;
            }
            return 0xffffff;
        }
        set color(color) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.color = color;
            }
        }
        get alpha() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].fill.alpha;
            }
            return 1.0;
        }
        set alpha(alpha) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.alpha = alpha;
            }
        }
        copy(target) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.copy(target);
            }
        }
        set(enable, color, alpha) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].fill.set(enable, color, alpha);
            }
        }
        clone() {
            return new EShapeGroupFillEditor(this._parent);
        }
        toObject() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].fill.toObject();
            }
            return {
                enable: true,
                color: 0xffffff,
                alpha: 1.0
            };
        }
        serialize(manager) {
            return -1;
        }
        deserialize(target, manager) {
            // DO NOTHING
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupPoints {
        constructor(parent) {
            this._parent = parent;
        }
        get length() {
            const children = this._parent.children;
            if (0 < children.length) {
                const points = children[children.length - 1].points;
                if (points != null) {
                    return points.length;
                }
            }
            return 0;
        }
        get plength() {
            const children = this._parent.children;
            if (0 < children.length) {
                const points = children[children.length - 1].points;
                if (points != null) {
                    return points.plength;
                }
            }
            return 0;
        }
        get id() {
            const children = this._parent.children;
            if (0 < children.length) {
                const points = children[children.length - 1].points;
                if (points != null) {
                    return points.id;
                }
            }
            return 0;
        }
        get values() {
            const children = this._parent.children;
            if (0 < children.length) {
                const points = children[children.length - 1].points;
                if (points != null) {
                    return points.values;
                }
            }
            return [];
        }
        set values(values) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    points.values = values;
                }
            }
        }
        get segments() {
            const children = this._parent.children;
            if (0 < children.length) {
                const points = children[children.length - 1].points;
                if (points != null) {
                    return points.segments;
                }
            }
            return [];
        }
        set segments(segments) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    points.segments = segments;
                }
            }
        }
        get style() {
            const children = this._parent.children;
            if (0 < children.length) {
                const points = children[children.length - 1].points;
                if (points != null) {
                    return points.style;
                }
            }
            return EShapePointsStyle.NONE;
        }
        set style(style) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    points.style = style;
                }
            }
        }
        get marker() {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    return points.marker;
                }
            }
            return EShapePointsMarkerContainerImplNoop.getInstance();
        }
        getMarker() {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    return points.getMarker();
                }
            }
            return undefined;
        }
        get formatter() {
            const children = this._parent.children;
            if (0 < children.length) {
                const points = children[children.length - 1].points;
                if (points != null) {
                    return points.formatter;
                }
            }
            return null;
        }
        set formatter(formatter) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    points.formatter = formatter;
                }
            }
        }
        get formatted() {
            const children = this._parent.children;
            if (0 < children.length) {
                const points = children[children.length - 1].points;
                if (points != null) {
                    return points.formatted;
                }
            }
            return this;
        }
        onSizeChange() {
            // DO NOTHING
        }
        copy(source) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    points.copy(source);
                }
            }
            return this;
        }
        set(values, segments, style) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    points.set(values, segments, style);
                }
            }
            return this;
        }
        clone(parent) {
            return new EShapeGroupPoints(parent);
        }
        toPoints(transform) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    return points.toPoints(transform);
                }
            }
            return [];
        }
        serialize(manager) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const points = children[i].points;
                if (points != null) {
                    return points.serialize(manager);
                }
            }
            return -1;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupStrokeEditor {
        constructor(parent) {
            this._parent = parent;
        }
        get enable() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.enable;
            }
            return false;
        }
        set enable(enable) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.enable = enable;
            }
        }
        get color() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.color;
            }
            return 0xffffff;
        }
        set color(color) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.color = color;
            }
        }
        get alpha() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.alpha;
            }
            return 1.0;
        }
        set alpha(alpha) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.alpha = alpha;
            }
        }
        get width() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.width;
            }
            return 1.0;
        }
        set width(width) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.width = width;
            }
        }
        get align() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.align;
            }
            return 1.0;
        }
        set align(align) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.align = align;
            }
        }
        get side() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.side;
            }
            return 1.0;
        }
        set side(side) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.side = side;
            }
        }
        get style() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.style;
            }
            return EShapeStrokeStyle.NONE;
        }
        set style(style) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.style = style;
            }
        }
        copy(target) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.copy(target);
            }
        }
        set(enable, color, alpha, width, side) {
            const children = this._parent.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].stroke.set(enable, color, alpha, width, side);
            }
        }
        clone() {
            return new EShapeGroupStrokeEditor(this._parent);
        }
        toObject() {
            const children = this._parent.children;
            if (0 < children.length) {
                return children[children.length - 1].stroke.toObject();
            }
            return {
                enable: false,
                color: 0xffffff,
                alpha: 1.0,
                width: 1.0,
                align: 0.0,
                side: EShapeStrokeSide.NONE,
                style: EShapeStrokeStyle.NONE
            };
        }
        serialize(manager) {
            return -1;
        }
        deserialize(target, manager) {
            //
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroup extends EShapeBase {
        constructor(mode, type = EShapeType.GROUP) {
            super(type);
            this._mode = mode;
            const data = new EShapeDataImpl();
            this.data = data;
            this.tag = data;
            this.size = this.newGroupSize(mode);
            this.fill = this.newGroupFill();
            this.stroke = this.newGroupStroke();
            this.text = this.newGroupText();
            this._points = this.newGroupPoints();
        }
        get mode() {
            return this._mode;
        }
        newGroupSize(mode) {
            const sizeX = EShapeDefaults.SIZE_X;
            const sizeY = EShapeDefaults.SIZE_Y;
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER) {
                return new EShapeGroupSizeEditor(this, sizeX, sizeY, this.isGroupSizeFittable());
            }
            else {
                return new EShapeGroupSizeViewer(this, sizeX, sizeY, sizeX, sizeY);
            }
        }
        isGroupSizeFittable() {
            return true;
        }
        newGroupFill() {
            return new EShapeGroupFillEditor(this);
        }
        newGroupStroke() {
            return new EShapeGroupStrokeEditor(this);
        }
        newGroupText() {
            return new EShapeTextImpl(this, EShapeDefaults.TEXT_VALUE, EShapeDefaults.TEXT_COLOR, EShapeDefaults.TEXT_ALPHA, EShapeDefaults.TEXT_FAMILY, EShapeDefaults.TEXT_SIZE);
        }
        newGroupPoints() {
            return new EShapeGroupPoints(this);
        }
        getBoundsSize() {
            const size = this.size;
            if (size instanceof EShapeGroupSizeViewer) {
                return size.base;
            }
            else {
                return size;
            }
        }
        onChildTransformChange() {
            super.onChildTransformChange();
            this.size.fit();
        }
        get corner() {
            const children = this.children;
            if (0 < children.length) {
                return children[children.length - 1].corner;
            }
            return EShapeCorner.ALL;
        }
        set corner(corner) {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].corner = corner;
            }
        }
        get gradient() {
            const children = this.children;
            for (let i = children.length - 1; 0 <= i; --i) {
                const gradient = children[i].gradient;
                if (gradient != null) {
                    return gradient;
                }
            }
            return undefined;
        }
        set gradient(gradient) {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].gradient = gradient;
            }
        }
        serializeGradient(manager) {
            return -1;
        }
        get radius() {
            const children = this.children;
            if (0 < children.length) {
                return children[children.length - 1].radius;
            }
            return 0.5;
        }
        set radius(radius) {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].radius = radius;
            }
        }
        get image() {
            const children = this.children;
            for (let i = children.length - 1; 0 <= i; --i) {
                const image = children[i].image;
                if (image != null) {
                    return image;
                }
            }
            return undefined;
        }
        set image(image) {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                children[i].image = image;
            }
        }
        serializeImage(manager) {
            return -1;
        }
        get points() {
            const children = this.children;
            for (let i = children.length - 1; 0 <= i; --i) {
                const points = children[i].points;
                if (points != null) {
                    return this._points;
                }
            }
            return undefined;
        }
        set points(points) {
            // DO NOTHING
        }
        clone() {
            const result = this.newClone().copy(this);
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const clone = children[i].clone();
                clone.parent = result;
                result.children.push(clone);
            }
            EShapeConnectors.moveAll(children, result.children, children, result.children);
            result.onChildTransformChange();
            result.toDirty();
            return result;
        }
        newClone() {
            const constructor = this.constructor;
            return new constructor(this._mode, this.type);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeGroup = (item, manager, shape) => {
        shape = shape || new EShapeGroup(manager.mode);
        const result = deserializeBase(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeGroup = () => {
        EShapeUploadeds[EShapeType.GROUP] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP] = deserializeGroup;
        EShapeCapabilities.set(EShapeType.GROUP, EShapeCapability.GROUP);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupSizeShadowed {
        constructor(parent, x, y) {
            this._parent = parent;
            this._size = new pixi_js.Point(x, y);
        }
        init() {
            return this;
        }
        get x() {
            return this._size.x;
        }
        set x(x) {
            const size = this._size;
            if (size.x !== x) {
                const ox = size.x;
                size.x = x;
                this.onChange(ox, size.y);
            }
        }
        get y() {
            return this._size.y;
        }
        set y(y) {
            const size = this._size;
            if (size.y !== y) {
                const oy = size.y;
                size.y = y;
                this.onChange(size.x, oy);
            }
        }
        set(x, y) {
            let isChanged = false;
            const size = this._size;
            const ox = size.x;
            const oy = size.y;
            if (x != null && ox !== x) {
                isChanged = true;
                size.x = x;
            }
            if (y != null && oy !== y) {
                isChanged = true;
                size.y = y;
            }
            if (isChanged) {
                this.onChange(ox, oy);
            }
            return this;
        }
        clone() {
            const size = this._size;
            return new EShapeGroupSizeShadowed(this._parent, size.x, size.y);
        }
        copy() {
            // DO NOTHING
        }
        copyFrom(point) {
            const x = point.x;
            const y = point.y;
            const size = this._size;
            const ox = size.x;
            const oy = size.y;
            if (ox !== x || oy !== y) {
                size.x = x;
                size.y = y;
                this.onChange(ox, oy);
            }
            return this;
        }
        copyTo(point) {
            return this._size.copyTo(point);
        }
        equals(point) {
            return this._size.equals(point);
        }
        fit() {
            return this;
        }
        onChange(ox, oy) {
            this._parent.onSizeChange();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeGroupShadowed extends EShapeGroup {
        constructor(mode, type = EShapeType.GROUP_SHADOWED) {
            super(mode, type);
        }
        newGroupSize(mode) {
            if (mode !== EShapeResourceManagerDeserializationMode.VIEWER) {
                return new EShapeGroupSizeShadowed(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            }
            else {
                return super.newGroupSize(mode);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeGroupShadowed = (item, manager, shape) => {
        shape = shape || new EShapeGroupShadowed(manager.mode);
        const result = deserializeBase(item, manager, shape);
        shape.size.init();
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeGroupShadowed = () => {
        EShapeUploadeds[EShapeType.GROUP_SHADOWED] = createGroupUploaded;
        EShapeDeserializers[EShapeType.GROUP_SHADOWED] = deserializeGroupShadowed;
        EShapeCapabilities.set(EShapeType.GROUP_SHADOWED, EShapeCapability.GROUP);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderRectangle extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, RECTANGLE_VERTEX_COUNT, RECTANGLE_INDEX_COUNT);
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            buildRectangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        }
        updateVertexStepAndUv(buffer, shape) {
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeSide = stroke.side;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isSizeChanged || isStrokeChanged;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Vertices
                const voffset = this.vertexOffset;
                buffer.updateVertices();
                buildRectangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, RECTANGLE_WORLD_SIZE);
                // Steps
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildRectangleStep(voffset, buffer.steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                }
                // UVs
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildRectangleUv(buffer.uvs, voffset, toTextureUvs(texture));
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createRectangleUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = RECTANGLE_VERTEX_COUNT + tvcount;
        const icount = RECTANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderRectangle(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + RECTANGLE_VERTEX_COUNT, ioffset + RECTANGLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeImage extends EShapeRectangle {
        constructor(image, type = EShapeType.IMAGE) {
            super(type);
            if (image != null) {
                this.image = image;
                this.size.set(image.width, image.height);
            }
            this.fill.alpha = 1;
        }
        clone() {
            return new EShapeImage(this.image, this.type).copy(this);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeImage = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeImage());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeImage = () => {
        EShapeUploadeds[EShapeType.IMAGE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.IMAGE] = deserializeImage;
    };

    const IMAGE_SDF_VERTEX_COUNT = 9;
    const IMAGE_SDF_INDEX_COUNT = 8;
    const IMAGE_SDF_WORLD_SIZE = [0, 0];
    const IMAGE_SDF_WORK_POINT = new pixi_js.Point();
    const buildImageSdfIndex = (indices, voffset, ioffset) => {
        let ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 7;
    };
    const buildImageSdfStep = (steps, voffset, strokeAlign, strokeWidth, strokeStyle, textureWidth, textureHeight, worldSize) => {
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const e = toPackedI4x64(2, scaleInvariant, 1, 1);
        const scaleX = textureWidth / worldSize[0];
        const scaleY = textureHeight / worldSize[1];
        const scaleZ = (scaleX + scaleY) * 0.5;
        const strokeWidthRatio = strokeWidth / 12.0;
        const position = -1 + strokeAlign;
        let is = voffset * 6 - 1;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleZ;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleY;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleZ;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleX;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleZ;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleX;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleZ;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleY;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
        steps[++is] = strokeWidthRatio;
        steps[++is] = e;
        steps[++is] = scaleY;
        steps[++is] = position;
        steps[++is] = 0;
        steps[++is] = 0;
    };
    const buildImageSdfVertex = (vertices, voffset, originX, originY, sizeX, sizeY, internalTransform, worldSize) => {
        // Calculate the transformed positions
        //
        // 0       1       2
        // |-------|-------|
        // |       |       |
        // 3-------4-------5
        // |       |       |
        // |-------|-------|
        // 6       7       8
        //
        const work = IMAGE_SDF_WORK_POINT;
        const sx = sizeX * 0.5;
        const sy = sizeY * 0.5;
        work.set(originX - sx, originY - sy);
        internalTransform.apply(work, work);
        const x0 = work.x;
        const y0 = work.y;
        work.set(originX + sx, originY - sy);
        internalTransform.apply(work, work);
        const x2 = work.x;
        const y2 = work.y;
        work.set(originX + sx, originY + sy);
        internalTransform.apply(work, work);
        const x8 = work.x;
        const y8 = work.y;
        const x6 = x0 + (x8 - x2);
        const y6 = y0 + (y8 - y2);
        // Vertices
        let iv = (voffset << 1) - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = (x0 + x2) * 0.5;
        vertices[++iv] = (y0 + y2) * 0.5;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = (x0 + x6) * 0.5;
        vertices[++iv] = (y0 + y6) * 0.5;
        vertices[++iv] = (x0 + x8) * 0.5;
        vertices[++iv] = (y0 + y8) * 0.5;
        vertices[++iv] = (x2 + x8) * 0.5;
        vertices[++iv] = (y2 + y8) * 0.5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = (x6 + x8) * 0.5;
        vertices[++iv] = (y6 + y8) * 0.5;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        worldSize[0] = toLength(x0, y0, x2, y2) * 0.5;
        worldSize[1] = toLength(x0, y0, x6, y6) * 0.5;
    };
    const buildImageSdfUv = (uvs, voffset, textureUv) => {
        const x0 = textureUv.x0;
        const y0 = textureUv.y0;
        const x1 = textureUv.x1;
        const y1 = textureUv.y1;
        const x2 = textureUv.x2;
        const y2 = textureUv.y2;
        const x3 = textureUv.x3;
        const y3 = textureUv.y3;
        let iv = (voffset << 1) - 1;
        uvs[++iv] = x0;
        uvs[++iv] = y0;
        uvs[++iv] = (x1 + x0) * 0.5;
        uvs[++iv] = (y1 + y0) * 0.5;
        uvs[++iv] = x1;
        uvs[++iv] = y1;
        uvs[++iv] = (x0 + x3) * 0.5;
        uvs[++iv] = (y0 + y3) * 0.5;
        uvs[++iv] = (x0 + x2) * 0.5;
        uvs[++iv] = (y0 + y2) * 0.5;
        uvs[++iv] = (x1 + x2) * 0.5;
        uvs[++iv] = (y1 + y2) * 0.5;
        uvs[++iv] = x3;
        uvs[++iv] = y3;
        uvs[++iv] = (x3 + x2) * 0.5;
        uvs[++iv] = (y3 + y2) * 0.5;
        uvs[++iv] = x2;
        uvs[++iv] = y2;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderImageSdf extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, IMAGE_SDF_VERTEX_COUNT, IMAGE_SDF_INDEX_COUNT);
            this.textureWidth = -1;
            this.textureHeight = -1;
        }
        init() {
            const voffset = this.vertexOffset;
            const buffer = this.buffer;
            buffer.updateIndices();
            buildImageSdfIndex(buffer.indices, voffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        }
        updateVertexAndStep(buffer, shape) {
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const texture = toTexture(shape);
            const textureWidth = texture.width * texture.resolution;
            const textureHeight = texture.height * texture.resolution;
            const isTextureSizeChanged = this.textureWidth !== textureWidth || this.textureHeight !== textureHeight;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited ||
                isSizeChanged ||
                isTransformChanged ||
                isStrokeChanged ||
                isTextureSizeChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.textureWidth = textureWidth;
                this.textureHeight = textureHeight;
                // Vertices
                buffer.updateVertices();
                buildImageSdfVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, shape.transform.internalTransform, IMAGE_SDF_WORLD_SIZE);
                // Steps
                buffer.updateSteps();
                buildImageSdfStep(buffer.steps, this.vertexOffset, strokeAlign, strokeWidth, strokeStyle, textureWidth, textureHeight, IMAGE_SDF_WORLD_SIZE);
            }
        }
        updateUv(buffer, shape) {
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                buildImageSdfUv(buffer.uvs, this.vertexOffset, toTextureUvs(texture));
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createImageSdfUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = IMAGE_SDF_VERTEX_COUNT + tvcount;
        const icount = IMAGE_SDF_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderImageSdf(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + IMAGE_SDF_VERTEX_COUNT, ioffset + IMAGE_SDF_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeImageSdf extends EShapeImage {
        constructor(image, type = EShapeType.IMAGE_SDF) {
            super(image, type);
        }
        clone() {
            return new EShapeImageSdf(this.image, this.type).copy(this);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeImageSdf = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeImageSdf());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeImageSdf = () => {
        EShapeUploadeds[EShapeType.IMAGE_SDF] = createImageSdfUploaded;
        EShapeDeserializers[EShapeType.IMAGE_SDF] = deserializeImageSdf;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderLabel {
        constructor(buffer, vertexOffset, indexOffset) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            this.vertexCount = 0;
            this.indexCount = 0;
            this.texture = null;
        }
        init() {
            return this;
        }
        reinit(buffer, shape, vertexOffset, indexOffset) {
            this.buffer = buffer;
            this.vertexOffset = vertexOffset;
            this.indexOffset = indexOffset;
            return true;
        }
        isCompatible(shape) {
            return true;
        }
        update(shape) {
            this.texture = toTexture(shape);
        }
        buildUnit(builder) {
            const texture = this.texture || pixi_js.Texture.WHITE;
            const baseTexture = texture.baseTexture;
            if (baseTexture !== builder.baseTexture) {
                builder.baseTexture = baseTexture;
                const indexOffset = this.indexOffset;
                builder.push(texture, indexOffset);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createLabelUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = tvcount;
        const icount = ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderLabel(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset, ioffset, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLabel extends EShapePrimitive {
        constructor(type = EShapeType.LABEL) {
            super(type);
        }
        clone() {
            return new EShapeLabel(this.type).copy(this);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeLabel = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeLabel());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeLabel = () => {
        EShapeUploadeds[EShapeType.LABEL] = createLabelUploaded;
        EShapeDeserializers[EShapeType.LABEL] = deserializeLabel;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLine extends EShapeLineBase {
        constructor(type = EShapeType.LINE) {
            super(type);
            this._points = new EShapeLinePoints(this);
        }
        get points() {
            return this._points;
        }
        clone() {
            return new EShapeLine(this.type).copy(this);
        }
        serialize(manager) {
            const result = super.serialize(manager);
            result[15] = this._points.serialize(manager);
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeLine = (item, manager, shape) => {
        shape = shape || new EShapeLine();
        const result = deserializeBase(item, manager, shape);
        shape.points.deserialize(item[15], manager);
        const style = shape.points.style;
        const mask = EShapePointsStyle.NON_SCALING_MASK |
            EShapePointsStyle.DOTTED_MASK |
            EShapePointsStyle.DASHED_MASK;
        const deprecated = style & mask;
        if (deprecated) {
            shape.points.style &= ~mask;
            shape.stroke.style |= deprecated;
        }
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeLine = () => {
        EShapeUploadeds[EShapeType.LINE] = createLineUploaded;
        EShapeDeserializers[EShapeType.LINE] = deserializeLine;
    };

    const buildNullIndex = (indices, voffset, ioffset, icount) => {
        for (let ii = ioffset * 3, iimax = (ioffset + icount) * 3; ii < iimax; ii += 3) {
            indices[ii + 0] = voffset;
            indices[ii + 1] = voffset;
            indices[ii + 2] = voffset;
        }
    };
    const buildNullVertex = (vertices, voffset, vcount) => {
        for (let i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            vertices[i + 0] = 0;
            vertices[i + 1] = 0;
        }
    };
    const buildNullStep = (steps, voffset, vcount) => {
        for (let i = voffset * 6, imax = (voffset + vcount) * 6; i < imax; i += 6) {
            steps[i + 0] = 0;
            steps[i + 1] = 0;
            steps[i + 2] = 0;
            steps[i + 3] = 0;
            steps[i + 4] = 0;
            steps[i + 5] = 0;
        }
    };
    const buildNullUv = (uvs, voffset, vcount) => {
        for (let i = voffset * 2, imax = (voffset + vcount) * 2; i < imax; i += 2) {
            uvs[i + 0] = 0;
            uvs[i + 1] = 0;
        }
    };

    const toLineOfAnyPointCount = (pointCount) => {
        return ((pointCount >> 4) + (0 < (pointCount & 0xf) ? 1 : 0)) << 4;
    };
    /**
     * Build a vertex buffer of colors.
     *
     * @param vo Vertex pffset
     * @param vcpp Vertex count per point
     * @param pf Point Fill
     * @param ps Point stroke
     * @param pc Point count
     * @param colors Vertex buffer of colors
     * @param ife True if fills are enabled
     * @param ise True if strokes are enabled
     * @param cfd Default fill color
     * @param afd Default fill alpha
     * @param csd Default stroke color
     * @param asd Default stroke alpha
     */
    const buildLineOfAnyColor = (vo, vcpp, pf, ps, pc, colors, ife, ise, cfd, afd, csd, asd) => {
        if (ife) {
            if (pf.isStaticColor()) {
                const cf = pf.getColor(0, cfd);
                if (pf.isStaticAlpha()) {
                    const af = pf.getAlpha(0, afd);
                    buildLineOfAnyColor0(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, af);
                }
                else {
                    buildLineOfAnyColor1(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, afd);
                }
            }
            else {
                if (pf.isStaticAlpha()) {
                    const af = pf.getAlpha(0, afd);
                    buildLineOfAnyColor2(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, af);
                }
                else {
                    buildLineOfAnyColor3(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, afd);
                }
            }
        }
        else {
            if (pf.isStaticColor()) {
                const cf = pf.getColor(0, cfd);
                buildLineOfAnyColor0(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, 0);
            }
            else {
                buildLineOfAnyColor2(vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, 0);
            }
        }
    };
    const buildLineOfAnyColor0 = (vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, af) => {
        if (ise) {
            if (ps.isStaticColor()) {
                const cs = ps.getColor(0, csd);
                if (ps.isStaticAlpha()) {
                    const as = ps.getAlpha(0, asd);
                    buildColor(cf, af, cs, as, vo, vcpp * pc, colors);
                }
                else {
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
            else {
                if (ps.isStaticAlpha()) {
                    const as = ps.getAlpha(0, asd);
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cs = ps.getColor(i, csd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cs = ps.getColor(i, csd);
                        const as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
        }
        else {
            if (ps.isStaticColor()) {
                const cs = ps.getColor(0, csd);
                buildColor(cf, af, cs, 0, vo, vcpp * pc, colors);
            }
            else {
                for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    const cs = ps.getColor(i, csd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
        }
    };
    const buildLineOfAnyColor1 = (vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cf, afd) => {
        if (ise) {
            if (ps.isStaticColor()) {
                const cs = ps.getColor(0, csd);
                if (ps.isStaticAlpha()) {
                    const as = ps.getAlpha(0, asd);
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const af = pf.getAlpha(i, afd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const af = pf.getAlpha(i, afd);
                        const as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
            else {
                if (ps.isStaticAlpha()) {
                    const as = ps.getAlpha(0, asd);
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const af = pf.getAlpha(i, afd);
                        const cs = ps.getColor(i, csd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const af = pf.getAlpha(i, afd);
                        const cs = ps.getColor(i, csd);
                        const as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
        }
        else {
            if (ps.isStaticColor()) {
                const cs = ps.getColor(0, csd);
                for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    const af = pf.getAlpha(i, afd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
            else {
                for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    const af = pf.getAlpha(i, afd);
                    const cs = ps.getColor(i, csd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
        }
    };
    const buildLineOfAnyColor2 = (vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, af) => {
        if (ise) {
            if (ps.isStaticColor()) {
                const cs = ps.getColor(0, csd);
                if (ps.isStaticAlpha()) {
                    const as = ps.getAlpha(0, asd);
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cf = pf.getColor(i, cfd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cf = pf.getColor(i, cfd);
                        const as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
            else {
                if (ps.isStaticAlpha()) {
                    const as = ps.getAlpha(0, asd);
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cf = pf.getColor(i, cfd);
                        const cs = ps.getColor(i, csd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cf = pf.getColor(i, cfd);
                        const cs = ps.getColor(i, csd);
                        const as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
        }
        else {
            if (ps.isStaticColor()) {
                const cs = ps.getColor(0, csd);
                for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    const cf = pf.getColor(i, cfd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
            else {
                for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    const cf = pf.getColor(i, cfd);
                    const cs = ps.getColor(i, csd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
        }
    };
    const buildLineOfAnyColor3 = (vo, vcpp, pf, ps, pc, colors, ise, csd, asd, cfd, afd) => {
        if (ise) {
            if (ps.isStaticColor()) {
                const cs = ps.getColor(0, csd);
                if (ps.isStaticAlpha()) {
                    const as = ps.getAlpha(0, asd);
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cf = pf.getColor(i, cfd);
                        const af = pf.getAlpha(i, afd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cf = pf.getColor(i, cfd);
                        const af = pf.getAlpha(i, afd);
                        const as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
            else {
                if (ps.isStaticAlpha()) {
                    const as = ps.getAlpha(0, asd);
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cf = pf.getColor(i, cfd);
                        const af = pf.getAlpha(i, afd);
                        const cs = ps.getColor(i, csd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
                else {
                    for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                        const cf = pf.getColor(i, cfd);
                        const af = pf.getAlpha(i, afd);
                        const cs = ps.getColor(i, csd);
                        const as = ps.getAlpha(i, asd);
                        buildColor(cf, af, cs, as, iv, vcpp, colors);
                    }
                }
            }
        }
        else {
            if (ps.isStaticColor()) {
                const cs = ps.getColor(0, csd);
                for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    const cf = pf.getColor(i, cfd);
                    const af = pf.getAlpha(i, afd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
            else {
                for (let i = 0, iv = vo; i < pc; i += 1, iv += vcpp) {
                    const cf = pf.getColor(i, cfd);
                    const af = pf.getAlpha(i, afd);
                    const cs = ps.getColor(i, csd);
                    buildColor(cf, af, cs, 0, iv, vcpp, colors);
                }
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderLineOfAny extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint) {
            super(buffer, vertexOffset, indexOffset, vertexCount, indexCount);
            this.pointId = -1;
            this.pointCount = 0;
            this.pointCountReserved = pointCountReserved;
            this.pointSizeId = -1;
            this.pointOffsetId = -1;
            this.pointFillId = -1;
            this.pointStrokeId = -1;
            this.vcountPerPoint = vcountPerPoint;
            this.icountPerPoint = icountPerPoint;
        }
        reinit(buffer, shape, vertexOffset, indexOffset) {
            const pointCount = toLineOfAnyPointCount(toPointCount(shape.points));
            if (this.buffer !== buffer ||
                this.vertexOffset !== vertexOffset ||
                this.indexOffset !== indexOffset ||
                this.pointCountReserved !== pointCount) {
                const vertexCount = pointCount * this.vcountPerPoint;
                const indexCount = pointCount * this.icountPerPoint;
                if (buffer.check(vertexOffset, indexOffset, vertexCount, indexCount)) {
                    this.inited = BuilderFlag.NONE;
                    this.buffer = buffer;
                    this.vertexOffset = vertexOffset;
                    this.indexOffset = indexOffset;
                    this.vertexCount = vertexCount;
                    this.indexCount = indexCount;
                    this.pointCountReserved = pointCount;
                    this.init();
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        }
        isCompatible(shape) {
            const pointCount = toLineOfAnyPointCount(toPointCount(shape.points));
            return pointCount === this.pointCountReserved;
        }
        updateLineOfAnyColor(buffer, shape, points, vcountPerPoint) {
            const pointFill = points.fill;
            const pointFillId = pointFill.id;
            const isPointFillChanged = pointFillId !== this.pointFillId;
            const fill = shape.fill;
            const isFillEnabled = shape.visible && fill.enable;
            const colorFill = fill.color;
            const alphaFill = isFillEnabled ? fill.alpha : 0;
            const isFillChanged = colorFill !== this.colorFill || alphaFill !== this.alphaFill;
            const pointStroke = points.stroke;
            const pointStrokeId = pointStroke.id;
            const isPointStrokeChanged = pointStrokeId !== this.pointStrokeId;
            const stroke = shape.stroke;
            const isStrokeEnabled = shape.visible && stroke.enable;
            const colorStroke = stroke.color;
            const alphaStroke = isStrokeEnabled ? stroke.alpha : 0;
            const isStrokeChanged = colorStroke !== this.colorStroke || alphaStroke !== this.alphaStroke;
            const isNotInited = !(this.inited & BuilderFlag.COLOR);
            if (isNotInited ||
                isPointFillChanged ||
                isFillChanged ||
                isPointStrokeChanged ||
                isStrokeChanged) {
                this.inited |= BuilderFlag.COLOR;
                this.colorFill = colorFill;
                this.alphaFill = alphaFill;
                this.pointFillId = pointFillId;
                this.colorStroke = colorStroke;
                this.alphaStroke = alphaStroke;
                this.pointStrokeId = pointStrokeId;
                buffer.updateColors();
                buildLineOfAnyColor(this.vertexOffset, vcountPerPoint, pointFill, pointStroke, this.pointCountReserved, buffer.colors, isFillEnabled, isStrokeEnabled, colorFill, alphaFill, colorStroke, alphaStroke);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const copyIndex = (indices, vcountPerPoint, ioffset, icountPerPoint, pointCount) => {
        let idiv = vcountPerPoint;
        let ii = ioffset + icountPerPoint;
        for (let i = 1; i < pointCount; ++i) {
            let iid = ii * 3;
            let iis = ioffset * 3;
            for (let j = 0; j < icountPerPoint; ++j) {
                indices[iid + 0] = indices[iis + 0] + idiv;
                indices[iid + 1] = indices[iis + 1] + idiv;
                indices[iid + 2] = indices[iis + 2] + idiv;
                iid += 3;
                iis += 3;
            }
            idiv += vcountPerPoint;
            ii += icountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const copyStep = (steps, voffset, vcountPerPoint, pointCount) => {
        const iss0 = voffset * 6;
        let isd = (voffset + vcountPerPoint) * 6;
        for (let i = 1; i < pointCount; ++i) {
            let iss = iss0;
            for (let j = 0; j < vcountPerPoint; ++j) {
                steps[isd + 0] = steps[iss + 0];
                steps[isd + 1] = steps[iss + 1];
                steps[isd + 2] = steps[iss + 2];
                steps[isd + 3] = steps[iss + 3];
                steps[isd + 4] = steps[iss + 4];
                steps[isd + 5] = steps[iss + 5];
                isd += 6;
                iss += 6;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const copyUvs = (uvs, voffset, vcountPerPoint, pointCount) => {
        let iv = voffset + vcountPerPoint;
        for (let i = 1; i < pointCount; ++i) {
            let iuvd = iv << 1;
            let iuvs = voffset << 1;
            for (let j = 0; j < vcountPerPoint; ++j) {
                uvs[iuvd] = uvs[iuvs];
                uvs[iuvd + 1] = uvs[iuvs + 1];
                iuvd += 2;
                iuvs += 2;
            }
            iv += vcountPerPoint;
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const copyVertex = (vertices, internalTransform, voffset, vcountPerPoint, pointCount, pointsValues, pointOffset) => {
        const a = internalTransform.a;
        const b = internalTransform.b;
        const c = internalTransform.c;
        const d = internalTransform.d;
        let i = pointCount - 1;
        let iv = voffset + i * vcountPerPoint;
        if (pointOffset.isStaticX() && pointOffset.isStaticY()) {
            const ox = pointOffset.getX(0);
            const oy = pointOffset.getY(0);
            for (; 0 <= i; --i) {
                const ip = i << 1;
                const px = pointsValues[ip] + ox;
                const py = pointsValues[ip + 1] + oy;
                const dx = a * px + c * py;
                const dy = b * px + d * py;
                let ivd = iv << 1;
                let ivs = voffset << 1;
                for (let j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
        else {
            for (; 0 <= i; --i) {
                const ip = i << 1;
                const px = pointsValues[ip] + pointOffset.getX(i);
                const py = pointsValues[ip + 1] + pointOffset.getY(i);
                const dx = a * px + c * py;
                const dy = b * px + d * py;
                let ivd = iv << 1;
                let ivs = voffset << 1;
                for (let j = 0; j < vcountPerPoint; ++j) {
                    vertices[ivd] = vertices[ivs] + dx;
                    vertices[ivd + 1] = vertices[ivs + 1] + dy;
                    ivd += 2;
                    ivs += 2;
                }
                iv -= vcountPerPoint;
            }
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const isStatic = (value) => {
        return isNumber(value) || value == null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toComputed = (index, value, def) => {
        if (isNumber(value)) {
            return value;
        }
        else if (isFunction(value)) {
            return value(index);
        }
        else if (value) {
            return value[index % value.length];
        }
        return def;
    };

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineOfAnyPointsFillImpl {
        constructor(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        get id() {
            return this._id;
        }
        get color() {
            return this._color;
        }
        set color(color) {
            this.set(color, undefined);
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            this.set(undefined, alpha);
        }
        set(color, alpha) {
            let isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        }
        getColor(index, def) {
            return toComputed(index, this._color, def);
        }
        getAlpha(index, def) {
            return toComputed(index, this._alpha, def);
        }
        isStaticColor() {
            return isStatic(this._color);
        }
        isStaticAlpha() {
            return isStatic(this._alpha);
        }
        toDirty() {
            this._id += 1;
        }
    }

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineOfAnyPointsPointImpl {
        constructor(parent, defX, defY) {
            this._parent = parent;
            this._id = 0;
            this._x = null;
            this._y = null;
            this._defX = defX;
            this._defY = defY;
            this._limit = null;
            this._limitComputed = 0;
            this._limitId = -1;
            this._limitParentLength = 0;
        }
        get id() {
            return this._id;
        }
        get x() {
            return this._x;
        }
        set x(x) {
            this.set(x, undefined);
        }
        get y() {
            return this._y;
        }
        set y(y) {
            this.set(undefined, y);
        }
        get limit() {
            return this._limit;
        }
        set limit(limit) {
            this._limit = limit;
        }
        set(x, y) {
            let isChanged = false;
            if (x !== undefined && this._x !== x) {
                isChanged = true;
                this._x = x;
            }
            if (y !== undefined && this._y !== y) {
                isChanged = true;
                this._y = y;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        }
        getX(index) {
            return toComputed(index, this._x, this._defX);
        }
        getY(index) {
            return toComputed(index, this._y, this._defY);
        }
        getLimit() {
            const limit = this._limit;
            if (limit != null) {
                return limit;
            }
            this.updateLimitComputed();
            return this._limitComputed;
        }
        updateLimitComputed() {
            const limitId = this._id;
            const parent = this._parent;
            const limitParentLength = parent.length;
            if (this._limitId !== limitId || this._limitParentLength !== limitParentLength) {
                this._limitId = limitId;
                this._limitParentLength = limitParentLength;
                this._limitComputed = Math.max(this.calcLimit(this._x, limitParentLength, this._defX), this.calcLimit(this._y, limitParentLength, this._defY));
            }
        }
        calcLimit(value, parentLenght, def) {
            if (isNumber(value)) {
                return Math.abs(value);
            }
            else if (isFunction(value)) {
                if (0 < parentLenght) {
                    let result = Math.abs(value(0));
                    for (let i = 1; i < parentLenght; ++i) {
                        result = Math.max(result, Math.abs(value(i)));
                    }
                    return result;
                }
                return 0;
            }
            else if (value != null) {
                const l = value.length;
                if (0 < l) {
                    let result = value[0];
                    for (let i = 1; i < l; ++i) {
                        result = Math.max(result, Math.abs(value[i]));
                    }
                    return result;
                }
                return 0;
            }
            else {
                return Math.abs(def);
            }
        }
        isStaticX() {
            return isStatic(this._x);
        }
        isStaticY() {
            return isStatic(this._y);
        }
        toDirty() {
            this._id += 1;
        }
    }

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineOfAnyPointsStrokeImpl {
        constructor(parent) {
            this._parent = parent;
            this._id = 0;
            this._color = null;
            this._alpha = null;
        }
        get id() {
            return this._id;
        }
        get color() {
            return this._color;
        }
        set color(color) {
            this.set(color, undefined);
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            this.set(undefined, alpha);
        }
        set(color, alpha) {
            let isChanged = false;
            if (color !== undefined && this._color !== color) {
                isChanged = true;
                this._color = color;
            }
            if (alpha !== undefined && this._alpha !== alpha) {
                isChanged = true;
                this._alpha = alpha;
            }
            if (isChanged) {
                this._id += 1;
                this._parent.updateUploaded();
            }
        }
        getColor(index, def) {
            return toComputed(index, this._color, def);
        }
        getAlpha(index, def) {
            return toComputed(index, this._alpha, def);
        }
        isStaticColor() {
            return isStatic(this._color);
        }
        isStaticAlpha() {
            return isStatic(this._alpha);
        }
        toDirty() {
            this._id += 1;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineOfAnyPointsImpl {
        constructor(parent) {
            this._parent = parent;
            this._values = [];
            this._valuesLength = 0;
            this._segments = [];
            this._length = 0;
            this._plength = 0;
            this._size = new EShapeLineOfAnyPointsPointImpl(this, EShapeDefaults.SIZE_X, EShapeDefaults.SIZE_Y);
            this._offset = new EShapeLineOfAnyPointsPointImpl(this, 0, 0);
            this._fill = new EShapeLineOfAnyPointsFillImpl(parent);
            this._stroke = new EShapeLineOfAnyPointsStrokeImpl(parent);
            this._id = 0;
        }
        get length() {
            return this._length;
        }
        get plength() {
            return this._plength;
        }
        get id() {
            return this._id;
        }
        get values() {
            return this._values;
        }
        set values(values) {
            this.set(values, undefined, undefined);
        }
        get segments() {
            return this._segments;
        }
        set segments(segments) {
            // DO NOTHING
        }
        get style() {
            return EShapePointsStyle.NONE;
        }
        set style(style) {
            this.set(undefined, undefined, style);
        }
        get marker() {
            let result = this._marker;
            if (result == null) {
                result = EShapePointsMarkerContainerImplNoop.getInstance();
                this._marker = result;
            }
            return result;
        }
        getMarker() {
            return undefined;
        }
        get size() {
            return this._size;
        }
        get offset() {
            return this._offset;
        }
        get fill() {
            return this._fill;
        }
        get stroke() {
            return this._stroke;
        }
        get formatter() {
            return null;
        }
        set formatter(formatter) {
            // DO NOTHING
        }
        get formatted() {
            return this;
        }
        onSizeChange() {
            // DO NOTHING
        }
        toFitted(x, y) {
            // DO NOTHING
        }
        copy(source) {
            return this.set(source.values, source.segments, source.style);
        }
        set(newValues, newSegments, newStyle) {
            let isDirty = false;
            let isUpdated = false;
            // Values
            if (newValues != null) {
                const values = this._values;
                const valuesLength = this._valuesLength;
                const newValuesLength = newValues.length;
                if (values !== newValues) {
                    const iupdate = Math.min(valuesLength, newValuesLength);
                    for (let i = 0; i < iupdate; ++i) {
                        values[i] = newValues[i];
                    }
                    for (let i = iupdate; i < newValuesLength; ++i) {
                        values.push(newValues[i]);
                    }
                    if (valuesLength !== newValuesLength) {
                        values.length = newValuesLength;
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
                else {
                    if (valuesLength !== newValuesLength) {
                        this._valuesLength = newValuesLength;
                        isDirty = true;
                    }
                    else {
                        isUpdated = true;
                    }
                }
                const newLength = newValuesLength >> 1;
                this._length = newLength;
                if (this._plength < newLength) {
                    this._plength = newLength;
                }
            }
            //
            if (isDirty) {
                this._id += 1;
                const parent = this._parent;
                const uploaded = parent.uploaded;
                if (uploaded) {
                    if (uploaded.isCompatible(parent)) {
                        parent.updateUploaded();
                    }
                    else {
                        parent.toDirty();
                    }
                }
                else {
                    parent.updateUploaded();
                }
            }
            else if (isUpdated) {
                this._id += 1;
                this._parent.updateUploaded();
            }
            return this;
        }
        updateUploaded() {
            this._parent.updateUploaded();
        }
        clone(parent) {
            return new EShapeLineOfAnyPointsImpl(parent).copy(this);
        }
        toPoints(transform) {
            const result = [];
            const values = this.values;
            for (let i = 0, imax = values.length; i < imax; i += 2) {
                const point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        }
        serialize(manager) {
            return manager.addResource(`[]`);
        }
        calcHitPointAbs(x, y, sw, ss, sa, threshold, toRange, tester, result) {
            const formatted = this.formatted;
            const pointCount = formatted.length;
            const pointValues = formatted.values;
            const size = this._size;
            const offset = this._offset;
            let istart = 0;
            let iend = pointCount;
            if (toRange) {
                const s = size.getLimit() * 0.5;
                const o = offset.getLimit();
                const work = EShapeLineOfAnyPointsImpl.WORK_RANGE;
                toRange(x, y, s, s, o, o, threshold, pointValues, work);
                istart = work[0];
                iend = work[1];
            }
            for (let i = istart, imax = Math.min(iend, pointCount); i < imax; ++i) {
                const iv = i << 1;
                const px = pointValues[iv];
                const py = pointValues[iv + 1];
                const sx = size.getX(i) * 0.5;
                const sy = size.getY(i) * 0.5;
                const ox = offset.getX(i);
                const oy = offset.getY(i);
                if (tester(x, y, sx, sy, ox, oy, px, py, sw, ss, sa, i, threshold, result)) {
                    return true;
                }
            }
            return false;
        }
    }
    EShapeLineOfAnyPointsImpl.WORK_RANGE = [0, 0];

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderLineOfCircles extends BuilderLineOfAny {
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            const indices = buffer.indices;
            const voffset = this.vertexOffset;
            const ioffset = this.indexOffset;
            const pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildCircleIndex(indices, voffset, ioffset);
                copyIndex(indices, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                const buffer = this.buffer;
                this.updateVertexAndStep(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, CIRCLE_VERTEX_COUNT);
                this.updateUv(buffer, shape);
            }
        }
        updateVertexAndStep(buffer, shape, points) {
            const pointId = points.id;
            const pointOffset = points.offset;
            const pointOffsetId = pointOffset.id;
            const isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            const pointSize = points.size;
            const pointSizeId = pointSize.id;
            const isPointSizeChanged = pointSizeId !== this.pointSizeId;
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited ||
                isPointChanged ||
                isPointSizeChanged ||
                isSizeChanged ||
                isTransformChanged ||
                isStrokeChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.pointId = pointId;
                const formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                const pointCount = this.pointCount;
                const pointsValues = formatted.values;
                const voffset = this.vertexOffset;
                const vertices = buffer.vertices;
                const steps = buffer.steps;
                const internalTransform = shape.transform.internalTransform;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    const pointSizeX = pointSize.getX(0);
                    const pointSizeY = pointSize.getY(0);
                    buildCircleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, CIRCLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    buildCircleStep(steps, voffset, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
                    copyStep(steps, voffset, CIRCLE_VERTEX_COUNT, pointCount);
                }
                else {
                    for (let i = 0; i < pointCount; ++i) {
                        const ip = i << 1;
                        const px = pointsValues[ip] + pointOffset.getX(i);
                        const py = pointsValues[ip + 1] + pointOffset.getY(i);
                        const pointSizeX = pointSize.getX(i);
                        const pointSizeY = pointSize.getY(i);
                        const iv = voffset + i * CIRCLE_VERTEX_COUNT;
                        buildCircleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, CIRCLE_WORLD_SIZE);
                        buildCircleStep(steps, iv, strokeWidth, strokeStyle, CIRCLE_WORLD_SIZE);
                    }
                }
                // Fill the rest
                const pointCountReserved = this.pointCountReserved;
                const voffsetReserved = voffset + pointCount * CIRCLE_VERTEX_COUNT;
                const vcountReserved = CIRCLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
            }
        }
        updateUv(buffer, shape) {
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                const uvs = buffer.uvs;
                const voffset = this.vertexOffset;
                const textureUvs = toTextureUvs(texture);
                const pointCountReserved = this.pointCountReserved;
                if (0 < pointCountReserved) {
                    buildCircleUv(uvs, voffset, textureUvs);
                    copyUvs(uvs, voffset, CIRCLE_VERTEX_COUNT, pointCountReserved);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createLineOfAnyUploaded = (buffer, shape, voffset, vcountPerPoint, ioffset, icountPerPoint, antialiasWeight, constructor) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const points = shape.points;
        const pointCount = toLineOfAnyPointCount(toPointCount(points));
        const pvcount = pointCount * vcountPerPoint;
        const picount = pointCount * icountPerPoint;
        const vcount = pvcount + tvcount;
        const icount = picount + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new constructor(buffer, voffset, ioffset, pvcount, picount, pointCount, vcountPerPoint, icountPerPoint),
                new BuilderText(buffer, voffset + pvcount, ioffset + picount, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createLineOfCirclesUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        return createLineOfAnyUploaded(buffer, shape, voffset, CIRCLE_VERTEX_COUNT, ioffset, CIRCLE_INDEX_COUNT, antialiasWeight, BuilderLineOfCircles);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineOfCircles extends EShapeCircle {
        constructor(type = EShapeType.LINE_OF_CIRCLES) {
            super(type);
            this._points = new EShapeLineOfAnyPointsImpl(this);
            this._tester = (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) => {
                return this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
        }
        get points() {
            return this._points;
        }
        clone() {
            return new EShapeLineOfCircles(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            const threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        }
        containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return super.containsAbs(x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        }
        calcHitPoint(x, y, toThreshold, toRange, tester, result) {
            const data = this.toHitTestData(x, y);
            const threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeLineOfCircles = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeLineOfCircles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeLineOfCircles = () => {
        EShapeUploadeds[EShapeType.LINE_OF_CIRCLES] = createLineOfCirclesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_CIRCLES] = deserializeLineOfCircles;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderLineOfRectangleRoundeds extends BuilderLineOfAny {
        constructor(buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint) {
            super(buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint);
            this.radius = 0;
            this.corner = 0;
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            const indices = buffer.indices;
            const voffset = this.vertexOffset;
            const ioffset = this.indexOffset;
            const pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleRoundedIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                const buffer = this.buffer;
                this.updateVertexStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, RECTANGLE_ROUNDED_VERTEX_COUNT);
            }
        }
        updateVertexStepAndUv(buffer, shape, points) {
            const pointId = points.id;
            const pointOffset = points.offset;
            const pointOffsetId = pointOffset.id;
            const isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            const pointSize = points.size;
            const pointSizeId = pointSize.id;
            const isPointSizeChanged = pointSizeId !== this.pointSizeId;
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const radius = shape.radius;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY || radius !== this.radius;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeSide = stroke.side;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            const corner = shape.corner;
            const isCornerChanged = corner !== this.corner;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isCornerChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.pointId = pointId;
                const formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                const pointCount = this.pointCount;
                const pointsValues = formatted.values;
                const voffset = this.vertexOffset;
                const vertices = buffer.vertices;
                const steps = buffer.steps;
                const uvs = buffer.uvs;
                const internalTransform = shape.transform.internalTransform;
                const textureUvs = toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    const pointSizeX = pointSize.getX(0);
                    const pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                        buildRectangleRoundedStep(steps, voffset, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isNotInited || isVertexChanged || isTextureChanged) {
                        buildRectangleRoundedUv(uvs, voffset, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (let i = 0; i < pointCount; ++i) {
                        const ip = i << 1;
                        const px = pointsValues[ip] + pointOffset.getX(i);
                        const py = pointsValues[ip + 1] + pointOffset.getY(i);
                        const pointSizeX = pointSize.getX(i);
                        const pointSizeY = pointSize.getY(i);
                        const iv = voffset + i * RECTANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildRectangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, RECTANGLE_ROUNDED_WORLD_SIZE);
                        // Steps
                        if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                            buildRectangleRoundedStep(steps, iv, strokeWidth, strokeSide, strokeStyle, corner, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isNotInited || isVertexChanged || isTextureChanged) {
                            buildRectangleRoundedUv(uvs, iv, textureUvs, RECTANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                const pointCountReserved = this.pointCountReserved;
                const voffsetReserved = voffset + pointCount * RECTANGLE_ROUNDED_VERTEX_COUNT;
                const vcountReserved = RECTANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createLineOfRectangleRoundedsUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_ROUNDED_VERTEX_COUNT, ioffset, RECTANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, BuilderLineOfRectangleRoundeds);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineOfRectangleRoundeds extends EShapeRectangleRounded {
        constructor(type = EShapeType.LINE_OF_RECTANGLE_ROUNDEDS) {
            super(type);
            this._points = new EShapeLineOfAnyPointsImpl(this);
            this._tester = (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) => {
                return this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
        }
        get points() {
            return this._points;
        }
        clone() {
            return new EShapeLineOfRectangleRoundeds(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            const threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, threshold, sw, ss, sa, null, this._tester, null);
            }
            return false;
        }
        containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return super.containsAbs(x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        }
        calcHitPoint(x, y, toThreshold, toRange, tester, result) {
            const data = this.toHitTestData(x, y);
            const threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeLineOfRectangleRoundeds = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeLineOfRectangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeLineOfRectangleRoundeds = () => {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = createLineOfRectangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLE_ROUNDEDS] = deserializeLineOfRectangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderLineOfRectangles extends BuilderLineOfAny {
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            const indices = buffer.indices;
            const voffset = this.vertexOffset;
            const ioffset = this.indexOffset;
            const pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildRectangleIndex(indices, voffset, ioffset);
                copyIndex(indices, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                const buffer = this.buffer;
                this.updateVertexStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, RECTANGLE_VERTEX_COUNT);
            }
        }
        updateVertexStepAndUv(buffer, shape, points) {
            const pointId = points.id;
            const pointOffset = points.offset;
            const pointOffsetId = pointOffset.id;
            const isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            const pointSize = points.size;
            const pointSizeId = pointSize.id;
            const isPointSizeChanged = pointSizeId !== this.pointSizeId;
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeSide = stroke.side;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeSide !== strokeSide ||
                this.strokeStyle !== strokeStyle;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.pointId = pointId;
                const formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.transformLocalId = transformLocalId;
                this.strokeWidth = strokeWidth;
                this.strokeAlign = strokeAlign;
                this.strokeSide = strokeSide;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                const pointCount = this.pointCount;
                const pointsValues = formatted.values;
                const voffset = this.vertexOffset;
                const vertices = buffer.vertices;
                const steps = buffer.steps;
                const uvs = buffer.uvs;
                const internalTransform = shape.transform.internalTransform;
                const textureUvs = toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    const pointSizeX = pointSize.getX(0);
                    const pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildRectangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, RECTANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isNotInited || isVertexChanged || isTransformChanged) {
                        buildRectangleStep(voffset, steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isNotInited || isVertexChanged || isTextureChanged) {
                        buildRectangleUv(uvs, voffset, textureUvs);
                        copyUvs(uvs, voffset, RECTANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (let i = 0; i < pointCount; ++i) {
                        const ip = i << 1;
                        const px = pointsValues[ip] + pointOffset.getX(i);
                        const py = pointsValues[ip + 1] + pointOffset.getY(i);
                        const pointSizeX = pointSize.getX(i);
                        const pointSizeY = pointSize.getY(i);
                        const iv = voffset + i * RECTANGLE_VERTEX_COUNT;
                        // Vertices
                        buildRectangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, RECTANGLE_WORLD_SIZE);
                        // Steps
                        if (isNotInited || isVertexChanged || isTransformChanged) {
                            buildRectangleStep(iv, steps, strokeWidth, strokeSide, strokeStyle, RECTANGLE_WORLD_SIZE);
                        }
                        // UVs
                        if (isNotInited || isVertexChanged || isTextureChanged) {
                            buildRectangleUv(uvs, iv, textureUvs);
                        }
                    }
                }
                // Fill the rest
                const pointCountReserved = this.pointCountReserved;
                const voffsetReserved = voffset + pointCount * RECTANGLE_VERTEX_COUNT;
                const vcountReserved = RECTANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createLineOfRectanglesUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        return createLineOfAnyUploaded(buffer, shape, voffset, RECTANGLE_VERTEX_COUNT, ioffset, RECTANGLE_INDEX_COUNT, antialiasWeight, BuilderLineOfRectangles);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineOfRectangles extends EShapeRectangle {
        constructor(type = EShapeType.LINE_OF_RECTANGLES) {
            super(type);
            this._points = new EShapeLineOfAnyPointsImpl(this);
            this._tester = (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) => {
                return this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
        }
        get points() {
            return this._points;
        }
        clone() {
            return new EShapeLineOfRectangles(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            const threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        }
        containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return super.containsAbs(x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        }
        calcHitPoint(x, y, toThreshold, toRange, tester, result) {
            const data = this.toHitTestData(x, y);
            const threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeLineOfRectangles = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeLineOfRectangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeLineOfRectangles = () => {
        EShapeUploadeds[EShapeType.LINE_OF_RECTANGLES] = createLineOfRectanglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_RECTANGLES] = deserializeLineOfRectangles;
        EShapeCapabilities.set(EShapeType.LINE_OF_RECTANGLES, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    const TRIANGLE_ROUNDED_VERTEX_COUNT = 22;
    const TRIANGLE_ROUNDED_INDEX_COUNT = 15;
    const TRIANGLE_ROUNDED_WORLD_SIZE = [
        0, 0, 0, 0, 0
    ];
    const TRIANGLE_ROUNDED_WORK_POINT = new pixi_js.Point();
    const buildTriangleRoundedIndex = (indices, voffset, ioffset) => {
        // Top corner
        let ii = ioffset * 3 - 1;
        indices[++ii] = voffset + 0;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 3;
        // Bottom-right corner
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 7;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 6;
        indices[++ii] = voffset + 7;
        // Bottom-left corner
        indices[++ii] = voffset + 8;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 11;
        indices[++ii] = voffset + 9;
        indices[++ii] = voffset + 10;
        indices[++ii] = voffset + 11;
        // Others
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 14;
        indices[++ii] = voffset + 15;
        indices[++ii] = voffset + 16;
        //
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 16;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 17;
        indices[++ii] = voffset + 18;
        indices[++ii] = voffset + 19;
        //
        indices[++ii] = voffset + 12;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 19;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 13;
        indices[++ii] = voffset + 20;
        indices[++ii] = voffset + 21;
        indices[++ii] = voffset + 13;
    };
    const buildTriangleRoundedVertex = (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, radius, internalTransform, worldSize) => {
        // Calculate the transformed positions
        const s = strokeAlign * strokeWidth;
        const sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        const sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        const sz = Math.sqrt(sx * sx + 4 * sy * sy);
        const sw = (2 * sx * sy) / (sx + sz);
        const ry = (sw * radius) / (2 * sy);
        const rz = (0.5 * (sz - sw) * radius) / sz;
        const rx = (ry * sz) / (2 * sx);
        const work = TRIANGLE_ROUNDED_WORK_POINT;
        work.set(originX, originY - sy);
        internalTransform.apply(work, work);
        const x1 = work.x;
        const y1 = work.y;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        const tx = work.x;
        const ty = work.y;
        work.set(originX + sx, originY);
        internalTransform.apply(work, work);
        const dx = tx - x1;
        const dy = ty - y1;
        const x4 = work.x + dx;
        const y4 = work.y + dy;
        const x7 = tx + (tx - work.x) + dx;
        const y7 = ty + (ty - work.y) + dy;
        const dx14 = x4 - x1;
        const dy14 = y4 - y1;
        const x2 = x1 + rz * dx14;
        const y2 = y1 + rz * dy14;
        const x3 = x4 - ry * dx14;
        const y3 = y4 - ry * dy14;
        const dx47r = rx * (x7 - x4);
        const dy47r = rx * (y7 - y4);
        const x5 = x4 + dx47r;
        const y5 = y4 + dy47r;
        const x6 = x7 - dx47r;
        const y6 = y7 - dy47r;
        const dx71 = x1 - x7;
        const dy71 = y1 - y7;
        const x8 = x7 + ry * dx71;
        const y8 = y7 + ry * dy71;
        const x9 = x1 - rz * dx71;
        const y9 = y1 - rz * dy71;
        work.set(originX, originY + sy - sw); // Incenter of a triangle
        internalTransform.apply(work, work);
        const x0 = work.x;
        const y0 = work.y;
        const x10 = x1 + radius * (x0 - x1);
        const y10 = y1 + radius * (y0 - y1);
        const x11 = x4 + radius * (x0 - x4);
        const y11 = y4 + radius * (y0 - y4);
        const x12 = x7 + radius * (x0 - x7);
        const y12 = y7 + radius * (y0 - y7);
        // World size
        const xb = tx + dx;
        const yb = ty + dy;
        worldSize[0] = toLength(xb, yb, x0, y0);
        worldSize[1] = rx;
        worldSize[2] = ry;
        worldSize[3] = rz;
        worldSize[4] = 1 - (0.5 * sw) / sy;
        // Vertices
        // Top corner
        let iv = voffset * 2 - 1;
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        // Bottom-right corner
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        // Bottom-left corner
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x7;
        vertices[++iv] = y7;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        // Others
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x10;
        vertices[++iv] = y10;
        vertices[++iv] = x2;
        vertices[++iv] = y2;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x11;
        vertices[++iv] = y11;
        vertices[++iv] = x5;
        vertices[++iv] = y5;
        vertices[++iv] = x6;
        vertices[++iv] = y6;
        vertices[++iv] = x12;
        vertices[++iv] = y12;
        vertices[++iv] = x8;
        vertices[++iv] = y8;
        vertices[++iv] = x9;
        vertices[++iv] = y9;
    };
    const buildTriangleRoundedStep = (steps, voffset, strokeWidth, strokeStyle, corner, radius, worldSize) => {
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const s = worldSize[0];
        const sr = radius * s;
        const w = 1 - radius;
        const e0 = toPackedI4x64(0, scaleInvariant, 1, 1);
        const e1 = toPackedI4x64(1, scaleInvariant, 1, 1);
        const c00 = toPackedF2x1024(0, 0);
        const c10 = toPackedF2x1024(1, 0);
        const c11 = toPackedF2x1024(1, 1);
        const c01 = toPackedF2x1024(0, 1);
        const cww = toPackedF2x1024(w, w);
        const c1w = toPackedF2x1024(1, w);
        const cw1 = toPackedF2x1024(w, 1);
        const cw0 = toPackedF2x1024(w, 0);
        // Top corner
        let is = voffset * 6 - 1;
        if (corner & EShapeCorner.TOP) {
            // 001
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c00;
            steps[++is] = 0;
            // 101
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c10;
            steps[++is] = 0;
            // 111
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c11;
            steps[++is] = 0;
            // 011
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c01;
            steps[++is] = 0;
        }
        else {
            // ww0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cww;
            steps[++is] = 0;
            // 1w0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c1w;
            steps[++is] = 0;
            // 110
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c11;
            steps[++is] = 0;
            // w10
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cw1;
            steps[++is] = 0;
        }
        // Bottom-right corner
        if (corner & EShapeCorner.BOTTOM_RIGHT) {
            // 001
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c00;
            steps[++is] = 0;
            // 101
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c10;
            steps[++is] = 0;
            // 111
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c11;
            steps[++is] = 0;
            // 011
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c01;
            steps[++is] = 0;
        }
        else {
            // ww0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cww;
            steps[++is] = 0;
            // 1w0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c1w;
            steps[++is] = 0;
            // 110
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c11;
            steps[++is] = 0;
            // w10
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cw1;
            steps[++is] = 0;
        }
        // Bottom-left corner
        if (corner & EShapeCorner.BOTTOM_LEFT) {
            // 001
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c00;
            steps[++is] = 0;
            // 101
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c10;
            steps[++is] = 0;
            // 111
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c11;
            steps[++is] = 0;
            // 011
            steps[++is] = strokeWidth;
            steps[++is] = e1;
            steps[++is] = sr;
            steps[++is] = sr;
            steps[++is] = c01;
            steps[++is] = 0;
        }
        else {
            // ww0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cww;
            steps[++is] = 0;
            // 1w0
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c1w;
            steps[++is] = 0;
            // 110
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = c11;
            steps[++is] = 0;
            // w10
            steps[++is] = strokeWidth;
            steps[++is] = e0;
            steps[++is] = s;
            steps[++is] = s;
            steps[++is] = cw1;
            steps[++is] = 0;
        }
        // Others
        // 000
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c00;
        steps[++is] = 0;
        // w00
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = cw0;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // w00
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = cw0;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // w00
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = cw0;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
        // 100
        steps[++is] = strokeWidth;
        steps[++is] = e0;
        steps[++is] = s;
        steps[++is] = s;
        steps[++is] = c10;
        steps[++is] = 0;
    };
    const buildTriangleRoundedUv = (uvs, voffset, textureUvs, radius, worldSize) => {
        const x0 = textureUvs.x0;
        const x1 = textureUvs.x1;
        const x2 = textureUvs.x2;
        const x3 = textureUvs.x3;
        const y0 = textureUvs.y0;
        const y1 = textureUvs.y1;
        const y2 = textureUvs.y2;
        const y3 = textureUvs.y3;
        const x4 = 0.5 * (x0 + x1);
        const y4 = 0.5 * (y0 + y1);
        const c = worldSize[4];
        const x5 = x4 + c * (x3 - x0);
        const y5 = y4 + c * (y3 - y0);
        const rx = worldSize[1];
        const ry = worldSize[2];
        const rz = worldSize[3];
        const x6 = x4 + rz * (x3 - x4);
        const y6 = y4 + rz * (y3 - y4);
        const x7 = x4 + radius * (x5 - x4);
        const y7 = y4 + radius * (y5 - y4);
        const x8 = x4 + rz * (x2 - x4);
        const y8 = y4 + rz * (y2 - y4);
        const x9 = x2 + ry * (x4 - x2);
        const y9 = y2 + ry * (y4 - y2);
        const x10 = x2 + radius * (x5 - x2);
        const y10 = y2 + radius * (y5 - y2);
        const x11 = x2 + rx * (x3 - x2);
        const y11 = y2 + rx * (y3 - y2);
        const x12 = x3 + rx * (x2 - x3);
        const y12 = y3 + rx * (y2 - y3);
        const x13 = x3 + radius * (x5 - x3);
        const y13 = y3 + radius * (y5 - y3);
        const x14 = x3 + ry * (x4 - x3);
        const y14 = y3 + ry * (y4 - y3);
        // Uvs
        // Top corner
        let iuv = voffset * 2 - 1;
        uvs[++iuv] = x7;
        uvs[++iuv] = y7;
        uvs[++iuv] = x6;
        uvs[++iuv] = y6;
        uvs[++iuv] = x4;
        uvs[++iuv] = y4;
        uvs[++iuv] = x8;
        uvs[++iuv] = y8;
        // Bottom-right corner
        uvs[++iuv] = x10;
        uvs[++iuv] = y10;
        uvs[++iuv] = x9;
        uvs[++iuv] = y9;
        uvs[++iuv] = x2;
        uvs[++iuv] = y2;
        uvs[++iuv] = x11;
        uvs[++iuv] = y11;
        // Bottom-left corner
        uvs[++iuv] = x13;
        uvs[++iuv] = y13;
        uvs[++iuv] = x12;
        uvs[++iuv] = y12;
        uvs[++iuv] = x3;
        uvs[++iuv] = y3;
        uvs[++iuv] = x14;
        uvs[++iuv] = y14;
        // Others
        uvs[++iuv] = x5;
        uvs[++iuv] = y5;
        uvs[++iuv] = x7;
        uvs[++iuv] = y7;
        uvs[++iuv] = x8;
        uvs[++iuv] = y8;
        uvs[++iuv] = x9;
        uvs[++iuv] = y9;
        uvs[++iuv] = x10;
        uvs[++iuv] = y10;
        uvs[++iuv] = x11;
        uvs[++iuv] = y11;
        uvs[++iuv] = x12;
        uvs[++iuv] = y12;
        uvs[++iuv] = x13;
        uvs[++iuv] = y13;
        uvs[++iuv] = x14;
        uvs[++iuv] = y14;
        uvs[++iuv] = x6;
        uvs[++iuv] = y6;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderLineOfTriangleRoundeds extends BuilderLineOfAny {
        constructor(buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint) {
            super(buffer, vertexOffset, indexOffset, vertexCount, indexCount, pointCountReserved, vcountPerPoint, icountPerPoint);
            this.radius = 0;
            this.corner = 0;
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            const voffset = this.vertexOffset;
            const ioffset = this.indexOffset;
            const pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleRoundedIndex(buffer.indices, voffset, ioffset);
                copyIndex(buffer.indices, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                const buffer = this.buffer;
                this.updateVertexStepAndUv(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, TRIANGLE_ROUNDED_VERTEX_COUNT);
            }
        }
        updateVertexStepAndUv(buffer, shape, points) {
            const pointId = points.id;
            const pointOffset = points.offset;
            const pointOffsetId = pointOffset.id;
            const isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            const pointSize = points.size;
            const pointSizeId = pointSize.id;
            const isPointSizeChanged = pointSizeId !== this.pointSizeId;
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const radius = shape.radius;
            const isRadiusChanged = radius !== this.radius;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const corner = shape.corner;
            const isCornerChanged = this.corner !== corner;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isPointChanged ||
                isPointSizeChanged ||
                isSizeChanged ||
                isRadiusChanged ||
                isStrokeChanged;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isCornerChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.pointId = pointId;
                const formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                const pointCount = this.pointCount;
                const pointsValues = formatted.values;
                const voffset = this.vertexOffset;
                const vertices = buffer.vertices;
                const steps = buffer.steps;
                const uvs = buffer.uvs;
                const internalTransform = shape.transform.internalTransform;
                const textureUvs = toTextureUvs(texture);
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    const pointSizeX = pointSize.getX(0);
                    const pointSizeY = pointSize.getY(0);
                    // Vertices
                    buildTriangleRoundedVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    // Steps
                    if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                        buildTriangleRoundedStep(steps, voffset, strokeWidth, strokeStyle, corner, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                    // UVs
                    if (isNotInited || isVertexChanged || isTextureChanged) {
                        buildTriangleRoundedUv(uvs, voffset, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (let i = 0; i < pointCount; ++i) {
                        const ip = i << 1;
                        const px = pointsValues[ip] + pointOffset.getX(i);
                        const py = pointsValues[ip + 1] + pointOffset.getY(i);
                        const pointSizeX = pointSize.getX(i);
                        const pointSizeY = pointSize.getY(i);
                        const iv = voffset + i * TRIANGLE_ROUNDED_VERTEX_COUNT;
                        // Vertices
                        buildTriangleRoundedVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, radius, internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                        // Steps
                        if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                            buildTriangleRoundedStep(steps, iv, strokeWidth, strokeStyle, corner, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                        // UVs
                        if (isNotInited || isVertexChanged || isTextureChanged) {
                            buildTriangleRoundedUv(uvs, iv, textureUvs, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                const pointCountReserved = this.pointCountReserved;
                const voffsetReserved = voffset + pointCount * TRIANGLE_ROUNDED_VERTEX_COUNT;
                const vcountReserved = TRIANGLE_ROUNDED_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createLineOfTriangleRoundedsUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset, TRIANGLE_ROUNDED_INDEX_COUNT, antialiasWeight, BuilderLineOfTriangleRoundeds);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const containsCorner_ = (shape, x, y, r, aw, sw, ss) => {
        const fill = shape.fill;
        if (fill.enable) {
            if (x * x + y * y <= r * r) {
                return true;
            }
        }
        else {
            if (0 < sw) {
                const d = x * x + y * y;
                if (d <= r * r) {
                    const w = Math.max(0.0, r * (1 - (sw * ss) / aw));
                    if (w * w <= d) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    const containsCorner = (shape, x, y, x0, y0, x1, y1, x2, y2, x3, y3, r12, r13, aw, radius, sw, ss) => {
        const xl = x1 + r12 * (x2 - x1) - x0;
        const yl = y1 + r12 * (y2 - y1) - y0;
        const n = Math.sqrt(xl * xl + yl * yl);
        const threshold = 0.00001;
        if (threshold < n) {
            const ni = 1 / n;
            const nlx = xl * ni;
            const nly = yl * ni;
            const xr = x1 + r13 * (x3 - x1) - x0;
            const yr = y1 + r13 * (y3 - y1) - y0;
            const nrx = xr * ni;
            const nry = yr * ni;
            const det = nlx * nry - nrx * nly;
            if (threshold < Math.abs(det)) {
                const deti = 1 / det;
                const xc = x - x0;
                const yc = y - y0;
                const dx = (+nry * xc - nrx * yc) * deti;
                const dy = (-nly * xc + nlx * yc) * deti;
                if (containsCorner_(shape, dx, dy, n, aw * radius, sw, ss)) {
                    return true;
                }
            }
        }
        return false;
    };
    const hitTestTriangleRounded = (shape, x, y, ax, ay, sw, ss) => {
        const a = (2 * ay) / ax;
        if (hitTestTriangleFilled(x, y, a, -ay, +ay)) {
            const az = Math.sqrt(ax * ax + 4 * ay * ay);
            const aw = (2 * ax * ay) / (ax + az);
            const radius = shape.radius;
            const x0 = 0;
            const y0 = ay - aw;
            const x1 = 0;
            const y1 = -ay;
            const x4 = +ax;
            const y4 = +ay;
            const x7 = -x4;
            const y7 = +y4;
            const x10 = x1 + radius * (x0 - x1);
            const y10 = y1 + radius * (y0 - y1);
            const x11 = x4 + radius * (x0 - x4);
            const y11 = y4 + radius * (y0 - y4);
            const y12 = +y11;
            const x12 = -x11;
            const c0 = -a * x + y10 - y <= 0;
            const c1 = +a * x + y10 - y <= 0;
            const c2 = y <= y11;
            const corner = shape.corner;
            if (!c0 && !c1 && corner & EShapeCorner.TOP) {
                // Top corner
                const rz = (0.5 * (az - aw) * radius) / az;
                if (containsCorner(shape, x, y, x10, y10, x1, y1, x7, y7, x4, y4, rz, rz, aw, radius, sw, ss)) {
                    return true;
                }
            }
            else if (!c0 && !c2 && corner & EShapeCorner.BOTTOM_LEFT) {
                // Bottom-left corner
                const ry = (aw * radius) / (2 * ay);
                const rx = (ry * az) / (2 * ax);
                if (containsCorner(shape, x, y, x12, y12, x7, y7, x4, y4, x1, y1, rx, ry, aw, radius, sw, ss)) {
                    return true;
                }
            }
            else if (!c1 && !c2 && corner & EShapeCorner.BOTTOM_RIGHT) {
                // Bottom-right corner
                const ry = (aw * radius) / (2 * ay);
                const rx = (ry * az) / (2 * ax);
                if (containsCorner(shape, x, y, x11, y11, x4, y4, x1, y1, x7, y7, ry, rx, aw, radius, sw, ss)) {
                    return true;
                }
            }
            else {
                // Others
                const fill = shape.fill;
                if (fill.enable) {
                    return true;
                }
                else {
                    if (0 < sw) {
                        const s = sw * ss;
                        const cy = ay - aw;
                        const ay1 = cy + ((-ay - cy) * Math.max(0.0, aw - s)) / aw;
                        const ay2 = ay - s;
                        if (!hitTestTriangleFilled(x, y, a, ay1, ay2)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeTriangleRounded extends EShapePrimitive {
        constructor(type = EShapeType.TRIANGLE_ROUNDED) {
            super(type);
        }
        clone() {
            return new EShapeTriangleRounded(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            if (super.containsAbsBBox(x, y, ax, ay)) {
                return hitTestTriangleRounded(this, x, y, ax, ay, sw, ss);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineOfTriangleRoundeds extends EShapeTriangleRounded {
        constructor(type = EShapeType.LINE_OF_TRIANGLE_ROUNDEDS) {
            super(type);
            this._points = new EShapeLineOfAnyPointsImpl(this);
            this._tester = (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) => {
                return this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
        }
        get points() {
            return this._points;
        }
        clone() {
            return new EShapeLineOfTriangleRoundeds(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            const threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        }
        containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return super.containsAbs(x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        }
        calcHitPoint(x, y, toThreshold, toRange, tester, result) {
            const data = this.toHitTestData(x, y);
            const threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeLineOfTriangleRoundeds = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeLineOfTriangleRoundeds());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeLineOfTriangleRoundeds = () => {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = createLineOfTriangleRoundedsUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLE_ROUNDEDS] = deserializeLineOfTriangleRoundeds;
        EShapeCapabilities.set(EShapeType.LINE_OF_TRIANGLE_ROUNDEDS, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderLineOfTriangles extends BuilderLineOfAny {
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            const indices = buffer.indices;
            const voffset = this.vertexOffset;
            const ioffset = this.indexOffset;
            const pointCountReserved = this.pointCountReserved;
            if (0 < pointCountReserved) {
                buildTriangleIndex(indices, voffset, ioffset);
                copyIndex(indices, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, pointCountReserved);
            }
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const points = shape.points;
            if (points instanceof EShapeLineOfAnyPointsImpl) {
                const buffer = this.buffer;
                this.updateVertexStepAndUvs(buffer, shape, points);
                this.updateLineOfAnyColor(buffer, shape, points, TRIANGLE_VERTEX_COUNT);
            }
        }
        updateVertexStepAndUvs(buffer, shape, points) {
            const pointId = points.id;
            const pointOffset = points.offset;
            const pointOffsetId = pointOffset.id;
            const isPointChanged = pointId !== this.pointId || pointOffsetId !== this.pointOffsetId;
            const pointSize = points.size;
            const pointSizeId = pointSize.id;
            const isPointSizeChanged = pointSizeId !== this.pointSizeId;
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isPointChanged || isPointSizeChanged || isSizeChanged || isStrokeChanged;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.pointId = pointId;
                const formatted = points.formatted;
                this.pointCount = formatted.length;
                this.pointOffsetId = pointOffsetId;
                this.pointSizeId = pointSizeId;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                // Buffer
                buffer.updateVertices();
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                }
                const pointCount = this.pointCount;
                const pointsValues = formatted.values;
                const voffset = this.vertexOffset;
                const vertices = buffer.vertices;
                const steps = buffer.steps;
                const uvs = buffer.uvs;
                const textureUvs = toTextureUvs(texture);
                const internalTransform = shape.transform.internalTransform;
                if (0 < pointCount && pointSize.isStaticX() && pointSize.isStaticY()) {
                    const pointSizeX = pointSize.getX(0);
                    const pointSizeY = pointSize.getY(0);
                    buildTriangleVertex(vertices, voffset, 0, 0, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                    copyVertex(vertices, internalTransform, voffset, TRIANGLE_VERTEX_COUNT, pointCount, pointsValues, pointOffset);
                    if (isNotInited || isVertexChanged || isTransformChanged) {
                        buildTriangleStep(steps, voffset, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                        copyStep(steps, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                    if (isNotInited || isVertexChanged || isTextureChanged) {
                        buildTriangleUv(uvs, textureUvs, voffset, TRIANGLE_WORLD_SIZE);
                        copyUvs(uvs, voffset, TRIANGLE_VERTEX_COUNT, pointCount);
                    }
                }
                else {
                    for (let i = 0; i < pointCount; ++i) {
                        const ip = i << 1;
                        const px = pointsValues[ip] + pointOffset.getX(i);
                        const py = pointsValues[ip + 1] + pointOffset.getY(i);
                        const pointSizeX = pointSize.getX(i);
                        const pointSizeY = pointSize.getY(i);
                        const iv = voffset + i * TRIANGLE_VERTEX_COUNT;
                        buildTriangleVertex(vertices, iv, px, py, pointSizeX, pointSizeY, strokeAlign, strokeWidth, internalTransform, TRIANGLE_WORLD_SIZE);
                        if (isNotInited || isVertexChanged || isTransformChanged) {
                            buildTriangleStep(steps, iv, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                        }
                        if (isNotInited || isVertexChanged || isTextureChanged) {
                            buildTriangleUv(uvs, textureUvs, iv, TRIANGLE_WORLD_SIZE);
                        }
                    }
                }
                // Fill the rest
                const pointCountReserved = this.pointCountReserved;
                const voffsetReserved = voffset + pointCount * TRIANGLE_VERTEX_COUNT;
                const vcountReserved = TRIANGLE_VERTEX_COUNT * (pointCountReserved - pointCount);
                buildNullVertex(vertices, voffsetReserved, vcountReserved);
                buildNullStep(steps, voffsetReserved, vcountReserved);
                buildNullUv(uvs, voffsetReserved, vcountReserved);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createLineOfTrianglesUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        return createLineOfAnyUploaded(buffer, shape, voffset, TRIANGLE_VERTEX_COUNT, ioffset, TRIANGLE_INDEX_COUNT, antialiasWeight, BuilderLineOfTriangles);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeTriangle extends EShapePrimitive {
        constructor(type = EShapeType.TRIANGLE) {
            super(type);
        }
        clone() {
            return new EShapeTriangle(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            if (super.containsAbsBBox(x, y, ax, ay)) {
                return hitTestTriangle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeLineOfTriangles extends EShapeTriangle {
        constructor(type = EShapeType.LINE_OF_TRIANGLES) {
            super(type);
            this._points = new EShapeLineOfAnyPointsImpl(this);
            this._tester = (x, y, ax, ay, ox, oy, px, py, sw, ss, sa) => {
                return this.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa);
            };
        }
        get points() {
            return this._points;
        }
        clone() {
            return new EShapeLineOfTriangles(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            const threshold = toThresholdDefault(sw, ss, this._points.size.getLimit());
            if (this.containsAbsBBox(x, y, ax + threshold, ay + threshold)) {
                return this._points.calcHitPointAbs(x, y, sw, ss, sa, threshold, null, this._tester, null);
            }
            return false;
        }
        containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa) {
            return super.containsAbs(x - px - ox, y - py - oy, ax, ay, sw, ss, sa);
        }
        calcHitPoint(x, y, toThreshold, toRange, tester, result) {
            const data = this.toHitTestData(x, y);
            const threshold = (toThreshold || toThresholdDefault)(data.strokeWidth, data.strokeScale, this._points.size.getLimit());
            if (this.containsAbsBBox(data.x, data.y, data.width + threshold, data.height + threshold)) {
                return this._points.calcHitPointAbs(data.x, data.y, data.strokeWidth, data.strokeScale, data.strokeAlign, threshold, toRange, tester || this._tester, result);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeLineOfTriangles = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeLineOfTriangles());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeLineOfTriangles = () => {
        EShapeUploadeds[EShapeType.LINE_OF_TRIANGLES] = createLineOfTrianglesUploaded;
        EShapeDeserializers[EShapeType.LINE_OF_TRIANGLES] = deserializeLineOfTriangles;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createNullUploaded = (buffer, shape, voffset, ioffset) => {
        return new EShapeUploadedImpl(buffer, voffset, ioffset, 0, 0, [
            new BuilderNull(buffer, voffset, ioffset)
        ]).init(shape);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeNull extends EShapePrimitive {
        constructor(type = EShapeType.NULL) {
            super(type);
        }
        clone() {
            return new EShapeNull(this.type).copy(this);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeNull = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeNull());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeNull = () => {
        EShapeUploadeds[EShapeType.NULL] = createNullUploaded;
        EShapeDeserializers[EShapeType.NULL] = deserializeNull;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeRectangle = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeRectangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeRectangle = () => {
        EShapeUploadeds[EShapeType.RECTANGLE] = createRectangleUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE] = deserializeRectangle;
        EShapeCapabilities.set(EShapeType.RECTANGLE, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeRectanglePivoted = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeRectanglePivoted());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeRectanglePivoted = () => {
        EShapeUploadeds[EShapeType.RECTANGLE_PIVOTED] = createRectanglePivotedUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE_PIVOTED] = deserializeRectanglePivoted;
        EShapeCapabilities.set(EShapeType.RECTANGLE_PIVOTED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeRectangleRounded = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeRectangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeRectangleRounded = () => {
        EShapeUploadeds[EShapeType.RECTANGLE_ROUNDED] = createRectangleRoundedUploaded;
        EShapeDeserializers[EShapeType.RECTANGLE_ROUNDED] = deserializeRectangleRounded;
        EShapeCapabilities.set(EShapeType.RECTANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    const SEMICIRCLE_VERTEX_COUNT = 6;
    const SEMICIRCLE_INDEX_COUNT = 4;
    const SEMICIRCLE_WORLD_SIZE = [0, 0];
    const SEMICIRCLE_WORK_POINT = new pixi_js.Point();
    const buildSemicircleIndex = (indices, voffset, ioffset) => {
        let ii = ioffset * 3 - 1;
        indices[++ii] = voffset;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 3;
        indices[++ii] = voffset + 1;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 4;
        indices[++ii] = voffset + 2;
        indices[++ii] = voffset + 5;
        indices[++ii] = voffset + 4;
    };
    const buildSemicircleVertex = (vertices, voffset, originX, originY, sizeX, sizeY, strokeAlign, strokeWidth, internalTransform, worldSize) => {
        // Calculate the transformed positions
        //
        //  0       1       2
        // |-------|-------|
        // |3      |4      |5
        // |-------|-------|
        //
        const work = SEMICIRCLE_WORK_POINT;
        const s = strokeAlign * strokeWidth;
        const sx = sizeX * 0.5 + (0 <= sizeX ? +s : -s);
        const sy = sizeY * 0.5 + (0 <= sizeY ? +s : -s);
        work.set(-sx + originX, -sy + originY);
        internalTransform.apply(work, work);
        const x0 = work.x;
        const y0 = work.y;
        work.set(0 + originX, -sy + originY);
        internalTransform.apply(work, work);
        const x1 = work.x;
        const y1 = work.y;
        const dx = x1 - x0;
        const dy = y1 - y0;
        work.set(originX, originY);
        internalTransform.apply(work, work);
        const x4 = work.x;
        const y4 = work.y;
        const x3 = x4 - dx;
        const y3 = y4 - dy;
        // Vertices
        let iv = voffset * 2 - 1;
        vertices[++iv] = x0;
        vertices[++iv] = y0;
        vertices[++iv] = x1;
        vertices[++iv] = y1;
        vertices[++iv] = x1 + dx;
        vertices[++iv] = y1 + dy;
        vertices[++iv] = x3;
        vertices[++iv] = y3;
        vertices[++iv] = x4;
        vertices[++iv] = y4;
        vertices[++iv] = x4 + dx;
        vertices[++iv] = y4 + dy;
        worldSize[0] = toLength(x0, y0, x1, y1);
        worldSize[1] = toLength(x0, y0, x3, y3);
    };
    const buildSemicircleStep = (steps, voffset, strokeWidth, strokeStyle, worldSize) => {
        const scaleInvariant = toScaleInvariant(strokeStyle);
        const ws0 = worldSize[0];
        const ws1 = worldSize[1];
        const e = toPackedI4x64(1, scaleInvariant, 1, 1);
        const c11 = toPackedF2x1024(1, 1);
        const c01 = toPackedF2x1024(0, 1);
        const c10 = toPackedF2x1024(1, 0);
        const c00 = toPackedF2x1024(0, 0);
        let is = voffset * 6 - 1;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c01;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c11;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c10;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c00;
        steps[++is] = 0;
        steps[++is] = strokeWidth;
        steps[++is] = e;
        steps[++is] = ws0;
        steps[++is] = ws1;
        steps[++is] = c10;
        steps[++is] = 0;
    };
    const buildSemicircleUv = (uvs, voffset, textureUvs) => {
        const x0 = textureUvs.x0;
        const x1 = textureUvs.x1;
        const x2 = textureUvs.x2;
        const x3 = textureUvs.x3;
        const y0 = textureUvs.y0;
        const y1 = textureUvs.y1;
        const y2 = textureUvs.y2;
        const y3 = textureUvs.y3;
        // UVs
        let iuv = voffset * 2 - 1;
        uvs[++iuv] = x0;
        uvs[++iuv] = y0;
        uvs[++iuv] = 0.5 * (x0 + x1);
        uvs[++iuv] = 0.5 * (y0 + y1);
        uvs[++iuv] = x1;
        uvs[++iuv] = y1;
        uvs[++iuv] = 0.5 * (x0 + x3);
        uvs[++iuv] = 0.5 * (y0 + y3);
        uvs[++iuv] = 0.5 * (x0 + x2);
        uvs[++iuv] = 0.5 * (y0 + y2);
        uvs[++iuv] = 0.5 * (x1 + x2);
        uvs[++iuv] = 0.5 * (y1 + y2);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderSemicircle extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, SEMICIRCLE_VERTEX_COUNT, SEMICIRCLE_INDEX_COUNT);
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            const voffset = this.vertexOffset;
            buildSemicircleIndex(buffer.indices, voffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexAndStep(buffer, shape);
            this.updateColor(buffer, shape);
            this.updateUv(buffer, shape);
        }
        updateVertexAndStep(buffer, shape) {
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_AND_STEP);
            if (isNotInited || isSizeChanged || isTransformChanged || isStrokeChanged) {
                this.inited |= BuilderFlag.VERTEX_AND_STEP;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                // Buffer
                buffer.updateVertices();
                buffer.updateSteps();
                buildSemicircleVertex(buffer.vertices, this.vertexOffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, SEMICIRCLE_WORLD_SIZE);
                buildSemicircleStep(buffer.steps, this.vertexOffset, strokeWidth, strokeStyle, SEMICIRCLE_WORLD_SIZE);
            }
        }
        updateUv(buffer, shape) {
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isNotInited = !(this.inited & BuilderFlag.UV);
            if (isNotInited ||
                texture !== this.texture ||
                textureTransformId !== this.textureTransformId) {
                this.inited |= BuilderFlag.UV;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                buffer.updateUvs();
                const textureUvs = toTextureUvs(texture);
                buildSemicircleUv(buffer.uvs, this.vertexOffset, textureUvs);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createSemicircleUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = SEMICIRCLE_VERTEX_COUNT + tvcount;
        const icount = SEMICIRCLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderSemicircle(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + SEMICIRCLE_VERTEX_COUNT, ioffset + SEMICIRCLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const hitTestSemicircle = (shape, x, y, ax, ay, sw, ss) => {
        if (y <= 0) {
            return hitTestCircle(shape, x, y, ax, ay, sw, ss);
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A semicircle shape.
     *
     * @beta
     */
    class EShapeSemicircle extends EShapePrimitive {
        constructor(type = EShapeType.SEMICIRCLE) {
            super(type);
            this.stroke.side = EShapeStrokeSide.ALL & ~EShapeStrokeSide.BOTTOM;
        }
        clone() {
            return new EShapeSemicircle(this.type).copy(this);
        }
        containsAbs(x, y, ax, ay, sw, ss, sa) {
            if (super.containsAbsBBox(x, y, ax, ay)) {
                return hitTestSemicircle(this, x, y, ax, ay, sw, ss);
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeSemicircle = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeSemicircle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeSemicircle = () => {
        EShapeUploadeds[EShapeType.SEMICIRCLE] = createSemicircleUploaded;
        EShapeDeserializers[EShapeType.SEMICIRCLE] = deserializeSemicircle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderTriangle extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, TRIANGLE_VERTEX_COUNT, TRIANGLE_INDEX_COUNT);
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            buildTriangleIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        }
        updateVertexStepAndUv(buffer, shape) {
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isSizeChanged || isStrokeChanged;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited || isVertexChanged || isTransformChanged || isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                const voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, shape.transform.internalTransform, TRIANGLE_WORLD_SIZE);
                if (isNotInited || isVertexChanged || isTransformChanged) {
                    buffer.updateSteps();
                    buildTriangleStep(buffer.steps, voffset, strokeWidth, strokeStyle, TRIANGLE_WORLD_SIZE);
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleUv(buffer.uvs, toTextureUvs(texture), voffset, TRIANGLE_WORLD_SIZE);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createTriangleUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = TRIANGLE_VERTEX_COUNT + tvcount;
        const icount = TRIANGLE_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderTriangle(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + TRIANGLE_VERTEX_COUNT, ioffset + TRIANGLE_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeTriangle = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeTriangle());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeTriangle = () => {
        EShapeUploadeds[EShapeType.TRIANGLE] = createTriangleUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE] = deserializeTriangle;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class BuilderTriangleRounded extends BuilderBase {
        constructor(buffer, vertexOffset, indexOffset) {
            super(buffer, vertexOffset, indexOffset, TRIANGLE_ROUNDED_VERTEX_COUNT, TRIANGLE_ROUNDED_INDEX_COUNT);
            this.radius = 0;
            this.corner = 0;
        }
        init() {
            const buffer = this.buffer;
            buffer.updateIndices();
            buildTriangleRoundedIndex(buffer.indices, this.vertexOffset, this.indexOffset);
            this.inited |= BuilderFlag.INDEX;
        }
        update(shape) {
            const buffer = this.buffer;
            this.updateVertexStepAndUv(buffer, shape);
            this.updateColor(buffer, shape);
        }
        updateVertexStepAndUv(buffer, shape) {
            const size = shape.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const isSizeChanged = sizeX !== this.sizeX || sizeY !== this.sizeY;
            const radius = shape.radius;
            const isRadiusChanged = radius !== this.radius;
            const transformLocalId = toTransformLocalId(shape);
            const isTransformChanged = this.transformLocalId !== transformLocalId;
            const stroke = shape.stroke;
            const strokeAlign = stroke.align;
            const strokeWidth = stroke.enable ? stroke.width : 0;
            const strokeStyle = stroke.style;
            const isStrokeChanged = this.strokeAlign !== strokeAlign ||
                this.strokeWidth !== strokeWidth ||
                this.strokeStyle !== strokeStyle;
            const corner = shape.corner;
            const isCornerChanged = corner !== this.corner;
            const texture = toTexture(shape);
            const textureTransformId = toTextureTransformId(texture);
            const isTextureChanged = texture !== this.texture || textureTransformId !== this.textureTransformId;
            const isVertexChanged = isSizeChanged || isRadiusChanged || isStrokeChanged;
            const isNotInited = !(this.inited & BuilderFlag.VERTEX_STEP_AND_UV);
            if (isNotInited ||
                isVertexChanged ||
                isTransformChanged ||
                isCornerChanged ||
                isTextureChanged) {
                this.inited |= BuilderFlag.VERTEX_STEP_AND_UV;
                this.sizeX = sizeX;
                this.sizeY = sizeY;
                this.radius = radius;
                this.transformLocalId = transformLocalId;
                this.strokeAlign = strokeAlign;
                this.strokeWidth = strokeWidth;
                this.strokeStyle = strokeStyle;
                this.corner = corner;
                this.texture = texture;
                this.textureTransformId = textureTransformId;
                const voffset = this.vertexOffset;
                buffer.updateVertices();
                buildTriangleRoundedVertex(buffer.vertices, voffset, 0, 0, sizeX, sizeY, strokeAlign, strokeWidth, radius, shape.transform.internalTransform, TRIANGLE_ROUNDED_WORLD_SIZE);
                if (isNotInited || isVertexChanged || isTransformChanged || isCornerChanged) {
                    buffer.updateSteps();
                    buildTriangleRoundedStep(buffer.steps, voffset, strokeWidth, strokeStyle, corner, radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
                if (isNotInited || isVertexChanged || isTextureChanged) {
                    buffer.updateUvs();
                    buildTriangleRoundedUv(buffer.uvs, voffset, toTextureUvs(texture), radius, TRIANGLE_ROUNDED_WORLD_SIZE);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createTriangleRoundedUploaded = (buffer, shape, voffset, ioffset, antialiasWeight) => {
        const tcount = toTextBufferCount(shape);
        const tvcount = tcount << TEXT_VERTEX_COUNT_SHIFT;
        const ticount = tcount << TEXT_INDEX_COUNT_SHIFT;
        const vcount = TRIANGLE_ROUNDED_VERTEX_COUNT + tvcount;
        const icount = TRIANGLE_ROUNDED_INDEX_COUNT + ticount;
        if (buffer.check(voffset, ioffset, vcount, icount)) {
            return new EShapeUploadedImpl(buffer, voffset, ioffset, vcount, icount, [
                new BuilderTriangleRounded(buffer, voffset, ioffset),
                new BuilderText(buffer, voffset + TRIANGLE_ROUNDED_VERTEX_COUNT, ioffset + TRIANGLE_ROUNDED_INDEX_COUNT, tvcount, ticount)
            ]).init(shape);
        }
        return null;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const deserializeTriangleRounded = (item, manager, shape) => {
        return deserializeBase(item, manager, shape || new EShapeTriangleRounded());
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeTriangleRounded = () => {
        EShapeUploadeds[EShapeType.TRIANGLE_ROUNDED] = createTriangleRoundedUploaded;
        EShapeDeserializers[EShapeType.TRIANGLE_ROUNDED] = deserializeTriangleRounded;
        EShapeCapabilities.set(EShapeType.TRIANGLE_ROUNDED, EShapeCapability.PRIMITIVE | EShapeCapability.STROKE_SIDE | EShapeCapability.BORDER_RADIUS);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadShapeAll = () => {
        loadShapeBar();
        loadShapeButton();
        loadShapeCircle();
        loadShapeConnectorElbow();
        loadShapeConnectorLine();
        loadShapeEmbedded();
        loadShapeGroupShadowed();
        loadShapeGroup();
        loadShapeImage();
        loadShapeImageSdf();
        loadShapeLabel();
        loadShapeLine();
        loadShapeNull();
        loadShapeRectanglePivoted();
        loadShapeRectangleRounded();
        loadShapeRectangle();
        loadShapeSemicircle();
        loadShapeTriangleRounded();
        loadShapeTriangle();
        loadShapeLineOfCircles();
        loadShapeLineOfRectangleRoundeds();
        loadShapeLineOfRectangles();
        loadShapeLineOfTriangleRoundeds();
        loadShapeLineOfTriangles();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DImage extends DImageBase {
        getType() {
            return "DImage";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemBase extends DImage {
        constructor(options) {
            var _a;
            super(options);
            this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : null;
        }
        init(options) {
            super.init(options);
            this.on(UtilPointerEvent.tap, (e) => {
                this.onClick(e);
            });
        }
        onClick(e) {
            if (this.state.isActionable) {
                this.activate(e);
            }
        }
        activate(e) {
            this.onSelect(e);
        }
        get value() {
            return this._value;
        }
        set value(value) {
            this._value = value;
        }
        hasSelection(target) {
            return target && target.selection && target.selection.add;
        }
        getSelection() {
            let parent = this.parent;
            while (parent) {
                if (this.hasSelection(parent)) {
                    return parent.selection;
                }
                parent = parent.parent;
            }
            return null;
        }
        onSelect(e) {
            this.emit("select", this._value, this);
            const selection = this.getSelection();
            if (selection) {
                selection.add(this);
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return super.onKeyDown(e);
        }
        onKeyDownActivate(e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.activate(e);
                return true;
            }
            return false;
        }
        getType() {
            return "DMenuItemBase";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItem extends DMenuItemBase {
        getContext() {
            let parent = this.parent;
            while (parent) {
                if (parent.getContext) {
                    return parent.getContext();
                }
                parent = parent.parent;
            }
            return null;
        }
        getCloseable() {
            let parent = this.parent;
            while (parent) {
                if (parent.getCloseable) {
                    return parent.getCloseable();
                }
                parent = parent.parent;
            }
            return null;
        }
        getType() {
            return "DMenuItem";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemText extends DMenuItem {
        init(options) {
            super.init(options);
            this.initOnOver(options);
            this.initShortcuts(options);
        }
        initOnOver(options) {
            this.on(UtilPointerEvent.over, () => {
                const context = this.getContext();
                if (context != null) {
                    const parent = this.parent;
                    if (parent instanceof DBase) {
                        context.trim(this.getCloseable());
                    }
                }
            });
        }
        initShortcuts(options) {
            const shortcuts = this._shortcuts;
            if (shortcuts != null && 0 < shortcuts.length) {
                const shortcut = shortcuts[0];
                const shortcutText = this.newShortcutText();
                this._shortcutText = shortcutText;
                this.snippet.add(shortcutText, true);
                shortcutText.text = UtilKeyboardEvent.toString(shortcut);
            }
            else {
                this._shortcutText = null;
            }
            this._shortcutMargin = this.theme.getShortcutTextMargin();
        }
        newShortcutText() {
            var _a, _b;
            return new DDynamicText(new DDynamicTextStyle(this, this.theme, (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.text) === null || _b === void 0 ? void 0 : _b.style));
        }
        updateShortcutText() {
            const text = this._shortcutText;
            const margin = this._shortcutMargin;
            if (text != null && margin != null) {
                const auto = this._auto;
                let textX = 0;
                if (auto.width.isOn) {
                    textX = margin;
                }
                else {
                    textX = this.width - text.width - margin;
                }
                let textY = 0;
                const padding = this._padding;
                const ptop = padding.getTop();
                if (auto.height.isOn) {
                    textY = ptop;
                }
                else {
                    textY = ptop + (this.height - ptop - padding.getBottom() - text.height) * 0.5;
                }
                text.position.set(textX, textY);
            }
        }
        updateShortcutColor() {
            const shortcutText = this._shortcutText;
            if (shortcutText != null) {
                const theme = this.theme;
                const state = this.state;
                shortcutText.style.fill = theme.getShortcutColor(state);
                shortcutText.alpha = theme.getShortcutAlpha(state);
            }
        }
        onReflow() {
            super.onReflow();
            this.updateShortcutColor();
            this.updateShortcutText();
        }
        getType() {
            return "DMenuItemText";
        }
        onSelect(e) {
            super.onSelect(e);
            const closeable = this.getCloseable();
            if (closeable != null) {
                closeable.emit("select", this.value, this, closeable);
            }
        }
        onShortcut(e) {
            super.onShortcut(e);
            this.activate(e);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemCheck extends DMenuItemText {
        init(options) {
            super.init(options);
            if (options === null || options === void 0 ? void 0 : options.check) {
                this.state.isActive = true;
            }
        }
        getType() {
            return "DMenuItemCheck";
        }
        onSelect(e) {
            this.state.isActive = !this.state.isActive;
            super.onSelect(e);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DMenuItemCheckIsCompatible = (options) => {
        return "check" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DLinkMenuItemId = {
        OPEN_LINK: 0,
        OPEN_LINK_IN_NEW_WINDOW: 1,
        COPY_LINK_ADDRESS: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenus {
        static addItemCreator(creator) {
            this.CREATORS.push(creator);
        }
        static setItemCreatorDefault(creator) {
            this.CREATOR_DEFAULT = creator;
        }
        static setMenuCreator(creator) {
            this.MENU_CREATOR = creator;
        }
        static newItemOf(creators, creatorDefault, options, sticky) {
            for (let i = 0, imax = creators.length; i < imax; ++i) {
                const created = creators[i](options, sticky);
                if (created != null) {
                    return created;
                }
            }
            if (creatorDefault) {
                return creatorDefault(options, sticky);
            }
            return null;
        }
        static newItem(options, sticky) {
            return this.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky);
        }
        static newItemsOf(creator, parent, items, sticky) {
            for (let i = 0, imax = items.length; i < imax; ++i) {
                const item = items[i];
                if (item instanceof pixi_js.DisplayObject) {
                    parent.addChild(item);
                }
                else if (item != null) {
                    const created = creator.newItem(item, sticky);
                    if (created != null) {
                        parent.addChild(created);
                    }
                    else {
                        throw new Error(`No matching menu item creator found: ${JSON.stringify(item)}`);
                    }
                }
            }
        }
        static newItems(parent, items, sticky) {
            this.newItemsOf(this, parent, items, sticky);
        }
        static newMenu(options) {
            if (this.MENU_CREATOR != null) {
                return this.MENU_CREATOR(options);
            }
            else {
                throw new Error("Missing DMenu creator.");
            }
        }
    }
    DMenus.CREATORS = [];
    DMenus.CREATOR_DEFAULT = null;

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DLinkMenu {
        constructor(parent, options) {
            this._parent = parent;
            this._options = options;
            this._isEnabled = true;
        }
        get enable() {
            return this._isEnabled;
        }
        set enable(enable) {
            this._isEnabled = enable;
        }
        open(target) {
            this.get().open(target);
        }
        get() {
            let result = this._menu;
            if (result == null) {
                result = this.toMenu(this._options);
                this._menu = result;
                result.on("select", (value, item, menu) => {
                    this.onSelect(value, item, menu);
                });
            }
            return result;
        }
        toMenu(options) {
            if (options instanceof pixi_js.DisplayObject) {
                return options;
            }
            return this.newMenu(options);
        }
        newMenu(options) {
            return DMenus.newMenu(options);
        }
        onSelect(value, item, menu) {
            const parent = this._parent;
            switch (value) {
                case DLinkMenuItemId.OPEN_LINK:
                    parent.open(false);
                    break;
                case DLinkMenuItemId.OPEN_LINK_IN_NEW_WINDOW:
                    parent.open(true);
                    break;
                case DLinkMenuItemId.COPY_LINK_ADDRESS:
                    parent.copy();
                    break;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DLinkTarget = {
        AUTO: 0,
        THIS_WINDOW: 1,
        NEW_WINDOW: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const getSelection = (element) => {
        const selection = document.getSelection();
        if (selection) {
            const range = document.createRange();
            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        return selection;
    };
    const toClipboardData = (e) => {
        return e.clipboardData || window.clipboardData;
    };
    const copyUsingDiv = (text) => {
        const div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        div.textContent = "Dummy";
        document.body.appendChild(div);
        const selection = getSelection(div);
        let result = false;
        if (selection) {
            const handler = (e) => {
                if (e.target === div) {
                    const clipboardData = toClipboardData(e);
                    clipboardData.setData("text/plain", text);
                    result = clipboardData.getData("text/plain") === text;
                    e.preventDefault();
                }
            };
            document.addEventListener("copy", handler);
            try {
                document.execCommand("copy");
            }
            finally {
                document.removeEventListener("copy", handler);
            }
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    const copyUsingSpan = (text) => {
        const div = document.createElement("div");
        div.setAttribute("style", "-webkit-user-select: text !important");
        const span = document.createElement("span");
        span.innerText = text;
        const root = div.attachShadow ? div.attachShadow({ mode: "open" }) : div;
        root.appendChild(span);
        document.body.appendChild(div);
        let result = false;
        const selection = getSelection(div);
        if (selection) {
            result = document.execCommand("copy");
            selection.removeAllRanges();
        }
        document.body.removeChild(div);
        return result;
    };
    const copyUsingWindow = (window, text) => {
        if (typeof ClipboardEvent === "undefined") {
            const clipboardData = window.clipboardData;
            if (typeof clipboardData !== "undefined" && typeof clipboardData.setData !== "undefined") {
                clipboardData.setData("Text", text);
                return true;
            }
        }
        return false;
    };
    class UtilClipboard extends pixi_js.utils.EventEmitter {
        constructor() {
            super();
            const element = document.body;
            element.addEventListener("copy", (e) => {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.emit("copy", toClipboardData(e));
                }
            });
            element.addEventListener("cut", (e) => {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.emit("cut", toClipboardData(e));
                }
            });
            element.addEventListener("paste", (e) => {
                if (e.target === element) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.emit("paste", toClipboardData(e));
                }
            });
        }
        static copy(text) {
            const clipboard = navigator.clipboard;
            if (clipboard && clipboard.writeText) {
                clipboard.writeText(text);
            }
            else {
                if (!copyUsingWindow(window, text)) {
                    if (!copyUsingDiv(text)) {
                        if (navigator.userAgent.indexOf("Edge") < 0) {
                            copyUsingSpan(text);
                        }
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DLink {
        constructor(options) {
            this._options = options;
            this._url = options === null || options === void 0 ? void 0 : options.url;
            this._target = this.toNormalizedTarget(options === null || options === void 0 ? void 0 : options.target);
            this._checker = options === null || options === void 0 ? void 0 : options.checker;
            this._isEnabled = true;
        }
        get enable() {
            return this._isEnabled;
        }
        set enable(enable) {
            this._isEnabled = enable;
        }
        get url() {
            return this._url;
        }
        set url(url) {
            this._url = url;
        }
        get target() {
            return this._target;
        }
        set target(target) {
            this._target = this.toNormalizedTarget(target);
        }
        get checker() {
            return this._checker;
        }
        set checker(checker) {
            this._checker = checker;
        }
        get menu() {
            let result = this._menu;
            if (result == null) {
                result = this.newMenu();
                this._menu = result;
            }
            return result;
        }
        newMenu() {
            const options = this._options;
            if (options) {
                const menu = options.menu;
                if (menu) {
                    return new DLinkMenu(this, menu);
                }
            }
            let result = DLink.MENU;
            if (result == null) {
                result = new DLinkMenu(this, DThemes.getInstance().get("DLink").getMenuOptions());
                DLink.MENU = result;
            }
            return result;
        }
        toStringifiedUrl(target, onResolved) {
            const url = isFunction(target) ? target() : target;
            if (url != null) {
                if (isString(url)) {
                    onResolved(url);
                }
                else {
                    url.then((resolved) => {
                        if (resolved != null) {
                            onResolved(resolved);
                        }
                    });
                }
            }
        }
        toNormalizedUrl(url) {
            const a = DLink.ANCHOR_ELEMENT || document.createElement("a");
            DLink.ANCHOR_ELEMENT = a;
            a.href = url;
            return a.href;
        }
        toNormalizedTarget(target) {
            return toEnum(target !== null && target !== void 0 ? target : DLinkTarget.AUTO, DLinkTarget);
        }
        /**
         * Copys the URL to the clipboard.
         */
        copy() {
            this.toStringifiedUrl(this._url, (url) => {
                UtilClipboard.copy(this.toNormalizedUrl(url));
            });
        }
        open(x) {
            this.toStringifiedUrl(this._url, (url) => {
                const inNewWindow = x === true || x === false ? x : this.inNewWindow(x);
                this.check(url, inNewWindow, () => {
                    this.exec(url, inNewWindow);
                });
            });
        }
        check(url, inNewWindow, onResolved) {
            const checker = this._checker;
            if (checker) {
                const checked = checker();
                if (checked === true) {
                    onResolved();
                }
                else if (checked === false) ;
                else {
                    checked.then((resolved) => {
                        if (resolved) {
                            onResolved();
                        }
                    });
                }
            }
            else {
                onResolved();
            }
        }
        /**
         * Opens the given URL.
         *
         * @param url An URL to be opened
         * @param inNewWindow True to open in a new window.
         */
        exec(url, inNewWindow) {
            if (inNewWindow) {
                const a = document.createElement("a");
                a.href = url;
                a.target = "_blank";
                a.style.display = "none";
                a.rel = "noopener noreferrer";
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                }, 100);
            }
            else {
                window.location.href = url;
            }
        }
        /**
         * Returns true if the URL need to be opened in a new window.
         *
         * @param e An event object.
         */
        inNewWindow(e) {
            switch (this._target) {
                case DLinkTarget.NEW_WINDOW:
                    return true;
                case DLinkTarget.THIS_WINDOW:
                    return false;
                case DLinkTarget.AUTO:
                    if (e != null) {
                        const oe = e instanceof pixi_js.InteractionEvent ? e.data.originalEvent : e;
                        return (oe.ctrlKey ||
                            oe.shiftKey ||
                            oe.altKey ||
                            oe.metaKey ||
                            ("button" in oe && oe.button !== 0));
                    }
                    return false;
            }
        }
        onClick(base, e) {
            if (this._target === DLinkTarget.AUTO) {
                const oe = e.data.originalEvent;
                if (("pointerType" in oe && oe.pointerType !== "mouse") || "touches" in oe) {
                    const menu = this.menu;
                    if (menu.enable) {
                        if (this._isEnabled && base.state.isActionable) {
                            menu.open(base);
                        }
                        return true;
                    }
                }
            }
            if (this._isEnabled) {
                return false;
            }
            return true;
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DLinks {
        static toStateOptions(target, options) {
            if (options) {
                if (target === DLinkTarget.NEW_WINDOW || target === "NEW_WINDOW") {
                    const state = options.state;
                    if (state == null) {
                        options.state = DBaseState.NEW_WINDOW;
                    }
                    else if (isString(state)) {
                        if (state !== DBaseState.NEW_WINDOW) {
                            options.state = [state, DBaseState.NEW_WINDOW];
                        }
                    }
                    else if (isArray(state)) {
                        if (state.indexOf(DBaseState.NEW_WINDOW) < 0) {
                            state.push(DBaseState.NEW_WINDOW);
                        }
                    }
                    else {
                        const values = state.values;
                        if (values == null) {
                            state.values = DBaseState.NEW_WINDOW;
                        }
                        else if (isString(values)) {
                            if (values !== DBaseState.NEW_WINDOW) {
                                state.values = [values, DBaseState.NEW_WINDOW];
                            }
                        }
                        else {
                            if (values.indexOf(DBaseState.NEW_WINDOW) < 0) {
                                values.push(DBaseState.NEW_WINDOW);
                            }
                        }
                    }
                }
            }
            return options;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemLink extends DMenuItemText {
        toLinkOptions(options) {
            if (options) {
                return {
                    url: this.toUrl(options.url),
                    target: options.target,
                    checker: this.toChecker(options.checker),
                    menu: options.menu
                };
            }
            return undefined;
        }
        toUrl(url) {
            if (isString(url) || url == null) {
                return url;
            }
            else {
                return () => {
                    return url(this);
                };
            }
        }
        toChecker(checker) {
            if (checker != null) {
                return () => {
                    return checker(this);
                };
            }
            return undefined;
        }
        init(options) {
            super.init(DLinks.toStateOptions(options === null || options === void 0 ? void 0 : options.target, options));
        }
        get link() {
            let result = this._link;
            if (result == null) {
                result = new DLink(this.toLinkOptions(this._options));
                this._link = result;
            }
            return result;
        }
        onClick(e) {
            if (!this.link.onClick(this, e)) {
                super.onClick(e);
            }
        }
        getType() {
            return "DMenuItemLink";
        }
        onSelect(e) {
            super.onSelect(e);
            this.link.open(e);
        }
        open(inNewWindow) {
            this.link.open(inNewWindow);
        }
        onShortcut(e) {
            super.onShortcut(e);
            this.activate(e);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DMenuItemLinkIsCompatible = (options) => {
        return "url" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemMenu extends DMenuItem {
        init(options) {
            super.init(options);
            this.initHover(options);
        }
        initHover(options) {
            this.on(UtilPointerEvent.over, () => {
                if (this.state.isActionable) {
                    this.open();
                }
            });
        }
        toMenu(options) {
            const menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof pixi_js.DisplayObject) {
                return menu;
            }
            return this.newMenu(menu);
        }
        newMenu(options) {
            return DMenus.newMenu(options);
        }
        get menu() {
            let result = this._menu;
            if (result == null) {
                result = this.toMenu(this._options);
                result.on("select", (value, item, menu) => {
                    this.onMenuSelect(value, item, menu);
                });
                this._menu = result;
            }
            return result;
        }
        getType() {
            return "DMenuItemMenu";
        }
        open() {
            const menu = this.menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
        }
        onOpen(menu) {
            const context = this.getContext();
            if (context != null) {
                menu.open(this, this.getCloseable(), context);
            }
        }
        close() {
            this.menu.close();
        }
        toggle() {
            const menu = this.menu;
            if (menu.isHidden()) {
                this.onOpen(menu);
            }
            else {
                menu.close();
            }
        }
        onSelect(e) {
            this.open();
            super.onSelect(e);
        }
        onMenuSelect(value, item, menu) {
            const closeable = this.getCloseable();
            if (closeable != null) {
                closeable.emit("select", value, item, closeable);
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                this.onKeyDownArrowRight(e);
            }
            return super.onKeyDown(e);
        }
        onKeyDownArrowRight(e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onSelect(e);
                return true;
            }
            return false;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DMenuItemMenuIsCompatible = (options) => {
        return "menu" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DMenuItemMenuToSubMenuOptions = (options, sticky) => {
        const menu = options.menu;
        if (!(menu instanceof pixi_js.DisplayObject)) {
            if (menu.sticky == null) {
                menu.sticky = sticky;
            }
            if (menu.align == null) {
                menu.align = UtilAttachAlign.RIGHT;
            }
        }
        return options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemSeparatorReflowable extends pixi_js.Graphics {
        constructor(base) {
            super();
            base.snippet.add(this, true);
            base.reflowable.add(this);
        }
        onReflow(base, width, height) {
            const state = base.state;
            const border = base.border;
            const borderWidth = border.getWidth(state);
            const borderColor = border.getColor(state);
            if (borderColor != null) {
                const borderAlpha = border.getAlpha(state);
                const borderAlign = border.getAlign(state);
                const padding = base.padding;
                const middle = height * 0.5;
                this.clear();
                this.lineStyle(borderWidth, borderColor, borderAlpha, borderAlign);
                this.moveTo(padding.getLeft(), middle);
                this.lineTo(width - padding.getRight(), middle);
                this.visible = true;
            }
            else {
                this.clear();
                this.visible = false;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DMenuItemSeparatorIsCompatible = (options) => {
        return "separator" in options;
    };
    class DMenuItemSeparator extends DMenuItemBase {
        initReflowable() {
            new DMenuItemSeparatorReflowable(this);
        }
        getType() {
            return "DMenuItemSeparator";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemSpace extends DLayoutSpace {
        getType() {
            return "DMenuItemSpace";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DMenuItemSpaceIsCompatible = (options) => {
        return "space" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadMenuItem = () => {
        DMenus.addItemCreator((options) => {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuItemCheck(options);
            }
            return null;
        });
        DMenus.addItemCreator((options) => {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuItemLink(options);
            }
            return null;
        });
        DMenus.addItemCreator((options, sticky) => {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenus.addItemCreator((options) => {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuItemSeparator(options);
            }
            return null;
        });
        DMenus.addItemCreator((options) => {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuItemSpace(options);
            }
            return null;
        });
        DMenus.setItemCreatorDefault((options) => {
            return new DMenuItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandableBody extends DLayoutVertical {
        getType() {
            return "DMenuItemExpandableBody";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandableHeader extends DMenuItemBase {
        getSelection() {
            return null;
        }
        getType() {
            return "DMenuItemExpandableHeader";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandables {
        static addItemCreator(creator) {
            this.CREATORS.push(creator);
        }
        static setItemCreatorDefault(creator) {
            this.CREATOR_DEFAULT = creator;
        }
        static newItem(options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky));
        }
        static newItems(parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        }
    }
    DMenuItemExpandables.CREATORS = [];
    DMenuItemExpandables.CREATOR_DEFAULT = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandable extends DLayoutVertical {
        init(options) {
            var _a;
            super.init(options);
            // Header
            const theme = this.theme;
            const header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", () => {
                this.toggle();
            });
            this.addChild(header);
            // Body
            const body = this.toBody(theme, options);
            this._body = body;
            const sticky = (_a = options === null || options === void 0 ? void 0 : options.sticky) !== null && _a !== void 0 ? _a : false;
            this.newItems(body, sticky, theme, options);
            this.addChild(body);
            //
            if (this.state.isActive) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        }
        newItems(body, sticky, theme, options) {
            const items = options === null || options === void 0 ? void 0 : options.items;
            if (items != null) {
                DMenuItemExpandables.newItems(body, items, sticky);
            }
        }
        toHeader(theme, options) {
            if (options) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        }
        newHeader(theme, options) {
            return new DMenuItemExpandableHeader(options);
        }
        toBody(theme, options) {
            const body = options === null || options === void 0 ? void 0 : options.body;
            if (body) {
                if (body instanceof pixi_js.DisplayObject) {
                    return body;
                }
                else {
                    return this.newBody(theme, body);
                }
            }
            return this.newBody(theme);
        }
        newBody(theme, options) {
            return new DMenuItemExpandableBody(options);
        }
        open() {
            this.state.isActive = true;
        }
        close() {
            this.state.isActive = false;
        }
        toggle() {
            this.state.isActive = !this.state.isActive;
        }
        onActivated() {
            const body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        }
        onDeactivated() {
            const body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        }
        onStateChange(newState, oldState) {
            super.onStateChange(newState, oldState);
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this.onActivated();
                }
            }
            else {
                if (oldState.isActive) {
                    this.onDeactivated();
                }
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                if (this.state.isActionable && !this.state.isActive) {
                    const header = this._header;
                    if (header instanceof DBase && header.state.isFocused) {
                        this.state.isActive = true;
                    }
                }
            }
            else if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                if (this.state.isActionable && this.state.isActive) {
                    // Move the focus
                    const header = this._header;
                    if (header instanceof DBase) {
                        header.focus();
                    }
                    else {
                        this.focus();
                    }
                    // Deactivate
                    this.state.isActive = false;
                    // Key handling
                    super.onKeyDown(e);
                    return true;
                }
            }
            return super.onKeyDown(e);
        }
        getType() {
            return "DMenuItemExpandable";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DMenuItemExpandableIsCompatible = (options) => {
        return "header" in options;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandableItemCheck extends DMenuItemCheck {
        getType() {
            return "DMenuItemExpandableItemCheck";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandableItemLink extends DMenuItemLink {
        getType() {
            return "DMenuItemExpandableItemLink";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandableItemSeparator extends DMenuItemSeparator {
        getType() {
            return "DMenuItemExpandableItemSeparator";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandableItemSpace extends DMenuItemSpace {
        getType() {
            return "DMenuItemExpandableItemSpace";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandableItemText extends DMenuItemText {
        getType() {
            return "DMenuItemExpandableItemText";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadMenuItemExpandable = () => {
        DMenus.addItemCreator((options) => {
            if (DMenuItemExpandableIsCompatible(options)) {
                return new DMenuItemExpandable(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator((options) => {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator((options) => {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator((options) => {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuItemExpandables.addItemCreator((options) => {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuItemExpandables.setItemCreatorDefault((options) => {
            return new DMenuItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemCheck extends DMenuItemCheck {
        getType() {
            return "DMenuSidedItemCheck";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemLink extends DMenuItemLink {
        getSelection() {
            return null;
        }
        getType() {
            return "DMenuSidedItemLink";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemMenu extends DMenuItemMenu {
        initHover(options) {
            // DO NOTHING
        }
        onMenuSelect(value, item, menu) {
            super.onMenuSelect(value, item, menu);
            const selection = super.getSelection();
            if (selection) {
                selection.add(item);
            }
        }
        onOpen(menu) {
            menu.open(this, this);
        }
        getSelection() {
            return null;
        }
        getType() {
            return "DMenuSidedItemMenu";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemSeparator extends DMenuItemSeparator {
        getType() {
            return "DMenuSidedItemSeparator";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemSpace extends DMenuItemSpace {
        getType() {
            return "DMenuSidedItemSpace";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemText extends DMenuItemText {
        getType() {
            return "DMenuSidedItemText";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSideds {
        static addItemCreator(creator) {
            this.CREATORS.push(creator);
        }
        static setItemCreatorDefault(creator) {
            this.CREATOR_DEFAULT = creator;
        }
        static newItem(options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenus.newItem(options, sticky));
        }
        static newItems(parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        }
    }
    DMenuSideds.CREATORS = [];
    DMenuSideds.CREATOR_DEFAULT = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadMenuSidedItem = () => {
        DMenuSideds.setItemCreatorDefault((options) => {
            return new DMenuSidedItemText(options);
        });
        DMenuSideds.addItemCreator((options) => {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuSidedItemSpace(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator((options) => {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuSidedItemSeparator(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator((options, sticky) => {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuSidedItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSideds.addItemCreator((options) => {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuSidedItemLink(options);
            }
            return null;
        });
        DMenuSideds.addItemCreator((options) => {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuSidedItemCheck(options);
            }
            return null;
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemExpandables {
        static addItemCreator(creator) {
            this.CREATORS.push(creator);
        }
        static setItemCreatorDefault(creator) {
            this.CREATOR_DEFAULT = creator;
        }
        static newItem(options, sticky) {
            return (DMenus.newItemOf(this.CREATORS, this.CREATOR_DEFAULT, options, sticky) ||
                DMenuSideds.newItem(options, sticky));
        }
        static newItems(parent, items, sticky) {
            DMenus.newItemsOf(this, parent, items, sticky);
        }
    }
    DMenuSidedItemExpandables.CREATORS = [];
    DMenuSidedItemExpandables.CREATOR_DEFAULT = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemExpandable extends DMenuItemExpandable {
        newItems(body, sticky, theme, options) {
            if (options != null && options.items != null) {
                DMenuSidedItemExpandables.newItems(body, options.items, sticky);
            }
        }
        getType() {
            return "DMenuSidedItemExpandable";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemExpandableItemCheck extends DMenuItemExpandableItemCheck {
        getType() {
            return "DMenuSidedItemExpandableItemCheck";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemExpandableItemLink extends DMenuItemLink {
        getType() {
            return "DMenuSidedItemExpandableItemLink";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItemExpandableItemMenu extends DMenuItemMenu {
        getType() {
            return "DMenuItemExpandableItemMenu";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemExpandableItemMenu extends DMenuItemExpandableItemMenu {
        onOpen(menu) {
            menu.open(this, this);
        }
        getType() {
            return "DMenuSidedItemExpandableItemMenu";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemExpandableItemSeparator extends DMenuItemExpandableItemSeparator {
        getType() {
            return "DMenuSidedItemSeparator";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemExpandableItemSpace extends DMenuItemExpandableItemSpace {
        getType() {
            return "DMenuSidedItemExpandableItemSpace";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedItemExpandableItemText extends DMenuItemExpandableItemText {
        getType() {
            return "DMenuSidedItemExpandableItemText";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadMenuSidedItemExpandable = () => {
        DMenuSideds.addItemCreator((options) => {
            if (DMenuItemExpandableIsCompatible(options)) {
                return new DMenuSidedItemExpandable(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator((options) => {
            if (DMenuItemCheckIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemCheck(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator((options) => {
            if (DMenuItemLinkIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemLink(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator((options, sticky) => {
            if (DMenuItemMenuIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemMenu(DMenuItemMenuToSubMenuOptions(options, sticky));
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator((options) => {
            if (DMenuItemSeparatorIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemSeparator(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.addItemCreator((options) => {
            if (DMenuItemSpaceIsCompatible(options)) {
                return new DMenuSidedItemExpandableItemSpace(options);
            }
            return null;
        });
        DMenuSidedItemExpandables.setItemCreatorDefault((options) => {
            return new DMenuSidedItemExpandableItemText(options);
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadMenuItemAll = () => {
        loadMenuItem();
        loadMenuItemExpandable();
        loadMenuSidedItem();
        loadMenuSidedItemExpandable();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const loadAll = () => {
        loadMenuItemAll();
        loadShapeAll();
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueMiscEmitEvent extends EShapeActionValueMisc {
        constructor(condition, target) {
            super(EShapeActionValueMiscType.EMIT_EVENT, condition, target, EShapeActionValueOnInputAction.EMIT_EVENT, "");
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueMiscHtmlElement extends EShapeActionValueMisc {
        constructor(subtype, when, initializer) {
            super(subtype, when, "", EShapeActionValueOnInputAction.EMIT_EVENT, initializer);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueMiscInput extends EShapeActionValueMisc {
        constructor(subtype, when, target, onInputAction) {
            super(subtype, when, target, onInputAction, "");
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeActionValueMiscWrite extends EShapeActionValueMisc {
        constructor(subtype, condition, target, value) {
            super(subtype, condition, target, EShapeActionValueOnInputAction.EMIT_EVENT, value);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createImageSdf = (dataUrl, convertToSdf) => {
        if (convertToSdf) {
            return toImageElement(dataUrl).then((image) => {
                const generator = DynamicSDFFontGenerator.getInstance().init();
                generator.updateTexture(image.width, image.height, image.source);
                generator.render();
                const canvas = document.createElement("canvas");
                generator.read(canvas);
                return createImageSdf(canvas.toDataURL(), false);
            });
        }
        else {
            return toImageElement(dataUrl).then((image) => {
                return new EShapeImageSdf(image);
            });
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const createImage = (dataUrl) => {
        return toImageElement(dataUrl).then((image) => {
            return new EShapeImage(image);
        });
    };

    const createLine = (points, segments, strokeWidth, pointsStyle) => {
        // Calculate the boundary
        const boundary = toPointsBoundary(points, [0, 0, 0, 0]);
        const cx = (boundary[2] + boundary[0]) * 0.5;
        const cy = (boundary[3] + boundary[1]) * 0.5;
        const sx = boundary[2] - boundary[0];
        const sy = boundary[3] - boundary[1];
        // Calculate values
        const values = [];
        for (let i = 0, imax = points.length; i < imax; i += 2) {
            values.push(points[i] - cx, points[i + 1] - cy);
        }
        // Create a line
        const result = new EShapeLine();
        result.stroke.set(true, undefined, undefined, strokeWidth);
        result.transform.position.set(cx, cy);
        result.size.set(sx, sy);
        result.points.set(values, segments, pointsStyle);
        return result;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeEmbeddeds {
        static from(serializedOrSimple, controller, mode) {
            const serialized = DDiagrams.toSerialized(serializedOrSimple);
            const pieces = serialized.pieces;
            return DDiagrams.toPieceData(controller, pieces, mode).then((pieceData) => {
                return this.from_(serialized, mode, pieces, pieceData);
            });
        }
        static from_(serialized, mode, pieces, pieceData) {
            const width = serialized.width;
            const height = serialized.height;
            const container = new EShapeEmbeddedLayerContainer(width, height);
            const manager = new EShapeResourceManagerDeserialization(serialized, pieces, pieceData, mode, 1);
            return DDiagrams.newLayer(serialized, container, manager).then(() => {
                return this.create(serialized.name, width, height, container, mode, 0);
            });
        }
        static create(name, width, height, container, mode, depth) {
            const shape = new EShapeEmbedded(name, mode, depth);
            shape.size.set(width, height);
            container.copyTo(shape);
            shape.size.init();
            return shape;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toSvgUrl = (svg) => {
        return `data:image/svg+xml;base64,${btoa(svg)}`;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toGradientImageUrl = (gradient) => {
        const direction = gradient.direction;
        const points = gradient.points;
        let stops = "";
        for (let i = 0, imax = points.length; i < imax; ++i) {
            const point = points[i];
            const color = UtilRgb.toCode(point.color);
            const alpha = point.alpha;
            const offset = point.position * 100;
            stops += `<stop offset="${offset}%" stop-color="#${color}" stop-opacity="${alpha}" />`;
        }
        const radian = (direction * Math.PI) / 180;
        const dx = 0.5 * Math.cos(radian);
        const dy = -0.5 * Math.sin(radian);
        const url = toSvgUrl(
        /* eslint-disable prettier/prettier */
        `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">` +
            `<defs>` +
            `<linearGradient id="o2glkm3aeu2oio" x1="${0.5 - dx}" x2="${0.5 + dx}" y1="${0.5 - dy}" y2="${0.5 + dy}">` +
            stops +
            `</linearGradient>` +
            `</defs>` +
            `<rect x="0" y="0" width="32" height="32" stroke="none" fill="url(#o2glkm3aeu2oio)" />` +
            `</svg>`
        /* eslint-enable prettier/prettier */
        );
        return url;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toSizeRounded = (value) => {
        return Math.round(value * 100) / 100;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toResized = (shape, from, to, centerMode, isPerfect) => {
        const cposition = EShapeCapabilities.contains(shape, EShapeCapability.POSITION);
        const cwidth = EShapeCapabilities.contains(shape, EShapeCapability.WIDTH);
        const cheight = EShapeCapabilities.contains(shape, EShapeCapability.HEIGHT);
        shape.lock(EShapeLockPart.UPLOADED);
        const position = shape.transform.position;
        if (centerMode) {
            const dx = Math.abs(to.x - from.x);
            const dy = Math.abs(to.y - from.y);
            if (isPerfect) {
                const d = Math.max(dx, dy);
                const s = toSizeNormalized(d + d);
                const x = toSizeRounded(from.x);
                const y = toSizeRounded(from.y);
                const size = shape.size;
                if (cwidth && cheight) {
                    size.set(s, s);
                }
                else if (cwidth) {
                    size.x = s;
                }
                else if (cheight) {
                    size.y = s;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
            else {
                const w = toSizeNormalized(dx + dx);
                const h = toSizeNormalized(dy + dy);
                const x = toSizeRounded(from.x);
                const y = toSizeRounded(from.y);
                const size = shape.size;
                if (cwidth && cheight) {
                    size.set(w, h);
                }
                else if (cwidth) {
                    size.x = w;
                }
                else if (cheight) {
                    size.y = h;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
        }
        else {
            if (isPerfect) {
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const d = Math.max(Math.abs(dx), Math.abs(dy));
                const x2 = from.x + (dx < 0 ? -d : +d);
                const y2 = from.y + (dy < 0 ? -d : +d);
                const hd = d * 0.5;
                const s = toSizeNormalized(d);
                const x = toSizeRounded(Math.min(from.x, x2) + hd);
                const y = toSizeRounded(Math.min(from.y, y2) + hd);
                const size = shape.size;
                if (cwidth && cheight) {
                    size.set(s, s);
                }
                else if (cwidth) {
                    size.x = s;
                }
                else if (cheight) {
                    size.y = s;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
            else {
                const x0 = Math.min(from.x, to.x);
                const y0 = Math.min(from.y, to.y);
                const x1 = Math.max(from.x, to.x);
                const y1 = Math.max(from.y, to.y);
                const dx = x1 - x0;
                const dy = y1 - y0;
                const px = dx * 0.5;
                const py = dy * 0.5;
                const w = toSizeNormalized(dx);
                const h = toSizeNormalized(dy);
                const x = toSizeRounded(x0 + px);
                const y = toSizeRounded(y0 + py);
                const size = shape.size;
                if (cwidth && cheight) {
                    size.set(w, h);
                }
                else if (cwidth) {
                    size.x = w;
                }
                else if (cheight) {
                    size.y = h;
                }
                if (cposition) {
                    position.set(x, y);
                }
            }
        }
        shape.unlock(EShapeLockPart.UPLOADED, true);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * @deprecated in favor of {@link EShapeAcceptorEdgeType}.
     */
    const EShapeAcceptorType = EShapeAcceptorEdgeType;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeEditor {
        constructor() {
            this.localTransform = new pixi_js.Matrix();
            this.internalTransform = new pixi_js.Matrix();
            this.internalTransformParentInverse = new pixi_js.Matrix();
            this.rotation = 0;
            this.size = new pixi_js.Point();
        }
    }

    class EShapePointsStyles {
        static from(style) {
            if (isString(style)) {
                return EShapePointsStyle[style];
            }
            else if (isNumber(style)) {
                return style;
            }
            else if (style != null) {
                let result = EShapePointsStyle.NONE;
                for (let i = 0, imax = style.length; i < imax; ++i) {
                    result |= EShapePointsStyle[style[i]];
                }
                return result;
            }
            else {
                return EShapePointsStyle.NONE;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class EShapeResourceManagerSerialization {
        constructor() {
            this.resources = [];
            this.resourceToIndex = new Map();
            this.data = [];
            this.dataToIndex = new Map();
            this.pieces = [];
            this.pieceToIndex = new Map();
            this.uuids = new Set();
            this.uuidNext = 0;
        }
        addResource(resource) {
            return this.add_(resource, this.resources, this.resourceToIndex);
        }
        addData(data) {
            return this.add_(data, this.data, this.dataToIndex);
        }
        addPiece(piece) {
            return this.add_(piece, this.pieces, this.pieceToIndex);
        }
        addUuid(uuid) {
            if (uuid !== 0) {
                const uuids = this.uuids;
                if (uuids.has(uuid)) {
                    return 0;
                }
                else {
                    uuids.add(uuid);
                    return uuid;
                }
            }
            return 0;
        }
        updateUuid(uuid) {
            const uuids = this.uuids;
            if (uuid !== 0) {
                return uuid;
            }
            else {
                const newUuid = this.newUuid();
                uuids.add(newUuid);
                return newUuid;
            }
        }
        newUuid() {
            const uuids = this.uuids;
            let uuidNext = this.uuidNext;
            while (true) {
                uuidNext += 1;
                if (uuidNext !== 0 && !uuids.has(uuidNext)) {
                    this.uuidNext = uuidNext;
                    return uuidNext;
                }
            }
        }
        add_(target, array, map) {
            const result = map.get(target);
            if (result != null) {
                return result;
            }
            const index = array.length;
            array.push(target);
            map.set(target, index);
            return index;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class ESnapperGrid extends pixi_js.utils.EventEmitter {
        constructor(theme, options) {
            var _a, _b, _c;
            super();
            this._isVisibleDefault = (_a = options === null || options === void 0 ? void 0 : options.visible) !== null && _a !== void 0 ? _a : theme.isSnapGridVisible();
            this._isVisible = this._isVisibleDefault;
            this._isEnabledDefault = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isSnapGridEnabled();
            this._isEnabled = this._isEnabledDefault;
            this._sizeDefault = (_c = options === null || options === void 0 ? void 0 : options.size) !== null && _c !== void 0 ? _c : theme.getSnapGridSize();
            this._size = this._sizeDefault;
        }
        get visible() {
            return this._isVisible;
        }
        set visible(visible) {
            if (this._isVisible !== visible) {
                this._isVisible = visible;
                this.emit("change", this);
            }
        }
        get enable() {
            return this._isEnabled;
        }
        set enable(enable) {
            if (this._isEnabled !== enable) {
                this._isEnabled = enable;
                this.emit("change", this);
            }
        }
        get size() {
            return this._size;
        }
        set size(size) {
            if (this._size !== size) {
                this._size = size;
                this.emit("change", size, this);
            }
        }
        snap(value, result) {
            if (this._isEnabled) {
                const size = this._size;
                result.set(value, Math.round(value / size) * size);
            }
        }
        reset() {
            this._isVisible = this._isVisibleDefault;
            this._isEnabled = this._isEnabledDefault;
            this._size = this._sizeDefault;
            this.emit("change", this);
        }
        serialize() {
            return [this._isEnabled ? 1 : 0, this._isVisible ? 1 : 0, this._size];
        }
        deserialize(serialized) {
            this.enable = !!serialized[0];
            if (2 in serialized) {
                this.visible = !!serialized[1];
                this.size = serialized[2];
            }
            else {
                this.visible = this._isVisibleDefault;
                this.size = serialized[1];
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class ESnapperResultScale {
        constructor() {
            this.distance = NaN;
            this.scale = new pixi_js.Point();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class ESnapperResult {
        constructor() {
            this.distance = NaN;
            this.result = 0;
            this.threshold = 10;
        }
        reset(value, scale) {
            this.distance = NaN;
            this.result = value;
            this.threshold = 0.0001 < scale ? 10 / scale : 10;
        }
        set(value, snapped) {
            const newDistance = Math.abs(snapped - value);
            if (newDistance <= this.threshold) {
                const oldDistance = this.distance;
                if (oldDistance !== oldDistance || newDistance < oldDistance) {
                    this.distance = newDistance;
                    this.result = snapped;
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const ESnapperTargetValueType = {
        HORIZONTAL: 0,
        VERTICAL: 1
    };
    class ESnapperTargetValue {
        constructor(type, position) {
            this.type = type;
            this.position = position;
        }
        serialize() {
            return [this.type, this.position];
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class ESnapperTarget extends pixi_js.utils.EventEmitter {
        constructor(theme, options) {
            var _a, _b;
            super();
            this.values = [];
            this._isVisibleDefault = (_a = options === null || options === void 0 ? void 0 : options.visible) !== null && _a !== void 0 ? _a : theme.isSnapTargetVisible();
            this._isVisible = this._isVisibleDefault;
            this._isEnabledDefault = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isSnapTargetEnabled();
            this._isEnabled = this._isEnabledDefault;
        }
        get enable() {
            return this._isEnabled;
        }
        set enable(enable) {
            if (this._isEnabled !== enable) {
                this._isEnabled = enable;
                this.emit("change", this);
            }
        }
        get visible() {
            return this._isVisible;
        }
        set visible(visible) {
            if (this._isVisible !== visible) {
                this._isVisible = visible;
                this.emit("change", this);
            }
        }
        get size() {
            return this.values.length;
        }
        add(target, index) {
            if (index != null) {
                this.values.splice(index, 0, target);
            }
            else {
                this.values.push(target);
            }
            this.emit("change", this);
        }
        remove(index) {
            const values = this.values;
            if (0 <= index && index < values.length) {
                values.splice(index, 1);
                this.emit("change", this);
            }
        }
        replace(index, value) {
            const values = this.values;
            if (0 <= index && index < values.length) {
                const result = values[index];
                values[index] = value;
                this.emit("change", this);
                return result;
            }
            return null;
        }
        swap(indexA, indexB) {
            if (indexA !== indexB) {
                const values = this.values;
                const valueA = values[indexA];
                values[indexA] = values[indexB];
                values[indexB] = valueA;
                this.emit("change", this);
            }
        }
        snap(px, py, x, y) {
            if (this._isEnabled) {
                const values = this.values;
                for (let i = 0, imax = values.length; i < imax; ++i) {
                    const value = values[i];
                    if (value.type === ESnapperTargetValueType.VERTICAL) {
                        x.set(px, value.position);
                    }
                    else {
                        y.set(py, value.position);
                    }
                }
            }
        }
        reset() {
            this._isEnabled = this._isEnabledDefault;
            this._isVisible = this._isVisibleDefault;
            this.values.length = 0;
            this.emit("change", this);
        }
        serialize() {
            const targets = [];
            const values = this.values;
            for (let i = 0, imax = values.length; i < imax; ++i) {
                targets.push(values[i].serialize());
            }
            return [this._isEnabled ? 1 : 0, this._isVisible ? 1 : 0, targets];
        }
        deserialize(serialized) {
            // Availability
            this._isEnabled = !!serialized[0];
            // Visibility
            this._isVisible = !!serialized[1];
            // Values
            const sources = serialized[2];
            const values = this.values;
            values.length = 0;
            for (let i = 0, imax = sources.length; i < imax; ++i) {
                const source = sources[i];
                values.push(new ESnapperTargetValue(source[0], source[1]));
            }
            this.emit("change", this);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const EPSILON = 0.00001;
    const ESnapperModifierAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_CENTER: 2,
        TOP_RIGHT: 3,
        MIDDLE_LEFT: 4,
        MIDDLE_RIGHT: 5,
        BOTTOM_LEFT: 6,
        BOTTOM_CENTER: 7,
        BOTTOM_RIGHT: 8,
        ROTATION: 9
    };
    class ESnapper extends pixi_js.utils.EventEmitter {
        constructor(parent, theme, options) {
            var _a;
            super();
            this._points = [
                new pixi_js.Point(), // Top left
                new pixi_js.Point(), // Top right
                new pixi_js.Point(), // Bottom left
                new pixi_js.Point(), // Bottom right
                new pixi_js.Point() // Center
            ];
            this._normals = [new pixi_js.Point(), new pixi_js.Point()];
            this._lengths = [1, 1];
            this._workScale = new pixi_js.Point();
            this._workSnapResultX = new ESnapperResult();
            this._workSnapResultY = new ESnapperResult();
            this._workScaleResult = {
                distance: 0,
                scale: new pixi_js.Point()
            };
            this._workTranslate = new pixi_js.Point();
            this._workSnapRectangle = new pixi_js.Rectangle();
            this._workSnap = new pixi_js.Point();
            this.grid = new ESnapperGrid(theme, options === null || options === void 0 ? void 0 : options.grid);
            this.target = new ESnapperTarget(theme, options === null || options === void 0 ? void 0 : options.target);
            this._parent = parent;
            this._isEnabledDefault = (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : theme.isSnapEnabled();
            this._isEnabled = this._isEnabledDefault;
        }
        get enable() {
            return this._isEnabled;
        }
        set enable(enable) {
            if (this._isEnabled !== enable) {
                this._isEnabled = enable;
                this.emit("change", this);
            }
        }
        prepare(modifier) {
            modifier.updateTransform();
            const localTransform = modifier.transform.localTransform;
            const sx = modifier.width;
            const sy = modifier.height;
            const points = this._points;
            points[0].set(0, 0);
            points[1].set(sx, 0);
            points[2].set(sx, sy);
            points[3].set(0, sy);
            points[4].set(sx * 0.5, sy * 0.5);
            localTransform.apply(points[0], points[0]);
            localTransform.apply(points[1], points[1]);
            localTransform.apply(points[2], points[2]);
            localTransform.apply(points[3], points[3]);
            localTransform.apply(points[4], points[4]);
        }
        prepareForTranslate(modifier) {
            if (this._isEnabled) {
                this.prepare(modifier);
            }
        }
        snap(point, result) {
            const px = point.x;
            const py = point.y;
            const canvas = this._parent.canvas;
            const x = this._workSnapResultX;
            const y = this._workSnapResultY;
            // Canvas
            if (canvas != null) {
                const scale = Math.max(canvas.scale.x, canvas.scale.y);
                x.reset(px, scale);
                y.reset(py, scale);
                x.set(px, 0);
                x.set(px, canvas.width);
                y.set(py, 0);
                y.set(py, canvas.height);
            }
            else {
                x.reset(px, 1);
                y.reset(py, 1);
            }
            // Target
            this.target.snap(px, py, x, y);
            // Grid
            this.grid.snap(px, x);
            this.grid.snap(py, y);
            //
            result.x = isNaN$1(x.distance) ? NaN : x.result;
            result.y = isNaN$1(y.distance) ? NaN : y.result;
            return result;
        }
        toSnapped(point, result) {
            const px = point.x;
            const py = point.y;
            if (this._isEnabled) {
                this.snap(point, result);
                const x = result.x;
                const y = result.y;
                result.set(isNaN$1(x) ? px : x, isNaN$1(y) ? py : y);
            }
            else {
                result.set(px, py);
            }
            return result;
        }
        toTranslationSnapped(delta, result) {
            const dx = delta.x;
            const dy = delta.y;
            let x = NaN;
            let y = NaN;
            if (this._isEnabled) {
                const workTranslate = this._workTranslate;
                const points = this._points;
                for (let i = 0, imax = points.length; i < imax; ++i) {
                    const point = points[i];
                    workTranslate.set(point.x + dx, point.y + dy);
                    this.snap(workTranslate, workTranslate);
                    // X
                    if (!isNaN$1(workTranslate.x)) {
                        const newDx = workTranslate.x - point.x;
                        if (isNaN$1(x) || Math.abs(newDx - dx) < Math.abs(x - dx)) {
                            x = newDx;
                        }
                    }
                    // Y
                    if (!isNaN$1(workTranslate.y)) {
                        const newDy = workTranslate.y - point.y;
                        if (isNaN$1(y) || Math.abs(newDy - dy) < Math.abs(y - dy)) {
                            y = newDy;
                        }
                    }
                }
            }
            result.x = isNaN$1(x) ? dx : x;
            result.y = isNaN$1(y) ? dy : y;
            return result;
        }
        prepareForRotate(modifier) {
            //
        }
        getGridSizeRotation() {
            return 5;
        }
        toRadian(value) {
            return (value / 180) * Math.PI;
        }
        toDegree(value) {
            return (value / Math.PI) * 180;
        }
        toRotationSnapped(baseRotation, deltaRotation) {
            if (this._isEnabled) {
                const gridSize = this.getGridSizeRotation();
                const newRotation = baseRotation + deltaRotation;
                const newRotationDegree = Math.round(this.toDegree(newRotation));
                const newRotationDegreeResidual = newRotationDegree % 90;
                if (Math.abs(newRotationDegreeResidual) <= gridSize) {
                    return this.toRadian(newRotationDegree - newRotationDegreeResidual) - baseRotation;
                }
                else {
                    if (90 - gridSize <= newRotationDegreeResidual) {
                        return (this.toRadian(newRotationDegree + (90 - newRotationDegreeResidual)) -
                            baseRotation);
                    }
                    else if (newRotationDegreeResidual <= -90 + gridSize) {
                        return (this.toRadian(newRotationDegree - (90 + newRotationDegreeResidual)) -
                            baseRotation);
                    }
                    else {
                        return deltaRotation;
                    }
                }
            }
            return deltaRotation;
        }
        calcNormalizedVector(p0, p1, result) {
            const dx = p1.x - p0.x;
            const dy = p1.y - p0.y;
            const l = Math.sqrt(dx * dx + dy * dy);
            if (EPSILON < l) {
                const d = 1 / l;
                result.x = dx * d;
                result.y = dy * d;
            }
            else {
                result.x = 1;
                result.y = 0;
            }
            return l;
        }
        prepareForScale(modifier, anchor) {
            if (this._isEnabled) {
                this.prepare(modifier);
                const points = this._points;
                const normals = this._normals;
                const lengths = this._lengths;
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[3], points[0], normals[1]);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[3], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[2], points[1], normals[1]);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[1], points[0], normals[0]);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[0], points[1], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        lengths[0] = this.calcNormalizedVector(points[2], points[3], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[0], points[3], normals[1]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        lengths[0] = this.calcNormalizedVector(points[0], points[3], normals[0]);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        lengths[0] = this.calcNormalizedVector(points[3], points[2], normals[0]);
                        lengths[1] = this.calcNormalizedVector(points[1], points[2], normals[1]);
                        break;
                }
            }
        }
        setScaleSnappedResult(distance, length, move, axis, // true => x axis, false y axis
        result) {
            if (EPSILON < length) {
                if (isNaN$1(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    const newScale = 1 + move / length;
                    if (axis) {
                        result.scale.x = newScale;
                    }
                    else {
                        result.scale.y = newScale;
                    }
                }
            }
        }
        calcScaleSnapped1D(transform, point, normal, length, axis, result) {
            const work = this._workScale;
            transform.apply(point, work);
            const tx = work.x;
            const ty = work.y;
            this.snap(work, work);
            const x = work.x;
            const y = work.y;
            // X coordinate
            if (!isNaN$1(x)) {
                const nx = Math.abs(normal.x);
                if (EPSILON < nx) {
                    const dx = (x - tx) / normal.x;
                    const distance = Math.abs(dx);
                    const mx = (x - point.x) / normal.x;
                    this.setScaleSnappedResult(distance, length, mx, axis, result);
                }
            }
            // Y coordinate
            if (!isNaN$1(y)) {
                const ny = Math.abs(normal.y);
                if (EPSILON < ny) {
                    const dy = (y - ty) / normal.y;
                    const distance = Math.abs(dy);
                    const my = (y - point.y) / normal.y;
                    this.setScaleSnappedResult(distance, length, my, axis, result);
                }
            }
        }
        calcScaleSnappedX(transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, true, result);
        }
        calcScaleSnappedY(transform, point, normal, length, result) {
            this.calcScaleSnapped1D(transform, point, normal, length, false, result);
        }
        calcScaleSnapped2D(transform, point, normals, lengths, result) {
            const work = this._workScale;
            transform.apply(point, work);
            const tx = work.x;
            const ty = work.y;
            this.snap(work, work);
            let x = work.x;
            let y = work.y;
            if (isNaN$1(x)) {
                if (isNaN$1(y)) {
                    return;
                }
                else {
                    x = tx;
                }
            }
            else {
                if (isNaN$1(y)) {
                    y = ty;
                }
            }
            // (x, y) = (tx, ty) + normalA * a + normalB * b
            // dx = x - tx
            // dy = y - ty
            // V = ( a, b )^T
            // D = ( dx, dy )^T
            // A = | normalA.x normalB.x |
            //     | normalA.y normalB.y |
            // A V = D
            // det A = normalA.x * normalB.y - normalB.x * normalA.y
            // A^-1 = |  normalB.y -normalB.x | / det A
            //        | -normalA.y  normalA.x |
            const detA = normals[0].x * normals[1].y - normals[1].x * normals[0].y;
            if (EPSILON < Math.abs(detA)) {
                const dx = x - tx;
                const dy = y - ty;
                const distance = Math.abs(dx * dx + dy * dy);
                if (isNaN$1(result.distance) || distance < result.distance) {
                    result.distance = distance;
                    const mdx = x - point.x;
                    const mdy = y - point.y;
                    const mx = (+normals[1].y * mdx - normals[1].x * mdy) / detA;
                    const my = (-normals[0].y * mdx + normals[0].x * mdy) / detA;
                    result.scale.set(1 + mx / lengths[0], 1 + my / lengths[1]);
                }
            }
        }
        calcScaleSnappedXY(transform, pointO, pointX, pointY, normals, lengths, result) {
            this.calcScaleSnapped2D(transform, pointO, normals, lengths, result);
            this.calcScaleSnappedX(transform, pointY, normals[0], lengths[0], result);
            this.calcScaleSnappedY(transform, pointX, normals[1], lengths[1], result);
        }
        toScaleSnapped(transform, anchor, keepRatio, scale) {
            if (this._isEnabled) {
                const points = this._points;
                const normals = this._normals;
                const lengths = this._lengths;
                const work = this._workScaleResult;
                work.distance = NaN;
                work.scale.set(scale.x, scale.y);
                switch (anchor) {
                    case ESnapperModifierAnchor.TOP_LEFT:
                        this.calcScaleSnappedXY(transform, points[0], points[1], points[3], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.TOP_CENTER:
                        this.calcScaleSnappedY(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[1], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.TOP_RIGHT:
                        this.calcScaleSnappedXY(transform, points[1], points[0], points[2], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.MIDDLE_LEFT:
                        this.calcScaleSnappedX(transform, points[0], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.NONE:
                        break;
                    case ESnapperModifierAnchor.MIDDLE_RIGHT:
                        this.calcScaleSnappedX(transform, points[1], normals[0], lengths[0], work);
                        this.calcScaleSnappedX(transform, points[2], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_LEFT:
                        this.calcScaleSnappedXY(transform, points[3], points[2], points[0], normals, lengths, work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_CENTER:
                        this.calcScaleSnappedY(transform, points[2], normals[0], lengths[0], work);
                        this.calcScaleSnappedY(transform, points[3], normals[0], lengths[0], work);
                        break;
                    case ESnapperModifierAnchor.BOTTOM_RIGHT:
                        this.calcScaleSnappedXY(transform, points[2], points[3], points[1], normals, lengths, work);
                        break;
                }
                if (!isNaN$1(work.distance)) {
                    scale.copyFrom(work.scale);
                    if (keepRatio) {
                        switch (anchor) {
                            case ESnapperModifierAnchor.TOP_LEFT:
                            case ESnapperModifierAnchor.TOP_RIGHT:
                            case ESnapperModifierAnchor.BOTTOM_LEFT:
                            case ESnapperModifierAnchor.BOTTOM_RIGHT:
                                scale.x = scale.y = Math.max(scale.x, scale.y);
                                break;
                            case ESnapperModifierAnchor.TOP_CENTER:
                            case ESnapperModifierAnchor.BOTTOM_CENTER:
                                scale.x = scale.y;
                                break;
                            case ESnapperModifierAnchor.MIDDLE_LEFT:
                            case ESnapperModifierAnchor.MIDDLE_RIGHT:
                                scale.y = scale.x;
                                break;
                            case ESnapperModifierAnchor.NONE:
                                break;
                        }
                    }
                    return true;
                }
            }
            return false;
        }
        reset() {
            this.enable = this._isEnabledDefault;
            this.target.reset();
            this.grid.reset();
        }
        serialize() {
            return [this._isEnabled ? 1 : 0, this.target.serialize(), this.grid.serialize()];
        }
        deserialize(serialized) {
            this.enable = !!serialized[0];
            this.target.deserialize(serialized[1]);
            this.grid.deserialize(serialized[2]);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicAtlasItemText extends DynamicAtlasItem {
        constructor(id, text, baseTexture) {
            super(id, text.width, text.height, 0, baseTexture);
            this._text = text;
        }
        render(context) {
            const frame = this.frame;
            context.drawImage(this._text.canvas, frame.x, frame.y, frame.width, frame.height);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicFontAtlasFont {
        constructor(fontId, size, color, padding) {
            this.id = fontId;
            this.size = size;
            this.color = pixi_js.utils.hex2string(color);
            this.height = size + padding * 2;
            this.measured = false;
            this.ascent = 0;
            this.descent = 0;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DynamicFontAtlas {
        constructor(fontId, fontSize, fontColor, resolution) {
            this._id = fontId;
            this._canvas = document.createElement("canvas");
            this._context = null;
            const padding = this.toPadding(fontSize);
            this._padding = padding;
            this._font = new DynamicFontAtlasFont(fontId, fontSize, fontColor, padding);
            this._unrefCount = 0;
            this._width = 1;
            this._height = 1;
            this._revisionUpdated = 0;
            this._texture = pixi_js.Texture.from(this._canvas, {
                mipmap: pixi_js.MIPMAP_MODES.OFF,
                resolution,
                scaleMode: pixi_js.SCALE_MODES.NEAREST
            });
            const characters = new Map();
            characters.set(Character.SPACE, this.newChar(Character.SPACE, DynamicFontAtlasCharacterType.SPACE_R));
            characters.set(Character.TAB, this.newChar(Character.SOFT_TAB, DynamicFontAtlasCharacterType.SPACE_R));
            characters.set(Character.DOTS, this.newChar(Character.DOTS, DynamicFontAtlasCharacterType.LETTER_RNB));
            for (let i = 0, imax = Character.ASCII.length; i < imax; ++i) {
                const ac = Character.ASCII[i];
                characters.set(ac, this.newChar(ac, DynamicFontAtlasCharacterType.LETTER_RNB));
            }
            this._characters = characters;
            this._createds = new Map();
            this._revision = 1;
        }
        toPadding(fontSize) {
            return Math.max(3, Math.ceil(fontSize * 0.2));
        }
        get id() {
            return this._id;
        }
        get font() {
            return this._font;
        }
        get width() {
            return this._width;
        }
        get height() {
            return this._height;
        }
        get canvas() {
            return this._canvas;
        }
        get characters() {
            return this._characters;
        }
        get texture() {
            return this._texture;
        }
        newChar(character, type) {
            const advance = this.getAdvance(character);
            const padding = this._padding;
            const width = Math.ceil(padding + advance + padding);
            const height = this.font.height;
            return new DynamicFontAtlasCharacter(type, character, -width, // Setting X and Y to zeros leads to render the character at the UV coordinate (0, 0).
            -height, width, height, advance);
        }
        add(characters, type) {
            const cs = this._characters;
            const cds = this._createds;
            for (let i = 0, imax = characters.length; i < imax;) {
                if (characters.charCodeAt(i) <= 0xff) {
                    // Ignore ASCII characters
                    i += 1;
                    continue;
                }
                let j = i + 1;
                for (; j < imax; ++j) {
                    const cc = characters.charCodeAt(j);
                    if ((0xdc00 <= cc && cc <= 0xdfff) || (0xfe00 <= cc && cc <= 0xfe0f)) {
                        // Low surrogate
                        // Variation selector
                        continue;
                    }
                    break;
                }
                // Increment the reference count or create a new one
                const nac = characters.substring(i, j);
                const c = cs.get(nac);
                if (c != null) {
                    if (!(c.type & DynamicFontAtlasCharacterType.RESERVED)) {
                        if (c.ref === 0) {
                            this._unrefCount -= 1;
                        }
                        c.ref += 1;
                    }
                }
                else {
                    const cd = cds.get(nac);
                    if (cd != null) {
                        cd.ref = 1;
                        cs.set(nac, cd);
                    }
                    else {
                        const newCharacter = this.newChar(nac, type);
                        cs.set(nac, newCharacter);
                        cds.set(nac, newCharacter);
                    }
                    this._revision += 1;
                }
                // Go to the next
                i = j;
            }
        }
        remove(characters) {
            const cs = this._characters;
            for (let i = 0, imax = characters.length; i < imax;) {
                if (characters.charCodeAt(i) <= 0xff) {
                    // Ignore ASCII characters
                    i += 1;
                    continue;
                }
                let j = i + 1;
                for (; j < imax; ++j) {
                    const cc = characters.charCodeAt(j);
                    if ((0xdc00 <= cc && cc <= 0xdfff) || (0xfe00 <= cc && cc <= 0xfe0f)) {
                        // Low surrogate
                        // Variation selector
                        continue;
                    }
                    break;
                }
                // Decrement the reference count
                const nac = characters.substring(i, j);
                const c = cs.get(nac);
                if (c != null && 0 < c.ref && !(c.type & DynamicFontAtlasCharacterType.RESERVED)) {
                    c.ref -= 1;
                    if (c.ref === 0) {
                        this._unrefCount += 1;
                    }
                }
                // Go to the next
                i = j;
            }
        }
        cleanup() {
            const characters = this._characters;
            if (characters.size >> 1 <= this._unrefCount) {
                characters.forEach((char, id) => {
                    if (char.ref <= 0) {
                        characters.delete(id);
                    }
                });
                this._revision += 1;
                this._unrefCount = 0;
            }
        }
        get(id) {
            return this._characters.get(id);
        }
        getAdvance(target) {
            const context = this.getContext();
            if (context != null) {
                return context.measureText(target).width;
            }
            return 0;
        }
        getContext() {
            let context = this._context;
            if (context == null) {
                const canvas = this._canvas;
                if (canvas != null) {
                    context = this._context = canvas.getContext("2d", { alpha: true });
                    if (context == null) {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
            const font = this._font;
            if (context.font !== font.id) {
                context.font = font.id;
                font.id = context.font;
                context.textAlign = "left";
                context.textBaseline = "alphabetic";
                context.lineWidth = 0;
                context.lineCap = "round";
                context.lineJoin = "miter";
                context.miterLimit = 10;
                context.fillStyle = font.color;
                context.strokeStyle = "#0000ff";
            }
            return context;
        }
        update() {
            this.cleanup();
            if (this._revisionUpdated < this._revision) {
                this._revisionUpdated = this._revision;
                const canvas = this._canvas;
                if (canvas != null) {
                    const font = this._font;
                    const fontHeight = font.height;
                    const characters = this._characters;
                    const width = (this._width = this.toPowerOf2(Math.ceil(Math.sqrt(characters.size)) * fontHeight));
                    const offsetX = this._padding;
                    let x = 0;
                    let y = 0;
                    characters.forEach((character) => {
                        if (width <= x + character.width) {
                            x = 0;
                            y += fontHeight;
                        }
                        character.x = x;
                        character.y = y;
                        character.origin.x = x + offsetX;
                        x += character.width;
                    });
                    const height = (this._height = y + fontHeight);
                    // Make an input canvas
                    // Here, we need to reset the context because
                    // context settings will be lost when we set the width/height.
                    const baseTexture = this._texture.baseTexture;
                    const resolution = baseTexture.resolution;
                    const realWidth = Math.ceil(width * resolution);
                    const realHeight = Math.ceil(height * resolution);
                    canvas.width = realWidth;
                    canvas.height = realHeight;
                    const context = this.getContext();
                    if (context != null) {
                        UtilFont.measure(context, font);
                        const offsetY = Math.round((fontHeight - (font.ascent + font.descent)) * 0.5 + font.ascent);
                        context.save();
                        context.scale(resolution, resolution);
                        context.clearRect(0, 0, width, height);
                        characters.forEach((character) => {
                            character.origin.y = character.y + offsetY;
                            context.fillText(character.character, character.origin.x, character.origin.y);
                        });
                        context.restore();
                    }
                    baseTexture.setRealSize(realWidth, realHeight);
                    return true;
                }
            }
            return false;
        }
        getRevision() {
            return this._revision;
        }
        getRevisionUpdate() {
            return this._revisionUpdated;
        }
        get length() {
            return this._characters.size;
        }
        destroy() {
            const canvas = this._canvas;
            if (canvas != null) {
                this._canvas = null;
            }
            this._characters.clear();
            this._createds.clear();
            this._unrefCount = 0;
        }
        toPowerOf2(size) {
            let result = 32;
            while (result < size) {
                result <<= 1;
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const update = (atlas) => {
        atlas.update();
    };
    const updateAll = (colorToAltas) => {
        colorToAltas.forEach(update);
    };
    const destroy = (atlas) => {
        atlas.update();
    };
    const destroyAll = (colorToAltas) => {
        colorToAltas.forEach(destroy);
    };
    class DynamicFontAtlases {
        constructor(layer) {
            this._atlases = new Map();
            this._resolution = layer.renderer.resolution;
            layer.renderer.on("prerender", () => {
                this.update();
            });
        }
        add(fontId, fontSize, fontColor, targets) {
            const atlases = this._atlases;
            let colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                colorToAtlas = new Map();
                atlases.set(fontId, colorToAtlas);
            }
            let atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                atlas = new DynamicFontAtlas(fontId, fontSize, fontColor, this._resolution);
                colorToAtlas.set(fontColor, atlas);
            }
            atlas.add(targets, DynamicFontAtlasCharacterType.LETTER);
        }
        remove(fontId, fontColor, targets) {
            const colorToAtlas = this._atlases.get(fontId);
            if (colorToAtlas != null) {
                const atlas = colorToAtlas.get(fontColor);
                if (atlas != null) {
                    atlas.remove(targets);
                }
            }
        }
        get(fontId, fontColor) {
            const atlases = this._atlases;
            const colorToAtlas = atlases.get(fontId);
            if (colorToAtlas == null) {
                return null;
            }
            const atlas = colorToAtlas.get(fontColor);
            if (atlas == null) {
                return null;
            }
            return atlas;
        }
        update() {
            this._atlases.forEach(updateAll);
        }
        destroy() {
            const atlases = this._atlases;
            atlases.forEach(destroyAll);
            atlases.clear();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const isObject = (target) => {
        if (typeof target === "object" &&
            Object.prototype.toString.call(target) === "[object Object]") {
            const prototype = Object.getPrototypeOf(target);
            return prototype == null || prototype === Object.prototype;
        }
        return false;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class Lazy {
        constructor(newInstance, options, base) {
            this.instance = null;
            this.newInstance = newInstance;
            this.options = options;
            if (base != null) {
                if (base.state.isActive) {
                    setTimeout(() => {
                        this.get();
                    }, 0);
                }
                base.on("active", () => {
                    this.get();
                });
            }
        }
        get() {
            let result = this.instance;
            if (result == null) {
                result = new this.newInstance(this.options);
                this.instance = result;
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Returns a ceiling index of the given value.
     * The array must be sorted in an ascending order.
     *
     * @param array an array sorted in an ascending order
     * @param value a value to be searched
     * @returns a ceiling index of the given value
     */
    const toCeilingIndex = (array, value, size, offset) => {
        let i0 = 0;
        let i1 = Math.floor(array.length / size) - 1;
        while (i0 <= i1) {
            const i2 = i0 + ((i1 - i0) >> 1);
            const v2 = array[i2 * size + offset];
            if (value < v2) {
                i1 = i2 - 1;
            }
            else if (v2 < value) {
                i0 = i2 + 1;
            }
            else {
                return i2;
            }
        }
        return Math.max(i0, i1);
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toClonedArray = (target) => {
        const result = [];
        for (let i = 0, imax = target.length; i < imax; ++i) {
            result[i] = target[i];
        }
        return result;
    };
    const toClonedObject = (target) => {
        const result = {};
        for (const key in target) {
            if (Object.hasOwnProperty.call(target, key)) {
                result[key] = toCloned(target[key]);
            }
        }
        return result;
    };
    const toCloned = (target) => {
        if (isArray(target)) {
            return toClonedArray(target);
        }
        else if (isObject(target)) {
            return toClonedObject(target);
        }
        return target;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toId = (target) => {
        if (target != null) {
            if (isString(target)) {
                return target;
            }
            else if (isNumber(target)) {
                return target;
            }
            else if ("id" in target) {
                return target.id;
            }
            else if ("name" in target) {
                return target.name;
            }
            else if ("label" in target) {
                return target.label;
            }
        }
        return 0;
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toLabel$1 = (target) => {
        if (target != null) {
            if (isString(target)) {
                return target;
            }
            else if (isNumber(target)) {
                return String(target);
            }
            else if ("name" in target) {
                return target.name;
            }
            else if ("label" in target) {
                return target.label;
            }
            else if ("id" in target) {
                return target.id;
            }
        }
        return "";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toMerged = (one, other) => {
        if (one != null) {
            const o = toCloned(one);
            if (other != null) {
                for (const key in other) {
                    if (Object.prototype.hasOwnProperty.call(other, key)) {
                        const otherValue = other[key];
                        if (isObject(otherValue)) {
                            if (Object.prototype.hasOwnProperty.call(o, key)) {
                                const oneValue = o[key];
                                if (isObject(oneValue)) {
                                    toMerged(oneValue, otherValue);
                                }
                            }
                            else {
                                o[key] = toCloned(otherValue);
                            }
                        }
                        else {
                            if (!Object.prototype.hasOwnProperty.call(o, key)) {
                                o[key] = otherValue;
                            }
                        }
                    }
                }
            }
            return o;
        }
        else if (other != null) {
            return toCloned(other);
        }
        else {
            return {};
        }
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toString = (value) => {
        return value != null ? String(value) : "";
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toSvgTexture = (svg, resolution) => {
        return pixi_js.Texture.from(toSvgUrl(svg), {
            resolution
        });
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilSvgAtlasBuilder {
        constructor(options) {
            var _a, _b, _c, _d, _e, _f;
            this._width = (_a = options.width) !== null && _a !== void 0 ? _a : 256;
            this._ratio = (_b = options.ratio) !== null && _b !== void 0 ? _b : 1;
            this._margin = (_c = options.margin) !== null && _c !== void 0 ? _c : 3;
            const resolution = options.resolution;
            if (resolution != null) {
                this._resolution = resolution;
            }
            else {
                const dpr = (_d = window.devicePixelRatio) !== null && _d !== void 0 ? _d : 1;
                this._resolution = 2 < dpr ? dpr : dpr * 2;
            }
            this._scaling = (_e = options.scaling) !== null && _e !== void 0 ? _e : pixi_js.settings.SCALE_MODE;
            this._mipmap = (_f = options.mipmap) !== null && _f !== void 0 ? _f : pixi_js.settings.MIPMAP_TEXTURES;
            this._frames = {};
            this._svg = "";
            this._nextX = 0;
            this._nextY = 0;
            this._height = 0;
        }
        get width() {
            return this._width;
        }
        get ratio() {
            return this._ratio;
        }
        get margin() {
            return this._margin;
        }
        add(name, width, height, path, frameX, frameY, frameWidth, frameHeight) {
            const frames = this._frames;
            if (!(name in frames)) {
                // Position
                const margin = this._margin;
                let x = this._nextX;
                let y = this._nextY;
                if (this._width <= x + width) {
                    x = 0;
                    y = this._nextY + this._height + margin;
                    this._height = height;
                    this._nextY = y;
                }
                else {
                    this._height = Math.max(this._height, height);
                }
                this._nextX = x + width + margin;
                // Frame
                frames[name] = new pixi_js.Rectangle(x + (frameX !== null && frameX !== void 0 ? frameX : 0), y + (frameY !== null && frameY !== void 0 ? frameY : 0), frameWidth !== null && frameWidth !== void 0 ? frameWidth : width, frameHeight !== null && frameHeight !== void 0 ? frameHeight : height);
                // Svg
                const ratio = this._ratio;
                this._svg += `<g transform="translate(${x * ratio},${y * ratio})">${path}</g>`;
                return true;
            }
            return false;
        }
        has(name) {
            return name in this._frames;
        }
        get mappings() {
            return this.build();
        }
        build(options) {
            var _a, _b;
            let built = this._built;
            if (built == null || (options === null || options === void 0 ? void 0 : options.force)) {
                const resolution = (_a = options === null || options === void 0 ? void 0 : options.resolution) !== null && _a !== void 0 ? _a : this._resolution;
                const width = this._width;
                const height = Math.pow(2, Math.ceil(Math.log(this._nextY + this._height) / Math.LN2));
                const realWidth = width * resolution;
                const realHeight = height * resolution;
                const ratio = this._ratio;
                const attrWidth = `width="${realWidth}"`;
                const attrHeight = `height="${realHeight}"`;
                const attrViewBox = `viewBox="0 0 ${width * ratio} ${height * ratio}"`;
                const attrXmlns = `xmlns="http://www.w3.org/2000/svg"`;
                const url = toSvgUrl(`<svg ${attrWidth} ${attrHeight} ${attrViewBox} ${attrXmlns}>${this._svg}</svg>`);
                const scaleMode = (_b = options === null || options === void 0 ? void 0 : options.scaling) !== null && _b !== void 0 ? _b : this._scaling;
                const baseTexture = pixi_js.BaseTexture.from(url, {
                    resolution,
                    scaleMode,
                    mipmap: this._mipmap
                });
                const frames = this._frames;
                built = this._built = {};
                for (const name in frames) {
                    built[name] = new pixi_js.Texture(baseTexture, frames[name]);
                }
            }
            return built;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An output format.
     */
    const UtilFileAs = {
        TEXT: 0,
        DATA_URL: 1,
        BINARY_STRING: 2,
        ARRAY_BUTTER: 3,
        FILE: 4
    };
    /**
     * An utility class for opening files.
     */
    class UtilFileOpener {
        constructor(as, facade) {
            this._input = null;
            this._as = as;
            this._facade = facade;
        }
        open() {
            const input = this.getOrCreateInput();
            if (input != null) {
                input.click();
            }
            else {
                this.onCancel();
            }
        }
        getOrCreateInput() {
            if ("FileReader" in window && this._input == null) {
                const input = document.createElement("input");
                this._input = input;
                input.setAttribute("type", "file");
                input.setAttribute("style", "display:none");
                input.addEventListener("change", (e) => {
                    this.onInputChange(input);
                    input.value = "";
                    e.stopImmediatePropagation();
                    e.preventDefault();
                });
                document.body.appendChild(input);
            }
            return this._input;
        }
        onInputChange(input) {
            const files = input.files;
            if (files != null && 0 < files.length) {
                const file = files[0];
                if (this._as === UtilFileAs.FILE) {
                    this.onOpen(file, file);
                }
                else {
                    const fileReader = new FileReader();
                    fileReader.onload = (e) => {
                        if (e.target != null) {
                            const target = e.target;
                            this.onOpen(target.result, file);
                        }
                    };
                    fileReader.onabort = (e) => {
                        this.onAboart(e);
                    };
                    switch (this._as) {
                        case UtilFileAs.TEXT:
                            fileReader.readAsText(file);
                            break;
                        case UtilFileAs.DATA_URL:
                            fileReader.readAsDataURL(file);
                            break;
                        case UtilFileAs.BINARY_STRING:
                            fileReader.readAsBinaryString(file);
                            break;
                        case UtilFileAs.ARRAY_BUTTER:
                            fileReader.readAsArrayBuffer(file);
                            break;
                        default:
                            fileReader.readAsText(file);
                            break;
                    }
                }
            }
            else {
                this.onCancel();
            }
        }
        onOpen(result, file) {
            const facade = this._facade;
            facade.emit("open", result, file, facade);
        }
        onAboart(e) {
            const facade = this._facade;
            facade.emit("abort", e, facade);
        }
        onCancel() {
            const facade = this._facade;
            facade.emit("cancel", facade);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilHsv {
        /**
         * Returns HSV colors.
         * Ranges of components are:
         *
         * * H: [0, 360)
         * * S: [0, 255]
         * * V: [0, 255]
         *
         * @param color a rgb color
         * @return an array of hsv components
         */
        static fromRgb(color) {
            const r = (color & 0xff0000) >> 16;
            const g = (color & 0x00ff00) >> 8;
            const b = (color & 0x0000ff) | 0;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const length = max - min;
            let h = 0;
            if (0 < length) {
                if (r === max) {
                    h = (60 * (g - b)) / length;
                }
                else if (g === max) {
                    h = (60 * (b - r)) / length + 120;
                }
                else if (b === max) {
                    h = (60 * (r - g)) / length + 240;
                }
                if (h < 0) {
                    h += 360;
                }
            }
            const s = (length / max) * 255;
            const v = max;
            return [h, s, v];
        }
        static toRgb(h, s, v) {
            const max = v;
            const min = v - (s / 255) * v;
            const length = max - min;
            let r = 0;
            let g = 0;
            let b = 0;
            if (h <= 60) {
                r = max;
                g = (h / 60) * length + min;
                b = min;
            }
            else if (h <= 120) {
                r = ((120 - h) / 60) * length + min;
                g = max;
                b = min;
            }
            else if (h <= 180) {
                r = min;
                g = max;
                b = ((h - 120) / 60) * length + min;
            }
            else if (h <= 240) {
                r = min;
                g = ((240 - h) / 60) * length + min;
                b = max;
            }
            else if (h <= 300) {
                r = ((h - 240) / 60) * length + min;
                g = min;
                b = max;
            }
            else {
                r = max;
                g = min;
                b = ((360 - h) / 60) * length + min;
            }
            r = Math.max(0, Math.min(255, r));
            g = Math.max(0, Math.min(255, g));
            b = Math.max(0, Math.min(255, b));
            return (r << 16) | (g << 8) | b;
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilInputTextArea extends UtilInput {
        onElementAttached(element, before, after) {
            element.addEventListener("keydown", this._onInputKeyDownBound);
            super.onElementAttached(element, before, after);
        }
        onElementDetached(element, before, after) {
            element.removeEventListener("keydown", this._onInputKeyDownBound);
            super.onElementDetached(element, before, after);
        }
        onInputKeyDown(e) {
            if (UtilKeyboardEvent.isOkKey(e)) {
                this._operation.onEnter();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilName {
        static create(type) {
            const mapping = this._mapping;
            if (type in mapping) {
                return `${type} ${++mapping[type]}`;
            }
            else {
                mapping[type] = 1;
                return `${type} 1`;
            }
        }
    }
    UtilName._mapping = {};

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilRgba {
        static toCode(color, alpha) {
            const r = (color >> 16) & 0xff;
            const g = (color >> 8) & 0xff;
            const b = color & 0xff;
            return `rgba(${r},${g},${b},${alpha})`;
        }
    }

    class UtilStateBlinker {
        constructor(state, delay, interval) {
            this._targets = new Set();
            this._state = state;
            this._delay = delay;
            this._interval = interval;
            this._timeout = null;
            this._updateBound = () => {
                this.update();
            };
        }
        start() {
            if (this._timeout == null) {
                this._timeout = window.setTimeout(this._updateBound, this._delay);
            }
            return this;
        }
        stop() {
            const timeout = this._timeout;
            if (timeout != null) {
                this._timeout = null;
                clearTimeout(timeout);
            }
            return this;
        }
        add(target) {
            this._targets.add(target);
            target.state.set(this._state, this.isOn(Date.now()));
            return this;
        }
        remove(target) {
            if (this._targets.delete(target)) {
                target.state.remove(this._state);
                return true;
            }
            return false;
        }
        contains(target) {
            return this._targets.has(target);
        }
        clear() {
            this._targets.clear();
            return this;
        }
        isOn(time) {
            return Math.floor(time / this._interval) % 2 === 0;
        }
        update() {
            const now = Date.now();
            const isOn = this.isOn(now);
            const state = this._state;
            this._targets.forEach((target) => {
                target.state.set(state, isOn);
            });
            const interval = this._interval;
            this._timeout = window.setTimeout(this._updateBound, interval - (now % interval));
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilTransition {
        constructor(options) {
            var _a;
            this._duration = (_a = options === null || options === void 0 ? void 0 : options.duration) !== null && _a !== void 0 ? _a : 300;
            this._current = null;
            this._lastUpdate = 0;
            this._updateId = null;
        }
        show(next, forcibly) {
            const updateId = this._updateId;
            if (updateId != null) {
                clearTimeout(updateId);
            }
            const current = this._current;
            if (next !== current) {
                const duration = this._duration;
                const lastUpdate = this._lastUpdate;
                const now = Date.now();
                const remaining = lastUpdate + duration - now;
                if (forcibly === true || remaining <= 0) {
                    this.update(now, next);
                }
                else {
                    this._updateId = window.setTimeout(() => {
                        this.update(Date.now(), next);
                    }, remaining);
                }
            }
        }
        update(now, next) {
            const current = this._current;
            if (current !== next) {
                this._lastUpdate = now;
                if (current != null) {
                    current.hide();
                }
                this._current = next;
                if (next != null) {
                    next.show();
                }
            }
        }
        hide() {
            this.show(null);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /*!
     * jQuery Mousewheel 3.1.13
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * See also https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
     * and https://github.com/openlayers/openlayers/blob/v5.2.0/src/ol/interaction/MouseWheelZoom.js#L51
     */
    class UtilWheelEvent {
        constructor() {
            this._lowest = null;
            this._timestamp = 0;
            this._lineHeight = null;
            this._pageHeight = null;
        }
        getNames() {
            let result = this._names;
            if (result == null) {
                if ("onwheel" in document || 9 <= document.documentMode) {
                    result = ["wheel"];
                }
                else {
                    result = ["mousewheel", "DOMMouseScroll", "MozMousePixelScroll"];
                }
                this._names = result;
            }
            return result;
        }
        on(target, handler, useCapture = false) {
            const names = this.getNames();
            for (let i = names.length - 1; 0 <= i; --i) {
                const name = names[i];
                target.addEventListener(name, handler, useCapture);
            }
        }
        off(target, handler, useCapture = false) {
            const names = this.getNames();
            for (let i = names.length - 1; 0 <= i; --i) {
                const name = names[i];
                target.removeEventListener(name, handler, useCapture);
            }
        }
        getLineHeight() {
            if (this._lineHeight == null) {
                const theme = DThemes.getInstance().get("DBase");
                this._lineHeight = theme.getLineHeight();
            }
            return this._lineHeight;
        }
        getPageHeight() {
            if (this._pageHeight == null) {
                this._pageHeight = this.getLineHeight() * 12;
            }
            return this._pageHeight;
        }
        normalize(e) {
            let deltaX = 0;
            let deltaY = 0;
            // Old school scrollwheel delta
            if ("detail" in e) {
                deltaY = e.detail * -1;
            }
            if ("wheelDelta" in e) {
                deltaY = e.wheelDelta;
            }
            if ("wheelDeltaY" in e) {
                deltaY = e.wheelDeltaY;
            }
            if ("wheelDeltaX" in e) {
                deltaX = e.wheelDeltaX * -1;
            }
            // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
            if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
                deltaX = deltaY * -1;
                deltaY = 0;
            }
            // New school wheel delta (wheel event)
            if ("deltaY" in e) {
                deltaY = e.deltaY * -1;
            }
            if ("deltaX" in e) {
                deltaX = e.deltaX;
            }
            // No change actually happened, no reason to go any further
            if (deltaY === 0 && deltaX === 0) {
                return null;
            }
            // Store lowest absolute delta to normalize the delta values
            let delta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
            // Reset the this._lowest to better handle multiple device types
            // that give different a different lowestDelta
            // Ex: trackpad = 3 and mouse wheel = 120
            const now = Date.now();
            if (this._timestamp + 200 <= now) {
                this._lowest = null;
            }
            this._timestamp = now;
            //
            const shouldAdjust = e.type === "mousewheel" && delta % 120 === 0;
            if (!this._lowest || delta < this._lowest) {
                this._lowest = delta;
                // Adjust older deltas if necessary
                if (shouldAdjust) {
                    this._lowest /= 40;
                }
            }
            // Adjust older deltas if necessary
            if (shouldAdjust) {
                // Divide all the things by 40!
                delta /= 40;
                deltaX /= 40;
                deltaY /= 40;
            }
            // Get a whole, normalized value for the deltas
            const lowest = this._lowest;
            delta = Math.floor(delta / lowest);
            deltaX = Math[1 <= deltaX ? "floor" : "ceil"](deltaX / lowest);
            deltaY = Math[1 <= deltaY ? "floor" : "ceil"](deltaY / lowest);
            // Mode
            const mode = e.deltaMode || 0;
            if (mode !== 0) {
                const scale = mode === 1 ? this.getLineHeight() : this.getPageHeight();
                delta *= scale;
                deltaX *= scale;
                deltaY *= scale;
            }
            return {
                mode,
                delta,
                deltaX,
                deltaY,
                lowest
            };
        }
        static getInstance() {
            if (this.INSTANCE == null) {
                this.INSTANCE = new UtilWheelEvent();
            }
            return this.INSTANCE;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DAnimationEmpty extends pixi_js.utils.EventEmitter {
        constructor(options) {
            var _a;
            super();
            this._target = (_a = options === null || options === void 0 ? void 0 : options.target) !== null && _a !== void 0 ? _a : null;
            this._reverse = false;
            this._isStarted = false;
            this._onTime = options === null || options === void 0 ? void 0 : options.onTime;
            this._onStart = options === null || options === void 0 ? void 0 : options.onStart;
            this._onEnd = options === null || options === void 0 ? void 0 : options.onEnd;
        }
        get target() {
            return this._target;
        }
        set target(target) {
            this._target = target;
        }
        get duration() {
            return 0;
        }
        set duration(duration) {
            // DO NOTHING
        }
        start(reverse = false) {
            this.stop();
            this._isStarted = true;
            this._reverse = reverse;
            // onStart
            this.onStart(reverse);
            if (!this._isStarted) {
                return;
            }
            // onTime
            this.onTime(reverse ? 1 : 0, reverse, 0);
            if (!this._isStarted) {
                return;
            }
            this.onTime(reverse ? 0 : 1, reverse, 0);
            if (this._isStarted) {
                return;
            }
            // OnEnd
            this.onEnd(reverse);
        }
        onStart(isReverse) {
            const onStart = this._onStart;
            if (onStart != null) {
                onStart(isReverse, this);
            }
            this.emit("start", isReverse, this);
        }
        onTime(time, isReverse, elapsedTime) {
            const onTime = this._onTime;
            if (onTime != null) {
                onTime(time, isReverse, elapsedTime, this);
            }
            this.emit("time", time, isReverse, elapsedTime, this);
        }
        onEnd(isReverse) {
            const onEnd = this._onEnd;
            if (onEnd != null) {
                onEnd(isReverse, this);
            }
            this.emit("end", isReverse, this);
        }
        isStarted() {
            return this._isStarted;
        }
        isReverse() {
            return this._reverse;
        }
        stop() {
            this._isStarted = false;
        }
        end() {
            const isStarted = this._isStarted;
            if (isStarted) {
                this._isStarted = false;
                // OnTime
                const reverse = this._reverse;
                const time = reverse ? 0 : 1;
                this.onTime(time, reverse, 0);
                // OnEnd
                this.onEnd(reverse);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DAnimationFadeIn extends DAnimationBase {
        constructor(options) {
            var _a, _b;
            super(options);
            this._storedX = 0;
            this._storedY = 0;
            this._storedAlpha = 0;
            this._storedTime = 0;
            this._storedTarget = null;
            this._layer = null;
            // Shifts
            const shift = options === null || options === void 0 ? void 0 : options.shift;
            this._shiftX = (_a = shift === null || shift === void 0 ? void 0 : shift.x) !== null && _a !== void 0 ? _a : 0;
            this._shiftY = (_b = shift === null || shift === void 0 ? void 0 : shift.y) !== null && _b !== void 0 ? _b : 15;
            this._onPrerenderBound = () => {
                this.onPrerender();
            };
            this._onPostrenderBound = () => {
                this.onPostrender();
            };
        }
        stop() {
            this._storedTime = 0;
            this.removeEventListeners();
            super.stop();
        }
        addEventListeners(target) {
            const layer = DApplications.getLayer(target);
            if (layer) {
                this._layer = layer;
                const renderer = layer.renderer;
                renderer.on("prerender", this._onPrerenderBound);
                renderer.on("postrender", this._onPostrenderBound);
            }
        }
        removeEventListeners() {
            const layer = this._layer;
            if (layer) {
                this._layer = null;
                const renderer = layer.renderer;
                renderer.off("prerender", this._onPrerenderBound);
                renderer.off("postrender", this._onPostrenderBound);
            }
        }
        onStart(isReverse) {
            const target = (this._storedTarget = this._target);
            if (target != null) {
                this._storedTime = 0;
                this.removeEventListeners();
                this.addEventListeners(target);
                if (!isReverse) {
                    target.visible = true;
                }
                super.onStart(isReverse);
            }
        }
        onTime(time, isReverse, elapsedTime) {
            const target = this._storedTarget;
            if (target != null) {
                const layer = this._layer;
                if (layer) {
                    this._storedTime = time;
                    super.onTime(time, isReverse, elapsedTime);
                    layer.update();
                }
                else {
                    this._storedTime = time;
                    super.onTime(time, isReverse, elapsedTime);
                }
            }
        }
        onEnd(isReverse) {
            const target = this._storedTarget;
            if (target != null) {
                this.removeEventListeners();
                if (isReverse) {
                    target.visible = false;
                }
                super.onEnd(isReverse);
            }
        }
        onPrerender() {
            const target = this._storedTarget;
            if (target != null) {
                const storedTime = this._storedTime;
                // Position
                const position = target.unsafe.position;
                this._storedX = position.x;
                this._storedY = position.y;
                position.set(position.x - this._shiftX * (1 - storedTime), position.y - this._shiftY * (1 - storedTime));
                // Alpha
                this._storedAlpha = target.alpha;
                target.alpha = storedTime;
            }
        }
        onPostrender() {
            const target = this._storedTarget;
            if (target != null) {
                // Position
                const position = target.unsafe.position;
                position.set(this._storedX, this._storedY);
                // Alpha
                target.alpha = this._storedAlpha;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DApplicationPadding {
        constructor(padding) {
            var _a, _b, _c, _d;
            if (isNumber(padding)) {
                this.top = padding;
                this.right = padding;
                this.bottom = padding;
                this.left = padding;
            }
            else if (padding != null) {
                this.top = (_a = padding.top) !== null && _a !== void 0 ? _a : 6;
                this.right = (_b = padding.right) !== null && _b !== void 0 ? _b : 6;
                this.bottom = (_c = padding.bottom) !== null && _c !== void 0 ? _c : 6;
                this.left = (_d = padding.left) !== null && _d !== void 0 ? _d : 6;
            }
            else {
                this.top = 6;
                this.right = 6;
                this.bottom = 6;
                this.left = 6;
            }
        }
        getTheme() {
            throw new Error("Not supported");
        }
        setTheme(theme) {
            throw new Error("Not supported");
        }
        getTop() {
            return this.left;
        }
        getRight() {
            return this.right;
        }
        getBottom() {
            return this.bottom;
        }
        getLeft() {
            return this.left;
        }
        set(top, right, bottom, left) {
            if (right == null) {
                this.top = top;
                this.right = top;
                this.bottom = top;
                this.left = top;
            }
            else if (bottom == null) {
                this.top = top;
                this.right = right;
                this.bottom = top;
                this.left = right;
            }
            else if (left == null) {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = right;
            }
            else {
                this.top = top;
                this.right = right;
                this.bottom = bottom;
                this.left = left;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * DApplicationLayer options
     */
    class DApplicationLayerOptions {
        constructor(options) {
            var _a;
            // Root
            const root = options.root;
            this._root = root;
            // Overlay mode or not
            this._overlay = options.overlay;
            // Padding
            this._padding = new DApplicationPadding(options === null || options === void 0 ? void 0 : options.padding);
            // Width & height
            let width = 100;
            let height = 100;
            if (options) {
                if (options.width != null) {
                    width = options.width;
                    if (options.height != null) {
                        height = options.height;
                    }
                    else {
                        height = root.getBoundingClientRect().height;
                    }
                }
                else if (options.height != null) {
                    width = root.getBoundingClientRect().width;
                    height = options.height;
                }
                else {
                    const bbox = root.getBoundingClientRect();
                    width = bbox.width;
                    height = bbox.height;
                }
            }
            else {
                const bbox = root.getBoundingClientRect();
                width = bbox.width;
                height = bbox.height;
            }
            this._isWidthFixed = options.width != null;
            this._isHeightFixed = options.height != null;
            // Background color
            const background = options === null || options === void 0 ? void 0 : options.background;
            let backgroundColor = 0;
            let transparent = true;
            if (background != null) {
                const color = background.color;
                if (color != null) {
                    backgroundColor = color;
                    transparent = false;
                }
            }
            // Resolution
            const resolution = options.resolution;
            // Antialias
            const antialias = (_a = options === null || options === void 0 ? void 0 : options.antialias) !== null && _a !== void 0 ? _a : false;
            // Pixi
            this._pixi = {
                width,
                height,
                autoStart: false,
                backgroundColor,
                transparent,
                resolution,
                antialias
            };
        }
        /**
         * Returns a root element.
         * `HTMLCanvasElement` and other DOM elements are created in this element.
         * The default root element is `document.body`.
         */
        getRootElement() {
            return this._root;
        }
        /**
         * Sets a root element and updates the canvas width and height
         * if `updateWidthAndHeight` is not false.
         *
         * @param root new root element
         * @param updateWidthAndHeight false to preserve the canvas width / height
         */
        setRootElement(root, updateWidthAndHeight) {
            if (this._root !== root) {
                this._root = root;
                if (updateWidthAndHeight !== false) {
                    const bbox = root.getBoundingClientRect();
                    const pixi = this._pixi;
                    pixi.width = bbox.width;
                    pixi.height = bbox.height;
                }
            }
            return this;
        }
        /**
         * Returns a canvas width.
         */
        getWidth() {
            return this._pixi.width;
        }
        /**
         * Sets a canvas width.
         *
         * @param width new canvas width
         */
        setWidth(width) {
            this._pixi.width = width;
            return this;
        }
        /**
         * Returns true if the width is fixed.
         *
         * @returns true if the width is fixed.
         */
        isWidthFixed() {
            return this._isWidthFixed;
        }
        /**
         * Makes the canvas width fixed.
         *
         * @param fixed true to make the canvas width fixed
         */
        setWidthFixed(fixed) {
            this._isWidthFixed = fixed;
            return this;
        }
        /**
         * Returns a canvas height.
         */
        getHeight() {
            return this._pixi.height;
        }
        /**
         * Sets a canvas height.
         *
         * @param height new canvas height
         */
        setHeight(height) {
            this._pixi.height = height;
            return this;
        }
        /**
         * Returns true if the height is fixed.
         *
         * @returns true if the height is fixed.
         */
        isHeightFixed() {
            return this._isHeightFixed;
        }
        /**
         * Makes the canvas height fixed.
         *
         * @param fixed true to make the canvas height fixed
         */
        setHeightFixed(fixed) {
            this._isHeightFixed = fixed;
            return this;
        }
        /**
         * Returns padding sizes.
         * The default padding size is 6.
         */
        getPadding() {
            return this._padding;
        }
        /**
         * Sets padding sizes.
         *
         * @param left new left padding
         * @param top new top padding
         * @param right new right padding
         * @param bottom new bottom padding
         */
        setPadding(left, top, right, bottom) {
            const padding = this._padding;
            padding.left = left;
            padding.top = top;
            padding.right = right;
            padding.bottom = bottom;
            return this;
        }
        /**
         * Returns a background color.
         */
        getBackgroundColor() {
            return this._pixi.backgroundColor;
        }
        /**
         * Sets a background color.
         *
         * @param color new background color
         */
        setBackgroundColor(color) {
            this._pixi.backgroundColor = color;
            return this;
        }
        /**
         * Returns an antialias setting.
         * The default antialias setting is false.
         */
        getAntialias() {
            return this._pixi.antialias;
        }
        /**
         * Sets an antialias setting.
         *
         * @param antialias new antialias setting
         */
        setAntialias(antialias) {
            this._pixi.antialias = antialias;
            return this;
        }
        /**
         * Returns true if a layer is supposed to be an overlay layer.
         */
        isOverlay() {
            return this._overlay;
        }
        getPixiApplicationOptions() {
            return this._pixi;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DCommandBase {
        isStorable() {
            return true;
        }
        isClear() {
            return false;
        }
        isClean() {
            return false;
        }
        execute() {
            return true;
        }
        merge(target) {
            return false;
        }
        isMerged() {
            return false;
        }
        redo() {
            return true;
        }
        undo() {
            return true;
        }
        destroy() {
            // DO NOTHING
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DCommandClear extends DCommandBase {
        isStorable() {
            return false;
        }
        isClear() {
            return true;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DControllerCommandImpl extends pixi_js.utils.EventEmitter {
        constructor() {
            super();
            this._position = 0;
            this._done = [];
        }
        last() {
            const done = this._done;
            const doneLength = done.length;
            if (0 < doneLength) {
                return done[doneLength - 1];
            }
            else {
                return null;
            }
        }
        push(command) {
            this.merge(command);
            this.execute(command);
        }
        merge(command) {
            const done = this._done;
            const isClear = command.isClear();
            const isStorable = command.isStorable();
            if (isClear || isStorable) {
                const size = isClear ? done.length : this._position;
                if (0 < size) {
                    this.remove(size);
                    this._position = 0;
                    this.emit("change", this);
                }
                this.cleanup();
            }
            const doneLength = done.length;
            if (0 < doneLength) {
                command.merge(done[doneLength - 1]);
            }
        }
        execute(command) {
            this.emit("executing", command, this);
            if (command.execute()) {
                return this.onSuccess(command);
            }
            else {
                return this.onFail(command);
            }
        }
        onSuccess(command) {
            if (command.isStorable()) {
                if (!command.isMerged()) {
                    this._done.push(command);
                }
                if (!command.isClean()) {
                    this.emit("dirty", this);
                }
            }
            this.emit("change", this);
            this.emit("executed", command, this);
        }
        onFail(command) {
            command.destroy();
            this.emit("change", this);
        }
        cleanup() {
            const done = this._done;
            const size = done.length - 100;
            if (0 < size) {
                for (let i = 0; i < size; ++i) {
                    done[i].destroy();
                    done.shift();
                }
            }
        }
        remove(size) {
            const done = this._done;
            if (0 < size) {
                const ifrom = Math.max(0, done.length - size);
                size = done.length - ifrom;
                if (0 < size) {
                    for (let i = ifrom, imax = done.length; i < imax; ++i) {
                        done[i].destroy();
                    }
                    done.splice(ifrom, done.length - ifrom);
                    return true;
                }
            }
            return false;
        }
        size() {
            return this._done.length;
        }
        clear() {
            this.push(new DCommandClear());
        }
        redo() {
            if (this.isRedoable()) {
                this.doRedo();
            }
        }
        doRedo() {
            const done = this._done;
            if (0 < this._position) {
                const current = done[done.length - this._position];
                this._position -= 1;
                this.emit("change", this);
                this.emit("redoing", current, this);
                const result = current.redo();
                if (result === true) {
                    this.onRedoSuccess(current);
                }
                else {
                    this.onRedoFail(current);
                }
            }
        }
        onRedoSuccess(redoed) {
            if (!redoed.isClean()) {
                this.emit("dirty", this);
            }
            this.emit("change", this);
            this.emit("redoed", redoed, this);
        }
        onRedoFail(command) {
            this.emit("change", this);
        }
        isRedoable() {
            return 0 < this._position;
        }
        undo() {
            if (this.isUndoable()) {
                this.doUndo();
            }
        }
        doUndo() {
            const done = this._done;
            if (this._position < done.length) {
                const current = done[done.length - 1 - this._position];
                this._position += 1;
                this.emit("change", this);
                this.emit("undoing", current, this);
                const result = current.undo();
                if (result === true) {
                    this.onUndoSuccess(current);
                }
                else {
                    this.onUndoFail(current);
                }
            }
        }
        onUndoSuccess(undoed) {
            if (!undoed.isClean()) {
                this.emit("dirty", this);
            }
            this.emit("change", this);
            this.emit("undoed", undoed, this);
        }
        onUndoFail(command) {
            this.emit("change", this);
        }
        isUndoable() {
            return this._position < this._done.length;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DControllerKeyboardImpl extends pixi_js.utils.EventEmitter {
        init(element, stage, focusController) {
            element.addEventListener("keydown", (e) => {
                this.emit("keydown", e);
                const focused = focusController.get();
                if (focused != null) {
                    let current = focused;
                    while (current != null) {
                        if (this.hasOnKeyDown(current)) {
                            if (current.onKeyDown(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
                if (UtilKeyboardEvent.isFocusKey(e)) {
                    const direction = UtilKeyboardEvent.getFocusDirection(e);
                    const next = focused != null
                        ? focusController.find(focused, false, focused.state.isFocusRoot || direction, direction)
                        : focusController.find(stage, false, true, direction);
                    if (next != null) {
                        focusController.focus(next);
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                }
            });
            element.addEventListener("keyup", (e) => {
                this.emit("keyup", e);
                const focused = focusController.get();
                if (focused != null) {
                    let current = focused;
                    while (current != null) {
                        if (this.hasOnKeyUp(current)) {
                            if (current.onKeyUp(e)) {
                                return;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        }
        hasOnKeyDown(target) {
            return "onKeyDown" in target;
        }
        hasOnKeyUp(target) {
            return "onKeyUp" in target;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DControllers {
        // Keyboard
        static getKeyboardController() {
            if (this.KEYBOARD == null) {
                this.KEYBOARD = new DControllerKeyboardImpl();
            }
            return this.KEYBOARD;
        }
        static setKeyboardController(instance) {
            const result = this.KEYBOARD;
            this.KEYBOARD = instance;
            return result;
        }
        // Command
        static getCommandController() {
            if (this.COMMAND == null) {
                this.COMMAND = new DControllerCommandImpl();
            }
            return this.COMMAND;
        }
        static setCommandController(instance) {
            const result = this.COMMAND;
            this.COMMAND = instance;
            return result;
        }
        // Document
        static getDocumentController() {
            if (this.DOCUMENT == null) {
                throw new Error("Not supported");
            }
            return this.DOCUMENT;
        }
        static setDocumentController(instance) {
            const result = this.DOCUMENT;
            this.DOCUMENT = instance;
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const isDblClickable = (target) => {
        return target != null && target.onDblClick != null;
    };
    const isWheelable = (target) => {
        return target != null && target.onWheel != null;
    };
    class DApplicationLayer extends pixi_js.Application {
        constructor(application, options) {
            super(options.getPixiApplicationOptions());
            this._renderId = null;
            this._dynamicFontAtlases = null;
            this._options = options;
            this._isLocked = false;
            this._isVisible = true;
            this._isOverlay = options.isOverlay();
            this._padding = options.getPadding();
            this._rootElement = options.getRootElement();
            this._reflowLimit = 5;
            this._elementContainer = this.newElementContainer();
            this.application = application;
            this._renderBound = () => {
                if (this._renderId != null) {
                    this.render();
                }
            };
            this.initStage();
            this.initView();
            this.initRootElement();
            this.initFocusHandling();
            this.initResizeHandling();
            this.initWheelHandling();
            this.initDoubleClickHandling();
        }
        newElementContainer() {
            const result = document.createElement("div");
            result.setAttribute("style", "position: absolute; top: 0; left: 0; width: 0; height: 0;" +
                "margin: 0; padding: 0; outline: none;");
            return result;
        }
        initStage() {
            const stage = this.stage;
            stage.layer = this;
            stage.application = this.application;
            stage.interactive = true;
        }
        initView() {
            const view = this.view;
            const style = view.style;
            style.position = "absolute";
            style.top = "0";
            style.left = "0";
            style.width = "100%";
            style.height = "100%";
            style.display = "block";
            style.outline = "none";
            style.webkitTapHighlightColor = "rgba(255,255,255,0)";
            style.webkitUserSelect = "none";
            style.setProperty("-khtml-user-select", "none");
            style.setProperty("-moz-user-select", "none");
            style.setProperty("-ms-user-select", "none");
            style.userSelect = "none";
        }
        initRootElement() {
            const view = this.view;
            const isOverlay = this._isOverlay;
            const rootElement = this._rootElement;
            const elementContainer = this._elementContainer;
            // Insert elements
            const insertionPosition = isOverlay ? 2 : 0;
            const children = rootElement.children;
            if (insertionPosition < children.length) {
                const child = children[insertionPosition];
                rootElement.insertBefore(view, child);
                rootElement.insertBefore(elementContainer, child);
            }
            else {
                rootElement.appendChild(view);
                rootElement.appendChild(elementContainer);
            }
            if (isOverlay) {
                const stage = this.stage;
                const oldOnChildrenChange = stage.onChildrenChange;
                stage.onChildrenChange = () => {
                    this.onStageDirty();
                    oldOnChildrenChange.call(stage);
                };
            }
            // Init styles
            const rootElementStyle = rootElement.style;
            if (rootElement !== document.body) {
                const rootElementStylePosition = window.getComputedStyle(rootElement).position;
                if (rootElementStylePosition === "static") {
                    rootElementStyle.position = "relative";
                }
            }
            rootElementStyle.margin = "0";
            rootElementStyle.padding = "0";
            rootElementStyle.overflow = "hidden";
        }
        initFocusHandling() {
            const view = this.view;
            const stage = this.stage;
            const focusController = this.getFocusController();
            view.setAttribute("tabindex", "0");
            DControllers.getKeyboardController().init(view, stage, focusController);
            const interactionManager = this.renderer.plugins.interaction;
            interactionManager.on(UtilPointerEvent.down, (e) => {
                if (e.target == null || e.target === stage) {
                    focusController.clear();
                }
            });
        }
        initResizeHandling() {
            const options = this._options;
            const isWidthFixed = options.isWidthFixed();
            const isHeightFixed = options.isHeightFixed();
            if (!isWidthFixed || !isHeightFixed) {
                const onResizeBound = () => {
                    this.onResize();
                };
                if (window.ResizeObserver != null) {
                    new ResizeObserver(onResizeBound).observe(this._rootElement);
                }
                else {
                    window.addEventListener("resize", onResizeBound);
                    window.addEventListener("orientationchange", onResizeBound);
                }
            }
        }
        onResize() {
            const options = this._options;
            const bboxes = this._rootElement.getClientRects();
            if (bboxes.length <= 0) {
                // The root element size is (0, 0) and not visible.
                // In this case, skip the resizing.
                return;
            }
            const bbox = bboxes[0];
            const newWidth = options.isWidthFixed() ? options.getWidth() : bbox.width;
            const newHeight = options.isHeightFixed() ? options.getHeight() : bbox.height;
            this.renderer.resize(newWidth, newHeight);
            const wasLocked = this._isLocked;
            this._isLocked = true;
            const padding = this._padding;
            const children = this.stage.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child instanceof DBase) {
                    child.onParentResize(newWidth, newHeight, padding);
                }
            }
            this._isLocked = wasLocked;
            if (!this._isLocked && this._renderId == null) {
                this.render();
            }
        }
        initWheelHandling() {
            const global = new pixi_js.Point();
            const util = UtilWheelEvent.getInstance();
            const interactionManager = this.renderer.plugins.interaction;
            util.on(this.view, (e) => {
                const wheelEvent = e;
                UtilPointerEvent.toGlobal(wheelEvent, interactionManager, global);
                let current = interactionManager.hitTest(global);
                const deltas = util.normalize(e);
                if (deltas != null) {
                    while (current != null) {
                        if (isWheelable(current)) {
                            if (current.onWheel(wheelEvent, deltas, global)) {
                                wheelEvent.preventDefault();
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        }
        initDoubleClickHandling() {
            const focusController = this.getFocusController();
            const interactionManager = this.renderer.plugins.interaction;
            UtilPointerEvent.onDblClick(this.view, (e) => {
                const focused = focusController.get();
                if (focused != null) {
                    let current = focused;
                    while (current != null) {
                        if (isDblClickable(current)) {
                            if (current.onDblClick(e, interactionManager)) {
                                break;
                            }
                        }
                        current = current.parent;
                    }
                }
            });
        }
        lock() {
            this._isLocked = true;
        }
        unlock() {
            this._isLocked = false;
        }
        update() {
            if (!this._isLocked && this._renderId == null) {
                this._renderId = requestAnimationFrame(this._renderBound);
            }
        }
        onStageDirty() {
            // Update the visibility if this is a overlay layer.
            if (this._isOverlay) {
                if (0 < this.stage.children.length) {
                    // There are more than one children,
                    // therefore must be visible.
                    if (!this._isVisible) {
                        this._isVisible = true;
                        this.view.style.display = "block";
                    }
                }
                else {
                    // There is no child,
                    // therefore must not be visible.
                    if (this._isVisible) {
                        this._isVisible = false;
                        this.view.style.display = "none";
                    }
                }
            }
        }
        render() {
            this.reflow();
            // Please note why the following line is here.
            //
            // Before this line, the update method does not enque a rendering task
            // because `this._renderId` is not null. As a result, this prevents
            // an unintentional rendering loop caused by the refit or the reflow.
            //
            // After this line, the update method enques a rendering task.
            // Namely, in the DisplayObject#render(Renderer) method, allowed to enque
            // a rendering task. For instance, please refer to the DDiagramShape#update().
            this._renderId = null;
            // Render
            super.render();
        }
        get width() {
            return this.screen.width;
        }
        get height() {
            return this.screen.height;
        }
        get padding() {
            return this._padding;
        }
        reflow() {
            const children = this.stage.children;
            for (let ilimit = 0, limit = this._reflowLimit; ilimit < limit; ++ilimit) {
                let isDirty = false;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    if (child instanceof DBase) {
                        child.reflow();
                        isDirty =
                            isDirty || child.isDirty() || child.hasDirty() || child.isHierarchyDirty();
                    }
                }
                // If DBases are changed during the `reflow` process, need to reflow again.
                if (!isDirty) {
                    break;
                }
            }
        }
        getFocusController() {
            return this.application.getFocusController();
        }
        getRootElement() {
            return this._rootElement;
        }
        getElementContainer() {
            return this._elementContainer;
        }
        getDynamicFontAtlases() {
            if (this._dynamicFontAtlases == null) {
                this._dynamicFontAtlases = new DynamicFontAtlases(this);
            }
            return this._dynamicFontAtlases;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DControllerFocusImpl extends pixi_js.utils.EventEmitter {
        constructor() {
            super(...arguments);
            this._focused = null;
        }
        focus(focusable) {
            const previous = this._focused;
            if (previous !== focusable) {
                if (previous != null) {
                    previous.state.isFocused = false;
                }
                this._focused = focusable;
                if (this.isFocusable(focusable)) {
                    focusable.state.isFocused = true;
                }
                this.emit("change", focusable, previous, this);
                return previous;
            }
            return null;
        }
        blur(focusable) {
            if (focusable != null && this._focused === focusable) {
                this._focused = null;
                focusable.state.isFocused = false;
                this.emit("change", null, focusable, this);
                return focusable;
            }
            return null;
        }
        clear() {
            return this.focus(null);
        }
        set(focusable, isFocused) {
            if (isFocused) {
                return this.focus(focusable);
            }
            else {
                return this.blur(focusable);
            }
        }
        get() {
            return this._focused;
        }
        findParent(mightBeFocusable) {
            let current = mightBeFocusable;
            while (current != null) {
                if (this.isFocusable(current)) {
                    return current;
                }
                else {
                    current = current.parent;
                }
            }
            return null;
        }
        find(target, includesTarget, includesTargetChildren, direction, root) {
            if (direction) {
                const result = this.findNext(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                if (this.isFocusRoot(target, root)) {
                    return null;
                }
                const parent = target.parent;
                if (parent != null) {
                    const children = parent.children;
                    const index = children.indexOf(target);
                    if (0 <= index) {
                        const childrenLength = children.length;
                        if (this.isFocusReverse(parent)) {
                            for (let i = index - 1; 0 <= i; --i) {
                                const found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent, root)) {
                                const found = this.find(parent, false, false, true, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (let i = childrenLength - 1; index <= i; --i) {
                                const found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                        else {
                            for (let i = index + 1; i < childrenLength; ++i) {
                                const found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent, root)) {
                                const found = this.find(parent, false, false, true, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (let i = 0; i <= index; ++i) {
                                const found = this.findNext(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                    }
                }
            }
            else {
                const result = this.findPrevious(target, includesTarget, includesTargetChildren);
                if (result != null) {
                    return result;
                }
                const parent = target.parent;
                if (parent != null) {
                    const children = parent.children;
                    const index = children.indexOf(target);
                    if (0 <= index) {
                        const childrenLength = children.length;
                        if (this.isFocusReverse(parent)) {
                            for (let i = index + 1; i < childrenLength; ++i) {
                                const found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent, root)) {
                                const found = this.find(parent, true, false, false, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (let i = 0; i <= index; ++i) {
                                const found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                        else {
                            for (let i = index - 1; 0 <= i; --i) {
                                const found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                            if (!this.isFocusRoot(parent, root)) {
                                const found = this.find(parent, true, false, false, root);
                                if (found != null) {
                                    return found;
                                }
                            }
                            for (let i = childrenLength - 1; index <= i; --i) {
                                const found = this.findPrevious(children[i], true, true);
                                if (found != null) {
                                    return found;
                                }
                            }
                        }
                    }
                }
            }
            return null;
        }
        findNext(target, includesTarget, includesTargetChildren) {
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Target children
            if (includesTargetChildren && this.isFocusableContainer(target) && target.visible) {
                const children = target.children;
                const childrenLength = children.length;
                if (this.isFocusReverse(target)) {
                    for (let i = childrenLength - 1; 0 <= i; --i) {
                        const found = this.findNext(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
                else {
                    for (let i = 0; i < childrenLength; ++i) {
                        const found = this.findNext(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
            }
            // Found nothing
            return null;
        }
        findPrevious(target, includesTarget, includesTargetChildren) {
            // Target children
            if (includesTargetChildren && this.isFocusableContainer(target) && target.visible) {
                const children = target.children;
                const childrenLength = children.length;
                if (this.isFocusReverse(target)) {
                    for (let i = 0; i < childrenLength; ++i) {
                        const found = this.findPrevious(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
                else {
                    for (let i = childrenLength - 1; 0 <= i; --i) {
                        const found = this.findPrevious(children[i], true, true);
                        if (found != null) {
                            return found;
                        }
                    }
                }
            }
            // Target itself
            if (includesTarget) {
                if (this.isFocusable(target)) {
                    return target;
                }
            }
            // Found nothing
            return null;
        }
        isFocusable(target) {
            return (target != null &&
                "state" in target &&
                target.state.inEnabled &&
                target.state.isFocusable &&
                target.visible);
        }
        isFocusableContainer(target) {
            return target != null && "children" in target;
        }
        isFocusRoot(target, root) {
            if (target === root) {
                return true;
            }
            return target != null && "state" in target && target.state.isFocusRoot && target.visible;
        }
        isFocusReverse(target) {
            return target != null && "state" in target && target.state.isFocusReverse;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DApplication {
        constructor(options) {
            var _a, _b;
            DApplications.add(this);
            // Root
            const root = this.toRootElement(options);
            this._root = root;
            this.initFocusHandling(root);
            // Resolution
            const resolution = (_b = (_a = options === null || options === void 0 ? void 0 : options.resolution) !== null && _a !== void 0 ? _a : window.devicePixelRatio) !== null && _b !== void 0 ? _b : 1;
            this._resolution = resolution;
            // Remove the accessibility plugin
            delete pixi_js.Renderer.__plugins.accessibility;
            // Options
            this._options = options;
            // Base layer
            const base = this.newLayerBase(options);
            this._base = base;
            // Overlay layer
            this._isOverlayEnabled = !!(options === null || options === void 0 ? void 0 : options.overlay);
            if (!this._isOverlayEnabled) {
                this._overlay = base;
            }
        }
        get stage() {
            return this._base.stage;
        }
        getRootElement() {
            return this._root;
        }
        getResolution() {
            return this._resolution;
        }
        toRootElement(options) {
            const root = options === null || options === void 0 ? void 0 : options.root;
            if (root != null) {
                if (isString(root)) {
                    const found = document.querySelector(root);
                    if (found) {
                        return found;
                    }
                }
                else {
                    return root;
                }
            }
            return document.body;
        }
        toLayerBaseOptions(options) {
            const root = this._root;
            const resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: options.background,
                    resolution,
                    antialias: options.antialias,
                    overlay: false
                });
            }
            return new DApplicationLayerOptions({
                root,
                resolution,
                overlay: false
            });
        }
        getFocusController() {
            if (this._focus == null) {
                this._focus = new DControllerFocusImpl();
            }
            return this._focus;
        }
        initFocusHandling(root) {
            let hasFocus = false;
            const onFocus = () => {
                hasFocus = true;
            };
            const onBlured = () => {
                if (!hasFocus) {
                    this.getFocusController().clear();
                }
            };
            const onBlur = () => {
                hasFocus = false;
                setTimeout(onBlured, 0);
            };
            root.addEventListener("focus", onFocus, true);
            root.addEventListener("blur", onBlur, true);
        }
        newLayerBase(options) {
            return new DApplicationLayer(this, this.toLayerBaseOptions(options));
        }
        getLayerBase() {
            return this._base;
        }
        toLayerOverlayOptions(options) {
            const root = this._root;
            const resolution = this._resolution;
            if (options) {
                return new DApplicationLayerOptions({
                    root,
                    padding: options.padding,
                    width: options.width,
                    height: options.height,
                    background: {
                        color: null
                    },
                    resolution,
                    antialias: options.antialias,
                    overlay: true
                });
            }
            return new DApplicationLayerOptions({
                root,
                resolution,
                overlay: true
            });
        }
        newLayerOverlay(options) {
            return new DApplicationLayer(this, this.toLayerOverlayOptions(options));
        }
        getLayerOverlay() {
            if (this._isOverlayEnabled) {
                if (this._overlay == null) {
                    this._overlay = this.newLayerOverlay(this._options);
                }
                return this._overlay;
            }
            else {
                return this._base;
            }
        }
        update() {
            if (this._isOverlayEnabled) {
                const base = this._base;
                base.update();
                const overlay = this._overlay;
                if (overlay) {
                    overlay.update();
                }
            }
            else {
                return this._base.update();
            }
        }
        render() {
            if (this._isOverlayEnabled) {
                const base = this._base;
                base.render();
                const overlay = this._overlay;
                if (overlay) {
                    overlay.render();
                }
            }
            else {
                return this._base.render();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBasePaddingAdjustable extends DBasePadding {
        constructor(theme, options, callback) {
            super(theme, options, callback);
            this._atop = 0;
            this._aright = 0;
            this._abottom = 0;
            this._aleft = 0;
        }
        getLeft() {
            return super.getLeft() + this._aleft;
        }
        adjLeft(aleft) {
            if (this._aleft !== aleft) {
                this._aleft = aleft;
                const callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        }
        getTop() {
            return super.getTop() + this._atop;
        }
        adjTop(atop) {
            if (this._atop !== atop) {
                this._atop = atop;
                const callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        }
        getRight() {
            return super.getRight() + this._aright;
        }
        adjRight(aright) {
            if (this._aright !== aright) {
                this._aright = aright;
                const callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        }
        getBottom() {
            return super.getBottom() + this._abottom;
        }
        adjBottom(abottom) {
            if (this._abottom !== abottom) {
                this._abottom = abottom;
                const callback = this._callback;
                if (callback) {
                    callback();
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DBoard extends DBase {
        getType() {
            return "DBoard";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonCheck extends DButtonBase {
        getType() {
            return "DButtonCheck";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonCheckRight extends DButtonCheck {
        getType() {
            return "DButtonCheckRight";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DColorGradientPointObservable {
        constructor(color, alpha, position, selected, callback) {
            this._color = color;
            this._alpha = alpha;
            this._position = position;
            this._callback = callback;
            this._selected = selected;
        }
        set(color, alpha, position, selected) {
            if (this._color !== color ||
                this._alpha !== alpha ||
                this._position !== position ||
                this._selected !== selected) {
                this._color = color;
                this._alpha = alpha;
                this._position = position;
                this._selected = selected;
                this._callback(this);
            }
        }
        get color() {
            return this._color;
        }
        set color(color) {
            if (this._color !== color) {
                this._color = color;
                this._callback(this);
            }
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(alpha) {
            if (this._alpha !== alpha) {
                this._alpha = alpha;
                this._callback(this);
            }
        }
        get position() {
            return this._position;
        }
        set position(position) {
            if (this._position !== position) {
                this._position = position;
                this._callback(this);
            }
        }
        get selected() {
            return this._selected;
        }
        set selected(selected) {
            if (this._selected !== selected) {
                this._selected = selected;
                this._callback(this);
            }
        }
        toObject() {
            return {
                color: this._color,
                alpha: this._alpha,
                position: this._position
            };
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const POINT_SORTER = (a, b) => {
        return a.position - b.position;
    };
    class DColorGradientObservable extends pixi_js.utils.EventEmitter {
        constructor() {
            super();
            const onChangeBound = (target) => {
                this.onChange(target);
            };
            this._onChangeBound = onChangeBound;
            const first = new DColorGradientPointObservable(0xffffff, 1, 0, false, onChangeBound);
            const second = new DColorGradientPointObservable(0x808080, 1, 1, true, onChangeBound);
            this._points = [first, second];
            this._direction = -90;
            this._selected = second;
            this._workColor = [0, 0, 0];
        }
        onChange(target) {
            const isSelectionChanged = target.selected && this._selected !== target;
            if (isSelectionChanged) {
                const selected = this._selected;
                if (selected != null) {
                    selected._selected = false;
                }
                this._selected = target;
            }
            this._points.sort(POINT_SORTER);
            if (isSelectionChanged) {
                this.emit("selectionchange", this._selected, this);
            }
            this.emit("change", this);
        }
        get points() {
            return this._points;
        }
        get direction() {
            return this._direction;
        }
        set direction(direction) {
            if (this._direction !== direction) {
                this._direction = direction;
                this.emit("directionchange", direction, this);
                this.emit("change", this);
            }
        }
        get selected() {
            return this._selected;
        }
        size() {
            return this._points.length;
        }
        get(index) {
            const points = this._points;
            if (0 <= index && index < points.length) {
                return points[index];
            }
            return null;
        }
        addAt(position) {
            const points = this._points;
            let previous = null;
            for (let i = 0, imax = points.length; i < imax; ++i) {
                const point = points[i];
                if (position <= point.position) {
                    if (previous != null) {
                        const span = point.position - previous.position;
                        if (0.001 < span) {
                            const rgb0 = pixi_js.utils.hex2rgb(point.color, this._workColor);
                            const r0 = rgb0[0];
                            const g0 = rgb0[1];
                            const b0 = rgb0[2];
                            const rgb1 = pixi_js.utils.hex2rgb(previous.color, this._workColor);
                            const r1 = rgb1[0];
                            const g1 = rgb1[1];
                            const b1 = rgb1[2];
                            const ratio = (position - previous.position) / span;
                            const r = r0 * ratio + r1 * (1 - ratio);
                            const g = g0 * ratio + g1 * (1 - ratio);
                            const b = b0 * ratio + b1 * (1 - ratio);
                            const rgb = this._workColor;
                            rgb[0] = r;
                            rgb[1] = g;
                            rgb[2] = b;
                            const color = pixi_js.utils.rgb2hex(rgb);
                            const alpha = point.alpha * ratio + previous.alpha * (1 - ratio);
                            return this.add(color, alpha, position, true);
                        }
                    }
                    else {
                        return this.add(point.color, point.alpha, position, true);
                    }
                }
                previous = point;
            }
            if (previous != null) {
                return this.add(previous.color, previous.alpha, position, true);
            }
            else {
                return this.add(0xffffff, 1.0, position, true);
            }
        }
        add(color, alpha, position, selected) {
            const onChangeBound = this._onChangeBound;
            const result = new DColorGradientPointObservable(color, alpha, position, selected, onChangeBound);
            this._points.push(result);
            onChangeBound(result);
            return result;
        }
        remove(point) {
            const points = this._points;
            if (2 < points.length) {
                for (let i = 0, imax = points.length; i < imax; ++i) {
                    if (points[i] === point) {
                        points.splice(i, 1);
                        const isSelectionChanged = this._selected === point;
                        if (isSelectionChanged) {
                            if (i + 1 < imax) {
                                this._selected = points[i];
                            }
                            else {
                                this._selected = points[i - 1];
                            }
                        }
                        if (isSelectionChanged) {
                            this.emit("selectionchange", this._selected, this);
                        }
                        this.emit("change", this);
                        return true;
                    }
                }
            }
            return false;
        }
        reset() {
            const oldDirection = this._direction;
            this._direction = -90;
            const points = this._points;
            const oldSelected = this._selected;
            const index = oldSelected ? points.indexOf(oldSelected) : -1;
            points.length = 0;
            const onChangeBound = this._onChangeBound;
            points.push(new DColorGradientPointObservable(0xffffff, 0, 0, false, onChangeBound));
            points.push(new DColorGradientPointObservable(0xffffff, 0, 1, false, onChangeBound));
            if (0 <= index && index < points.length) {
                const point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                const point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
            return this;
        }
        toObject() {
            const pointsCopy = [];
            const points = this._points;
            for (let i = 0, imax = points.length; i < imax; ++i) {
                pointsCopy.push(points[i].toObject());
            }
            return {
                points: pointsCopy,
                direction: this._direction
            };
        }
        fromObject(data) {
            const oldDirection = this._direction;
            this._direction = data.direction;
            const points = this._points;
            const oldSelected = this._selected;
            const index = oldSelected ? points.indexOf(oldSelected) : -1;
            points.length = 0;
            const onChangeBound = this._onChangeBound;
            for (let i = 0, imax = data.points.length; i < imax; ++i) {
                const pointLike = data.points[i];
                const point = new DColorGradientPointObservable(pointLike.color, pointLike.alpha, pointLike.position, false, onChangeBound);
                points.push(point);
            }
            points.sort(POINT_SORTER);
            if (0 <= index && index < points.length) {
                const point = points[index];
                point._selected = true;
                this._selected = point;
            }
            else if (0 < points.length) {
                const point = points[points.length - 1];
                point._selected = true;
                this._selected = point;
            }
            else {
                this._selected = null;
            }
            if (oldSelected !== this._selected) {
                this.emit("selectionchange", this._selected, this);
            }
            if (oldDirection !== this._direction) {
                this.emit("directionchange", this._direction, this);
            }
            this.emit("change", this);
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputLabel extends DText {
        getType() {
            return "DInputLabel";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputAndLabel extends DLayoutHorizontal {
        constructor(options) {
            super(options);
            this.addChild((this._label = new DInputLabel(options === null || options === void 0 ? void 0 : options.label)));
            this.addChild((this._input = this.createInput(options === null || options === void 0 ? void 0 : options.input)));
            const space = options === null || options === void 0 ? void 0 : options.space;
            if (space != null) {
                this.addChild(new DLayoutSpace(space));
            }
        }
        get input() {
            return this._input;
        }
        get label() {
            return this._label;
        }
        getType() {
            return "DInputAndLabel";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputRealAndLabel extends DInputAndLabel {
        createInput(options) {
            return new DInputReal(options);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputTextAndLabel extends DInputAndLabel {
        createInput(options) {
            return new DInputText(options);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerColorAndAlpha {
        constructor(colorAndAlpha, onColorChange, onAlphaChange) {
            this._colorAndAlpha = colorAndAlpha;
            this._onColorChange = onColorChange;
            this._onAlphaChange = onAlphaChange;
        }
        get color() {
            return this._colorAndAlpha.color;
        }
        set color(color) {
            if (this._colorAndAlpha.color !== color) {
                const callback = this._onColorChange;
                if (callback != null) {
                    callback(color);
                }
            }
        }
        get alpha() {
            return this._colorAndAlpha.alpha;
        }
        set alpha(alpha) {
            if (this._colorAndAlpha.alpha !== alpha) {
                const callback = this._onAlphaChange;
                if (callback != null) {
                    callback(alpha);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuContext {
        constructor(owner) {
            this._owner = owner;
            this._closeables = [];
        }
        indexOf(target) {
            return this._closeables.indexOf(target);
        }
        close(index) {
            const closeables = this._closeables;
            const imin = Math.max(0, index);
            for (let i = closeables.length - 1; imin <= i; --i) {
                closeables[i].close();
            }
        }
        add(closeable) {
            this._closeables.push(closeable);
        }
        trim(closeable) {
            this.close(this.indexOf(closeable) + 1);
        }
        remove(closeable) {
            const index = this.indexOf(closeable);
            if (0 <= index) {
                this.close(index + 1);
                this._closeables.splice(index, 1);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenu extends DLayoutVertical {
        init(options) {
            var _a, _b, _c;
            super.init(options);
            this._onPrerenderBound = () => {
                this.onPrerender();
            };
            this._align = toEnum((_a = options === null || options === void 0 ? void 0 : options.align) !== null && _a !== void 0 ? _a : UtilAttachAlign.BOTTOM, UtilAttachAlign);
            this._fit = (_b = options === null || options === void 0 ? void 0 : options.fit) !== null && _b !== void 0 ? _b : false;
            this._sticky = (_c = options === null || options === void 0 ? void 0 : options.sticky) !== null && _c !== void 0 ? _c : false;
            this._sub = false;
            this._owner = null;
            this._context = null;
            this.visible = false;
            // Event handlers
            UtilClickOutside.apply(this, () => {
                this.close();
            });
            this.on("select", () => {
                this.close();
            });
            // Items
            const items = options === null || options === void 0 ? void 0 : options.items;
            if (items) {
                DMenus.newItems(this, items, this._sticky);
            }
            // Overlay
            this._overlay = new UtilOverlay(options);
        }
        findItem(value) {
            const children = this.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child instanceof DMenuItem && child.value === value) {
                    return child;
                }
            }
            return null;
        }
        getType() {
            return "DMenu";
        }
        getContext() {
            return this._context;
        }
        getCloseable() {
            return this;
        }
        open(owner, closeable, context) {
            var _a;
            if (this.isHidden()) {
                const layer = this._overlay.pick(this, owner);
                this._owner = owner;
                // States
                const children = this.children;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    if (child instanceof DBase) {
                        child.state.removeAll(DBaseState.FOCUSED, DBaseState.HOVERED);
                    }
                }
                // Position & size
                const renderer = layer.renderer;
                const onPrerenderBound = this._onPrerenderBound;
                if (this._sticky) {
                    renderer.on("prerender", onPrerenderBound);
                }
                else {
                    renderer.once("prerender", onPrerenderBound);
                }
                if (this._fit) {
                    const bounds = owner.getBounds(false, ((_a = DMenu.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DMenu.WORK_BOUNDS = new pixi_js.Rectangle())));
                    if (bounds != null) {
                        this.width = bounds.width;
                    }
                }
                // Target
                this._sub = context != null;
                context = context || new DMenuContext(owner);
                if (closeable != null) {
                    context.trim(closeable);
                }
                context.add(this);
                this._context = context;
                // Stage
                layer.stage.addChild(this);
                // Focus
                this._focused = layer.getFocusController().get();
                this.focus();
                // Show
                super.show();
                // Event
                this.emit("open", this);
            }
            return this;
        }
        onPrerender() {
            var _a;
            const owner = this._owner;
            if (owner) {
                const bounds = owner.getBounds(false, ((_a = DMenu.WORK_BOUNDS) !== null && _a !== void 0 ? _a : (DMenu.WORK_BOUNDS = new pixi_js.Rectangle())));
                if (bounds) {
                    if (this._fit) {
                        this.width = bounds.width;
                    }
                    const layer = this._overlay.picked;
                    if (layer) {
                        const theme = this.theme;
                        UtilAttach.attach(this, bounds, theme.getOffsetX(), theme.getOffsetY(), layer.width, layer.height, this._align);
                    }
                }
            }
        }
        close() {
            if (this.isShown()) {
                // Remove from the context
                const context = this._context;
                if (context) {
                    context.remove(this);
                }
                // Remove the prerender event handler
                const layer = this._overlay.picked;
                if (layer) {
                    layer.renderer.off("prerender", this._onPrerenderBound);
                }
                // Forget the owner
                this._owner = null;
                // Restore the focus
                const focused = this._focused;
                if (focused != null) {
                    this._focused = null;
                    if (layer) {
                        const focusedLayer = DApplications.getLayer(focused);
                        if (focusedLayer != null && layer !== focusedLayer) {
                            focusedLayer.view.focus();
                        }
                        layer.getFocusController().focus(focused);
                    }
                    else {
                        this.blur(true);
                    }
                }
                else {
                    this.blur(true);
                }
                // Visibility
                super.hide();
                // Remove from the tree
                const parent = this.parent;
                if (parent) {
                    parent.removeChild(this);
                }
                // Emit the event
                this.emit("close", this);
            }
            return this;
        }
        onKeyDown(e) {
            UtilKeyboardEvent.moveFocusVertically(e, this, this._overlay);
            if (this.state.isActionable &&
                (UtilKeyboardEvent.isArrowLeftKey(e) || UtilKeyboardEvent.isCancelKey(e))) {
                this.close();
            }
            return super.onKeyDown(e);
        }
        containsGlobalPoint(point) {
            return !this._sub;
        }
    }
    DMenus.setMenuCreator((options) => new DMenu(options));

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A dropdown base class.
     */
    class DDropdownBase extends DButtonBase {
        onMenuSelect(value, item, menu) {
            this.emit("select", value, item, this);
        }
        onMenuClose(menu) {
            if (menu) {
                const onMenuSelectBound = this._onMenuSelectBound;
                if (onMenuSelectBound) {
                    menu.off("select", onMenuSelectBound);
                }
                const onMenuCloseBound = this._onMenuCloseBound;
                if (onMenuCloseBound) {
                    menu.off("close", onMenuCloseBound);
                }
            }
        }
        toMenu(theme, options) {
            const menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof DMenu) {
                return menu;
            }
            return new DMenu(this.toMenuOptions(theme, menu));
        }
        toMenuOptions(theme, options) {
            if (options) {
                if (options.fit == null) {
                    options.fit = true;
                }
                return options;
            }
            return {
                fit: true
            };
        }
        get menu() {
            let result = this._menu;
            if (result == null) {
                result = this.toMenu(this.theme, this._options);
                this._menu = result;
            }
            return result;
        }
        set menu(newMenu) {
            const oldMenu = this._menu;
            if (oldMenu != newMenu) {
                this._menu = newMenu;
                this.onMenuReplaced(newMenu, oldMenu);
            }
        }
        onMenuReplaced(newMenu, oldMenu) {
            if (oldMenu != null) {
                this.onMenuClose(oldMenu);
            }
        }
        getType() {
            return "DDropdownBase";
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.onKeyDownArrowDown(e);
            }
            return super.onKeyDown(e);
        }
        onKeyDownArrowDown(e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.activate(e);
                return true;
            }
            return false;
        }
        onActivate(e) {
            super.onActivate(e);
            this.open();
        }
        open() {
            const menu = this.menu;
            if (menu.isHidden()) {
                this.onMenuOpening(menu);
                menu.open(this);
                this.onMenuOpened(menu);
            }
        }
        onMenuOpening(menu) {
            // In the case that the menu is created elsewhere,
            // the menu might be opened by other UI elements
            // and the `select` event might be triggered. In
            // that case, we are not supposed to catch that
            // `select` event. This is why the `select` event
            // handler is registered here. Instead of the
            // initialization time.
            let onMenuSelectBound = this._onMenuSelectBound;
            if (onMenuSelectBound == null) {
                onMenuSelectBound = (value, item, m) => {
                    this.onMenuSelect(value, item, m);
                };
                this._onMenuSelectBound = onMenuSelectBound;
            }
            let onMenuCloseBound = this._onMenuCloseBound;
            if (onMenuCloseBound == null) {
                onMenuCloseBound = () => {
                    this.onMenuClose(this._menu);
                };
            }
            menu.on("select", onMenuSelectBound);
            menu.on("close", onMenuCloseBound);
        }
        onMenuOpened(menu) {
            this.emit("open", menu, this);
        }
        close() {
            this.menu.close();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuItems {
        static each(menu, iteratee) {
            const children = menu.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child instanceof DMenuItemMenu) {
                    const result = this.each(child.menu, iteratee);
                    if (result != null) {
                        return result;
                    }
                }
                else if (child instanceof DMenuItem) {
                    if (iteratee(child)) {
                        return child;
                    }
                }
            }
            return null;
        }
        static find(menu, value) {
            return this.each(menu, (item) => {
                return item.value === value;
            });
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A selector class.
     */
    class DSelect extends DDropdownBase {
        constructor(options) {
            super(options);
            // Default value
            this._value = null;
            const value = options === null || options === void 0 ? void 0 : options.value;
            if (value != null) {
                this.value = value;
            }
        }
        onMenuSelect(newValue, item, menu) {
            super.onMenuSelect(newValue, item, menu);
            const oldValue = this._value;
            if (oldValue !== newValue) {
                this._value = newValue;
                this.text = item;
                this.onValueChange(newValue, oldValue, item);
            }
        }
        onMenuReplaced(newMenu, oldMenu) {
            super.onMenuReplaced(newMenu, oldMenu);
            // Update the value
            const value = this._value;
            const item = DMenuItems.find(newMenu, value);
            if (item != null) {
                this._value = value;
                this.text = item;
            }
            else {
                this._value = null;
                this.text = null;
            }
        }
        onValueChange(newValue, oldValue, item) {
            this.emit("change", newValue, oldValue, item, this);
        }
        onMenuOpening(menu) {
            super.onMenuOpening(menu);
            const value = this._value;
            DMenuItems.each(menu, (item) => {
                item.state.isActive = item.value === value;
            });
        }
        /**
         * Returns a selected value or null.
         */
        get value() {
            return this.getValue();
        }
        /**
         * Sets to the specified value.
         */
        set value(value) {
            this.setValue(value);
        }
        getValue() {
            return this._value;
        }
        setValue(value, forcibly) {
            if (forcibly || this._value !== value) {
                const item = DMenuItems.find(this.menu, value);
                if (item != null) {
                    this._value = value;
                    this.text.setValue(item, forcibly);
                }
                else {
                    this._value = null;
                    this.text.setValue(null, forcibly);
                }
            }
        }
        getType() {
            return "DSelect";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DColorType = {
        CUSTOM: 0,
        STANDARD: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DColorStandard extends pixi_js.utils.EventEmitter {
        constructor(standards) {
            super();
            this._standards = standards;
        }
        get(index) {
            const standards = this._standards;
            if (0 <= index && index < standards.length) {
                return standards[index];
            }
            return null;
        }
        set(index, color) {
            const standards = this._standards;
            if (0 <= index && index < standards.length) {
                const result = standards[index];
                standards[index] = color;
                this.emit("change", this);
                return result;
            }
            return null;
        }
        setAll(colors) {
            let isChanged = false;
            const standards = this._standards;
            for (let i = 0, imax = Math.min(colors.length, standards.length); i < imax; ++i) {
                if (standards[i] !== colors[i]) {
                    standards[i] = colors[i];
                    isChanged = true;
                }
            }
            if (isChanged) {
                this.emit("change", this);
            }
            return this;
        }
        contains(color) {
            const standards = this._standards;
            for (let i = 0, imax = standards.length; i < imax; ++i) {
                if (standards[i] === color) {
                    return true;
                }
            }
            return false;
        }
        size() {
            return this._standards.length;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DColorStandards {
        static getInstance() {
            var _a;
            return ((_a = this.INSTANCE) !== null && _a !== void 0 ? _a : (this.INSTANCE = this.newInstance()));
        }
        static newInstance() {
            const theme = DThemes.get("DColorStandard");
            return new DColorStandard(theme.newColors());
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DColorRecent extends pixi_js.utils.EventEmitter {
        constructor(recents, capacity) {
            super();
            this._recents = recents;
            this._capacity = capacity;
        }
        get(index) {
            const recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        }
        set(index, colorAndAlpha) {
            const recents = this._recents;
            if (0 <= index && index < recents.length) {
                const result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = {
                    color: colorAndAlpha.color,
                    alpha: colorAndAlpha.alpha
                };
                this.emit("change", this);
                return result;
            }
            return null;
        }
        contains(colorAndAlpha) {
            const recents = this._recents;
            for (let i = 0, imax = recents.length; i < imax; ++i) {
                const recent = recents[i];
                if (recent.color === colorAndAlpha.color && recent.alpha === colorAndAlpha.alpha) {
                    return true;
                }
            }
            return false;
        }
        clear() {
            const recents = this._recents;
            if (0 < recents.length) {
                recents.length = 0;
                this.emit("change", this);
            }
            return this;
        }
        add(colorAndAlpha) {
            const recents = this._recents;
            recents.push({
                color: colorAndAlpha.color,
                alpha: colorAndAlpha.alpha
            });
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        }
        addAll(colorAndAlphas) {
            const length = colorAndAlphas.length;
            if (0 < length) {
                const recents = this._recents;
                for (let i = 0; i < length; ++i) {
                    const colorAndAlpha = colorAndAlphas[i];
                    recents.push({
                        color: colorAndAlpha.color,
                        alpha: colorAndAlpha.alpha
                    });
                    if (this._capacity < recents.length) {
                        recents.shift();
                    }
                }
                this.emit("change", this);
            }
            return this;
        }
        clearAndAddAll(colorAndAlphas) {
            let isChanged = false;
            const recents = this._recents;
            if (0 < recents.length) {
                recents.length = 0;
                isChanged = true;
            }
            const length = colorAndAlphas.length;
            if (0 < length) {
                for (let i = 0; i < length; ++i) {
                    const colorAndAlpha = colorAndAlphas[i];
                    recents.push({
                        color: colorAndAlpha.color,
                        alpha: colorAndAlpha.alpha
                    });
                    if (this._capacity < recents.length) {
                        recents.shift();
                    }
                }
                isChanged = true;
            }
            if (isChanged) {
                this.emit("change", this);
            }
            return this;
        }
        pop() {
            const recents = this._recents;
            const result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        }
        size() {
            return this._recents.length;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DColorRecents {
        static getInstance() {
            var _a;
            return ((_a = this.INSTANCE) !== null && _a !== void 0 ? _a : (this.INSTANCE = this.newInstance()));
        }
        static newInstance() {
            const theme = DThemes.get("DColorRecent");
            return new DColorRecent(theme.newColors(), theme.getCapacity());
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerColor extends DBase {
        get current() {
            return this._currentPicker;
        }
        get new() {
            return this._newPicker;
        }
        get recent() {
            return this._recent;
        }
        get standard() {
            return this._standard;
        }
        init(options) {
            super.init(options);
            this._base = 0xff0000;
            this._new = { color: 0xffffff, alpha: 1 };
            this._newPicker = new DPickerColorAndAlpha(this._new, (color) => {
                this.setColorNew(color);
            }, (alpha) => {
                this.setAlphaNew(alpha);
            });
            this._current = { color: 0xffffff, alpha: 1 };
            this._currentPicker = new DPickerColorAndAlpha(this._current, (color) => {
                this.setColorCurrent(color);
            }, (alpha) => {
                this.setAlphaCurrent(alpha);
            });
            const theme = this.theme;
            const padding = this._padding;
            const paddingTop = padding.getTop();
            const paddingRight = padding.getRight();
            const paddingBottom = padding.getBottom();
            const paddingLeft = padding.getLeft();
            this._pointerPoint = new pixi_js.Point();
            const mainWidth = theme.getMainWidth();
            const mainHeight = theme.getMainHeight();
            const typeSelector = new DSelect({
                parent: this,
                value: DColorType.STANDARD,
                menu: {
                    items: [
                        {
                            value: DColorType.STANDARD,
                            text: {
                                value: theme.toColorTypeLabel(DColorType.STANDARD)
                            }
                        },
                        {
                            value: DColorType.CUSTOM,
                            text: {
                                value: theme.toColorTypeLabel(DColorType.CUSTOM)
                            }
                        }
                    ]
                },
                on: {
                    change: (value) => {
                        this.onTypeChange(value);
                    }
                }
            });
            this._typeSelector = typeSelector;
            typeSelector.x = paddingLeft;
            typeSelector.y = paddingTop;
            typeSelector.width = mainWidth;
            typeSelector.interactive = true;
            this.addChild(typeSelector);
            // Main
            const mainBaseSprite = new pixi_js.Sprite(theme.getMainBaseTexture());
            this._mainBaseSprite = mainBaseSprite;
            mainBaseSprite.x = paddingLeft;
            mainBaseSprite.y = typeSelector.y + typeSelector.height + theme.getBaseMargin();
            mainBaseSprite.width = mainWidth;
            mainBaseSprite.height = mainHeight;
            mainBaseSprite.interactive = true;
            mainBaseSprite.visible = false;
            this.addChild(mainBaseSprite);
            const mainSprite = new pixi_js.Sprite(theme.getMainTexture());
            this._mainSprite = mainSprite;
            mainSprite.x = paddingLeft;
            mainSprite.y = typeSelector.y + typeSelector.height + theme.getBaseMargin();
            mainSprite.tint = this._base;
            mainSprite.interactive = false;
            mainSprite.visible = false;
            this.addChild(mainSprite);
            // Main event handling
            this._onMainMoveBound = (e) => {
                this.onMainMove(e);
            };
            this._onMainUpBound = (e) => {
                this.onMainUp(e);
            };
            mainBaseSprite.on(UtilPointerEvent.down, (e) => {
                this.onMainDown(e);
            });
            // Base color picker
            const baseSprite = new pixi_js.Sprite(theme.getBaseTexture());
            this._baseSprite = baseSprite;
            baseSprite.x = paddingLeft;
            baseSprite.y = mainBaseSprite.y + mainBaseSprite.height + theme.getBaseMargin();
            baseSprite.interactive = true;
            baseSprite.visible = false;
            this.addChild(baseSprite);
            // Base event
            this._onBaseMoveBound = (e) => {
                this.onBaseMove(e);
            };
            this._onBaseUpBound = (e) => {
                this.onBaseUp(e);
            };
            baseSprite.on(UtilPointerEvent.down, (e) => {
                this.onBaseDown(e);
            });
            // Standard main color
            this._standardColorSprites = [];
            const standardColorSprites = this._standardColorSprites;
            const standardColorCount = theme.getStandardColorCount();
            const standardColorWidth = theme.getStandardColorWidth();
            const standardColorHeight = theme.getStandardColorHeight();
            const standardColorMargin = theme.getStandardColorMargin();
            const standardColorY = typeSelector.y + typeSelector.height + theme.getBaseMargin();
            const standardTexture = theme.getStandardTexture();
            const standard = (this._standard = DColorStandards.getInstance());
            standard.on("change", () => {
                this.onStandardChange();
            });
            const onStandardClick = (e) => {
                const sprite = e.currentTarget;
                if (sprite instanceof pixi_js.Sprite) {
                    this.setColorNew(sprite.tint);
                }
            };
            for (let i = 0; i < standardColorCount; ++i) {
                const x = paddingLeft + (i % 10) * (standardColorWidth + standardColorMargin);
                const y = standardColorY + Math.floor(i / 10) * (standardColorHeight + standardColorMargin);
                const sprite = new pixi_js.Sprite(standardTexture);
                const standardColor = standard.get(i);
                if (standardColor != null) {
                    sprite.tint = standardColor;
                    sprite.alpha = 1;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 1;
                }
                sprite.x = x;
                sprite.y = y;
                sprite.buttonMode = true;
                sprite.interactive = true;
                sprite.on(UtilPointerEvent.tap, onStandardClick);
                standardColorSprites.push(sprite);
            }
            const mainStandardColor = new DLayoutHorizontal({
                width: "auto",
                height: "auto",
                row: 8,
                children: standardColorSprites
            });
            this._mainStandardColor = mainStandardColor;
            mainStandardColor.visible = true;
            this.addChild(mainStandardColor);
            // Alpha picker
            const alphaCheckerboardSprite = new pixi_js.Sprite(theme.getAlphaCheckerboardTexture());
            this._alphaCheckerboardSprite = alphaCheckerboardSprite;
            alphaCheckerboardSprite.x = padding.getLeft();
            alphaCheckerboardSprite.y = baseSprite.y + theme.getBaseHeight() + theme.getBaseMargin();
            alphaCheckerboardSprite.interactive = false;
            this.addChild(alphaCheckerboardSprite);
            const alphaSprite = new pixi_js.Sprite(theme.getAlphaTexture());
            alphaSprite.tint = this._new.color;
            alphaSprite.interactive = true;
            alphaCheckerboardSprite.addChild(alphaSprite);
            // Alpha event
            this._onAlphaMoveBound = (e) => {
                this.onAlphaMove(e);
            };
            this._onAlphaUpBound = (e) => {
                this.onAlphaUp(e);
            };
            alphaSprite.on(UtilPointerEvent.down, (e) => {
                this.onAlphaDown(e);
            });
            // Pointers
            const mainPointerSprite = new pixi_js.Sprite(theme.getMainPointerTexture());
            this._mainPointerSprite = mainPointerSprite;
            mainPointerSprite.x = paddingLeft;
            mainPointerSprite.y = typeSelector.y + typeSelector.height + theme.getBaseMargin();
            mainPointerSprite.anchor.x = 0.5;
            mainPointerSprite.anchor.y = 0.5;
            mainPointerSprite.tint = theme.getMainPointerColor();
            mainPointerSprite.alpha = theme.getMainPointerAlpha();
            mainPointerSprite.interactive = false;
            mainPointerSprite.visible = false;
            this.addChild(mainPointerSprite);
            const alphaPointerSprite = new pixi_js.Sprite(theme.getAlphaPointerTexture());
            this._alphaPointerSprite = alphaPointerSprite;
            alphaPointerSprite.x = mainWidth;
            alphaPointerSprite.y = alphaCheckerboardSprite.height * 0.5;
            alphaPointerSprite.tint = theme.getAlphaPointerColor();
            alphaPointerSprite.alpha = theme.getAlphaPointerAlpha();
            alphaPointerSprite.anchor.set(0.5, 0.5);
            alphaPointerSprite.interactive = false;
            alphaCheckerboardSprite.addChild(alphaPointerSprite);
            const basePointerSprite = new pixi_js.Sprite(theme.getBasePointerTexture());
            this._basePointerSprite = basePointerSprite;
            basePointerSprite.x = 0;
            basePointerSprite.y = baseSprite.height * 0.5;
            basePointerSprite.tint = theme.getBasePointerColor();
            basePointerSprite.alpha = theme.getBasePointerAlpha();
            basePointerSprite.anchor.set(0.5, 0.5);
            basePointerSprite.interactive = false;
            baseSprite.addChild(basePointerSprite);
            // Recently used
            this._recentColorSprites = [];
            const recentColorSprites = this._recentColorSprites;
            const recentColorCount = theme.getRecentColorCount();
            const recentColorWidth = theme.getRecentColorWidth();
            const recentColorHeight = theme.getRecentColorHeight();
            const recentColorMargin = theme.getRecentColorMargin();
            const recentColorY = alphaCheckerboardSprite.y + theme.getAlphaHeight() + theme.getRecentMargin();
            const recentCheckerboardTexture = theme.getRecentCheckerboardTexture();
            const recentTexture = theme.getRecentTexture();
            const recent = (this._recent = DColorRecents.getInstance());
            recent.on("change", () => {
                this.onRecentChange();
            });
            const onRecentClick = (e) => {
                const sprite = e.currentTarget;
                if (sprite instanceof pixi_js.Sprite) {
                    this.setColorNew(sprite.tint);
                    this.setAlphaNew(sprite.alpha);
                }
            };
            for (let i = 0; i < recentColorCount; ++i) {
                const x = paddingLeft + i * (recentColorWidth + recentColorMargin);
                const y = recentColorY;
                const checkerboardSprite = new pixi_js.Sprite(recentCheckerboardTexture);
                checkerboardSprite.x = x;
                checkerboardSprite.y = y;
                checkerboardSprite.interactive = false;
                this.addChild(checkerboardSprite);
                const sprite = new pixi_js.Sprite(recentTexture);
                const recentColorAndAlpha = recent.get(i);
                if (recentColorAndAlpha != null) {
                    sprite.tint = recentColorAndAlpha.color;
                    sprite.alpha = recentColorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
                sprite.x = x;
                sprite.y = y;
                sprite.buttonMode = true;
                sprite.interactive = true;
                sprite.on(UtilPointerEvent.tap, onRecentClick);
                this.addChild(sprite);
                recentColorSprites.push(sprite);
            }
            // Input color
            const inputMargin = theme.getInputMargin();
            const inputLabelWidth = theme.getInputLabelWidth();
            const inputY = recentColorY + recentColorHeight + inputMargin;
            const inputWidth = (mainWidth - inputMargin) * 0.5;
            const inputAndLabelColor = new DInputTextAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY,
                width: inputWidth,
                label: {
                    width: inputLabelWidth,
                    text: {
                        value: "#"
                    },
                    interactive: DBaseInteractive.NONE
                },
                input: {
                    weight: 1,
                    text: {
                        value: "FFFFFF"
                    },
                    on: {
                        input: (code) => {
                            const color = UtilRgb.fromCode(code);
                            if (color != null) {
                                this.setColorNew(color);
                            }
                        }
                    }
                }
            });
            this._inputAndLabelColor = inputAndLabelColor;
            const inputHeight = inputAndLabelColor.height;
            const inputAndLabelAlpha = new DInputRealAndLabel({
                parent: this,
                x: paddingLeft,
                y: inputY + inputHeight + inputMargin,
                width: inputWidth,
                label: {
                    width: inputLabelWidth,
                    text: {
                        value: "A"
                    },
                    interactive: DBaseInteractive.NONE
                },
                input: {
                    weight: 1,
                    text: {
                        value: 1
                    },
                    min: 0,
                    max: 1,
                    on: {
                        input: (value) => {
                            this.setAlphaNew(value);
                        }
                    }
                }
            });
            this._inputAndLabelAlpha = inputAndLabelAlpha;
            // Samples
            const sampleWidth = theme.getSampleWidth();
            const sampleHeight = theme.getSampleHeight();
            const sampleX = paddingLeft + (mainWidth - inputMargin) * 0.5 + inputMargin;
            const sampleY = inputY + (inputHeight + inputMargin + inputAndLabelAlpha.height - sampleHeight) * 0.5;
            const sampleMargin = theme.getSampleMargin();
            const sampleCurrentCheckerboardSprite = new pixi_js.Sprite(theme.getSampleCheckerboardOldTexture());
            this._sampleCurrentCheckerboardSprite = sampleCurrentCheckerboardSprite;
            sampleCurrentCheckerboardSprite.x = sampleX;
            sampleCurrentCheckerboardSprite.y = sampleY;
            sampleCurrentCheckerboardSprite.width = sampleWidth;
            sampleCurrentCheckerboardSprite.height = sampleHeight;
            sampleCurrentCheckerboardSprite.interactive = false;
            this.addChild(sampleCurrentCheckerboardSprite);
            const current = this._current;
            const sampleCurrentSprite = new pixi_js.Sprite(theme.getSampleOldTexture());
            this._sampleCurrentSprite = sampleCurrentSprite;
            sampleCurrentSprite.x = sampleX;
            sampleCurrentSprite.y = sampleY;
            sampleCurrentSprite.tint = current.color;
            sampleCurrentSprite.alpha = current.alpha;
            sampleCurrentSprite.width = sampleWidth;
            sampleCurrentSprite.height = sampleHeight;
            sampleCurrentSprite.interactive = true;
            sampleCurrentSprite.buttonMode = true;
            sampleCurrentSprite.on(UtilPointerEvent.tap, () => {
                this.setColorNew(current.color);
                this.setAlphaNew(current.alpha);
            });
            this.addChild(sampleCurrentSprite);
            const sampleNewCheckerboardSprite = new pixi_js.Sprite(theme.getSampleCheckerboardNewTexture());
            this._sampleNewCheckerboardSprite = sampleNewCheckerboardSprite;
            sampleNewCheckerboardSprite.x = sampleX + sampleWidth + sampleMargin;
            sampleNewCheckerboardSprite.y = sampleY;
            sampleNewCheckerboardSprite.width = sampleWidth;
            sampleNewCheckerboardSprite.height = sampleHeight;
            sampleNewCheckerboardSprite.interactive = false;
            this.addChild(sampleNewCheckerboardSprite);
            const sampleNewSprite = new pixi_js.Sprite(theme.getSampleNewTexture());
            this._sampleNewSprite = sampleNewSprite;
            sampleNewSprite.x = sampleX + sampleWidth + sampleMargin;
            sampleNewSprite.y = sampleY;
            sampleNewSprite.tint = this._new.color;
            sampleNewSprite.alpha = this._new.alpha;
            sampleNewSprite.width = sampleWidth;
            sampleNewSprite.height = sampleHeight;
            sampleNewSprite.interactive = false;
            this.addChild(sampleNewSprite);
            // Width
            if (options == null || options.width == null) {
                this.width = paddingLeft + mainWidth + paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height =
                    inputY +
                        inputAndLabelColor.height +
                        inputMargin +
                        inputAndLabelAlpha.height +
                        paddingBottom;
            }
        }
        onMainDown(e) {
            this.onMainPick(e.data.global);
            const layer = DApplications.getLayer(this);
            if (layer) {
                const stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onMainMoveBound);
                stage.on(UtilPointerEvent.up, this._onMainUpBound);
                stage.on(UtilPointerEvent.upoutside, this._onMainUpBound);
            }
        }
        onMainMove(e) {
            this.onMainPick(e.data.global);
        }
        onMainUp(e) {
            const layer = DApplications.getLayer(this);
            if (layer) {
                const stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onMainMoveBound);
                stage.off(UtilPointerEvent.up, this._onMainUpBound);
            }
        }
        toMainHex(b, w0, w1, shift) {
            return Math.max(0, Math.min(255, w0 * 255 + w1 * ((b >> shift) & 0xff))) << shift;
        }
        toMainColor(base, tx, ty, width, height) {
            const hw = width * 0.5;
            const ux = Math.max(0, Math.min(1, ((tx - hw) * (1 - ty / height) + hw) / width));
            const uy = Math.max(0, Math.min(1, ty / height));
            const w1 = Math.abs(0.5 * uy - ux);
            const w0 = 1 - w1 - uy;
            const r = this.toMainHex(base, w0, w1, 16);
            const g = this.toMainHex(base, w0, w1, 8);
            const b = this.toMainHex(base, w0, w1, 0);
            return r | g | b;
        }
        onMainPick(global) {
            const mainBaseSprite = this._mainBaseSprite;
            const point = this._pointerPoint;
            const theme = this.theme;
            const mainWidth = theme.getMainWidth();
            const mainHeight = theme.getMainHeight();
            this.toLocal(global, undefined, point);
            const x = Math.max(0, Math.min(mainWidth, point.x - mainBaseSprite.x));
            const y = Math.max(0, Math.min(mainHeight, point.y - mainBaseSprite.y));
            const mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.position.set(mainBaseSprite.x + x, mainBaseSprite.y + y);
            this.onColorNew(this.toMainColor(this._base, x, y, mainWidth, mainHeight));
        }
        setColorCurrent(color) {
            this._sampleCurrentSprite.tint = this._current.color = color;
        }
        setAlphaCurrent(alpha) {
            this._sampleCurrentSprite.alpha = this._current.alpha = alpha;
        }
        setColorNew(color) {
            const theme = this.theme;
            const mainWidth = theme.getMainWidth();
            const mainHeight = theme.getMainHeight();
            const mainBaseSprite = this._mainBaseSprite;
            // Base color
            const hsv = UtilHsv.fromRgb(color);
            this._mainSprite.tint = this._base = UtilHsv.toRgb(hsv[0], 255, 255);
            // Move the base pointer
            const basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, hsv[0] / 360)) * mainWidth;
            // Move the main pointer
            const ns = Math.max(0, Math.min(1, hsv[1] / 255));
            const nv = Math.max(0, Math.min(1, 1 - hsv[2] / 255));
            const mainPointerSprite = this._mainPointerSprite;
            mainPointerSprite.tint = nv < 0.45 ? theme.getMainPointerColor() : 0xffffff;
            mainPointerSprite.position.set(mainBaseSprite.x + ns * mainWidth, mainBaseSprite.y + nv * mainHeight);
            // New color
            this.onColorNew(color);
        }
        onColorNew(color) {
            const layer = DApplications.getLayer(this);
            if (layer) {
                layer.lock();
            }
            this._sampleNewSprite.tint = this._new.color = color;
            this._inputAndLabelColor.input.value = UtilRgb.toCode(color);
            this.emit("newcolorchange", color, this);
            if (layer) {
                layer.unlock();
                layer.update();
            }
        }
        onBaseDown(e) {
            this.onBasePick(e.data.global);
            const layer = DApplications.getLayer(this);
            if (layer) {
                const stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.on(UtilPointerEvent.up, this._onBaseUpBound);
            }
        }
        onBaseMove(e) {
            this.onBasePick(e.data.global);
        }
        onBaseUp(e) {
            const layer = DApplications.getLayer(this);
            if (layer) {
                const stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onBaseMoveBound);
                stage.off(UtilPointerEvent.up, this._onBaseUpBound);
            }
        }
        toBaseHex(t, shift) {
            return Math.max(0, Math.min(255, t * 6 * 255)) << shift;
        }
        toBaseColor(t) {
            if (t <= 0.167) {
                return 0xff0000 + this.toBaseHex(t, 8);
            }
            else if (t <= 0.333) {
                t = 0.333 - t;
                return 0x00ff00 + this.toBaseHex(t, 16);
            }
            else if (t <= 0.5) {
                t -= 0.333;
                return 0x00ff00 + this.toBaseHex(t, 0);
            }
            else if (t < 0.667) {
                t = 0.667 - t;
                return 0x0000ff + this.toBaseHex(t, 8);
            }
            else if (t < 0.883) {
                t -= 0.667;
                return 0x0000ff + this.toBaseHex(t, 16);
            }
            else {
                t = 0.883 - t;
                return 0xff0000 + this.toBaseHex(t, 0);
            }
        }
        onBasePick(global) {
            const point = this._pointerPoint;
            const padding = this._padding;
            const theme = this.theme;
            const mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            const x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            const basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = x;
            this.onColorBase(this.toBaseColor(x / mainWidth));
        }
        setColorBase(h) {
            const theme = this.theme;
            const mainWidth = theme.getMainWidth();
            const basePointerSprite = this._basePointerSprite;
            basePointerSprite.x = Math.max(0, Math.min(1, h / 360)) * mainWidth;
            this.onColorBase(UtilHsv.toRgb(h, 255, 255));
        }
        onColorBase(color) {
            this._mainSprite.tint = this._base = color;
            const mainPointerSprite = this._mainPointerSprite;
            const theme = this.theme;
            const mainWidth = theme.getMainWidth();
            const mainHeight = theme.getMainHeight();
            const padding = this._padding;
            this.onColorNew(this.toMainColor(this._base, mainPointerSprite.x - padding.getLeft(), mainPointerSprite.y - padding.getTop(), mainWidth, mainHeight));
        }
        onAlphaDown(e) {
            this.onAlphaPick(e.data.global);
            const layer = DApplications.getLayer(this);
            if (layer) {
                const stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.on(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        }
        onAlphaMove(e) {
            this.onAlphaPick(e.data.global);
        }
        onAlphaUp(e) {
            const layer = DApplications.getLayer(this);
            if (layer) {
                const stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAlphaMoveBound);
                stage.off(UtilPointerEvent.up, this._onAlphaUpBound);
            }
        }
        onAlphaPick(global) {
            const point = this._pointerPoint;
            const padding = this._padding;
            const theme = this.theme;
            const mainWidth = theme.getMainWidth();
            this.toLocal(global, undefined, point);
            const x = Math.max(0, Math.min(mainWidth, point.x - padding.getLeft()));
            this._alphaPointerSprite.x = x;
            this.onAlphaNew(x / mainWidth);
        }
        setAlphaNew(alpha) {
            const theme = this.theme;
            const mainWidth = theme.getMainWidth();
            this._alphaPointerSprite.x = Math.max(0, Math.min(1, alpha)) * mainWidth;
            this.onAlphaNew(alpha);
        }
        onAlphaNew(alpha) {
            const layer = DApplications.getLayer(this);
            if (layer) {
                layer.lock();
            }
            this._sampleNewSprite.alpha = this._new.alpha = alpha;
            this._inputAndLabelAlpha.input.value = Number(alpha.toFixed(2));
            this.emit("newalphachange", alpha, this);
            if (layer) {
                layer.unlock();
                layer.update();
            }
        }
        onRecentChange() {
            const sprites = this._recentColorSprites;
            const recent = this._recent;
            for (let i = 0, imax = sprites.length; i < imax; ++i) {
                const sprite = sprites[i];
                const colorAndAlpha = recent.get(i);
                if (colorAndAlpha != null) {
                    sprite.tint = colorAndAlpha.color;
                    sprite.alpha = colorAndAlpha.alpha;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 0;
                }
            }
        }
        onStandardChange() {
            const sprites = this._standardColorSprites;
            const standard = this._standard;
            for (let i = 0, imax = sprites.length; i < imax; ++i) {
                const sprite = sprites[i];
                const color = standard.get(i);
                if (color != null) {
                    sprite.tint = color;
                    sprite.alpha = 1;
                }
                else {
                    sprite.tint = 0xffffff;
                    sprite.alpha = 1;
                }
            }
        }
        onTypeChange(type) {
            switch (type) {
                case DColorType.CUSTOM:
                    this._mainBaseSprite.visible = true;
                    this._mainSprite.visible = true;
                    this._mainPointerSprite.visible = true;
                    this._baseSprite.visible = true;
                    this._mainStandardColor.visible = false;
                    break;
                case DColorType.STANDARD:
                    this._mainBaseSprite.visible = false;
                    this._mainSprite.visible = false;
                    this._mainPointerSprite.visible = false;
                    this._baseSprite.visible = false;
                    this._mainStandardColor.visible = true;
                    break;
                default:
                    return;
            }
        }
        getType() {
            return "DPickerColor";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const isEqual = (a, b) => {
        if (a.direction !== b.direction) {
            return false;
        }
        const ap = a.points;
        const bp = b.points;
        if (ap.length !== bp.length) {
            return false;
        }
        for (let j = 0, jmax = ap.length; j < jmax; ++j) {
            const apj = ap[j];
            const bpj = bp[j];
            if (apj.color !== bpj.color || apj.alpha !== bpj.alpha || apj.position !== bpj.position) {
                return false;
            }
        }
        return true;
    };
    class DPickerColorGradientRecent extends pixi_js.utils.EventEmitter {
        constructor(recents, capacity) {
            super();
            this._recents = recents;
            this._capacity = capacity;
        }
        getCapacity() {
            return this._capacity;
        }
        get(index) {
            const recents = this._recents;
            if (0 <= index && index < recents.length) {
                return recents[recents.length - 1 - index];
            }
            return null;
        }
        set(index, points) {
            const recents = this._recents;
            if (0 <= index && index < recents.length) {
                const result = recents[recents.length - 1 - index];
                recents[recents.length - 1 - index] = points;
                this.emit("change", this);
                return result;
            }
            return null;
        }
        contains(points) {
            const recents = this._recents;
            for (let i = 0, imax = recents.length; i < imax; ++i) {
                if (isEqual(recents[i], points)) {
                    return true;
                }
            }
            return false;
        }
        add(points) {
            const recents = this._recents;
            recents.push(points);
            if (this._capacity < recents.length) {
                recents.shift();
            }
            this.emit("change", this);
            return this;
        }
        pop() {
            const recents = this._recents;
            const result = recents.shift();
            if (result != null) {
                this.emit("change", this);
                return result;
            }
            return null;
        }
        size() {
            return this._recents.length;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const VERTEX_SHADER = `
attribute vec2 aPosition;
attribute vec2 aUv;
attribute vec4 aColor;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;

varying vec2 vUv;
varying vec4 vColor;

void main(void) {
	vec3 position = vec3(aPosition.x, aPosition.y, 1.0);
	gl_Position = vec4((projectionMatrix * translationMatrix * position).xy, 0.0, 1.0);
	vUv = aUv;
	vColor = aColor;
}
`;
    const FRAGMENT_SHADER = `
varying vec2 vUv;
varying vec4 vColor;

uniform sampler2D uSampler;
uniform vec2 uCheckerColors;

void main(void) {
	vec4 texture = texture2D(uSampler, vUv);
	float cy = step( 1.0, mod( gl_FragCoord.y / 10.0, 2.0 ) );
	float cx = step( 1.0, mod( gl_FragCoord.x / 10.0 + cy, 2.0 ) );
	float c = mix( uCheckerColors.x, uCheckerColors.y, cx );
	gl_FragColor = texture * vec4( mix( vec3( c ), vColor.xyz, vColor.a ), 1.0 );
}`;
    class DPickerColorGradientView extends pixi_js.Mesh {
        constructor(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader) {
            super(geometry, shader);
            this.interactive = true;
            this.interactiveChildren = false;
            this.cursor = "pointer";
            this._nPointsPerData = nPointsPerData;
            this._vertices = vertices;
            this._uvs = uvs;
            this._colors = colors;
            this._indices = indices;
            this._lastHitIndex = -1;
            this._workColor = [0, 0, 0];
            this._workPoint = new pixi_js.Point();
            this._parts = parts;
            shader.uniforms.uSampler.on("update", () => {
                this.update();
                DApplications.update(this);
            });
            this.update();
        }
        getRectangle(index) {
            const parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].rect;
            }
            return null;
        }
        setRectangle(index, x, y, width, height) {
            const parts = this._parts;
            if (0 <= index && index < parts.length) {
                const rect = parts[index].rect;
                rect.x = x;
                rect.y = y;
                rect.width = width;
                rect.height = height;
            }
        }
        getData(index) {
            const parts = this._parts;
            if (0 <= index && index < parts.length) {
                return parts[index].data;
            }
            return null;
        }
        setData(index, data) {
            const parts = this._parts;
            if (0 <= index && index < parts.length) {
                parts[index].data = data;
            }
        }
        getLastHitIndex() {
            return this._lastHitIndex;
        }
        setColors(ic, colors, rgb, alpha) {
            colors[ic + 0] = rgb[0];
            colors[ic + 1] = rgb[1];
            colors[ic + 2] = rgb[2];
            colors[ic + 3] = alpha;
            colors[ic + 4] = rgb[0];
            colors[ic + 5] = rgb[1];
            colors[ic + 6] = rgb[2];
            colors[ic + 7] = alpha;
        }
        setColorsHex(ic, colors, color, alpha) {
            const rgb = pixi_js.utils.hex2rgb(color, this._workColor);
            this.setColors(ic, colors, rgb, alpha);
        }
        setColorsWhite(ic, colors) {
            const rgb = this._workColor;
            rgb[0] = 1;
            rgb[1] = 1;
            rgb[2] = 1;
            this.setColors(ic, colors, rgb, 0);
        }
        setColorsPoint(ic, data, index, colors) {
            const point = data.points[index];
            if (point != null) {
                this.setColorsHex(ic, colors, point.color, point.alpha);
            }
            else {
                this.setColorsWhite(ic, colors);
            }
        }
        setVertices(iv, vertices, position, rect) {
            const y = rect.y + rect.height * position;
            vertices[iv + 0] = rect.x;
            vertices[iv + 1] = y;
            vertices[iv + 2] = rect.x + rect.width;
            vertices[iv + 3] = y;
        }
        setUvs(iv, uvs, position, textureUvs) {
            const x0 = textureUvs.x0 + (textureUvs.x3 - textureUvs.x0) * position;
            const y0 = textureUvs.y0 + (textureUvs.y3 - textureUvs.y0) * position;
            const x1 = textureUvs.x1 + (textureUvs.x2 - textureUvs.x1) * position;
            const y1 = textureUvs.y1 + (textureUvs.y2 - textureUvs.y1) * position;
            uvs[iv + 0] = x0;
            uvs[iv + 1] = y0;
            uvs[iv + 2] = x1;
            uvs[iv + 3] = y1;
        }
        newIndices(ii, iv, size, indices) {
            for (let i = 0; i < size; ++i) {
                indices[ii + 0] = iv + 0;
                indices[ii + 1] = iv + 1;
                indices[ii + 2] = iv + 2;
                indices[ii + 3] = iv + 2;
                indices[ii + 4] = iv + 1;
                indices[ii + 5] = iv + 3;
                ii += 6;
                iv += 2;
            }
            return indices;
        }
        _calculateBounds() {
            const worldTransform = this.transform.worldTransform;
            const rect = this._parts[0].rect;
            const bounds = this._bounds;
            const work = this._workPoint;
            work.set(rect.x, rect.y);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(rect.x + rect.width, rect.y + rect.height);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
        }
        update() {
            const vertices = this._vertices;
            const uvs = this._uvs;
            const colors = this._colors;
            const indices = this._indices;
            const texture = this.shader.uniforms.uSampler;
            if (texture._uvs == null) {
                texture.updateUvs();
            }
            const textureUvs = texture._uvs;
            let iv = 0;
            let nv = 0;
            let ic = 0;
            let ii = 0;
            const parts = this._parts;
            for (let i = 0, imax = parts.length; i < imax; ++i) {
                const data = parts[i].data;
                const rect = parts[i].rect;
                if (data == null) {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsWhite(ic, colors);
                    this.setVertices(iv + 4, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsWhite(ic + 8, colors);
                    this.newIndices(ii, nv, 1, indices);
                    iv += 4 * 2;
                    ic += 4 * 4;
                    nv += 4;
                    ii += 6;
                }
                else {
                    this.setVertices(iv, vertices, 0, rect);
                    this.setUvs(iv, uvs, 0, textureUvs);
                    this.setColorsPoint(ic, data, 0, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    const pointSize = data.points.length;
                    for (let j = 0, jmax = Math.min(pointSize, this._nPointsPerData); j < jmax; ++j) {
                        const point = data.points[j];
                        this.setVertices(iv, vertices, point.position, rect);
                        this.setUvs(iv, uvs, point.position, textureUvs);
                        this.setColorsHex(ic, colors, point.color, point.alpha);
                        iv += 2 * 2;
                        ic += 2 * 4;
                    }
                    this.setVertices(iv, vertices, 1, rect);
                    this.setUvs(iv, uvs, 1, textureUvs);
                    this.setColorsPoint(ic, data, pointSize - 1, colors);
                    iv += 2 * 2;
                    ic += 2 * 4;
                    this.newIndices(ii, nv, pointSize + 1, indices);
                    ii += (pointSize + 1) * 6;
                    nv += (pointSize + 2) * 2;
                }
            }
            this.size = ii;
            const geometry = this.geometry;
            geometry.getBuffer("aPosition").update();
            geometry.getBuffer("aUv").update();
            geometry.getBuffer("aColor").update();
            geometry.getIndex().update();
        }
        containsPoint(point) {
            const local = this.toLocal(point, undefined, this._workPoint);
            const parts = this._parts;
            for (let i = 0, imax = parts.length; i < imax; ++i) {
                const rect = parts[i].rect;
                if (rect.contains(local.x, local.y)) {
                    this._lastHitIndex = i;
                    return true;
                }
            }
            return false;
        }
        static from(size, nPointsPerData, checkerColors, texture = pixi_js.Texture.WHITE) {
            const vertices = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            const uvs = new Float32Array(size * (nPointsPerData + 2) * 2 * 2);
            const colors = new Float32Array(size * (nPointsPerData + 2) * 2 * 4);
            const indices = new Uint16Array(size * (nPointsPerData + 1) * 6);
            const parts = [];
            for (let i = 0; i < size; ++i) {
                parts.push({
                    data: null,
                    rect: new pixi_js.Rectangle()
                });
            }
            const geometry = new pixi_js.Geometry()
                .addIndex(new pixi_js.Buffer(indices, false, true))
                .addAttribute("aPosition", new pixi_js.Buffer(vertices, false, false), 2)
                .addAttribute("aUv", new pixi_js.Buffer(uvs, false, false), 2)
                .addAttribute("aColor", new pixi_js.Buffer(colors, false, false), 4);
            const program = pixi_js.Program.from(VERTEX_SHADER, FRAGMENT_SHADER);
            const shader = new pixi_js.MeshMaterial(texture, {
                program,
                uniforms: {
                    uCheckerColors: checkerColors
                }
            });
            return new DPickerColorGradientView(nPointsPerData, vertices, uvs, colors, indices, parts, geometry, shader);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerColorGradient extends DBase {
        init(options) {
            super.init(options);
            const theme = this.theme;
            const padding = this._padding;
            const paddingTop = padding.getTop();
            const paddingRight = padding.getRight();
            const paddingBottom = padding.getBottom();
            const paddingLeft = padding.getLeft();
            this._work = new pixi_js.Point();
            // Picker
            const gradientPointsWidth = theme.getGradientPointsWidth();
            const gradientPointsMargin = theme.getGradientPointsMargin();
            const picker = new DPickerColor({
                x: paddingLeft + gradientPointsWidth + gradientPointsMargin,
                y: paddingTop
            });
            this._picker = picker;
            picker.on("newcolorchange", (color) => {
                this.onAnchorColorChange(color);
            });
            picker.on("newalphachange", (alpha) => {
                this.onAnchorAlphaChange(alpha);
            });
            this.addChild(picker);
            // Points view
            const view = (this._view = DPickerColorGradientView.from(17, 10, theme.getGradientCheckerColors()));
            view.setRectangle(0, paddingLeft, paddingTop, gradientPointsWidth, picker.height);
            this.addChild(view);
            view.on(UtilPointerEvent.down, (e) => {
                if (view.getLastHitIndex() === 0) {
                    this.onViewDown(e);
                }
            });
            // Anchor
            this._onAnchorDownBound = (e) => {
                this.onAnchorDown(e);
            };
            this._onAnchorMoveBound = (e) => {
                this.onAnchorMove(e);
            };
            this._onAnchorUpBound = (e) => {
                this.onAnchorUp(e);
            };
            this._anchors = [];
            //
            const recentColumn = theme.getGradientRecentColumn();
            const recentWidth = theme.getGradientRecentWidth();
            const recentMargin = theme.getGradientRecentMargin();
            const recentWidthAndMargin = recentWidth + recentMargin;
            const inputLabelWidth = picker.theme.getInputLabelWidth();
            const inputWidth = recentWidth * recentColumn + recentMargin * (recentColumn - 1);
            const inputMargin = 5;
            const inputDirectionMargin = theme.getGradientDirectionMargin();
            const inputDirectionTexture = theme.getGradientDirectionTexture();
            const inputLeft = picker.x + picker.width + inputDirectionMargin;
            const inputDirection = new DInputReal({
                parent: this,
                x: inputLeft + inputLabelWidth + inputMargin,
                y: paddingTop,
                width: inputWidth - (inputLabelWidth + inputMargin) * 2,
                step: 1,
                image: {
                    source: inputDirectionTexture,
                    align: {
                        with: DAlignWith.BORDER
                    },
                    margin: {
                        horizontal: -inputDirectionTexture.width - inputMargin
                    }
                },
                on: {
                    change: (value) => {
                        this._value._direction = value;
                    }
                }
            });
            // Recent gradients
            const x0 = inputLeft;
            const y0 = inputDirection.y + inputDirection.height + inputDirectionMargin;
            if (DPickerColorGradient.RECENT_COLOR_GRADIENT == null) {
                DPickerColorGradient.RECENT_COLOR_GRADIENT = new DPickerColorGradientRecent(theme.getGradientRecents(), theme.getGradientRecentCount());
            }
            this._recent = DPickerColorGradient.RECENT_COLOR_GRADIENT;
            const recent = this._recent;
            for (let i = 0, imax = recent.getCapacity(); i < imax; ++i) {
                const ix = i % recentColumn;
                const x = x0 + ix * recentWidthAndMargin;
                const iy = (i / recentColumn) | 0;
                const y = y0 + iy * recentWidthAndMargin;
                view.setRectangle(1 + i, x, y, recentWidth, recentWidth);
            }
            recent.on("change", () => {
                this.onRecentUpdate();
            });
            view.on(UtilPointerEvent.tap, (e) => {
                const lastHitIndex = view.getLastHitIndex();
                if (1 <= lastHitIndex) {
                    this.onRecentClick(view.getData(lastHitIndex));
                }
            });
            // Points
            const data = new DColorGradientObservable();
            this._value = data;
            data.on("change", () => {
                this.updateAnchors();
                view.update();
            });
            data.on("selectionchange", (point) => {
                this.onAnchorSelect(point);
            });
            data.on("directionchange", (value) => {
                inputDirection.value = value;
            });
            view.setData(0, data);
            view.update();
            inputDirection.value = data.direction;
            this.updateAnchors();
            const selected = data.selected;
            if (selected != null) {
                this.onAnchorSelect(selected);
            }
            // Width
            if (options == null || options.width == null) {
                this.width =
                    paddingLeft +
                        gradientPointsWidth +
                        gradientPointsMargin +
                        picker.width +
                        inputDirectionMargin +
                        (recentColumn - 1) * recentMargin +
                        recentColumn * recentWidth +
                        paddingRight;
            }
            // Height
            if (options == null || options.height == null) {
                this.height = paddingTop + picker.height + paddingBottom;
            }
        }
        get value() {
            return this._value;
        }
        get recent() {
            return this._recent;
        }
        onRecentClick(recentData) {
            const value = this._value;
            if (recentData != null) {
                value.fromObject(recentData);
            }
            else {
                value.reset();
            }
        }
        onRecentUpdate() {
            const recent = this._recent;
            const view = this._view;
            for (let i = 0, imax = recent.size(); i < imax; ++i) {
                view.setData(1 + i, recent.get(i));
            }
            view.update();
            DApplications.update(this);
        }
        toAnchorPosition(e) {
            const local = this.toLocal(e.data.global, undefined, this._work);
            return Math.max(0, Math.min(1, (local.y - this.padding.getTop()) / this._picker.height));
        }
        onViewDown(e) {
            this._value.addAt(this.toAnchorPosition(e));
            this.onAnchorDragStart();
        }
        onAnchorDown(e) {
            const target = e.target;
            if (target instanceof pixi_js.Sprite) {
                const value = this._value;
                const index = this._anchors.indexOf(target);
                if (0 <= index && index < value.points.length) {
                    value.points[index].selected = true;
                    this.onAnchorDragStart();
                }
            }
        }
        onAnchorSelect(point) {
            const picker = this._picker;
            picker.current.color = point.color;
            picker.current.alpha = point.alpha;
            picker.new.color = point.color;
            picker.new.alpha = point.alpha;
        }
        onAnchorColorChange(color) {
            const value = this._value;
            if (value != null) {
                const selected = value.selected;
                if (selected != null) {
                    selected.color = color;
                }
            }
        }
        onAnchorAlphaChange(alpha) {
            const value = this._value;
            if (value != null) {
                const selected = value.selected;
                if (selected != null) {
                    selected.alpha = alpha;
                }
            }
        }
        onAnchorDragStart() {
            const layer = DApplications.getLayer(this);
            if (layer) {
                const stage = layer.stage;
                stage.on(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.on(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        }
        onAnchorMove(e) {
            const value = this._value;
            if (value != null) {
                const selected = value.selected;
                if (selected != null) {
                    selected.position = this.toAnchorPosition(e);
                }
            }
        }
        onAnchorUp(e) {
            const layer = DApplications.getLayer(this);
            if (layer) {
                const stage = layer.stage;
                stage.off(UtilPointerEvent.move, this._onAnchorMoveBound);
                stage.off(UtilPointerEvent.up, this._onAnchorUpBound);
            }
        }
        updateAnchors() {
            const theme = this.theme;
            const anchorTexture = theme.getGradientAnchorTexture();
            const anchorOutlinedTexture = theme.getGradientAnchorOutlinedTexture();
            const gradientPointsWidth = theme.getGradientPointsWidth();
            const value = this._value;
            const pointSize = value.points.length;
            const anchors = this._anchors;
            const anchorSize = anchors.length;
            for (let i = anchorSize; i < pointSize; ++i) {
                const newAnchor = new pixi_js.Sprite(anchorTexture);
                newAnchor.anchor.set(0.5, 0.5);
                newAnchor.cursor = "pointer";
                newAnchor.interactive = true;
                newAnchor.on(UtilPointerEvent.down, this._onAnchorDownBound);
                anchors.push(newAnchor);
                this.addChild(newAnchor);
            }
            for (let i = anchorSize - 1; pointSize <= i; --i) {
                const oldAnchor = anchors[i];
                oldAnchor.off(UtilPointerEvent.down, this._onAnchorDownBound);
                oldAnchor.destroy();
            }
            anchors.length = pointSize;
            const y = this.padding.getTop();
            const right = this.padding.getLeft() + gradientPointsWidth;
            const height = this._picker.height;
            for (let i = 0; i < pointSize; ++i) {
                const point = value.points[i];
                const anchor = anchors[i];
                anchor.tint = point.color;
                anchor.position.set(right, y + height * point.position);
                anchor.texture = point.selected ? anchorOutlinedTexture : anchorTexture;
            }
            DApplications.update(this);
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isDeleteKey(e)) {
                const value = this._value;
                if (value != null) {
                    const selected = value.selected;
                    if (selected != null) {
                        value.remove(selected);
                        super.onKeyDown(e);
                        return true;
                    }
                }
            }
            return super.onKeyDown(e);
        }
        getType() {
            return "DPickerColorGradient";
        }
    }
    DPickerColorGradient.RECENT_COLOR_GRADIENT = null;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogColorGradient extends DDialogFitted {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.picker);
            return result;
        }
        onOk(value) {
            super.onOk(value);
            const picker = this.picker;
            const data = picker.value;
            const recent = picker.recent;
            if (!recent.contains(data)) {
                recent.add(data.toObject());
            }
        }
        get value() {
            return this.picker.value;
        }
        get recent() {
            return this.picker.recent;
        }
        get picker() {
            var _a;
            let result = this._picker;
            if (result == null) {
                result = new DPickerColorGradient((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                this._picker = result;
            }
            return result;
        }
        getResolvedValue() {
            return this.picker.value;
        }
        onKeyDown(e) {
            this.picker.onKeyDown(e);
            return super.onKeyDown(e);
        }
        getType() {
            return "DDialogColorGradient";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonColorGradient extends DButton {
        init(options) {
            var _a;
            super.init(options);
            const source = (_a = options === null || options === void 0 ? void 0 : options.image) === null || _a === void 0 ? void 0 : _a.source;
            if (source === undefined) {
                const theme = this.theme;
                const texture = theme.getViewBaseTexture();
                if (texture instanceof pixi_js.Texture) {
                    const checkers = theme.getCheckerColors();
                    const view = DPickerColorGradientView.from(1, 10, checkers, texture);
                    this._view = view;
                    view.setRectangle(0, 0, 0, texture.width, texture.height);
                    view.setData(0, this.text.computed);
                    view.update();
                    this.image = view;
                }
            }
        }
        onActivate(e) {
            super.onActivate(e);
            const computed = this.text.computed;
            const dialog = this.dialog;
            if (computed != null) {
                dialog.value.fromObject(computed);
            }
            dialog.open(this).then((newValue) => {
                this.onValueChange(newValue, this.toClone(computed));
            });
        }
        toClone(value) {
            const result = new DColorGradientObservable();
            if (value != null) {
                result.fromObject(value);
            }
            return result;
        }
        onValueChange(newValue, oldValue) {
            const computed = this.text.computed;
            if (computed != null) {
                computed.fromObject(newValue);
            }
            const view = this._view;
            if (view != null) {
                view.update();
            }
            this.text.compute(true);
            this.emit("change", newValue, oldValue, this);
        }
        get dialog() {
            var _a;
            let dialog = this._dialog;
            if (dialog == null) {
                const options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                if (options) {
                    dialog = this.newDialog(options);
                }
                else {
                    if (DButtonColorGradient.DIALOG == null) {
                        DButtonColorGradient.DIALOG = this.newDialog({
                            mode: "MENU",
                            sticky: true
                        });
                    }
                    dialog = DButtonColorGradient.DIALOG;
                }
                this._dialog = dialog;
            }
            return dialog;
        }
        newDialog(options) {
            return new DDialogColorGradient(options);
        }
        get value() {
            return this.text.computed;
        }
        getType() {
            return "DButtonColorGradient";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogColor extends DDialogFitted {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.picker);
            return result;
        }
        onOk(value) {
            super.onOk(value);
            const picker = this.picker;
            const recent = picker.recent;
            if (!recent.contains(picker.new)) {
                recent.add(picker.new);
            }
        }
        get current() {
            return this.picker.current;
        }
        get new() {
            return this.picker.new;
        }
        get recent() {
            return this.picker.recent;
        }
        get picker() {
            var _a;
            let result = this._picker;
            if (result == null) {
                result = new DPickerColor((_a = this._options) === null || _a === void 0 ? void 0 : _a.picker);
                this._picker = result;
            }
            return result;
        }
        getResolvedValue() {
            return this.picker.new;
        }
        getType() {
            return "DDialogColor";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonColor extends DButton {
        onActivate(e) {
            super.onActivate(e);
            const dialog = this.dialog;
            const computed = this.text.computed;
            if (computed != null) {
                const dialogCurrent = dialog.current;
                dialogCurrent.color = computed.color;
                dialogCurrent.alpha = computed.alpha;
                const dialogNew = dialog.new;
                dialogNew.color = computed.color;
                dialogNew.alpha = computed.alpha;
            }
            dialog.open(this).then(() => {
                this.onValueChange(this.toClone(dialog.new), this.toClone(dialog.current));
            });
        }
        toClone(value) {
            return {
                color: value.color,
                alpha: value.alpha
            };
        }
        onValueChange(newValue, oldValue) {
            const computed = this.text.computed;
            if (computed != null) {
                computed.color = newValue.color;
                computed.alpha = newValue.alpha;
            }
            this.onColorChange();
            this.emit("change", newValue, oldValue, this);
        }
        onColorChange() {
            const image = this.image.get(0);
            if (image != null) {
                const computed = this.text.computed;
                if (computed != null) {
                    image.tint.color = computed.color;
                }
            }
            this.text.compute(true);
        }
        get dialog() {
            var _a;
            let dialog = this._dialog;
            if (dialog == null) {
                const options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                if (options) {
                    dialog = this.newDialog(options);
                }
                else {
                    if (DButtonColor.DIALOG == null) {
                        DButtonColor.DIALOG = this.newDialog({
                            mode: "MENU",
                            sticky: true
                        });
                    }
                    dialog = DButtonColor.DIALOG;
                }
                this._dialog = dialog;
            }
            return dialog;
        }
        newDialog(options) {
            return new DDialogColor(options);
        }
        get value() {
            let result = this._value;
            if (result == null) {
                result = this.newValue();
                this._value = result;
            }
            return result;
        }
        newValue() {
            const text = this.text;
            const computed = text.computed;
            return new DPickerColorAndAlpha(computed, (color) => {
                computed.color = color;
                this.onColorChange();
            }, (alpha) => {
                computed.alpha = alpha;
                text.compute(true);
            });
        }
        getType() {
            return "DButtonColor";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonDanger extends DButton {
        getType() {
            return "DButtonDanger";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonDate extends DButton {
        onActivate(e) {
            var _a, _b;
            super.onActivate(e);
            const value = (_b = (_a = this.text.computed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            const dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open(this).then(() => {
                this.onValueChange(dialog.new, dialog.current);
            });
        }
        onValueChange(newValue, oldValue) {
            this.text = new Date(newValue.getTime());
            this.emit("change", newValue, oldValue, this);
        }
        get dialog() {
            var _a;
            let dialog = this._dialog;
            if (dialog == null) {
                const options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                if (options) {
                    dialog = this.newDialog(options);
                }
                else {
                    if (DButtonDate.DIALOG == null) {
                        DButtonDate.DIALOG = this.newDialog({
                            mode: "MENU",
                            sticky: true
                        });
                    }
                    dialog = DButtonDate.DIALOG;
                }
                this._dialog = dialog;
            }
            return dialog;
        }
        newDialog(options) {
            return new DDialogDate(options);
        }
        get value() {
            var _a;
            return (_a = this.text.computed) !== null && _a !== void 0 ? _a : new Date();
        }
        set value(value) {
            const computed = this.text.computed;
            if (computed === undefined || computed.getTime() !== value.getTime()) {
                this.text = value;
            }
        }
        getType() {
            return "DButtonDate";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDates {
        static format(date) {
            const y = toPadded(String(date.getFullYear()), 4, "0");
            const M = toPadded(String(date.getMonth() + 1), 2, "0");
            const S = toPadded(String(date.getDate()), 2, "0");
            return `${y}/${M}/${S}`;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerTimes {
        static format(date, mask) {
            let result = "";
            if (mask & DPickerDatetimeMask.HOURS) {
                result += toPadded(String(date.getHours()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.MINUTES) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getMinutes()), 2, "0");
            }
            if (mask & DPickerDatetimeMask.SECONDS) {
                if (0 < result.length) {
                    result += ":";
                }
                result += toPadded(String(date.getSeconds()), 2, "0");
            }
            return result;
        }
        static toMask(options) {
            return DPickerDatetimeMasks.from("DPickerTime", options);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetimes {
        static format(date, mask) {
            const hms = DPickerTimes.format(date, mask);
            if (0 < hms.length) {
                return `${DPickerDates.format(date)} ${hms}`;
            }
            else {
                return `${DPickerDates.format(date)}`;
            }
        }
        static toMask(options) {
            return DPickerDatetimeMasks.from("DPickerDatetime", options);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonDatetime extends DButton {
        onActivate(e) {
            var _a, _b;
            super.onActivate(e);
            const value = (_b = (_a = this.text.computed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            const dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.page = new Date(value);
            dialog.open(this).then(() => {
                this.onValueChange(dialog.new, dialog.current);
            });
        }
        onValueChange(newValue, oldValue) {
            this.text = new Date(newValue.getTime());
            this.emit("change", newValue, oldValue, this);
        }
        getDatetimeMask() {
            var _a, _b;
            let result = this._datetimeMask;
            if (result == null) {
                result = DPickerDatetimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        }
        get dialog() {
            var _a;
            let dialog = this._dialog;
            if (dialog == null) {
                const options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                if (options) {
                    dialog = this.newDialog(options);
                }
                else {
                    if (DButtonDatetime.DIALOG == null) {
                        DButtonDatetime.DIALOG = this.newDialog({
                            mode: "MENU",
                            sticky: true
                        });
                    }
                    dialog = DButtonDatetime.DIALOG;
                }
                this._dialog = dialog;
            }
            return dialog;
        }
        newDialog(options) {
            return new DDialogDatetime(options);
        }
        get value() {
            var _a;
            return (_a = this.text.computed) !== null && _a !== void 0 ? _a : new Date();
        }
        set value(value) {
            const computed = this.text.computed;
            if (computed === undefined || computed.getTime() !== value.getTime()) {
                this.text = value;
            }
        }
        getType() {
            return "DButtonDatetime";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A file selector.
     */
    class DButtonFile extends DButton {
        getChecker() {
            var _a, _b;
            let result = this._checker;
            if (result === undefined) {
                result = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.checker) !== null && _b !== void 0 ? _b : null;
                this._checker = result;
            }
            return result;
        }
        getOpener() {
            let result = this._opener;
            if (result == null) {
                result = this.newOpener();
                this._opener = result;
            }
            return result;
        }
        newOpener() {
            var _a, _b;
            return new UtilFileOpener(toEnum((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.as) !== null && _b !== void 0 ? _b : UtilFileAs.TEXT, UtilFileAs), this);
        }
        onActivate(e) {
            super.onActivate(e);
            this.check(() => {
                this.open();
            });
        }
        check(onResolve) {
            const checker = this.getChecker();
            if (checker != null) {
                const result = checker();
                if (result === true) {
                    onResolve();
                }
                else if (result === false) ;
                else {
                    result.then(() => {
                        onResolve();
                    });
                }
            }
            else {
                onResolve();
            }
        }
        open() {
            this.getOpener().open();
        }
        getType() {
            return "DButtonFile";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonLink extends DButtonBase {
        onClick(e) {
            if (!this.link.onClick(this, e)) {
                super.onClick(e);
            }
        }
        get link() {
            let result = this._link;
            if (result == null) {
                result = new DLink(this._options);
                this._link = result;
            }
            return result;
        }
        onActivate(e) {
            super.onActivate(e);
            this.link.open(e);
        }
        open(inNewWindow) {
            this.link.open(inNewWindow);
        }
        getType() {
            return "DButtonLink";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonRadio extends DButtonBase {
        getType() {
            return "DButtonRadio";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonRadioRight extends DButtonRadio {
        getType() {
            return "DButtonRadioRight";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonRedo extends DButton {
        constructor(options) {
            super(options);
            const state = this.state;
            const commandController = DControllers.getCommandController();
            state.isDisabled = !commandController.isRedoable();
            commandController.on("change", () => {
                state.isDisabled = !commandController.isRedoable();
            });
        }
        onActivate(e) {
            super.onActivate(e);
            DControllers.getCommandController().redo();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonSecondary extends DButton {
        getType() {
            return "DButtonSecondary";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DListDataSelection} type.
     */
    const DListDataSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DListItem extends DImageBase {
        constructor(data, options) {
            super(options);
            this._data = data;
            this.on(UtilPointerEvent.tap, (e) => {
                this.onClick(e);
            });
        }
        get link() {
            let result = this._link;
            if (result === undefined) {
                result = this.newLink();
                this._link = result;
            }
            return result;
        }
        newLink() {
            const link = this._data.accessor.link;
            if (link) {
                return new DLink(this.toLinkOptions(link));
            }
            return null;
        }
        onClick(e) {
            var _a;
            if (((_a = this.link) === null || _a === void 0 ? void 0 : _a.onClick(this, e)) !== true) {
                if (this.state.isActionable) {
                    this.activate(e);
                }
            }
        }
        activate(e) {
            const value = this._value;
            if (value !== undefined) {
                this.onSelect(e, value);
            }
        }
        toLinkOptions(accessor) {
            return {
                url: this.toLinkUrl(accessor.toUrl),
                target: accessor.target,
                checker: this.toLinkChecker(accessor.checker)
            };
        }
        toLinkUrl(toUrl) {
            return () => {
                const value = this._value;
                if (value !== undefined) {
                    return toUrl(value);
                }
            };
        }
        toLinkChecker(checker) {
            if (checker) {
                return () => {
                    const value = this._value;
                    if (value != null) {
                        return checker(value);
                    }
                    return false;
                };
            }
            return undefined;
        }
        get value() {
            return this._value;
        }
        get index() {
            return this._index;
        }
        onSelect(e, value) {
            var _a;
            this.emit("select", value, this);
            const data = this._data;
            const selection = data.selection;
            if (selection.type !== DListDataSelectionType.MULTIPLE) {
                selection.clearAndAdd(value);
            }
            else {
                const originalEvent = e && "data" in e ? e.data.originalEvent : e;
                if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.ctrlKey) {
                    selection.toggle(value);
                }
                else if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.shiftKey) {
                    const mapped = data.mapped;
                    const last = selection.last;
                    if (value === last) {
                        selection.clearAndAdd(value);
                    }
                    else {
                        let isFound = false;
                        let isReverse = false;
                        const newSelection = [];
                        mapped.each((item) => {
                            if (isFound) {
                                if (isReverse) {
                                    newSelection.unshift(item);
                                    if (item === value) {
                                        return false;
                                    }
                                }
                                else {
                                    newSelection.push(item);
                                    if (item === last) {
                                        return false;
                                    }
                                }
                            }
                            else {
                                if (item === value) {
                                    isFound = true;
                                    isReverse = false;
                                    newSelection.push(item);
                                }
                                else if (item === last) {
                                    isFound = true;
                                    isReverse = true;
                                    newSelection.push(item);
                                }
                            }
                        });
                        selection.clearAndAddAll(newSelection);
                    }
                }
                else {
                    selection.clearAndAdd(value);
                }
            }
            (_a = this._link) === null || _a === void 0 ? void 0 : _a.open(e);
        }
        set(value, index, forcibly) {
            const data = this._data;
            const isValueChanged = forcibly || this._value !== value;
            if (isValueChanged) {
                this._value = value;
                this._index = index;
                const accessor = data.accessor;
                this.text = accessor.toLabel(value);
                this.title = accessor.toTitle(value) || "";
                this.image = accessor.toImage(value);
            }
            const state = this.state;
            state.lock();
            state.set(DBaseState.ACTIVE, data.selection.contains(value));
            state.remove(DBaseState.DISABLED);
            state.unlock();
            if (isValueChanged) {
                this.emit("set", value, index, this);
            }
        }
        unset() {
            if (this._value !== undefined) {
                this._value = undefined;
                this._index = undefined;
                this.text = undefined;
                this.title = "";
                this.image = undefined;
                const state = this.state;
                state.lock();
                state.add(DBaseState.DISABLED);
                state.remove(DBaseState.ACTIVE);
                state.unlock();
                this.emit("unset", this);
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return super.onKeyDown(e);
        }
        onKeyDownActivate(e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.activate(e);
                return true;
            }
            return false;
        }
        getType() {
            return "DListItem";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogSelectListItem extends DListItem {
        getType() {
            return "DDialogSelectListItem";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * The primary purpose of this class is to minimize the number of rendered items (e.g., {@link DListItem})
     * as low as possible and to update their positions and states. For this sake, the updater calculates the
     * required number of items whenever their container size changes and creates items if needed.
     */
    class DItemUpdater {
        constructor(data, content, container, options) {
            this._updateItemsCount = 0;
            this._isUpdateItemsCalled = false;
            this._isUpdateItemsCalledForcibly = false;
            this._itemHeight = -1;
            this._itemWidth = -1;
            this._multiplicity = 1;
            this._itemIndexStart = 0;
            this._itemIndexEnd = 0;
            this._workItems = [];
            this._data = data;
            this._content = content;
            this._container = container;
            this._newItem = this.toNewItem(options);
            this._initItem = this.toInitItem(options);
        }
        toNewItem(options) {
            return (options === null || options === void 0 ? void 0 : options.newItem) || this.newItem;
        }
        toInitItem(options) {
            if (options) {
                const initItem = options.initItem;
                if (initItem) {
                    return initItem;
                }
                if (options.stripe !== false) {
                    return this.initItem;
                }
                return this.initItemNoStriping;
            }
            return this.initItem;
        }
        initItem(item, index, data) {
            item.state.isAlternated = index % 2 === 1;
            return item;
        }
        initItemNoStriping(item, index, data) {
            return item;
        }
        get multiplicity() {
            return this._multiplicity;
        }
        lock() {
            this._updateItemsCount += 1;
            if (this._updateItemsCount === 1) {
                this._isUpdateItemsCalled = false;
                this._isUpdateItemsCalledForcibly = false;
            }
        }
        unlock(callIfNeeded) {
            this._updateItemsCount -= 1;
            if (this._updateItemsCount === 0) {
                if (callIfNeeded && this._isUpdateItemsCalled) {
                    this.update(this._isUpdateItemsCalledForcibly);
                }
                this._isUpdateItemsCalled = false;
                this._isUpdateItemsCalledForcibly = false;
            }
        }
        update(forcibly) {
            if (0 < this._updateItemsCount) {
                this._isUpdateItemsCalled = true;
                if (forcibly) {
                    this._isUpdateItemsCalledForcibly = true;
                }
                return;
            }
            const content = this._content;
            const contentParent = content.parent;
            if (contentParent == null) {
                return;
            }
            const container = this._container;
            const items = container.children;
            const height = contentParent.height;
            const data = this._data;
            const mapped = this.toMapped(data);
            const dataSize = mapped.size();
            const oldItemIndexStart = this._itemIndexStart;
            let oldItemIndexEnd = this._itemIndexEnd;
            let oldItemCount = oldItemIndexEnd - oldItemIndexStart;
            const newItem = this._newItem;
            const initItem = this._initItem;
            let itemHeight = this._itemHeight;
            let itemWidth = this._itemWidth;
            if (this._itemHeight < 0) {
                let item;
                if (0 < items.length) {
                    item = items[0];
                }
                else {
                    item = initItem(newItem(data), oldItemIndexStart, data);
                    container.addChild(item);
                    oldItemIndexEnd += 1;
                    oldItemCount += 1;
                }
                itemHeight = Math.max(1, item.height);
                if (isNumber(item.getWidth())) {
                    itemWidth = Math.max(1, item.width);
                }
                this._itemHeight = itemHeight;
                this._itemWidth = itemWidth;
            }
            const contentPadding = content.padding;
            const contentPaddingTop = contentPadding.getTop();
            const contentPaddingBottom = contentPadding.getBottom();
            const contentPaddingLeft = contentPadding.getLeft();
            const contentPaddingRight = contentPadding.getRight();
            const contentWidthAvailable = Math.max(0, content.width - contentPaddingLeft - contentPaddingRight);
            const multiplicity = 0 < itemWidth ? Math.max(1, Math.floor(contentWidthAvailable / itemWidth)) : 1;
            this._multiplicity = multiplicity;
            const y = content !== container ? container.transform.position.y : contentPaddingTop;
            const newHeight = Math.ceil(dataSize / multiplicity) * itemHeight;
            const newContentHeight = Math.max(height, contentPaddingTop + newHeight + contentPaddingBottom);
            const newContentY = Math.max(height - newContentHeight, content.position.y);
            const newItemIndexLowerBound = Math.floor(((0 - (newContentY + y)) * multiplicity) / itemHeight);
            const newItemIndexUpperBound = Math.floor(((height - (newContentY + y)) * multiplicity) / itemHeight);
            let newItemIndexStart = newItemIndexLowerBound - multiplicity;
            if (newItemIndexStart % 2 !== 0) {
                newItemIndexStart -= 1;
            }
            let newItemIndexEnd = newItemIndexUpperBound + multiplicity + multiplicity;
            if (newItemIndexEnd % 2 !== 0) {
                newItemIndexEnd += 1;
            }
            let newItemCount = newItemIndexEnd - newItemIndexStart;
            if (newItemCount < oldItemCount) {
                newItemCount = oldItemCount;
                newItemIndexEnd = newItemIndexStart + newItemCount;
            }
            if (oldItemCount < newItemCount) {
                for (let i = oldItemCount; i < newItemCount; ++i) {
                    const oldItemIndex = oldItemIndexStart + i;
                    const item = initItem(newItem(data), oldItemIndex, data);
                    container.addChild(item);
                }
                oldItemCount = newItemCount;
                oldItemIndexEnd = oldItemIndexStart + oldItemCount;
            }
            else if (newItemCount < oldItemCount) {
                for (let i = oldItemCount - 1; newItemCount <= i; --i) {
                    container.removeChild(items[i]);
                }
                oldItemCount = newItemCount;
                oldItemIndexEnd = oldItemIndexStart + oldItemCount;
            }
            this._itemIndexStart = newItemIndexStart;
            this._itemIndexEnd = newItemIndexEnd;
            const itemIndexStartDelta = newItemIndexStart - oldItemIndexStart;
            const itemIndexStartDeltaAbs = Math.abs(itemIndexStartDelta);
            const itemsLength = items.length;
            if (0 < itemIndexStartDeltaAbs && itemIndexStartDeltaAbs < itemsLength) {
                const work = this._workItems;
                if (0 < itemIndexStartDelta) {
                    for (let i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        const item = items[i];
                        this.reset(item);
                        work.push(item);
                    }
                    for (let i = itemIndexStartDeltaAbs; i < itemsLength; ++i) {
                        items[i - itemIndexStartDeltaAbs] = items[i];
                    }
                    for (let i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        items[itemsLength - itemIndexStartDeltaAbs + i] = work[i];
                    }
                }
                else {
                    for (let i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        const item = items[itemsLength - itemIndexStartDeltaAbs + i];
                        this.reset(item);
                        work.push(item);
                    }
                    for (let i = itemsLength - itemIndexStartDeltaAbs - 1; 0 <= i; --i) {
                        items[i + itemIndexStartDeltaAbs] = items[i];
                    }
                    for (let i = 0; i < itemIndexStartDeltaAbs; ++i) {
                        items[i] = work[i];
                    }
                }
                work.length = 0;
            }
            let itemOffsetX = 0;
            let itemOffsetY = 0;
            if (content === container) {
                itemOffsetX = contentPaddingLeft;
                itemOffsetY = contentPaddingTop;
            }
            mapped.each((datum, index) => {
                const item = items[index - newItemIndexStart];
                const ix = index % multiplicity;
                const iy = Math.floor(index / multiplicity);
                item.position.set(itemOffsetX + ix * itemWidth, itemOffsetY + iy * itemHeight);
                this.set(item, datum, index, forcibly);
            }, newItemIndexStart, newItemIndexStart + itemsLength);
            for (let i = 0; newItemIndexStart + i < 0 && i < itemsLength; ++i) {
                const item = items[i];
                const index = newItemIndexStart + i;
                const ix = index % multiplicity;
                const iy = Math.floor(index / multiplicity);
                item.position.set(itemOffsetX + ix * itemWidth, itemOffsetY + iy * itemHeight);
                this.unset(item);
            }
            for (let i = itemsLength - 1; dataSize <= newItemIndexStart + i && 0 <= i; --i) {
                const item = items[i];
                const index = newItemIndexStart + i;
                const ix = index % multiplicity;
                const iy = Math.floor(index / multiplicity);
                item.position.set(itemOffsetX + ix * itemWidth, itemOffsetY + iy * itemHeight);
                this.unset(item);
            }
            this.lock();
            content.position.y = newContentY;
            content.height = newContentHeight;
            if (content !== container) {
                container.height = newHeight;
            }
            this.unlock(false);
        }
        set(item, value, index, forcibly) {
            item.set(value, index, forcibly);
        }
        unset(item) {
            item.unset();
        }
        reset(item) {
            item.blur(true);
            const cells = item.children;
            for (let i = 0, imax = cells.length; i < imax; ++i) {
                const cell = cells[i];
                if (cell instanceof DBase) {
                    const state = cell.state;
                    state.lock();
                    state.isPressed = false;
                    state.isHovered = false;
                    state.unlock();
                }
            }
            item.state.isHovered = false;
            return item;
        }
        moveFocus(e, target, moveVertically, moveHorizontally) {
            if (!(moveVertically || moveHorizontally)) {
                return false;
            }
            const isUp = moveVertically && UtilKeyboardEvent.isArrowUpKey(e);
            const isDown = moveVertically && UtilKeyboardEvent.isArrowDownKey(e);
            const isLeft = moveHorizontally && UtilKeyboardEvent.isArrowLeftKey(e);
            const isRight = moveHorizontally && UtilKeyboardEvent.isArrowRightKey(e);
            if (!(isUp || isDown || isLeft || isRight)) {
                return false;
            }
            if (!target.state.isActionable) {
                return false;
            }
            const layer = DApplications.getLayer(target);
            if (layer == null) {
                return false;
            }
            const focusController = layer.getFocusController();
            const focused = focusController.get();
            if (focused == null) {
                return false;
            }
            const container = this._container;
            if (focused.parent !== container) {
                return false;
            }
            const item = focused;
            const index = item.index;
            if (index == null) {
                return false;
            }
            const multiplicity = this._multiplicity;
            const data = this._data;
            const mapped = this.toMapped(data);
            const dataSize = mapped.size();
            let newIndex = index;
            if (isLeft || isRight) {
                if (isLeft) {
                    if (0 <= newIndex - 1) {
                        newIndex -= 1;
                    }
                }
                else {
                    if (newIndex + 1 < dataSize) {
                        newIndex += 1;
                    }
                }
            }
            if (isUp || isDown) {
                if (isUp) {
                    if (0 <= newIndex - multiplicity) {
                        newIndex -= multiplicity;
                    }
                }
                else {
                    if (newIndex + multiplicity < dataSize) {
                        newIndex += multiplicity;
                    }
                }
            }
            if (newIndex === index) {
                return false;
            }
            const items = container.children;
            const itemIndex = items.indexOf(item);
            if (itemIndex < 0) {
                return false;
            }
            const newItemIndex = itemIndex + (newIndex - index);
            if (newItemIndex < 0 || items.length <= newItemIndex) {
                return false;
            }
            const newItem = items[newItemIndex];
            focusController.focus(newItem);
            return true;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DListItemUpdater extends DItemUpdater {
        toMapped(data) {
            return data.mapped;
        }
        newItem(data) {
            return new DListItem(data);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogSelectListItemUpdater extends DListItemUpdater {
        newItem(data) {
            return new DDialogSelectListItem(data);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DListDataMappedImpl {
        constructor(parent) {
            this._parent = parent;
        }
        size() {
            const parent = this._parent;
            return parent.before.length + parent.items.length + parent.after.length;
        }
        each(iteratee, from, to) {
            const parent = this._parent;
            const index0 = this.each_(iteratee, parent.before, 0, from, to);
            if (index0 < 0) {
                return;
            }
            const index1 = this.each_(iteratee, parent.items, index0, from, to);
            if (index1 < 0) {
                return;
            }
            this.each_(iteratee, parent.after, index1, from, to);
        }
        each_(iteratee, items, start, from, to) {
            const end = start + items.length;
            const ifrom = from != null ? Math.max(start, from) : start;
            const ito = to != null ? Math.min(end, to) : end;
            for (let i = ifrom; i < ito; ++i) {
                if (iteratee(items[i - start], i) === false) {
                    return -1;
                }
            }
            return ito;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DListDataSelectionMultiple extends pixi_js.utils.EventEmitter {
        constructor(parent, accessor, options) {
            super();
            this._parent = parent;
            this._accessor = accessor;
            this._items = new Set();
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        get type() {
            return DListDataSelectionType.MULTIPLE;
        }
        get first() {
            return this.get(0);
        }
        get last() {
            return this.get(this.size() - 1);
        }
        get(index) {
            const items = this._items;
            if (0 <= index && index < items.size) {
                let counter = 0;
                let result = null;
                items.forEach((item) => {
                    if (counter === index) {
                        result = item;
                    }
                    counter += 1;
                });
                return result;
            }
            return null;
        }
        add(target) {
            const items = this._items;
            if (!items.has(target)) {
                items.add(target);
                this.onChange();
                return true;
            }
            return false;
        }
        remove(target) {
            const items = this._items;
            if (items.has(target)) {
                items.delete(target);
                this.onChange();
                return true;
            }
            return false;
        }
        toggle(target) {
            const items = this._items;
            if (items.has(target)) {
                items.delete(target);
            }
            else {
                items.add(target);
            }
            this.onChange();
            return true;
        }
        clear() {
            const items = this._items;
            if (0 < items.size) {
                items.clear();
                this.onChange();
            }
        }
        clearAndAdd(target) {
            const items = this._items;
            const size = items.size;
            if (size === 1) {
                if (items.has(target)) {
                    return false;
                }
                else {
                    items.clear();
                    items.add(target);
                    this.onChange();
                    return true;
                }
            }
            else {
                items.clear();
                items.add(target);
                this.onChange();
                return true;
            }
        }
        clearAndAddAll(targets) {
            let isDirty = false;
            const newNodes = new Set();
            const oldNodes = this._items;
            for (let i = 0, imax = targets.length; i < imax; ++i) {
                const target = targets[i];
                if (!oldNodes.has(target)) {
                    isDirty = true;
                }
                newNodes.add(target);
            }
            if (!isDirty) {
                oldNodes.forEach((oldItem) => {
                    if (!newNodes.has(oldItem)) {
                        isDirty = true;
                    }
                });
            }
            if (isDirty) {
                this._items = newNodes;
                this.onChange();
            }
            return isDirty;
        }
        contains(target) {
            return this._items.has(target);
        }
        size() {
            return this._items.size;
        }
        isEmpty() {
            return this.size() <= 0;
        }
        each(iteratee) {
            let isCanceled = false;
            this._items.forEach((item) => {
                if (!isCanceled) {
                    if (iteratee(item) === false) {
                        isCanceled = true;
                    }
                }
            });
        }
        toArray() {
            const result = [];
            this._items.forEach((item) => {
                result.push(item);
            });
            return result;
        }
        onChange() {
            this._parent.update();
            this.emit("change", this);
        }
        toItemIdMap(items, toId, result) {
            for (let i = 0, imax = items.length; i < imax; ++i) {
                const item = items[i];
                result.set(toId(item), item);
            }
        }
        toItemSet(items, result) {
            for (let i = 0, imax = items.length; i < imax; ++i) {
                result.add(items[i]);
            }
        }
        onItemChange(before, items, after) {
            const oldItems = this._items;
            const newItems = new Set();
            const toId = this._accessor.toId;
            if (toId) {
                const newItemIdMap = new Map();
                this.toItemIdMap(before, toId, newItemIdMap);
                this.toItemIdMap(items, toId, newItemIdMap);
                this.toItemIdMap(after, toId, newItemIdMap);
                oldItems.forEach((oldItem) => {
                    const oldItemId = toId(oldItem);
                    const newItem = newItemIdMap.get(oldItemId);
                    if (newItem != null) {
                        newItems.add(newItem);
                    }
                });
                this._items = newItems;
                this.onChange();
            }
            else {
                const newItemSet = new Set();
                this.toItemSet(before, newItemSet);
                this.toItemSet(items, newItemSet);
                this.toItemSet(after, newItemSet);
                oldItems.forEach((oldItem) => {
                    if (newItemSet.has(oldItem)) {
                        newItems.add(oldItem);
                    }
                });
                if (oldItems.size !== newItems.size) {
                    this._items = newItems;
                    this.onChange();
                }
            }
        }
        newItems(items, existing, result) {
            for (let i = 0, imax = items.length; i < imax; ++i) {
                const item = items[i];
                if (existing.has(item)) {
                    result.add(item);
                }
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DListDataSelectionNone extends pixi_js.utils.EventEmitter {
        constructor(parent, accessor, options) {
            super();
            this._parent = parent;
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        get type() {
            return DListDataSelectionType.NONE;
        }
        get first() {
            return null;
        }
        get last() {
            return null;
        }
        get(index) {
            return null;
        }
        add(target) {
            return false;
        }
        remove(target) {
            return false;
        }
        toggle(target) {
            return false;
        }
        clear() {
            // DO NOTHING
        }
        clearAndAdd(target) {
            return false;
        }
        clearAndAddAll(targets) {
            return false;
        }
        contains(target) {
            return false;
        }
        size() {
            return 0;
        }
        isEmpty() {
            return true;
        }
        each(iteratee) {
            // DO NOTHING
        }
        toArray() {
            return [];
        }
        onChange() {
            this._parent.update();
            this.emit("change", this);
        }
        onItemChange(before, items, after) {
            // DO NOTHING
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DListDataSelectionSingle extends pixi_js.utils.EventEmitter {
        constructor(parent, accessor, options) {
            super();
            this._parent = parent;
            this._accessor = accessor;
            this._item = null;
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        get type() {
            return DListDataSelectionType.SINGLE;
        }
        get first() {
            return this._item;
        }
        get last() {
            return this.get(this.size() - 1);
        }
        get(index) {
            if (0 === index) {
                return this._item;
            }
            return null;
        }
        add(target) {
            if (this._item !== target) {
                this._item = target;
                this.onChange();
                return true;
            }
            return false;
        }
        remove(target) {
            if (this._item === target) {
                this._item = null;
                this.onChange();
                return true;
            }
            return false;
        }
        toggle(target) {
            if (this._item === target) {
                this._item = null;
            }
            else {
                this._item = target;
            }
            this.onChange();
            return true;
        }
        clear() {
            if (this._item != null) {
                this._item = null;
                this.onChange();
            }
        }
        clearAndAdd(target) {
            if (this._item !== target) {
                this._item = target;
                this.onChange();
                return true;
            }
            return false;
        }
        clearAndAddAll(targets) {
            const targetsLength = targets.length;
            if (0 < targetsLength) {
                const last = targets[targetsLength - 1];
                if (this._item !== last) {
                    this._item = last;
                    this.onChange();
                    return true;
                }
            }
            else {
                if (this._item != null) {
                    this._item = null;
                    this.onChange();
                    return true;
                }
            }
            return false;
        }
        contains(target) {
            return this._item === target;
        }
        size() {
            return this._item != null ? 1 : 0;
        }
        isEmpty() {
            return this.size() <= 0;
        }
        each(iteratee) {
            const item = this._item;
            if (item != null) {
                iteratee(item);
            }
        }
        toArray() {
            const item = this._item;
            if (item != null) {
                return [item];
            }
            return [];
        }
        onChange() {
            this._parent.update();
            this.emit("change", this);
        }
        findById(id, toId, items) {
            for (let i = 0, imax = items.length; i < imax; ++i) {
                const item = items[i];
                const itemId = toId(item);
                if (id === itemId) {
                    return item;
                }
            }
            return null;
        }
        find(target, items) {
            for (let i = 0, imax = items.length; i < imax; ++i) {
                const item = items[i];
                if (target === item) {
                    return item;
                }
            }
            return null;
        }
        onItemChange(before, items, after) {
            const oldItem = this._item;
            if (oldItem == null) {
                return;
            }
            let newItem = null;
            const toId = this._accessor.toId;
            if (toId) {
                const oldItemId = toId(oldItem);
                newItem =
                    this.findById(oldItemId, toId, before) ||
                        this.findById(oldItemId, toId, items) ||
                        this.findById(oldItemId, toId, after);
            }
            else {
                newItem =
                    this.find(oldItem, before) ||
                        this.find(oldItem, items) ||
                        this.find(oldItem, after);
            }
            if (oldItem !== newItem) {
                this._item = newItem;
                this.onChange();
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toImage$1 = (value) => {
        return value.image;
    };
    const toTitle$1 = (value) => {
        return value.title;
    };
    const toLinkUrl = (value) => {
        return value.url;
    };
    class DListItemAccessorImpl {
        constructor(options) {
            this.toLabel = (options === null || options === void 0 ? void 0 : options.toLabel) || toLabel$1;
            this.toTitle = (options === null || options === void 0 ? void 0 : options.toTitle) || toTitle$1;
            this.toImage = (options === null || options === void 0 ? void 0 : options.toImage) || toImage$1;
            this.toId = options === null || options === void 0 ? void 0 : options.toId;
            this.link = this.toLink(options);
        }
        toLink(options) {
            if (options) {
                const link = options.link;
                if (link) {
                    const toUrl = link.toUrl;
                    const target = link.target;
                    const checker = link.checker;
                    if (toUrl !== undefined || target !== undefined || checker !== undefined) {
                        return {
                            toUrl: toUrl || toLinkUrl,
                            target,
                            checker
                        };
                    }
                }
            }
            return undefined;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DListDataImpl {
        constructor(parent, options) {
            this._parent = parent;
            if (options) {
                this._before = options.before || [];
                this._items = options.items || [];
                this._after = options.after || [];
            }
            else {
                this._before = [];
                this._items = [];
                this._after = [];
            }
            const accessor = new DListItemAccessorImpl(options);
            this._accessor = accessor;
            this._selection = this.toSelection(accessor, options);
            this._mapped = new DListDataMappedImpl(this);
        }
        toSelection(accessor, options) {
            const selection = options === null || options === void 0 ? void 0 : options.selection;
            switch (selection === null || selection === void 0 ? void 0 : selection.type) {
                case DListDataSelectionType.NONE:
                case "NONE":
                    return new DListDataSelectionNone(this, accessor, selection);
                case DListDataSelectionType.MULTIPLE:
                case "MULTIPLE":
                    return new DListDataSelectionMultiple(this, accessor, selection);
                default:
                    return new DListDataSelectionSingle(this, accessor, selection);
            }
        }
        get before() {
            return this._before;
        }
        set before(before) {
            this._before = before;
            this._selection.onItemChange(before, this._items, this._after);
            this.update();
        }
        get items() {
            return this._items;
        }
        set items(items) {
            this._items = items;
            this._selection.onItemChange(this._before, items, this._after);
            this.update();
        }
        get after() {
            return this._after;
        }
        set after(after) {
            this._after = after;
            this._selection.onItemChange(this._before, this._items, after);
            this.update();
        }
        get mapped() {
            return this._mapped;
        }
        get accessor() {
            return this._accessor;
        }
        get selection() {
            return this._selection;
        }
        update(forcibly) {
            this._parent.update(forcibly);
        }
        size() {
            return this._items.length;
        }
        clear() {
            const items = this._items;
            if (0 < items.length) {
                items.length = 0;
                this.onChange();
                return true;
            }
            return false;
        }
        clearAndAdd(item) {
            const items = this._items;
            if (items.length === 1) {
                const first = items[0];
                if (first === item) {
                    return false;
                }
                else {
                    items[0] = item;
                    this.onChange();
                    return true;
                }
            }
            else {
                items.length = 0;
                items.push(item);
                this.onChange();
                return true;
            }
        }
        clearAndAddAll(newItems) {
            let isChanged = false;
            const items = this._items;
            if (0 < items.length) {
                items.length = 0;
                isChanged = true;
            }
            if (0 < newItems.length) {
                for (let i = 0, imax = newItems.length; i < imax; ++i) {
                    items.push(newItems[i]);
                }
                isChanged = true;
            }
            if (isChanged) {
                this.onChange();
                return true;
            }
            return false;
        }
        add(item, index) {
            const items = this._items;
            if (index == null) {
                items.push(item);
                this.onChange();
                return true;
            }
            else if (0 <= index && index < items.length) {
                items.splice(index, 0, item);
                this.onChange();
                return true;
            }
            return false;
        }
        addAll(newItems, index) {
            if (0 < newItems.length) {
                const items = this._items;
                const itemsLength = items.length;
                if (index == null) {
                    for (let i = 0, imax = newItems.length; i < imax; ++i) {
                        items.push(newItems[i]);
                    }
                    this.onChange();
                    return true;
                }
                else if (0 <= index && index < itemsLength) {
                    for (let i = 0, imax = newItems.length; i < imax; ++i) {
                        items.splice(index + i, 0, newItems[i]);
                    }
                    this.onChange();
                    return true;
                }
            }
            return false;
        }
        get(index) {
            const items = this._items;
            if (0 <= index && index < items.length) {
                return items[index];
            }
            return null;
        }
        set(index, item) {
            const items = this._items;
            if (0 <= index && index < items.length) {
                const result = items[index];
                items[index] = item;
                this.onChange();
                return result;
            }
            return null;
        }
        remove(index) {
            const items = this._items;
            if (0 <= index && index < items.length) {
                const result = items.splice(index, 1)[0];
                this.onChange();
                return result;
            }
            return null;
        }
        each(iteratee, from, to) {
            const items = this._items;
            const size = items.length;
            const ifrom = from != null ? Math.max(0, from) : 0;
            const ito = to != null ? Math.min(size, to) : size;
            for (let i = ifrom; i < ito; ++i) {
                if (iteratee(items[i], i) === false) {
                    break;
                }
            }
        }
        onChange() {
            this.update();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DContent extends DBase {
        initReflowable() {
            // DO NOTHING
        }
        getType() {
            return "DContent";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DScrollBar extends DBase {
        constructor(options) {
            var _a, _b;
            super(options);
            this._start = 0;
            this._end = 1;
            this.visible = false;
            this._touchedAt = -1;
            this._isTouched = false;
            this._fadeOutTimeoutId = null;
            this._fadeOutDelay = (_b = (_a = options === null || options === void 0 ? void 0 : options.fadeOut) === null || _a === void 0 ? void 0 : _a.delay) !== null && _b !== void 0 ? _b : this.theme.getFadeOutDelay();
            this._isSilent = true;
            this._onFadeOutTimeoutBound = () => {
                this.onFadeOutTimeout();
            };
            const thumb = this.newThumb(options === null || options === void 0 ? void 0 : options.thumb);
            thumb.on("statechange", (newState, oldState) => {
                this.onThumbStateChange(newState, oldState);
            });
            this._thumb = thumb;
            this.addChild(thumb);
        }
        get thumb() {
            return this._thumb;
        }
        get start() {
            return this._start;
        }
        get end() {
            return this._end;
        }
        set(start, end, size, silently) {
            if (size < 1) {
                start = 0;
                end = 1;
            }
            else {
                start = Math.max(0, Math.min(1, start / size));
                end = Math.max(start, Math.min(1, end / size));
            }
            if (this._start !== start || this._end !== end) {
                this._start = start;
                this._end = end;
                this.onChange(silently);
            }
        }
        onChange(silently) {
            this.updateThumb(this.width, this.height);
            if (silently) {
                this._isSilent = true;
            }
            if (!this._isTouched) {
                this._isTouched = true;
                DApplications.update(this);
            }
        }
        touch(silently) {
            this.onChange(silently);
        }
        isRegionVisible() {
            return 0 < this._start || this._end < 1;
        }
        render(renderer) {
            if (this._isTouched) {
                this._isTouched = false;
                if (!this._isSilent && this.isRegionVisible()) {
                    const fadeOutDelay = this._fadeOutDelay;
                    if (0 <= fadeOutDelay) {
                        this._touchedAt = Date.now();
                        if (this._fadeOutTimeoutId == null) {
                            this._fadeOutTimeoutId = window.setTimeout(this._onFadeOutTimeoutBound, fadeOutDelay);
                        }
                    }
                    if (!this.visible) {
                        this.visible = true;
                        this.updateTransform();
                    }
                }
                else {
                    if (this._fadeOutDelay < 0 && this.visible) {
                        this.visible = false;
                    }
                }
            }
            if (this._isSilent) {
                this._isSilent = false;
            }
            super.render(renderer);
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
            this.updateThumb(newWidth, newHeight);
        }
        onFadeOutTimeout() {
            this._fadeOutTimeoutId = null;
            const fadeOutDelay = this._fadeOutDelay;
            const onTouchTimeoutBound = this._onFadeOutTimeoutBound;
            const state = this.state;
            if (state.isGesturing || state.onHovered || state.isHovered || state.isPressed) {
                this._fadeOutTimeoutId = window.setTimeout(onTouchTimeoutBound, fadeOutDelay);
                return;
            }
            const thumbState = this._thumb.state;
            if (thumbState.isGesturing || thumbState.isHovered || thumbState.isPressed) {
                this._fadeOutTimeoutId = window.setTimeout(onTouchTimeoutBound, fadeOutDelay);
                return;
            }
            const now = Date.now();
            const remainingTime = fadeOutDelay - (now - this._touchedAt);
            if (0 < remainingTime) {
                this._fadeOutTimeoutId = window.setTimeout(onTouchTimeoutBound, remainingTime);
                return;
            }
            if (this.visible) {
                this.visible = false;
                DApplications.update(this);
            }
        }
        onThumbStateChange(newState, oldState) {
            if (!newState.isGesturing && !newState.isHovered && !newState.isPressed) {
                if (oldState.isGesturing || oldState.isHovered || oldState.isPressed) {
                    this._touchedAt = Date.now();
                }
            }
        }
        onStateChange(newState, oldState) {
            super.onStateChange(newState, oldState);
            if (!newState.isGesturing && !newState.isHovered && !newState.isPressed) {
                if (oldState.isGesturing || oldState.isHovered || oldState.isPressed) {
                    this._touchedAt = Date.now();
                }
            }
        }
        getType() {
            return "DScrollBar";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DScrollBarThumb extends DBase {
        init(options) {
            super.init(options);
            const position = new pixi_js.Point();
            this._gestureUtil = new UtilGesture({
                bind: this,
                on: {
                    start: () => {
                        position.copyFrom(this.position);
                    },
                    move: (target, dx, dy) => {
                        position.set(position.x + dx, position.y + dy);
                        this.onGestureMove(position.x, position.y);
                    }
                }
            });
        }
        getMinimumLength() {
            return this.theme.getThumbMinimumLength();
        }
        getType() {
            return "DScrollBarThumb";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DScrollBarThumbReflowableHorizontal extends pixi_js.Graphics {
        constructor(base) {
            super();
            base.snippet.add(this, true);
            base.reflowable.add(this);
        }
        onReflow(base, width, height) {
            this.clear();
            const state = base.state;
            const border = base.border;
            const borderColor = border.getColor(state);
            if (borderColor != null) {
                const borderAlpha = border.getAlpha(state);
                const borderWidth = border.getWidth(state);
                const borderAlign = border.getAlign(state);
                this.beginFill(borderColor, borderAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(0, borderAlign * (height - borderWidth), width, borderWidth);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DScrollBarThumbHorizontal extends DScrollBarThumb {
        onGestureMove(dx, dy) {
            this.emit("regionmove", dx, this);
        }
        initReflowable() {
            new DScrollBarThumbReflowableHorizontal(this);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DScrollBarHorizontal extends DScrollBar {
        constructor(options) {
            super(options);
            this._thumb.on("regionmove", (x) => {
                this.onThumbRegionMove(x);
            });
        }
        onThumbRegionMove(x) {
            const width = this.width;
            if (0 < width) {
                const size = this._end - this._start;
                const newStart = Math.min(1 - size, Math.max(0, x / width));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        }
        onDownThis(e) {
            super.onDownThis(e);
            const width = this.width;
            if (0 < width) {
                const size = this._end - this._start;
                const position = e.data.getLocalPosition(this);
                const newStart = Math.min(1 - size, Math.max(0, position.x / width - size * 0.5));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        }
        newThumb(options) {
            return new DScrollBarThumbHorizontal(options);
        }
        updateThumb(width, height) {
            const thumb = this._thumb;
            const thumbMinimumLength = Math.min(width * 0.5, thumb.getMinimumLength());
            const space = width - thumbMinimumLength;
            const barStart = space * this._start;
            const barLength = space * this._end + thumbMinimumLength - barStart;
            thumb.position.set(barStart, 0);
            thumb.resize(barLength, height);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DScrollBarThumbReflowableVertical extends pixi_js.Graphics {
        constructor(base) {
            super();
            base.snippet.add(this, true);
            base.reflowable.add(this);
        }
        onReflow(base, width, height) {
            this.clear();
            const state = base.state;
            const border = base.border;
            const borderColor = border.getColor(state);
            if (borderColor != null) {
                const borderAlpha = border.getAlpha(state);
                const borderWidth = border.getWidth(state);
                const borderAlign = border.getAlign(state);
                this.beginFill(borderColor, borderAlpha);
                this.lineStyle(0, 0, 0, 0);
                this.drawRect(borderAlign * (width - borderWidth), 0, borderWidth, height);
                this.endFill();
                this.visible = true;
            }
            else {
                this.visible = false;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DScrollBarThumbVertical extends DScrollBarThumb {
        onGestureMove(dx, dy) {
            this.emit("regionmove", dy, this);
        }
        initReflowable() {
            new DScrollBarThumbReflowableVertical(this);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DScrollBarVertical extends DScrollBar {
        constructor(options) {
            super(options);
            this._thumb.on("regionmove", (y) => {
                this.onThumbRegionMove(y);
            });
        }
        onThumbRegionMove(y) {
            const height = this.height;
            if (0 < height) {
                const size = this._end - this._start;
                const newStart = Math.min(1 - size, Math.max(0, y / height));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        }
        onDownThis(e) {
            super.onDownThis(e);
            const height = this.height;
            if (0 < height) {
                const size = this._end - this._start;
                const position = e.data.getLocalPosition(this);
                const newStart = Math.min(1 - size, Math.max(0, position.y / height - size * 0.5));
                if (this._start !== newStart) {
                    this.emit("regionmove", newStart, this);
                }
            }
        }
        newThumb(options) {
            return new DScrollBarThumbVertical(options);
        }
        updateThumb(width, height) {
            const thumb = this._thumb;
            const thumbMinimumLength = Math.min(height * 0.5, thumb.getMinimumLength());
            const space = height - thumbMinimumLength;
            const barStart = space * this._start;
            const barLength = space * this._end + thumbMinimumLength - barStart;
            thumb.position.set(0, barStart);
            thumb.resize(width, barLength);
            thumb.updateTransform();
        }
    }

    class DPaneScrollBar {
        constructor(parent, options, onUpdate) {
            this._parent = parent;
            this._onUpdate = onUpdate;
            this._isLocked = 0;
            this._isCalled = false;
            this.vertical = new DScrollBarVertical(options === null || options === void 0 ? void 0 : options.vertical);
            this.horizontal = new DScrollBarHorizontal(options === null || options === void 0 ? void 0 : options.horizontal);
        }
        lock() {
            this._isLocked += 1;
            if (this._isLocked === 1) {
                this._isCalled = false;
                this._isCalledSilently = undefined;
            }
        }
        unlock(callIfNeeded) {
            this._isLocked -= 1;
            if (this._isLocked === 0) {
                if (callIfNeeded && this._isCalled) {
                    this.update(this._isCalledSilently);
                }
                this._isCalled = false;
                this._isCalledSilently = undefined;
            }
        }
        update(silently) {
            if (0 < this._isLocked) {
                this._isCalled = true;
                if (silently != null) {
                    this._isCalledSilently || (this._isCalledSilently = silently);
                }
                return;
            }
            const parent = this._parent;
            const width = parent.width;
            const height = parent.height;
            const content = parent.content;
            const x = -content.x;
            const y = -content.y;
            const vertical = this.vertical;
            const verticalWidth = vertical.width;
            const verticalOffsetStart = this.getOffsetVerticalStart(verticalWidth);
            const verticalOffsetEnd = this.getOffsetVerticalEnd(verticalWidth);
            vertical.set(y, y + height, content.height, silently);
            vertical.position.set(width - verticalWidth, verticalOffsetStart);
            vertical.height = height - verticalOffsetStart - verticalOffsetEnd;
            const horizontal = this.horizontal;
            const horizontalHeight = horizontal.height;
            const horizontalOffsetStart = this.getOffsetHorizontalStart(horizontalHeight);
            const horizontalOffsetEnd = this.getOffsetHorizontalEnd(horizontalHeight);
            horizontal.set(x, x + width, content.width, silently);
            horizontal.position.set(horizontalOffsetStart, height - horizontalHeight);
            horizontal.width = width - horizontalOffsetStart - horizontalOffsetEnd;
            this._onUpdate(vertical.isRegionVisible() || horizontal.isRegionVisible());
        }
        touch(silently) {
            this.vertical.touch(silently);
            this.horizontal.touch(silently);
        }
        getOffsetHorizontalStart(size) {
            return size * 0.5;
        }
        getOffsetHorizontalEnd(size) {
            return size * 0.5;
        }
        getOffsetVerticalStart(size) {
            return size * 0.5;
        }
        getOffsetVerticalEnd(size) {
            return size * 0.5;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    // Class
    class DPane extends DBase {
        constructor(options) {
            var _a;
            super(options);
            // Mask
            const theme = this.theme;
            if ((_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : theme.isOverflowMaskEnabled()) {
                this.mask = this.getOverflowMask();
            }
            // Content
            this.addChild(this.content);
            // Scroll bar
            const scrollbar = this.scrollbar;
            this.addChild(scrollbar.vertical);
            this.addChild(scrollbar.horizontal);
            scrollbar.update();
            // Gesture
            this.initGesture(theme, options);
        }
        initGesture(theme, options) {
            var _a, _b;
            // Edge does not fire the wheel event when scrolling using the 2-fingure scroll gesture on a touchpad.
            // Instead, it fires touch events. This is why the gesture is enabled regardless of the `UtilPointerEvent.touchable`.
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7134034/
            const mode = toEnum((_b = (_a = options === null || options === void 0 ? void 0 : options.gesture) === null || _a === void 0 ? void 0 : _a.mode) !== null && _b !== void 0 ? _b : theme.getGestureMode(), UtilGestureMode);
            if (mode === UtilGestureMode.ON || mode === UtilGestureMode.TOUCH) {
                const position = new pixi_js.Point();
                const content = this.content;
                this._gestureUtil = new UtilGesture({
                    bind: this,
                    touch: mode === UtilGestureMode.TOUCH,
                    on: {
                        start: () => {
                            position.copyFrom(content.position);
                        },
                        move: (target, dx, dy) => {
                            position.set(position.x + dx, position.y + dy);
                            content.position.set(this.toContentX(content, position.x), this.toContentY(content, position.y));
                        }
                    }
                });
            }
        }
        get scrollbar() {
            var _a;
            let result = this._scrollbar;
            if (result == null) {
                result = this.newScrollBar((_a = this._options) === null || _a === void 0 ? void 0 : _a.scrollbar);
                this.initScrollBar(result);
                this._scrollbar = result;
            }
            return result;
        }
        newScrollBar(options) {
            return new DPaneScrollBar(this, options, (isRegionVisible) => {
                this.onScrollBarUpdate(isRegionVisible);
            });
        }
        onScrollBarUpdate(isRegionVisible) {
            // DO NOTHING
        }
        initScrollBar(scrollbar) {
            scrollbar.vertical.on("regionmove", (start) => {
                this.onScrollBarMoveY(start);
            });
            scrollbar.horizontal.on("regionmove", (start) => {
                this.onScrollBarMoveX(start);
            });
        }
        onScrollBarMoveX(start) {
            const gestureUtil = this._gestureUtil;
            if (gestureUtil != null) {
                gestureUtil.stop(this);
            }
            const content = this.content;
            content.x = -content.width * start;
        }
        onScrollBarMoveY(start) {
            const gestureUtil = this._gestureUtil;
            if (gestureUtil != null) {
                gestureUtil.stop(this);
            }
            const content = this.content;
            content.y = -content.height * start;
        }
        onOver(e) {
            super.onOver(e);
            this.scrollbar.touch();
        }
        getType() {
            return "DPane";
        }
        get content() {
            let result = this._content;
            if (result == null) {
                result = this.toContent(this._options);
                this.initContent(result);
                this._content = result;
            }
            return result;
        }
        toContent(options) {
            const content = options === null || options === void 0 ? void 0 : options.content;
            if (content) {
                if (content instanceof DBase) {
                    return content;
                }
                else {
                    return this.newContent(content);
                }
            }
            return this.newContent();
        }
        newContent(options) {
            return new DContent(options);
        }
        initContent(content) {
            content.on("move", () => {
                this.onContentChange();
            });
            content.on("resize", () => {
                this.onContentChange();
            });
        }
        getOverflowMask() {
            let result = this._overflowMask;
            if (result === undefined) {
                result = this.newOverflowMask();
                this._overflowMask = result;
            }
            return result;
        }
        newOverflowMask() {
            const result = new DBaseOverflowMask(this);
            this.reflowable.add(result);
            this.toDirty();
            return result;
        }
        onWheel(e, deltas, global) {
            const content = this.content;
            const x = this.getWheelContentX(content, deltas.deltaX * deltas.lowest);
            const y = this.getWheelContentY(content, deltas.deltaY * deltas.lowest);
            if (content.x !== x || content.y !== y) {
                const gestureUtil = this._gestureUtil;
                if (gestureUtil != null) {
                    gestureUtil.stop(this);
                }
                content.position.set(x, y);
                return true;
            }
            return false;
        }
        getWheelContentX(content, delta) {
            if (0 < delta || delta < 0) {
                const speed = this.theme.getWheelSpeed();
                return this.toContentX(content, content.x - delta * speed);
            }
            return content.x;
        }
        getWheelContentY(content, delta) {
            if (0 < delta || delta < 0) {
                const speed = this.theme.getWheelSpeed();
                return this.toContentY(content, content.y + delta * speed);
            }
            return content.y;
        }
        toContentX(content, x) {
            return Math.min(0, Math.max(this.width - content.width, x));
        }
        toContentY(content, y) {
            return Math.min(0, Math.max(this.height - content.height, y));
        }
        isRefitable(target) {
            return super.isRefitable(target) && !(target instanceof DScrollBar);
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            const scrollbar = this.scrollbar;
            scrollbar.lock();
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
            scrollbar.update();
            scrollbar.unlock(true);
        }
        onContentChange() {
            this.scrollbar.update();
        }
        getFocusedChildClippingRect(focused, contentX, contentY, contentWidth, contentHeight, width, height, result) {
            result.x = 0;
            result.y = 0;
            result.width = width;
            result.height = height;
            return result;
        }
        onChildFocus(focused) {
            const point = DPane.WORK_POINT || new pixi_js.Point();
            DPane.WORK_POINT = point;
            // Content rectangle
            const content = this.content;
            const contentX = content.x;
            const contentY = content.y;
            const contentWidth = content.width;
            const contentHeight = content.height;
            point.set(0, 0);
            focused.toGlobal(point, point, false);
            content.toLocal(point, undefined, point, false);
            const x0 = contentX + Math.min(contentWidth, Math.max(0, point.x));
            const y0 = contentY + Math.min(contentHeight, Math.max(0, point.y));
            point.set(focused.width, focused.height);
            focused.toGlobal(point, point, true);
            content.toLocal(point, undefined, point, true);
            const x1 = contentX + Math.min(contentWidth, Math.max(0, point.x));
            const y1 = contentY + Math.min(contentHeight, Math.max(0, point.y));
            const width = this.width;
            const height = this.height;
            const clippingRect = DPane.WORK_RECTANGLE || new pixi_js.Rectangle();
            DPane.WORK_RECTANGLE = clippingRect;
            this.getFocusedChildClippingRect(focused, contentX, contentY, contentWidth, contentHeight, width, height, clippingRect);
            const clippingRectX = clippingRect.x;
            const clippingRectY = clippingRect.y;
            const clippingRectX0 = clippingRectX;
            const clippingRectY0 = clippingRectY;
            const clippingRectX1 = clippingRectX + clippingRect.width;
            const clippingRectY1 = clippingRectY + clippingRect.height;
            let newX = null;
            if (x0 < clippingRectX0) {
                if (x1 <= clippingRectX1) {
                    newX = contentX + Math.min(clippingRectX0 - x0, clippingRectX1 - x1);
                    newX = Math.max(width - contentWidth, Math.min(0, newX));
                }
            }
            else if (clippingRectX1 < x1) {
                newX = contentX - Math.min(x0 - clippingRectX0, x1 - clippingRectX1);
                newX = Math.max(width - contentWidth, Math.min(0, newX));
            }
            let newY = null;
            if (y0 < clippingRectY0) {
                if (y1 <= clippingRectY1) {
                    newY = contentY + Math.min(clippingRectY0 - y0, clippingRectY1 - y1);
                    newY = Math.max(height - contentHeight, Math.min(0, newY));
                }
            }
            else if (clippingRectY1 < y1) {
                newY = contentY - Math.min(y0 - clippingRectY0, y1 - clippingRectY1);
                newY = Math.max(height - contentHeight, Math.min(0, newY));
            }
            const contentPosition = content.position;
            if (newX != null) {
                if (newY != null) {
                    contentPosition.set(newX, newY);
                }
                else {
                    contentPosition.x = newX;
                }
            }
            else {
                if (newY != null) {
                    contentPosition.y = newY;
                }
            }
            super.onChildFocus(focused);
        }
        destroy() {
            // Overflow mask
            const overflowMask = this._overflowMask;
            if (overflowMask != null) {
                this._overflowMask = null;
                overflowMask.destroy();
            }
            this.mask = null;
            super.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DList extends DPane {
        constructor(options) {
            super(options);
            this.update();
        }
        get updater() {
            let result = this._updater;
            if (result == null) {
                result = this.newUpdater(this.data, this.content, this._options);
                this._updater = result;
            }
            return result;
        }
        newUpdater(data, content, options) {
            return new DListItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        }
        get data() {
            let result = this._data;
            if (result == null) {
                result = this.toData(this._options);
                this._data = result;
            }
            return result;
        }
        toData(options) {
            const data = options && (options.data || options.items);
            const selection = options === null || options === void 0 ? void 0 : options.selection;
            if (data == null) {
                if (selection) {
                    return new DListDataImpl(this, {
                        selection
                    });
                }
                else {
                    return new DListDataImpl(this);
                }
            }
            else if (isArray(data)) {
                if (selection) {
                    return new DListDataImpl(this, {
                        items: data,
                        selection
                    });
                }
                else {
                    return new DListDataImpl(this, {
                        items: data
                    });
                }
            }
            else if ("each" in data) {
                return data;
            }
            else {
                if (selection) {
                    if (data.selection === undefined) {
                        data.selection = selection;
                    }
                    return new DListDataImpl(this, data);
                }
                else {
                    return new DListDataImpl(this, data);
                }
            }
        }
        onContentChange() {
            super.onContentChange();
            this.update();
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            const updater = this.updater;
            updater.lock();
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
            updater.update();
            updater.unlock(true);
        }
        get selection() {
            return this.data.selection;
        }
        lock() {
            this.updater.lock();
        }
        unlock(callIfNeeded) {
            this.updater.unlock(callIfNeeded);
        }
        /**
         * Updates items. If the `forcibly` is true, some dirty checkings for
         * avoiding unnecessary state changes are skipped.
         *
         * @param forcibly true to update forcibly
         */
        update(forcibly) {
            this.updater.update(forcibly);
        }
        onKeyDown(e) {
            this.updater.moveFocus(e, this, true, true);
            return super.onKeyDown(e);
        }
        getType() {
            return "DList";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogSelectList extends DList {
        newUpdater(data, content, options) {
            return new DDialogSelectListItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        }
        getType() {
            return "DDialogSelectList";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogSelectSearhImpl extends pixi_js.utils.EventEmitter {
        constructor(search) {
            super();
            this._search =
                search !== null && search !== void 0 ? search : ((word, categoryId) => Promise.resolve([]));
            this._id = 0;
            this._idCompleted = 0;
        }
        create(args) {
            const id = ++this._id;
            const search = this._search;
            (args.length <= 1 ? search(args[0]) : search(args[0], args[1])).then((searchResult) => {
                if (this._id === id) {
                    this._idCompleted = id;
                    this.emit("success", this, searchResult);
                    this.emit("change", this);
                }
            }, () => {
                if (this._id === id) {
                    this._idCompleted = id;
                    this.emit("fail", this);
                    this.emit("change", this);
                }
            });
            this.emit("change", this);
        }
        isDone() {
            return this._id === this._idCompleted;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputSearch extends DInputText {
        getType() {
            return "DInputSearch";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DNote extends DImageBase {
        getType() {
            return "DNote";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DNoteSmall extends DNote {
        getType() {
            return "DNoteSmall";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DNoteSmallError extends DNoteSmall {
        getType() {
            return "DNoteSmallError";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DNoteSmallNoItemsFound extends DNoteSmall {
        getType() {
            return "DNoteSmallNoItemsFound";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DNoteSmallSearching extends DNoteSmall {
        getType() {
            return "DNoteSmallSearching";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogSelect extends DDialogLayered {
        constructor(options) {
            var _a, _b;
            super(options);
            // Value
            this._value = null;
            // Categories
            const categories = (_b = (_a = options === null || options === void 0 ? void 0 : options.category) === null || _a === void 0 ? void 0 : _a.items) !== null && _b !== void 0 ? _b : [];
            this._categories = categories;
            if (0 < categories.length) {
                this.onCategoriesChange(categories);
            }
            // Controller binding
            const transition = new UtilTransition();
            const search = this.search;
            search.on("success", (e, results) => {
                if (0 < results.length) {
                    transition.hide();
                }
                else {
                    transition.show(this.noteNoItemsFound);
                }
                this.onSearched(results);
            });
            search.on("fail", () => {
                transition.show(this.noteError);
                this.onSearched([]);
            });
            search.on("change", () => {
                if (!search.isDone()) {
                    const noteSearching = this.noteSearching;
                    if (noteSearching) {
                        transition.show(noteSearching);
                    }
                }
            });
        }
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.inputLayout, this.list, this.buttonDismiss);
            return result;
        }
        get inputLayout() {
            var _a;
            return ((_a = this._inputLayout) !== null && _a !== void 0 ? _a : (this._inputLayout = this.newInputLayout()));
        }
        newInputLayout() {
            return new DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [this.selectCategory, this.input]
            });
        }
        newSpace() {
            return new DLayoutSpace({
                width: this.toInputMargin(this.theme, this._options)
            });
        }
        get selectCategory() {
            var _a;
            return ((_a = this._selectCategory) !== null && _a !== void 0 ? _a : (this._selectCategory = this.newSelectCategory()));
        }
        newSelectCategory() {
            const result = new DSelect(this.toSelectCategoryOptions(this.theme, this._options));
            result.on("change", (value) => {
                this.onSelectCategoryChange(value);
            });
            return result;
        }
        toSelectCategoryOptions(theme, options) {
            const result = (options === null || options === void 0 ? void 0 : options.category) || {};
            if (result.width === undefined && result.weight === undefined) {
                result.width = 140;
            }
            if (result.visible === undefined) {
                result.visible = false;
            }
            return result;
        }
        onSelectCategoryChange(categoryId) {
            this.search.create([this.input.value, categoryId]);
        }
        get input() {
            var _a;
            return ((_a = this._input) !== null && _a !== void 0 ? _a : (this._input = this.newInput()));
        }
        newInput() {
            const result = new DInputSearch(this.toInputOptions(this.theme, this._options));
            result.on("input", (value) => {
                this.onInputInput(value);
            });
            return result;
        }
        toInputOptions(theme, options) {
            const result = (options === null || options === void 0 ? void 0 : options.input) || {};
            if (result.width === undefined && result.weight === undefined) {
                result.weight = 1;
            }
            return result;
        }
        toInputMargin(theme, options) {
            var _a, _b;
            return (_b = (_a = options === null || options === void 0 ? void 0 : options.input) === null || _a === void 0 ? void 0 : _a.margin) !== null && _b !== void 0 ? _b : theme.getInputMargin();
        }
        onInputInput(value) {
            if (0 < this._categories.length) {
                this.search.create([value, this.selectCategory.value]);
            }
            else {
                this.search.create([value]);
            }
        }
        get list() {
            var _a;
            return ((_a = this._list) !== null && _a !== void 0 ? _a : (this._list = this.newList()));
        }
        newList() {
            const result = new DDialogSelectList(this.toListOptions(this.theme, this._options));
            result.selection.on("change", (selection) => {
                this.onListSelectionChange(selection);
            });
            return result;
        }
        onListSelectionChange(selection) {
            const selected = selection.first;
            if (selected == null) {
                return;
            }
            this._value = selected;
            this.onOk(selected);
        }
        toListOptions(theme, options) {
            const result = (options === null || options === void 0 ? void 0 : options.list) || {};
            if (result.width === undefined) {
                result.width = "padding";
            }
            return result;
        }
        get noteError() {
            var _a;
            return ((_a = this._noteError) !== null && _a !== void 0 ? _a : (this._noteError = this.newNoteError()));
        }
        newNoteError() {
            var _a, _b;
            const error = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.note) === null || _b === void 0 ? void 0 : _b.error;
            if (error !== null) {
                return new DNoteSmallError(this.toNoteOptions(this.list, error));
            }
            return null;
        }
        get noteNoItemsFound() {
            var _a;
            return ((_a = this._noteNoItemsFound) !== null && _a !== void 0 ? _a : (this._noteNoItemsFound = this.newNoteNoItemsFound()));
        }
        newNoteNoItemsFound() {
            var _a, _b;
            const noItemsFound = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.note) === null || _b === void 0 ? void 0 : _b.noItemsFound;
            if (noItemsFound !== null) {
                return new DNoteSmallNoItemsFound(this.toNoteOptions(this.list, noItemsFound));
            }
            return null;
        }
        get noteSearching() {
            var _a;
            return ((_a = this._noteSearching) !== null && _a !== void 0 ? _a : (this._noteSearching = this.newNoteSearching()));
        }
        newNoteSearching() {
            var _a, _b;
            const searching = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.note) === null || _b === void 0 ? void 0 : _b.searching;
            // Because the `searching` note is disabled by default,
            // if options.searching is missing, i.e., if its value is undefined,
            // this method returns null. This is why `!=` is used here instead of `!==`.
            if (searching != null) {
                return new DNoteSmallSearching(this.toNoteOptions(this.list, searching));
            }
            return null;
        }
        toNoteOptions(parent, options) {
            if (options != null) {
                if (options.parent == null) {
                    options.parent = parent;
                }
                if (options.visible == null) {
                    options.visible = false;
                }
                return options;
            }
            return {
                parent,
                visible: false
            };
        }
        get search() {
            var _a;
            return ((_a = this._search) !== null && _a !== void 0 ? _a : (this._search = this.newSearch()));
        }
        newSearch() {
            const options = this._options;
            if (options) {
                const controller = options.controller;
                if (controller) {
                    const search = controller.search;
                    if ("create" in search) {
                        return search;
                    }
                    else {
                        return new DDialogSelectSearhImpl(search);
                    }
                }
            }
            return new DDialogSelectSearhImpl();
        }
        get buttonDismiss() {
            let result = this._buttonDismiss;
            if (result === undefined) {
                result = this.newButtonDismiss();
                this._buttonDismiss = result;
            }
            return result;
        }
        newButtonDismiss() {
            const options = this.toButtonDismissOptions(this._options);
            if (options.enabled === true) {
                const result = new DButton(options);
                result.on("active", () => {
                    this._value = null;
                    this.onOk(null);
                });
                return result;
            }
            return null;
        }
        toButtonDismissOptions(options) {
            const theme = this.theme;
            if (options != null) {
                const dismiss = options.dismiss;
                if (dismiss != null) {
                    if (dismiss.enabled === undefined) {
                        dismiss.enabled = theme.isDismissable();
                    }
                    if (dismiss.weight === undefined && dismiss.width === undefined) {
                        dismiss.width = "padding";
                    }
                    const text = dismiss.text;
                    if (text === undefined) {
                        dismiss.text = {
                            value: theme.getDismissLabel()
                        };
                    }
                    else if (text.value === undefined) {
                        text.value = theme.getDismissLabel();
                    }
                    return dismiss;
                }
            }
            return {
                width: "padding",
                enabled: theme.isDismissable(),
                text: {
                    value: theme.getDismissLabel()
                }
            };
        }
        get value() {
            return this._value;
        }
        onSearched(results) {
            this.list.data.items = results;
        }
        getResolvedValue() {
            return this._value;
        }
        getType() {
            return "DDialogSelect";
        }
        onOpen() {
            super.onOpen();
            this.list.selection.clear();
            if (0 < this._categories.length) {
                this.search.create([this.input.value, this.selectCategory.value]);
            }
            else {
                this.search.create([this.input.value]);
            }
        }
        get categories() {
            return this._categories;
        }
        set categories(categories) {
            this._categories = categories;
            this.onCategoriesChange(categories);
        }
        onCategoriesChange(categories) {
            var _a, _b, _c, _d, _e;
            const selectCategory = this.selectCategory;
            if (0 < categories.length) {
                const items = [];
                const theme = this.theme;
                const options = (_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.category) === null || _b === void 0 ? void 0 : _b.dismiss) !== null && _c !== void 0 ? _c : {};
                if ((_d = options.enable) !== null && _d !== void 0 ? _d : theme.isCategoryDismissable()) {
                    items.push({
                        value: null,
                        text: {
                            value: (_e = options.label) !== null && _e !== void 0 ? _e : theme.getCategoryDismissLabel()
                        }
                    });
                }
                for (let i = 0, imax = categories.length; i < imax; ++i) {
                    const category = categories[i];
                    items.push({
                        value: category.id,
                        text: {
                            value: category.label
                        }
                    });
                }
                selectCategory.menu = new DMenu({
                    fit: true,
                    items
                });
                selectCategory.show();
            }
            else {
                selectCategory.hide();
            }
        }
        onOk(value) {
            this.emit("select", value, this);
            super.onOk(value);
        }
        destroy() {
            const input = this._input;
            if (input) {
                input.destroy();
            }
            const noteError = this._noteError;
            if (noteError) {
                noteError.destroy();
            }
            const noteNoItemsFound = this._noteNoItemsFound;
            if (noteNoItemsFound) {
                noteNoItemsFound === null || noteNoItemsFound === void 0 ? void 0 : noteNoItemsFound.destroy();
            }
            const noteSearching = this._noteSearching;
            if (noteSearching) {
                noteSearching === null || noteSearching === void 0 ? void 0 : noteSearching.destroy();
            }
            const list = this._list;
            if (list) {
                list.destroy();
            }
            super.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const defaultGetter$1 = (dialog) => {
        // Assumes the dialog.value is VALUE.
        return dialog.value;
    };
    const defaultSetter$1 = () => {
        // DO NOTHING
    };
    class DButtonSelect extends DButton {
        constructor(options) {
            var _a, _b;
            super(options);
            this._dialogGetter = (_a = options === null || options === void 0 ? void 0 : options.getter) !== null && _a !== void 0 ? _a : defaultGetter$1;
            this._dialogSetter = (_b = options === null || options === void 0 ? void 0 : options.setter) !== null && _b !== void 0 ? _b : defaultSetter$1;
        }
        onActivate(e) {
            var _a;
            super.onActivate(e);
            const dialog = this.dialog;
            const oldValue = (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
            this._dialogSetter(dialog, oldValue);
            dialog.open(this).then(() => {
                const newValue = this._dialogGetter(dialog);
                if (newValue !== oldValue) {
                    this.text = newValue;
                    this.emit("change", newValue, oldValue, this);
                }
            });
        }
        get dialog() {
            var _a;
            let dialog = this._dialog;
            if (dialog == null) {
                const options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                if (options && "open" in options) {
                    dialog = options;
                }
                else {
                    // Assumes DIALOG === DDialogSelect<DIALOG_VALUE, DIALOG_CATEGORY_ID>.
                    dialog = new DDialogSelect(options);
                }
                this._dialog = dialog;
            }
            return dialog;
        }
        get value() {
            var _a;
            return (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
        }
        set value(value) {
            this.text = value;
        }
        getType() {
            return "DButtonSelect";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonTime extends DButton {
        onActivate(e) {
            var _a, _b;
            super.onActivate(e);
            const value = (_b = (_a = this.text.computed) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : Date.now();
            const dialog = this.dialog;
            dialog.current = new Date(value);
            dialog.new = new Date(value);
            dialog.open(this).then(() => {
                this.onValueChange(dialog.new, dialog.current);
            });
        }
        onValueChange(newValue, oldValue) {
            this.text = new Date(newValue.getTime());
            this.emit("change", newValue, oldValue, this);
        }
        getDatetimeMask() {
            var _a, _b;
            let result = this._datetimeMask;
            if (result == null) {
                result = DPickerTimes.toMask((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog) === null || _b === void 0 ? void 0 : _b.picker);
                this._datetimeMask = result;
            }
            return result;
        }
        get dialog() {
            var _a;
            let dialog = this._dialog;
            if (dialog == null) {
                const options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.dialog;
                if (options) {
                    dialog = this.newDialog(options);
                }
                else {
                    if (DButtonTime.DIALOG == null) {
                        DButtonTime.DIALOG = this.newDialog({
                            mode: "MENU",
                            sticky: true
                        });
                    }
                    dialog = DButtonTime.DIALOG;
                }
                this._dialog = dialog;
            }
            return dialog;
        }
        newDialog(options) {
            return new DDialogTime(options);
        }
        get value() {
            var _a;
            return (_a = this.text.computed) !== null && _a !== void 0 ? _a : new Date();
        }
        set value(value) {
            const computed = this.text.computed;
            if (computed === undefined || computed.getTime() !== value.getTime()) {
                this.text = value;
            }
        }
        getType() {
            return "DButtonTime";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DButtonUndo extends DButton {
        constructor(options) {
            super(options);
            const state = this.state;
            const commandController = DControllers.getCommandController();
            state.isDisabled = !commandController.isUndoable();
            commandController.on("change", () => {
                state.isDisabled = !commandController.isUndoable();
            });
        }
        onActivate(e) {
            super.onActivate(e);
            DControllers.getCommandController().undo();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DChartAxisPosition = {
        TOP: 0,
        BOTTOM: 1,
        LEFT: 2,
        RIGHT: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartAxisBaseBar {
        constructor(parser) {
            this._parser = parser;
            this._index = 0;
        }
        get shape() {
            let result = this._shape;
            if (result == null) {
                result = this.newShape();
                this._shape = result;
            }
            return result;
        }
        newShape() {
            var _a;
            const parser = this._parser;
            const bar = parser.bar;
            const result = new EShapeBar();
            result.points.position = this.newShapePosition();
            result.points.style = (_a = bar.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
            result.stroke.copy(bar.stroke);
            result.text.copy(parser.label);
            return result;
        }
        newShapePosition() {
            switch (this._parser.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.TOP;
                default:
                    return EShapeBarPosition.LEFT;
            }
        }
        bind(container, index) {
            this._container = container;
            this._index = index;
            this.shape.attach(container.container);
        }
        unbind() {
            const shape = this._shape;
            if (shape != null) {
                shape.detach();
            }
            this._index = 0;
            this._container = undefined;
        }
        update() {
            const container = this._container;
            const index = this._index;
            const shape = this._shape;
            if (shape != null && container != null) {
                const parser = this._parser;
                const plotArea = container.plotArea;
                const plotAreaBounds = plotArea.getAxisBounds(parser.position);
                const plotAreaX = plotAreaBounds.x;
                const plotAreaY = plotAreaBounds.y;
                const plotAreaWidth = plotAreaBounds.width;
                const plotAreaHeight = plotAreaBounds.height;
                const offset = parser.padding * index;
                shape.lock(EShapeLockPart.UPLOADED);
                const position = shape.transform.position;
                const size = shape.size;
                switch (parser.position) {
                    case DChartAxisPosition.TOP:
                        position.set(plotAreaX + plotAreaWidth * 0.5, plotAreaY - offset);
                        size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.BOTTOM:
                        position.set(plotAreaX + plotAreaWidth * 0.5, plotAreaY + plotAreaHeight + offset);
                        size.set(plotAreaWidth, 0);
                        break;
                    case DChartAxisPosition.LEFT:
                        position.set(plotAreaX - offset, plotAreaY + plotAreaHeight * 0.5);
                        size.set(0, plotAreaHeight);
                        break;
                    case DChartAxisPosition.RIGHT:
                        position.set(plotAreaX + plotAreaWidth + offset, plotAreaY + plotAreaHeight * 0.5);
                        size.set(0, plotAreaHeight);
                        break;
                }
                shape.unlock(EShapeLockPart.UPLOADED, true);
                return true;
            }
            return false;
        }
        destroy() {
            const shape = this._shape;
            if (shape != null) {
                this._shape = undefined;
                shape.destroy();
            }
            this._index = 0;
            this._container = undefined;
        }
    }

    class DChartAxisBaseGuideContainer {
        constructor(axis) {
            this._axis = axis;
            this._index = 0;
            this._list = [];
        }
        add(guide) {
            this._list.push(guide);
            const container = this._container;
            const index = this._index;
            if (container != null) {
                guide.bind(container, index, this._axis);
            }
            return this;
        }
        get(index) {
            const list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        }
        indexOf(guide) {
            return this._list.indexOf(guide);
        }
        clear() {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            return this;
        }
        size() {
            return this._list.length;
        }
        bind(container, index) {
            this._container = container;
            this._index = index;
            const axis = this._axis;
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].bind(container, index, axis);
            }
        }
        unbind() {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].unbind();
            }
            this._index = 0;
            this._container = undefined;
        }
        update() {
            let isUpdated = false;
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                if (list[i].update()) {
                    isUpdated = true;
                }
            }
            return isUpdated;
        }
        destroy() {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            this._index = 0;
            this._container = undefined;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DChartAxisTickPosition = {
        INSIDE: 0,
        OUTSIDE: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartAxisBaseOptionParser {
        constructor(theme, options) {
            var _a, _b;
            this.coordinate = (_a = options === null || options === void 0 ? void 0 : options.coordinate) !== null && _a !== void 0 ? _a : 0;
            this.position = this.toPosition(theme, options);
            this.tick = this.toTick(theme, options);
            this.label = this.toLabel(theme, options);
            this.padding = (_b = options === null || options === void 0 ? void 0 : options.padding) !== null && _b !== void 0 ? _b : theme.getPadding();
            this.bar = this.toBar(theme, options);
            this.guide = this.toGuide(theme, options);
        }
        toPosition(theme, options) {
            const position = options === null || options === void 0 ? void 0 : options.position;
            if (isString(position)) {
                return DChartAxisPosition[position];
            }
            else if (position != null) {
                return position;
            }
            return theme.getPosition();
        }
        toGuide(theme, options) {
            var _a, _b;
            return {
                list: (_b = (_a = options === null || options === void 0 ? void 0 : options.guide) === null || _a === void 0 ? void 0 : _a.list) !== null && _b !== void 0 ? _b : []
            };
        }
        toBar(theme, options) {
            var _a;
            return {
                style: (_a = options === null || options === void 0 ? void 0 : options.style) !== null && _a !== void 0 ? _a : theme.getStyle(),
                stroke: this.toBarStroke(theme, options === null || options === void 0 ? void 0 : options.stroke)
            };
        }
        toTick(theme, options) {
            var _a;
            const tick = options === null || options === void 0 ? void 0 : options.tick;
            return {
                enable: (_a = tick === null || tick === void 0 ? void 0 : tick.enable) !== null && _a !== void 0 ? _a : theme.getTickEnable(),
                major: this.toTickMajor(theme, tick),
                minor: this.toTickMinor(theme, tick)
            };
        }
        toTickMajor(theme, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const major = options === null || options === void 0 ? void 0 : options.major;
            const position = (_b = (_a = major === null || major === void 0 ? void 0 : major.position) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.position) !== null && _b !== void 0 ? _b : theme.getMajorTickPosition();
            const optionsStyle = options === null || options === void 0 ? void 0 : options.style;
            const style = EShapePointsStyles.from((_d = (_c = major === null || major === void 0 ? void 0 : major.style) !== null && _c !== void 0 ? _c : optionsStyle) !== null && _d !== void 0 ? _d : theme.getMajorTickStyle());
            const optionsStroke = options === null || options === void 0 ? void 0 : options.stroke;
            const stroke = this.toTickMajorStroke(theme, major === null || major === void 0 ? void 0 : major.stroke, optionsStroke);
            const count = (_e = major === null || major === void 0 ? void 0 : major.count) !== null && _e !== void 0 ? _e : theme.getMajorTickCount();
            const capacity = (_f = major === null || major === void 0 ? void 0 : major.capacity) !== null && _f !== void 0 ? _f : theme.getMajorTickCapacity(count);
            return {
                count,
                capacity,
                step: (_g = major === null || major === void 0 ? void 0 : major.step) !== null && _g !== void 0 ? _g : theme.getMajorTickStep(),
                size: (_h = major === null || major === void 0 ? void 0 : major.size) !== null && _h !== void 0 ? _h : theme.getMajorTickSize(),
                position: this.toTickPosition(position),
                style,
                stroke,
                text: this.toTickMajorText(theme, major === null || major === void 0 ? void 0 : major.text),
                formatter: this.toTickMajorFormatter(theme, major),
                gridline: this.toTickMajorGridline(theme, major === null || major === void 0 ? void 0 : major.gridline, optionsStyle, optionsStroke)
            };
        }
        toTickMajorGridline(theme, options, optionsStyle, optionsStroke) {
            var _a, _b, _c;
            const style = EShapePointsStyles.from((_b = (_a = options === null || options === void 0 ? void 0 : options.style) !== null && _a !== void 0 ? _a : optionsStyle) !== null && _b !== void 0 ? _b : theme.getMajorTickGridlineStyle());
            return {
                enable: (_c = options === null || options === void 0 ? void 0 : options.enable) !== null && _c !== void 0 ? _c : theme.getMajorTickGridlineEnable(),
                style,
                stroke: this.toTickMajorGridlineStroke(theme, options === null || options === void 0 ? void 0 : options.stroke, optionsStroke)
            };
        }
        toTickPosition(tickPosition) {
            const position = this.position;
            if (tickPosition === DChartAxisTickPosition.OUTSIDE || tickPosition === "OUTSIDE") {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.RIGHT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.LEFT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
            else {
                switch (position) {
                    case DChartAxisPosition.TOP:
                        return EShapeBarPosition.TOP;
                    case DChartAxisPosition.BOTTOM:
                        return EShapeBarPosition.BOTTOM;
                    case DChartAxisPosition.LEFT:
                        return EShapeBarPosition.LEFT;
                    case DChartAxisPosition.RIGHT:
                        return EShapeBarPosition.RIGHT;
                    default:
                        return EShapeBarPosition.TOP;
                }
            }
        }
        toTickMinor(theme, options) {
            var _a, _b, _c, _d, _e, _f, _g;
            const minor = options === null || options === void 0 ? void 0 : options.minor;
            const position = (_b = (_a = minor === null || minor === void 0 ? void 0 : minor.position) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.position) !== null && _b !== void 0 ? _b : theme.getMinorTickPosition();
            const style = EShapePointsStyles.from((_d = (_c = minor === null || minor === void 0 ? void 0 : minor.style) !== null && _c !== void 0 ? _c : options === null || options === void 0 ? void 0 : options.style) !== null && _d !== void 0 ? _d : theme.getMinorTickStyle());
            return {
                count: (_e = minor === null || minor === void 0 ? void 0 : minor.count) !== null && _e !== void 0 ? _e : theme.getMinorTickCount(),
                step: (_f = minor === null || minor === void 0 ? void 0 : minor.step) !== null && _f !== void 0 ? _f : theme.getMinorTickStep(),
                size: (_g = minor === null || minor === void 0 ? void 0 : minor.size) !== null && _g !== void 0 ? _g : theme.getMinorTickSize(),
                position: this.toTickPosition(position),
                style,
                stroke: this.toTickMinorStroke(theme, minor === null || minor === void 0 ? void 0 : minor.stroke, options === null || options === void 0 ? void 0 : options.stroke),
                text: this.toTickMinorText(theme, minor === null || minor === void 0 ? void 0 : minor.text),
                formatter: this.toTickMinorFormatter(theme, minor)
            };
        }
        toBarStroke(theme, options) {
            return this.toStroke(options, undefined, theme.getStrokeEnable(), theme.getStrokeColor(), theme.getStrokeAlpha(), theme.getStrokeWidth(), theme.getStrokeAlign(), theme.getStrokeSide(), theme.getStrokeStyle());
        }
        toTickMajorStroke(theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickStrokeEnable(), theme.getMajorTickStrokeColor(), theme.getMajorTickStrokeAlpha(), theme.getMajorTickStrokeWidth(), theme.getMajorTickStrokeAlign(), theme.getMajorTickStrokeSide(), theme.getMajorTickStrokeStyle());
        }
        toTickMajorGridlineStroke(theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMajorTickGridlineStrokeEnable(), theme.getMajorTickGridlineStrokeColor(), theme.getMajorTickGridlineStrokeAlpha(), theme.getMajorTickGridlineStrokeWidth(), theme.getMajorTickGridlineStrokeAlign(), theme.getMajorTickGridlineStrokeSide(), theme.getMajorTickGridlineStrokeStyle());
        }
        toTickMinorStroke(theme, optionsA, optionsB) {
            return this.toStroke(optionsA, optionsB, theme.getMinorTickStrokeEnable(), theme.getMinorTickStrokeColor(), theme.getMinorTickStrokeAlpha(), theme.getMinorTickStrokeWidth(), theme.getMinorTickStrokeAlign(), theme.getMinorTickStrokeSide(), theme.getMinorTickStrokeStyle());
        }
        toStroke(optionsA, optionsB, enable, color, alpha, width, align, side, style) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
            if (optionsA) {
                if (optionsB) {
                    return {
                        enable: (_b = (_a = optionsA.enable) !== null && _a !== void 0 ? _a : optionsB.enable) !== null && _b !== void 0 ? _b : enable,
                        color: (_d = (_c = optionsA.color) !== null && _c !== void 0 ? _c : optionsB.color) !== null && _d !== void 0 ? _d : color,
                        alpha: (_f = (_e = optionsA.alpha) !== null && _e !== void 0 ? _e : optionsB.alpha) !== null && _f !== void 0 ? _f : alpha,
                        width: (_h = (_g = optionsA.width) !== null && _g !== void 0 ? _g : optionsB.width) !== null && _h !== void 0 ? _h : width,
                        align: (_k = (_j = optionsA.align) !== null && _j !== void 0 ? _j : optionsB.align) !== null && _k !== void 0 ? _k : align,
                        side: (_m = (_l = optionsA.side) !== null && _l !== void 0 ? _l : optionsB.side) !== null && _m !== void 0 ? _m : side,
                        style: this.toStrokeStyle((_p = (_o = optionsA.style) !== null && _o !== void 0 ? _o : optionsB.style) !== null && _p !== void 0 ? _p : style)
                    };
                }
                else {
                    return {
                        enable: (_q = optionsA.enable) !== null && _q !== void 0 ? _q : enable,
                        color: (_r = optionsA.color) !== null && _r !== void 0 ? _r : color,
                        alpha: (_s = optionsA.alpha) !== null && _s !== void 0 ? _s : alpha,
                        width: (_t = optionsA.width) !== null && _t !== void 0 ? _t : width,
                        align: (_u = optionsA.align) !== null && _u !== void 0 ? _u : align,
                        side: (_v = optionsA.side) !== null && _v !== void 0 ? _v : side,
                        style: this.toStrokeStyle((_w = optionsA.style) !== null && _w !== void 0 ? _w : style)
                    };
                }
            }
            else if (optionsB) {
                return {
                    enable: (_x = optionsB.enable) !== null && _x !== void 0 ? _x : enable,
                    color: (_y = optionsB.color) !== null && _y !== void 0 ? _y : color,
                    alpha: (_z = optionsB.alpha) !== null && _z !== void 0 ? _z : alpha,
                    width: (_0 = optionsB.width) !== null && _0 !== void 0 ? _0 : width,
                    align: (_1 = optionsB.align) !== null && _1 !== void 0 ? _1 : align,
                    side: (_2 = optionsB.side) !== null && _2 !== void 0 ? _2 : side,
                    style: this.toStrokeStyle((_3 = optionsB.style) !== null && _3 !== void 0 ? _3 : style)
                };
            }
            else {
                return {
                    enable,
                    color,
                    alpha,
                    width,
                    align,
                    side,
                    style
                };
            }
        }
        toStrokeStyle(target) {
            if (isString(target)) {
                return EShapeStrokeStyle[target];
            }
            else if (isArray(target)) {
                let result = EShapeStrokeStyle.NONE;
                for (let i = 0, imax = target.length; i < imax; ++i) {
                    result |= EShapeStrokeStyle[target[i]];
                }
                return result;
            }
            return target;
        }
        toTickMajorFormatter(theme, options) {
            const text = options === null || options === void 0 ? void 0 : options.text;
            if (text) {
                const format = text.format;
                if (format === null) {
                    return undefined;
                }
                else if (format != null) {
                    return NumberFormatters.create(format);
                }
                else {
                    const formatter = text.formatter;
                    if (formatter) {
                        return {
                            format: formatter
                        };
                    }
                }
            }
            const format = theme.getMajorTickTextFormat();
            if (format != null) {
                return NumberFormatters.create(format);
            }
            return undefined;
        }
        toTickMajorText(theme, options) {
            options = options || {};
            return {
                format: options.format,
                color: this.toTickMajorTextColor(theme, options.color),
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: toEnum(options.weight, EShapeTextWeight),
                align: this.toTickMajorTextAlign(theme, options.align),
                offset: this.toTickMajorTextOffset(theme, options.offset),
                style: toEnum(options.style, EShapeTextStyle),
                outline: this.toTickMajorTextOutline(theme, options.outline),
                spacing: this.toTickMajorTextSpacing(theme, options.spacing),
                direction: this.toTickMajorTextDirection(theme, options.direction),
                padding: this.toTickMajorTextPadding(theme, options.padding),
                clipping: options.clipping
            };
        }
        toTickMajorTextOutline(theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        }
        toTickMajorTextAlign(theme, options) {
            var _a, _b;
            const position = this.position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMajorTickTextAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMajorTickTextAlignVertical(position)
            };
        }
        toTickMajorTextOffset(theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        }
        toTickMajorTextSpacing(theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        }
        toTickMajorTextPadding(theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMajorTickTextPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMajorTickTextPaddingVertical()
            };
        }
        toTickMajorTextDirection(theme, options) {
            return toEnum(options !== null && options !== void 0 ? options : theme.getMajorTickTextDirection(), EShapeTextDirection);
        }
        toTickMajorTextColor(theme, options) {
            return options !== null && options !== void 0 ? options : theme.getMajorTickTextColor();
        }
        toTickMinorFormatter(theme, options) {
            const text = options === null || options === void 0 ? void 0 : options.text;
            if (text) {
                const format = text.format;
                if (format === null) {
                    return undefined;
                }
                else if (format != null) {
                    return NumberFormatters.create(format);
                }
                else {
                    const formatter = text.formatter;
                    if (formatter) {
                        return {
                            format: formatter
                        };
                    }
                }
            }
            const format = theme.getMinorTickTextFormat();
            if (format != null) {
                return NumberFormatters.create(format);
            }
            return undefined;
        }
        toTickMinorText(theme, options) {
            options = options || {};
            return {
                format: options.format,
                color: this.toTickMinorTextColor(theme, options.color),
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: toEnum(options.weight, EShapeTextWeight),
                align: this.toTickMinorTextAlign(theme, options.align),
                offset: this.toTickMinorTextOffset(theme, options.offset),
                style: toEnum(options.style, EShapeTextStyle),
                outline: this.toTickMinorTextOutline(theme, options.outline),
                spacing: this.toTickMinorTextSpacing(theme, options.spacing),
                direction: this.toTickMinorTextDirection(theme, options.direction),
                padding: this.toTickMinorTextPadding(theme, options.padding),
                clipping: options.clipping
            };
        }
        toTickMinorTextOutline(theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        }
        toTickMinorTextAlign(theme, options) {
            var _a, _b;
            const position = this.position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMinorTickTextAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMinorTickTextAlignVertical(position)
            };
        }
        toTickMinorTextOffset(theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        }
        toTickMinorTextSpacing(theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        }
        toTickMinorTextPadding(theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getMinorTickTextPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getMinorTickTextPaddingVertical()
            };
        }
        toTickMinorTextDirection(theme, options) {
            return toEnum(options !== null && options !== void 0 ? options : theme.getMinorTickTextDirection(), EShapeTextDirection);
        }
        toTickMinorTextColor(theme, options) {
            return options !== null && options !== void 0 ? options : theme.getMinorTickTextColor();
        }
        toLabel(theme, options) {
            const label = options === null || options === void 0 ? void 0 : options.label;
            if (label) {
                return {
                    value: label.value,
                    color: this.toLabelColor(theme, label.color),
                    alpha: label.alpha,
                    family: label.family,
                    size: label.size,
                    weight: toEnum(label.weight, EShapeTextWeight),
                    align: this.toLabelAlign(theme, label.align),
                    offset: this.toLabelOffset(theme, label.offset),
                    style: toEnum(label.style, EShapeTextStyle),
                    outline: this.toLabelOutline(theme, label.outline),
                    spacing: this.toLabelSpacing(theme, label.spacing),
                    direction: this.toLabelDirection(theme, label.direction),
                    padding: this.toLabelPadding(theme, label.padding),
                    clipping: label.clipping
                };
            }
        }
        toLabelOutline(theme, options) {
            if (options) {
                return {
                    enable: options.enable,
                    color: options.color,
                    alpha: options.alpha,
                    width: options.width
                };
            }
        }
        toLabelAlign(theme, options) {
            var _a, _b;
            const position = this.position;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getLabelAlignHorizontal(position),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getLabelAlignVertical(position)
            };
        }
        toLabelOffset(theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        }
        toLabelSpacing(theme, options) {
            if (options) {
                return {
                    horizontal: options.horizontal,
                    vertical: options.vertical
                };
            }
        }
        toLabelPadding(theme, options) {
            var _a, _b;
            return {
                horizontal: (_a = options === null || options === void 0 ? void 0 : options.horizontal) !== null && _a !== void 0 ? _a : theme.getLabelPaddingHorizontal(),
                vertical: (_b = options === null || options === void 0 ? void 0 : options.vertical) !== null && _b !== void 0 ? _b : theme.getLabelPaddingVertical()
            };
        }
        toLabelDirection(theme, options) {
            return toEnum(options !== null && options !== void 0 ? options : theme.getLabelDirection(), EShapeTextDirection);
        }
        toLabelColor(theme, options) {
            return options !== null && options !== void 0 ? options : theme.getLabelColor();
        }
    }

    class DChartAxisBaseTickMajorGridline {
        constructor(parser) {
            this._parser = parser;
            this._index = 0;
        }
        get shapes() {
            var _a;
            return ((_a = this._shapes) !== null && _a !== void 0 ? _a : (this._shapes = this.newShapes()));
        }
        newShapes() {
            var _a;
            const result = [];
            const tick = this._parser.tick;
            const major = tick.major;
            const gridline = major.gridline;
            if (tick.enable && gridline.enable) {
                const capacity = major.capacity;
                const style = (_a = gridline.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
                const position = this.newShapePosition();
                for (let i = 0; i < capacity; ++i) {
                    const shape = new EShapeBar();
                    shape.points.position = position;
                    shape.points.style = style;
                    shape.stroke.copy(gridline.stroke);
                    result.push(shape);
                }
            }
            return result;
        }
        newShapePosition() {
            switch (this._parser.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.LEFT;
                default:
                    return EShapeBarPosition.TOP;
            }
        }
        bind(container, index) {
            this._container = container;
            this._index = index;
            const shapes = this.shapes;
            const containerContainer = container.container;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(containerContainer);
            }
        }
        unbind() {
            const shapes = this._shapes;
            if (shapes != null) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].detach();
                }
            }
            this._index = 0;
            this._container = undefined;
        }
        destroy() {
            const shapes = this._shapes;
            if (shapes != null) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].destroy();
                }
                shapes.length = 0;
                this._shapes = undefined;
            }
            this._index = 0;
            this._container = undefined;
        }
    }

    class DChartAxisBaseTickMajor {
        constructor(parser) {
            this._parser = parser;
            this._index = 0;
            this._gridline = new DChartAxisBaseTickMajorGridline(parser);
        }
        get shapes() {
            var _a;
            return ((_a = this._shapes) !== null && _a !== void 0 ? _a : (this._shapes = this.newShapes()));
        }
        newShapes() {
            var _a;
            const result = [];
            const tick = this._parser.tick;
            if (tick.enable) {
                const major = tick.major;
                const capacity = major.capacity;
                const size = major.size;
                const position = major.position;
                const style = (_a = major.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
                for (let i = 0; i < capacity; ++i) {
                    const shape = new EShapeBar();
                    shape.points.position = position;
                    shape.points.size = size;
                    shape.points.style = style;
                    shape.stroke.copy(major.stroke);
                    shape.text.copy(major.text);
                    shape.size.set(0, 0);
                    result.push(shape);
                }
            }
            return result;
        }
        get gridline() {
            return this._gridline;
        }
        bind(container, index) {
            this._container = container;
            this._index = index;
            // Gridline
            this._gridline.bind(container, index);
            // Ticks
            const shapes = this.shapes;
            const containerContainer = container.container;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(containerContainer);
            }
        }
        unbind() {
            const shapes = this._shapes;
            if (shapes != null) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].detach();
                }
            }
            this._gridline.unbind();
            this._index = 0;
            this._container = undefined;
        }
        destroy() {
            const shapes = this._shapes;
            if (shapes != null) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].destroy();
                }
                shapes.length = 0;
                this._shapes = undefined;
            }
            this._gridline.destroy();
            this._index = 0;
            this._container = undefined;
        }
    }

    class DChartAxisBaseTickMinor {
        constructor(parser) {
            this._parser = parser;
            this._index = 0;
        }
        get shapes() {
            var _a;
            return ((_a = this._shapes) !== null && _a !== void 0 ? _a : (this._shapes = this.newShapes()));
        }
        newShapes() {
            var _a;
            const result = [];
            const tick = this._parser.tick;
            if (tick.enable) {
                const minor = tick.minor;
                const count = minor.count;
                const size = minor.size;
                const position = minor.position;
                const style = (_a = minor.style) !== null && _a !== void 0 ? _a : EShapePointsStyle.NONE;
                const major = tick.major;
                for (let i = 0, imax = (major.capacity + 1) * count; i < imax; ++i) {
                    const shape = new EShapeBar();
                    shape.points.position = position;
                    shape.points.size = size;
                    shape.points.style = style;
                    shape.stroke.copy(minor.stroke);
                    shape.text.copy(minor.text);
                    shape.size.set(0, 0);
                    result.push(shape);
                }
            }
            return result;
        }
        bind(container, index) {
            this._container = container;
            this._index = index;
            const shapes = this.shapes;
            const containerContainer = container.container;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(containerContainer);
            }
        }
        unbind() {
            const shapes = this._shapes;
            if (shapes != null) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].detach();
                }
            }
            this._index = 0;
            this._container = undefined;
        }
        destroy() {
            const shapes = this._shapes;
            if (shapes != null) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].destroy();
                }
                shapes.length = 0;
                this._shapes = undefined;
            }
            this._index = 0;
            this._container = undefined;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartRegionImpl {
        constructor(from, to) {
            this.from = from;
            this.to = to;
        }
        set(from, to) {
            if (from != null) {
                this.from = from;
            }
            if (to != null) {
                this.to = to;
            }
            return this;
        }
        add(from, to) {
            if (!isNaN$1(from)) {
                this.from = isNaN$1(this.from) ? from : Math.min(this.from, from);
            }
            if (!isNaN$1(to)) {
                this.to = isNaN$1(this.to) ? to : Math.max(this.to, to);
            }
            return this;
        }
        clear() {
            this.from = NaN;
            this.to = NaN;
            return this;
        }
    }

    class DChartAxisBaseTickContainer {
        constructor(parser, options) {
            this._parser = parser;
            this._index = 0;
            this._major = this.newMajor(parser, options);
            this._minor = this.newMinor(parser, options);
            this._majorTicks = [];
            this._minorTicks = [];
            this._work = new DChartRegionImpl(0, 0);
        }
        get major() {
            return this._major;
        }
        newMajor(parser, options) {
            return new DChartAxisBaseTickMajor(parser);
        }
        get minor() {
            return this._minor;
        }
        newMinor(parser, options) {
            return new DChartAxisBaseTickMinor(parser);
        }
        bind(container, index) {
            this._container = container;
            this._index = index;
            this._major.bind(container, index);
            this._minor.bind(container, index);
        }
        unbind() {
            this._minor.unbind();
            this._major.unbind();
            this._index = 0;
            this._container = undefined;
        }
        update() {
            const parser = this._parser;
            const container = this._container;
            const majorShapes = this._major.shapes;
            const minorShapes = this._minor.shapes;
            if (parser.tick.enable && container != null && majorShapes && minorShapes) {
                const plotArea = container.plotArea;
                const plotAreaBounds = plotArea.getAxisBounds(parser.position);
                const plotAreaX = plotAreaBounds.x;
                const plotAreaY = plotAreaBounds.y;
                const plotAreaWidth = plotAreaBounds.width;
                const plotAreaHeight = plotAreaBounds.height;
                const transform = plotArea.container.transform.localTransform;
                const gridlineShapes = this._major.gridline.shapes;
                const offset = parser.padding * this._index;
                const work = this._work;
                let coordinate;
                switch (parser.position) {
                    case DChartAxisPosition.TOP:
                        coordinate = plotArea.coordinate.x.get(parser.coordinate);
                        if (coordinate) {
                            const domain = this.getDomain(plotArea, coordinate, work);
                            const domainFrom = domain.from;
                            const domainTo = domain.to;
                            const domainVisible = this.getDomainVisible(plotArea, coordinate, work);
                            const domainVisibleFrom = domainVisible.from;
                            const domainVisibleTo = domainVisible.to;
                            return this.updateX(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaY - offset, transform, plotAreaY, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.BOTTOM:
                        coordinate = plotArea.coordinate.x.get(parser.coordinate);
                        if (coordinate) {
                            const domain = this.getDomain(plotArea, coordinate, work);
                            const domainFrom = domain.from;
                            const domainTo = domain.to;
                            const domainVisible = this.getDomainVisible(plotArea, coordinate, work);
                            const domainVisibleFrom = domainVisible.from;
                            const domainVisibleTo = domainVisible.to;
                            return this.updateX(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaY + plotAreaHeight + offset, transform, plotAreaY, plotAreaHeight);
                        }
                        break;
                    case DChartAxisPosition.LEFT:
                        coordinate = plotArea.coordinate.y.get(parser.coordinate);
                        if (coordinate) {
                            const range = this.getRange(plotArea, coordinate, work);
                            const rangeFrom = range.from;
                            const rangeTo = range.to;
                            const rangeVisible = this.getRangeVisible(plotArea, coordinate, work);
                            const rangeVisibleFrom = rangeVisible.from;
                            const rangeVisibleTo = rangeVisible.to;
                            return this.updateY(rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaX - offset, transform, plotAreaX, plotAreaWidth);
                        }
                        break;
                    case DChartAxisPosition.RIGHT:
                        coordinate = plotArea.coordinate.y.get(parser.coordinate);
                        if (coordinate) {
                            const range = this.getRange(plotArea, coordinate, work);
                            const rangeFrom = range.from;
                            const rangeTo = range.to;
                            const rangeVisible = this.getRangeVisible(plotArea, coordinate, work);
                            const rangeVisibleFrom = rangeVisible.from;
                            const rangeVisibleTo = rangeVisible.to;
                            return this.updateY(rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, plotAreaX + plotAreaWidth + offset, transform, plotAreaX, plotAreaWidth);
                        }
                        break;
                }
            }
            return false;
        }
        getDomain(plotArea, coordinate, result) {
            const bounds = plotArea.getContainerBounds();
            const transform = coordinate.transform;
            return result.set(coordinate.unmap(transform.unmap(bounds.x)), coordinate.unmap(transform.unmap(bounds.x + bounds.width)));
        }
        getDomainVisible(plotArea, coordinate, result) {
            return result;
        }
        getRange(plotArea, coordinate, result) {
            const bounds = plotArea.getContainerBounds();
            const transform = coordinate.transform;
            return result.set(coordinate.unmap(transform.unmap(bounds.y)), coordinate.unmap(transform.unmap(bounds.y + bounds.height)));
        }
        getRangeVisible(plotArea, coordinate, result) {
            return result;
        }
        updateX(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionY, transform, plotAreaY, plotAreaHeight) {
            const tick = this._parser.tick;
            const majorTick = tick.major;
            const majorCount = majorTick.count;
            const majorCapacity = majorTick.capacity;
            const majorStep = majorTick.step;
            const majorFormatter = majorTick.formatter;
            const minorTick = tick.minor;
            const minorCountPerMajor = minorTick.count;
            const minorCount = (majorCapacity + 1) * minorCountPerMajor;
            const minorStep = minorTick.step;
            const minorFormatter = minorTick.formatter;
            const majorTicks = this._majorTicks;
            const minorTicks = this._minorTicks;
            this.newTicks(coordinate, domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorTicks, minorTicks);
            const a = transform.a;
            const tx = transform.tx;
            for (let i = 0; i < majorCapacity; ++i) {
                const majorShape = majorShapes[i];
                const imajorTick = i * 3;
                const majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    const majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    const majotTickPositionX = a * majorTickProjectedPosition + tx;
                    const majorTickStep = majorTicks[imajorTick + 2];
                    this.showMajor(majorShape, majotTickPositionX, shapePositionY, majorFormatter === null || majorFormatter === void 0 ? void 0 : majorFormatter.format(majorTickPosition, majorTickStep));
                    if (i < gridlineShapes.length) {
                        this.showMajorGridline(gridlineShapes[i], majorTickPosition, majotTickPositionX, plotAreaY + plotAreaHeight * 0.5, 0, plotAreaHeight);
                    }
                }
                else {
                    this.hideMajor(majorShape);
                    if (i < gridlineShapes.length) {
                        this.hideMajorGridline(gridlineShapes[i]);
                    }
                }
            }
            for (let i = 0; i < minorCount; ++i) {
                const minorShape = minorShapes[i];
                const iminorTick = i * 3;
                const minorTickPosition = minorTicks[iminorTick + 0];
                if (!isNaN(minorTickPosition)) {
                    const minorTickProjectedPosition = minorTicks[iminorTick + 1];
                    const minorTickPositionX = a * minorTickProjectedPosition + tx;
                    const minorTickStep = minorTicks[iminorTick + 2];
                    this.showMinor(minorShape, minorTickPositionX, shapePositionY, minorFormatter === null || minorFormatter === void 0 ? void 0 : minorFormatter.format(minorTickPosition, minorTickStep));
                }
                else {
                    this.hideMinor(minorShape);
                }
            }
            return true;
        }
        updateY(rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, coordinate, majorShapes, minorShapes, gridlineShapes, shapePositionX, transform, plotAreaX, plotAreaWidth) {
            const tick = this._parser.tick;
            const majorTick = tick.major;
            const majorCount = majorTick.count;
            const majorCapacity = majorTick.capacity;
            const majorStep = majorTick.step;
            const majorFormatter = majorTick.formatter;
            const minorTick = tick.minor;
            const minorCountPerMajor = minorTick.count;
            const minorCount = (majorCapacity + 1) * minorCountPerMajor;
            const minorStep = minorTick.step;
            const minorFormatter = minorTick.formatter;
            const majorTicks = this._majorTicks;
            const minorTicks = this._minorTicks;
            this.newTicks(coordinate, rangeFrom, rangeTo, rangeVisibleFrom, rangeVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorTicks, minorTicks);
            const d = transform.d;
            const ty = transform.ty;
            for (let i = 0; i < majorCapacity; ++i) {
                const majorShape = majorShapes[i];
                const imajorTick = i * 3;
                const majorTickPosition = majorTicks[imajorTick + 0];
                if (!isNaN(majorTickPosition)) {
                    const majorTickProjectedPosition = majorTicks[imajorTick + 1];
                    const majotTickPositionY = d * majorTickProjectedPosition + ty;
                    const majorTickStep = majorTicks[imajorTick + 2];
                    this.showMajor(majorShape, shapePositionX, majotTickPositionY, majorFormatter === null || majorFormatter === void 0 ? void 0 : majorFormatter.format(majorTickPosition, majorTickStep));
                    if (i < gridlineShapes.length) {
                        this.showMajorGridline(gridlineShapes[i], majorTickPosition, plotAreaX + plotAreaWidth * 0.5, majotTickPositionY, plotAreaWidth, 0);
                    }
                }
                else {
                    this.hideMajor(majorShape);
                    if (i < gridlineShapes.length) {
                        this.hideMajorGridline(gridlineShapes[i]);
                    }
                }
            }
            for (let i = 0; i < minorCount; ++i) {
                const minorShape = minorShapes[i];
                const iminorTick = i * 3;
                const minorTickPosition = minorTicks[iminorTick + 0];
                if (!isNaN(minorTickPosition)) {
                    const minorTickProjectedPosition = minorTicks[iminorTick + 1];
                    const minorTickPositionY = d * minorTickProjectedPosition + ty;
                    const minorTickStep = minorTicks[iminorTick + 2];
                    this.showMinor(minorShape, shapePositionX, minorTickPositionY, minorFormatter === null || minorFormatter === void 0 ? void 0 : minorFormatter.format(minorTickPosition, minorTickStep));
                }
                else {
                    this.hideMinor(minorShape);
                }
            }
            return true;
        }
        showMajor(shape, x, y, text) {
            shape.lock(EShapeLockPart.UPLOADED);
            shape.visible = true;
            shape.transform.position.set(x, y);
            shape.text.value = text != null ? text : "";
            shape.unlock(EShapeLockPart.UPLOADED, true);
        }
        showMajorGridline(shape, value, x, y, sx, sy) {
            shape.lock(EShapeLockPart.UPLOADED);
            shape.visible = true;
            shape.transform.position.set(x, y);
            shape.size.set(sx, sy);
            shape.unlock(EShapeLockPart.UPLOADED, true);
        }
        hideMajor(shape) {
            shape.visible = false;
        }
        hideMajorGridline(shape) {
            shape.visible = false;
        }
        showMinor(shape, x, y, text) {
            shape.lock(EShapeLockPart.UPLOADED);
            shape.visible = true;
            shape.transform.position.set(x, y);
            shape.text.value = text != null ? text : "";
            shape.unlock(EShapeLockPart.UPLOADED, true);
        }
        hideMinor(shape) {
            shape.visible = false;
        }
        newTicks(coordinate, domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult) {
            coordinate.ticks(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult);
        }
        destroy() {
            this._major.destroy();
            this._minor.destroy();
            this._index = 0;
            this._container = undefined;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartAxisBase {
        constructor(options) {
            const theme = this.toTheme(options);
            this._theme = theme;
            const parser = this.newParser(theme, options);
            this._parser = parser;
            this._index = 0;
            this._bar = this.newBar(parser, theme, options);
            this._tick = this.newTick(parser, theme, options);
            this._guide = this.newGuide(parser, theme, options);
        }
        newParser(theme, options) {
            return new DChartAxisBaseOptionParser(theme, options);
        }
        get position() {
            return this._parser.position;
        }
        set position(position) {
            this._parser.position = position;
        }
        get coordinate() {
            return this._parser.coordinate;
        }
        set coordinate(coordinate) {
            this._parser.coordinate = coordinate;
        }
        get padding() {
            return this._parser.padding;
        }
        set padding(padding) {
            this._parser.padding = padding;
        }
        get bar() {
            return this._bar;
        }
        newBar(parser, theme, options) {
            return new DChartAxisBaseBar(parser);
        }
        get tick() {
            return this._tick;
        }
        newTick(parser, theme, options) {
            return new DChartAxisBaseTickContainer(parser);
        }
        get guide() {
            return this._guide;
        }
        newGuide(parser, theme, options) {
            const result = new DChartAxisBaseGuideContainer(this);
            const list = parser.guide.list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                result.add(list[i]);
            }
            return result;
        }
        bind(container, index) {
            this._container = container;
            this._index = index;
            this._bar.bind(container, index);
            this._tick.bind(container, index);
            this._guide.bind(container, index);
        }
        unbind() {
            this._guide.unbind();
            this._tick.unbind();
            this._bar.unbind();
            this._index = 0;
            this._container = undefined;
        }
        update() {
            const isBarUpdated = this._bar.update();
            const isTicksUpdated = this._tick.update();
            const isGuideUpdated = this._guide.update();
            if (isBarUpdated || isTicksUpdated || isGuideUpdated) {
                const container = this._container;
                if (container) {
                    DApplications.update(container.plotArea);
                }
            }
        }
        onRender() {
            this._bar.update();
            this._tick.update();
            this._guide.update();
        }
        destroy() {
            this._bar.destroy();
            this._tick.destroy();
            this._guide.destroy();
            this._container = undefined;
        }
        toTheme(options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        }
        getThemeDefault() {
            return DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "DChartAxisBase";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartAxisContainerImpl {
        constructor(plotArea, container, options) {
            this._plotArea = plotArea;
            this._container = container;
            this._list = new Map();
        }
        get container() {
            return this._container;
        }
        get plotArea() {
            return this._plotArea;
        }
        add(axis) {
            const list = this._list;
            let axes = list.get(axis.position);
            if (axes == null) {
                axes = [];
                list.set(axis.position, axes);
            }
            axes.push(axis);
            axis.bind(this, axes.length - 1);
        }
        get(position, index) {
            const list = this._list;
            const axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                if (0 <= index && index < axes.length) {
                    return axes[index];
                }
            }
            return null;
        }
        indexOf(axis) {
            const list = this._list;
            const axes = list.get(axis.position);
            if (axes) {
                return axes.indexOf(axis);
            }
            return -1;
        }
        clear(position) {
            const list = this._list;
            const axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                for (let i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            }
            return this;
        }
        size(position) {
            const list = this._list;
            const axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                return axes.length;
            }
            return 0;
        }
        update() {
            this._list.forEach((axes) => {
                for (let i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].update();
                }
            });
        }
        onRender() {
            this._list.forEach((axes) => {
                for (let i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].onRender();
                }
            });
        }
        destroy() {
            this._list.forEach((axes) => {
                for (let i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            });
        }
    }

    class DChartAxisGuideSimpleShapeImpl {
        constructor(options) {
            this._options = options;
        }
        get bar() {
            let result = this._bar;
            if (result === undefined) {
                result = this.newBar();
                this._bar = result;
            }
            return result;
        }
        newBar() {
            var _a, _b;
            const bar = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.bar) !== null && _b !== void 0 ? _b : {};
            if (bar.enable !== false) {
                const result = new EShapeBar();
                result.stroke.copy(this.toStrokeOptions(bar.stroke, EShapeStrokeStyle.DASHED));
                result.text.copy(this.toTextOptions(bar.text));
                return result;
            }
            return null;
        }
        toStrokeOptions(options, style) {
            var _a;
            options = options || {};
            return {
                enable: options.enable,
                color: options.color,
                alpha: options.alpha,
                width: options.width,
                align: options.align,
                side: toEnum(options.side, EShapeStrokeSide),
                style: toEnum((_a = options.style) !== null && _a !== void 0 ? _a : style, EShapeStrokeStyle)
            };
        }
        toTextOptions(options) {
            options = options || {};
            return {
                value: options.value,
                color: options.color,
                alpha: options.alpha,
                family: options.family,
                size: options.size,
                weight: toEnum(options.weight, EShapeTextWeight),
                align: this.toTextAlignOptions(options.align),
                offset: options.offset,
                style: toEnum(options.style, EShapeTextStyle),
                outline: options.outline,
                spacing: options.spacing,
                direction: toEnum(options.direction, EShapeTextDirection),
                padding: options.padding,
                clipping: options.clipping,
                fitting: options.fitting
            };
        }
        toTextAlignOptions(options) {
            options = options || {};
            return {
                horizontal: toEnum(options === null || options === void 0 ? void 0 : options.horizontal, EShapeTextAlignHorizontal),
                vertical: toEnum(options === null || options === void 0 ? void 0 : options.vertical, EShapeTextAlignVertical)
            };
        }
        toBarPosition(axis) {
            switch (axis.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.LEFT;
                default:
                    return EShapeBarPosition.TOP;
            }
        }
        get label() {
            let result = this._label;
            if (result === undefined) {
                result = this.newLabel();
                this._label = result;
            }
            return result;
        }
        newLabel() {
            var _a, _b, _c, _d;
            const label = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : {};
            if (label.enable === true) {
                const result = new EShapeRectangleRounded();
                result.stroke.copy(this.toStrokeOptions(label.stroke));
                result.fill.copy(label.fill);
                result.text.copy(this.toTextOptions(label.text));
                result.size.set((_c = label.width) !== null && _c !== void 0 ? _c : 50, (_d = label.height) !== null && _d !== void 0 ? _d : 30);
                return result;
            }
            return null;
        }
        get labelMargin() {
            let result = this._labelMargin;
            if (result == null) {
                result = this.newLabelMargin();
                this._labelMargin = result;
            }
            return result;
        }
        newLabelMargin() {
            const options = this._options;
            if (options != null) {
                const label = options.label;
                if (label != null) {
                    const result = label.margin;
                    if (result != null) {
                        return result;
                    }
                }
            }
            return 10;
        }
        get tick() {
            let result = this._tick;
            if (result === undefined) {
                result = this.newTick();
                this._tick = result;
            }
            return result;
        }
        newTick() {
            var _a, _b, _c;
            const tick = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.tick) !== null && _b !== void 0 ? _b : {};
            if (tick.enable === true) {
                const result = new EShapeBar();
                result.stroke.copy(this.toStrokeOptions(tick.stroke));
                result.text.copy(this.toTextOptions(tick.text));
                const size = (_c = tick.size) !== null && _c !== void 0 ? _c : 5;
                result.size.set(size, size);
                return result;
            }
            return null;
        }
        get tickMargin() {
            let result = this._tickMargin;
            if (result == null) {
                result = this.newTickMargin();
                this._tickMargin = result;
            }
            return result;
        }
        newTickMargin() {
            const options = this._options;
            if (options != null) {
                const tick = options.tick;
                if (tick != null) {
                    const result = tick.margin;
                    if (result != null) {
                        return result;
                    }
                }
            }
            return 0;
        }
        toTickPosition(axis) {
            switch (axis.position) {
                case DChartAxisPosition.LEFT:
                case DChartAxisPosition.RIGHT:
                    return EShapeBarPosition.LEFT;
                default:
                    return EShapeBarPosition.TOP;
            }
        }
        bind(container, index, axis) {
            const bar = this.bar;
            if (bar != null) {
                bar.points.position = this.toBarPosition(axis);
                bar.attach(container.container);
            }
            const label = this.label;
            if (label != null) {
                label.attach(container.container);
            }
            const tick = this.tick;
            if (tick != null) {
                tick.points.position = this.toTickPosition(axis);
                tick.attach(container.container);
            }
        }
        unbind() {
            const bar = this._bar;
            if (bar != null) {
                bar.detach();
            }
            const label = this._label;
            if (label != null) {
                label.detach();
            }
            const tick = this._tick;
            if (tick != null) {
                tick.detach();
            }
        }
        update(position, x, y, visible, width, height, offset) {
            const bar = this._bar;
            if (bar != null) {
                bar.lock(EShapeLockPart.UPLOADED);
                switch (position) {
                    case DChartAxisPosition.TOP:
                        bar.transform.position.set(x, y);
                        bar.size.set(0, height);
                        bar.visible = visible;
                        break;
                    case DChartAxisPosition.BOTTOM:
                        bar.transform.position.set(x, y);
                        bar.size.set(0, height);
                        bar.visible = visible;
                        break;
                    case DChartAxisPosition.LEFT:
                        bar.transform.position.set(x, y);
                        bar.size.set(width, 0);
                        bar.visible = visible;
                        break;
                    case DChartAxisPosition.RIGHT:
                        bar.transform.position.set(x, y);
                        bar.size.set(width, 0);
                        bar.visible = visible;
                        break;
                }
                bar.unlock(EShapeLockPart.UPLOADED, true);
            }
            const label = this._label;
            if (label != null) {
                const m = this.labelMargin;
                const s = label.size;
                const ox = offset + s.x * 0.5 + m;
                const oy = offset + s.y * 0.5 + m;
                label.lock(EShapeLockPart.UPLOADED);
                switch (position) {
                    case DChartAxisPosition.TOP:
                        label.transform.position.set(x, -oy);
                        label.visible = visible;
                        break;
                    case DChartAxisPosition.BOTTOM:
                        label.transform.position.set(x, height + oy);
                        label.visible = visible;
                        break;
                    case DChartAxisPosition.LEFT:
                        label.transform.position.set(-ox, y);
                        label.visible = visible;
                        break;
                    case DChartAxisPosition.RIGHT:
                        label.transform.position.set(width + ox, y);
                        label.visible = visible;
                        break;
                }
                label.unlock(EShapeLockPart.UPLOADED, true);
            }
            const tick = this._tick;
            if (tick != null) {
                const m = this.tickMargin;
                const s = tick.size;
                const ox = offset + s.x * 0.5 + m;
                const oy = offset + s.y * 0.5 + m;
                tick.lock(EShapeLockPart.UPLOADED);
                switch (position) {
                    case DChartAxisPosition.TOP:
                        tick.transform.position.set(x, -oy);
                        tick.visible = visible;
                        break;
                    case DChartAxisPosition.BOTTOM:
                        tick.transform.position.set(x, height + oy);
                        tick.visible = visible;
                        break;
                    case DChartAxisPosition.LEFT:
                        tick.transform.position.set(-ox, y);
                        tick.visible = visible;
                        break;
                    case DChartAxisPosition.RIGHT:
                        tick.transform.position.set(width + ox, y);
                        tick.visible = visible;
                        break;
                }
                tick.unlock(EShapeLockPart.UPLOADED, true);
            }
            return true;
        }
        destroy() {
            const bar = this._bar;
            if (bar != null) {
                bar.destroy();
            }
            const label = this._label;
            if (label != null) {
                label.destroy();
            }
            const tick = this._tick;
            if (tick != null) {
                tick.destroy();
            }
        }
    }

    class DChartAxisGuideSimple {
        constructor(options) {
            var _a, _b;
            this._options = options;
            this._index = 0;
            if (options != null) {
                this._position = (_a = options.position) !== null && _a !== void 0 ? _a : 0;
                this._fixed = (_b = options.fixed) !== null && _b !== void 0 ? _b : false;
            }
            else {
                this._position = 0;
                this._fixed = false;
            }
            this._isShown = true;
        }
        get shape() {
            let result = this._shape;
            if (result == null) {
                result = this.newShape();
                this._shape = result;
            }
            return result;
        }
        newShape() {
            return new DChartAxisGuideSimpleShapeImpl(this._options);
        }
        get position() {
            return this._position;
        }
        set position(position) {
            this._position = position;
        }
        show() {
            this._isShown = true;
            return this;
        }
        isShown() {
            return this._isShown;
        }
        hide() {
            this._isShown = false;
            return this;
        }
        isHidden() {
            return !this._isShown;
        }
        bind(container, index, axis) {
            this._container = container;
            this._index = index;
            this._axis = axis;
            this.shape.bind(container, index, axis);
        }
        unbind() {
            const shape = this._shape;
            if (shape != null) {
                shape.unbind();
            }
            this._axis = undefined;
            this._index = 0;
            this._container = undefined;
        }
        update() {
            const container = this._container;
            const index = this._index;
            const shape = this._shape;
            const axis = this._axis;
            if (shape != null && container != null && axis != null) {
                const plotArea = container.plotArea;
                const plotAreaBounds = plotArea.getAxisBounds(axis.position);
                const plotAreaX = plotAreaBounds.x;
                const plotAreaY = plotAreaBounds.y;
                const plotAreaWidth = plotAreaBounds.width;
                const plotAreaHeight = plotAreaBounds.height;
                const offset = axis.padding * index;
                switch (axis.position) {
                    case DChartAxisPosition.TOP:
                    case DChartAxisPosition.BOTTOM:
                        const x = this.getPositionX(axis, plotArea, plotAreaX);
                        shape.update(axis.position, x, plotAreaY + plotAreaHeight * 0.5, this._isShown && plotAreaX <= x && x <= plotAreaX + plotAreaWidth, plotAreaWidth, plotAreaHeight, offset);
                        break;
                    case DChartAxisPosition.LEFT:
                    case DChartAxisPosition.RIGHT:
                        const y = this.getPositionY(axis, plotArea, plotAreaY);
                        shape.update(axis.position, plotAreaX + plotAreaWidth * 0.5, y, this._isShown && plotAreaY <= y && y <= plotAreaY + plotAreaHeight, plotAreaWidth, plotAreaHeight, offset);
                        break;
                }
                return true;
            }
            return false;
        }
        getPositionX(axis, plotArea, plotAreaX) {
            var _a, _b;
            if (this._fixed) {
                const work = ((_a = DChartAxisGuideSimple.WORK_REGION) !== null && _a !== void 0 ? _a : (DChartAxisGuideSimple.WORK_REGION = new DChartRegionImpl(0, 0)));
                plotArea.getPixelDomain(work);
                return work.from + this._position * (work.to - work.from);
            }
            else {
                const coordinateX = plotArea.coordinate.x.get(axis.coordinate);
                if (coordinateX) {
                    const work = ((_b = DChartAxisGuideSimple.WORK_POINT) !== null && _b !== void 0 ? _b : (DChartAxisGuideSimple.WORK_POINT = new pixi_js.Point()));
                    work.set(coordinateX.transform.map(coordinateX.map(this._position)), 0);
                    plotArea.container.transform.localTransform.apply(work, work);
                    return work.x;
                }
                else {
                    return plotAreaX - 100;
                }
            }
        }
        getPositionY(axis, plotArea, plotAreaY) {
            var _a, _b;
            if (this._fixed) {
                const work = ((_a = DChartAxisGuideSimple.WORK_REGION) !== null && _a !== void 0 ? _a : (DChartAxisGuideSimple.WORK_REGION = new DChartRegionImpl(0, 0)));
                plotArea.getPixelRange(work);
                return work.to + (1 - this._position) * (work.from - work.to);
            }
            else {
                const coordinateY = plotArea.coordinate.y.get(axis.coordinate);
                if (coordinateY) {
                    const work = ((_b = DChartAxisGuideSimple.WORK_POINT) !== null && _b !== void 0 ? _b : (DChartAxisGuideSimple.WORK_POINT = new pixi_js.Point()));
                    work.set(0, coordinateY.transform.map(coordinateY.map(this._position)));
                    plotArea.container.transform.localTransform.apply(work, work);
                    return work.y;
                }
                else {
                    return plotAreaY - 100;
                }
            }
        }
        destroy() {
            const shape = this._shape;
            if (shape != null) {
                shape.destroy();
            }
            this._index = 0;
            this._container = undefined;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis.
     */
    class DChartAxisX extends DChartAxisBase {
        getType() {
            return "DChartAxisX";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An X axis for datetimes.
     */
    class DChartAxisXDatetime extends DChartAxisX {
        getType() {
            return "DChartAxisXDatetime";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * An Y axis.
     */
    class DChartAxisY extends DChartAxisBase {
        getType() {
            return "DChartAxisY";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DCHART_COLOR_SET_1 = [0x10b7e3, 0xfe5420, 0xf0c312, 0x1c5d71];
    const DCHART_COLOR_SET_2 = [
        DCHART_COLOR_SET_1[0],
        UtilRgb.brighten(DCHART_COLOR_SET_1[0], 0.4),
        DCHART_COLOR_SET_1[1],
        UtilRgb.brighten(DCHART_COLOR_SET_1[1], 0.4),
        DCHART_COLOR_SET_1[2],
        UtilRgb.brighten(DCHART_COLOR_SET_1[2], 0.4),
        DCHART_COLOR_SET_1[3],
        UtilRgb.brighten(DCHART_COLOR_SET_1[3], 0.4)
    ];
    const DChartColorSet1 = (index) => {
        return DCHART_COLOR_SET_1[index % DCHART_COLOR_SET_1.length];
    };
    const DChartColorSet2 = (index) => {
        return DCHART_COLOR_SET_2[index % DCHART_COLOR_SET_2.length];
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DChartCoordinateDirection = {
        X: 0,
        Y: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartCoordinateTransformImpl {
        constructor(options) {
            this._theme = this.toTheme(options);
            this._id = 0;
            this._isTranslationEnabled = options === null || options === void 0 ? void 0 : options.translation;
            this._translate = 0;
            this._isScalingEnabled = options === null || options === void 0 ? void 0 : options.scaling;
            this._scale = 1;
            this._itranslate = 0;
            this._iscale = 1;
        }
        get id() {
            return this._id;
        }
        get translate() {
            return this._translate;
        }
        set translate(translate) {
            this.set(translate);
        }
        get scale() {
            return this._scale;
        }
        set scale(scale) {
            this.set(undefined, scale);
        }
        bind(container, direction) {
            this.set(0, direction === DChartCoordinateDirection.X ? +1 : -1);
        }
        unbind() {
            // DO NOTHING
        }
        set(translate, scale) {
            let isChanged = false;
            if (translate != null &&
                this._isTranslationEnabled !== false &&
                this._translate !== translate) {
                isChanged = true;
                this._translate = translate;
            }
            if (scale != null && this._isScalingEnabled !== false && this._scale !== scale) {
                isChanged = true;
                this._scale = scale;
            }
            if (isChanged) {
                this._id += 1;
                this._iscale = this._theme.isZero(this._scale) ? 0 : 1 / this._scale;
                this._itranslate = -this._translate * this._iscale;
            }
        }
        blend(ratio, mark) {
            const ratioi = 1 - ratio;
            const newTranslate = mark.newTranslate * ratio + mark.oldTranslate * ratioi;
            const newScale = mark.newScale * ratio + mark.oldScale * ratioi;
            this.set(newTranslate, newScale);
        }
        map(value) {
            return this._translate + this._scale * value;
        }
        mapAll(values, ifrom, iend, stride, offset) {
            const translate = this._translate;
            const scale = this._scale;
            for (let i = ifrom + offset; i < iend; i += stride) {
                values[i] = translate + scale * values[i];
            }
        }
        unmap(value) {
            return this._itranslate + this._iscale * value;
        }
        unmapAll(values, ifrom, iend, stride, offset) {
            const itranslate = this._itranslate;
            const iscale = this._iscale;
            for (let i = ifrom + offset; i < iend; i += stride) {
                values[i] = itranslate + iscale * values[i];
            }
        }
        toTheme(options) {
            return (options && options.theme) || this.getThemeDefault();
        }
        getThemeDefault() {
            return DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "DChartCoordinateTransform";
        }
    }

    class DChartCoordinateTransformMarkImpl {
        constructor() {
            this.oldTranslate = 0;
            this.oldScale = 1;
            this.newTranslate = 0;
            this.newScale = 1;
        }
        set(translate, scale) {
            if (translate != null) {
                this.newTranslate = translate;
            }
            if (scale != null) {
                this.newScale = scale;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartCoordinateBase {
        constructor(options) {
            this._id = 0;
            this._direction = DChartCoordinateDirection.X;
            this._theme = this.toTheme(options);
            this._transform = this.newTransform(options === null || options === void 0 ? void 0 : options.transform);
            this._tick = this.newTick(options === null || options === void 0 ? void 0 : options.tick);
            this._work = this.newRegion();
            this._mark = this.newMark();
            this._from = options === null || options === void 0 ? void 0 : options.from;
            this._to = options === null || options === void 0 ? void 0 : options.to;
        }
        newTransform(options) {
            return new DChartCoordinateTransformImpl(options);
        }
        newRegion() {
            return new DChartRegionImpl(NaN, NaN);
        }
        newMark() {
            return new DChartCoordinateTransformMarkImpl();
        }
        get from() {
            return this._from;
        }
        set from(from) {
            this._from = from;
        }
        get to() {
            return this._to;
        }
        set to(to) {
            this._to = to;
        }
        bind(container, direction) {
            this._container = container;
            this._direction = direction;
            this._transform.bind(container, direction);
        }
        unbind() {
            this._container = undefined;
            this._transform.unbind();
        }
        fit(from, to) {
            this.doFit(from, to, this._transform);
        }
        mark(from, to) {
            const mark = this._mark;
            const transform = this._transform;
            mark.oldTranslate = transform.translate;
            mark.oldScale = transform.scale;
            this.doFit(from, to, mark);
        }
        blend(ratio) {
            this._transform.blend(ratio, this._mark);
        }
        doFit(from, to, result) {
            const container = this._container;
            if (container) {
                const plotArea = container.container.plotArea;
                const work = this._work;
                switch (this._direction) {
                    case DChartCoordinateDirection.X:
                        this.getPixelDomain(plotArea, work);
                        this.doFit_(work.from, work.to, this.toFitDomain(from, to, plotArea, work), result);
                        break;
                    case DChartCoordinateDirection.Y:
                        this.getPixelRange(plotArea, work);
                        this.doFit_(work.from, work.to, this.toFitRange(from, to, plotArea, work), result);
                        break;
                }
            }
        }
        getPixelDomain(plotArea, result) {
            return plotArea.getPixelDomain(result);
        }
        getPixelRange(plotArea, result) {
            return plotArea.getPixelRange(result);
        }
        toFitDomain(from, to, plotArea, result) {
            if (from == null) {
                from = this._from;
            }
            if (to == null) {
                to = this._to;
            }
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getDomain(this, result);
                result.set(from, to);
            }
            return result;
        }
        toFitRange(from, to, plotArea, result) {
            if (from == null) {
                from = this._from;
            }
            if (to == null) {
                to = this._to;
            }
            if (from != null && to != null) {
                result.set(from, to);
            }
            else {
                plotArea.series.getRange(this, result);
                result.set(from, to);
            }
            return result;
        }
        doFit_(pixelFrom, pixelTo, region, result) {
            const regionFrom = region.from;
            const regionTo = region.to;
            if (!(isNaN$1(regionFrom) || isNaN$1(regionTo))) {
                // Scale
                let newScale = 1;
                const regionFromMapped = this.map(regionFrom);
                const regionToMapped = this.map(regionTo);
                const regionSizeMapped = regionToMapped - regionFromMapped;
                if (!this._theme.isZero(regionSizeMapped)) {
                    const pixelSize = pixelTo - pixelFrom;
                    newScale = pixelSize / regionSizeMapped;
                }
                else {
                    newScale = pixelTo < pixelFrom ? -1 : 1;
                }
                // Translation
                const newTranslation = pixelFrom - regionFromMapped * newScale;
                // Done
                result.set(newTranslation, newScale);
            }
        }
        get id() {
            return this._id;
        }
        get transform() {
            return this._transform;
        }
        map(value) {
            return value;
        }
        mapAll(values, ifrom, iend, stride, offset) {
            // DO NOTHING
        }
        unmap(value) {
            return value;
        }
        unmapAll(values, ifrom, iend, stride, offset) {
            // DO NOTHING
        }
        ticks(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult) {
            this._tick.calculate(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult, this);
        }
        toTheme(options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        }
        getThemeDefault() {
            return DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "DChartCoordinate";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartCoordinateContainerSubImpl {
        constructor(container, direction) {
            this._container = container;
            this._direction = direction;
            this._list = [];
        }
        get container() {
            return this._container;
        }
        add(coordinate, index) {
            const list = this._list;
            if (index == null) {
                list.push(coordinate);
            }
            else if (0 <= index && index < list.length) {
                list.splice(index, 0, coordinate);
            }
            else {
                list.push(coordinate);
            }
            coordinate.bind(this, this._direction);
            return this;
        }
        get(index) {
            const list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        }
        indexOf(coordinate) {
            return this._list.indexOf(coordinate);
        }
        remove(coordinateOrIndex) {
            const list = this._list;
            if (isNumber(coordinateOrIndex)) {
                const index = coordinateOrIndex;
                if (0 <= index && index < list.length) {
                    const removed = list.splice(index, 1)[0];
                    removed.unbind();
                    return removed;
                }
            }
            else {
                const coordinate = coordinateOrIndex;
                const index = list.indexOf(coordinate);
                if (0 <= index) {
                    list.splice(index, 1);
                    coordinate.unbind();
                    return coordinate;
                }
            }
            return null;
        }
        clear() {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].unbind();
            }
            list.length = 0;
            return this;
        }
        destroy() {
            return this.clear();
        }
        size() {
            return this._list.length;
        }
        fit(from, to) {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].fit(from, to);
            }
            return this;
        }
        mark(from, to) {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].mark(from, to);
            }
            return this;
        }
        blend(ratio) {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].blend(ratio);
            }
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartCoordinateContainerImpl {
        constructor(plotArea, options) {
            this._plotArea = plotArea;
            const x = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.X);
            this._x = x;
            const y = new DChartCoordinateContainerSubImpl(this, DChartCoordinateDirection.Y);
            this._y = y;
            if (options) {
                const cxs = options.x;
                if (cxs) {
                    if (isArray(cxs)) {
                        for (let i = 0, imax = cxs.length; i < imax; ++i) {
                            x.add(cxs[i]);
                        }
                    }
                    else {
                        x.add(cxs);
                    }
                }
                const cys = options.y;
                if (cys) {
                    if (isArray(cys)) {
                        for (let i = 0, imax = cys.length; i < imax; ++i) {
                            y.add(cys[i]);
                        }
                    }
                    else {
                        y.add(cys);
                    }
                }
            }
        }
        get x() {
            return this._x;
        }
        get y() {
            return this._y;
        }
        get plotArea() {
            return this._plotArea;
        }
        fit(domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.fit(domainFrom, domainTo);
            this._y.fit(rangeFrom, rangeTo);
            return this;
        }
        mark(domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.mark(domainFrom, domainTo);
            this._y.mark(rangeFrom, rangeTo);
            return this;
        }
        blend(ratio) {
            this._x.blend(ratio);
            this._y.blend(ratio);
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartCoordinateLinearTick {
        constructor(options) {
            this._theme = this.toTheme(options);
        }
        toMajorStep(domainMin, domainMax, majorCount, majorStep) {
            if (majorStep == null) {
                if (0 < majorCount) {
                    return this._theme.toStep(domainMin, domainMax, majorCount);
                }
                return -1;
            }
            else if (isNumber(majorStep)) {
                return majorStep;
            }
            else {
                return majorStep(domainMin, domainMax, majorCount);
            }
        }
        toMinorStep(majorStep, minorCount, minorStep) {
            if (minorStep == null) {
                if (0 <= majorStep) {
                    return this.calcStepMinor(majorStep, minorCount);
                }
                return -1;
            }
            else if (isNumber(minorStep)) {
                return minorStep;
            }
            else {
                return minorStep(majorStep, minorCount);
            }
        }
        calcStepMinor(majorStep, minorCount) {
            return majorStep / (minorCount + 1);
        }
        calcTickMinorPositions(step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (let i = 0; i < count; i += 1) {
                const minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        }
        calculate(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            const transform = coordinate.transform;
            const domainMin = Math.min(domainFrom, domainTo);
            const domainMax = Math.max(domainFrom, domainTo);
            const domainVisibleMin = Math.min(domainVisibleFrom, domainVisibleTo);
            const domainVisibleMax = Math.max(domainVisibleFrom, domainVisibleTo);
            const domainVisibleMinMapped = coordinate.map(domainVisibleMin);
            const domainVisibleMaxMapped = coordinate.map(domainVisibleMax);
            const from0 = Math.min(domainVisibleMinMapped, domainVisibleMaxMapped);
            const to0 = Math.max(domainVisibleMinMapped, domainVisibleMaxMapped);
            const domainMinMapped = coordinate.map(domainMin);
            const domainMaxMapped = coordinate.map(domainMax);
            const from1 = Math.min(domainMinMapped, domainMaxMapped);
            const to1 = Math.max(domainMinMapped, domainMaxMapped);
            const from = Math.max(from0, from1);
            const to = Math.min(to0, to1);
            let imajor = 0;
            let iminor = 0;
            const majorStepMapped = this.toMajorStep(domainMinMapped, domainMaxMapped, majorCount, majorStep);
            if (majorStepMapped <= 0) {
                if (from <= domainMinMapped && domainMinMapped <= to) {
                    majorResult[0] = domainMin;
                    majorResult[1] = transform.map(domainMinMapped);
                    majorResult[2] = 0;
                    imajor += 1;
                }
            }
            else {
                // Major tick start position
                const idomainStartMapped = Math.floor(domainMinMapped / majorStepMapped) - 1;
                const idomainEndMapped = Math.ceil(domainMaxMapped / majorStepMapped) + 1;
                // Major / minor tick positions
                const minorStepMapped = this.toMinorStep(majorStepMapped, minorCountPerMajor, minorStep);
                for (let i = idomainStartMapped; i <= idomainEndMapped; ++i) {
                    const majorPositionMapped = i * majorStepMapped;
                    if (imajor < majorCapacity) {
                        if (from <= majorPositionMapped && majorPositionMapped <= to) {
                            const imajorResult = imajor * 3;
                            majorResult[imajorResult + 0] = coordinate.unmap(majorPositionMapped);
                            majorResult[imajorResult + 1] = transform.map(majorPositionMapped);
                            majorResult[imajorResult + 2] = majorStepMapped;
                            imajor += 1;
                        }
                    }
                    for (let j = 0; j < minorCountPerMajor; j += 1) {
                        if (iminor < minorCount) {
                            const minorPositionMapped = majorPositionMapped + (j + 1) * minorStepMapped;
                            if (from <= minorPositionMapped && minorPositionMapped <= to) {
                                const iminorResult = iminor * 3;
                                minorResult[iminorResult + 0] = coordinate.unmap(minorPositionMapped);
                                minorResult[iminorResult + 1] = transform.map(minorPositionMapped);
                                minorResult[iminorResult + 2] = minorStepMapped;
                                iminor += 1;
                            }
                        }
                    }
                }
            }
            for (let i = imajor; i < majorCapacity; ++i) {
                const imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (let i = iminor; i < minorCount; ++i) {
                const iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        }
        toTheme(options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        }
        getThemeDefault() {
            return DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "DChartCoordinateTick";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartCoordinateLinear extends DChartCoordinateBase {
        newTick(options) {
            return new DChartCoordinateLinearTick(options);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartCoordinateLogTick {
        constructor(options) {
            this._theme = this.toTheme(options);
        }
        toMajorStep(domainMin, domainMax, majorCount, majorStep) {
            if (majorStep == null) {
                if (0 < majorCount) {
                    return this._theme.toStep(domainMin, domainMax, majorCount);
                }
                return -1;
            }
            else if (isNumber(majorStep)) {
                return majorStep;
            }
            else {
                return majorStep(domainMin, domainMax, majorCount);
            }
        }
        toMinorStep(majorStep, minorCount, minorStep) {
            if (minorStep == null) {
                if (0 <= majorStep) {
                    return this.calcStepMinor(majorStep, minorCount);
                }
                return -1;
            }
            else if (isNumber(minorStep)) {
                return minorStep;
            }
            else {
                return minorStep(majorStep, minorCount);
            }
        }
        calcStepMinor(majorStep, minorCount) {
            return majorStep / (minorCount + 1);
        }
        calcTickMinorPositions(step, count, majorPosition, rangeMin, rangeMax, iresult, result) {
            for (let i = 0; i < count; i += 1) {
                const minorPosition = majorPosition + (i + 1) * step;
                if (rangeMin <= minorPosition && minorPosition <= rangeMax) {
                    result[iresult++] = minorPosition;
                }
            }
        }
        calculate(domainFrom, domainTo, domainVisibleFrom, domainVisibleTo, majorCount, majorCapacity, majorStep, minorCountPerMajor, minorCount, minorStep, majorResult, minorResult, coordinate) {
            if (majorCount <= 0) {
                return;
            }
            const transform = coordinate.transform;
            const domainMin = Math.min(domainFrom, domainTo);
            const domainMax = Math.max(domainFrom, domainTo);
            const domainVisibleMin = Math.min(domainVisibleFrom, domainVisibleTo);
            const domainVisibleMax = Math.max(domainVisibleFrom, domainVisibleTo);
            const domainVisibleMinMapped = coordinate.map(domainVisibleMin);
            const domainVisibleMaxMapped = coordinate.map(domainVisibleMax);
            const from0 = Math.min(domainVisibleMinMapped, domainVisibleMaxMapped);
            const to0 = Math.max(domainVisibleMinMapped, domainVisibleMaxMapped);
            const domainMinMapped = coordinate.map(domainMin);
            const domainMaxMapped = coordinate.map(domainMax);
            const from1 = Math.min(domainMinMapped, domainMaxMapped);
            const to1 = Math.max(domainMinMapped, domainMaxMapped);
            const from = Math.max(from0, from1);
            const to = Math.min(to0, to1);
            let imajor = 0;
            let iminor = 0;
            const majorStepMapped = this.toMajorStep(domainMinMapped, domainMaxMapped, majorCount, majorStep);
            if (majorStepMapped <= 0) {
                if (from <= domainMinMapped && domainMinMapped <= to) {
                    majorResult[0] = domainMin;
                    majorResult[1] = transform.map(domainMinMapped);
                    majorResult[2] = 0;
                    imajor += 1;
                }
            }
            else {
                // Major tick start position
                const idomainStartMapped = Math.floor(domainMinMapped / majorStepMapped) - 1;
                const idomainEndMapped = Math.ceil(domainMaxMapped / majorStepMapped) + 1;
                // Major / minor tick positions
                const minorStepMapped = this.toMinorStep(majorStepMapped, minorCountPerMajor, minorStep);
                for (let i = idomainStartMapped; i <= idomainEndMapped; ++i) {
                    const majorPositionMapped = i * majorStepMapped;
                    if (imajor < majorCapacity) {
                        if (from <= majorPositionMapped && majorPositionMapped <= to) {
                            const imajorResult = imajor * 3;
                            majorResult[imajorResult + 0] = coordinate.unmap(majorPositionMapped);
                            majorResult[imajorResult + 1] = transform.map(majorPositionMapped);
                            majorResult[imajorResult + 2] = coordinate.unmap(majorPositionMapped - 1);
                            imajor += 1;
                        }
                    }
                    for (let j = 0; j < minorCountPerMajor; j += 1) {
                        if (iminor < minorCount) {
                            const minorPositionMapped = majorPositionMapped + (j + 1) * minorStepMapped;
                            if (from <= minorPositionMapped && minorPositionMapped <= to) {
                                const iminorResult = iminor * 3;
                                minorResult[iminorResult + 0] = coordinate.unmap(minorPositionMapped);
                                minorResult[iminorResult + 1] = transform.map(minorPositionMapped);
                                minorResult[iminorResult + 2] = coordinate.unmap(minorPositionMapped - 1);
                                iminor += 1;
                            }
                        }
                    }
                }
            }
            for (let i = imajor; i < majorCapacity; ++i) {
                const imajorResult = i * 3;
                majorResult[imajorResult + 0] = NaN;
                majorResult[imajorResult + 1] = NaN;
                majorResult[imajorResult + 2] = NaN;
            }
            for (let i = iminor; i < minorCount; ++i) {
                const iminorResult = i * 3;
                minorResult[iminorResult + 0] = NaN;
                minorResult[iminorResult + 1] = NaN;
                minorResult[iminorResult + 2] = NaN;
            }
        }
        toTheme(options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.theme) !== null && _a !== void 0 ? _a : this.getThemeDefault();
        }
        getThemeDefault() {
            return DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "DChartCoordinateTick";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartCoordinateLog extends DChartCoordinateBase {
        newTick(options) {
            return new DChartCoordinateLogTick(options);
        }
        map(value) {
            return Math.log(Math.max(0, value)) / Math.LN10;
        }
        mapAll(values, ifrom, iend, stride, offset) {
            const factor = 1 / Math.LN10;
            for (let i = ifrom + offset; i < iend; i += stride) {
                const value = values[i];
                values[i] = Math.log(Math.max(0, value)) * factor;
            }
        }
        unmap(value) {
            return Math.pow(10, value);
        }
        unmapAll(values, ifrom, iend, stride, offset) {
            for (let i = ifrom + offset; i < iend; i += stride) {
                values[i] = Math.pow(10, values[i]);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartLegendItem extends DBase {
        getType() {
            return "DChartLegendItem";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartLegend extends DBase {
        getType() {
            return "DChartLegend";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartOverview extends DBase {
        getType() {
            return "DChartOverview";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaBase extends DBase {
        constructor(chart, options) {
            super(options);
            this._isContainerBoundsDirty = true;
            this._containerBounds = new pixi_js.Rectangle();
            this._workPoint = new pixi_js.Point();
            this._pixelBounds = new pixi_js.Rectangle();
            this._chart = chart;
            this._blendStartTime = 0;
            this._blendDuration = 1000;
            this._blendTimeout = null;
            this._onBlendBound = () => {
                this.onBlend();
            };
            this._isViewDirty = true;
            this._view = this.newView(options);
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            this._isViewDirty = true;
            this._isContainerBoundsDirty = true;
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
        }
        get chart() {
            return this._chart;
        }
        get view() {
            return this._view;
        }
        onWheel(e, deltas, global) {
            const vresult = this._view.onWheel(e, deltas, global);
            const sresult = super.onWheel(e, deltas, global);
            return vresult || sresult;
        }
        onDblClick(e, interactionManager) {
            const vresult = this._view.onDblClick(e, interactionManager);
            const sresult = super.onDblClick(e, interactionManager);
            return vresult || sresult;
        }
        onDown(e) {
            this._view.onDown(e);
            super.onDown(e);
        }
        render(renderer) {
            if (this._isViewDirty) {
                this._isViewDirty = false;
                this.onViewDirty();
            }
            super.render(renderer);
        }
        getPixelDomain(result) {
            const padding = this.padding;
            return result.set(padding.getLeft(), this.width - padding.getRight());
        }
        getPixelRange(result) {
            const padding = this.padding;
            return result.set(this.height - padding.getBottom(), padding.getTop());
        }
        getPixelBounds() {
            const result = this._pixelBounds;
            result.x = 0;
            result.y = 0;
            result.width = this.width;
            result.height = this.height;
            return result;
        }
        getAxisBounds(position) {
            return this.getPixelBounds();
        }
        getSelectionBoundsX() {
            return this.getPixelBounds();
        }
        getSelectionBoundsY() {
            return this.getPixelBounds();
        }
        getContainerBounds() {
            const result = this._containerBounds;
            if (this._isContainerBoundsDirty) {
                this._isContainerBoundsDirty = false;
                const container = this.container;
                container.updateTransform();
                const transform = container.transform.localTransform;
                const work = this._workPoint;
                work.set(0, 0);
                transform.applyInverse(work, work);
                result.x = work.x;
                result.y = work.y;
                work.set(this.width, this.height);
                transform.applyInverse(work, work);
                result.width = work.x - result.x;
                result.height = work.y - result.y;
            }
            return result;
        }
        getType() {
            return "DChartPlotArea";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaContainer extends EShapeContainer {
        constructor(onChange) {
            super();
            const transform = this.transform;
            this._position = new DBasePoint(transform.position, onChange);
            this._scale = new DBasePoint(transform.scale, onChange);
            this._workRect = new pixi_js.Rectangle();
        }
        // @ts-ignore
        get position() {
            return this._position;
        }
        // @ts-ignore
        get scale() {
            return this._scale;
        }
        getBounds(skipUpdate, rect) {
            this._lastBoundsID = -1;
            return super.getBounds(skipUpdate, rect);
        }
        calculateBounds() {
            const bounds = this._bounds;
            const work = this._work;
            const rect = this._workRect;
            const worldTransform = this.transform.worldTransform;
            let xmin = 0;
            let xmax = 0;
            let ymin = 0;
            let ymax = 0;
            const children = this.children;
            if (0 < children.length) {
                let isFirst = true;
                for (let i = 0, imax = children.length; i < imax; ++i) {
                    const child = children[i];
                    if (child.visible) {
                        child.getBoundsInternal(false, rect);
                        if (isFirst) {
                            isFirst = false;
                            xmin = rect.x;
                            ymin = rect.y;
                            xmax = rect.x + rect.width;
                            ymax = rect.y + rect.height;
                        }
                        else {
                            xmin = Math.min(xmin, rect.x);
                            ymin = Math.min(ymin, rect.y);
                            xmax = Math.max(xmax, rect.x + rect.width);
                            ymax = Math.max(ymax, rect.y + rect.height);
                        }
                    }
                }
            }
            bounds.clear();
            work.set(xmin, ymin);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
            work.set(xmax, ymax);
            worldTransform.apply(work, work);
            bounds.addPoint(work);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesHitResult {
        constructor() {
            this.shape = null;
            this.x = 0;
            this.y = 0;
            this.p0x = 0;
            this.p0y = 0;
            this.p1x = 0;
            this.p1y = 0;
            this.index = 0;
            this.t = 0;
            this.distance = 0;
        }
        copyFrom(other) {
            this.shape = other.shape;
            this.x = other.x;
            this.y = other.y;
            this.p0x = other.p0x;
            this.p0y = other.p0y;
            this.p1x = other.p1x;
            this.p1y = other.p1y;
            this.index = other.index;
            this.t = other.t;
            this.distance = other.distance;
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesFillComputedImpl {
        constructor(enable, color, alpha) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
        }
        static from(base, index, fill) {
            var _a, _b, _c;
            return new DChartSeriesFillComputedImpl((_a = fill === null || fill === void 0 ? void 0 : fill.enable) !== null && _a !== void 0 ? _a : base.enable(index), (_b = fill === null || fill === void 0 ? void 0 : fill.color) !== null && _b !== void 0 ? _b : base.color(index), (_c = fill === null || fill === void 0 ? void 0 : fill.alpha) !== null && _c !== void 0 ? _c : base.alpha(index));
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesScalars {
        static from(value, def) {
            if (isArray(value)) {
                return (index) => value[index % value.length];
            }
            else if (isFunction(value)) {
                return value;
            }
            else if (value != null) {
                return () => value;
            }
            else if (isArray(def)) {
                return (index) => def[index % def.length];
            }
            else if (isFunction(def)) {
                return def;
            }
            else {
                return () => def;
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesFillImpl {
        constructor(options) {
            this.enable = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.enable, true);
            this.color = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.alpha, EShapeDefaults.FILL_ALPHA);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesPaddingComputedImpl {
        constructor(outer, inner) {
            this.outer = outer;
            this.inner = inner;
        }
        static from(base, index, point) {
            var _a, _b;
            return new DChartSeriesPaddingComputedImpl((_a = point === null || point === void 0 ? void 0 : point.outer) !== null && _a !== void 0 ? _a : base.outer(index), (_b = point === null || point === void 0 ? void 0 : point.inner) !== null && _b !== void 0 ? _b : base.inner(index));
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesPaddingImpl {
        constructor(options) {
            this.outer = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.outer, 0.2);
            this.inner = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.inner, 0.1);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesPointComputedImpl {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        static from(base, index, point, x, y) {
            var _a, _b;
            return new DChartSeriesPointComputedImpl((_a = point === null || point === void 0 ? void 0 : point.x) !== null && _a !== void 0 ? _a : (base.x != null ? base.x(index) : x), (_b = point === null || point === void 0 ? void 0 : point.y) !== null && _b !== void 0 ? _b : (base.y != null ? base.y(index) : y));
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesPointImpl {
        constructor(options) {
            if (options) {
                if (options.x != null) {
                    this.x = DChartSeriesScalars.from(options.x, 0);
                }
                if (options.y != null) {
                    this.y = DChartSeriesScalars.from(options.y, 0);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesStrokeComputedImpl {
        constructor(enable, color, alpha, width, align, side, style) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
            this.width = width;
            this.align = align;
            this.side = side;
            this.style = style;
        }
        static from(base, index, stroke) {
            var _a, _b, _c, _d, _e, _f, _g;
            return new DChartSeriesStrokeComputedImpl((_a = stroke === null || stroke === void 0 ? void 0 : stroke.enable) !== null && _a !== void 0 ? _a : base.enable(index), (_b = stroke === null || stroke === void 0 ? void 0 : stroke.color) !== null && _b !== void 0 ? _b : base.color(index), (_c = stroke === null || stroke === void 0 ? void 0 : stroke.alpha) !== null && _c !== void 0 ? _c : base.alpha(index), (_d = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _d !== void 0 ? _d : base.width(index), (_e = stroke === null || stroke === void 0 ? void 0 : stroke.align) !== null && _e !== void 0 ? _e : base.align(index), (_f = stroke === null || stroke === void 0 ? void 0 : stroke.side) !== null && _f !== void 0 ? _f : base.side(index), (_g = stroke === null || stroke === void 0 ? void 0 : stroke.style) !== null && _g !== void 0 ? _g : base.style(index));
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesStrokeImpl {
        constructor(options) {
            this.enable = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.enable, true);
            this.color = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.color, DChartColorSet2);
            this.alpha = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.alpha, EShapeDefaults.STROKE_ALPHA);
            this.width = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.width, EShapeDefaults.STROKE_WIDTH);
            this.align = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.width, EShapeDefaults.STROKE_ALIGN);
            this.side = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.side, EShapeStrokeSide.ALL);
            this.style = DChartSeriesScalars.from(options === null || options === void 0 ? void 0 : options.style, EShapeStrokeStyle.NON_SCALING);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesContainerImpl {
        constructor(plotArea, options) {
            this._plotArea = plotArea;
            this._domain = new DChartRegionImpl(NaN, NaN);
            this._range = new DChartRegionImpl(NaN, NaN);
            this._selection = null;
            this._fill = new DChartSeriesFillImpl(options === null || options === void 0 ? void 0 : options.fill);
            this._stroke = new DChartSeriesStrokeImpl(options === null || options === void 0 ? void 0 : options.stroke);
            this._size = new DChartSeriesPointImpl(options === null || options === void 0 ? void 0 : options.size);
            this._offset = new DChartSeriesPointImpl(options === null || options === void 0 ? void 0 : options.offset);
            this._padding = new DChartSeriesPaddingImpl(options === null || options === void 0 ? void 0 : options.padding);
            this._list = [];
        }
        newFill(index, options) {
            return DChartSeriesFillComputedImpl.from(this._fill, index, options);
        }
        newStroke(index, options) {
            return DChartSeriesStrokeComputedImpl.from(this._stroke, index, options);
        }
        newSize(index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._size, index, options, x, y);
        }
        newOffset(index, options, x, y) {
            return DChartSeriesPointComputedImpl.from(this._offset, index, options, x, y);
        }
        newPadding(index, options) {
            return DChartSeriesPaddingComputedImpl.from(this._padding, index, options);
        }
        get plotArea() {
            return this._plotArea;
        }
        get selection() {
            return this._selection;
        }
        set selection(selection) {
            this._selection = selection;
        }
        update() {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].update();
            }
            const selection = this._selection;
            if (selection) {
                selection.update();
            }
        }
        onRender() {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].onRender();
            }
            const selection = this._selection;
            if (selection) {
                selection.onRender();
            }
        }
        add(series) {
            const list = this._list;
            series.bind(this, list.length);
            list.push(series);
        }
        get(index) {
            const list = this._list;
            if (0 <= index && index < list.length) {
                return list[index];
            }
            return null;
        }
        indexOf(series) {
            return this._list.indexOf(series);
        }
        clear() {
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                list[i].destroy();
            }
            list.length = 0;
            return this;
        }
        size() {
            return this._list.length;
        }
        destroy() {
            this.clear();
            const selection = this._selection;
            if (selection) {
                selection.unbind();
            }
        }
        getDomain(coordinate, result) {
            result.clear();
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                const series = list[i];
                if (series.coordinate.x === coordinate) {
                    const domain = series.domain;
                    result.add(domain.from, domain.to);
                }
            }
            return result;
        }
        getRange(coordinate, result) {
            result.clear();
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                const series = list[i];
                if (series.coordinate.y === coordinate) {
                    const range = series.range;
                    result.add(range.from, range.to);
                }
            }
            return result;
        }
        get domain() {
            const result = this._domain;
            result.clear();
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                const domain = list[i].domain;
                result.add(domain.from, domain.to);
            }
            return result;
        }
        get range() {
            const result = this._range;
            result.clear();
            const list = this._list;
            for (let i = 0, imax = list.length; i < imax; ++i) {
                const range = list[i].range;
                result.add(range.from, range.to);
            }
            return result;
        }
        hitTest(x, y) {
            const list = this._list;
            for (let i = list.length - 1; 0 <= i; --i) {
                const series = list[i];
                if (series.hitTest(x, y)) {
                    return series;
                }
            }
            return null;
        }
        calcHitPoint(x, y, result) {
            let tmp1 = result;
            let tmp2 = DChartSeriesContainerImpl.WORK_CALCHITPOINT;
            const list = this._list;
            let closest = null;
            tmp2.distance = +Infinity;
            for (let i = list.length - 1; 0 <= i; --i) {
                const series = list[i];
                if (series.calcHitPoint(x, y, tmp1)) {
                    if (tmp1.distance < tmp2.distance) {
                        closest = series;
                        const tmp = tmp1;
                        tmp1 = tmp2;
                        tmp2 = tmp;
                    }
                }
            }
            if (closest && tmp2 !== result) {
                result.copyFrom(tmp2);
            }
            return closest;
        }
    }
    DChartSeriesContainerImpl.WORK_CALCHITPOINT = new DChartSeriesHitResult();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaOnefold extends DChartPlotAreaBase {
        constructor(chart, options) {
            var _a;
            super(chart, options);
            // Container
            const container = new DChartPlotAreaContainer(() => {
                this._isViewDirty = true;
                this._isContainerBoundsDirty = true;
                DApplications.update(this);
            });
            this._container = container;
            this.addChild(container);
            // Overflow mask
            const mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : this.theme.isOverflowMaskEnabled();
            if (mask) {
                container.mask = this.getOverflowMask();
            }
            // View
            this._isViewDirty = true;
            this._view = new DViewImpl(this, () => container, options === null || options === void 0 ? void 0 : options.view);
            // Coordinate
            this._coordinate = new DChartCoordinateContainerImpl(this, options === null || options === void 0 ? void 0 : options.coordinate);
            // Series
            const seriesOptions = options === null || options === void 0 ? void 0 : options.series;
            const series = new DChartSeriesContainerImpl(this, seriesOptions);
            this._series = series;
            // Axis
            const axisOptions = options === null || options === void 0 ? void 0 : options.axis;
            const axis = new DChartAxisContainerImpl(this, new EShapeContainer(), axisOptions);
            this._axis = axis;
            this.addChild(axis.container);
            // Add series
            this.addSeries(series, seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.list);
            // Add axes
            this.addAxes(axis, axisOptions === null || axisOptions === void 0 ? void 0 : axisOptions.list);
            // Selection
            const selection = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.selection;
            if (selection != null) {
                series.selection = selection;
                selection.bind(series);
            }
        }
        getOverflowMask() {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        }
        addSeries(series, list) {
            if (list != null) {
                const listLength = list.length;
                if (0 < listLength) {
                    for (let i = 0; i < listLength; ++i) {
                        series.add(list[i]);
                    }
                    series.update();
                }
            }
        }
        addAxes(axis, list) {
            if (list != null) {
                for (let i = 0, imax = list.length; i < imax; ++i) {
                    axis.add(list[i]);
                }
            }
        }
        get coordinate() {
            return this._coordinate;
        }
        get series() {
            return this._series;
        }
        get container() {
            return this._container;
        }
        get axis() {
            return this._axis;
        }
        newView(options) {
            return new DViewImpl(this, () => this._container, options === null || options === void 0 ? void 0 : options.view);
        }
        onViewDirty() {
            this._coordinate.fit();
            this._axis.onRender();
            this._series.onRender();
        }
        fit(duration, domainFrom, domainTo, rangeFrom, rangeTo) {
            const coordinate = this._coordinate;
            const axis = this._axis;
            const series = this._series;
            if (duration != null && duration <= 0) {
                coordinate.fit(domainFrom, domainTo, rangeFrom, rangeTo);
                axis.update();
                series.update();
            }
            else {
                this._blendDuration = duration != null ? duration : 200;
                this._blendStartTime = Date.now();
                coordinate.mark(domainFrom, domainTo, rangeFrom, rangeTo);
                const blendTimeout = this._blendTimeout;
                if (blendTimeout != null) {
                    window.clearTimeout(blendTimeout);
                }
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            return this;
        }
        onBlend() {
            const now = Date.now();
            let ratio = (now - this._blendStartTime) / this._blendDuration;
            if (ratio < 1) {
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            else {
                this._blendTimeout = null;
                ratio = 1;
            }
            this._coordinate.blend(DAnimationTimings.ELASTIC(ratio));
            this._axis.update();
            this._series.update();
        }
        destroy() {
            this._container.destroy();
            this._series.destroy();
            this._axis.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofoldAxisContainer {
        constructor(plotArea, container, primary, secondary) {
            this._plotArea = plotArea;
            this._container = container;
            this._list = new Map();
            this._primary = primary;
            this._secondary = secondary;
        }
        get container() {
            return this._container;
        }
        get plotArea() {
            return this._plotArea;
        }
        add(axis) {
            const list = this._list;
            let axes = list.get(axis.position);
            if (axes == null) {
                axes = [];
                list.set(axis.position, axes);
            }
            axes.push(axis);
            axis.bind(this, axes.length - 1);
        }
        get(position, index) {
            const primary = this._primary;
            const primarySize = primary.size(position);
            if (0 <= index && index < primarySize) {
                return primary.get(position, index);
            }
            const secondary = this._secondary;
            const secondarySize = secondary.size(position);
            if (primarySize <= index && index < primarySize + secondarySize) {
                return secondary.get(position, index - primarySize);
            }
            const list = this._list;
            const axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                if (primarySize + secondarySize <= index &&
                    index < primarySize + secondarySize + axes.length) {
                    return axes[index - primarySize - secondarySize];
                }
            }
            return null;
        }
        indexOf(axis) {
            const primary = this._primary;
            let result = primary.indexOf(axis);
            if (0 <= result) {
                return result;
            }
            const secondary = this._secondary;
            result = secondary.indexOf(axis);
            if (0 <= result) {
                return primary.size(axis.position) + result;
            }
            const list = this._list;
            const axes = list.get(axis.position);
            if (axes) {
                return primary.size(axis.position) + secondary.size(axis.position) + axes.indexOf(axis);
            }
            return -1;
        }
        clear(position) {
            this._primary.clear(position);
            this._secondary.clear(position);
            const list = this._list;
            const axes = list.get(toEnum(position, DChartAxisPosition));
            if (axes) {
                for (let i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            }
            return this;
        }
        size(position) {
            const list = this._list;
            const axes = list.get(toEnum(position, DChartAxisPosition));
            return (this._primary.size(position) +
                this._secondary.size(position) +
                (axes != null ? axes.length : 0));
        }
        update() {
            this._primary.update();
            this._secondary.update();
            this._list.forEach((axes) => {
                for (let i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].update();
                }
            });
        }
        onRender() {
            this._primary.onRender();
            this._secondary.onRender();
            this._list.forEach((axes) => {
                for (let i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].onRender();
                }
            });
        }
        destroy() {
            this._primary.destroy();
            this._secondary.destroy();
            this._list.forEach((axes) => {
                for (let i = 0, imax = axes.length; i < imax; ++i) {
                    axes[i].destroy();
                }
                axes.length = 0;
            });
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofoldCoorinateContainerSub {
        constructor(container, primary, secondary) {
            this._container = container;
            this._primary = primary;
            this._secondary = secondary;
        }
        get container() {
            return this._container;
        }
        add(coordinate, index) {
            if (index != null) {
                const primary = this._primary;
                const primarySize = primary.size();
                if (index < primarySize) {
                    if (0 <= index) {
                        primary.add(coordinate, index);
                    }
                }
                else {
                    this._secondary.add(coordinate, index - primarySize);
                }
                return this;
            }
            else {
                this._secondary.add(coordinate);
            }
            return this;
        }
        get(index) {
            const primary = this._primary;
            const primarySize = primary.size();
            if (0 <= index && index < primarySize) {
                return primary.get(index);
            }
            const secondary = this._secondary;
            const secondarySize = secondary.size();
            if (primarySize <= index && index < primarySize + secondarySize) {
                return secondary.get(index - primarySize);
            }
            return null;
        }
        indexOf(coordinate) {
            const primary = this._primary;
            let result = primary.indexOf(coordinate);
            if (0 <= result) {
                return result;
            }
            result = this._secondary.indexOf(coordinate);
            if (0 <= result) {
                return primary.size() + result;
            }
            return -1;
        }
        remove(coordinateOrIndex) {
            if (isNumber(coordinateOrIndex)) {
                const index = coordinateOrIndex;
                const primary = this._primary;
                const primarySize = primary.size();
                if (0 <= index && index < primarySize) {
                    return primary.remove(index);
                }
                const secondary = this._secondary;
                const secondarySize = secondary.size();
                if (primarySize <= index && index < primarySize + secondarySize) {
                    return secondary.remove(index - primarySize);
                }
            }
            else {
                const coordinate = coordinateOrIndex;
                let result = this._primary.remove(coordinate);
                if (result != null) {
                    return result;
                }
                result = this._secondary.remove(coordinate);
                if (result != null) {
                    return result;
                }
            }
            return null;
        }
        clear() {
            this._primary.clear();
            this._secondary.clear();
            return this;
        }
        destroy() {
            return this.clear();
        }
        size() {
            return this._primary.size() + this._secondary.size();
        }
        fit(from, to) {
            this._primary.fit(from, to);
            this._secondary.fit(from, to);
            return this;
        }
        mark(from, to) {
            this._primary.mark(from, to);
            this._secondary.mark(from, to);
            return this;
        }
        blend(ratio) {
            this._primary.blend(ratio);
            this._secondary.blend(ratio);
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofoldCoorinateContainer {
        constructor(plotArea, primary, secondary) {
            this._plotArea = plotArea;
            this._primary = primary;
            this._secondary = secondary;
            this._x = new DChartPlotAreaTwofoldCoorinateContainerSub(this, primary.x, secondary.x);
            this._y = new DChartPlotAreaTwofoldCoorinateContainerSub(this, primary.y, secondary.y);
        }
        get x() {
            return this._x;
        }
        get y() {
            return this._y;
        }
        get plotArea() {
            return this._plotArea;
        }
        fit(domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.fit(domainFrom, domainTo);
            this._y.fit(rangeFrom, rangeTo);
            return this;
        }
        mark(domainFrom, domainTo, rangeFrom, rangeTo) {
            this._x.mark(domainFrom, domainTo);
            this._y.mark(rangeFrom, rangeTo);
            return this;
        }
        blend(ratio) {
            this._x.blend(ratio);
            this._y.blend(ratio);
            return this;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofoldOverflowMaskPrimary extends DBaseOverflowMaskSimple {
        onReflow(base, width, height) {
            if (this._isInitialized && this._width === width && this._height === height) {
                return;
            }
            this._isInitialized = true;
            this._width = width;
            this._height = height;
            const hh = height * 0.5;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.drawRect(0, 0, width, hh);
            this.endFill();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofoldOverflowMaskSecondary extends DBaseOverflowMaskSimple {
        onReflow(base, width, height) {
            if (this._isInitialized && this._width === width && this._height === height) {
                return;
            }
            this._isInitialized = true;
            this._width = width;
            this._height = height;
            const hh = height * 0.5;
            this.clear();
            this.beginFill(0xffffff, 1);
            this.drawRect(0, hh, width, hh);
            this.endFill();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofoldSeriesContainer {
        constructor(plotArea, primary, secondary) {
            this._plotArea = plotArea;
            this._primary = primary;
            this._secondary = secondary;
            this._domain = new DChartRegionImpl(NaN, NaN);
            this._range = new DChartRegionImpl(NaN, NaN);
        }
        newFill(index, options) {
            return this._secondary.newFill(index, options);
        }
        newStroke(index, options) {
            return this._secondary.newStroke(index, options);
        }
        newSize(index, options, x, y) {
            return this._secondary.newSize(index, options, x, y);
        }
        newOffset(index, options, x, y) {
            return this._secondary.newOffset(index, options, x, y);
        }
        newPadding(index, options) {
            return this._secondary.newPadding(index, options);
        }
        get plotArea() {
            return this._plotArea;
        }
        get selection() {
            return this._secondary.selection;
        }
        update() {
            this._primary.update();
            this._secondary.update();
            const selection = this._secondary.selection;
            if (selection) {
                selection.update();
            }
        }
        onRender() {
            this._primary.onRender();
            this._secondary.onRender();
            const selection = this._secondary.selection;
            if (selection) {
                selection.onRender();
            }
        }
        add(series) {
            this._secondary.add(series);
        }
        get(index) {
            const primary = this._primary;
            const primarySize = primary.size();
            if (0 <= index && index < primarySize) {
                return primary.get(index);
            }
            const secondary = this._secondary;
            const secondarySize = secondary.size();
            if (primarySize <= index && index < primarySize + secondarySize) {
                return secondary.get(index - primarySize);
            }
            return null;
        }
        indexOf(series) {
            const primary = this._primary;
            let result = primary.indexOf(series);
            if (0 <= result) {
                return result;
            }
            result = this._secondary.indexOf(series);
            if (0 <= result) {
                return primary.size() + result;
            }
            return -1;
        }
        clear() {
            this._primary.clear();
            this._secondary.clear();
            return this;
        }
        size() {
            return this._primary.size() + this._secondary.size();
        }
        destroy() {
            this.clear();
            const selection = this._secondary.selection;
            if (selection) {
                selection.unbind();
            }
        }
        getDomain(coordinate, result) {
            this._primary.getDomain(coordinate, result);
            const from = result.from;
            const to = result.to;
            this._secondary.getDomain(coordinate, result);
            result.add(from, to);
            return result;
        }
        getRange(coordinate, result) {
            result.clear();
            this._primary.getRange(coordinate, result);
            const from = result.from;
            const to = result.to;
            this._secondary.getRange(coordinate, result);
            result.add(from, to);
            return result;
        }
        get domain() {
            const result = this._domain;
            result.clear();
            const pdomain = this._primary.domain;
            result.add(pdomain.from, pdomain.to);
            const sdomain = this._secondary.domain;
            result.add(sdomain.from, sdomain.to);
            return result;
        }
        get range() {
            const result = this._domain;
            result.clear();
            const prange = this._primary.range;
            result.add(prange.from, prange.to);
            const srange = this._secondary.range;
            result.add(srange.from, srange.to);
            return result;
        }
        hitTest(x, y) {
            const result = this._secondary.hitTest(x, y);
            if (result != null) {
                return result;
            }
            return this._primary.hitTest(x, y);
        }
        calcHitPoint(x, y, result) {
            var _a;
            const result1 = result;
            const result2 = ((_a = DChartPlotAreaTwofoldSeriesContainer.WORK_CALCHITPOINT) !== null && _a !== void 0 ? _a : (DChartPlotAreaTwofoldSeriesContainer.WORK_CALCHITPOINT = new DChartSeriesHitResult()));
            const series2 = this._secondary.calcHitPoint(x, y, result2);
            const series1 = this._primary.calcHitPoint(x, y, result1);
            if (series1 != null) {
                if (series2 != null) {
                    if (result1.distance <= result2.distance) {
                        return series1;
                    }
                    else {
                        result1.copyFrom(result2);
                        return series2;
                    }
                }
                else {
                    return series1;
                }
            }
            else {
                if (series2 != null) {
                    result1.copyFrom(result2);
                    return series2;
                }
                else {
                    return null;
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofoldSubBase {
        constructor(plotArea, onContainerChange, mask, margin, axisShapeContainer, options) {
            this._isContainerBoundsDirty = true;
            this._containerBounds = new pixi_js.Rectangle();
            this._workPoint = new pixi_js.Point();
            this._margin = margin;
            this._plotArea = plotArea;
            // Container
            const container = new DChartPlotAreaContainer(onContainerChange);
            this._container = container;
            // Coordinate
            this._coordinate = new DChartCoordinateContainerImpl(this, options === null || options === void 0 ? void 0 : options.coordinate);
            // Overflow mask
            if (mask) {
                container.mask = this.getOverflowMask();
            }
            // Series
            this._series = new DChartSeriesContainerImpl(this, options === null || options === void 0 ? void 0 : options.series);
            // Axis
            this._axis = new DChartAxisContainerImpl(this, axisShapeContainer, options === null || options === void 0 ? void 0 : options.axis);
        }
        get plotArea() {
            return this._plotArea;
        }
        get chart() {
            return this._plotArea.chart;
        }
        get container() {
            return this._container;
        }
        get series() {
            return this._series;
        }
        get coordinate() {
            return this._coordinate;
        }
        get axis() {
            return this._axis;
        }
        get state() {
            return this._plotArea.state;
        }
        get view() {
            return this._plotArea.view;
        }
        // eslint-disable-next-line @typescript-eslint/ban-types
        on(name, callback, context) {
            this._plotArea.on(name, callback, context);
            return this;
        }
        // eslint-disable-next-line @typescript-eslint/ban-types
        off(name, callback, context) {
            this._plotArea.off(name, callback, context);
            return this;
        }
        getPixelDomain(result) {
            const plotArea = this._plotArea;
            const padding = plotArea.padding;
            const width = plotArea.width;
            return result.set(padding.getLeft(), width - padding.getRight());
        }
        getAxisBounds(position) {
            return this.getPixelBounds();
        }
        getSelectionBoundsX() {
            return this.getPixelBounds();
        }
        getSelectionBoundsY() {
            return this.getPixelBounds();
        }
        toBoundsDirty() {
            this._isContainerBoundsDirty = true;
        }
        toLocal(position, from, result, skipUpdate) {
            return this._plotArea.toLocal(position, from, result, skipUpdate);
        }
        destroy() {
            this._container.destroy();
            this._series.destroy();
            this._axis.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofoldSubPrimary extends DChartPlotAreaTwofoldSubBase {
        getOverflowMask() {
            if (this._overflowMask == null) {
                const plotArea = this._plotArea;
                this._overflowMask = new DChartPlotAreaTwofoldOverflowMaskPrimary(plotArea);
                plotArea.reflowable.add(this._overflowMask);
                plotArea.toDirty();
            }
            return this._overflowMask;
        }
        getPixelRange(result) {
            const plotArea = this._plotArea;
            const padding = plotArea.padding;
            const paddingTop = padding.getTop();
            const height = plotArea.height;
            return result.set((height - this._margin) * 0.5, paddingTop);
        }
        getPixelBounds() {
            const result = this._plotArea.getPixelBounds();
            result.height *= 0.5;
            return result;
        }
        getContainerBounds() {
            const result = this._containerBounds;
            if (this._isContainerBoundsDirty) {
                this._isContainerBoundsDirty = false;
                const bounds = this._plotArea.getContainerBounds();
                result.width = bounds.width;
                result.height = bounds.height * 0.5;
                result.x = bounds.x;
                result.y = bounds.y;
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofoldSubSecondary extends DChartPlotAreaTwofoldSubBase {
        getOverflowMask() {
            if (this._overflowMask == null) {
                const plotArea = this._plotArea;
                this._overflowMask = new DChartPlotAreaTwofoldOverflowMaskSecondary(plotArea);
                plotArea.reflowable.add(this._overflowMask);
                plotArea.toDirty();
            }
            return this._overflowMask;
        }
        getPixelRange(result) {
            const plotArea = this._plotArea;
            const padding = plotArea.padding;
            const paddingBottom = padding.getBottom();
            const height = plotArea.height;
            return result.set(height - paddingBottom, (height + this._margin) * 0.5);
        }
        getPixelBounds() {
            const result = this._plotArea.getPixelBounds();
            result.height *= 0.5;
            result.y = result.height;
            return result;
        }
        getContainerBounds() {
            const result = this._containerBounds;
            if (this._isContainerBoundsDirty) {
                this._isContainerBoundsDirty = false;
                const bounds = this._plotArea.getContainerBounds();
                result.width = bounds.width;
                result.height = bounds.height * 0.5;
                result.x = bounds.x;
                result.y = bounds.y + result.height;
            }
            return result;
        }
    }

    class DChartPlotAreaTwofoldViewTargetPoint {
        constructor(primary, secondary) {
            this._primary = primary;
            this._secondary = secondary;
        }
        get x() {
            return this._secondary.x;
        }
        set x(x) {
            this._primary.x = x;
            this._secondary.x = x;
        }
        get y() {
            return this._secondary.y;
        }
        set y(y) {
            this._primary.y = y;
            this._secondary.y = y;
        }
        set(x, y) {
            this._primary.set(x, y);
            this._secondary.set(x, y);
            return this;
        }
    }
    class DChartPlotAreaTwofoldViewTarget {
        constructor(primary, secondary) {
            this._primary = primary;
            this._secondary = secondary;
            this._scale = new DChartPlotAreaTwofoldViewTargetPoint(primary.scale, secondary.scale);
            this._position = new DChartPlotAreaTwofoldViewTargetPoint(primary.position, secondary.position);
        }
        get scale() {
            return this._scale;
        }
        get position() {
            return this._position;
        }
        getLocalBounds(rect) {
            this._primary.getLocalBounds(rect);
            const x1 = rect.x;
            const y1 = rect.y;
            const w1 = rect.width;
            const h1 = rect.height;
            this._secondary.getLocalBounds(rect);
            const x2 = rect.x;
            const y2 = rect.y;
            const w2 = rect.width;
            const h2 = rect.height;
            const x3 = Math.min(x1, x2);
            const y3 = Math.min(y1, y2);
            const x4 = Math.max(x1 + w1, x2 + w2);
            const y4 = Math.max(y1 + h1, y2 + h2);
            rect.x = x3;
            rect.y = y3;
            rect.width = x4 - x3;
            rect.height = y4 - y3;
            return rect;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartPlotAreaTwofold extends DChartPlotAreaBase {
        constructor(chart, options) {
            var _a, _b, _c, _d, _e, _f, _g;
            super(chart, options);
            // Margin
            const theme = this.theme;
            const margin = (_a = options === null || options === void 0 ? void 0 : options.margin) !== null && _a !== void 0 ? _a : theme.getMargin();
            this._margin = margin;
            // Primary
            const axisShapeContainer = new EShapeContainer();
            const onContainerChangeBound = () => {
                this.onContainerChange();
            };
            const mask = (_b = options === null || options === void 0 ? void 0 : options.mask) !== null && _b !== void 0 ? _b : theme.isOverflowMaskEnabled();
            const primaryOptions = options === null || options === void 0 ? void 0 : options.primary;
            const primary = new DChartPlotAreaTwofoldSubPrimary(this, onContainerChangeBound, mask, margin, axisShapeContainer, primaryOptions);
            this._primary = primary;
            // Secondary
            const secondaryOptions = options === null || options === void 0 ? void 0 : options.secondary;
            const secondary = new DChartPlotAreaTwofoldSubSecondary(this, onContainerChangeBound, mask, margin, axisShapeContainer, secondaryOptions);
            this._secondary = secondary;
            // Container
            this.addChild(primary.container);
            this.addChild(secondary.container);
            // Coordinate
            this._coordinate = new DChartPlotAreaTwofoldCoorinateContainer(this, primary.coordinate, secondary.coordinate);
            // Series
            const primarySeries = primary.series;
            const secondarySeries = secondary.series;
            const series = new DChartPlotAreaTwofoldSeriesContainer(this, primarySeries, secondarySeries);
            this._series = series;
            // Axis
            const primaryAxis = primary.axis;
            const secondaryAxis = secondary.axis;
            this.addChild(axisShapeContainer);
            const axis = new DChartPlotAreaTwofoldAxisContainer(this, axisShapeContainer, primaryAxis, secondaryAxis);
            this._axis = axis;
            // Add Series
            this.addSeries(primarySeries, (_c = primaryOptions === null || primaryOptions === void 0 ? void 0 : primaryOptions.series) === null || _c === void 0 ? void 0 : _c.list);
            this.addSeries(secondarySeries, (_d = secondaryOptions === null || secondaryOptions === void 0 ? void 0 : secondaryOptions.series) === null || _d === void 0 ? void 0 : _d.list);
            // Add Axes
            this.addAxes(primaryAxis, (_e = primaryOptions === null || primaryOptions === void 0 ? void 0 : primaryOptions.axis) === null || _e === void 0 ? void 0 : _e.list);
            this.addAxes(secondaryAxis, (_f = secondaryOptions === null || secondaryOptions === void 0 ? void 0 : secondaryOptions.axis) === null || _f === void 0 ? void 0 : _f.list);
            this.addAxes(axis, (_g = options === null || options === void 0 ? void 0 : options.axis) === null || _g === void 0 ? void 0 : _g.list);
            // Selection
            const selection = options === null || options === void 0 ? void 0 : options.selection;
            if (selection != null) {
                primarySeries.selection = selection;
                secondarySeries.selection = selection;
                selection.bind(series);
            }
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            this._primary.toBoundsDirty();
            this._secondary.toBoundsDirty();
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
        }
        addSeries(series, list) {
            if (list != null) {
                const listLength = list.length;
                if (0 < listLength) {
                    for (let i = 0; i < listLength; ++i) {
                        series.add(list[i]);
                    }
                    series.update();
                }
            }
        }
        addAxes(axis, list) {
            if (list != null) {
                for (let i = 0, imax = list.length; i < imax; ++i) {
                    axis.add(list[i]);
                }
            }
        }
        get primary() {
            return this._primary;
        }
        get secondary() {
            return this._secondary;
        }
        get container() {
            return this.secondary.container;
        }
        onContainerChange() {
            this._isViewDirty = true;
            this._isContainerBoundsDirty = true;
            this._primary.toBoundsDirty();
            this._secondary.toBoundsDirty();
            DApplications.update(this);
        }
        get coordinate() {
            return this._coordinate;
        }
        get series() {
            return this._series;
        }
        get axis() {
            return this._axis;
        }
        newView(options) {
            let viewTarget;
            const toViewTarget = () => {
                return (viewTarget !== null && viewTarget !== void 0 ? viewTarget : (viewTarget = new DChartPlotAreaTwofoldViewTarget(this._primary.container, this._secondary.container)));
            };
            return new DViewImpl(this, toViewTarget, options === null || options === void 0 ? void 0 : options.view);
        }
        onViewDirty() {
            this._coordinate.fit();
            this._axis.onRender();
            this._series.onRender();
        }
        fit(duration, domainFrom, domainTo, rangeFrom, rangeTo) {
            if (duration != null && duration <= 0) {
                const primary = this.primary;
                primary.coordinate.fit(domainFrom, domainTo, rangeFrom, rangeTo);
                primary.axis.update();
                primary.series.update();
                const secondary = this.secondary;
                secondary.coordinate.fit(domainFrom, domainTo, rangeFrom, rangeTo);
                secondary.axis.update();
                secondary.series.update();
            }
            else {
                this._blendDuration = duration != null ? duration : 200;
                this._blendStartTime = Date.now();
                this.primary.coordinate.mark(domainFrom, domainTo, rangeFrom, rangeTo);
                this.secondary.coordinate.mark(domainFrom, domainTo, rangeFrom, rangeTo);
                const blendTimeout = this._blendTimeout;
                if (blendTimeout != null) {
                    window.clearTimeout(blendTimeout);
                }
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            return this;
        }
        onBlend() {
            const now = Date.now();
            let ratio = (now - this._blendStartTime) / this._blendDuration;
            if (ratio < 1) {
                this._blendTimeout = window.setTimeout(this._onBlendBound, 0);
            }
            else {
                this._blendTimeout = null;
                ratio = 1;
            }
            const t = DAnimationTimings.ELASTIC(ratio);
            const primary = this.primary;
            primary.coordinate.blend(t);
            primary.axis.update();
            primary.series.update();
            const secondary = this.secondary;
            secondary.coordinate.blend(t);
            secondary.axis.update();
            secondary.series.update();
        }
        destroy() {
            var _a, _b;
            (_a = this._primary) === null || _a === void 0 ? void 0 : _a.destroy();
            (_b = this._secondary) === null || _b === void 0 ? void 0 : _b.destroy();
            this._axis.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartRegionImplObservable {
        constructor(from, to, onChange) {
            this._from = from;
            this._to = to;
            this._onChange = onChange;
        }
        get from() {
            return this._from;
        }
        set from(from) {
            this.set(from, undefined);
        }
        get to() {
            return this._to;
        }
        set to(to) {
            this.set(undefined, to);
        }
        set(from, to) {
            let isChanged = false;
            if (from != null && this._from !== from) {
                if (!isNaN$1(this._from) || !isNaN$1(from)) {
                    this._from = from;
                    isChanged = true;
                }
            }
            if (to != null && this._to !== to) {
                if (!isNaN$1(this._to) || !isNaN$1(to)) {
                    this._to = to;
                    isChanged = true;
                }
            }
            if (isChanged) {
                this._onChange();
            }
            return this;
        }
        add(from, to) {
            let newFrom;
            if (!isNaN$1(from)) {
                newFrom = isNaN$1(this.from) ? from : Math.min(this.from, from);
            }
            let newTo;
            if (!isNaN$1(to)) {
                newTo = isNaN$1(this.to) ? to : Math.max(this.to, to);
            }
            return this.set(newFrom, newTo);
        }
        clear() {
            return this.set(NaN, NaN);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSelectionContainerImpl {
        constructor(x, y) {
            this._x = x;
            this._y = y;
        }
        get x() {
            return this._x;
        }
        get y() {
            return this._y;
        }
        bind(container) {
            this._x.bind(container);
            this._y.bind(container);
        }
        unbind() {
            this._x.unbind();
            this._y.unbind();
        }
        set(container, position, mappedPosition, series) {
            this._x.set(container, position, mappedPosition, series);
            this._y.set(container, position, mappedPosition, series);
        }
        unset() {
            this._x.unset();
            this._y.unset();
        }
        update(container, position, mappedPosition, series) {
            const isXUpdated = this._x.update(container, position, mappedPosition, series);
            const isYUpdated = this._y.update(container, position, mappedPosition, series);
            return isXUpdated || isYUpdated;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSelectionShapeBase {
        constructor(options) {
            var _a, _b, _c;
            const theme = this.toTheme(options);
            this._theme = theme;
            const state = new DBaseStateSetImpl().add((_a = options === null || options === void 0 ? void 0 : options.state) !== null && _a !== void 0 ? _a : DBaseState.HOVERED);
            this._state = state;
            this._isEnabled = (_b = options === null || options === void 0 ? void 0 : options.enable) !== null && _b !== void 0 ? _b : theme.isEnabled(state);
            if (options != null) {
                const shape = options.shape;
                if (shape != null) {
                    if (isFunction(shape)) {
                        this._newShape = shape;
                    }
                    else {
                        this._shape = shape;
                    }
                }
            }
            this._style = (_c = options === null || options === void 0 ? void 0 : options.style) !== null && _c !== void 0 ? _c : this.setStyle;
        }
        bind(container) {
            if (this._isEnabled) {
                let shape = this._shape;
                if (shape == null) {
                    const state = this._state;
                    const newShape = this._newShape;
                    if (newShape != null) {
                        shape = newShape(state);
                    }
                    else {
                        shape = this.newShape(state, this._theme);
                    }
                }
                this._shape = shape;
                shape.attach(container.plotArea.axis.container);
                shape.visible = false;
            }
        }
        unbind() {
            const shape = this._shape;
            if (shape) {
                shape.detach();
            }
        }
        newShape(state, theme) {
            return theme.newShape(state);
        }
        set(container, position, mappedPosition, series) {
            this.update(container, position, mappedPosition, series);
            const shape = this._shape;
            if (shape != null) {
                this._style(shape, series);
            }
        }
        setStyle(shape, series) {
            // DO NOTHING
        }
        unset() {
            const shape = this._shape;
            if (shape) {
                shape.visible = false;
            }
        }
        toTheme(options) {
            const theme = options === null || options === void 0 ? void 0 : options.theme;
            if (isString(theme)) {
                return this.getTheme(theme);
            }
            else if (theme != null) {
                return theme;
            }
            else {
                return this.getTheme(this.getType());
            }
        }
        getTheme(type) {
            return DThemes.getInstance().get(type);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSelectionGridlineX extends DChartSelectionShapeBase {
        update(container, position, mappedPosition, series) {
            const shape = this._shape;
            if (shape) {
                const mappedX = mappedPosition.x;
                const bounds = container.plotArea.getSelectionBoundsX();
                shape.transform.position.set(mappedX, bounds.y + bounds.height * 0.5);
                shape.size.set(0, bounds.height);
                const hw = shape.stroke.width * 0.5;
                shape.visible = bounds.x <= mappedX + hw && mappedX - hw <= bounds.x + bounds.width;
                return true;
            }
            return false;
        }
        getType() {
            return "DChartSelectionGridlineX";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSelectionGridlineY extends DChartSelectionShapeBase {
        update(container, position, mappedPosition, series) {
            const shape = this._shape;
            if (shape) {
                const mappedY = mappedPosition.y;
                const bounds = container.plotArea.getSelectionBoundsY();
                shape.transform.position.set(bounds.x + bounds.width * 0.5, mappedY);
                shape.size.set(bounds.width, 0);
                const hw = shape.stroke.width * 0.5;
                shape.visible = bounds.y <= mappedY + hw && mappedY - hw <= bounds.y + bounds.height;
                return true;
            }
            return false;
        }
        getType() {
            return "DChartSelectionGridlineY";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSelectionMarker extends DChartSelectionShapeBase {
        update(container, position, mappedPosition, series) {
            const shape = this._shape;
            if (shape) {
                shape.transform.position.copyFrom(mappedPosition);
                shape.visible = this.isVisible(container, position, mappedPosition, series);
                return true;
            }
            return false;
        }
        isVisible(container, position, mappedPosition, series) {
            container = (series === null || series === void 0 ? void 0 : series.container) || container;
            const x = mappedPosition.x;
            const y = mappedPosition.y;
            const bounds = container.plotArea.getPixelBounds();
            return (bounds.x <= x &&
                x <= bounds.x + bounds.width &&
                bounds.y <= y &&
                y <= bounds.y + bounds.height);
        }
        getType() {
            return "DChartSelectionMarker";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DChartSelectionPoint = {
        PREVIOUS: 0,
        NEXT: 1,
        CLOSER: 2,
        INTERSECTION: 3
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSelectionSubImpl extends pixi_js.utils.EventEmitter {
        constructor(options) {
            var _a, _b, _c;
            super();
            this._container = null;
            this._series = null;
            this._isEnabled = (_a = options.enable) !== null && _a !== void 0 ? _a : true;
            this._isVisible = false;
            const gridline = options.gridline;
            if (gridline != null) {
                this._gridline = new DChartSelectionContainerImpl(new DChartSelectionGridlineX(gridline.x), new DChartSelectionGridlineY(gridline.y));
            }
            else {
                this._gridline = new DChartSelectionContainerImpl(new DChartSelectionGridlineX(), new DChartSelectionGridlineY());
            }
            this._marker = new DChartSelectionMarker(options.marker);
            this._state = (_b = options.state) !== null && _b !== void 0 ? _b : DBaseState.HOVERED;
            this._coordinateX = null;
            this._coordinateY = null;
            this._position = new pixi_js.Point();
            this._point = (_c = options.point) !== null && _c !== void 0 ? _c : DChartSelectionPoint.CLOSER;
            this._work = new pixi_js.Point();
            // Events
            const on = options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        bind(container) {
            if (this._isEnabled) {
                this._container = container;
                this._gridline.bind(container);
                this._marker.bind(container);
            }
        }
        unbind() {
            this._marker.unbind();
            this._gridline.unbind();
            this._container = null;
            this._coordinateX = null;
            this._coordinateY = null;
        }
        get visible() {
            return this._isVisible;
        }
        get series() {
            return this._series;
        }
        get position() {
            return this._position;
        }
        get gridline() {
            return this._gridline;
        }
        get marker() {
            return this._marker;
        }
        set(series, result) {
            if (isNumber(series)) {
                this.set1(series, result);
            }
            else {
                this.set2(series, result);
            }
        }
        set1(x, y) {
            const container = this._container;
            if (container == null) {
                return;
            }
            const work = this._work;
            work.set(x, y);
            const plotArea = container.plotArea;
            plotArea.container.toLocal(work, undefined, work, true);
            const coordinate = plotArea.coordinate;
            let coordinateX = coordinate.x.get(0);
            let coordinateY = coordinate.y.get(0);
            let newPositionX = work.x;
            let newPositionY = work.y;
            if (coordinateX && coordinateY) {
                newPositionX = coordinateX.unmap(coordinateX.transform.unmap(newPositionX));
                newPositionY = coordinateY.unmap(coordinateY.transform.unmap(newPositionY));
            }
            else {
                coordinateX = null;
                coordinateY = null;
            }
            const oldSeries = this._series;
            const position = this._position;
            if (this._isVisible &&
                oldSeries == null &&
                newPositionX === position.x &&
                newPositionY === position.y) {
                return;
            }
            this._isVisible = true;
            position.set(newPositionX, newPositionY);
            this._coordinateX = coordinateX;
            this._coordinateY = coordinateY;
            plotArea.container.localTransform.apply(work, work);
            this._gridline.set(container, position, work, null);
            this._marker.set(container, position, work, null);
            if (oldSeries != null) {
                const state = this._state;
                if (oldSeries) {
                    oldSeries.state.remove(state);
                }
                this._series = null;
            }
            this.emit("change", this);
            DApplications.update(plotArea);
        }
        set2(series, result) {
            const container = this._container;
            if (container == null) {
                return;
            }
            const work = this._work;
            let x = result.x;
            let y = result.y;
            switch (this._point) {
                case DChartSelectionPoint.PREVIOUS:
                    x = result.p0x;
                    y = result.p0y;
                    break;
                case DChartSelectionPoint.NEXT:
                    x = result.p1x;
                    y = result.p1y;
                    break;
                case DChartSelectionPoint.CLOSER:
                    if (Math.abs(result.p0x - result.x) < Math.abs(result.p1x - result.x)) {
                        x = result.p0x;
                        y = result.p0y;
                    }
                    else {
                        x = result.p1x;
                        y = result.p1y;
                    }
            }
            work.set(x, y);
            const plotArea = container.plotArea;
            plotArea.container.localTransform.apply(work, work);
            let coordinateX = series.coordinate.x;
            let coordinateY = series.coordinate.y;
            let newPositionX = x;
            let newPositionY = y;
            if (coordinateX && coordinateY) {
                newPositionX = coordinateX.unmap(coordinateX.transform.unmap(newPositionX));
                newPositionY = coordinateY.unmap(coordinateY.transform.unmap(newPositionY));
            }
            else {
                coordinateX = null;
                coordinateY = null;
            }
            const oldSeries = this._series;
            const position = this._position;
            if (this._isVisible &&
                oldSeries === series &&
                newPositionX === position.x &&
                newPositionY === position.y) {
                return;
            }
            this._isVisible = true;
            position.set(newPositionX, newPositionY);
            this._coordinateX = coordinateX;
            this._coordinateY = coordinateY;
            this._gridline.set(container, position, work, series);
            this._marker.set(container, position, work, series);
            if (oldSeries !== series) {
                const state = this._state;
                if (oldSeries) {
                    oldSeries.state.remove(state);
                }
                this._series = series;
                series.state.add(state);
            }
            this.emit("change", this);
            DApplications.update(plotArea);
        }
        unset() {
            const container = this._container;
            if (container == null) {
                return;
            }
            const oldSeries = this._series;
            if (!this._isVisible && oldSeries == null) {
                return;
            }
            this._isVisible = false;
            this._coordinateX = null;
            this._coordinateY = null;
            this._gridline.unset();
            this._marker.unset();
            if (oldSeries != null) {
                this._series = null;
                oldSeries.state.remove(this._state);
            }
            this.emit("change", this);
            DApplications.update(container.plotArea);
        }
        update() {
            const container = this._container;
            if (container == null) {
                return false;
            }
            if (!this._isVisible) {
                return false;
            }
            const position = this._position;
            const work = this._work;
            const coordinateX = this._coordinateX;
            const coordinateY = this._coordinateY;
            if (coordinateX && coordinateY) {
                work.set(coordinateX.transform.map(coordinateX.map(position.x)), coordinateY.transform.map(coordinateY.map(position.y)));
            }
            else {
                work.copyFrom(position);
            }
            container.plotArea.container.localTransform.apply(work, work);
            const series = this._series;
            const isGridlineUpdated = this._gridline.update(container, position, work, series);
            const isMarkerUpdated = this._marker.update(container, position, work, series);
            return isGridlineUpdated || isMarkerUpdated;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSelectionSimple extends pixi_js.utils.EventEmitter {
        constructor(options) {
            var _a;
            super();
            this._container = null;
            const point = toEnum((_a = options === null || options === void 0 ? void 0 : options.point) !== null && _a !== void 0 ? _a : DChartSelectionPoint.CLOSER, DChartSelectionPoint);
            this._selected = this.newSelected(point, options === null || options === void 0 ? void 0 : options.selected);
            this._hovered = this.newHovered(point, options === null || options === void 0 ? void 0 : options.hovered);
            this._dismiss = this.toDismiss(options);
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
            this._onMoveBound = (e) => {
                this.onMove(e);
            };
            this._onTapBound = (target, e) => {
                this.onTap(e);
            };
            this._onLongPressBound = (target, e) => {
                this.onLongPress(e);
            };
        }
        toDismiss(options) {
            var _a;
            if (options != null) {
                const dismiss = options.dismiss;
                if (dismiss != null) {
                    return {
                        enable: (_a = dismiss.enable) !== null && _a !== void 0 ? _a : true,
                        tap: this.toDismissTap(dismiss.tap),
                        longPress: this.toDismissLongPress(dismiss.longPress),
                        noSeries: this.toDismissNoSeries(dismiss.noSeries)
                    };
                }
            }
            return {
                enable: true,
                tap: this.toDismissTap(),
                longPress: this.toDismissLongPress(),
                noSeries: this.toDismissNoSeries()
            };
        }
        toDismissTap(options) {
            var _a, _b;
            return {
                enable: (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : true,
                modifier: toEnum((_b = options === null || options === void 0 ? void 0 : options.modifier) !== null && _b !== void 0 ? _b : UtilGestureModifier.NOT_NONE, UtilGestureModifier)
            };
        }
        toDismissLongPress(options) {
            var _a;
            return {
                enable: (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : true
            };
        }
        toDismissNoSeries(options) {
            var _a;
            return {
                enable: (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : true
            };
        }
        newSelected(point, options) {
            return new DChartSelectionSubImpl(this.toSelectedOptions(point, options));
        }
        newHovered(point, options) {
            return new DChartSelectionSubImpl(this.toHoveredOptions(point, options));
        }
        toSelectedOptions(point, options) {
            return this.toSubOptions(point, options, DBaseState.ACTIVE);
        }
        toHoveredOptions(point, options) {
            return this.toSubOptions(point, options, DBaseState.HOVERED);
        }
        toSubOptions(point, options, state) {
            var _a, _b, _c, _d, _e, _f, _g;
            options = options || {};
            if (options.point == null) {
                options.point = point;
            }
            if (options.state == null) {
                options.state = state;
            }
            const gridline = ((_a = options.gridline) !== null && _a !== void 0 ? _a : (options.gridline = {}));
            const gridlineX = ((_b = gridline.x) !== null && _b !== void 0 ? _b : (gridline.x = {}));
            if (gridlineX.state == null) {
                gridlineX.state = state;
            }
            const gridlineY = ((_c = gridline.y) !== null && _c !== void 0 ? _c : (gridline.y = {}));
            if (gridlineY.state == null) {
                gridlineY.state = state;
            }
            const marker = ((_d = options.marker) !== null && _d !== void 0 ? _d : (options.marker = {}));
            if (marker.state == null) {
                marker.state = state;
            }
            const label = ((_e = options.label) !== null && _e !== void 0 ? _e : (options.label = {}));
            const labelX = ((_f = label.x) !== null && _f !== void 0 ? _f : (label.x = {}));
            if (labelX.state == null) {
                labelX.state = state;
            }
            const labelY = ((_g = label.y) !== null && _g !== void 0 ? _g : (label.y = {}));
            if (labelY.state == null) {
                labelY.state = state;
            }
            return options;
        }
        onTap(e) {
            const container = this._container;
            if (container == null) {
                return;
            }
            const dismiss = this._dismiss;
            const selected = this._selected;
            if (dismiss.enable &&
                dismiss.tap.enable &&
                UtilGestureModifiers.match(e, dismiss.tap.modifier)) {
                selected.unset();
            }
            else {
                const result = DChartSelectionSimple.WORK_SELECT;
                const global = e.data.global;
                const series = container.calcHitPoint(global.x, global.y, result);
                if (series != null) {
                    selected.set(series, result);
                }
                else {
                    if (dismiss.enable && dismiss.noSeries.enable) {
                        selected.unset();
                    }
                    else {
                        selected.set(global.x, global.y);
                    }
                }
            }
        }
        onLongPress(e) {
            const container = this._container;
            if (container == null) {
                return;
            }
            const dismiss = this._dismiss;
            if (dismiss.enable && dismiss.longPress.enable) {
                this._selected.unset();
            }
        }
        onMove(e) {
            const container = this._container;
            if (container == null) {
                return;
            }
            const plotArea = container.plotArea;
            if (plotArea.state.isGesturing) {
                return;
            }
            const hovered = this._hovered;
            if (e.target === container.plotArea) {
                const result = DChartSelectionSimple.WORK_SELECT;
                const global = e.data.global;
                const series = container.calcHitPoint(global.x, global.y, result);
                if (series != null) {
                    hovered.set(series, result);
                }
                else {
                    hovered.unset();
                }
            }
            else {
                hovered.unset();
            }
        }
        bind(container) {
            this._container = container;
            this._selected.bind(container);
            this._hovered.bind(container);
            const plotArea = container.plotArea;
            const plotAreaView = plotArea.view;
            plotArea.on(UtilPointerEvent.move, this._onMoveBound);
            plotAreaView.on("gesturetap", this._onTapBound);
            plotAreaView.on("gesturelongpress", this._onLongPressBound);
        }
        unbind() {
            const container = this._container;
            this._container = null;
            if (container != null) {
                const plotArea = container.plotArea;
                const plotAreaView = plotArea.view;
                plotArea.off(UtilPointerEvent.move, this._onMoveBound);
                plotAreaView.off("gesturetap", this._onTapBound);
                plotAreaView.off("gesturelongpress", this._onLongPressBound);
            }
            this._selected.unbind();
            this._hovered.unbind();
        }
        get selected() {
            return this._selected;
        }
        get hovered() {
            return this._hovered;
        }
        update() {
            const isSelectedUpdated = this._selected.update();
            const isHoveredUpdated = this._hovered.update();
            if (isSelectedUpdated || isHoveredUpdated) {
                const container = this._container;
                if (container != null) {
                    DApplications.update(container.plotArea);
                }
            }
        }
        onRender() {
            this._selected.update();
            this._hovered.update();
        }
    }
    DChartSelectionSimple.WORK_SELECT = new DChartSeriesHitResult();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesBaseCoordinateContainer {
        constructor(parent, options) {
            var _a, _b;
            this._parent = parent;
            this._coordinateIndexX = (_a = options === null || options === void 0 ? void 0 : options.x) !== null && _a !== void 0 ? _a : 0;
            this._coordinateIndexY = (_b = options === null || options === void 0 ? void 0 : options.y) !== null && _b !== void 0 ? _b : 0;
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
            this._coordinateTransformIdUpdatedX = NaN;
            this._coordinateTransformIdUpdatedY = NaN;
        }
        get x() {
            const container = this._parent.container;
            if (container) {
                return container.plotArea.coordinate.x.get(this._coordinateIndexX);
            }
            return null;
        }
        set x(coordinate) {
            const index = this.toIndexX(coordinate);
            if (this._coordinateIndexX !== index) {
                this._coordinateIndexX = index;
                this._coordinateIdUpdatedX = NaN;
                this._coordinateTransformIdUpdatedX = NaN;
            }
        }
        toIndexX(target) {
            if (isNumber(target)) {
                return target;
            }
            else if (target != null) {
                const container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.x.indexOf(target);
                }
            }
            return -1;
        }
        get y() {
            const container = this._parent.container;
            if (container) {
                return container.plotArea.coordinate.y.get(this._coordinateIndexY);
            }
            return null;
        }
        set y(coordinate) {
            const index = this.toIndexY(coordinate);
            if (this._coordinateIndexY !== index) {
                this._coordinateIndexY = index;
                this._coordinateIdUpdatedY = NaN;
                this._coordinateTransformIdUpdatedY = NaN;
            }
        }
        toIndexY(target) {
            if (isNumber(target)) {
                return target;
            }
            else if (target != null) {
                const container = this._parent.container;
                if (container) {
                    return container.plotArea.coordinate.y.indexOf(target);
                }
            }
            return -1;
        }
        isDirty(coordinateX, coordinateY) {
            const coordinateIdX = coordinateX.id;
            const coordinateIdY = coordinateY.id;
            const isCoordinateXChanged = coordinateIdX !== this._coordinateIdUpdatedX;
            const isCoordinateYChanged = coordinateIdY !== this._coordinateIdUpdatedY;
            this._coordinateIdUpdatedX = coordinateIdX;
            this._coordinateIdUpdatedY = coordinateIdY;
            return isCoordinateXChanged || isCoordinateYChanged;
        }
        isTransformDirty(coordinateX, coordinateY) {
            const coordinateTransformIdX = coordinateX.transform.id;
            const coordinateTransformIdY = coordinateY.transform.id;
            const isCoordinateTransformXChanged = coordinateTransformIdX !== this._coordinateTransformIdUpdatedX;
            const isCoordinateTransformYChanged = coordinateTransformIdY !== this._coordinateTransformIdUpdatedY;
            this._coordinateTransformIdUpdatedX = coordinateTransformIdX;
            this._coordinateTransformIdUpdatedY = coordinateTransformIdY;
            return isCoordinateTransformXChanged || isCoordinateTransformYChanged;
        }
        reset() {
            this._coordinateIdUpdatedX = NaN;
            this._coordinateIdUpdatedY = NaN;
        }
        destroy() {
            this.reset();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     */
    class DChartSeriesBase extends pixi_js.utils.EventEmitter {
        constructor(options) {
            super();
            this._coordinate = new DChartSeriesBaseCoordinateContainer(this, options === null || options === void 0 ? void 0 : options.coordinate);
            this._index = 0;
            this._domain = new DChartRegionImpl(NaN, NaN);
            this._range = new DChartRegionImpl(NaN, NaN);
            this._regionPointId = NaN;
            this._isShown = true;
            this._state = new DBaseStateSetImplObservable((newState, oldState) => {
                this.onStateChange(newState, oldState);
            });
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on != null) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        bind(container, index) {
            this._container = container;
            this._coordinate.reset();
            this._index = index;
            const chart = container.plotArea.chart;
            if (chart) {
                this._state.parent = chart.state;
            }
            return this;
        }
        unbind() {
            this._container = undefined;
            return this;
        }
        get domain() {
            this.updateRegion();
            return this._domain;
        }
        get range() {
            this.updateRegion();
            return this._range;
        }
        get container() {
            return this._container || null;
        }
        get index() {
            return this._index;
        }
        get coordinate() {
            return this._coordinate;
        }
        get state() {
            return this._state;
        }
        show() {
            if (this._isShown !== true) {
                this._isShown = true;
                this.onShow();
            }
            return this;
        }
        onShow() {
            const shape = this.shape;
            if (shape != null) {
                shape.visible = true;
            }
        }
        isShown() {
            return this._isShown;
        }
        hide() {
            if (this._isShown !== false) {
                this._isShown = false;
                this.onHide();
            }
            return this;
        }
        onHide() {
            const shape = this.shape;
            if (shape != null) {
                shape.visible = false;
            }
        }
        isHidden() {
            return !this._isShown;
        }
        destroy() {
            this._container = undefined;
            this._coordinate.destroy();
            return this;
        }
        hitTest(x, y) {
            return false;
        }
        calcHitPoint(x, y, result) {
            return false;
        }
        onStateChange(newState, oldState) {
            var _a;
            this.toDirty();
            const chart = (_a = this._container) === null || _a === void 0 ? void 0 : _a.plotArea.chart;
            DApplications.update(chart);
            this.emit("statechange", newState, oldState, this);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of anything.
     * Data points must be sorted in ascending order on the X axis.
     */
    class DChartSeriesLineOfAny extends DChartSeriesBase {
        constructor(options) {
            var _a;
            super(options);
            this._line = null;
            this._options = options;
            this._points = (_a = options === null || options === void 0 ? void 0 : options.points) !== null && _a !== void 0 ? _a : [];
            this._pointId = 0;
            this._pointIdUpdated = NaN;
        }
        getSizeDefault() {
            return 10;
        }
        getOffsetDefault() {
            return 0;
        }
        bind(container, index) {
            let line = this._line;
            if (!line) {
                line = this._line = this.newLineOfAny();
                line.visible = this._isShown;
                const options = this._options;
                this.initLine(line, options, container, index);
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            super.bind(container, index);
            return this;
        }
        initLine(line, options, container, index) {
            const fill = container.newFill(index, options === null || options === void 0 ? void 0 : options.fill);
            this._fill = fill;
            line.fill.copy(fill);
            const stroke = container.newStroke(index, options === null || options === void 0 ? void 0 : options.stroke);
            this._stroke = stroke;
            line.stroke.copy(stroke);
            const sizeDefault = this.getSizeDefault();
            const size = container.newSize(index, options === null || options === void 0 ? void 0 : options.size, sizeDefault, sizeDefault);
            this._size = size;
            line.points.size.set(size.x, size.y);
            const offsetDefault = this.getOffsetDefault();
            const offset = container.newOffset(index, options && options.offset, offsetDefault, offsetDefault);
            this._offset = offset;
            line.points.offset.set(offset.x, offset.y);
        }
        unbind() {
            const line = this._line;
            if (line) {
                line.detach();
            }
            super.unbind();
            return this;
        }
        get shape() {
            return this._line;
        }
        get points() {
            return this._points;
        }
        set points(points) {
            this._points = points;
            this._pointId += 1;
        }
        toDirty() {
            this._pointId += 1;
            return this;
        }
        update() {
            this.doUpdate(true);
            return this;
        }
        onRender() {
            this.doUpdate(false);
            return this;
        }
        doUpdate(render) {
            const line = this._line;
            if (line) {
                const coordinate = this._coordinate;
                const coordinateX = coordinate.x;
                const coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    const pointId = this._pointId;
                    const isPointChanged = pointId !== this._pointIdUpdated;
                    const isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    const isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.doUpdateLine(line, coordinateX, coordinateY);
                        if (render) {
                            DApplications.update(line);
                        }
                        return true;
                    }
                }
            }
            return false;
        }
        doUpdateLine(line, xcoordinate, ycoordinate) {
            const values = line.points.values;
            const valuesLength = values.length;
            let ivalues = 0;
            const points = this._points;
            let xmin = NaN;
            let xmax = NaN;
            let ymin = NaN;
            let ymax = NaN;
            for (let i = 0, imax = points.length; i < imax; i += 2) {
                const x = points[i];
                const y = points[i + 1];
                if (x != null && y != null) {
                    if (ivalues < valuesLength) {
                        values[ivalues] = x;
                        values[ivalues + 1] = y;
                    }
                    else {
                        values.push(x, y);
                    }
                    ivalues += 2;
                    if (xmin !== xmin) {
                        xmin = x;
                        xmax = x;
                        ymin = y;
                        ymax = y;
                    }
                    else {
                        xmin = Math.min(xmin, x);
                        xmax = Math.max(xmax, x);
                        ymin = Math.min(ymin, y);
                        ymax = Math.max(ymax, y);
                    }
                }
            }
            if (values.length !== ivalues) {
                values.length = ivalues;
            }
            xcoordinate.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.mapAll(values, 0, ivalues, 2, 1);
            xcoordinate.transform.mapAll(values, 0, ivalues, 2, 0);
            ycoordinate.transform.mapAll(values, 0, ivalues, 2, 1);
            if (xmin !== xmin) {
                xmin = 0;
                xmax = 0;
                ymin = 0;
                ymax = 0;
            }
            const region = DChartSeriesLineOfAny.WORK_REGION || {
                xmin: 0,
                xmax: 0,
                ymin: 0,
                ymax: 0
            };
            DChartSeriesLineOfAny.WORK_REGION = region;
            this.adjustLineRegion(xmin, xmax, ymin, ymax, region);
            xmin = xcoordinate.transform.map(xcoordinate.map(region.xmin));
            xmax = xcoordinate.transform.map(xcoordinate.map(region.xmax));
            ymin = ycoordinate.transform.map(ycoordinate.map(region.ymin));
            ymax = ycoordinate.transform.map(ycoordinate.map(region.ymax));
            const sx = Math.abs(xmax - xmin);
            const sy = Math.abs(ymax - ymin);
            const cx = (xmin + xmax) * 0.5;
            const cy = (ymin + ymax) * 0.5;
            for (let i = 0, imax = values.length; i < imax; i += 2) {
                values[i + 0] -= cx;
                values[i + 1] -= cy;
            }
            line.lock(EShapeLockPart.UPLOADED);
            this.applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
            line.unlock(EShapeLockPart.UPLOADED, true);
        }
        adjustLineRegion(xmin, xmax, ymin, ymax, result) {
            result.xmin = xmin;
            result.xmax = xmax;
            result.ymin = ymin;
            result.ymax = ymax;
            return result;
        }
        applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            line.points.set(values);
            line.points.toFitted(sx, sy);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
        }
        updateRegion() {
            const pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                const points = this._points;
                const domain = this._domain;
                const range = this._range;
                domain.clear();
                range.clear();
                this.calcRegion(points, domain, range);
            }
        }
        calcRegion(points, domain, range) {
            for (let i = 0, imax = points.length; i < imax; i += 2) {
                const xraw = points[i];
                if (xraw != null) {
                    domain.add(xraw, xraw);
                }
                const yraw = points[i + 1];
                if (yraw != null) {
                    range.add(yraw, yraw);
                }
            }
        }
        destroy() {
            const line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            super.destroy();
            return this;
        }
        hitTest(x, y) {
            const line = this._line;
            if (line) {
                const local = DChartSeriesLineOfAny.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                return line.contains(local.x, local.y) != null;
            }
            return false;
        }
        calcHitPoint(x, y, result) {
            const line = this._line;
            if (line) {
                const local = DChartSeriesLineOfAny.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                result.shape = line;
                return line.calcHitPoint(local.x, local.y, null, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        }
        calcHitPointTestRange(x, y, ax, ay, ox, oy, threshold, values, result) {
            const to = toCeilingIndex(values, x + ax + ox, 2, 0);
            let from = 0;
            for (let i = to - 1, iv = i << 1; 0 <= i; i -= 1, iv -= 2) {
                if (values[iv] <= x - ax) {
                    from = i;
                    break;
                }
            }
            result[0] = from;
            result[1] = from !== to ? to : Math.min(values.length << 1, to + 1);
            return result;
        }
        calcHitPointHitTester(x, y, ax, ay, ox, oy, px, py, sw, ss, sa, index, threshold, result) {
            const shape = result.shape;
            if (shape.containsPointAbs(x, y, ax, ay, ox, oy, px, py, sw, ss, sa)) {
                const transform = shape.transform;
                const position = transform.position;
                const scale = transform.scale;
                result.x = result.p0x = result.p1x = position.x + scale.x * px;
                result.y = result.p0y = result.p1y = position.y + scale.y * py;
                result.t = threshold;
                result.index = index;
                const dx = x - (px + ox);
                const dy = y - (py + oy);
                result.distance = Math.sqrt(dx * dx + dy * dy);
                return true;
            }
            return false;
        }
    }
    DChartSeriesLineOfAny.WORK = new pixi_js.Point();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents bars.
     * Data points must be sorted in ascending order on the X axis.
     */
    class DChartSeriesBar extends DChartSeriesLineOfAny {
        constructor(options) {
            super(options);
            this._barCount = -1;
            this._barIndex = -1;
            this._xcoordinateId = -1;
            this._xcoordinateTransformId = -1;
            this._isSizeAutomatic = (options && options.size && options.size.auto) !== false;
        }
        bind(container, index) {
            this._barCount = -1;
            this._barIndex = -1;
            this._xcoordinateId = -1;
            this._xcoordinateTransformId = -1;
            super.bind(container, index);
            return this;
        }
        initLine(line, options, container, index) {
            super.initLine(line, options, container, index);
            this._padding = container.newPadding(index, options && options.padding);
        }
        newLineOfAny() {
            return new EShapeLineOfRectangles();
        }
        getSizeDefault() {
            return 1;
        }
        adjustLineRegion(xmin, xmax, ymin, ymax, result) {
            return super.adjustLineRegion(xmin, xmax, Math.min(0, ymin), Math.max(0, ymax), result);
        }
        updateBarCountAndIndex() {
            if (this._barIndex < 0 || this._barCount < 0) {
                let barIndex = 0;
                let barCount = 0;
                const container = this._container;
                if (container) {
                    for (let i = 0, imax = container.size(); i < imax; ++i) {
                        const series = container.get(i);
                        if (series === this) {
                            barIndex = barCount;
                        }
                        if (series instanceof DChartSeriesBar) {
                            barCount += 1;
                        }
                    }
                }
                barCount = Math.max(1, barCount);
                this._barCount = barCount;
                this._barIndex = barIndex;
                return true;
            }
            return false;
        }
        applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            const linePoints = line.points;
            const linePointsOffset = linePoints.offset;
            const linePointsSize = linePoints.size;
            // Offset
            const size = this._size;
            const offset = this._offset;
            const padding = this._padding;
            if (size && offset && padding) {
                const xcoordinateId = xcoordinate.id;
                const xcoordinateTransformId = xcoordinate.transform.id;
                if (this.updateBarCountAndIndex() ||
                    this._xcoordinateId !== xcoordinateId ||
                    this._xcoordinateTransformId !== xcoordinateTransformId) {
                    const barCount = this._barCount;
                    const barIndex = this._barIndex;
                    this._xcoordinateId = xcoordinateId;
                    this._xcoordinateTransformId = xcoordinateTransformId;
                    const x0 = xcoordinate.transform.map(xcoordinate.map(0));
                    const x1 = xcoordinate.transform.map(xcoordinate.map(size.x));
                    const totalBandWidth = Math.abs(x0 - x1) * (1 - padding.outer);
                    if (barCount <= 1) {
                        linePointsOffset.x = offset.x;
                        linePointsSize.x = totalBandWidth;
                    }
                    else {
                        const totalBarWidth = totalBandWidth * (1 - padding.inner);
                        const totalPaddingInner = totalBandWidth - totalBarWidth;
                        const barWidth = totalBarWidth / barCount;
                        const barPadding = totalPaddingInner / (barCount - 1);
                        const barX = barWidth * (barIndex + 0.5) + barIndex * barPadding;
                        linePointsOffset.x = offset.x + barX - totalBandWidth * 0.5;
                        linePointsSize.x = barWidth;
                    }
                }
            }
            // Sizes & Offsets
            let sizes = linePointsSize.y;
            if (!isArray(sizes)) {
                sizes = [];
            }
            const sizesLength = sizes.length;
            let offsets = linePointsOffset.y;
            if (!isArray(offsets)) {
                offsets = [];
            }
            const offsetsLength = offsets.length;
            let isize = 0;
            const y0 = ycoordinate.transform.map(ycoordinate.map(0)) - cy;
            for (let i = 0, imax = values.length; i < imax; i += 2, isize += 1) {
                const distance = values[i + 1] - y0;
                const s = Math.abs(distance);
                if (isize < sizesLength) {
                    sizes[isize] = s;
                }
                else {
                    sizes.push(s);
                }
                const o = -0.5 * distance;
                if (isize < offsetsLength) {
                    offsets[isize] = o;
                }
                else {
                    offsets.push(o);
                }
            }
            if (sizes.length !== isize) {
                sizes.length = isize;
            }
            if (offsets.length !== isize) {
                offsets.length = isize;
            }
            linePointsOffset.y = offsets;
            linePointsSize.y = sizes;
            // Others
            super.applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        }
        calcSizeX(def) {
            const points = this._points;
            if (2 < points.length) {
                const pointsLength = points.length;
                let x0 = points[pointsLength - 2];
                for (let i = pointsLength - 4; 0 <= i; i -= 2) {
                    const x1 = points[i];
                    if (x0 != null && x1 != null) {
                        return Math.abs(x0 - x1);
                    }
                    else {
                        x0 = x1;
                    }
                }
            }
            return def;
        }
        calcRegion(points, domain, range) {
            super.calcRegion(points, domain, range);
            const size = this._size;
            if (size) {
                let sx = size.x;
                if (this._isSizeAutomatic) {
                    sx = this.calcSizeX(sx);
                    size.x = sx;
                }
                const sxh = sx * 0.5;
                domain.set(domain.from - sxh, domain.to + sxh);
            }
            range.add(0, 0);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of circles.
     * Data points must be sorted in ascending order on the X axis.
     */
    class DChartSeriesLineOfCircles extends DChartSeriesLineOfAny {
        newLineOfAny() {
            return new EShapeLineOfCircles();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    class DChartSeriesLineOfRectangleRoundeds extends DChartSeriesLineOfAny {
        newLineOfAny() {
            return new EShapeLineOfRectangleRoundeds();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rectangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    class DChartSeriesLineOfRectangles extends DChartSeriesLineOfAny {
        newLineOfAny() {
            return new EShapeLineOfRectangles();
        }
    }

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    class DChartSeriesLineOfTriangles extends DChartSeriesLineOfAny {
        constructor(options) {
            super(options);
            this._sizeId = 0;
        }
        newLineOfAny() {
            return new EShapeLineOfTriangles();
        }
        applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values) {
            // Offset
            const size = this._size;
            const offset = this._offset;
            if (size && offset && this._sizeId !== size.y) {
                this._sizeId = size.y;
                line.points.offset.y = offset.y - size.y * 0.2;
            }
            //
            super.applyLine(line, xcoordinate, ycoordinate, sx, sy, cx, cy, values);
        }
    }

    /*
     * Copyright (C) 2020 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a line of rounded triangles.
     * Data points must be sorted in ascending order on the X axis.
     */
    class DChartSeriesLineOfTriangleRoundeds extends DChartSeriesLineOfTriangles {
        newLineOfAny() {
            return new EShapeLineOfTriangleRoundeds();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a polyline.
     * Data points must be sorted in ascending order on the X axis.
     */
    class DChartSeriesLine extends DChartSeriesBase {
        constructor(options) {
            var _a;
            super(options);
            this._line = null;
            this._options = options;
            this._points = (_a = options === null || options === void 0 ? void 0 : options.points) !== null && _a !== void 0 ? _a : [];
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            this._centerX = 0;
            this._centerY = 0;
        }
        bind(container, index) {
            var _a;
            let line = this._line;
            if (!line) {
                const stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                this._stroke = stroke;
                line = new EShapeLine();
                line.stroke.copy(stroke);
                line.visible = this._isShown;
                this._line = line;
            }
            line.attach(container.plotArea.container, index);
            this._pointIdUpdated = NaN;
            super.bind(container, index);
            return this;
        }
        unbind() {
            const line = this._line;
            if (line) {
                line.detach();
            }
            super.unbind();
            return this;
        }
        get shape() {
            return this._line;
        }
        get points() {
            return this._points;
        }
        set points(points) {
            this._points = points;
            this._pointId += 1;
        }
        toDirty() {
            this._pointId += 1;
            return this;
        }
        update() {
            this.doUpdate(true);
            return this;
        }
        onRender() {
            this.doUpdate(false);
            return this;
        }
        doUpdate(render) {
            const line = this._line;
            if (line) {
                const coordinate = this._coordinate;
                const coordinateX = coordinate.x;
                const coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    const pointId = this._pointId;
                    const isPointChanged = pointId !== this._pointIdUpdated;
                    const isCoordinateChanged = coordinate.isDirty(coordinateX, coordinateY);
                    const isCoordinateTransformChanged = coordinate.isTransformDirty(coordinateX, coordinateY);
                    if (isPointChanged || isCoordinateChanged || isCoordinateTransformChanged) {
                        this._pointIdUpdated = pointId;
                        this.doUpdateLine(line, coordinateX, coordinateY, isPointChanged || isCoordinateChanged);
                        if (render) {
                            DApplications.update(line);
                        }
                        return true;
                    }
                }
            }
            return false;
        }
        doUpdateLine(line, xcoordinate, ycoordinate, isPointsDirty) {
            line.lock(EShapeLockPart.UPLOADED);
            if (isPointsDirty) {
                const values = line.points.values;
                const segments = line.points.segments;
                const valuesLength = values.length;
                const segmentsLength = segments.length;
                let ivalues = 0;
                let isegments = 0;
                const points = this._points;
                let xmin = NaN;
                let xmax = NaN;
                let ymin = NaN;
                let ymax = NaN;
                for (let i = 0, imax = points.length; i < imax; i += 2) {
                    const x = points[i];
                    const y = points[i + 1];
                    if (x != null && y != null) {
                        if (ivalues < valuesLength) {
                            values[ivalues] = x;
                            values[ivalues + 1] = y;
                        }
                        else {
                            values.push(x, y);
                        }
                        ivalues += 2;
                        if (xmin !== xmin) {
                            xmin = x;
                            xmax = x;
                            ymin = y;
                            ymax = y;
                        }
                        else {
                            xmin = Math.min(xmin, x);
                            xmax = Math.max(xmax, x);
                            ymin = Math.min(ymin, y);
                            ymax = Math.max(ymax, y);
                        }
                    }
                    else {
                        const segment = (i >> 1) - isegments;
                        if (isegments < segmentsLength) {
                            segments[isegments] = segment;
                        }
                        else {
                            segments.push(segment);
                        }
                        isegments += 1;
                    }
                }
                if (values.length !== ivalues) {
                    values.length = ivalues;
                }
                if (segments.length !== isegments) {
                    segments.length = isegments;
                }
                xcoordinate.mapAll(values, 0, ivalues, 2, 0);
                ycoordinate.mapAll(values, 0, ivalues, 2, 1);
                if (xmin !== xmin) {
                    xmin = 0;
                    xmax = 0;
                    ymin = 0;
                    ymax = 0;
                }
                xmin = xcoordinate.map(xmin);
                xmax = xcoordinate.map(xmax);
                ymin = ycoordinate.map(ymin);
                ymax = ycoordinate.map(ymax);
                const sx = Math.abs(xmax - xmin);
                const sy = Math.abs(ymax - ymin);
                const cx = (xmin + xmax) * 0.5;
                const cy = (ymin + ymax) * 0.5;
                for (let i = 0, imax = values.length; i < imax; i += 2) {
                    values[i + 0] -= cx;
                    values[i + 1] -= cy;
                }
                line.points.set(values, segments);
                line.points.toFitted(sx, sy);
                line.size.set(sx, sy);
                this._centerX = cx;
                this._centerY = cy;
            }
            line.transform.position.set(xcoordinate.transform.map(this._centerX), ycoordinate.transform.map(this._centerY));
            line.transform.scale.set(xcoordinate.transform.scale, ycoordinate.transform.scale);
            line.unlock(EShapeLockPart.UPLOADED, true);
        }
        updateRegion() {
            const pointId = this._pointId;
            if (this._regionPointId !== pointId) {
                this._regionPointId = pointId;
                const points = this._points;
                const domain = this._domain;
                const range = this._range;
                domain.clear();
                range.clear();
                if (points != null) {
                    for (let i = 0, imax = points.length; i < imax; i += 2) {
                        const xraw = points[i];
                        if (xraw != null) {
                            domain.add(xraw, xraw);
                        }
                        const yraw = points[i + 1];
                        if (yraw != null) {
                            range.add(yraw, yraw);
                        }
                    }
                }
            }
        }
        destroy() {
            const line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            this._points.length = 0;
            this._pointId = 0;
            this._pointIdUpdated = NaN;
            super.destroy();
            return this;
        }
        hitTest(x, y) {
            const line = this._line;
            if (line) {
                const local = DChartSeriesLine.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                return line.contains(local.x, local.y) != null;
            }
            return false;
        }
        calcHitPoint(x, y, result) {
            const line = this._line;
            if (line) {
                const local = DChartSeriesLine.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                result.shape = line;
                return line.calcHitPoint(local.x, local.y, this.toThreshold, this.calcHitPointTestRange, this.calcHitPointHitTester, result);
            }
            return false;
        }
        toThreshold(strokeWidth, strokeScale) {
            return +Infinity;
        }
        calcHitPointTestRange(x, y, threshold, values, result) {
            const index = toCeilingIndex(values, x, 2, 0);
            result[0] = Math.max(0, index - 1);
            result[1] = index;
            return result;
        }
        calcHitPointHitTester(x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                const l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    const t = (x - p0x) / l;
                    const p2x = x;
                    const p2y = p0y + t * (p1y - p0y);
                    const distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        const transform = result.shape.transform;
                        const position = transform.position;
                        const px = position.x;
                        const py = position.y;
                        const scale = transform.scale;
                        const sx = scale.x;
                        const sy = scale.y;
                        result.x = px + sx * p2x;
                        result.y = py + sy * p2y;
                        result.p0x = px + sx * p0x;
                        result.p0y = py + sy * p0y;
                        result.p1x = px + sx * p1x;
                        result.p1y = py + sy * p1y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        }
    }
    DChartSeriesLine.WORK = new pixi_js.Point();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChartSeriesExpressionParametersImpl {
        constructor(a, b, x0, y0) {
            this._id = 0;
            this._idUpdated = NaN;
            this._a = a;
            this._b = b;
            this._x0 = x0;
            this._y0 = y0;
        }
        get a() {
            return this._a;
        }
        set a(a) {
            if (this._a !== a) {
                this._id += 1;
                this._a = a;
            }
        }
        get b() {
            return this._b;
        }
        set b(b) {
            if (this._b !== b) {
                this._id += 1;
                this._b = b;
            }
        }
        get x0() {
            return this._x0;
        }
        set x0(x0) {
            if (this._x0 !== x0) {
                this._id += 1;
                this._x0 = x0;
            }
        }
        get y0() {
            return this._y0;
        }
        set y0(y0) {
            if (this._y0 !== y0) {
                this._id += 1;
                this._y0 = y0;
            }
        }
        toDirty() {
            this._id += 1;
        }
        isDirty() {
            return this._id !== this._idUpdated;
        }
        toClean() {
            this._idUpdated = this._id;
        }
        static from(options) {
            var _c, _d, _e, _f;
            return new DChartSeriesExpressionParametersImpl((_c = options === null || options === void 0 ? void 0 : options.a) !== null && _c !== void 0 ? _c : 1, (_d = options === null || options === void 0 ? void 0 : options.b) !== null && _d !== void 0 ? _d : 1, (_e = options === null || options === void 0 ? void 0 : options.x0) !== null && _e !== void 0 ? _e : 0, (_f = options === null || options === void 0 ? void 0 : options.y0) !== null && _f !== void 0 ? _f : 0);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A series represents a linear equation `a (x - x0) === b (y - y0)`.
     */
    class DChartSeriesLinear extends DChartSeriesBase {
        constructor(options) {
            super(options);
            this._line = null;
            this._options = options;
            this._parameters = DChartSeriesExpressionParametersImpl.from(options);
        }
        bind(container, index) {
            var _a;
            let line = this._line;
            if (!line) {
                const stroke = container.newStroke(index, (_a = this._options) === null || _a === void 0 ? void 0 : _a.stroke);
                this._stroke = stroke;
                line = new EShapeLine();
                line.stroke.copy(stroke);
                line.visible = this._isShown;
                this._line = line;
            }
            line.attach(container.plotArea.container, index);
            super.bind(container, index);
            return this;
        }
        unbind() {
            const line = this._line;
            if (line) {
                line.detach();
            }
            super.unbind();
            return this;
        }
        get shape() {
            return this._line;
        }
        get parameters() {
            return this._parameters;
        }
        toDirty() {
            this._parameters.toDirty();
            return this;
        }
        update() {
            this.doUpdate(true);
            return this;
        }
        onRender() {
            this.doUpdate(false);
            return this;
        }
        doUpdate(render) {
            const line = this._line;
            const container = this._container;
            if (line && container) {
                const coordinate = this._coordinate;
                const coordinateX = coordinate.x;
                const coordinateY = coordinate.y;
                if (coordinateX && coordinateY) {
                    this.doUpdateLine(line, container, coordinateX, coordinateY);
                    if (render) {
                        DApplications.update(line);
                    }
                    return true;
                }
            }
            return false;
        }
        doUpdateLine(line, container, xcoordinate, ycoordinate) {
            const values = line.points.values;
            const segments = line.points.segments;
            const parameters = this._parameters;
            const a = parameters.a;
            const b = parameters.b;
            const x0 = parameters.x0;
            const y0 = parameters.y0;
            const aabs = Math.abs(a);
            const babs = Math.abs(b);
            let p0x = NaN;
            let p0y = NaN;
            let p1x = NaN;
            let p1y = NaN;
            const threshold = 0.00001;
            const bounds = container.plotArea.getContainerBounds();
            if (babs <= aabs) {
                const xfrom = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x));
                const xto = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x + bounds.width));
                p0x = Math.min(xfrom, xto);
                p1x = Math.max(xfrom, xto);
                const yfrom = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y));
                const yto = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y + bounds.height));
                p0y = Math.min(yfrom, yto);
                p1y = Math.max(yfrom, yto);
                if (threshold < babs) {
                    const f = b / a;
                    const xfrom1 = f * (yfrom - y0) + x0;
                    const xto1 = f * (yto - y0) + x0;
                    const p2x = Math.min(xfrom1, xto1);
                    const p3x = Math.max(xfrom1, xto1);
                    p0x = Math.max(p0x, p2x);
                    p1x = Math.min(p1x, p3x);
                    const g = 1 / f;
                    p0y = g * (p0x - x0) + b * y0;
                    p1y = g * (p1x - x0) + b * y0;
                }
                else {
                    p0x = x0;
                    p1x = x0;
                }
            }
            else {
                const yfrom = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y));
                const yto = ycoordinate.unmap(ycoordinate.transform.unmap(bounds.y + bounds.height));
                p0y = Math.min(yfrom, yto);
                p1y = Math.max(yfrom, yto);
                const xfrom = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x));
                const xto = xcoordinate.unmap(xcoordinate.transform.unmap(bounds.x + bounds.width));
                p0x = Math.min(xfrom, xto);
                p1x = Math.max(xfrom, xto);
                if (threshold < aabs) {
                    const f = a / b;
                    const yfrom1 = f * (xfrom - x0) + y0;
                    const yto1 = f * (xto - x0) + y0;
                    const p2y = Math.min(yfrom1, yto1);
                    const p3y = Math.max(yfrom1, yto1);
                    p0y = Math.max(p0y, p2y);
                    p1y = Math.min(p1y, p3y);
                    const g = 1 / f;
                    p0x = g * (p0y - y0) + a * x0;
                    p1x = g * (p1y - y0) + a * x0;
                }
                else {
                    p0y = y0;
                    p1y = y0;
                }
            }
            p0x = xcoordinate.transform.map(xcoordinate.map(p0x));
            p0y = ycoordinate.transform.map(ycoordinate.map(p0y));
            p1x = xcoordinate.transform.map(xcoordinate.map(p1x));
            p1y = ycoordinate.transform.map(ycoordinate.map(p1y));
            const cx = (p0x + p1x) * 0.5;
            const cy = (p0y + p1y) * 0.5;
            const sx = Math.abs(p1x - p0x);
            const sy = Math.abs(p1y - p0y);
            p0x -= cx;
            p0y -= cy;
            p1x -= cx;
            p1y -= cy;
            if (values.length !== 4) {
                values.length = 0;
                values.push(p0x, p0y, p1x, p1y);
            }
            else {
                values[0] = p0x;
                values[1] = p0y;
                values[2] = p1x;
                values[3] = p1y;
            }
            if (0 < segments.length) {
                segments.length = 0;
            }
            line.lock(EShapeLockPart.UPLOADED);
            line.points.set(values, segments);
            line.points.toFitted(sx, sy);
            line.size.set(sx, sy);
            line.transform.position.set(cx, cy);
            line.unlock(EShapeLockPart.UPLOADED, true);
        }
        updateRegion() {
            // DO NOTHING
        }
        destroy() {
            const line = this._line;
            if (line) {
                this._line = null;
                line.detach();
                line.destroy();
            }
            super.destroy();
            return this;
        }
        hitTest(x, y) {
            const line = this._line;
            if (line) {
                const local = DChartSeriesLinear.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                return line.contains(local.x, local.y) != null;
            }
            return false;
        }
        calcHitPoint(x, y, result) {
            const line = this._line;
            if (line) {
                const local = DChartSeriesLinear.WORK;
                local.set(x, y);
                line.toLocal(local, undefined, local);
                result.shape = line;
                return line.calcHitPoint(local.x, local.y, this.toThreshold, null, this.calcHitPointHitTester, result);
            }
            return false;
        }
        toThreshold(strokeWidth, strokeScale) {
            return +Infinity;
        }
        calcHitPointHitTester(x, y, p0x, p0y, p1x, p1y, index, threshold, result) {
            if (p0x <= x && x < p1x) {
                const l = p1x - p0x;
                if (0.0001 < Math.abs(l)) {
                    const t = (x - p0x) / l;
                    const p2x = x;
                    const p2y = p0y + t * (p1y - p0y);
                    const distance = Math.abs(p2y - y);
                    if (distance < threshold) {
                        const transform = result.shape.transform;
                        const position = transform.position;
                        const px = position.x;
                        const py = position.y;
                        const scale = transform.scale;
                        const sx = scale.x;
                        const sy = scale.y;
                        result.x = result.p0x = result.p1x = px + sx * p2x;
                        result.y = result.p0y = result.p1y = py + sy * p2y;
                        result.t = t;
                        result.index = index;
                        result.distance = distance;
                        return true;
                    }
                }
            }
            return false;
        }
    }
    DChartSeriesLinear.WORK = new pixi_js.Point();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DChart extends DBase {
        init(options) {
            var _a;
            super.init(options);
            // Overflow mask
            const plotArea = this.plotArea;
            const mask = (_a = options === null || options === void 0 ? void 0 : options.mask) !== null && _a !== void 0 ? _a : this.theme.isOverflowMaskEnabled();
            if (mask) {
                plotArea.axis.container.mask = this.getOverflowMask();
            }
        }
        getOverflowMask() {
            if (this._overflowMask == null) {
                this._overflowMask = new DBaseOverflowMask(this);
                this.reflowable.add(this._overflowMask);
                this.toDirty();
            }
            return this._overflowMask;
        }
        get plotArea() {
            var _a;
            return ((_a = this._plotArea) !== null && _a !== void 0 ? _a : (this._plotArea = this.newPlotArea()));
        }
        newPlotArea() {
            var _a;
            const plotArea = (_a = this._options) === null || _a === void 0 ? void 0 : _a.plotArea;
            if (plotArea != null && ("primary" in plotArea || "secondary" in plotArea)) {
                const result = new DChartPlotAreaTwofold(this, plotArea);
                this.addChild(result);
                return result;
            }
            else {
                const result = new DChartPlotAreaOnefold(this, plotArea);
                this.addChild(result);
                return result;
            }
        }
        destroy() {
            var _a;
            if (!this._destroyed) {
                (_a = this._plotArea) === null || _a === void 0 ? void 0 : _a.destroy();
                super.destroy();
            }
        }
        getType() {
            return "DChart";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DCommandCreate extends DCommandBase {
        isStorable() {
            return false;
        }
        isClear() {
            return true;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DCommandSaveAs extends DCommandBase {
        constructor(name) {
            super();
            this._name = name;
        }
        get name() {
            return this._name;
        }
        isStorable() {
            return false;
        }
        execute() {
            DControllers.getDocumentController().saveAs(this._name);
            return true;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DCommandSave extends DCommandBase {
        isStorable() {
            return false;
        }
        execute() {
            DControllers.getDocumentController().save();
            return true;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasEditorShapeImpl extends DDiagramCanvasBaseShapeImpl {
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasEditorSnap {
        constructor(parent, theme, options) {
            this._parent = parent;
            this._isDirty = true;
            // Controller
            const controller = options.controller;
            this._controller = controller;
            const onChangeBound = () => {
                this.onChange();
            };
            controller.grid.on("change", onChangeBound);
            controller.target.on("change", onChangeBound);
            // Container
            const container = new EShapeContainer();
            container.visible = false;
            this._container = container;
            parent.addChildAt(container, parent.children.length - 1);
            // Grid
            this._grid = this.toGrid(theme, options.grid);
            this._gridParentWidth = parent.width;
            this._gridParentHeight = parent.height;
            this._gridParentScale = parent.scale.x;
            this._gridSize = this.newGridSize();
            // Target
            this._target = this.toTarget(theme, options.target);
        }
        toGrid(theme, options) {
            var _a;
            if (options != null) {
                return {
                    major: this.toGridMajor(theme, options.major),
                    minor: this.toGridMinor(theme, options.minor),
                    size: (_a = options.size) !== null && _a !== void 0 ? _a : theme.getSnapGridSize()
                };
            }
            return {
                major: this.toGridMajor(theme),
                minor: this.toGridMinor(theme),
                size: theme.getSnapGridSize()
            };
        }
        toGridMajor(theme, options) {
            var _a, _b, _c, _d, _e;
            if (options != null) {
                return {
                    interval: (_a = options.interval) !== null && _a !== void 0 ? _a : theme.getSnapGridMajorInterval(),
                    color: (_b = options.color) !== null && _b !== void 0 ? _b : theme.getSnapGridMajorColor(),
                    alpha: (_c = options.alpha) !== null && _c !== void 0 ? _c : theme.getSnapGridMajorAlpha(),
                    width: (_d = options.width) !== null && _d !== void 0 ? _d : theme.getSnapGridMajorWidth(),
                    style: (_e = options.style) !== null && _e !== void 0 ? _e : theme.getSnapGridMajorStyle()
                };
            }
            return {
                interval: theme.getSnapGridMajorInterval(),
                color: theme.getSnapGridMajorColor(),
                alpha: theme.getSnapGridMajorAlpha(),
                width: theme.getSnapGridMajorWidth(),
                style: theme.getSnapGridMajorStyle()
            };
        }
        toGridMinor(theme, options) {
            var _a, _b, _c, _d;
            if (options != null) {
                return {
                    color: (_a = options.color) !== null && _a !== void 0 ? _a : theme.getSnapGridMinorColor(),
                    alpha: (_b = options.alpha) !== null && _b !== void 0 ? _b : theme.getSnapGridMinorAlpha(),
                    width: (_c = options.width) !== null && _c !== void 0 ? _c : theme.getSnapGridMinorWidth(),
                    style: (_d = options.style) !== null && _d !== void 0 ? _d : theme.getSnapGridMinorStyle()
                };
            }
            return {
                color: theme.getSnapGridMinorColor(),
                alpha: theme.getSnapGridMinorAlpha(),
                width: theme.getSnapGridMinorWidth(),
                style: theme.getSnapGridMinorStyle()
            };
        }
        toTarget(theme, options) {
            var _a, _b, _c, _d;
            if (options != null) {
                return {
                    color: (_a = options.color) !== null && _a !== void 0 ? _a : theme.getSnapTargetColor(),
                    alpha: (_b = options.alpha) !== null && _b !== void 0 ? _b : theme.getSnapTargetAlpha(),
                    width: (_c = options.width) !== null && _c !== void 0 ? _c : theme.getSnapTargetWidth(),
                    style: (_d = options.style) !== null && _d !== void 0 ? _d : theme.getSnapTargetStyle()
                };
            }
            return {
                color: theme.getSnapTargetColor(),
                alpha: theme.getSnapTargetAlpha(),
                width: theme.getSnapTargetWidth(),
                style: theme.getSnapTargetStyle()
            };
        }
        onChange() {
            this._isDirty = true;
            DApplications.update(this._parent);
        }
        get container() {
            return this._container;
        }
        serialize() {
            return this._controller.serialize();
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            if (this._gridParentWidth !== newWidth || this._gridParentHeight !== newHeight) {
                this._gridParentWidth = newWidth;
                this._gridParentHeight = newHeight;
                this._isDirty = true;
                this.updateGridSize();
            }
        }
        onScale(newX, newY, oldX, oldY) {
            if (this._gridParentScale !== newX) {
                this._gridParentScale = newX;
                this.updateGridSize();
            }
        }
        updateGridSize() {
            const gridSize = this.newGridSize();
            if (this._gridSize !== gridSize) {
                this._gridSize = gridSize;
                this._isDirty = true;
            }
        }
        newGridSize() {
            return this._grid.size(this._controller.grid.size, this._gridParentWidth, this._gridParentHeight, this._gridParentScale);
        }
        onRender() {
            if (this._isDirty) {
                this._isDirty = false;
                this.updateAll();
            }
        }
        updateAll() {
            const container = this._container;
            const controller = this._controller;
            const isGridVisible = controller.grid.visible;
            const isTargetVisible = controller.target.visible;
            if (isGridVisible || isTargetVisible) {
                const w = this._gridParentWidth;
                const h = this._gridParentHeight;
                const wh = 0.5 * w;
                const hh = 0.5 * h;
                const TOP = EShapeBarPosition.TOP;
                const LEFT = EShapeBarPosition.LEFT;
                const shapes = container.children;
                let index = 0;
                // Grid
                if (isGridVisible) {
                    const grid = this._grid;
                    const major = grid.major;
                    const minor = grid.minor;
                    const interval = major.interval;
                    const size = this._gridSize;
                    for (let x = size, ix = 1; x < w; x += size, ix += 1, index += 1) {
                        const style = ix % interval === 0 ? major : minor;
                        this.update(container, shapes, index, x, hh, TOP, w, h, style);
                    }
                    for (let y = size, iy = 1; y < h; y += size, iy += 1, index += 1) {
                        const style = iy % interval === 0 ? major : minor;
                        this.update(container, shapes, index, wh, y, LEFT, w, h, style);
                    }
                }
                // Target
                if (isTargetVisible) {
                    const values = controller.target.values;
                    const target = this._target;
                    for (let i = 0, imax = values.length; i < imax; i += 1, index += 1) {
                        const value = values[i];
                        const position = value.position;
                        if (value.type === ESnapperTargetValueType.VERTICAL) {
                            this.update(container, shapes, index, position, hh, TOP, w, h, target);
                        }
                        else {
                            this.update(container, shapes, index, wh, position, LEFT, w, h, target);
                        }
                    }
                }
                for (let i = index, imax = shapes.length; i < imax; ++i) {
                    shapes[i].visible = false;
                }
                container.visible = true;
            }
            else {
                container.visible = false;
            }
        }
        update(container, shapes, index, x, y, position, w, h, style) {
            let shape = null;
            if (index < shapes.length) {
                shape = shapes[index];
                shape.lock(EShapeLockPart.UPLOADED);
                shape.points.position = position;
                shape.transform.position.set(x, y);
                shape.stroke.set(true, style.color, style.alpha, style.width, undefined, undefined, style.style);
                shape.size.set(w, h);
                shape.visible = true;
                shape.unlock(EShapeLockPart.UPLOADED, true);
            }
            else {
                shape = new EShapeBar();
                shape.lock(EShapeLockPart.UPLOADED);
                shape.points.position = position;
                shape.transform.position.set(x, y);
                shape.stroke.set(true, style.color, style.alpha, style.width, undefined, undefined, style.style);
                shape.size.set(w, h);
                shape.visible = true;
                shape.unlock(EShapeLockPart.UPLOADED, true);
                shape.attach(container);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DDiagramSerializedVersion = 1;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramCanvasEditor extends DDiagramCanvasBase {
        constructor(options) {
            super(options);
            this._snap = this.toSnap(this.theme, options.snap);
        }
        toSnap(theme, options) {
            if (options) {
                return new DDiagramCanvasEditorSnap(this, theme, options);
            }
            return null;
        }
        get snap() {
            return this._snap;
        }
        get shape() {
            var _a;
            return ((_a = this._shape) !== null && _a !== void 0 ? _a : (this._shape = this.newShape()));
        }
        newShape() {
            return new DDiagramCanvasEditorShapeImpl(this);
        }
        serialize(id, thumbnail) {
            var _a;
            const manager = new EShapeResourceManagerSerialization();
            const items = [];
            const background = this._background;
            const backgroundColor = background.color;
            const backgroundAlpha = background.alpha;
            return {
                version: DDiagramSerializedVersion,
                id,
                name: this.name,
                label: this.label,
                width: this.width,
                height: this.height,
                category: this.category,
                summary: this.summary,
                description: this.description,
                background: {
                    color: isNumber(backgroundColor) ? backgroundColor : 0xffffff,
                    alpha: isNumber(backgroundAlpha) ? backgroundAlpha : 0
                },
                tile: this._tile.serialize(),
                resources: manager.resources,
                data: manager.data,
                pieces: manager.pieces,
                layers: this._layer.serialize(manager, items),
                items,
                snap: (_a = this._snap) === null || _a === void 0 ? void 0 : _a.serialize(),
                thumbnail: thumbnail === null || thumbnail === void 0 ? void 0 : thumbnail.serialize()
            };
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            const snap = this._snap;
            if (snap != null) {
                snap.onResize(newWidth, newHeight, oldWidth, oldHeight);
            }
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
        }
        onScale(newX, newY, oldX, oldY) {
            const snap = this._snap;
            if (snap != null) {
                snap.onScale(newX, newY, oldX, oldY);
            }
            super.onScale(newX, newY, oldX, oldY);
        }
        render(renderer) {
            const snap = this._snap;
            if (snap != null) {
                snap.onRender();
            }
            super.render(renderer);
        }
        getType() {
            return "DDiagramCanvasEditor";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramEditorThumbnail {
        constructor(snapshot, theme, options) {
            this._snapshot = snapshot;
            this._isEnabled = this.toIsEnabled(theme, options);
            this._options = this.toCreateAsUrlOptions(theme, options);
        }
        toIsEnabled(theme, options) {
            var _a;
            return (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : theme.isThumbnailEnabled();
        }
        toSize(theme, options) {
            return options !== undefined ? options : theme.getThumbnailSize();
        }
        toCleanup(theme, cleanup) {
            var _a, _b;
            if (cleanup == null || cleanup === true) {
                return {
                    snap: true,
                    background: true
                };
            }
            else if (cleanup === false) {
                return {
                    snap: false,
                    background: false
                };
            }
            return {
                snap: (_a = cleanup.snap) !== null && _a !== void 0 ? _a : true,
                background: (_b = cleanup.background) !== null && _b !== void 0 ? _b : true
            };
        }
        toCreateAsUrlOptions(theme, options) {
            return {
                size: this.toSize(theme, options === null || options === void 0 ? void 0 : options.size),
                cleanup: this.toCleanup(theme, options === null || options === void 0 ? void 0 : options.cleanup)
            };
        }
        get enable() {
            return this._isEnabled;
        }
        set enable(enable) {
            this._isEnabled = enable;
        }
        get size() {
            return this._options.size;
        }
        set size(size) {
            this._options.size = size;
        }
        get cleanup() {
            return this._options.cleanup;
        }
        serialize() {
            if (this._isEnabled) {
                return this._snapshot.createAsUrl(this._options);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDiagramEditor extends DDiagramBase {
        constructor(options) {
            super(options);
            this._isChanged = false;
            this._isChanged = false;
            const commands = DControllers.getCommandController();
            commands.on("dirty", () => {
                if (this._isChanged !== true) {
                    this._isChanged = true;
                    this.emit("change", this);
                }
            });
            const theme = this.theme;
            this._snapper = new ESnapper(this, theme, options === null || options === void 0 ? void 0 : options.snapper);
            this._thumbnail = new DDiagramEditorThumbnail(this._snapshot, theme, options === null || options === void 0 ? void 0 : options.thumbnail);
        }
        get thumbnail() {
            return this._thumbnail;
        }
        get snapper() {
            return this._snapper;
        }
        toMode(options) {
            if (options === null || options === void 0 ? void 0 : options.mapping) {
                return EShapeResourceManagerDeserializationMode.EDITOR_DATA_MAPPED;
            }
            return EShapeResourceManagerDeserializationMode.EDITOR;
        }
        newCanvas(serialized) {
            return new DDiagramCanvasEditor(this.toCanvasOptions(serialized));
        }
        toCanvasOptions(serialized) {
            const options = this.toCanvasBaseOptions(serialized);
            // Snapper
            const snapper = this._snapper;
            const snap = options.snap;
            if (snap == null) {
                options.snap = {
                    controller: snapper
                };
            }
            else if (snap.controller == null) {
                snap.controller = snapper;
            }
            return options;
        }
        serialize() {
            const canvas = this.canvas;
            const serialized = this._serialized;
            if (canvas != null && serialized != null) {
                this.emit("serializing", canvas, this);
                try {
                    const result = canvas.serialize(serialized.id, this._thumbnail);
                    this.emit("serialized", canvas, null, this);
                    return result;
                }
                catch (e) {
                    this.emit("serialized", canvas, "exception", this);
                    return null;
                }
            }
            return null;
        }
        save() {
            const serialized = this.serialize();
            if (serialized != null) {
                const controller = this._controller;
                if (controller) {
                    const simple = DDiagrams.toSimple(serialized);
                    this.emit("saving", simple, this);
                    return controller.save(simple).then((newId) => {
                        this._isChanged = false;
                        serialized.id = newId;
                        this._serialized = serialized;
                        this.emit("change", this);
                        this.emit("saved", null, this);
                    }, (reason) => {
                        this.emit("saved", reason, this);
                    });
                }
                else {
                    this.emit("saved", "no-controller", this);
                    return Promise.reject();
                }
            }
            this.emit("saved", null, this);
            return Promise.resolve();
        }
        saveAs(name) {
            const serialized = this.serialize();
            if (serialized != null) {
                const controller = this._controller;
                if (controller) {
                    serialized.id = undefined;
                    serialized.name = name;
                    const simple = DDiagrams.toSimple(serialized);
                    this.emit("saving", simple, this);
                    return controller.save(simple).then((newId) => {
                        this._isChanged = false;
                        serialized.id = newId;
                        this._serialized = serialized;
                        const canvas = this.canvas;
                        if (canvas != null) {
                            canvas.name = name;
                        }
                        this.emit("change", this);
                        this.emit("saved", null, this);
                    }, (reason) => {
                        this.emit("saved", reason, this);
                    });
                }
                else {
                    this.emit("saved", "no-controller", this);
                    return Promise.reject("no-controller");
                }
            }
            this.emit("saved", null, this);
            return Promise.resolve();
        }
        delete() {
            const serialized = this._serialized;
            if (serialized && serialized.id != null) {
                const controller = this._controller;
                if (controller) {
                    this.emit("deleting", this);
                    return controller.delete(serialized.id).then(() => {
                        const result = this.set(null);
                        this.emit("deleted", null, this);
                        return result;
                    }, (reason) => {
                        this.emit("deleted", reason, this);
                        return Promise.reject(reason);
                    });
                }
                else {
                    this.emit("deleted", "no-controller", this);
                    return Promise.reject("no-controller");
                }
            }
            this.set(null);
            this.emit("deleted", null, this);
            return Promise.resolve(null);
        }
        create(options) {
            return this.set({
                version: DDiagramSerializedVersion,
                id: undefined,
                name: options.name,
                label: options.label,
                width: options.width,
                height: options.height,
                category: options.category,
                summary: options.summary,
                description: options.description,
                background: options.background,
                resources: [],
                data: [],
                layers: [[this.theme.getBaseLayerLabel()]],
                items: [],
                snap: undefined
            });
        }
        onSet(serialized, canvas) {
            super.onSet(serialized, canvas);
            // Snap settings
            const snap = serialized.snap;
            const snapper = this._snapper;
            if (snap != null) {
                snapper.deserialize(snap);
            }
            else {
                snapper.reset();
            }
            if (this._isAmbient) {
                snapper.target.visible = false;
                snapper.grid.visible = false;
            }
            // Reset the isChanged flag
            this._isChanged = false;
            // Done
            this.emit("change", this);
        }
        onUnset() {
            super.onUnset();
            this._isChanged = false;
            this.emit("change", this);
        }
        open(id) {
            const controller = this._controller;
            if (controller) {
                this.emit("opening", this);
                return controller.get(id).then((serialized) => {
                    const result = this.set(DDiagrams.toSerialized(serialized));
                    this.emit("opened", null, this);
                    return result;
                }, (reason) => {
                    this.emit("opened", reason, this);
                    return Promise.reject(reason);
                });
            }
            this.emit("opened", "no-controller", this);
            return Promise.reject("no-controller");
        }
        close() {
            return this.set(null);
        }
        isChanged() {
            return this._isChanged || this.isNew();
        }
        isNew() {
            const serialized = this._serialized;
            if (serialized != null) {
                return serialized.id == null;
            }
            return false;
        }
        getName() {
            const serialized = this._serialized;
            if (serialized != null) {
                return serialized.name;
            }
            return null;
        }
        getType() {
            return "DDiagramEditor";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogConfirmMessage extends DImage {
        getType() {
            return "DDialogConfirmMessage";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogConfirm extends DDialogLayered {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.message);
            return result;
        }
        toMessage(theme, options) {
            const message = options === null || options === void 0 ? void 0 : options.message;
            if (message != null) {
                if (isString(message) || isFunction(message)) {
                    return this.newMessage(this.toMessageOptions(message));
                }
                else if (message instanceof DBase) {
                    return message;
                }
                else {
                    return this.newMessage(this.toMessageOptionsMerged(message, theme.getMessage()));
                }
            }
            return this.newMessage(this.toMessageOptions(theme.getMessage()));
        }
        toMessageOptionsMerged(options, message) {
            let text = options.text;
            if (text == null) {
                text = {};
                options.text = text;
            }
            if (text.value === undefined) {
                text.value = message;
            }
            return options;
        }
        toMessageOptions(message) {
            return {
                text: {
                    value: message
                }
            };
        }
        newMessage(options) {
            return new DDialogConfirmMessage(options);
        }
        get message() {
            let result = this._message;
            if (result == null) {
                result = this.toMessage(this.theme, this._options);
                this._message = result;
            }
            return result;
        }
        getResolvedValue() {
            return undefined;
        }
        getType() {
            return "DDialogConfirm";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogConfirmDelete extends DDialogConfirm {
        getType() {
            return "DDialogConfirmDelete";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogConfirmDiscard extends DDialogConfirm {
        getType() {
            return "DDialogConfirmDiscard";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogMessage extends DDialogConfirm {
        getType() {
            return "DDialogMessage";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogProcessingMessage extends DDialogConfirmMessage {
        getType() {
            return "DDialogProcessingMessage";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogProcessing extends DDialogConfirm {
        constructor(options) {
            var _a;
            super(options);
            this._isDone = true;
            this._startTime = 0;
            const theme = this.theme;
            const delay = options === null || options === void 0 ? void 0 : options.delay;
            this._delayDone = (_a = delay === null || delay === void 0 ? void 0 : delay.done) !== null && _a !== void 0 ? _a : theme.getDoneDelay();
            const delayClose = delay === null || delay === void 0 ? void 0 : delay.close;
            this._delayClose = delayClose !== undefined ? delayClose : theme.getCloseDelay();
            this._messageText = this.message.text.value;
        }
        newMessage(options) {
            return new DDialogProcessingMessage(options);
        }
        onOpen() {
            this._isDone = false;
            this._startTime = Date.now();
            const timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
            const closeTimeoutId = this._closeTimeoutId;
            if (closeTimeoutId != null) {
                clearTimeout(closeTimeoutId);
            }
            const message = this.message;
            message.text = this._messageText;
            message.state.removeAll(DBaseState.SUCCEEDED, DBaseState.FAILED);
            const footer = this._footer;
            if (footer != null) {
                footer.hide();
            }
            super.onOpen();
        }
        onDone(delay) {
            if (delay != null) {
                this._closeTimeoutId = window.setTimeout(() => {
                    this.close();
                }, delay);
            }
            else {
                this.close();
            }
        }
        onResolved(message) {
            if (message != null) {
                this.message.text = message;
            }
            this.message.state.set(DBaseState.SUCCEEDED, DBaseState.FAILED);
            const delayClose = this._delayClose;
            if (delayClose != null) {
                this.onDone(delayClose);
            }
            else {
                const footer = this._footer;
                if (footer != null) {
                    footer.show();
                }
                else {
                    this.close();
                }
            }
        }
        onRejected(message) {
            if (message != null) {
                this.message.text = message;
            }
            this.message.state.set(DBaseState.FAILED, DBaseState.SUCCEEDED);
            const footer = this._footer;
            if (footer != null) {
                footer.show();
            }
            else {
                this.onDone(this._delayClose);
            }
        }
        resolve(message) {
            if (!this._isDone) {
                this._isDone = true;
                const elapsedTime = Date.now() - this._startTime;
                const delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(() => {
                        this._timeoutId = undefined;
                        this.onResolved(message);
                    }, delay);
                }
                else {
                    this.onResolved(message);
                }
            }
        }
        reject(message) {
            if (!this._isDone) {
                this._isDone = true;
                const elapsedTime = Date.now() - this._startTime;
                const delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(() => {
                        this._timeoutId = undefined;
                        this.onRejected(message);
                    }, delay);
                }
                else {
                    this.onRejected(message);
                }
            }
        }
        onCloseOn() {
            if (this._isDone) {
                super.onCloseOn();
            }
        }
        getType() {
            return "DDialogProcessing";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDialogSaveAs extends DDialogInputText {
        onOpen() {
            const name = DControllers.getDocumentController().getName();
            if (name != null) {
                this.input.value = name;
            }
            super.onOpen();
        }
        onOk(value) {
            super.onOk(value);
            const commandController = DControllers.getCommandController();
            if (isString(value)) {
                commandController.push(new DCommandSaveAs(value));
            }
            else {
                value.then((resolved) => {
                    commandController.push(new DCommandSaveAs(resolved));
                });
            }
        }
        getType() {
            return "DDialogSaveAs";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DDropdown extends DDropdownBase {
        getType() {
            return "DDropdown";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DExpandableHeader extends DImage {
        constructor(options) {
            super(options);
            this.on(UtilPointerEvent.down, (e) => {
                if (this.state.isActionable) {
                    this.onSelect(e);
                }
            });
        }
        onSelect(e) {
            this.emit("select", this);
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            return super.onKeyDown(e);
        }
        onKeyDownActivate(e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onSelect(e);
                return true;
            }
            return false;
        }
        getType() {
            return "DExpandableHeader";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DExpandable extends DLayoutVertical {
        init(options) {
            super.init(options);
            // Header
            const theme = this.theme;
            const header = this.toHeader(theme, options);
            this._header = header;
            header.on("select", () => {
                this.toggle();
            });
            this.addChild(header);
            // Body
            const body = this.toBody(theme, options);
            this._body = body;
            this.addChild(body);
            //
            if (this.state.isActive) {
                this.onActivated();
            }
            else {
                this.onDeactivated();
            }
        }
        toHeader(theme, options) {
            if (options && options.header) {
                if (options.header instanceof pixi_js.DisplayObject) {
                    return options.header;
                }
                else {
                    return this.newHeader(theme, options.header);
                }
            }
            return this.newHeader(theme);
        }
        newHeader(theme, options) {
            return new DExpandableHeader(options);
        }
        toBody(theme, options) {
            return options.body;
        }
        open() {
            this.state.isActive = true;
        }
        close() {
            this.state.isActive = false;
        }
        toggle() {
            this.state.isActive = !this.state.isActive;
        }
        onActivated() {
            const body = this._body;
            if (body instanceof DBase) {
                body.show();
            }
            else {
                body.visible = true;
            }
        }
        onDeactivated() {
            const body = this._body;
            if (body instanceof DBase) {
                body.hide();
            }
            else {
                body.visible = false;
            }
        }
        onStateChange(newState, oldState) {
            super.onStateChange(newState, oldState);
            if (newState.isActive) {
                if (!oldState.isActive) {
                    this.onActivated();
                }
            }
            else {
                if (oldState.isActive) {
                    this.onDeactivated();
                }
            }
        }
        getType() {
            return "DExpandable";
        }
    }

    const DIndicatorProcessingState = {
        INITIAL: 0,
        STARTED: 1,
        RESOLVED: 2,
        REJECTED: 3
    };
    class DIndicatorProcessing {
        constructor(parent, options) {
            var _a, _b, _c, _d, _e, _f, _g;
            this._parent = parent;
            this._state = DIndicatorProcessingState.INITIAL;
            this._startTime = 0;
            // Delay
            const theme = this.theme;
            const delay = options === null || options === void 0 ? void 0 : options.delay;
            this._delayDone = (_a = delay === null || delay === void 0 ? void 0 : delay.done) !== null && _a !== void 0 ? _a : theme.getProcessDoneDelay();
            const delayClose = delay === null || delay === void 0 ? void 0 : delay.close;
            this._delayClose = delayClose !== undefined ? delayClose : theme.getProcessCloseDelay();
            // Text
            const text = options === null || options === void 0 ? void 0 : options.text;
            this._isTextEnabled = (_b = text === null || text === void 0 ? void 0 : text.enabled) !== null && _b !== void 0 ? _b : theme.isProcessTextEnabled();
            this._textValue = (_c = text === null || text === void 0 ? void 0 : text.value) !== null && _c !== void 0 ? _c : theme.newProcessTextValue();
            // Image
            const image = options === null || options === void 0 ? void 0 : options.image;
            this._isImageEnabled = (_d = image === null || image === void 0 ? void 0 : image.enabled) !== null && _d !== void 0 ? _d : theme.isProcessImageEnabled();
            this._imageIndex = (_e = image === null || image === void 0 ? void 0 : image.index) !== null && _e !== void 0 ? _e : theme.getProcessImageIndex();
            this._imageSource = (_f = image === null || image === void 0 ? void 0 : image.source) !== null && _f !== void 0 ? _f : theme.newProcessImageSource();
            this._imageRotation = (_g = image === null || image === void 0 ? void 0 : image.rotation) !== null && _g !== void 0 ? _g : theme.newProcessImageRotation();
            // State
            this._wasReadOnly = false;
        }
        start() {
            const state = this._state;
            if (state === DIndicatorProcessingState.INITIAL) {
                this._state = DIndicatorProcessingState.STARTED;
                this.onBegin();
            }
            else if (state === DIndicatorProcessingState.RESOLVED ||
                state === DIndicatorProcessingState.REJECTED) {
                this._state = DIndicatorProcessingState.STARTED;
                this.onEnd();
                this.onBegin();
            }
            return this;
        }
        onBegin() {
            this._startTime = Date.now();
            const timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
            const closeTimeoutId = this._closeTimeoutId;
            if (closeTimeoutId != null) {
                clearTimeout(closeTimeoutId);
            }
            const parent = this._parent;
            const state = parent.state;
            state.lock();
            state.ticker.remove(DBaseState.PROCESSING).add(DBaseState.PROCESSING, 32);
            state.removeAll(DBaseState.SUCCEEDED, DBaseState.FAILED);
            this._wasReadOnly = state.isReadOnly;
            if (!this._wasReadOnly) {
                state.add(DBaseState.READ_ONLY);
            }
            state.unlock();
            if (this._isTextEnabled) {
                this._textValueBackup = parent.text.value;
                const textValue = this._textValue;
                if (textValue !== undefined) {
                    parent.text = textValue;
                }
            }
            if (this._isImageEnabled) {
                const image = parent.image.get(this._imageIndex);
                if (image != null) {
                    this._imageSourceBackup = image.source;
                    this._imageRotationBackup = image.rotation;
                    const imageSource = this._imageSource;
                    if (imageSource !== undefined) {
                        image.source = imageSource;
                    }
                    const imageRotation = this._imageRotation;
                    if (imageRotation !== undefined) {
                        image.rotation = imageRotation;
                    }
                }
            }
        }
        end() {
            const state = this._state;
            if (state === DIndicatorProcessingState.STARTED ||
                state === DIndicatorProcessingState.RESOLVED ||
                state === DIndicatorProcessingState.REJECTED) {
                this._state = DIndicatorProcessingState.INITIAL;
                this.onEnd();
            }
            return this;
        }
        onEnd() {
            const timeoutId = this._timeoutId;
            if (timeoutId != null) {
                clearTimeout(timeoutId);
            }
            const closeTimeoutId = this._closeTimeoutId;
            if (closeTimeoutId != null) {
                clearTimeout(closeTimeoutId);
            }
            const parent = this._parent;
            const state = parent.state;
            state.lock();
            state.ticker.remove(DBaseState.PROCESSING);
            state.removeAll(DBaseState.SUCCEEDED, DBaseState.FAILED);
            if (!this._wasReadOnly) {
                state.remove(DBaseState.READ_ONLY);
            }
            state.unlock();
            if (this._isTextEnabled) {
                parent.text = this._textValueBackup;
            }
            if (this._isImageEnabled) {
                const image = parent.image.get(this._imageIndex);
                if (image != null) {
                    image.source = this._imageSourceBackup;
                    image.rotation = this._imageRotationBackup;
                }
            }
        }
        resolve(message) {
            if (this._state === DIndicatorProcessingState.STARTED) {
                this._state = DIndicatorProcessingState.RESOLVED;
                const elapsedTime = Date.now() - this._startTime;
                const delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(() => {
                        this._timeoutId = undefined;
                        this.onResolved(message);
                    }, delay);
                }
                else {
                    this.onResolved(message);
                }
            }
        }
        onResolved(message) {
            const parent = this._parent;
            if (this._isTextEnabled && message != null) {
                parent.text = message;
            }
            const state = parent.state;
            state.lock();
            state.ticker.remove(DBaseState.PROCESSING);
            state.add(DBaseState.SUCCEEDED);
            state.remove(DBaseState.FAILED);
            if (!this._wasReadOnly) {
                state.remove(DBaseState.READ_ONLY);
            }
            state.unlock();
            this.onDone(this._delayClose);
        }
        reject(message) {
            if (this._state === DIndicatorProcessingState.STARTED) {
                this._state = DIndicatorProcessingState.REJECTED;
                const elapsedTime = Date.now() - this._startTime;
                const delay = this._delayDone - elapsedTime;
                if (0 < delay) {
                    this._timeoutId = window.setTimeout(() => {
                        this._timeoutId = undefined;
                        this.onRejected(message);
                    }, delay);
                }
                else {
                    this.onRejected(message);
                }
            }
        }
        onRejected(message) {
            const parent = this._parent;
            if (this._isTextEnabled && message != null) {
                parent.text = message;
            }
            const state = parent.state;
            state.lock();
            state.ticker.remove(DBaseState.PROCESSING);
            state.add(DBaseState.FAILED);
            state.remove(DBaseState.SUCCEEDED);
            if (!this._wasReadOnly) {
                state.remove(DBaseState.READ_ONLY);
            }
            state.unlock();
            this.onDone(this._delayClose);
        }
        onDone(delay) {
            if (delay != null) {
                this._closeTimeoutId = window.setTimeout(() => {
                    this._closeTimeoutId = undefined;
                    this.end();
                }, delay);
            }
            else {
                this.end();
            }
        }
        getType() {
            return "DIndicatorProcessing";
        }
        get theme() {
            return DThemes.get(this.getType());
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputIntegerAndLabel extends DInputAndLabel {
        createInput(options) {
            return new DInputInteger(options);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DInputTextArea extends DInput {
        newUtil() {
            return new UtilInputTextArea(this, this.newOperation(), this.theme, this._options);
        }
        getType() {
            return "DInputTextArea";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A board for layouting elements.
     * Unlike {@link DLayoutVertical} and {@link DLayoutHorizontal},
     * this class doesn't change the position and the size of children.
     * Unlike {@link DBase} and {@link DBoard}, this class doesn't have
     * the background, the border, and the outline. And its children are
     * interactive by default.
     */
    class DLayoutBoard extends DBase {
        getType() {
            return "DLayoutBoard";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DListItemAmbient extends DListItem {
        getType() {
            return "DListItemAmbient";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMapCoordinateEPSG3857 {
        constructor(tileSize = 256) {
            this._tileSize = tileSize;
        }
        getTileSize() {
            return this._tileSize;
        }
        /**
         * Converts the given (lon, lat) point in WGS84 to (x, y) in EPSG:900913.
         * The origin of the converted point (x, y) is at the middle-left corner.
         * The `meters` can be the same instance that is passed in as the `lonlat`.
         *
         * @param lonlat (lon, lat) point
         * @param meters (x, y) point in meters converted from the given lonlat.
         * @return (x, y) point in meters
         * @see https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/
         * @see https://qiita.com/MALORGIS/items/1a9114dd090e5b891bf7
         */
        lonLatToMeters(lonlat, meters) {
            const C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = (lonlat.x * C) / 180;
            meters.y = (Math.log(Math.tan(((90 + lonlat.y) * Math.PI) / 360)) * C) / Math.PI;
            return meters;
        }
        /**
         * The `lonlat` can be the same instance that is passed in as the `meters`.
         *
         * @param meters
         * @param lonlat
         */
        metersToLonLat(meters, lonlat) {
            const C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            lonlat.x = (meters.x / C) * 180;
            lonlat.y = (Math.atan(Math.exp((meters.y * Math.PI) / C)) * 360) / Math.PI - 90;
            return lonlat;
        }
        /**
         * Converts pixel coordinates in given zoom level of pyramid to EPSG:900913.
         * The origin of the `pixels` is the top-left corner.
         * The `meters` can be the same instance that is passed in as the `pixels`.
         */
        pixelsToMeters(pixels, tz, tileSize, meters) {
            const R = this.toResolution(tz, tileSize);
            const C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = pixels.x * R - C;
            meters.y = C - pixels.y * R;
            return meters;
        }
        /**
         * Converts EPSG:900913 to pyramid pixel coordinates in given zoom level.
         * The origin of the pixels is the top-left corner.
         * The `pixels` can be the same instance that is passed in as the `meters`.
         */
        metersToPixels(meters, tz, tileSize, pixels) {
            const R = this.toResolution(tz, tileSize);
            const C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            pixels.x = (meters.x + C) / R;
            pixels.y = (C - meters.y) / R;
            return pixels;
        }
        /**
         * Returns a tile covering region in given pixel coordinates.
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `pixels`.
         */
        pixelsToTile(pixels, tileSize, tile) {
            tile.x = Math.ceil(pixels.x / tileSize) - 1;
            tile.y = Math.ceil(pixels.y / tileSize) - 1;
            return tile;
        }
        /**
         * The origin of the tile is the top-left corner.
         * The `tile` can be the same instance that is passed in as the `meters`.
         */
        metersToTile(meters, tz, tile) {
            const C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            const Z = 1 << tz;
            tile.x = Math.ceil(0.5 * (meters.x / C + 1) * Z) - 1;
            tile.y = Math.ceil(0.5 * (1 - meters.y / C) * Z) - 1;
            return tile;
        }
        lonLatToTile(lonlat, tz, tile) {
            return this.metersToTile(this.lonLatToMeters(lonlat, tile), tz, tile);
        }
        lonLatToPixels(lonlat, tz, tileSize, pixels) {
            return this.metersToPixels(this.lonLatToMeters(lonlat, pixels), tz, tileSize, pixels);
        }
        pixelsToLonLat(pixels, tz, tileSize, lonlat) {
            return this.metersToLonLat(this.pixelsToMeters(pixels, tz, tileSize, lonlat), lonlat);
        }
        /**
         * The `pixels` can be the same instance that is passed in as the `tile`.
         */
        tileToPixels(tile, tileSize, pixels) {
            pixels.x = tile.x * tileSize;
            pixels.y = tile.y * tileSize;
            return pixels;
        }
        /**
         * Returns bounds of the given tile in EPSG:900913 coordinates
         * The `meters` can be the same instance that is passed in as the `tile`.
         */
        tileToMeters(tile, tz, meters) {
            const R = this.toResolutionMeter(tz);
            const C = DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF;
            meters.x = tile.x * R + C;
            meters.y = C - tile.y * R;
            return meters;
        }
        toResolutionMeter(tz) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (1 << tz);
        }
        toResolution(tz, tileSize) {
            return (2 * DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF) / (tileSize << tz);
        }
        toTileCount(tz) {
            return 1 << tz;
        }
        toTileCode(tz, tx, ty) {
            return (tx << tz) + ty;
        }
    }
    DMapCoordinateEPSG3857.CIRCUMFERENCE_HALF = Math.PI * 6378137 /* Approximate earth radius in meter */;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMapCoordinates {
        static get DEFAULT() {
            if (this._default == null) {
                this._default = new DMapCoordinateEPSG3857();
            }
            return this._default;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMapTile {
        constructor(parent, tx, ty, px, py, scale) {
            this.tx = tx;
            this.ty = ty;
            const sprite = new pixi_js.Sprite(pixi_js.Texture.EMPTY);
            sprite.parent = parent;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
            this._sprite = sprite;
        }
        load(url, onLoaded) {
            const texture = pixi_js.Texture.from(url, { resolution: 1 });
            this._sprite.texture = texture;
            if (texture.valid) {
                onLoaded();
            }
            else {
                texture.on("update", onLoaded);
            }
        }
        transform(px, py, scale) {
            const sprite = this._sprite;
            sprite.position.set(px, py);
            sprite.scale.set(scale, scale);
        }
        get loaded() {
            return this._sprite.texture.valid;
        }
        render(renderer) {
            const sprite = this._sprite;
            sprite.updateTransform();
            sprite.render(renderer);
        }
        destroy() {
            const sprite = this._sprite;
            const texture = sprite.texture;
            const resource = texture.baseTexture.resource;
            let image = null;
            if (resource instanceof pixi_js.resources.BaseImageResource) {
                if (resource.source instanceof HTMLImageElement) {
                    image = resource.source;
                }
            }
            texture.destroy(true);
            sprite.destroy();
            if (image) {
                image.src = "";
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMapTilePlane {
        constructor(parent, builder, tz, mapping, coordinate, onLoaded) {
            this._parent = parent;
            this._builder = builder;
            this._onLoaded = onLoaded;
            this._isOnLoadedCalled = false;
            this._isOnLoadedAllowed = true;
            this._onLoadedBound = () => {
                this.onLoaded();
            };
            this._tz = tz;
            this._lon0 = NaN;
            this._lat0 = NaN;
            this._lon1 = NaN;
            this._lat1 = NaN;
            this._tiles = new Map();
            this._renderTileBound = (tile) => {
                this.renderTile(tile);
            };
            this._txmin = NaN;
            this._txmax = NaN;
            this._tymin = NaN;
            this._tymax = NaN;
            this._deleteTileBound = (tile, tileCode, tiles) => {
                this.deleteTile(tile, tileCode, tiles);
            };
            this._destroyTileBound = (tile) => {
                this.destroyTile(tile);
            };
            this._updateLoadingStateForEach = (tile) => {
                if (!tile.loaded) {
                    this._isLoaded = false;
                }
            };
            this._tileCount = coordinate.toTileCount(tz);
            this._tileScaleRelative = 1 / this._tileCount;
            this._tileScale = mapping.scale * this._tileScaleRelative;
            this._tileSize = coordinate.getTileSize() * mapping.scale;
            this._mapping = mapping;
            this._coordinate = coordinate;
            this._isLoaded = true;
        }
        newTile(tx, ty, px, py, scale) {
            return new DMapTile(this._parent, tx, ty, px, py, scale);
        }
        renderTile(tile) {
            tile.render(this._renderer);
        }
        get tz() {
            return this._tz;
        }
        render(renderer) {
            this._renderer = renderer;
            this._tiles.forEach(this._renderTileBound);
        }
        move(lon0, lat0, lon1, lat1) {
            const oldLon0 = this._lon0;
            const oldLat0 = this._lat0;
            const oldLon1 = this._lon1;
            const oldLat1 = this._lat1;
            if (oldLon0 !== lon0 || oldLat0 !== lat0 || oldLon1 !== lon1 || oldLat1 !== lat1) {
                this._lon0 = lon0;
                this._lat0 = lat0;
                this._lon1 = lon1;
                this._lat1 = lat1;
                const tz = this._tz;
                const coordinate = this._coordinate;
                const work = DMapTilePlane.WORK;
                work.set(lon0, lat0);
                coordinate.lonLatToTile(work, tz, work);
                const tx0 = work.x;
                const ty0 = work.y;
                work.set(lon1, lat1);
                coordinate.lonLatToTile(work, tz, work);
                const tx1 = work.x;
                const ty1 = work.y;
                const tileCount = this._tileCount;
                let txmin = Math.max(0, tx0);
                let txmax = Math.min(tileCount - 1, tx1);
                let tymin = Math.max(0, ty0);
                let tymax = Math.min(tileCount - 1, ty1);
                const dtxmin = txmin - this._txmin;
                const dtxmax = txmax - this._txmax;
                const dtymin = tymin - this._tymin;
                const dtymax = tymax - this._tymax;
                const isTxMinChanged = dtxmin !== dtxmin || dtxmin < 0 || 1 < dtxmin;
                const isTxMaxChanged = dtxmax !== dtxmax || 0 < dtxmax || dtxmax < -1;
                const isTyMinChanged = dtymin !== dtymin || dtymin < 0 || 1 < dtymin;
                const isTyMaxChanged = dtymax !== dtymax || 0 < dtymax || dtymax < -1;
                if (isTxMinChanged || isTxMaxChanged || isTyMinChanged || isTyMaxChanged) {
                    if (isTxMinChanged) {
                        this._txmin = txmin;
                    }
                    else {
                        txmin = this._txmin;
                    }
                    if (isTxMaxChanged) {
                        this._txmax = txmax;
                    }
                    else {
                        txmax = this._txmax;
                    }
                    if (isTyMinChanged) {
                        this._tymin = tymin;
                    }
                    else {
                        tymin = this._tymin;
                    }
                    if (isTyMaxChanged) {
                        this._tymax = tymax;
                    }
                    else {
                        tymax = this._tymax;
                    }
                    const tiles = this._tiles;
                    tiles.forEach(this._deleteTileBound);
                    const ctx = (txmin + txmax) >> 1;
                    const cty = (tymin + tymax) >> 1;
                    const ltx = Math.max(ctx - txmin, txmax - ctx);
                    const lty = Math.max(cty - tymin, tymax - cty);
                    const lt = Math.max(ltx, lty);
                    this.toOffset(work);
                    const offsetX = work.x;
                    const offsetY = work.y;
                    this._isOnLoadedCalled = false;
                    this._isOnLoadedAllowed = false;
                    this.loadTile(tz, ctx, cty, offsetX, offsetY, work);
                    for (let it = 1; it <= lt; ++it) {
                        const txa = ctx - it;
                        if (txmin <= txa) {
                            this.loadTilesY(tz, txa, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        const txb = ctx + it;
                        if (txb <= txmax) {
                            this.loadTilesY(tz, txb, cty, it, tymin, tymax, offsetX, offsetY, work);
                        }
                        const tya = cty - it;
                        if (tymin <= tya) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tya, offsetX, offsetY, work);
                        }
                        const tyb = cty + it;
                        if (tyb <= tymax) {
                            this.loadTilesX(tz, ctx, it - 1, txmin, txmax, tyb, offsetX, offsetY, work);
                        }
                    }
                    this._isOnLoadedAllowed = true;
                    if (this._isOnLoadedCalled) {
                        this.onLoaded();
                    }
                }
            }
        }
        loadTilesX(tz, ctx, ltx, txmin, txmax, ty, ox, oy, work) {
            this.loadTile(tz, ctx, ty, ox, oy, work);
            for (let i = 1; i <= ltx; ++i) {
                const txa = ctx - i;
                if (txmin <= txa) {
                    this.loadTile(tz, txa, ty, ox, oy, work);
                }
                const txb = ctx + i;
                if (txb <= txmax) {
                    this.loadTile(tz, txb, ty, ox, oy, work);
                }
            }
        }
        loadTilesY(tz, tx, cty, lty, tymin, tymax, ox, oy, work) {
            this.loadTile(tz, tx, cty, ox, oy, work);
            for (let i = 1; i <= lty; ++i) {
                const tya = cty - i;
                if (tymin <= tya) {
                    this.loadTile(tz, tx, tya, ox, oy, work);
                }
                const tyb = cty + i;
                if (tyb <= tymax) {
                    this.loadTile(tz, tx, tyb, ox, oy, work);
                }
            }
        }
        loadTile(tz, tx, ty, ox, oy, work) {
            const coordinate = this._coordinate;
            const tileCode = coordinate.toTileCode(tz, tx, ty);
            const tiles = this._tiles;
            let tile = tiles.get(tileCode);
            if (tile == null) {
                this.toTilePosition(tx, ty, ox, oy, work);
                tile = this.newTile(tx, ty, work.x, work.y, this._tileScale);
                tiles.set(tileCode, tile);
                tile.load(this._builder(tz, tx, ty), this._onLoadedBound);
                this._isLoaded = false;
            }
        }
        toTilePosition(tx, ty, ox, oy, result) {
            const tileSize = this._tileSize;
            const tileScaleRelative = this._tileScaleRelative;
            result.set(tx, ty);
            this._coordinate.tileToPixels(result, tileSize, result);
            result.set(result.x * tileScaleRelative + ox, result.y * tileScaleRelative + oy);
            return result;
        }
        toOffset(result) {
            const parent = this._parent;
            const mapping = this._mapping;
            const tileSize = this._tileSize;
            result.set(-mapping.x * tileSize + parent.width * 0.5, -mapping.y * tileSize + parent.height * 0.5);
            return result;
        }
        deleteTile(tile, tileCode, tiles) {
            const tx = tile.tx;
            const ty = tile.ty;
            if (tx < this._txmin || this._txmax < tx || ty < this._tymin || this._tymax < ty) {
                tiles.delete(tileCode);
                tile.destroy();
            }
        }
        destroy() {
            const tiles = this._tiles;
            tiles.forEach(this._destroyTileBound);
            tiles.clear();
        }
        destroyTile(tile) {
            tile.destroy();
        }
        updateLoadingState() {
            this._isLoaded = true;
            this._tiles.forEach(this._updateLoadingStateForEach);
        }
        onLoaded() {
            if (this._isOnLoadedAllowed) {
                this._onLoaded();
            }
            else {
                this._isOnLoadedCalled = true;
            }
        }
        get loaded() {
            if (!this._isLoaded) {
                this.updateLoadingState();
            }
            return this._isLoaded;
        }
        get mapping() {
            return this._mapping;
        }
        set mapping(mapping) {
            const coordinate = this._coordinate;
            const tileScale = mapping.scale * this._tileScaleRelative;
            const tileSize = coordinate.getTileSize() * mapping.scale;
            this._tileScale = tileScale;
            this._tileSize = tileSize;
            this._mapping = mapping;
            const work = DMapTilePlane.WORK;
            this.toOffset(work);
            const offsetX = work.x;
            const offsetY = work.y;
            this._tiles.forEach((tile) => {
                this.toTilePosition(tile.tx, tile.ty, offsetX, offsetY, work);
                tile.transform(work.x, work.y, tileScale);
            });
        }
    }
    DMapTilePlane.WORK = new pixi_js.Point();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMapTilePyramidImpl extends pixi_js.utils.EventEmitter {
        constructor(options) {
            super();
            const canvas = options.canvas;
            this._canvas = canvas;
            this._builder = options.builder;
            const mapping = options.mapping;
            this._mapping = mapping;
            const coordinate = options.coordinate;
            this._coordinate = coordinate;
            this._mappingInternal = this.toMapping(canvas, mapping, coordinate);
            this._z = NaN;
            this._tz = NaN;
            this._minZ = options.plane.min;
            this._maxZ = options.plane.max;
            this._planes = [];
            this._onLoadedBound = () => {
                this.onLoaded();
            };
            this._fitBound = () => {
                this._fitBoundTimeout = undefined;
                this.fit();
            };
            this._fitThrottle = options.plane.throttle;
            const fitThrottledBound = () => {
                this.fitThrottled();
            };
            this._fitThrottledBound = fitThrottledBound;
            canvas.on("scale", fitThrottledBound);
            canvas.on("move", fitThrottledBound);
            canvas.snippet.add(this, true);
        }
        get coordinate() {
            return this._coordinate;
        }
        fitThrottled() {
            if (this._fitBoundTimeout == null) {
                this._fitBoundTimeout = window.setTimeout(this._fitBound, this._fitThrottle);
            }
        }
        toMapping(canvas, mapping, coordinate) {
            const work = DMapTilePyramidImpl.WORK_LONLAT;
            const tileSize = coordinate.getTileSize();
            work.set(mapping.from.lon, mapping.from.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            const x0 = work.x;
            const y0 = work.y;
            work.set(mapping.to.lon, mapping.to.lat);
            coordinate.lonLatToPixels(work, 0, tileSize, work);
            const x1 = work.x;
            const y1 = work.y;
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const dmin = 0.0000001;
            let scale = 1;
            if (dmin < dx) {
                if (dmin < dy) {
                    scale = Math.max(canvas.width / dx, canvas.height / dy);
                }
                else {
                    scale = canvas.width / dx;
                }
            }
            else {
                if (dmin < dy) {
                    scale = canvas.height / dy;
                }
            }
            return {
                scale,
                x: (0.5 * (x1 + x0)) / tileSize,
                y: (0.5 * (y1 + y0)) / tileSize
            };
        }
        get mapping() {
            return this._mapping;
        }
        set mapping(mapping) {
            const oldMapping = this._mappingInternal;
            const newMapping = this.toMapping(this._canvas, mapping, this._coordinate);
            const threshold = 0.0000001;
            if (threshold < Math.abs(oldMapping.scale - newMapping.scale) ||
                threshold < Math.abs(oldMapping.x - newMapping.x) ||
                threshold < Math.abs(oldMapping.y - newMapping.y)) {
                this._mappingInternal = newMapping;
                const planes = this._planes;
                for (let i = 0, imax = planes.length; i < imax; ++i) {
                    const plane = planes[i];
                    if (plane) {
                        plane.mapping = newMapping;
                    }
                }
                DApplications.update(this._canvas);
                this._fitThrottledBound();
            }
        }
        newPlane(tz) {
            return new DMapTilePlane(this._canvas, this._builder, tz, this._mappingInternal, this._coordinate, this._onLoadedBound);
        }
        render(renderer) {
            const tz = this._tz;
            const planes = this._planes;
            for (let i = 0; i < tz; ++i) {
                const plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            for (let i = planes.length - 1; tz < i; --i) {
                const plane = planes[i];
                if (plane != null) {
                    plane.render(renderer);
                }
            }
            const planeTz = planes[tz];
            if (planeTz != null) {
                planeTz.render(renderer);
            }
        }
        toTileZ(tz) {
            return Math.min(this._maxZ, Math.max(this._minZ, Math.floor(tz)));
        }
        updateTransform() {
            // DO NOTHING
        }
        toZ(scale) {
            return Math.log(this._mappingInternal.scale * scale) / Math.log(2);
        }
        move(scale, lon0, lat0, lon1, lat1) {
            const planes = this._planes;
            const z = this.toZ(scale);
            if (this._z !== z) {
                this._z = z;
                const tz = this.toTileZ(z);
                if (this._tz !== tz) {
                    this._tz = tz;
                    let newPlane = planes[tz];
                    if (newPlane == null) {
                        newPlane = this.newPlane(tz);
                        planes[tz] = newPlane;
                    }
                }
            }
            const plane = planes[this._tz];
            if (plane != null) {
                plane.move(lon0, lat0, lon1, lat1);
            }
            return this;
        }
        fit() {
            const canvas = this._canvas;
            if (canvas != null) {
                const container = canvas.parent;
                if (container != null) {
                    const scale = canvas.scale;
                    const scaleX = scale.x;
                    const scaleY = scale.y;
                    const x = canvas.x;
                    const y = canvas.y;
                    const coordinate = this._coordinate;
                    const mapping = this._mappingInternal;
                    const tileSize = coordinate.getTileSize() * mapping.scale;
                    const x0 = mapping.x * tileSize - (x / scaleX + 0.5 * canvas.width);
                    const x1 = x0 + container.width / scaleX;
                    const y0 = mapping.y * tileSize - (y / scaleY + 0.5 * canvas.height);
                    const y1 = y0 + container.height / scaleY;
                    const work = DMapTilePyramidImpl.WORK_LONLAT;
                    work.set(x0, y0);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    const lon0 = work.x;
                    const lat0 = work.y;
                    work.set(x1, y1);
                    coordinate.pixelsToLonLat(work, 0, tileSize, work);
                    const lon1 = work.x;
                    const lat1 = work.y;
                    this.move(scaleX, lon0, lat0, lon1, lat1);
                }
            }
            return this;
        }
        destroyPlanesBefore(tz, planes) {
            for (let i = 0; i < tz; ++i) {
                const plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        }
        destroyPlanesAfter(tz, planes) {
            for (let i = tz + 1, imax = planes.length; i < imax; ++i) {
                const plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
        }
        cleanup() {
            const tz = this._tz;
            const planes = this._planes;
            const planeTz = planes[tz];
            if (planeTz && planeTz.loaded) {
                this.destroyPlanesBefore(tz, planes);
                this.destroyPlanesAfter(tz, planes);
                return;
            }
            for (let i = tz + 1, imax = planes.length; i < imax; ++i) {
                const plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(tz, planes);
                    this.destroyPlanesAfter(i, planes);
                    return;
                }
            }
            for (let i = tz - 1; 0 <= i; --i) {
                const plane = planes[i];
                if (plane && plane.loaded) {
                    this.destroyPlanesBefore(i, planes);
                    return;
                }
            }
        }
        onLoaded() {
            this.cleanup();
            DApplications.update(this._canvas);
        }
        destroy() {
            const planes = this._planes;
            for (let i = 0, imax = planes.length; i < imax; ++i) {
                const plane = planes[i];
                if (plane) {
                    plane.destroy();
                    planes[i] = undefined;
                }
            }
            const canvas = this._canvas;
            const fitThrottledBound = this._fitThrottledBound;
            canvas.off("scale", fitThrottledBound);
            canvas.off("move", fitThrottledBound);
            canvas.snippet.remove(this, true);
            return this;
        }
    }
    DMapTilePyramidImpl.WORK_LONLAT = new pixi_js.Point();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DMapTileUrlBuilderKokudo = (tz, tx, ty) => {
        if (5 <= tz) {
            return `https://cyberjapandata.gsi.go.jp/xyz/pale/${tz}/${tx}/${ty}.png`;
        }
        else if (2 <= tz) {
            return `https://cyberjapandata.gsi.go.jp/xyz/std/${tz}/${tx}/${ty}.png`;
        }
        else {
            return `https://cyberjapandata.gsi.go.jp/xyz/earthhillshade/${tz}/${tx}/${ty}.png`;
        }
    };
    const DMapTileUrlBuilderOsm = (tz, tx, ty) => {
        return `https://${"abc"[(tx + ty) % 3]}.tile.openstreetmap.org/${tz}/${tx}/${ty}.png`;
    };
    const DMapTileUrlBuilderOsmfj = (tz, tx, ty) => {
        return `https://j.tile.openstreetmap.jp/${tz}/${tx}/${ty}.png`;
    };
    class DMapTilePyramids {
        static toPlaneOptions(options) {
            var _a, _b, _c;
            const plane = options.plane;
            return {
                min: (_a = plane === null || plane === void 0 ? void 0 : plane.min) !== null && _a !== void 0 ? _a : this.MIN,
                max: (_b = plane === null || plane === void 0 ? void 0 : plane.max) !== null && _b !== void 0 ? _b : this.MAX,
                throttle: (_c = plane === null || plane === void 0 ? void 0 : plane.throttle) !== null && _c !== void 0 ? _c : this.THROTTLE
            };
        }
        static from(options) {
            return new DMapTilePyramidImpl({
                canvas: options.canvas,
                builder: options.builder || DMapTileUrlBuilderOsmfj,
                mapping: options.canvas.tile.mapping,
                coordinate: options.coordinate || DMapCoordinates.DEFAULT,
                plane: this.toPlaneOptions(options)
            });
        }
    }
    DMapTilePyramids.MIN = 0;
    DMapTilePyramids.MAX = 18;
    DMapTilePyramids.THROTTLE = 333;

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuBarItem extends DButton {
        toMenu(theme, options) {
            const menu = options === null || options === void 0 ? void 0 : options.menu;
            if (menu instanceof DMenu) {
                return menu;
            }
            else {
                return new DMenu(this.toMenuOptions(theme, menu));
            }
        }
        newMenu(theme, options) {
            return new DMenu(this.toMenuOptions(theme, options));
        }
        toMenuOptions(theme, options) {
            if (options) {
                if (options.fit == null) {
                    options.fit = false;
                }
                return options;
            }
            return {
                fit: false
            };
        }
        onActivate(e) {
            super.onActivate(e);
            this.open();
        }
        open() {
            this.menu.open(this);
        }
        close() {
            this.menu.close();
        }
        get menu() {
            let result = this._menu;
            if (result == null) {
                result = this.toMenu(this.theme, this._options);
                result.on("select", (value, item, menu) => {
                    this.onMenuSelect(value, item, menu);
                });
                this._menu = result;
            }
            return result;
        }
        onMenuSelect(value, item, menu) {
            this.emit("select", value, item, this);
            const parent = this.parent;
            if (parent) {
                parent.emit("select", value, item, parent);
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.onKeyDownArrowDown(e);
            }
            return super.onKeyDown(e);
        }
        onKeyDownArrowDown(e) {
            if (this.state.isActionable && this.state.isFocused) {
                this.onActivate(e);
                return true;
            }
            return false;
        }
        getType() {
            return "DMenuBarItem";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuBar extends DLayoutHorizontal {
        init(options) {
            super.init(options);
            const items = options === null || options === void 0 ? void 0 : options.items;
            if (items) {
                for (let i = 0, imax = items.length; i < imax; ++i) {
                    const item = this.toItem(items[i]);
                    if (item) {
                        this.addChild(item);
                    }
                }
            }
        }
        toItem(item) {
            if (item == null) {
                return null;
            }
            else if (item instanceof pixi_js.DisplayObject) {
                return item;
            }
            else if ("space" in item) {
                return new DLayoutSpace(item);
            }
            return new DMenuBarItem(item);
        }
        onKeyDown(e) {
            UtilKeyboardEvent.moveFocusHorizontally(e, this);
            return super.onKeyDown(e);
        }
        getType() {
            return "DMenuBar";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSidedContent extends DLayoutHorizontal {
        initReflowable() {
            // DO NOTHING
        }
        getType() {
            return "DMenuSidedContent";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DMenuSidedSelectionType = {
        NONE: 0,
        SINGLE: 1,
        SINGLE_ONCE: 2
    };
    const defaultFilter = () => true;
    class DMenuSidedSelection extends pixi_js.utils.EventEmitter {
        constructor(content, options) {
            var _a, _b, _c;
            super();
            this._content = content;
            this._item = null;
            this._isDirty = true;
            this._type = toEnum((_b = (_a = options === null || options === void 0 ? void 0 : options.mode) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : DMenuSidedSelectionType.SINGLE_ONCE, DMenuSidedSelectionType);
            this._filter = (_c = options === null || options === void 0 ? void 0 : options.filter) !== null && _c !== void 0 ? _c : this.getFilterDefault();
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        first() {
            return this._item;
        }
        toDirty() {
            this._isDirty = true;
        }
        update() {
            if (this._isDirty) {
                this._isDirty = false;
                this.update_(this._content);
            }
        }
        hasMenu(child) {
            return child && child.menu instanceof DMenu;
        }
        update_(root) {
            const children = root.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child instanceof DMenuItemBase) {
                    if (child.state.isActive) {
                        this.set_(child, false);
                    }
                }
                if (child instanceof pixi_js.Container) {
                    this.update_(child);
                }
                if (this.hasMenu(child)) {
                    this.update_(child.menu);
                }
            }
        }
        add(item) {
            this.update();
            this.set_(item, true);
        }
        set(item) {
            this.update();
            this.set_(item, true);
        }
        get(index) {
            this.update();
            return this._item;
        }
        getIndex(index) {
            return null;
        }
        size() {
            return this._item ? 1 : 0;
        }
        isEmpty() {
            return this._item == null;
        }
        remove(item) {
            this.update();
            if (this._item === item) {
                this.set_(null, true);
            }
        }
        clear() {
            this.update();
            this.set_(null, true);
        }
        getFilterDefault() {
            return defaultFilter;
        }
        set_(item, emit) {
            const oldItem = this._item;
            const mode = this._type;
            if (mode !== DMenuSidedSelectionType.NONE && this._filter(item) && oldItem !== item) {
                this.setState(oldItem, mode, false);
                this._item = item;
                this.setState(item, mode, true);
                if (emit) {
                    this.emit("change", this);
                }
            }
        }
        setState(item, mode, isOn) {
            if (item) {
                if (mode === DMenuSidedSelectionType.SINGLE) {
                    item.state.isActive = isOn;
                }
                else {
                    if (isOn) {
                        item.state.addAll(DBaseState.ACTIVE, DBaseState.READ_ONLY);
                    }
                    else {
                        item.state.removeAll(DBaseState.ACTIVE, DBaseState.READ_ONLY);
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DMenuSided extends DPane {
        constructor(options) {
            var _a;
            super(options);
            const context = new DMenuContext(this);
            this._context = context;
            context.add(this);
            const items = options === null || options === void 0 ? void 0 : options.items;
            if (items != null) {
                const sticky = (_a = options === null || options === void 0 ? void 0 : options.sticky) !== null && _a !== void 0 ? _a : false;
                this.newItems(items, sticky);
            }
            const selection = options === null || options === void 0 ? void 0 : options.selection;
            this._selection =
                selection instanceof DMenuSidedSelection ? selection : this.newSelection(selection);
        }
        newSelection(options) {
            return new DMenuSidedSelection(this.content, options);
        }
        onHierarchyDirty() {
            const selection = this._selection;
            if (selection != null) {
                selection.toDirty();
            }
            super.onHierarchyDirty();
        }
        newItems(items, sticky) {
            DMenuSideds.newItems(this.content, items, sticky);
        }
        newContent(options) {
            return new DMenuSidedContent(options);
        }
        get selection() {
            return this._selection;
        }
        getContext() {
            return this._context;
        }
        getCloseable() {
            return this;
        }
        open() {
            // DO NOTHING
        }
        close() {
            // DO NOTHING
        }
        onKeyDown(e) {
            UtilKeyboardEvent.moveFocusVertically(e, this);
            return super.onKeyDown(e);
        }
        getType() {
            return "DMenuSided";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DNoteError extends DNote {
        getType() {
            return "DNoteError";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DNoteNoItemsFound extends DNote {
        getType() {
            return "DNoteNoItemsFound";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DNoteSearching extends DNote {
        getType() {
            return "DNoteSearching";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DNotification extends DBase {
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPaginationButtonLast extends DButtonAmbient {
        getType() {
            return "DPaginationButtonLast";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPaginationButtonNext extends DButtonAmbient {
        getType() {
            return "DPaginationButtonNext";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPaginationButtonPage extends DButtonAmbient {
        getType() {
            return "DPaginationButtonPage";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPaginationButtonPrevious extends DButtonAmbient {
        getType() {
            return "DPaginationButtonPrevious";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPaginationButtonTop extends DButtonAmbient {
        getType() {
            return "DPaginationButtonTop";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPaginationDots extends DImageBase {
        getType() {
            return "DPaginationDots";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPaginationPage extends DImageBase {
        getType() {
            return "DPaginationPage";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPagination extends DLayoutHorizontal {
        constructor(options) {
            var _a, _b, _c, _d;
            super(options);
            if (options != null) {
                this._size = (_b = (_a = options.size) !== null && _a !== void 0 ? _a : options.total) !== null && _b !== void 0 ? _b : 10;
                this._value = (_d = (_c = options.value) !== null && _c !== void 0 ? _c : options.selected) !== null && _d !== void 0 ? _d : 0;
            }
            else {
                this._size = 10;
                this._value = 0;
            }
            const buttonTop = this.buttonTop;
            if (buttonTop != null) {
                this.addChild(buttonTop);
            }
            const buttonPrevious = this.buttonPrevious;
            if (buttonPrevious != null) {
                this.addChild(buttonPrevious);
            }
            const spaceLeft = this.spaceLeft;
            if (spaceLeft != null) {
                this.addChild(spaceLeft);
            }
            const buttonPages0 = this.buttonPages0;
            const buttonPages0Length = buttonPages0.length;
            this.addChild(buttonPages0[0]);
            this.addChild(this.dots0);
            for (let i = 1; i < buttonPages0Length; ++i) {
                this.addChild(buttonPages0[i]);
            }
            this.addChild(this.page);
            const buttonPages1 = this.buttonPages1;
            const buttonPages1Length = buttonPages1.length;
            for (let i = 0, imax = buttonPages1Length - 1; i < imax; ++i) {
                this.addChild(buttonPages1[i]);
            }
            this.addChild(this.dots1);
            this.addChild(buttonPages1[buttonPages1Length - 1]);
            const spaceRight = this.spaceRight;
            if (spaceRight != null) {
                this.addChild(spaceRight);
            }
            const buttonNext = this.buttonNext;
            if (buttonNext != null) {
                this.addChild(buttonNext);
            }
            const buttonLast = this.buttonLast;
            if (buttonLast != null) {
                this.addChild(buttonLast);
            }
        }
        /**
         * Sets a value that is an index of a current page.
         *
         * @param value a value that is an index of a page
         */
        set value(value) {
            if (0 <= value && value < this._size && this._value !== value) {
                this._value = value;
                this.toDirty();
                DApplications.update(this);
            }
        }
        /**
         * Returns a value that is an index of a current page.
         *
         * @returns a value that is an index of a selected page.
         */
        get value() {
            return this._value;
        }
        /**
         * Selects a page.
         *
         * @param index an index of a page
         * @deprecated in favor of {@link value}.
         */
        set selected(index) {
            this.value = index;
        }
        /**
         * Returns an index of the selected page.
         *
         * @returns an index of the selected page.
         * @deprecated in favor of {@link value}.
         */
        get selected() {
            return this.value;
        }
        /**
         * Sets a number of total pages.
         *
         * @param size a number of pages
         */
        set size(size) {
            if (0 <= size && this._size !== size) {
                this._size = size;
                if (size === 0) {
                    this._value = -1;
                }
                else {
                    this._value = Math.max(0, Math.min(this._size - 1, this._value));
                }
                this.toDirty();
                DApplications.update(this);
            }
        }
        /**
         * Returns a number of total pages.
         *
         * @returns a number of total pages.
         */
        get size() {
            return this._size;
        }
        /**
         * Sets a number of total pages.
         *
         * @param total a number of pages
         * @deprecated in favor of {@link size}
         */
        set total(total) {
            this.size = total;
        }
        /**
         * Returns a number of total pages.
         *
         * @returns a number of total pages.
         * @deprecated in favor of {@link size}
         */
        get total() {
            return this.size;
        }
        get dots0() {
            let result = this._dots0;
            if (result == null) {
                result = this.newDots();
                this._dots0 = result;
            }
            return result;
        }
        get dots1() {
            let result = this._dots1;
            if (result == null) {
                result = this.newDots();
                this._dots1 = result;
            }
            return result;
        }
        newDots() {
            return new DPaginationDots();
        }
        get buttonLast() {
            let result = this._buttonLast;
            if (result === undefined) {
                result = this.newButtonLast();
                this._buttonLast = result;
            }
            return result;
        }
        newButtonLast() {
            var _a, _b;
            const last = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.last;
            if (last !== null && last !== false && last !== undefined) {
                const result = new DPaginationButtonLast(last !== true ? last : undefined);
                result.on("active", () => {
                    this.onButtonLastActive();
                });
                return result;
            }
            return null;
        }
        onButtonLastActive() {
            this.goToLast();
        }
        /**
         * Goes to the last page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param silently true to suppress the change event
         * @returns true if succeeded.
         */
        goToLast(silently) {
            return this.goTo(this._size - 1, silently);
        }
        /**
         * Goes to the given page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param index a page index
         * @param silently true to suppress the change event
         * @returns this
         */
        goTo(index, silently) {
            if (0 <= index && index < this._size && this._value !== index) {
                const oldIndex = this._value;
                this._value = index;
                if (silently !== true) {
                    this.emit("change", index, oldIndex, this);
                }
                this.toDirty();
                DApplications.update(this);
                return true;
            }
            return false;
        }
        get buttonNext() {
            let result = this._buttonNext;
            if (result === undefined) {
                result = this.newButtonNext();
                this._buttonNext = result;
            }
            return result;
        }
        newButtonNext() {
            var _a, _b;
            const next = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.next;
            if (next !== null && next !== false) {
                const result = new DPaginationButtonNext(next !== true ? next : undefined);
                result.on("active", () => {
                    this.onButtonNextActive();
                });
                return result;
            }
            return null;
        }
        onButtonNextActive() {
            this.goToNext();
        }
        /**
         * Goes to the next page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param silently true to suppress the change event
         * @returns true if succeeded.
         */
        goToNext(silently) {
            return this.goTo(this._value + 1, silently);
        }
        get buttonPrevious() {
            let result = this._buttonPrevious;
            if (result === undefined) {
                result = this.newButtonPrevious();
                this._buttonPrevious = result;
            }
            return result;
        }
        newButtonPrevious() {
            var _a, _b;
            const previous = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.previous;
            if (previous !== null && previous !== false) {
                const result = new DPaginationButtonPrevious(previous !== true ? previous : undefined);
                result.on("active", () => {
                    this.onButtonPreviousActive();
                });
                return result;
            }
            return null;
        }
        onButtonPreviousActive() {
            this.goToPrevious();
        }
        /**
         * Goes to the previous page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param silently true to suppress the change event
         * @returns true if succeeded.
         */
        goToPrevious(silently) {
            return this.goTo(this._value - 1, silently);
        }
        get buttonTop() {
            let result = this._buttonTop;
            if (result === undefined) {
                result = this.newButtonTop();
                this._buttonTop = result;
            }
            return result;
        }
        newButtonTop() {
            var _a, _b;
            const top = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.top;
            if (top !== null && top !== false && top !== undefined) {
                const result = new DPaginationButtonTop(top !== true ? top : undefined);
                result.on("active", () => {
                    this.onButtonTopActive();
                });
                return result;
            }
            return null;
        }
        onButtonTopActive() {
            this.goToTop();
        }
        /**
         * Goes to the top page.
         * Unlike {@link value}, this method emits the change event if silently is not true.
         *
         * @param silently true to suppress the change event
         * @returns true if succeeded.
         */
        goToTop(silently) {
            return this.goTo(0, silently);
        }
        newButtonPage() {
            var _a, _b;
            const result = new DPaginationButtonPage((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.page);
            result.on("active", () => {
                this.onButtonPageActive(result);
            });
            return result;
        }
        get buttonPages0() {
            let result = this._buttonPages0;
            if (result == null) {
                result = this.newButtonPages0();
                this._buttonPages0 = result;
            }
            return result;
        }
        newButtonPages0() {
            return [
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage()
            ];
        }
        allocButtonPages0(size) {
            const buttonPages0 = this.buttonPages0;
            const buttonPages0Length = buttonPages0.length;
            const index = this.getChildIndex(buttonPages0[buttonPages0Length - 1]) + 1;
            for (let i = 0, imax = size - buttonPages0Length; i < imax; ++i) {
                const buttonPage = this.newButtonPage();
                this.addChildAt(buttonPage, index + i);
                buttonPages0.push(buttonPage);
            }
        }
        get buttonPages1() {
            let result = this._buttonPages1;
            if (result == null) {
                result = this.newButtonPages1();
                this._buttonPages1 = result;
            }
            return result;
        }
        newButtonPages1() {
            return [
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage(),
                this.newButtonPage()
            ];
        }
        allocButtonPages1(size) {
            const buttonPages1 = this.buttonPages1;
            const buttonPages1Length = buttonPages1.length;
            const index = this.getChildIndex(buttonPages1[0]);
            for (let i = 0, imax = size - buttonPages1Length; i < imax; ++i) {
                const buttonPage = this.newButtonPage();
                this.addChildAt(buttonPage, index);
                buttonPages1.unshift(buttonPage);
            }
        }
        get page() {
            let result = this._page;
            if (result == null) {
                result = this.newPage();
                this._page = result;
            }
            return result;
        }
        newPage() {
            var _a;
            return new DPaginationPage((_a = this._options) === null || _a === void 0 ? void 0 : _a.page);
        }
        onButtonPageActive(button) {
            const text = button.text.value;
            if (isNumber(text)) {
                this.goTo(text - 1);
                if (button.state.isFocused) {
                    button.state.isHovered = false;
                    this.page.focus();
                }
            }
        }
        get spaceLeft() {
            let result = this._spaceLeft;
            if (result === undefined) {
                result = this.newSpaceLeft();
                this._spaceLeft = result;
            }
            return result;
        }
        newSpaceLeft() {
            if (this.buttonTop != null || this.buttonPrevious != null) {
                return this.newSpace();
            }
            return null;
        }
        get spaceRight() {
            let result = this._spaceRight;
            if (result === undefined) {
                result = this.newSpaceRight();
                this._spaceRight = result;
            }
            return result;
        }
        newSpaceRight() {
            if (this.buttonLast != null || this.buttonNext != null) {
                return this.newSpace();
            }
            return null;
        }
        newSpace() {
            var _a, _b;
            const space = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.button) === null || _b === void 0 ? void 0 : _b.space;
            if (space !== null && space !== false) {
                if (space === true || space === undefined) {
                    return new DLayoutSpace({
                        weight: 1
                    });
                }
                else if (isNumber(space)) {
                    return new DLayoutSpace({
                        width: space
                    });
                }
                else {
                    return new DLayoutSpace(space);
                }
            }
            return null;
        }
        onReflow() {
            this.update();
            super.onReflow();
        }
        update() {
            const size = this._size;
            const value = this._value;
            if (size <= 0) {
                this.doUpdate0(value, size);
            }
            else {
                if (this._auto.width.isOn) {
                    this.doUpdate2(value, size, 0, 0, 0, 0);
                }
                else {
                    this.doUpdate1(value, size);
                }
            }
        }
        doUpdate0(value, size) {
            const buttonTop = this.buttonTop;
            if (buttonTop != null) {
                buttonTop.state.isEnabled = false;
            }
            const buttonPrevious = this.buttonPrevious;
            if (buttonPrevious != null) {
                buttonPrevious.state.isEnabled = false;
            }
            this.hideDots(this.dots0);
            const buttonPages0 = this.buttonPages0;
            for (let i = 0, imax = buttonPages0.length; i < imax; ++i) {
                this.hidePage(buttonPages0[i]);
            }
            this.hidePage(this.page);
            const buttonPages1 = this.buttonPages1;
            for (let i = 0, imax = buttonPages1.length; i < imax; ++i) {
                this.hidePage(buttonPages1[i]);
            }
            this.hideDots(this.dots1);
            const buttonNext = this.buttonNext;
            if (buttonNext != null) {
                buttonNext.state.isEnabled = false;
            }
            const buttonLast = this.buttonLast;
            if (buttonLast) {
                buttonLast.state.isEnabled = false;
            }
        }
        doUpdate1(value, size) {
            let required = 0;
            let nrequired = 0;
            const buttonTop = this.buttonTop;
            if (buttonTop != null) {
                required += buttonTop.width;
                nrequired += 1;
            }
            const buttonPrevious = this.buttonPrevious;
            if (buttonPrevious != null) {
                required += buttonPrevious.width;
                nrequired += 1;
            }
            const spaceLeft = this.spaceLeft;
            if (spaceLeft != null) {
                if (spaceLeft.weight < 0) {
                    required += spaceLeft.width;
                }
                nrequired += 1;
            }
            const page = this.page;
            required += page.width;
            nrequired += 1;
            const spaceRight = this.spaceRight;
            if (spaceRight != null) {
                if (spaceRight.weight < 0) {
                    required += spaceRight.width;
                }
                nrequired += 1;
            }
            const buttonNext = this.buttonNext;
            if (buttonNext != null) {
                required += buttonNext.width;
                nrequired += 1;
            }
            const buttonLast = this.buttonLast;
            if (buttonLast) {
                required += buttonLast.width;
                nrequired += 1;
            }
            const marginHorizontal = this._margin.horizontal;
            if (2 <= nrequired) {
                required += (nrequired - 1) * marginHorizontal;
            }
            const padding = this.padding;
            const space = this.width - (padding.getLeft() + padding.getRight());
            if (space <= required) {
                this.doUpdate2(value, size, 4, 4, 0, 0);
            }
            else {
                const buttonPages0 = this.buttonPages0;
                const buttonPage0Width = buttonPages0[0].width;
                const nrequired0 = value;
                const required0 = nrequired0 * (buttonPage0Width + marginHorizontal);
                const buttonPages1 = this.buttonPages1;
                const buttonPage1Width = buttonPages1[0].width;
                const nrequired1 = size - (value + 1);
                const required1 = nrequired1 * (buttonPage1Width + marginHorizontal);
                if (required + required0 + required1 <= space) {
                    this.doUpdate2(value, size, 0, 0, 0, 0);
                }
                else {
                    const dots1 = this.dots1;
                    const dots1Width = dots1.width;
                    const dots0 = this.dots0;
                    const dots0Width = dots0.width;
                    const m0 = marginHorizontal + buttonPage0Width;
                    const m1 = marginHorizontal + buttonPage1Width;
                    const required0n = dots0Width + m0;
                    const required1n = dots1Width + m1;
                    const required0m = required0n + m0;
                    const required1m = required1n + m1;
                    if (required0 <= required1) {
                        if (3 <= nrequired1 && required + required0 + required1m <= space) {
                            const l = space - (required + required0 + required1m);
                            const n1 = Math.floor(l / m1);
                            this.doUpdate2(value, size, 0, 1, 0, n1);
                        }
                        else if (3 <= nrequired0 &&
                            3 <= nrequired1 &&
                            required + required0m + required1m <= space) {
                            const l = space - (required + required0m + required1m);
                            const n1 = Math.floor((l * 0.5) / m1);
                            const n0 = Math.floor((l - n1 * m1) / m0);
                            this.doUpdate2(value, size, 1, 1, n0, n1);
                        }
                        else if (2 <= nrequired1 && required + required0 + required1n <= space) {
                            this.doUpdate2(value, size, 0, 2, 0, 0);
                        }
                        else if (3 <= nrequired0 &&
                            2 <= nrequired1 &&
                            required + required0m + required1n <= space) {
                            const l = space - (required + required0m + required1n);
                            const n0 = Math.floor(l / m0);
                            this.doUpdate2(value, size, 1, 2, n0, 0);
                        }
                        else if (2 <= nrequired0 &&
                            2 <= nrequired1 &&
                            required + required0n + required1n <= space) {
                            this.doUpdate2(value, size, 2, 2, 0, 0);
                        }
                        else if (1 <= nrequired0 &&
                            1 <= nrequired1 &&
                            required + dots0Width + dots1Width <= space) {
                            this.doUpdate2(value, size, 3, 3, 0, 0);
                        }
                        else {
                            this.doUpdate2(value, size, 4, 4, 0, 0);
                        }
                    }
                    else {
                        if (3 <= nrequired0 && required + required0m + required1 <= space) {
                            const l = space - (required + required0m + required1);
                            const n0 = Math.floor(l / m0);
                            this.doUpdate2(value, size, 1, 0, n0, 0);
                        }
                        else if (3 <= nrequired0 &&
                            3 <= nrequired1 &&
                            required + required0m + required1m <= space) {
                            const l = space - (required + required0m + required1m);
                            const n0 = Math.floor((l * 0.5) / m0);
                            const n1 = Math.floor((l - n0 * m0) / m1);
                            this.doUpdate2(value, size, 1, 1, n0, n1);
                        }
                        else if (2 <= nrequired0 && required + required0n + required1 <= space) {
                            this.doUpdate2(value, size, 2, 0, 0, 0);
                        }
                        else if (2 <= nrequired0 &&
                            3 <= nrequired1 &&
                            required + required0n + required1m <= space) {
                            const l = space - (required + required0n + required1m);
                            const n1 = Math.floor(l / m1);
                            this.doUpdate2(value, size, 2, 1, 0, n1);
                        }
                        else if (2 <= nrequired0 &&
                            2 <= nrequired1 &&
                            required + required0n + required1n <= space) {
                            this.doUpdate2(value, size, 2, 2, 0, 0);
                        }
                        else if (1 <= nrequired0 &&
                            1 <= nrequired1 &&
                            required + dots0Width + dots1Width <= space) {
                            this.doUpdate2(value, size, 3, 3, 0, 0);
                        }
                        else {
                            this.doUpdate2(value, size, 4, 4, 0, 0);
                        }
                    }
                }
            }
        }
        doUpdate2(value, size, left, right, nleft1, nright1) {
            const buttonTop = this.buttonTop;
            if (buttonTop != null) {
                buttonTop.state.isEnabled = 0 < value;
            }
            const buttonPrevious = this.buttonPrevious;
            if (buttonPrevious != null) {
                buttonPrevious.state.isEnabled = 0 < value;
            }
            const buttonPages0 = this.buttonPages0;
            switch (left) {
                case 0:
                    this.hideDots(this.dots0);
                    this.allocButtonPages0(value);
                    for (let i = 0, imax = buttonPages0.length; i < imax; ++i) {
                        if (i < value) {
                            this.showPage(buttonPages0[i], i);
                        }
                        else {
                            this.hidePage(buttonPages0[i]);
                        }
                    }
                    break;
                case 1:
                    this.showDots(this.dots0, 1, value - 2 - nleft1);
                    this.allocButtonPages0(2 + nleft1);
                    this.showPage(buttonPages0[0], 0);
                    for (let i = 1, imax = buttonPages0.length - nleft1 - 1; i < imax; ++i) {
                        this.hidePage(buttonPages0[i]);
                    }
                    for (let i = 0, imax = 1 + nleft1; i < imax; ++i) {
                        this.showPage(buttonPages0[buttonPages0.length - imax + i], value - 1 - (imax - 1) + i);
                    }
                    break;
                case 2:
                    this.showDots(this.dots0, 0, value - 2);
                    for (let i = 0, imax = buttonPages0.length - 1; i < imax; ++i) {
                        this.hidePage(buttonPages0[i]);
                    }
                    this.showPage(buttonPages0[buttonPages0.length - 1], value - 1);
                    break;
                case 3:
                    this.showDots(this.dots0, 0, value - 1);
                    for (let i = 0, imax = buttonPages0.length; i < imax; ++i) {
                        this.hidePage(buttonPages0[i]);
                    }
                    break;
                case 4:
                    this.hideDots(this.dots0);
                    for (let i = 0, imax = buttonPages0.length; i < imax; ++i) {
                        this.hidePage(buttonPages0[i]);
                    }
                    break;
            }
            this.showPage(this.page, value);
            const buttonPages1 = this.buttonPages1;
            switch (right) {
                case 0:
                    this.allocButtonPages1(size - (value + 1));
                    for (let i = 0, imax = buttonPages1.length; i < imax; ++i) {
                        const j = value + 1 + i;
                        if (j < size) {
                            this.showPage(buttonPages1[i], j);
                        }
                        else {
                            this.hidePage(buttonPages1[i]);
                        }
                    }
                    this.hideDots(this.dots1);
                    break;
                case 1:
                    this.allocButtonPages1(2 + nright1);
                    for (let i = 0, imax = 1 + nright1; i < imax; ++i) {
                        this.showPage(buttonPages1[i], value + 1 + i);
                    }
                    for (let i = 1 + nright1, imax = buttonPages1.length - 1; i < imax; ++i) {
                        this.hidePage(buttonPages1[i]);
                    }
                    this.showPage(buttonPages1[buttonPages1.length - 1], size - 1);
                    this.showDots(this.dots1, value + 2 + nright1, size - 2);
                    break;
                case 2:
                    this.showPage(buttonPages1[0], value + 1);
                    for (let i = 1, imax = buttonPages1.length; i < imax; ++i) {
                        this.hidePage(buttonPages1[i]);
                    }
                    this.showDots(this.dots1, value + 2, size - 1);
                    break;
                case 3:
                    for (let i = 0, imax = buttonPages1.length; i < imax; ++i) {
                        this.hidePage(buttonPages1[i]);
                    }
                    this.showDots(this.dots1, value + 1, size - 1);
                    break;
                case 4:
                    for (let i = 0, imax = buttonPages1.length; i < imax; ++i) {
                        this.hidePage(buttonPages1[i]);
                    }
                    this.hideDots(this.dots1);
                    break;
            }
            const buttonNext = this.buttonNext;
            if (buttonNext != null) {
                buttonNext.state.isEnabled = value < size - 1;
            }
            const buttonLast = this.buttonLast;
            if (buttonLast != null) {
                buttonLast.state.isEnabled = value < size - 1;
            }
        }
        showPage(button, index) {
            button.text = index + 1;
            button.show();
        }
        hidePage(button) {
            button.hide();
        }
        showDots(dots, from, to) {
            dots.show();
        }
        hideDots(dots) {
            dots.hide();
        }
        getType() {
            return "DPagination";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerDatetimeRange extends DBase {
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DPickerTimeRange extends DBase {
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A multi-value selector class.
     */
    class DSelectMultiple extends DDropdownBase {
        constructor(options) {
            super(options);
            // Default values
            this._values = [];
            const values = options === null || options === void 0 ? void 0 : options.values;
            if (values) {
                this.values = values;
            }
        }
        onMenuSelect(value, item, menu) {
            super.onMenuSelect(value, item, menu);
            if (item instanceof DMenuItemCheck) {
                const oldValues = this._values;
                const newValues = [];
                const newItems = [];
                if (item.state.isActive) {
                    this.updateMenuItems(menu, oldValues, value, undefined, newValues, newItems);
                }
                else {
                    this.updateMenuItems(menu, oldValues, undefined, value, newValues, newItems);
                }
                this._values = newValues;
                this.text = newItems;
                this.onValueChange(newValues, oldValues, newItems);
            }
        }
        onMenuReplaced(newMenu, oldMenu) {
            super.onMenuReplaced(newMenu, oldMenu);
            // Update the values
            const values = this._values;
            const newValues = [];
            const newItems = [];
            this.updateMenuItems(newMenu, values, undefined, undefined, newValues, newItems);
            this._values = newValues;
            this.text = newItems;
        }
        onValueChange(newValues, oldValues, items) {
            this.emit("change", newValues, oldValues, items, this);
        }
        onMenuOpening(menu) {
            super.onMenuOpening(menu);
            this.updateMenuItems(this.menu, this._values);
        }
        /**
         * Returns selected values.
         */
        get values() {
            return this.getValues();
        }
        /**
         * Sets to the specified values.
         */
        set values(values) {
            this.setValues(values);
        }
        getValues() {
            return this._values;
        }
        setValues(values, forcibly) {
            const oldValues = this._values;
            if (forcibly || !this.isSameValues(values, oldValues)) {
                const newValues = [];
                const newItems = [];
                this.updateMenuItems(this.menu, values, undefined, undefined, newValues, newItems);
                this._values = newValues;
                this.text.setValue(newItems, forcibly);
            }
        }
        isSameValues(a, b) {
            if (a.length === b.length) {
                for (let i = 0, imax = a.length; i < imax; ++i) {
                    if (b.indexOf(a[i]) < 0) {
                        return false;
                    }
                }
            }
            return false;
        }
        updateMenuItems(menu, oldValues, addedValue, removedValue, newValues, newItems) {
            const children = menu.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child instanceof DMenuItemMenu) {
                    this.updateMenuItems(child.menu, oldValues, addedValue, removedValue, newValues, newItems);
                }
                else if (child instanceof DMenuItemCheck) {
                    const childValue = child.value;
                    if (removedValue !== undefined && removedValue === childValue) {
                        child.state.isActive = false;
                    }
                    else if ((addedValue !== undefined && child.value === addedValue) ||
                        0 <= oldValues.indexOf(child.value)) {
                        if (newValues) {
                            newValues.push(child.value);
                        }
                        if (newItems) {
                            newItems.push(child);
                        }
                        child.state.isActive = true;
                    }
                    else {
                        child.state.isActive = false;
                    }
                }
            }
        }
        getType() {
            return "DSelectMultiple";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DShadowImpl extends pixi_js.NineSlicePlane {
        constructor(texture, width, height, offsetX, offsetY) {
            super(texture, width, height, width, height);
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._shiftX = width * 0.5;
            this._shiftY = height * 0.5;
            this.interactive = false;
            this.interactiveChildren = false;
            texture.on("update", () => {
                this.onTextureUpdate();
            });
        }
        onTextureUpdate() {
            this.emit("update", this);
        }
        onReflow(base, width, height) {
            const sx = this._shiftX;
            const sy = this._shiftY;
            this.x = -sx + this._offsetX;
            this.y = -sy + this._offsetY;
            this.width = sx + width + sx;
            this.height = sy + height + sy;
        }
        render(renderer) {
            const parent = this.parent;
            if (parent) {
                const alpha = parent.alpha;
                this.alpha = alpha * alpha * alpha;
            }
            super.render(renderer);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DSliderLabel extends DTextBase {
        init(options) {
            var _a;
            super.init(options);
            this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : 0;
        }
        set value(value) {
            this._value = value;
        }
        get value() {
            return this._value;
        }
        getType() {
            return "DSliderLabel";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DSliderThumb extends DButton {
        getType() {
            return "DSliderThumb";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DSliderValue extends DTextBase {
        constructor(options) {
            var _a, _b;
            super(options);
            this._value = (_a = options === null || options === void 0 ? void 0 : options.value) !== null && _a !== void 0 ? _a : 0;
            this._rounder = this.toRounder(options);
            this._delta = (_b = options === null || options === void 0 ? void 0 : options.delta) !== null && _b !== void 0 ? _b : 1;
        }
        toRounder(options) {
            var _a;
            const rounder = options === null || options === void 0 ? void 0 : options.rounder;
            if (rounder) {
                return rounder;
            }
            const precision = (_a = options === null || options === void 0 ? void 0 : options.precision) !== null && _a !== void 0 ? _a : this.theme.getPrecision();
            const base = Math.pow(10, precision);
            return (value) => {
                return Math.round(value * base) / base;
            };
        }
        set value(value) {
            this._value = value;
        }
        get value() {
            return this._value;
        }
        get rounder() {
            return this._rounder;
        }
        get delta() {
            return this._delta;
        }
        getType() {
            return "DSliderValue";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A slider class.
     */
    class DSlider extends DBase {
        init(options) {
            super.init(options);
            this._ratioValue = 0;
            this._track = this.newTrack(options);
            this.addChild(this._track);
            this._trackSelected = this.newTrackSelected(options);
            this._trackSelected.state.isActive = true;
            this.addChild(this._trackSelected);
            this._thumb = this.newThumb(options);
            this.addChild(this._thumb);
            this._min = this.newLabelMin(options);
            this.addChild(this._min);
            this._max = this.newLabelMax(options);
            this.addChild(this._max);
            this._value = this.newValue(options);
            this.addChild(this._value);
            // Event listeners
            this._track.on(UtilPointerEvent.down, (e) => {
                this._value.visible = this.state.inEnabled;
                this.onTrackDown(e.data.global);
            });
            this._trackSelected.on(UtilPointerEvent.down, (e) => {
                this._value.visible = this.state.inEnabled;
                this.onTrackSelectedDown(e.data.global);
            });
            this._onTrackUpBound = (e) => {
                this.onTrackUpBound(e);
                this._value.visible = false;
            };
            this._onTrackSelectedUpBound = (e) => {
                this.onTrackSelectedUpBound(e);
                this._value.visible = false;
            };
            this._thumb.on(UtilPointerEvent.down, (e) => {
                this._value.visible = true;
                this.onThumbDown(e);
            });
            this._onThumbMoveBound = (e) => {
                this.onThumbMove(e);
            };
            this._onThumbUpBound = (e) => {
                this.onThumbUp(e);
                this._value.visible = false;
            };
            //
            this.onValuesChange();
        }
        newThumb(options) {
            return new DSliderThumb(options === null || options === void 0 ? void 0 : options.thumb);
        }
        newValue(options) {
            return new DSliderValue(this.toValueOptions(options === null || options === void 0 ? void 0 : options.value));
        }
        toValueOptions(options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            const text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = options.value;
            }
            if (options.visible == null) {
                options.visible = false;
            }
            return options;
        }
        newLabelMin(options) {
            return new DSliderLabel(this.toLabelMinOptions(options === null || options === void 0 ? void 0 : options.min));
        }
        toLabelMinOptions(options) {
            options = options || {};
            if (options.value == null) {
                options.value = 0;
            }
            const text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = `${options.value}`;
            }
            return options;
        }
        newLabelMax(options) {
            return new DSliderLabel(this.toLabelMaxOptions(options === null || options === void 0 ? void 0 : options.max));
        }
        toLabelMaxOptions(options) {
            options = options || {};
            if (options.value == null) {
                options.value = 1;
            }
            const text = options.text || {};
            options.text = text;
            if (text.value == null) {
                text.value = `${options.value}`;
            }
            return options;
        }
        getValueMargin() {
            return 14;
        }
        onTrackDown(global) {
            if (this.state.inDisabled) {
                return;
            }
            const layer = DApplications.getLayer(this);
            if (layer) {
                const interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                const onTrackUpBound = this._onTrackUpBound;
                interactionManager.on(UtilPointerEvent.up, onTrackUpBound);
                interactionManager.on(UtilPointerEvent.upoutside, onTrackUpBound);
                interactionManager.on(UtilPointerEvent.cancel, onTrackUpBound);
            }
            this.onPick(global);
        }
        onTrackSelectedDown(global) {
            if (this.state.inDisabled) {
                return;
            }
            const layer = DApplications.getLayer(this);
            if (layer) {
                const interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                const onTrackSelectedUpBound = this._onTrackSelectedUpBound;
                interactionManager.on(UtilPointerEvent.up, onTrackSelectedUpBound);
                interactionManager.on(UtilPointerEvent.upoutside, onTrackSelectedUpBound);
                interactionManager.on(UtilPointerEvent.cancel, onTrackSelectedUpBound);
            }
            this.onPick(global);
        }
        onTrackUpBound(e) {
            const interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                const onTrackUpBound = this._onTrackUpBound;
                interactionManager.off(UtilPointerEvent.up, onTrackUpBound);
                interactionManager.off(UtilPointerEvent.upoutside, onTrackUpBound);
                interactionManager.off(UtilPointerEvent.cancel, onTrackUpBound);
            }
        }
        onTrackSelectedUpBound(e) {
            const interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                const onTrackSelectedUpBound = this._onTrackSelectedUpBound;
                interactionManager.off(UtilPointerEvent.up, onTrackSelectedUpBound);
                interactionManager.off(UtilPointerEvent.upoutside, onTrackSelectedUpBound);
                interactionManager.off(UtilPointerEvent.cancel, onTrackSelectedUpBound);
            }
        }
        onThumbMove(e) {
            if (this.state.inDisabled) {
                return;
            }
            this.onPick(e.data.global);
        }
        onThumbDown(e) {
            const layer = DApplications.getLayer(this);
            if (layer) {
                const interactionManager = layer.renderer.plugins.interaction;
                this._interactionManager = interactionManager;
                const onThumbMoveBound = this._onThumbMoveBound;
                interactionManager.on(UtilPointerEvent.move, onThumbMoveBound);
                const onThumbUpBound = this._onThumbUpBound;
                interactionManager.on(UtilPointerEvent.up, onThumbUpBound);
                interactionManager.on(UtilPointerEvent.upoutside, onThumbUpBound);
                interactionManager.on(UtilPointerEvent.cancel, onThumbUpBound);
            }
        }
        onThumbUp(e) {
            const interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = undefined;
                const onThumbMoveBound = this._onThumbMoveBound;
                interactionManager.off(UtilPointerEvent.move, onThumbMoveBound);
                const onThumbUpBound = this._onThumbUpBound;
                interactionManager.off(UtilPointerEvent.up, onThumbUpBound);
                interactionManager.off(UtilPointerEvent.upoutside, onThumbUpBound);
                interactionManager.off(UtilPointerEvent.cancel, onThumbUpBound);
            }
        }
        updateValue() {
            const min = this._min.value;
            const max = this._max.value;
            const value = this._value;
            const newValue = value.rounder(min + this._ratioValue * (max - min));
            const oldValue = value.value;
            if (newValue !== oldValue) {
                value.value = newValue;
                value.text = value.value;
                this.emit("change", newValue, oldValue, this);
            }
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
            this.onValuesChange();
        }
        /**
         * Returns a current value.
         */
        get value() {
            return this._value.value;
        }
        /**
         * Sets a current value.
         */
        set value(value) {
            value = Math.max(this._min.value, Math.min(this._max.value, value));
            // Adjust if value is new
            if (this._value.value !== value) {
                this._value.value = value;
                this.onValuesChange();
            }
        }
        /**
         * Returns a minimum value.
         */
        get min() {
            return this._min.value;
        }
        /**
         * Sets a minimum value.
         */
        set min(newMin) {
            const min = this._min;
            newMin = Math.min(this._max.value, newMin);
            if (min.value !== newMin) {
                const value = this._value;
                min.text = min.value = newMin;
                value.value = Math.max(newMin, value.value);
                this.onValuesChange();
            }
        }
        /**
         * Returns a maximum value.
         */
        get max() {
            return this._max.value;
        }
        /**
         * Sets a maximum value.
         */
        set max(newMax) {
            const max = this._max;
            newMax = Math.max(this._min.value, newMax);
            if (max.value !== newMax) {
                const value = this._value;
                max.text = max.value = newMax;
                value.value = Math.min(newMax, value.value);
                this.onValuesChange();
            }
        }
        getType() {
            return "DSlider";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DSliderTrack extends DButton {
        getType() {
            return "DSliderTrack";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DSliderTrackHorizontal extends DSliderTrack {
        getType() {
            return "DSliderTrackHorizontal";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DSliderHorizontal extends DSlider {
        newTrack(options) {
            return new DSliderTrackHorizontal(options === null || options === void 0 ? void 0 : options.track);
        }
        newTrackSelected(options) {
            return new DSliderTrackHorizontal(options === null || options === void 0 ? void 0 : options.track);
        }
        toValueOptions(options) {
            options = super.toValueOptions(options);
            if (options.y == null) {
                options.y = (p, s) => p * 0.5 - s - this.getValueMargin();
            }
            return options;
        }
        toLabelMinOptions(options) {
            options = super.toLabelMinOptions(options);
            if (options.x == null) {
                options.x = (p, s) => -s * 0.5;
            }
            if (options.y == null) {
                options.y = (p, s) => -s;
            }
            return options;
        }
        toLabelMaxOptions(options) {
            options = super.toLabelMaxOptions(options);
            if (options.x == null) {
                options.x = (p, s) => p - s * 0.5;
            }
            if (options.y == null) {
                options.y = (p, s) => -s;
            }
            return options;
        }
        onPick(global) {
            const point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            const x = Math.max(0, Math.min(this._track.width, point.x));
            this._ratioValue = x / this._track.width;
            this.moveThumbPosition(x);
        }
        onValuesChange() {
            const min = this._min.value;
            const max = this._max.value;
            const value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            const x = this._ratioValue * this._track.width;
            this.moveThumbPosition(x);
        }
        moveThumbPosition(x) {
            const thumb = this._thumb;
            thumb.x = x - thumb.width * 0.5;
            this._trackSelected.width = x;
            const value = this._value;
            value.x = x - value.width * 0.5;
            this.updateValue();
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                this.value += this._value.delta;
            }
            else if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                this.value -= this._value.delta;
            }
            return super.onKeyDown(e);
        }
        getType() {
            return "DSliderHorizontal";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DSliderTrackVertical extends DSliderTrack {
        getType() {
            return "DSliderTrackVertical";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DSliderVertical extends DSlider {
        newTrack(options) {
            return new DSliderTrackVertical(options === null || options === void 0 ? void 0 : options.track);
        }
        newTrackSelected(options) {
            return new DSliderTrackVertical(options === null || options === void 0 ? void 0 : options.track);
        }
        toLabelMinOptions(options) {
            options = super.toLabelMinOptions(options);
            if (options.x == null) {
                options.x = (p, s) => -s;
            }
            if (options.y == null) {
                options.y = (p, s) => p - s * 0.5;
            }
            const text = options.text || {};
            options.text = text;
            const textAlign = text.align || {};
            text.align = textAlign;
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        }
        toLabelMaxOptions(options) {
            options = super.toLabelMaxOptions(options);
            if (options.x == null) {
                options.x = (p, s) => -s;
            }
            if (options.y == null) {
                options.y = (p, s) => -s * 0.5;
            }
            const text = options.text || {};
            options.text = text;
            const textAlign = text.align || {};
            text.align = textAlign;
            if (textAlign.horizontal == null) {
                textAlign.horizontal = DAlignHorizontal.RIGHT;
            }
            return options;
        }
        onPick(global) {
            const point = new pixi_js.Point(0, 0);
            this.toLocal(global, undefined, point);
            const height = this.height;
            const y = Math.max(0, Math.min(height, point.y));
            this._ratioValue = (height - y) / height;
            this.moveThumbPosition(y);
        }
        onValuesChange() {
            const min = this._min.value;
            const max = this._max.value;
            const value = this._value.value;
            this._ratioValue = (value - min) / (max - min);
            const y = this.height * (1 - this._ratioValue);
            this.moveThumbPosition(y);
        }
        moveThumbPosition(y) {
            const thumb = this._thumb;
            thumb.y = y - thumb.height * 0.5;
            const trackSelected = this._trackSelected;
            trackSelected.y = y;
            trackSelected.height = this.height - y;
            const value = this._value;
            value.y = y - value.height - this.getValueMargin();
            this.updateValue();
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isArrowUpKey(e)) {
                this.value += this._value.delta;
            }
            else if (UtilKeyboardEvent.isArrowDownKey(e)) {
                this.value -= this._value.delta;
            }
            return super.onKeyDown(e);
        }
        getType() {
            return "DSliderVertical";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCells {
        static set(target, row, columnIndex, column, readOnly) {
            var _a;
            const renderable = this.toRenderable(row, columnIndex, column);
            target.renderable = renderable;
            const state = target.state;
            state.lock();
            state.isDisabled = !renderable;
            if (readOnly !== false) {
                state.isReadOnly = this.toReadOnly(row, columnIndex, column);
            }
            const columnStateModifier = (_a = column.state) === null || _a === void 0 ? void 0 : _a.modifier;
            if (columnStateModifier) {
                columnStateModifier(row, columnIndex, target.state);
            }
            state.unlock();
        }
        static toReadOnly(row, columnIndex, column) {
            const enable = column.editing.enable;
            if (enable === true) {
                return false;
            }
            else if (enable === false) {
                return true;
            }
            else {
                return !enable(row, columnIndex);
            }
        }
        static toRenderable(row, columnIndex, column) {
            const renderable = column.renderable;
            if (renderable === true) {
                return true;
            }
            else if (renderable === false) {
                return false;
            }
            else {
                return renderable(row, columnIndex);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellSelectDialog extends DButton {
        constructor(columnIndex, column, onChange, options) {
            var _a;
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
            this._isSyncEnabled = (_a = options === null || options === void 0 ? void 0 : options.sync) !== null && _a !== void 0 ? _a : this.theme.isSyncEnabled();
        }
        onActivate(e) {
            var _a;
            super.onActivate(e);
            const selecting = this._column.selecting;
            const dialog = selecting.dialog;
            if (dialog) {
                const oldValue = (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
                selecting.setter(dialog, oldValue);
                dialog.open(this).then(() => {
                    const newValue = selecting.getter(dialog, oldValue);
                    if (this._isSyncEnabled) {
                        if (newValue !== oldValue) {
                            this.text = newValue;
                            this.onValueChange(newValue, oldValue);
                        }
                    }
                    else {
                        this.onValueChange(newValue, null);
                    }
                });
            }
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        get value() {
            var _a;
            return (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
        }
        set value(value) {
            this.text = value;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text.setValue(value, forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellSelectDialog";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellActionDialog extends DTableBodyCellSelectDialog {
        getType() {
            return "DTableBodyCellActionDialog";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellActionMenu extends DDropdown {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onMenuSelect(selected, item, menu) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, selected);
                super.onMenuSelect(selected, item, menu);
                this._onChange(selected, null, row, rowIndex, columnIndex, column, this);
            }
        }
        onKeyDownArrowDown(e) {
            return false;
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text.setValue(value, forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellActionMenu";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellSelectPromise extends DButton {
        constructor(columnIndex, column, onChange, options) {
            var _a;
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
            this._isSyncEnabled = (_a = options === null || options === void 0 ? void 0 : options.sync) !== null && _a !== void 0 ? _a : this.theme.isSyncEnabled();
        }
        onActivate(e) {
            super.onActivate(e);
            const selecting = this._column.selecting;
            const promise = selecting.promise;
            if (promise) {
                promise().then((newValue) => {
                    var _a;
                    if (this._isSyncEnabled) {
                        const oldValue = (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
                        if (newValue !== oldValue) {
                            this.text = newValue;
                            this.onValueChange(newValue, oldValue);
                        }
                    }
                    else {
                        this.onValueChange(newValue, null);
                    }
                });
            }
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        get value() {
            var _a;
            return (_a = this.text.computed) !== null && _a !== void 0 ? _a : null;
        }
        set value(value) {
            this.text = value;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text.setValue(value, forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellSelectPromise";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellActionPromise extends DTableBodyCellSelectPromise {
        getType() {
            return "DTableBodyCellActionPromise";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellText extends DImageBase {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text.setValue(value, forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellText";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellButton extends DTableBodyCellText {
        constructor(columnIndex, column, onChange, options) {
            var _a;
            super(columnIndex, column, onChange, options);
            this._when = toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : DButtonBaseWhen.CLICKED, DButtonBaseWhen);
            this.on(UtilPointerEvent.tap, (e) => {
                this.onClick(e);
            });
        }
        onClick(e) {
            if (this._when === DButtonBaseWhen.CLICKED && this.state.isActionable) {
                this.activate(e);
            }
        }
        onDblClick(e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED && this.state.isActionable) {
                this.activate(e);
            }
            return super.onDblClick(e, interactionManager);
        }
        activate(e) {
            this.onActivate(e);
        }
        onActivate(e) {
            this.emit("active", this);
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                this.emit("change", null, null, this);
                this._onChange(null, null, row, rowIndex, columnIndex, column, this);
            }
        }
        onActivateKeyDown(e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        }
        onActivateKeyUp(e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.onActivate(e);
                }
                this.state.isPressed = false;
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return super.onKeyDown(e);
        }
        onKeyUp(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return super.onKeyUp(e);
        }
        getType() {
            return "DTableBodyCellButton";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DTableColumnType = {
        INDEX: 0,
        TEXT: 1,
        INTEGER: 2,
        REAL: 3,
        CHECK: 4,
        CHECK_SINGLE: 5,
        COLOR: 6,
        BUTTON: 7,
        SELECT: 8,
        DATE: 9,
        DATETIME: 10,
        TIME: 11,
        ACTION: 12,
        LINK: 13,
        TREE: 14,
        TEXT_AREA: 15
    };

    /**
     * An update region when table cells get edited.
     *
     * * CELL: Edited cells (Default).
     * * ROW: Rows that edited cells belongs to.
     * * ALL: All the rows.
     */
    const DTableColumnUpdate = {
        CELL: 0,
        ROW: 1,
        ALL: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellCheck extends DButtonCheck {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onActivate(e) {
            super.onActivate(e);
            this.onValueChange(true, false);
        }
        onInactivate(e) {
            super.onInactivate(e);
            this.onValueChange(false, true);
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                const onChange = this._onChange;
                onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
                if (newValue && column.type === DTableColumnType.CHECK_SINGLE) {
                    this.onChangeSingle(rowIndex, columnIndex, column, onChange);
                }
            }
        }
        onChangeSingle(rowIndex, columnIndex, column, onChange) {
            const tableBodyRow = this.parent;
            if (tableBodyRow != null) {
                const tableBody = tableBodyRow.parent;
                if (tableBody != null) {
                    let isChanged = false;
                    const getter = column.getter;
                    const setter = column.setter;
                    const data = tableBody.data;
                    data.each((row, index) => {
                        if (rowIndex !== index && getter(row, columnIndex)) {
                            setter(row, columnIndex, false);
                            isChanged = true;
                            onChange(false, true, row, index, columnIndex, column, this);
                            return false;
                        }
                        return true;
                    });
                    if (isChanged && column.update !== DTableColumnUpdate.ALL) {
                        tableBody.update(true);
                    }
                }
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.state.isActive = !!value;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
        }
        getType() {
            return "DTableBodyCellCheck";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellColor extends DButtonColor {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                super.onValueChange(newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
            else {
                super.onValueChange(newValue, oldValue);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            const cell = this.value;
            if (isNumber(value)) {
                cell.color = value;
                cell.alpha = 1;
            }
            else if (isString(value)) {
                const parsed = Number(value);
                cell.color = parsed === parsed ? parsed : 0xffffff;
                cell.alpha = 1;
            }
            else if (value != null) {
                const color = value.color;
                const alpha = value.alpha;
                cell.color = isNumber(color) ? color : 0xffffff;
                cell.alpha = isNumber(alpha) ? alpha : 1;
            }
            else {
                cell.color = 0xffffff;
                cell.alpha = 1;
            }
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
        }
        getType() {
            return "DTableBodyCellColor";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellDate extends DButtonDate {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                super.onValueChange(newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
            else {
                super.onValueChange(newValue, oldValue);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                this.text.setValue(value, forcibly || this._forcibly);
            }
            else if (isNumber(value)) {
                const text = this.text;
                const computed = text.computed;
                if (computed === undefined) {
                    this.text = new Date(value);
                }
                else if (computed.getTime() !== value) {
                    computed.setTime(value);
                    text.compute(true);
                }
            }
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellDate";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellDatetime extends DButtonDatetime {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                super.onValueChange(newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
            else {
                super.onValueChange(newValue, oldValue);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                this.text.setValue(value, forcibly || this._forcibly);
            }
            else if (isNumber(value)) {
                const text = this.text;
                const computed = text.computed;
                if (computed == null) {
                    this.text = new Date(value);
                }
                else if (computed.getTime() !== value) {
                    computed.setTime(value);
                    text.compute(true);
                }
            }
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellDatetime";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellIndex extends DImageBase {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text.setValue(rowIndex, forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellIndex";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellInputInteger extends DInputInteger {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                super.onValueChange(newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text.setValue(Number(value), forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellInputInteger";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellInputReal extends DInputReal {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                super.onValueChange(newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text.setValue(Number(value), forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellInputReal";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellInputTextArea extends DInputTextArea {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                super.onValueChange(newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text.setValue(String(value), forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellInputTextArea";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellInputText extends DInputText {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                super.onValueChange(newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text.setValue(String(value), forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellInputText";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellInputTreeInput extends DInputText {
        newPadding(theme, options, callback) {
            return new DBasePaddingAdjustable(theme, options, callback);
        }
        get padding() {
            return this._padding;
        }
        getType() {
            return "DTableBodyCellInputTreeInput";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellInputTreeMarker extends DButtonBase {
        getType() {
            return "DTableBodyCellInputTreeMarker";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTable} states.
     */
    const DTableState = {
        /**
         * Start cells in rows.
         */
        START: "START",
        /**
         * End cells in rows.
         */
        END: "END",
        /**
         * Cells of frozen columns.
         */
        FROZEN: "FROZEN",
        /**
         * Cells of a right-most frozen column.
         */
        FROZEN_END: "FROZEN_END",
        /**
         * Rows with data
         */
        HAS_DATA: "HAS_DATA",
        /**
         * Header cells of sortable columns.
         */
        SORTABLE: "SORTABLE",
        /**
         * Header cells of columns sorted in the ascending order.
         */
        SORTED_ASCENDING: "SORTED_ASCENDING",
        /**
         * Header cells of columns sorted in the descending order.
         */
        SORTED_DESCENDING: "SORTED_DESCENDING",
        /**
         * Tree cells with child cells.
         */
        HAS_CHILDREN: "HAS_CHILDREN",
        /**
         * Tree cells opened.
         */
        OPENED: "OPENED",
        /**
         * Header cells of checkable columns.
         */
        CHECKABLE: "CHECKABLE",
        /**
         * Selectable row
         */
        SELECTABLE: "SELECTABLE",
        /**
         * Header or category cells hovered on their edges.
         */
        HOVERED_ON_EDGE: "HOVERED_ON_EDGE",
        /**
         * Header or category of being resized.
         */
        RESIZING: "RESIZING"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toBaseOptions = (options) => {
        if (options != null) {
            return {
                weight: options.weight,
                width: options.width
            };
        }
        return undefined;
    };
    class DTableBodyCellInputTree extends DBase {
        constructor(columnIndex, column, onChange, options) {
            super(toBaseOptions(options));
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
            // Input
            const input = this.newInput(options);
            this._input = input;
            this.addChild(input);
            // Marker
            const marker = this.newMarker(options);
            this._marker = marker;
            this.addChild(marker);
        }
        newInput(options) {
            return new DTableBodyCellInputTreeInput(this.toInputOptions(options));
        }
        toInputOptions(options) {
            return {
                weight: 1,
                text: options === null || options === void 0 ? void 0 : options.text,
                editing: options === null || options === void 0 ? void 0 : options.editing,
                when: options === null || options === void 0 ? void 0 : options.when,
                cursor: options === null || options === void 0 ? void 0 : options.cursor,
                on: {
                    change: (newValue, oldValue) => {
                        this.onInputChange(newValue, oldValue);
                    }
                }
            };
        }
        onInputChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                this.emit("change", newValue, oldValue, this);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        }
        newMarker(options) {
            return new DTableBodyCellInputTreeMarker({
                visible: false,
                on: {
                    active: () => {
                        this.onMarkerActive();
                    }
                }
            });
        }
        onMarkerActive() {
            if (this._marker.state.is(DTableState.HAS_CHILDREN)) {
                this.toggle();
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        toggle() {
            const row = this._row;
            if (row === undefined) {
                return;
            }
            const parent = this.parent;
            if (parent == null) {
                return;
            }
            const body = parent.parent;
            if (body == null) {
                return;
            }
            const data = body.data;
            if (data && data.toggle) {
                if (data.isExpanded(row)) {
                    if (data.collapse(row)) {
                        this.emit("collapse", this);
                        data.emit("collapse", row, this);
                    }
                }
                else {
                    if (data.expand(row)) {
                        this.emit("expand", this);
                        data.emit("expand", row, this);
                    }
                }
            }
        }
        onRowSelect(e, local) {
            if (local.x <= this.position.x + this._input.padding.getLeft()) {
                return true;
            }
            return false;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            const input = this._input;
            input.visible = true;
            input.text.setValue(String(value), forcibly || this._forcibly);
            this._forcibly = undefined;
            const marker = this._marker;
            if (supplimental != null) {
                const isOpened = !!(supplimental & 0x1);
                const hasChildren = !!(supplimental & 0x2);
                const level = supplimental >> 2;
                const markerState = marker.state;
                markerState.lock();
                markerState.set(DTableState.HAS_CHILDREN, hasChildren);
                markerState.set(DBaseState.DISABLED, !hasChildren);
                markerState.set(DTableState.OPENED, isOpened);
                markerState.unlock();
                const padding = this.theme.getLevelPadding(level);
                marker.width = padding;
                if (hasChildren) {
                    marker.show();
                }
                else {
                    marker.hide();
                }
                input.padding.adjLeft(padding);
            }
            else {
                marker.state.removeAll(DTableState.OPENED, DTableState.HAS_CHILDREN);
                marker.hide();
                input.padding.adjLeft(0);
            }
            DTableBodyCells.set(this._input, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._input.visible = false;
            this._marker.hide();
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellInputTree";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toLinkOptions = (cell, options) => {
        if (options) {
            return {
                url: toUrl(cell, options.url),
                target: options.target,
                checker: toChecker(cell, options.checker),
                menu: options.menu
            };
        }
        return undefined;
    };
    const toUrl = (cell, url) => {
        if (isString(url) || url == null) {
            return url;
        }
        else {
            return () => {
                const row = cell.row;
                if (row !== undefined) {
                    return url(row, cell.rowIndex, cell.columnIndex, cell);
                }
                return null;
            };
        }
    };
    const toChecker = (cell, checker) => {
        if (checker != null) {
            return () => {
                const row = cell.row;
                if (row !== undefined) {
                    return checker(row, cell.rowIndex, cell.columnIndex, cell);
                }
                return false;
            };
        }
        return undefined;
    };
    class DTableBodyCellLink extends DTableBodyCellButton {
        constructor(columnIndex, column, onChange, options) {
            var _a;
            super(columnIndex, column, onChange, DLinks.toStateOptions((_a = options === null || options === void 0 ? void 0 : options.link) === null || _a === void 0 ? void 0 : _a.target, options));
        }
        onClick(e) {
            if (!this.link.onClick(this, e)) {
                super.onClick(e);
            }
        }
        get link() {
            var _a;
            let result = this._link;
            if (result == null) {
                result = new DLink(toLinkOptions(this, (_a = this._options) === null || _a === void 0 ? void 0 : _a.link));
                this._link = result;
            }
            return result;
        }
        getType() {
            return "DTableBodyCellLink";
        }
        onActivate(e) {
            super.onActivate(e);
            this.link.open(e);
        }
        open(inNewWindow) {
            this.link.open(inNewWindow);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellSelectMenu extends DSelect {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValue, oldValue, item) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                super.onValueChange(newValue, oldValue, item);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
        }
        onKeyDownArrowDown(e) {
            return false;
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.setValue(value, forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellSelectMenu";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellSelectMultiple extends DSelectMultiple {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValues, oldValues, items) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValues);
                super.onValueChange(newValues, oldValues, items);
                this._onChange(newValues, oldValues, row, rowIndex, columnIndex, column, this);
            }
        }
        onKeyDownArrowDown(e) {
            return false;
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.setValues(value, forcibly || this._forcibly);
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellSelectMultiple";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellTextArea extends DTableBodyCellText {
        getType() {
            return "DTableBodyCellTextArea";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellTime extends DButtonTime {
        constructor(columnIndex, column, onChange, options) {
            super(options);
            this._rowIndex = -1;
            this._columnIndex = columnIndex;
            this._column = column;
            this._onChange = onChange;
        }
        onValueChange(newValue, oldValue) {
            const row = this._row;
            if (row !== undefined) {
                const rowIndex = this._rowIndex;
                const columnIndex = this._columnIndex;
                const column = this._column;
                column.setter(row, columnIndex, newValue);
                super.onValueChange(newValue, oldValue);
                this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
            }
            else {
                super.onValueChange(newValue, oldValue);
            }
        }
        get row() {
            return this._row;
        }
        get rowIndex() {
            return this._rowIndex;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get column() {
            return this._column;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            if (value instanceof Date) {
                this.text.setValue(value, forcibly || this._forcibly);
            }
            else if (isNumber(value)) {
                const text = this.text;
                const computed = text.computed;
                if (computed == null) {
                    this.text = new Date(value);
                }
                else if (computed.getTime() !== value) {
                    computed.setTime(value);
                    text.compute(true);
                }
            }
            this._forcibly = undefined;
            DTableBodyCells.set(this, row, columnIndex, this._column);
        }
        unset(forcibly) {
            this._row = undefined;
            this._rowIndex = -1;
            this._forcibly || (this._forcibly = forcibly);
        }
        getType() {
            return "DTableBodyCellTime";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyCellTree extends DTableBodyCellButton {
        constructor(columnIndex, column, onChange, options) {
            var _a;
            super(columnIndex, column, onChange, DLinks.toStateOptions((_a = options === null || options === void 0 ? void 0 : options.link) === null || _a === void 0 ? void 0 : _a.target, options));
        }
        newPadding(theme, options, callback) {
            return new DBasePaddingAdjustable(theme, options, callback);
        }
        onClick(e) {
            var _a;
            if (((_a = this.link) === null || _a === void 0 ? void 0 : _a.onClick(this, e)) !== true) {
                super.onClick(e);
            }
        }
        get link() {
            let result = this._link;
            if (result === undefined) {
                result = this.newLink();
                this._link = result;
            }
            return result;
        }
        newLink() {
            var _a;
            const options = (_a = this._options) === null || _a === void 0 ? void 0 : _a.link;
            if (options) {
                return new DLink(toLinkOptions(this, options));
            }
            return null;
        }
        onActivate(e) {
            var _a;
            super.onActivate(e);
            if (this.state.is(DTableState.HAS_CHILDREN)) {
                this.toggle();
            }
            else {
                (_a = this.link) === null || _a === void 0 ? void 0 : _a.open(e);
            }
        }
        toggle() {
            const row = this._row;
            if (row === undefined) {
                return;
            }
            const parent = this.parent;
            if (parent == null) {
                return;
            }
            const body = parent.parent;
            if (body == null) {
                return;
            }
            const data = body.data;
            if (data && data.toggle) {
                if (data.isExpanded(row)) {
                    if (data.collapse(row)) {
                        this.emit("collapse", this);
                        data.emit("collapse", row, this);
                    }
                }
                else {
                    if (data.expand(row)) {
                        this.emit("expand", this);
                        data.emit("expand", row, this);
                    }
                }
            }
        }
        onRowSelect(e, local) {
            if (local.x <= this.position.x + this.padding.getLeft()) {
                this.toggle();
                return true;
            }
            return false;
        }
        set(value, row, supplimental, rowIndex, columnIndex, forcibly) {
            this._row = row;
            this._rowIndex = rowIndex;
            this.text = value;
            DTableBodyCells.set(this, row, columnIndex, this._column, false);
            const link = this.link;
            const padding = this._padding;
            if (supplimental != null) {
                const isOpened = !!(supplimental & 0x1);
                const hasChildren = !!(supplimental & 0x2);
                const level = supplimental >> 2;
                const state = this.state;
                state.lock();
                state.set(DTableState.HAS_CHILDREN, hasChildren);
                state.set(DTableState.OPENED, isOpened);
                state.unlock();
                padding.adjLeft(this.theme.getLevelPadding(level));
                if (link) {
                    link.menu.enable = !hasChildren;
                }
            }
            else {
                this.state.removeAll(DTableState.OPENED, DTableState.HAS_CHILDREN);
                padding.adjLeft(0);
                if (link) {
                    link.menu.enable = false;
                }
            }
        }
        getType() {
            return "DTableBodyCellTree";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTableDataSelection} type.
     */
    const DTableDataSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableRow extends DLayoutHorizontal {
        constructor(columns, frozen, options) {
            super(options);
            this._reverse = true;
            this._frozen = frozen;
            this._columns = columns;
        }
        initCells() {
            const columns = this._columns;
            const frozen = this._frozen;
            const options = this._options;
            const iend = this.toIndexEnd(columns);
            for (let i = columns.length - 1; 0 <= i; --i) {
                const cell = this.newCell(i, columns[i], columns, options);
                const cellState = cell.state;
                cellState.lock(false);
                if (i === 0) {
                    cellState.add(DTableState.START);
                }
                if (i === iend) {
                    cellState.add(DTableState.END);
                }
                if (i < frozen) {
                    cellState.add(DTableState.FROZEN);
                }
                if (i === frozen - 1) {
                    cellState.add(DTableState.FROZEN_END);
                }
                cellState.unlock();
                this.addChild(cell);
            }
        }
        toIndexEnd(columns) {
            const imax = columns.length;
            for (let i = 0; i < imax; ++i) {
                const column = columns[i];
                if (column.weight !== undefined) {
                    return imax - 1;
                }
            }
            return imax;
        }
        onRefit() {
            super.onRefit();
            this.resetFrozenCellPosition();
        }
        updateFrozenCellPosition(x) {
            const columns = this._columns;
            const cells = this.children;
            const cellsLength = cells.length;
            const frozen = this._frozen;
            for (let i = 0; i < frozen; ++i) {
                const column = columns[i];
                const cell = cells[cellsLength - 1 - i];
                cell.position.x = -x + column.offset;
            }
        }
        resetFrozenCellPosition() {
            const columns = this._columns;
            const cells = this.children;
            const cellsLength = cells.length;
            const frozen = this._frozen;
            const x = this.getContentPositionX();
            for (let i = 0; i < frozen; ++i) {
                const column = columns[i];
                const cell = cells[cellsLength - 1 - i];
                column.offset = cell.position.x;
                cell.position.x = -x + column.offset;
            }
        }
        getClippingRect(target, result) {
            super.getClippingRect(target, result);
            const frozen = this._frozen;
            if (0 < frozen) {
                const cell = target;
                if (cell && cell.parent === this) {
                    const cells = this.children;
                    const cellIndex = cells.indexOf(cell);
                    if (0 <= cellIndex) {
                        const columnIndex = cells.length - 1 - cellIndex;
                        if (frozen <= columnIndex) {
                            const previous = cells[cellIndex + 1];
                            const shiftX = previous.position.x + previous.width;
                            result.x += shiftX;
                            result.width -= shiftX;
                        }
                    }
                }
            }
        }
        getType() {
            return "DTableRow";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableBodyRow extends DTableRow {
        constructor(onChange, isEven, columnIndexToCellOptions, columns, frozen, options) {
            super(columns, frozen, options);
            this._index = -1;
            this._onChange = onChange;
            this._onCellChangeBound = (newValue, oldValue, row, rowIndex, columnIndex, column) => {
                this.onCellChange(newValue, oldValue, row, rowIndex, columnIndex, column);
            };
            this._columnIndexToCellOptions = columnIndexToCellOptions;
            this.state.isAlternated = !isEven;
            this.initCells();
        }
        onCellChange(newValue, oldValue, row, rowIndex, columnIndex, column) {
            this.emit("change", newValue, oldValue, row, rowIndex, columnIndex, this);
            if (column.update === DTableColumnUpdate.ROW) {
                const value = this._value;
                const supplimental = this._supplimental;
                const index = this._index;
                if (value !== undefined && supplimental !== undefined) {
                    this.set(value, supplimental, index, true);
                }
            }
            this._onChange(newValue, oldValue, row, rowIndex, columnIndex, column, this);
        }
        newCell(columnIndex, column, columns, options) {
            const onChange = this._onCellChangeBound;
            const columnIndexToCellOptions = this._columnIndexToCellOptions;
            let cellOptions = columnIndexToCellOptions.get(columnIndex);
            if (cellOptions == null) {
                cellOptions = this.toCellOptions(columnIndex, column, options);
                columnIndexToCellOptions.set(columnIndex, cellOptions);
            }
            if (column.editing.enable !== false) {
                return this.newCellEditable(columnIndex, column, onChange, cellOptions);
            }
            else {
                const cell = this.newCellUnediable(columnIndex, column, onChange, cellOptions);
                if (column.type !== DTableColumnType.TREE) {
                    cell.state.isReadOnly = true;
                }
                return cell;
            }
        }
        newCellEditable(columnIndex, column, onChange, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellInputText(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT_AREA:
                    return new DTableBodyCellInputTextArea(columnIndex, column, onChange, options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellInputTree(columnIndex, column, onChange, options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellInputInteger(columnIndex, column, onChange, options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellInputReal(columnIndex, column, onChange, options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(columnIndex, column, onChange, options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(columnIndex, column, onChange, options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(columnIndex, column, onChange, options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(columnIndex, column, onChange, options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(columnIndex, column, onChange, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(columnIndex, column, onChange, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(columnIndex, column, onChange, options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(columnIndex, column, onChange, options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(columnIndex, column, onChange, options);
                default:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        }
        newCellUnediable(columnIndex, column, onChange, options) {
            switch (column.type) {
                case DTableColumnType.INDEX:
                    return new DTableBodyCellIndex(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.TEXT_AREA:
                    return new DTableBodyCellTextArea(columnIndex, column, onChange, options);
                case DTableColumnType.TREE:
                    return new DTableBodyCellTree(columnIndex, column, onChange, options);
                case DTableColumnType.INTEGER:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.REAL:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
                case DTableColumnType.CHECK:
                case DTableColumnType.CHECK_SINGLE:
                    return new DTableBodyCellCheck(columnIndex, column, onChange, options);
                case DTableColumnType.COLOR:
                    return new DTableBodyCellColor(columnIndex, column, onChange, options);
                case DTableColumnType.BUTTON:
                    return new DTableBodyCellButton(columnIndex, column, onChange, options);
                case DTableColumnType.LINK:
                    return new DTableBodyCellLink(columnIndex, column, onChange, options);
                case DTableColumnType.SELECT:
                    return this.newCellSelect(columnIndex, column, onChange, options);
                case DTableColumnType.ACTION:
                    return this.newCellAction(columnIndex, column, onChange, options);
                case DTableColumnType.DATE:
                    return new DTableBodyCellDate(columnIndex, column, onChange, options);
                case DTableColumnType.DATETIME:
                    return new DTableBodyCellDatetime(columnIndex, column, onChange, options);
                case DTableColumnType.TIME:
                    return new DTableBodyCellTime(columnIndex, column, onChange, options);
                default:
                    return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        }
        newCellSelect(columnIndex, column, onChange, options) {
            const selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellSelectMenu(columnIndex, column, onChange, options);
            }
            else if (selecting.multiple != null) {
                return new DTableBodyCellSelectMultiple(columnIndex, column, onChange, options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellSelectDialog(columnIndex, column, onChange, options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellSelectPromise(columnIndex, column, onChange, options);
            }
            else {
                return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        }
        newCellAction(columnIndex, column, onChange, options) {
            const selecting = column.selecting;
            if (selecting.menu != null) {
                return new DTableBodyCellActionMenu(columnIndex, column, onChange, options);
            }
            else if (selecting.dialog != null) {
                return new DTableBodyCellActionDialog(columnIndex, column, onChange, options);
            }
            else if (selecting.promise != null) {
                return new DTableBodyCellActionPromise(columnIndex, column, onChange, options);
            }
            else {
                return new DTableBodyCellText(columnIndex, column, onChange, options);
            }
        }
        toCellOptions(columnIndex, column, options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            var _p;
            const result = toMerged(column.body, options === null || options === void 0 ? void 0 : options.cell);
            // Weight
            result.weight = column.weight;
            // Width
            result.width = column.width;
            // State
            (_a = result.state) !== null && _a !== void 0 ? _a : (result.state = column.state.initial);
            // Text formatter
            const columnFormatter = column.formatter;
            if (columnFormatter != null) {
                const text = ((_b = result.text) !== null && _b !== void 0 ? _b : (result.text = {}));
                (_c = text.formatter) !== null && _c !== void 0 ? _c : (text.formatter = columnFormatter);
            }
            // Text align horizontal
            const columnAlign = column.align;
            if (columnAlign != null) {
                const text = ((_d = result.text) !== null && _d !== void 0 ? _d : (result.text = {}));
                const textAlign = ((_e = text.align) !== null && _e !== void 0 ? _e : (text.align = {}));
                (_f = textAlign.horizontal) !== null && _f !== void 0 ? _f : (textAlign.horizontal = columnAlign);
            }
            // Editing
            const columnEditing = column.editing;
            if (columnEditing.enable !== false) {
                const editing = ((_g = (_p = result).editing) !== null && _g !== void 0 ? _g : (_p.editing = {}));
                (_h = editing.formatter) !== null && _h !== void 0 ? _h : (editing.formatter = columnEditing.formatter);
                (_j = editing.unformatter) !== null && _j !== void 0 ? _j : (editing.unformatter = columnEditing.unformatter);
                (_k = editing.validator) !== null && _k !== void 0 ? _k : (editing.validator = columnEditing.validator);
            }
            // Link
            const columnLink = column.link;
            if (columnLink !== undefined) {
                result.link = columnLink;
            }
            // Selecting
            const columnSelecting = column.selecting;
            const columnSelectingMenu = (_l = columnSelecting.menu) !== null && _l !== void 0 ? _l : columnSelecting.multiple;
            if (columnSelectingMenu !== undefined) {
                result.menu = columnSelectingMenu;
            }
            const selectionType = (_o = (_m = options === null || options === void 0 ? void 0 : options.selection) === null || _m === void 0 ? void 0 : _m.type) !== null && _o !== void 0 ? _o : DTableDataSelectionType.NONE;
            if (selectionType !== DTableDataSelectionType.NONE) {
                result.when = "DOUBLE_CLICKED";
                result.cursor = (state) => {
                    if (state.in(DTableState.SELECTABLE)) {
                        return "pointer";
                    }
                    return undefined;
                };
            }
            return result;
        }
        getType() {
            return "DTableBodyRow";
        }
        /**
         * Returns a row data if exists.
         * Returns undefined if a row data does not exit.
         *
         * @returns a row data or undefined.
         */
        get value() {
            return this._value;
        }
        /**
         * Returns a row index if a row data exists.
         * Returns -1 if a row data does not exit.
         *
         * @returns a row index or -1.
         */
        get index() {
            return this._index;
        }
        isCell(target) {
            return target != null && "set" in target;
        }
        set(value, supplimental, rowIndex, forcibly) {
            if (forcibly ||
                this._value !== value ||
                this._supplimental !== supplimental ||
                this._index !== rowIndex) {
                this._value = value;
                this._supplimental = supplimental;
                this._index = rowIndex;
                const cells = this.children;
                const cellsLength = cells.length;
                const columns = this._columns;
                const columnsLength = columns.length;
                for (let i = 0; i < cellsLength; ++i) {
                    const cell = cells[i];
                    const columnIndex = columnsLength - 1 - i;
                    const column = columns[columnIndex];
                    if (this.isCell(cell)) {
                        cell.set(column.getter(value, columnIndex), value, supplimental, rowIndex, columnIndex, forcibly);
                    }
                }
                this.onSet(value, rowIndex);
            }
        }
        onSet(value, rowIndex) {
            this.emit("set", value, rowIndex, this);
        }
        unset(forcibly) {
            if (forcibly || this._value !== undefined) {
                this._value = undefined;
                this._index = -1;
                const cells = this.children;
                const cellsLength = cells.length;
                for (let i = 0; i < cellsLength; ++i) {
                    const cell = cells[i];
                    if (this.isCell(cell)) {
                        cell.unset(forcibly);
                    }
                }
                this.onUnset();
            }
        }
        onUnset() {
            this.emit("unset", this);
        }
        getContentPositionX() {
            const parent = this.parent;
            if (parent) {
                const content = parent.parent;
                if (content) {
                    return content.position.x;
                }
            }
            return 0;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableDataListFilter extends pixi_js.utils.EventEmitter {
        constructor(parent) {
            super();
            this._id = 0;
            this._idUpdated = -1;
            this._isApplied = false;
            this._sorterId = -1;
            this._parent = parent;
            this._filter = null;
            this._filtered = null;
        }
        get id() {
            return this._id;
        }
        apply() {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        }
        unapply() {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        }
        isApplied() {
            return this._isApplied;
        }
        newFiltered() {
            const filter = this._filter;
            if (filter != null) {
                const filtered = [];
                const parent = this._parent;
                const sorter = parent.sorter;
                const rows = parent.rows;
                if (isFunction(filter)) {
                    const indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (let i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            const indexSorted = indicesSorted[i];
                            if (filter(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (let i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                else {
                    const indicesSorted = sorter.indices;
                    if (indicesSorted) {
                        for (let i = 0, imax = indicesSorted.length; i < imax; ++i) {
                            const indexSorted = indicesSorted[i];
                            if (filter.test(rows[indexSorted], indexSorted)) {
                                filtered.push(i);
                            }
                        }
                    }
                    else {
                        for (let i = 0, imax = rows.length; i < imax; ++i) {
                            if (filter.test(rows[i], i)) {
                                filtered.push(i);
                            }
                        }
                    }
                }
                return filtered;
            }
            else {
                return null;
            }
        }
        get() {
            return this._filter;
        }
        set(filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        }
        toDirty() {
            this._id += 1;
        }
        update() {
            if (this._id !== this._idUpdated || this._parent.sorter.id !== this._sorterId) {
                this._idUpdated = this._id;
                this._sorterId = this._parent.sorter.id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        }
        get indices() {
            this.update();
            return this._filtered;
        }
        map(sortedIndex) {
            let result = sortedIndex;
            const indicesFiltered = this.indices;
            if (indicesFiltered) {
                const index = indicesFiltered.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        }
        unmap(index) {
            let result = index;
            const indicesFiltered = this.indices;
            if (indicesFiltered) {
                result = indicesFiltered[result];
            }
            return result;
        }
    }

    class DTableDataListMapped {
        constructor(parent) {
            this._parent = parent;
        }
        get rows() {
            const result = [];
            this.each((row) => {
                result.push(row);
            });
            return result;
        }
        map(unmappedIndex) {
            const parent = this._parent;
            const sortedIndex = parent.sorter.map(unmappedIndex);
            if (sortedIndex != null) {
                return parent.filter.map(sortedIndex);
            }
            return null;
        }
        unmap(index) {
            const parent = this._parent;
            return parent.sorter.unmap(parent.filter.unmap(index));
        }
        size() {
            const parent = this._parent;
            const indicesFiltered = parent.filter.indices;
            return indicesFiltered != null ? indicesFiltered.length : parent.size();
        }
        get(index) {
            const parent = this._parent;
            return parent.get(this.unmap(index));
        }
        each(iteratee, ifrom, ito) {
            const parent = this._parent;
            const rows = parent.rows;
            const supplimentals = parent.supplimentals;
            const indicesFiltered = parent.filter.indices;
            const indicesSorted = parent.sorter.indices;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            if (indicesFiltered) {
                const size = indicesFiltered.length;
                ito = ito != null ? Math.min(size, ito) : size;
                if (indicesSorted) {
                    for (let i = ifrom; i < ito; ++i) {
                        const unmappedIndex = indicesSorted[indicesFiltered[i]];
                        const row = rows[unmappedIndex];
                        const supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (let i = ifrom; i < ito; ++i) {
                        const unmappedIndex = indicesFiltered[i];
                        const row = rows[unmappedIndex];
                        const supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
            }
            else {
                const size = rows.length;
                ito = ito != null ? Math.min(size, ito) : size;
                if (indicesSorted) {
                    for (let i = ifrom; i < ito; ++i) {
                        const unmappedIndex = indicesSorted[i];
                        const row = rows[unmappedIndex];
                        const supplimental = supplimentals ? supplimentals[unmappedIndex] : null;
                        if (iteratee(row, supplimental, i, unmappedIndex) === false) {
                            break;
                        }
                    }
                }
                else {
                    for (let i = ifrom; i < ito; ++i) {
                        const row = rows[i];
                        const supplimental = supplimentals ? supplimentals[i] : null;
                        if (iteratee(row, supplimental, i, i) === false) {
                            break;
                        }
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const COMPARATOR$1 = (a, b) => {
        return a[0] - b[0];
    };
    class DTableDataListSelection extends pixi_js.utils.EventEmitter {
        constructor(parent, options) {
            var _a;
            super();
            this._parent = parent;
            this._type = toEnum((_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : DTableDataSelectionType.NONE, DTableDataSelectionType);
            this._indices = new Set();
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        get parent() {
            return this._parent;
        }
        get type() {
            return this._type;
        }
        onChange() {
            this._parent.update();
            this.emit("change", this);
        }
        toggle(rowIndex) {
            const indices = this._indices;
            if (indices.has(rowIndex)) {
                indices.delete(rowIndex);
            }
            else {
                indices.add(rowIndex);
            }
            this.onChange();
        }
        add(rowIndex) {
            const indices = this._indices;
            const oldSize = indices.size;
            indices.add(rowIndex);
            const newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        }
        get first() {
            const indices = this._indices;
            if (0 < indices.size) {
                let result = -1;
                indices.forEach((index) => {
                    if (result < 0) {
                        result = index;
                    }
                });
                return result;
            }
            return null;
        }
        get last() {
            const indices = this._indices;
            if (0 < indices.size) {
                let result = 0;
                indices.forEach((index) => {
                    result = index;
                });
                return result;
            }
            return null;
        }
        addTo(rowIndex) {
            const lastRowIndex = this.last;
            if (lastRowIndex != null) {
                this.addRange(lastRowIndex, false, rowIndex, true);
            }
        }
        addRange(from, includeFrom, to, includeTo) {
            const indices = this._indices;
            const oldSize = indices.size;
            if (from < to) {
                const ifrom = from + (includeFrom ? 0 : 1);
                const ito = to + (includeTo ? 1 : 0);
                for (let i = ifrom; i < ito; ++i) {
                    indices.add(i);
                }
            }
            else {
                const ifrom = to + (includeTo ? 0 : 1);
                const ito = from + (includeFrom ? 1 : 0);
                for (let i = ifrom; i < ito; ++i) {
                    indices.add(i);
                }
            }
            const newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        }
        addAll(rowIndices) {
            const indices = this._indices;
            const oldSize = indices.size;
            for (let i = 0, imax = rowIndices.length; i < imax; ++i) {
                indices.add(rowIndices[i]);
            }
            const newSize = indices.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        }
        contains(rowIndex) {
            return this._indices.has(rowIndex);
        }
        remove(rowIndex) {
            if (this._indices.delete(rowIndex)) {
                this.onChange();
            }
        }
        clear() {
            const indices = this._indices;
            if (0 < indices.size) {
                indices.clear();
                this.onChange();
            }
        }
        clearAndAdd(rowIndex) {
            const indices = this._indices;
            if (!indices.has(rowIndex) || indices.size !== 1) {
                indices.clear();
                indices.add(rowIndex);
                this.onChange();
            }
        }
        clearAndAddAll(rowIndices) {
            const indices = this._indices;
            if (0 < indices.size || 0 < rowIndices.length) {
                indices.clear();
                for (let i = 0, imax = rowIndices.length; i < imax; ++i) {
                    indices.add(rowIndices[i]);
                }
                this.onChange();
            }
        }
        shift(rowIndex, amount) {
            const shifted = [];
            const indices = this._indices;
            indices.forEach((index) => {
                if (rowIndex <= index) {
                    shifted.push(index);
                }
            });
            const shiftedLength = shifted.length;
            if (0 < shiftedLength) {
                for (let i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.delete(shifted[i]);
                }
                for (let i = 0, imax = shifted.length; i < imax; ++i) {
                    indices.add(shifted[i] + amount);
                }
                this.onChange();
            }
        }
        size() {
            return this._indices.size;
        }
        isEmpty() {
            return this._indices.size === 0;
        }
        each(iteratee) {
            let isCanceled = false;
            this._indices.forEach((index) => {
                if (!isCanceled) {
                    if (iteratee(index) === false) {
                        isCanceled = true;
                    }
                }
            });
        }
        /**
         * Returns a copy of an index array of selected rows.
         * The order of indices is an insertion order.
         */
        get indices() {
            const result = [];
            this._indices.forEach((index) => {
                result.push(index);
            });
            return result;
        }
        /**
         * Returns a copy of an array of selected row value.
         * The order is an insertion order.
         */
        get rows() {
            const result = [];
            const parent = this._parent;
            this._indices.forEach((index) => {
                result.push(parent.get(index));
            });
            return result;
        }
        /**
         * Returns an array of the (index, row value) pairs of selected rows.
         * The order of pairs is an insertion order.
         */
        toArray() {
            const result = [];
            const parent = this._parent;
            this._indices.forEach((index) => {
                result.push([index, parent.get(index)]);
            });
            return result;
        }
        /**
         * Returns an sorted array of the (index, row value) pairs of selected rows.
         */
        toSortedArray() {
            return this.toArray().sort(COMPARATOR$1);
        }
        toObject() {
            const result = {};
            const parent = this._parent;
            this._indices.forEach((index) => {
                result[index] = parent.get(index);
            });
            return result;
        }
        toMap() {
            const result = new Map();
            const parent = this._parent;
            this._indices.forEach((index) => {
                result.set(index, parent.get(index));
            });
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * A sort order.
     */
    const DTableDataOrder = {
        ASCENDING: 0,
        DESCENDING: 1
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableDataListSorter extends pixi_js.utils.EventEmitter {
        constructor(parent) {
            super();
            this._id = 0;
            this._idUpdated = -1;
            this._isApplied = false;
            this._parent = parent;
            this._comparator = null;
            this._sorted = null;
            this._order = DTableDataOrder.ASCENDING;
        }
        get id() {
            return this._id;
        }
        get order() {
            return this._order;
        }
        set order(order) {
            this._order = order;
        }
        apply() {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        }
        unapply() {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        }
        isApplied() {
            return this._isApplied;
        }
        newSorted() {
            const comparator = this._comparator;
            if (comparator != null) {
                const parent = this._parent;
                const sorted = [];
                const rows = parent.rows;
                for (let i = 0, imax = rows.length; i < imax; ++i) {
                    sorted.push(i);
                }
                sorted.sort(this.toComparator(rows, comparator));
                return sorted;
            }
            else {
                return null;
            }
        }
        toComparator(rows, comparator) {
            const order = this._order;
            if (isFunction(comparator)) {
                if (order === DTableDataOrder.ASCENDING) {
                    return (indexA, indexB) => {
                        return comparator(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return (indexA, indexB) => {
                        return comparator(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
            else {
                if (order === DTableDataOrder.ASCENDING) {
                    return (indexA, indexB) => {
                        return comparator.compare(rows[indexA], rows[indexB], indexA, indexB);
                    };
                }
                else {
                    return (indexA, indexB) => {
                        return comparator.compare(rows[indexB], rows[indexA], indexB, indexA);
                    };
                }
            }
        }
        get() {
            return this._comparator;
        }
        set(comparator) {
            if (this._comparator !== comparator) {
                this._comparator = comparator;
            }
        }
        toDirty() {
            this._id += 1;
        }
        update() {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._sorted = this.newSorted();
                    this.emit("change", this);
                }
                else if (this._sorted != null) {
                    this._sorted = null;
                    this.emit("change", this);
                }
            }
        }
        get indices() {
            this.update();
            return this._sorted;
        }
        map(unmappedIndex) {
            let result = unmappedIndex;
            const indicesSorted = this.indices;
            if (indicesSorted) {
                const index = indicesSorted.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        }
        unmap(index) {
            let result = index;
            const indicesSorted = this.indices;
            if (indicesSorted) {
                result = indicesSorted[result];
            }
            return result;
        }
    }

    class DTableDataList extends pixi_js.utils.EventEmitter {
        constructor(options) {
            super();
            this._parent = null;
            this._rows = this.toRows(options === null || options === void 0 ? void 0 : options.rows);
            this._mapped = new DTableDataListMapped(this);
            this._selection = this.toSelection(options === null || options === void 0 ? void 0 : options.selection);
            this._filter = new DTableDataListFilter(this);
            this._sorter = new DTableDataListSorter(this);
            if (options) {
                // Filter
                const filter = options.filter;
                if (filter) {
                    this._filter.set(filter);
                }
                // Comparator
                const comparator = options.comparator;
                if (comparator) {
                    this._sorter.set(comparator);
                }
                // Events
                const on = options.on;
                if (on) {
                    for (const name in on) {
                        const handler = on[name];
                        if (handler) {
                            this.on(name, handler);
                        }
                    }
                }
            }
        }
        toSelection(options) {
            if (options instanceof pixi_js.utils.EventEmitter) {
                return options;
            }
            else if (isFunction(options)) {
                return options(this);
            }
            return this.newSelection(options);
        }
        newSelection(options) {
            return new DTableDataListSelection(this, options);
        }
        bind(parent) {
            this._parent = parent;
        }
        toRows(row) {
            const result = [];
            if (row != null) {
                for (let i = 0, imax = row.length; i < imax; ++i) {
                    result.push(row[i]);
                }
            }
            return result;
        }
        get rows() {
            return this._rows;
        }
        update(forcibly) {
            const parent = this._parent;
            if (parent) {
                parent.update(forcibly);
            }
        }
        lock() {
            const parent = this._parent;
            if (parent) {
                parent.lock();
            }
        }
        unlock(callIfNeeded) {
            const parent = this._parent;
            if (parent) {
                parent.unlock(callIfNeeded);
            }
        }
        size() {
            return this._rows.length;
        }
        clear() {
            const rows = this._rows;
            if (0 < rows.length) {
                rows.length = 0;
                this.lock();
                this._selection.clear();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.update();
                this.unlock(true);
            }
        }
        clearAndAdd(row) {
            const rows = this._rows;
            rows.length = 0;
            rows.push(row);
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.update();
            this.unlock(true);
        }
        clearAndAddAll(newRows) {
            const rows = this._rows;
            rows.length = 0;
            for (let i = 0, imax = newRows.length; i < imax; ++i) {
                rows.push(newRows[i]);
            }
            this.lock();
            this._selection.clear();
            this._sorter.toDirty();
            this._filter.toDirty();
            this.update();
            this.unlock(true);
        }
        add(row, index) {
            const rows = this._rows;
            const selection = this._selection;
            const sorter = this._sorter;
            const filter = this._filter;
            if (index == null) {
                rows.push(row);
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.update();
                this.unlock(true);
            }
            else if (0 <= index && index < rows.length) {
                rows.splice(index, 0, row);
                this.lock();
                selection.shift(index, 1);
                sorter.toDirty();
                filter.toDirty();
                this.update();
                this.unlock(true);
            }
        }
        addAll(newRows, index) {
            const rows = this._rows;
            const rowsLength = rows.length;
            const selection = this._selection;
            const sorter = this._sorter;
            const filter = this._filter;
            if (index == null) {
                const newRowsLength = newRows.length;
                for (let i = 0, imax = newRowsLength; i < imax; ++i) {
                    rows.push(newRows[i]);
                }
                this.lock();
                sorter.toDirty();
                filter.toDirty();
                this.update();
                this.unlock(true);
            }
            else if (0 <= index && index < rowsLength) {
                const newRowsLength = newRows.length;
                for (let i = 0; i < newRowsLength; ++i) {
                    rows.splice(index + i, 0, newRows[i]);
                }
                this.lock();
                selection.shift(index, newRowsLength);
                sorter.toDirty();
                filter.toDirty();
                this.update();
                this.unlock(true);
            }
        }
        get(index) {
            const rows = this._rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        }
        set(index, row) {
            const rows = this._rows;
            if (0 <= index && index < rows.length) {
                const result = rows[index];
                rows[index] = row;
                this.lock();
                this._sorter.toDirty();
                this._filter.toDirty();
                this.update();
                this.unlock(true);
                return result;
            }
            return null;
        }
        remove(index) {
            const rows = this._rows;
            if (0 <= index && index < rows.length) {
                const result = rows.splice(index, 1)[0];
                this.lock();
                this._selection.remove(index);
                this._sorter.toDirty();
                this._filter.toDirty();
                this.update();
                this.unlock(true);
                return result;
            }
            return null;
        }
        each(iteratee, ifrom, ito) {
            const rows = this._rows;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            ito = ito != null ? Math.min(rows.length, ito) : rows.length;
            for (let i = ifrom; i < ito; ++i) {
                const row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        }
        get selection() {
            return this._selection;
        }
        get filter() {
            return this._filter;
        }
        get sorter() {
            return this._sorter;
        }
        get mapped() {
            return this._mapped;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toRowOptions = (theme, options, selectionType) => {
        let result = options.row;
        if (result != null) {
            if (result.height == null) {
                result.height = theme.getRowHeight();
            }
            if (result.selection === undefined) {
                result.selection = {
                    type: selectionType
                };
            }
            else if (result.selection.type === undefined) {
                result.selection.type = selectionType;
            }
        }
        else {
            result = {
                height: theme.getRowHeight(),
                selection: {
                    type: selectionType
                }
            };
        }
        return result;
    };
    class DTableBody extends DBase {
        constructor(columns, frozen, offset, options) {
            super(options);
            this.transform.position.y = offset;
            const data = this.toData(options.data);
            this._data = data;
            data.bind(this);
            const theme = this.theme;
            this._columns = columns;
            this._frozen = frozen;
            const rowOptions = toRowOptions(theme, options, data.selection.type);
            this._rowOptions = rowOptions;
            this._rowHeight = rowOptions.height != null ? rowOptions.height : theme.getRowHeight();
            this._rowIndexMappedStart = 0;
            this._rowIndexMappedEnd = 0;
            this._updateRowsCount = 0;
            this._isUpdateRowsCalled = false;
            this._isUpdateRowsCalledForcibly = false;
            this._workRows = [];
            this._onRowChangeBound = (newValue, oldValue, row, rowIndex, columnIndex, column) => {
                this.onRowChange(newValue, oldValue, row, rowIndex, columnIndex, column);
            };
            this._columnIndexToCellOptions = new Map();
            this._data.emit("init", this._data);
        }
        onRowChange(newValue, oldValue, row, rowIndex, columnIndex, column) {
            const data = this._data;
            data.emit("change", newValue, oldValue, row, rowIndex, columnIndex, data);
            if (column.update === DTableColumnUpdate.ALL) {
                this.update(true);
            }
        }
        toData(options) {
            if (this.isData(options)) {
                return options;
            }
            return new DTableDataList(options);
        }
        isData(target) {
            return target != null && "mapped" in target;
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
            this.update();
        }
        get selection() {
            return this._data.selection;
        }
        lock() {
            this._updateRowsCount += 1;
            if (this._updateRowsCount === 1) {
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        }
        unlock(callIfNeeded) {
            this._updateRowsCount -= 1;
            if (this._updateRowsCount === 0) {
                if (callIfNeeded && this._isUpdateRowsCalled) {
                    this.update(this._isUpdateRowsCalledForcibly);
                }
                this._isUpdateRowsCalled = false;
                this._isUpdateRowsCalledForcibly = false;
            }
        }
        /**
         * Updates rows. If the `forcibly` is true, some dirty checkings for
         * avoiding unnecessary state changes are skipped.
         *
         * @param forcibly true to update forcibly
         */
        update(forcibly) {
            if (0 < this._updateRowsCount) {
                this._isUpdateRowsCalled = true;
                if (forcibly) {
                    this._isUpdateRowsCalledForcibly = true;
                }
                return;
            }
            const content = this.parent;
            if (content == null) {
                return;
            }
            const contentParent = content.parent;
            if (contentParent == null) {
                return;
            }
            const rows = this.children;
            const height = contentParent.height;
            const rowHeight = this._rowHeight;
            const data = this._data;
            const dataMappedSize = data.mapped.size();
            const oldRowIndexMappedStart = this._rowIndexMappedStart;
            let oldRowIndexMappedEnd = this._rowIndexMappedEnd;
            let oldRowCount = oldRowIndexMappedEnd - oldRowIndexMappedStart;
            const y = this.transform.position.y;
            const newHeight = y + dataMappedSize * rowHeight;
            const newContentHeight = Math.max(height, newHeight);
            const newContentY = Math.max(height - newContentHeight, content.position.y);
            const newRowIndexMappedLowerBound = -newContentY / rowHeight;
            const newRowIndexMappedUpperBound = (height - (newContentY + y)) / rowHeight;
            let newRowIndexMappedStart = Math.floor(newRowIndexMappedLowerBound);
            newRowIndexMappedStart -= newRowIndexMappedStart % 2 === 0 ? 2 : 1;
            let newRowIndexMappedEnd = Math.floor(newRowIndexMappedUpperBound);
            newRowIndexMappedEnd += (newRowIndexMappedEnd - newRowIndexMappedStart) % 2 === 1 ? 3 : 2;
            let newRowCount = newRowIndexMappedEnd - newRowIndexMappedStart;
            if (newRowCount < oldRowCount) {
                newRowCount = oldRowCount;
                newRowIndexMappedEnd = newRowIndexMappedStart + newRowCount;
            }
            if (oldRowCount < newRowCount) {
                for (let i = oldRowCount; i < newRowCount; ++i) {
                    const oldRowIndexMapped = oldRowIndexMappedStart + i;
                    const newRow = this.newRow(oldRowIndexMapped % 2 === 0);
                    this.addChild(newRow);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            else if (newRowCount < oldRowCount) {
                for (let i = oldRowCount - 1; newRowCount <= i; --i) {
                    this.removeChild(rows[i]);
                }
                oldRowCount = newRowCount;
                oldRowIndexMappedEnd = oldRowIndexMappedStart + oldRowCount;
            }
            this._rowIndexMappedStart = newRowIndexMappedStart;
            this._rowIndexMappedEnd = newRowIndexMappedEnd;
            const rowIndexMappedStartDelta = newRowIndexMappedStart - oldRowIndexMappedStart;
            const rowIndexMappedStartDeltaAbs = Math.abs(rowIndexMappedStartDelta);
            const rowsLength = rows.length;
            if (0 < rowIndexMappedStartDeltaAbs && rowIndexMappedStartDeltaAbs < rowsLength) {
                const work = this._workRows;
                if (0 < rowIndexMappedStartDelta) {
                    for (let i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[i]));
                    }
                    for (let i = rowIndexMappedStartDeltaAbs; i < rowsLength; ++i) {
                        rows[i - rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (let i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[rowsLength - rowIndexMappedStartDeltaAbs + i] = work[i];
                    }
                }
                else {
                    for (let i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        work.push(this.resetRow(rows[rowsLength - rowIndexMappedStartDeltaAbs + i]));
                    }
                    for (let i = rowsLength - rowIndexMappedStartDeltaAbs - 1; 0 <= i; --i) {
                        rows[i + rowIndexMappedStartDeltaAbs] = rows[i];
                    }
                    for (let i = 0; i < rowIndexMappedStartDeltaAbs; ++i) {
                        rows[i] = work[i];
                    }
                }
                work.length = 0;
            }
            const selection = data.selection;
            const isRowSelectable = selection.type !== DTableDataSelectionType.NONE;
            data.mapped.each((datum, supplimental, index, unmappedIndex) => {
                const row = rows[index - newRowIndexMappedStart];
                // Position
                row.position.y = index * rowHeight;
                // State
                const rowState = row.state;
                rowState.lock();
                rowState.add(DTableState.HAS_DATA);
                rowState.set(DTableState.SELECTABLE, isRowSelectable);
                rowState.set(DBaseState.ACTIVE, selection.contains(unmappedIndex));
                rowState.remove(DBaseState.DISABLED);
                rowState.unlock();
                // Data
                row.set(datum, supplimental, unmappedIndex, forcibly);
            }, newRowIndexMappedStart, newRowIndexMappedStart + rowsLength);
            for (let i = 0; newRowIndexMappedStart + i < 0 && i < rowsLength; ++i) {
                const row = rows[i];
                // Position
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                // State
                const rowState = row.state;
                rowState.lock();
                rowState.add(DBaseState.DISABLED);
                rowState.removeAll(DTableState.HAS_DATA, DTableState.SELECTABLE, DBaseState.ACTIVE);
                rowState.unlock();
                // Data
                row.unset(forcibly);
            }
            for (let i = rowsLength - 1; dataMappedSize <= newRowIndexMappedStart + i && 0 <= i; --i) {
                const row = rows[i];
                // Position
                row.position.y = (newRowIndexMappedStart + i) * rowHeight;
                // State
                const rowState = row.state;
                rowState.lock();
                rowState.add(DBaseState.DISABLED);
                rowState.removeAll(DTableState.HAS_DATA, DTableState.SELECTABLE, DBaseState.ACTIVE);
                rowState.unlock();
                // Data
                row.unset(forcibly);
            }
            this.lock();
            content.position.y = newContentY;
            content.height = newContentHeight;
            this.height = newHeight;
            this.unlock(false);
            this.emit("update", newRowIndexMappedLowerBound, newRowIndexMappedUpperBound, this);
        }
        resetRow(row) {
            row.blur(true);
            const cells = row.children;
            for (let i = 0, imax = cells.length; i < imax; ++i) {
                const cell = cells[i];
                if (cell instanceof DBase) {
                    cell.state.isPressed = false;
                }
            }
            return row;
        }
        newRow(isEven) {
            return new DTableBodyRow(this._onRowChangeBound, isEven, this._columnIndexToCellOptions, this._columns, this._frozen, this._rowOptions);
        }
        onParentMove(newX, newY, oldX, oldY) {
            super.onParentMove(newX, newY, oldX, oldY);
            this.updateFrozenCellPosition(newX);
        }
        updateFrozenCellPosition(x) {
            const frozen = this._frozen;
            if (frozen != null && 0 < frozen) {
                const rows = this.children;
                for (let i = 0, imax = rows.length; i < imax; ++i) {
                    rows[i].updateFrozenCellPosition(x);
                }
            }
        }
        getClippingRect(target, result) {
            super.getClippingRect(target, result);
            const parent = this.parent;
            if (parent) {
                const dy = -parent.transform.position.y;
                result.y += dy;
                result.height -= dy;
            }
        }
        /**
         * Scroll to the given row or row index.
         *
         * @param target a row or an row index to which the body scrolls to.
         * @returns true if succeeded
         */
        scrollTo(target) {
            const parent = this.parent;
            if (parent == null) {
                return false;
            }
            const parentParent = parent.parent;
            if (parentParent == null) {
                return false;
            }
            let rowIndexMapped = -1;
            if (isNumber(target)) {
                if (0 <= target && target < this.data.mapped.size()) {
                    rowIndexMapped = target;
                }
            }
            else {
                this.data.mapped.each((row, _, index) => {
                    if (row === target) {
                        rowIndexMapped = index;
                        return false;
                    }
                    return true;
                });
            }
            if (rowIndexMapped < 0) {
                return false;
            }
            parent.position.y = Math.max(Math.min(0, parentParent.height - parent.height), -rowIndexMapped * this._rowHeight);
            DApplications.update(this);
            return true;
        }
        /**
         * Returns a mapped row index at the given local Y position or -1.
         *
         * @param localY a local Y position
         * @returns a mapped row index at the given local Y position or -1.
         */
        toRowIndexMapped(localY) {
            if (0 <= this.parent.position.y + localY) {
                const result = Math.floor(localY / this._rowHeight);
                if (0 <= result && result < this._data.mapped.size()) {
                    return result;
                }
            }
            return -1;
        }
        /**
         * Returns a row at the given mapped row index or null if not exits.
         *
         * @param rowIndexMapped a mapped row index
         * @returns a row at the given mapped row index or null if not exists.
         */
        toRow(rowIndexMapped) {
            const index = rowIndexMapped - this._rowIndexMappedStart;
            const rows = this.children;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        }
        /**
         * Returns a cell at the given local X position or null if not exits.
         * This method assumes the given local X position is on the given row.
         *
         * @param row a row
         * @param localX a local X position
         * @returns a cell at the given local X position or null if not exits
         */
        toCell(row, localX) {
            const cells = row.children;
            const cellsLength = cells.length;
            const columns = this._columns;
            const columnsLength = columns.length;
            for (let i = 0, imax = Math.min(cellsLength, columnsLength); i < imax; ++i) {
                const cell = cells[cellsLength - i - 1];
                const x = localX - cell.position.x;
                if (0 <= x && x <= cell.width) {
                    return cell;
                }
            }
            return null;
        }
        onRowClick(e) {
            if (this.state.isActionable) {
                const local = DTableBody.WORK_ON_CLICK;
                local.copyFrom(e.data.global);
                this.toLocal(local, undefined, local, false);
                const rowIndexMapped = this.toRowIndexMapped(local.y);
                if (0 <= rowIndexMapped) {
                    // Delegate to the cell at first
                    const row = this.toRow(rowIndexMapped);
                    if (row) {
                        const cell = this.toCell(row, local.x);
                        if (cell && cell.onRowSelect && cell.onRowSelect(e, local)) {
                            return;
                        }
                    }
                    // Fallback to the default
                    this.onRowSelect(e, rowIndexMapped);
                }
            }
        }
        onRowSelect(e, rowIndexMapped) {
            const data = this._data;
            const selection = data.selection;
            const isSingle = selection.type === DTableDataSelectionType.SINGLE;
            const isNotSingle = !isSingle;
            const rowIndex = data.mapped.unmap(rowIndexMapped);
            const originalEvent = e.data.originalEvent;
            const ctrlKey = originalEvent.ctrlKey;
            const shiftKey = originalEvent.shiftKey;
            if (isSingle || selection.isEmpty() || !(isNotSingle && (ctrlKey || shiftKey))) {
                selection.clearAndAdd(rowIndex);
            }
            else if (ctrlKey) {
                selection.toggle(rowIndex);
            }
            else if (shiftKey) {
                const lastRowIndex = selection.last;
                if (lastRowIndex != null) {
                    const sorter = data.sorter;
                    const filter = data.filter;
                    const rowIndexSorted = sorter.map(rowIndex);
                    const lastRowIndexSorted = sorter.map(lastRowIndex);
                    if (rowIndexSorted != null && lastRowIndexSorted != null) {
                        let istart = lastRowIndexSorted + 1;
                        let iend = rowIndexSorted + 1;
                        if (rowIndexSorted < lastRowIndexSorted) {
                            istart = rowIndexSorted;
                            iend = lastRowIndexSorted;
                        }
                        if (istart < iend) {
                            const rowIndices = [];
                            const indicesFiltered = filter.indices;
                            const indicesSorted = sorter.indices;
                            if (indicesFiltered) {
                                if (indicesSorted) {
                                    for (let i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                        const indexFiltered = indicesFiltered[i];
                                        if (istart <= indexFiltered && indexFiltered < iend) {
                                            rowIndices.push(indicesSorted[indexFiltered]);
                                        }
                                    }
                                }
                                else {
                                    for (let i = 0, imax = indicesFiltered.length; i < imax; ++i) {
                                        const indexFiltered = indicesFiltered[i];
                                        if (istart <= indexFiltered && indexFiltered < iend) {
                                            rowIndices.push(indexFiltered);
                                        }
                                    }
                                }
                            }
                            else {
                                if (indicesSorted) {
                                    for (let i = istart; i < iend; ++i) {
                                        rowIndices.push(indicesSorted[i]);
                                    }
                                }
                                else {
                                    for (let i = istart; i < iend; ++i) {
                                        rowIndices.push(i);
                                    }
                                }
                            }
                            selection.addAll(rowIndices);
                        }
                    }
                }
            }
        }
        onDblClick(e, interactionManager) {
            return super.onDblClick(e, interactionManager);
        }
        getType() {
            return "DTableBody";
        }
        get data() {
            return this._data;
        }
    }
    DTableBody.WORK_ON_CLICK = new pixi_js.Point();

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const DTableCellEdgeHovered = {
        NONE: 0,
        LEFT: 1,
        RIGHT: 2,
        BOTH: 3
    };
    class DTableCellEdge {
        constructor(row, cell, columnIndex, size) {
            this._row = row;
            this._cell = cell;
            this._columnIndex = columnIndex;
            this._size = size;
            this._dragged = false;
            this._minWidth = 8;
        }
        findResizableCell(columnIndex, direction, weight) {
            const children = this._row.children;
            const childrenLength = children.length;
            if (direction) {
                for (let i = columnIndex; i < childrenLength; ++i) {
                    const child = children[childrenLength - i - 1];
                    const childColumn = child.column;
                    if (childColumn.resizable) {
                        if (weight == null) {
                            return child;
                        }
                        else if (weight === true) {
                            if (childColumn.weight != null) {
                                return child;
                            }
                        }
                        else {
                            if (childColumn.weight == null) {
                                return child;
                            }
                        }
                    }
                }
            }
            else {
                for (let i = columnIndex; 0 <= i; --i) {
                    const child = children[childrenLength - i - 1];
                    const childColumn = child.column;
                    if (childColumn.resizable) {
                        if (weight == null) {
                            return child;
                        }
                        else if (weight === true) {
                            if (childColumn.weight != null) {
                                return child;
                            }
                        }
                        else {
                            if (childColumn.weight == null) {
                                return child;
                            }
                        }
                    }
                }
            }
            return null;
        }
        findCells(columnIndex, direction, weight) {
            const result = [];
            const children = this._row.children;
            const childrenLength = children.length;
            if (direction) {
                for (let i = columnIndex; i < childrenLength; ++i) {
                    const child = children[childrenLength - i - 1];
                    if (weight) {
                        if (child.column.weight != null) {
                            result.push(child);
                        }
                    }
                    else {
                        if (child.column.weight == null) {
                            result.push(child);
                        }
                    }
                }
            }
            else {
                for (let i = columnIndex; 0 <= i; --i) {
                    const child = children[childrenLength - i - 1];
                    if (weight) {
                        if (child.column.weight != null) {
                            result.push(child);
                        }
                    }
                    else {
                        if (child.column.weight == null) {
                            result.push(child);
                        }
                    }
                }
            }
            return result;
        }
        calcData(columnIndex) {
            const left = this.findResizableCell(columnIndex, false, null);
            if (left != null) {
                const leftColumn = left.column;
                const right = this.findResizableCell(columnIndex + 1, true, null);
                if (right != null) {
                    const rightColumn = right.column;
                    if (leftColumn.weight == null) {
                        if (rightColumn.weight == null) {
                            // Width - Width
                            return [1, left, right];
                        }
                        else {
                            // Width - Weight
                            const others = this.findCells(0, true, true);
                            return [2, left, right, others];
                        }
                    }
                    else {
                        if (rightColumn.weight == null) {
                            // Weight - Width
                            const others = this.findCells(0, true, true);
                            return [3, left, right, others];
                        }
                        else {
                            // Weight - Weight
                            return [1, left, right];
                        }
                    }
                }
                else {
                    if (leftColumn.weight == null) {
                        // Width
                        const ls = this.findCells(left.columnIndex - 1, false, true);
                        if (ls.length <= 0) {
                            return [0, left];
                        }
                        // Not resizable
                        return null;
                    }
                    else {
                        // Not resizable
                        return null;
                    }
                }
            }
            // Not resizable
            return null;
        }
        get left() {
            let result = this._left;
            if (result === undefined) {
                result = this.calcData(this._columnIndex - 1);
                this._left = result;
            }
            return result;
        }
        get right() {
            let result = this._right;
            if (result === undefined) {
                result = this.calcData(this._columnIndex);
                this._right = result;
            }
            return result;
        }
        onDown(e) {
            const cell = this._cell;
            const hoveredOnEdge = cell.state.valueOf(DTableState.HOVERED_ON_EDGE);
            if (hoveredOnEdge != null) {
                this._dragged = true;
                const layer = DApplications.getLayer(cell);
                if (layer != null) {
                    const interactionManager = layer.renderer.plugins.interaction;
                    if (hoveredOnEdge === DTableCellEdgeHovered.LEFT) {
                        const left = this.left;
                        if (left != null) {
                            this.onDown_(e.data.global.x, left, interactionManager);
                        }
                    }
                    else {
                        const right = this.right;
                        if (right != null) {
                            this.onDown_(e.data.global.x, right, interactionManager);
                        }
                    }
                }
                return true;
            }
            else {
                this._dragged = false;
                return false;
            }
        }
        onDown_(onDownPoint, data, interactionManager) {
            switch (data[0]) {
                case 0:
                    this.onDown0(onDownPoint, data, interactionManager);
                    break;
                case 1:
                    this.onDown1(onDownPoint, data, interactionManager);
                    break;
                case 2:
                    this.onDown2(onDownPoint, data, interactionManager);
                    break;
                case 3:
                    this.onDown3(onDownPoint, data, interactionManager);
                    break;
            }
        }
        onOver(e) {
            var _a;
            if (this.left != null || this.right != null) {
                const onHoveredBound = ((_a = this._onHoveredBound) !== null && _a !== void 0 ? _a : (this._onHoveredBound = (event) => {
                    this.onHovered(event);
                }));
                const cell = this._cell;
                cell.off(UtilPointerEvent.move, onHoveredBound);
                cell.on(UtilPointerEvent.move, onHoveredBound);
                // Since the cursor is set by InteractionManager before this method is called,
                // the cursor need to be overriden.
                this.onHovered(e);
                const layer = DApplications.getLayer(cell);
                if (layer != null) {
                    layer.renderer.plugins.interaction.cursor = cell.cursor;
                }
            }
        }
        onOut(e) {
            const onHoveredBound = this._onHoveredBound;
            if (onHoveredBound != null) {
                const cell = this._cell;
                cell.state.remove(DTableState.HOVERED_ON_EDGE);
                cell.off(UtilPointerEvent.move, onHoveredBound);
            }
        }
        onHovered(e) {
            const cell = this._cell;
            const width = cell.width;
            const x = this.toX(e);
            const size = this._size;
            let onLeft = 0 <= x && x <= size;
            let onRight = width - size <= x && x <= width;
            if (onLeft && onRight) {
                if (x <= width - x) {
                    onRight = false;
                }
                else {
                    onLeft = false;
                }
            }
            if (onLeft) {
                if (this.left != null) {
                    cell.state.add(DTableState.HOVERED_ON_EDGE, DTableCellEdgeHovered.LEFT);
                }
                else {
                    cell.state.remove(DTableState.HOVERED_ON_EDGE);
                }
            }
            else if (onRight) {
                if (this.right != null) {
                    cell.state.add(DTableState.HOVERED_ON_EDGE, DTableCellEdgeHovered.RIGHT);
                }
                else {
                    cell.state.remove(DTableState.HOVERED_ON_EDGE);
                }
            }
            else {
                cell.state.remove(DTableState.HOVERED_ON_EDGE);
            }
        }
        toX(e) {
            var _a;
            const checkWork = ((_a = this._checkWork) !== null && _a !== void 0 ? _a : (this._checkWork = new pixi_js.Point()));
            return this._cell.toLocal(e.data.global, undefined, checkWork, true).x;
        }
        onDown0(onDownPoint, data, interactionManager) {
            const left = data[1];
            const leftColumn = left.column;
            const leftOldWidth = left.width;
            const leftMinWidth = Math.max(this._minWidth, leftColumn.minWidth);
            const onMove = (e) => {
                leftColumn.width = Math.max(leftMinWidth, leftOldWidth + e.data.global.x - onDownPoint);
            };
            this.newOnUp(onMove, interactionManager);
        }
        onDown1(onDownPoint, data, interactionManager) {
            const minWidth = this._minWidth;
            const left = data[1];
            const leftColumn = left.column;
            const leftOldWidth = left.width;
            const right = data[2];
            const rightColumn = right.column;
            const rightOldWidth = right.width;
            const totalWidth = leftOldWidth + rightOldWidth;
            if (leftColumn.weight == null) {
                const leftMinWidth = Math.max(minWidth, leftColumn.minWidth);
                const rightMinWidth = Math.max(minWidth, rightColumn.minWidth);
                const leftMaxWidth = totalWidth - rightMinWidth;
                if (totalWidth <= 0 || leftMaxWidth <= leftMinWidth) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                const onMove = (e) => {
                    const leftNewWidth = Math.max(leftMinWidth, Math.min(leftMaxWidth, leftOldWidth + e.data.global.x - onDownPoint));
                    leftColumn.width = leftNewWidth;
                    rightColumn.width = totalWidth - leftNewWidth;
                };
                this.newOnUp(onMove, interactionManager);
            }
            else {
                const leftOldWeight = left.weight;
                const rightOldWeight = right.weight;
                const totalWeight = leftOldWeight + rightOldWeight;
                const leftMinWeight = leftColumn.minWeight;
                const rightMinWeight = rightColumn.minWeight;
                const leftMaxWeight = totalWeight - rightMinWeight;
                const leftMinWidth = minWidth;
                const rightMinWidth = minWidth;
                const leftMaxWidth = totalWidth - rightMinWidth;
                if (totalWidth <= 0 || leftMaxWidth <= leftMinWidth || leftMaxWeight <= leftMinWeight) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                const onMove = (e) => {
                    const leftNewWidth = Math.max(leftMinWidth, Math.min(leftMaxWidth, leftOldWidth + e.data.global.x - onDownPoint));
                    const leftNewWeight = Math.max(leftMinWeight, Math.min(leftMaxWeight, totalWeight * (leftNewWidth / totalWidth)));
                    leftColumn.weight = leftNewWeight;
                    rightColumn.weight = totalWeight - leftNewWeight;
                };
                this.newOnUp(onMove, interactionManager);
            }
        }
        onDown2(onDownPoint, data, interactionManager) {
            if (data[3].length <= 1) {
                this.onDown2a(onDownPoint, data, interactionManager);
            }
            else {
                this.onDown2b(onDownPoint, data, interactionManager);
            }
        }
        onDown2a(onDownPoint, data, interactionManager) {
            const minWidth = this._minWidth;
            const left = data[1];
            const leftColumn = left.column;
            const leftOldWidth = left.width;
            const leftMinWidth = Math.max(minWidth, leftColumn.minWidth);
            const right = data[2];
            const rightOldWidth = right.width;
            const rightMinWidth = minWidth;
            const totalWidth = leftOldWidth + rightOldWidth;
            const leftMaxWidth = totalWidth - rightMinWidth;
            if (totalWidth <= 0 || leftMaxWidth <= leftMinWidth) {
                // The left and right resizable cells doesn't have enough width
                return;
            }
            const onMove = (e) => {
                leftColumn.width = Math.max(leftMinWidth, Math.min(leftMaxWidth, leftOldWidth + e.data.global.x - onDownPoint));
            };
            this.newOnUp(onMove, interactionManager);
        }
        onDown2b(onDownPoint, data, interactionManager) {
            const minWidth = this._minWidth;
            const left = data[1];
            const leftColumn = left.column;
            const leftOldWidth = left.width;
            const leftMinWidth = Math.max(minWidth, leftColumn.minWidth);
            const right = data[2];
            const rightColumn = right.column;
            const rightOldWidth = right.width;
            const rightMinWeight = rightColumn.minWeight;
            const totalWidth = leftOldWidth + rightOldWidth;
            const others = data[3];
            let totalWeight = 0;
            let totalSpace = 0;
            for (let i = 0, imax = others.length; i < imax; ++i) {
                const other = others[i];
                totalWeight += other.weight;
                totalSpace += other.width;
            }
            if (totalWeight <= 0 || totalSpace <= 0) {
                const rightMinWidth = minWidth;
                const leftMaxWidth = totalWidth - rightMinWidth;
                if (totalWidth <= 0 || leftMaxWidth <= leftMinWidth) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                if (totalWeight <= 0) {
                    totalWeight = 0;
                    for (let i = 0, imax = others.length; i < imax; ++i) {
                        const other = others[i];
                        const otherColumn = other.column;
                        if (other !== right) {
                            const otherNewWeight = otherColumn.minWeight;
                            otherColumn.weight = otherNewWeight;
                            totalWeight += otherNewWeight;
                        }
                        else {
                            const rightNewWeight = Math.max(1, rightMinWeight);
                            otherColumn.weight = rightNewWeight;
                            totalWeight += rightNewWeight;
                        }
                    }
                }
                const onMove = (e) => {
                    leftColumn.width = Math.max(leftMinWidth, Math.min(leftMaxWidth, leftOldWidth + e.data.global.x - onDownPoint));
                };
                this.newOnUp(onMove, interactionManager);
            }
            else {
                const rightMinWidth = Math.max(minWidth, totalSpace * (rightMinWeight / totalWeight));
                const leftMaxWidth = totalWidth - rightMinWidth;
                if (totalWidth <= 0 || leftMaxWidth <= leftMinWidth) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                const onMove = (e) => {
                    const leftNewWidth = Math.max(leftMinWidth, Math.min(leftMaxWidth, leftOldWidth + e.data.global.x - onDownPoint));
                    const rightNewWidth = totalWidth - leftNewWidth;
                    const rightNewWeight = Math.max(rightMinWeight, totalWeight * (rightNewWidth / totalSpace));
                    leftColumn.width = leftNewWidth;
                    rightColumn.weight = rightNewWeight;
                };
                this.newOnUp(onMove, interactionManager);
            }
        }
        onDown3(onDownPoint, data, interactionManager) {
            if (data[3].length <= 1) {
                this.onDown3a(onDownPoint, data, interactionManager);
            }
            else {
                this.onDown3b(onDownPoint, data, interactionManager);
            }
        }
        onDown3a(onDownPoint, data, interactionManager) {
            const minWidth = this._minWidth;
            const left = data[1];
            const leftOldWidth = left.width;
            const leftMinWidth = minWidth;
            const right = data[2];
            const rightColumn = right.column;
            const rightOldWidth = right.width;
            const rightMinWidth = Math.max(minWidth, rightColumn.minWidth);
            const totalWidth = leftOldWidth + rightOldWidth;
            const rightMaxWidth = totalWidth - leftMinWidth;
            if (totalWidth <= 0 || rightMaxWidth <= rightMinWidth) {
                // The left and right resizable cells doesn't have enough width
                return;
            }
            const onMove = (e) => {
                rightColumn.width = Math.max(rightMinWidth, Math.min(rightMaxWidth, rightOldWidth + onDownPoint - e.data.global.x));
            };
            this.newOnUp(onMove, interactionManager);
        }
        onDown3b(onDownPoint, data, interactionManager) {
            const minWidth = this._minWidth;
            const left = data[1];
            const leftColumn = left.column;
            const leftOldWidth = left.width;
            const leftMinWeight = leftColumn.minWeight;
            const right = data[2];
            const rightColumn = right.column;
            const rightOldWidth = right.width;
            const rightMinWidth = Math.max(minWidth, rightColumn.minWidth);
            const totalWidth = leftOldWidth + rightOldWidth;
            const others = data[3];
            let totalWeight = 0;
            let totalSpace = 0;
            for (let i = 0, imax = others.length; i < imax; ++i) {
                const other = others[i];
                totalWeight += other.weight;
                totalSpace += other.width;
            }
            if (totalWeight <= 0 || totalSpace <= 0) {
                const leftMinWidth = minWidth;
                const rightMaxWidth = totalWidth - leftMinWidth;
                if (totalWidth <= 0 || rightMaxWidth <= rightMinWidth) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                if (totalWeight <= 0) {
                    totalWeight = 0;
                    for (let i = 0, imax = others.length; i < imax; ++i) {
                        const other = others[i];
                        const otherColumn = other.column;
                        if (other !== left) {
                            const otherNewWeight = otherColumn.minWeight;
                            otherColumn.weight = otherNewWeight;
                            totalWeight += otherNewWeight;
                        }
                        else {
                            const leftNewWeight = Math.max(1, leftMinWeight);
                            otherColumn.weight = leftNewWeight;
                            totalWeight += leftNewWeight;
                        }
                    }
                }
                const onMove = (e) => {
                    rightColumn.width = Math.max(rightMinWidth, Math.min(rightMaxWidth, rightOldWidth + onDownPoint - e.data.global.x));
                };
                this.newOnUp(onMove, interactionManager);
            }
            else {
                const leftMinWidth = Math.max(minWidth, totalSpace * (leftMinWeight / totalWeight));
                const rightMaxWidth = totalWidth - leftMinWidth;
                if (totalWidth <= 0 || rightMaxWidth <= rightMinWidth) {
                    // The left and right resizable cells doesn't have enough width
                    return;
                }
                const onMove = (e) => {
                    const rightNewWidth = Math.max(rightMinWidth, Math.min(rightMaxWidth, rightOldWidth + onDownPoint - e.data.global.x));
                    const leftNewWidth = totalWidth - rightNewWidth;
                    const leftNewWeight = Math.max(leftMinWeight, totalWeight * (leftNewWidth / totalSpace));
                    rightColumn.width = rightNewWidth;
                    leftColumn.weight = leftNewWeight;
                };
                this.newOnUp(onMove, interactionManager);
            }
        }
        newOnUp(onMove, interactionManager) {
            const row = this._row;
            row.state.add(DTableState.RESIZING);
            const onUp = () => {
                row.state.remove(DTableState.RESIZING);
                interactionManager.off(UtilPointerEvent.move, onMove);
                interactionManager.off(UtilPointerEvent.up, onUp);
                interactionManager.off(UtilPointerEvent.upoutside, onUp);
                interactionManager.off(UtilPointerEvent.cancel, onUp);
            };
            interactionManager.on(UtilPointerEvent.move, onMove);
            interactionManager.on(UtilPointerEvent.up, onUp);
            interactionManager.on(UtilPointerEvent.upoutside, onUp);
            interactionManager.on(UtilPointerEvent.cancel, onUp);
            return onUp;
        }
        isClicked(e) {
            return (e instanceof pixi_js.InteractionEvent &&
                (this._cell.state.is(DTableState.HOVERED_ON_EDGE) || this._dragged));
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableCategoryCell extends DImage {
        constructor(category, columnIndex, column, options) {
            super(options);
            this._category = category;
            this._columnIndex = columnIndex;
            this._column = column;
            this._edge = new DTableCellEdge(this._category, this, columnIndex, this.theme.getEdgeWidth());
        }
        get column() {
            return this._column;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get category() {
            return this._category;
        }
        onDown(e) {
            if (!this._edge.onDown(e)) {
                super.onDown(e);
            }
        }
        onOver(e) {
            super.onOver(e);
            this._edge.onOver(e);
        }
        onOut(e) {
            super.onOut(e);
            this._edge.onOut(e);
        }
        getType() {
            return "DTableCategoryCell";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableCategoryColumnImpl extends pixi_js.utils.EventEmitter {
        constructor(index, column) {
            super();
            // Label
            const category = column.category;
            if (category) {
                if (isString(category)) {
                    if (index === 0) {
                        this.label = category;
                    }
                }
                else {
                    if (index < category.length) {
                        this.label = category[index];
                    }
                }
            }
            this._weight = column.weight;
            this._width = column.width;
            this._isLocked = false;
            this.offset = 0.0;
            this._columns = [column];
            this.resizable = column.resizable;
            const onResizeBound = () => {
                this.onResize();
            };
            this._onResizeBound = onResizeBound;
            column.on("resize", onResizeBound);
        }
        onResize() {
            if (this._isLocked) {
                return;
            }
            const columns = this._columns;
            if (this._weight != null) {
                let newWeight = 0;
                for (let i = 0, imax = columns.length; i < imax; ++i) {
                    const weight = columns[i].weight;
                    if (weight != null) {
                        newWeight += weight;
                    }
                }
                if (this._weight !== newWeight) {
                    this._weight = newWeight;
                    this.emit("resize", this);
                }
            }
            else {
                let newWidth = 0;
                for (let i = 0, imax = columns.length; i < imax; ++i) {
                    const width = columns[i].width;
                    if (width != null) {
                        newWidth += width;
                    }
                }
                if (this._width !== newWidth) {
                    this._width = newWidth;
                    this.emit("resize", this);
                }
            }
        }
        get weight() {
            return this._weight;
        }
        set weight(weight) {
            const oldWeight = this._weight;
            if (oldWeight != null && oldWeight !== weight) {
                const columns = this._columns;
                const columnsLength = columns.length;
                const minWeight = this.minWeight;
                const newWeight = Math.max(minWeight, weight);
                if (this._weight !== newWeight) {
                    this._isLocked = true;
                    if (minWeight < oldWeight) {
                        // TODO: IMPROVE THIS
                        const columnWeightRatio = newWeight / oldWeight;
                        for (let i = 0; i < columnsLength; ++i) {
                            const column = columns[i];
                            const columnWeight = column.weight;
                            if (columnWeight != null) {
                                column.weight = Math.max(column.minWeight, columnWeight * columnWeightRatio);
                            }
                        }
                    }
                    else {
                        for (let i = 0; i < columnsLength; ++i) {
                            const column = columns[i];
                            const columnWeight = column.weight;
                            if (columnWeight != null) {
                                column.weight = column.minWeight;
                            }
                        }
                    }
                    this._isLocked = false;
                    this.onResize();
                }
            }
        }
        get minWeight() {
            let result = 0;
            const columns = this._columns;
            const columnsLength = columns.length;
            for (let i = 0; i < columnsLength; ++i) {
                const column = columns[i];
                const columnWeight = column.weight;
                if (columnWeight != null) {
                    result += column.minWeight;
                }
            }
            return result;
        }
        get width() {
            return this._width;
        }
        set width(width) {
            const oldWidth = this._width;
            if (oldWidth != null && oldWidth !== width) {
                const columns = this._columns;
                const columnsLength = columns.length;
                const minWidth = this.minWidth;
                const newWidth = Math.max(minWidth, width);
                if (oldWidth !== newWidth) {
                    this._isLocked = true;
                    if (minWidth < oldWidth) {
                        // TODO: IMPROVE THIS
                        const columnWidthRatio = newWidth / oldWidth;
                        for (let i = 0; i < columnsLength; ++i) {
                            const column = columns[i];
                            const columnWidth = column.width;
                            if (columnWidth != null) {
                                column.width = Math.max(column.minWidth, columnWidth * columnWidthRatio);
                            }
                        }
                    }
                    else {
                        for (let i = 0; i < columnsLength; ++i) {
                            const column = columns[i];
                            const columnWidth = column.width;
                            if (columnWidth != null) {
                                column.width = column.minWidth;
                            }
                        }
                    }
                    this._isLocked = false;
                    this.onResize();
                }
            }
        }
        get minWidth() {
            let result = 0;
            const columns = this._columns;
            const columnsLength = columns.length;
            for (let i = 0; i < columnsLength; ++i) {
                const column = columns[i];
                const columnWidth = column.width;
                if (columnWidth != null) {
                    result += column.minWidth;
                }
            }
            return result;
        }
        add(column) {
            this._columns.push(column);
            if (this._weight != null) {
                const weight = column.weight;
                if (weight != null) {
                    this._weight += weight;
                    column.on("resize", this._onResizeBound);
                }
            }
            else if (this._width != null) {
                const width = column.width;
                if (width != null) {
                    this._width += width;
                    column.on("resize", this._onResizeBound);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableCategory extends DTableRow {
        constructor(columns, frozen, offset, options) {
            super(columns, frozen, options);
            this._columns = columns;
            this._frozen = frozen;
            this._offset = offset;
            this.transform.position.y = offset;
            this.initCells();
            for (let i = 0, imax = columns.length; i < imax; ++i) {
                const column = columns[i];
                column.on("resize", this.newOnColumnResize(i, column));
            }
        }
        newOnColumnResize(index, column) {
            return () => {
                this.onColumnResize(index, column);
            };
        }
        onColumnResize(index, column) {
            const columnWeight = column.weight;
            if (columnWeight != null) {
                this.onColumnResizeWeight(this, index, columnWeight);
            }
            else {
                const columnWidth = column.width;
                if (columnWidth != null) {
                    this.onColumnResizeWidth(this, index, columnWidth);
                }
            }
        }
        onColumnResizeWeight(row, index, columnWeight) {
            const cells = row.children;
            const cellsLength = cells.length;
            const cellsIndex = cellsLength - index - 1;
            if (0 <= cellsIndex && cellsIndex < cellsLength) {
                cells[cellsIndex].weight = columnWeight;
            }
        }
        onColumnResizeWidth(row, index, columnWidth) {
            const cells = row.children;
            const cellsLength = cells.length;
            const cellsIndex = cellsLength - index - 1;
            if (0 <= cellsIndex && cellsIndex < cellsLength) {
                cells[cellsIndex].width = columnWidth;
            }
        }
        onParentMove(newX, newY, oldX, oldY) {
            super.onParentMove(newX, newY, oldX, oldY);
            this.transform.position.y = -newY + this._offset;
            this.updateFrozenCellPosition(newX);
        }
        getContentPositionX() {
            const content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        }
        newCell(columnIndex, column, columns, options) {
            return new DTableCategoryCell(this, columnIndex, column, this.toCellOptions(columnIndex, column, options));
        }
        toCellOptions(columnIndex, column, options) {
            const result = options === null || options === void 0 ? void 0 : options.cell;
            if (result) {
                // Weight
                result.weight = column.weight;
                // Width
                result.width = column.width;
                // Label
                const text = result.text || {};
                result.text = text;
                text.value = text.value || column.label;
                // Done
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    }
                };
            }
        }
        getType() {
            return "DTableCategory";
        }
    }

    class DTableCategoryContainerImpl {
        constructor(columns, frozen, options) {
            const count = this.toCount(columns);
            const items = [];
            let offset = 0;
            for (let i = count - 1; 0 <= i; --i) {
                const item = new DTableCategory(this.toColumns(i, columns, frozen), frozen, offset, options);
                items.push(item);
                offset += item.height;
            }
            this.items = items;
        }
        toCount(columns) {
            let result = 0;
            for (let i = 0, imax = columns.length; i < imax; ++i) {
                const category = columns[i].category;
                if (category != null) {
                    const count = isString(category) ? 1 : category.length;
                    result = Math.max(result, count);
                }
            }
            return result;
        }
        isEqual(index, a, b) {
            if (a != null) {
                if (b != null) {
                    if (isString(a)) {
                        if (isString(b)) {
                            if (0 < index) {
                                return true;
                            }
                            else {
                                return a === b;
                            }
                        }
                        else {
                            if (0 < index) {
                                return b.length <= index;
                            }
                            else {
                                return b.length === 1 && a === b[0];
                            }
                        }
                    }
                    else {
                        if (isString(b)) {
                            if (0 < index) {
                                return a.length <= index;
                            }
                            else {
                                return a.length === 1 && a[0] === b;
                            }
                        }
                        else {
                            if (a.length <= index && b.length <= index) {
                                return true;
                            }
                            else if (b.length === a.length) {
                                for (let i = index, imax = a.length; i < imax; ++i) {
                                    if (a[i] !== b[i]) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                            return false;
                        }
                    }
                }
                else {
                    if (isString(a)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (a.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
            }
            else {
                if (b != null) {
                    if (isString(b)) {
                        if (0 < index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        if (b.length <= index) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    return true;
                }
            }
        }
        toColumns(index, columns, frozen) {
            const result = [];
            let tcolumn = null;
            let ccolumn = null;
            for (let i = 0, imax = columns.length; i < imax; ++i) {
                const column = columns[i];
                if (i !== frozen &&
                    ccolumn &&
                    tcolumn &&
                    this.isEqual(index, tcolumn.category, column.category)) {
                    if (ccolumn.resizable === column.resizable) {
                        if (ccolumn.weight != null && column.weight != null) {
                            ccolumn.add(column);
                        }
                        else if (ccolumn.width != null && column.width != null) {
                            ccolumn.add(column);
                        }
                        else {
                            tcolumn = column;
                            ccolumn = new DTableCategoryColumnImpl(index, column);
                            result.push(ccolumn);
                        }
                    }
                    else {
                        tcolumn = column;
                        ccolumn = new DTableCategoryColumnImpl(index, column);
                        result.push(ccolumn);
                    }
                }
                else {
                    tcolumn = column;
                    ccolumn = new DTableCategoryColumnImpl(index, column);
                    result.push(ccolumn);
                }
            }
            return result;
        }
    }

    const defaultGetter = (row, columnIndex) => {
        return row[columnIndex];
    };
    const defaultSetter = (row, columnIndex, cell) => {
        row[columnIndex] = cell;
    };
    const defaultGetterEmpty = () => "";
    const defaultSetterEmpty = () => {
        // DO NOTHING
    };
    const toPathGetter = (path, def) => {
        if (path.length <= 1) {
            const key = path[0];
            if (def === undefined) {
                return (row) => {
                    return row[key];
                };
            }
            else {
                return (row) => {
                    return Object.prototype.hasOwnProperty.call(row, key) ? row[key] : def;
                };
            }
        }
        else {
            if (def === undefined) {
                return (row) => {
                    for (let i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    return row[path[path.length - 1]];
                };
            }
            else {
                return (row) => {
                    for (let i = 0, imax = path.length - 1; i < imax; ++i) {
                        row = row[path[i]];
                    }
                    const key = path[path.length - 1];
                    return Object.prototype.hasOwnProperty.call(row, key) ? row[key] : def;
                };
            }
        }
    };
    const toPathSetter = (path) => {
        if (path.length <= 1) {
            const key = path[0];
            return (row, columnIndex, cell) => {
                row[key] = cell;
            };
        }
        else {
            return (row, columnIndex, cell) => {
                for (let i = 0, imax = path.length - 1; i < imax; ++i) {
                    row = row[path[i]] || {};
                }
                row[path[path.length - 1]] = cell;
            };
        }
    };
    const toAlign = (options, type) => {
        const align = options.align;
        if (align != null) {
            if (isString(align)) {
                return DAlignHorizontal[align];
            }
            else {
                return align;
            }
        }
        switch (type) {
            case DTableColumnType.TEXT:
            case DTableColumnType.TEXT_AREA:
                return DAlignHorizontal.LEFT;
            case DTableColumnType.REAL:
            case DTableColumnType.INTEGER:
                return DAlignHorizontal.RIGHT;
            case DTableColumnType.BUTTON:
            case DTableColumnType.INDEX:
            case DTableColumnType.SELECT:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
            case DTableColumnType.CHECK:
            case DTableColumnType.CHECK_SINGLE:
            case DTableColumnType.COLOR:
                return DAlignHorizontal.CENTER;
            default:
                return DAlignHorizontal.LEFT;
        }
    };
    const toDataChecker = (path) => {
        if (path != null) {
            const pathLength = path.length;
            if (pathLength <= 1) {
                const key = path[0];
                return (row) => {
                    return Object.prototype.hasOwnProperty.call(row, key);
                };
            }
            else {
                return (row) => {
                    for (let i = 0; i < pathLength; ++i) {
                        const part = path[i];
                        if (part in row) {
                            row = row[part];
                        }
                        else {
                            return false;
                        }
                    }
                    return true;
                };
            }
        }
        return (row, columnIndex) => {
            return columnIndex < row.length;
        };
    };
    const toEditingEnable = (enable, path) => {
        if (isString(enable)) {
            return toDataChecker(path);
        }
        else if (enable != null) {
            return enable;
        }
        else {
            return false;
        }
    };
    const toEditing = (options, path) => {
        var _a;
        const editing = options.editing;
        const editable = options.editable;
        if (editing) {
            return {
                enable: toEditingEnable((_a = editing.enable) !== null && _a !== void 0 ? _a : editable, path),
                formatter: editing.formatter,
                unformatter: editing.unformatter,
                validator: editing.validator
            };
        }
        return {
            enable: toEditingEnable(editable, path)
        };
    };
    const toComparator = (getter, index) => {
        return (rowA, rowB) => {
            const valueA = getter(rowA, index);
            const valueB = getter(rowB, index);
            return valueA < valueB ? -1 : valueB < valueA ? +1 : 0;
        };
    };
    const toSorting = (getter, index, options) => {
        const sorting = options.sorting;
        const sortable = options.sortable;
        if (sorting) {
            if (sorting.enable || sortable) {
                return {
                    enable: true,
                    comparator: sorting.comparator || toComparator(getter, index)
                };
            }
            return {
                enable: false
            };
        }
        if (sortable) {
            return {
                enable: true,
                comparator: toComparator(getter, index)
            };
        }
        return {
            enable: false
        };
    };
    const toMenu = (options) => {
        if (options == null) {
            return undefined;
        }
        else if (options instanceof DMenu) {
            return options;
        }
        else {
            return new DMenu(options);
        }
    };
    const toDialog = (options) => {
        if (options == null) {
            return undefined;
        }
        else if ("open" in options) {
            return options;
        }
        else {
            return new DDialogSelect(options);
        }
    };
    const defaultSelectingGetter = (dialog) => {
        return dialog.value;
    };
    const defaultSelectingSetter = () => {
        // DO NOTHING
    };
    const toSelecting = (options) => {
        if (options) {
            return {
                getter: options.getter || defaultSelectingGetter,
                setter: options.setter || defaultSelectingSetter,
                menu: toMenu(options.menu),
                multiple: toMenu(options.multiple),
                dialog: toDialog(options.dialog),
                promise: options.promise
            };
        }
        return {
            getter: defaultSelectingGetter,
            setter: defaultSelectingSetter
        };
    };
    const toGetter = (options, type, parts) => {
        const getter = options.getter;
        if (getter) {
            return getter;
        }
        switch (type) {
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultGetterEmpty;
            default:
                if (parts == null) {
                    return defaultGetter;
                }
                else {
                    return toPathGetter(parts, options.default);
                }
        }
    };
    const toSetter = (options, type, path) => {
        const setter = options.setter;
        if (setter) {
            return setter;
        }
        switch (type) {
            case DTableColumnType.BUTTON:
            case DTableColumnType.ACTION:
            case DTableColumnType.LINK:
                return defaultSetterEmpty;
            default:
                if (path == null) {
                    return defaultSetter;
                }
                else {
                    return toPathSetter(path);
                }
        }
    };
    const toState = (options) => {
        const state = options.state;
        if (state != null) {
            if (isString(state) || isArray(state)) {
                return {
                    initial: state,
                    modifier: undefined
                };
            }
            else {
                return {
                    initial: undefined,
                    modifier: state
                };
            }
        }
        return {
            initial: undefined,
            modifier: undefined
        };
    };
    const toPath = (options) => {
        return options.path != null ? options.path.split(".") : null;
    };
    const toRenderable = (options, path) => {
        const renderable = options.renderable;
        if (isString(renderable)) {
            return toDataChecker(path);
        }
        else if (renderable != null) {
            return renderable;
        }
        return true;
    };
    class DTableColumnImpl extends pixi_js.utils.EventEmitter {
        constructor(index, options) {
            var _a, _b, _c;
            super();
            let weight = options.weight;
            let width = options.width;
            if (weight != null) {
                if (width != null) {
                    width = undefined;
                }
            }
            else if (width == null) {
                weight = 1;
            }
            const type = toEnum((_a = options.type) !== null && _a !== void 0 ? _a : DTableColumnType.TEXT, DTableColumnType);
            const align = toAlign(options, type);
            const label = options.label || "";
            const path = toPath(options);
            const getter = toGetter(options, type, path);
            const setter = toSetter(options, type, path);
            this._weight = weight;
            this.minWeight = 0;
            this._width = width;
            this.minWidth = 0;
            this.resizable = (_b = options.resizable) !== null && _b !== void 0 ? _b : false;
            this.type = type;
            this.label = label;
            this.getter = getter;
            this.setter = setter;
            this.formatter = options.formatter;
            this.renderable = toRenderable(options, path);
            this.align = align;
            this.state = toState(options);
            this.editing = toEditing(options, path);
            this.sorting = toSorting(getter, index, options);
            this.header = options.header;
            this.body = options.body;
            this.selecting = toSelecting(options.selecting);
            this.category = options.category;
            this.frozen = options.frozen;
            this.offset = 0.0;
            this.link = options.link;
            this.update = toEnum((_c = options.update) !== null && _c !== void 0 ? _c : DTableColumnUpdate.CELL, DTableColumnUpdate);
        }
        get weight() {
            return this._weight;
        }
        set weight(weight) {
            if (this._weight != null && this._weight !== weight) {
                this._weight = weight;
                this.emit("resize", this);
            }
        }
        get width() {
            return this._width;
        }
        set width(width) {
            if (this._width != null && this._width !== width) {
                this._width = width;
                this.emit("resize", this);
            }
        }
    }

    class DTableColumnContainerImpl extends pixi_js.utils.EventEmitter {
        constructor(parent, options) {
            super();
            this.parent = parent;
            const columns = [];
            if (options != null) {
                for (let i = 0, imax = options.length; i < imax; ++i) {
                    const column = new DTableColumnImpl(i, options[i]);
                    columns.push(column);
                    column.on("resize", this.newOnColumnResize(i, column));
                }
            }
            this.items = columns;
            let frozen = 0;
            for (let i = columns.length - 1; 0 <= i; --i) {
                if (columns[i].frozen === true) {
                    frozen = i + 1;
                    break;
                }
            }
            this.frozen = frozen;
        }
        newOnColumnResize(index, column) {
            return () => {
                this.onColumnResize(index, column);
            };
        }
        onColumnResize(index, column) {
            this.onColumnResizeHeader(index, column);
            this.onColumnResizeBody(index, column);
            this.emit("resize", index, column, this);
        }
        onColumnResizeHeader(index, column) {
            const header = this.parent.header;
            if (header != null) {
                const columnWeight = column.weight;
                if (columnWeight != null) {
                    this.onColumnResizeWeight(header, index, columnWeight);
                }
                else {
                    const columnWidth = column.width;
                    if (columnWidth != null) {
                        this.onColumnResizeWidth(header, index, columnWidth);
                    }
                }
            }
        }
        onColumnResizeBody(index, column) {
            const rows = this.parent.body.children;
            const columnWeight = column.weight;
            if (columnWeight != null) {
                for (let i = 0, imax = rows.length; i < imax; ++i) {
                    this.onColumnResizeWeight(rows[i], index, columnWeight);
                }
            }
            else {
                const columnWidth = column.width;
                if (columnWidth != null) {
                    for (let i = 0, imax = rows.length; i < imax; ++i) {
                        this.onColumnResizeWidth(rows[i], index, columnWidth);
                    }
                }
            }
        }
        onColumnResizeWeight(row, index, columnWeight) {
            const cells = row.children;
            const cellsLength = cells.length;
            const cellsIndex = cellsLength - index - 1;
            if (0 <= cellsIndex && cellsIndex < cellsLength) {
                cells[cellsIndex].weight = columnWeight;
            }
        }
        onColumnResizeWidth(row, index, columnWidth) {
            const cells = row.children;
            const cellsLength = cells.length;
            const cellsIndex = cellsLength - index - 1;
            if (0 <= cellsIndex && cellsIndex < cellsLength) {
                cells[cellsIndex].width = columnWidth;
            }
        }
        get width() {
            let result = 0;
            const items = this.items;
            const length = items.length;
            for (let i = 0; i < length; ++i) {
                const item = items[i];
                const itemWidth = item.width;
                if (itemWidth != null) {
                    result += itemWidth;
                }
            }
            return result;
        }
        get(index) {
            const columns = this.items;
            if (0 <= index && index < columns.length) {
                return columns[index];
            }
            return null;
        }
        each(iteratee) {
            const columns = this.items;
            for (let i = 0, imax = columns.length; i < imax; ++i) {
                if (iteratee(columns[i], i) === false) {
                    break;
                }
            }
            return this;
        }
        size() {
            return this.items.length;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableDataTreeFilter extends pixi_js.utils.EventEmitter {
        constructor(parent) {
            super();
            this._id = 0;
            this._idUpdated = -1;
            this._isApplied = false;
            this._parent = parent;
            this._filter = null;
            this._filtered = null;
        }
        get id() {
            return this._id;
        }
        apply() {
            this._isApplied = true;
            this._id += 1;
            this._parent.update();
        }
        unapply() {
            if (this._isApplied) {
                this._isApplied = false;
                this._id += 1;
                this._parent.update();
            }
        }
        isApplied() {
            return this._isApplied;
        }
        isFiltered(node, index, filter) {
            if (isFunction(filter)) {
                return filter(node, index);
            }
            else {
                return filter.test(node, index);
            }
        }
        hasFiltered(parent, nodes, filter) {
            const accessor = this._parent.accessor;
            const toChildren = accessor.toChildren;
            const hasChildren = accessor.hasChildren;
            for (let i = 0, imax = nodes.length; i < imax; ++i) {
                const node = nodes[i];
                if (this.isFiltered(node, -1, filter)) {
                    return true;
                }
                const children = toChildren(node);
                if (hasChildren(node, children) && this.hasFiltered(parent, children, filter)) {
                    return true;
                }
            }
            return false;
        }
        addAllToFiltered(parent, nodes, filtered, cursor) {
            const accessor = this._parent.accessor;
            const toChildren = accessor.toChildren;
            const hasChildren = accessor.hasChildren;
            for (let i = 0, imax = nodes.length; i < imax; ++i) {
                const node = nodes[i];
                filtered.push(cursor[0]);
                cursor[0] += 1;
                const children = toChildren(node);
                if (hasChildren(node, children) && parent.isOpened(node)) {
                    this.addAllToFiltered(parent, children, filtered, cursor);
                }
            }
        }
        newFilteredSub(parent, nodes, filter, filtered, cursor) {
            let result = false;
            const accessor = this._parent.accessor;
            const toChildren = accessor.toChildren;
            const hasChildren = accessor.hasChildren;
            for (let i = 0, imax = nodes.length; i < imax; ++i) {
                const node = nodes[i];
                const index = cursor[0];
                cursor[0] += 1;
                const isFiltered = this.isFiltered(node, index, filter);
                const children = toChildren(node);
                if (hasChildren(node, children)) {
                    if (parent.isOpened(node)) {
                        if (isFiltered) {
                            filtered.push(index);
                            result = true;
                            this.addAllToFiltered(parent, children, filtered, cursor);
                        }
                        else {
                            const position = filtered.length;
                            if (this.newFilteredSub(parent, children, filter, filtered, cursor)) {
                                filtered.splice(position, 0, index);
                                result = true;
                            }
                        }
                    }
                    else if (isFiltered || this.hasFiltered(parent, children, filter)) {
                        filtered.push(index);
                        result = true;
                    }
                }
                else if (isFiltered) {
                    filtered.push(index);
                    result = true;
                }
            }
            return result;
        }
        newFiltered() {
            const filter = this._filter;
            if (filter != null) {
                const filtered = [];
                const parent = this._parent;
                const nodes = parent.nodes;
                if (nodes) {
                    const cursor = [0];
                    this.newFilteredSub(parent, nodes, filter, filtered, cursor);
                }
                return filtered;
            }
            return null;
        }
        get() {
            return this._filter;
        }
        set(filter) {
            if (this._filter !== filter) {
                this._filter = filter;
            }
        }
        toDirty() {
            this._id += 1;
        }
        update() {
            if (this._id !== this._idUpdated) {
                this._idUpdated = this._id;
                if (this._isApplied) {
                    this._filtered = this.newFiltered();
                    this.emit("change", this);
                }
                else if (this._filtered != null) {
                    this._filtered = null;
                    this.emit("change", this);
                }
            }
        }
        get indices() {
            this.update();
            return this._filtered;
        }
        map(sortedIndex) {
            let result = sortedIndex;
            const indices = this.indices;
            if (indices) {
                const index = indices.indexOf(result);
                if (0 <= index) {
                    result = index;
                }
                else {
                    return null;
                }
            }
            return result;
        }
        unmap(index) {
            let result = index;
            const indices = this.indices;
            if (indices) {
                result = indices[result];
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toParent = (node) => {
        return node.parent;
    };
    const toChildren$1 = (node) => {
        return node.children;
    };
    const hasChildren = (node, children) => {
        return children != null && 0 < children.length;
    };
    class DTableDataTreeItemAccessor {
        constructor(options) {
            if (options != null) {
                this.toParent = options.toParent || toParent;
                this.toChildren = options.toChildren || toChildren$1;
                this.hasChildren = options.hasChildren || hasChildren;
            }
            else {
                this.toParent = toParent;
                this.toChildren = toChildren$1;
                this.hasChildren = hasChildren;
            }
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const COMPARATOR = (a, b) => {
        return a[0] - b[0];
    };
    class DTableDataTreeSelectionImpl extends pixi_js.utils.EventEmitter {
        constructor(parent, options) {
            var _a;
            super();
            this._parent = parent;
            this._type = toEnum((_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : DTableDataSelectionType.NONE, DTableDataSelectionType);
            this._rows = new Set();
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        get parent() {
            return this._parent;
        }
        onNodeChange(nodes) {
            if (nodes != null) {
                const accessor = this._parent.accessor;
                const toChildren = accessor.toChildren;
                const hasChildren = accessor.hasChildren;
                const oldRows = this._rows;
                const newRows = this.newRows(nodes, toChildren, hasChildren, oldRows, new Set());
                if (oldRows.size !== newRows.size) {
                    this._rows = newRows;
                    this.onChange();
                }
            }
            else {
                const rows = this._rows;
                if (0 < rows.size) {
                    rows.clear();
                    this.onChange();
                }
            }
        }
        newRows(nodes, toChildren, hasChildren, rows, result) {
            for (let i = 0, imax = nodes.length; i < imax; ++i) {
                const node = nodes[i];
                if (rows.has(node)) {
                    result.add(node);
                }
                const children = toChildren(node);
                if (hasChildren(node, children)) {
                    this.newRows(children, toChildren, hasChildren, rows, result);
                }
            }
            return result;
        }
        get indices() {
            const rows = this._rows;
            const result = [];
            this._parent.each((row, index) => {
                if (rows.has(row)) {
                    result.push(index);
                }
            });
            return result;
        }
        get rows() {
            const result = [];
            this._rows.forEach((row) => {
                result.push(row);
            });
            return result;
        }
        get type() {
            return this._type;
        }
        getFirst() {
            const rows = this._rows;
            if (0 < rows.size) {
                let result = null;
                rows.forEach((row) => {
                    if (result == null) {
                        result = row;
                    }
                });
                return result;
            }
            return null;
        }
        getLast() {
            const rows = this._rows;
            if (0 < rows.size) {
                let result = null;
                rows.forEach((row) => {
                    result = row;
                });
                return result;
            }
            return null;
        }
        toIndex(target) {
            let result = null;
            this._parent.each((row, index) => {
                if (target === row) {
                    result = index;
                    return false;
                }
                return true;
            });
            return result;
        }
        get first() {
            const row = this.getFirst();
            if (row) {
                return this.toIndex(row);
            }
            return null;
        }
        get last() {
            const row = this.getLast();
            if (row) {
                return this.toIndex(row);
            }
            return null;
        }
        onChange() {
            this._parent.update();
            this.emit("change", this);
        }
        toggle(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                const rows = this._rows;
                if (rows.has(row)) {
                    rows.delete(row);
                }
                else {
                    rows.add(row);
                }
                this.onChange();
            }
        }
        add(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                const rows = this._rows;
                if (!rows.has(row)) {
                    rows.add(row);
                    this.onChange();
                }
            }
        }
        addTo(rowIndex) {
            const lastRowIndex = this.last;
            if (lastRowIndex != null) {
                this.addRange(lastRowIndex, false, rowIndex, true);
            }
        }
        addRange(from, includeFrom, to, includeTo) {
            const rows = this._rows;
            const oldSize = rows.size;
            const parent = this._parent;
            if (from < to) {
                parent.each((row) => {
                    rows.add(row);
                }, from + (includeFrom ? 0 : 1), to + (includeTo ? 1 : 0));
            }
            else {
                parent.each((row) => {
                    rows.add(row);
                }, to + (includeTo ? 0 : 1), from + (includeFrom ? 1 : 0));
            }
            const newSize = rows.size;
            if (oldSize !== newSize) {
                this.onChange();
            }
        }
        addAll(rowIndices) {
            if (0 < rowIndices.length) {
                const rows = this._rows;
                const parent = this._parent;
                for (let i = 0, imax = rowIndices.length; i < imax; ++i) {
                    const row = parent.get(rowIndices[i]);
                    if (row) {
                        rows.add(row);
                    }
                }
                this.onChange();
            }
        }
        contains(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                return this._rows.has(row);
            }
            return false;
        }
        remove(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                const rows = this._rows;
                if (rows.has(row)) {
                    rows.delete(row);
                    this.onChange();
                }
            }
        }
        clear() {
            const rows = this._rows;
            if (0 < rows.size) {
                rows.clear();
                this.onChange();
            }
        }
        clearAndAdd(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                const rows = this._rows;
                if (rows.has(row)) {
                    if (1 < rows.size) {
                        rows.clear();
                        rows.add(row);
                        this.onChange();
                    }
                }
                else {
                    rows.clear();
                    rows.add(row);
                    this.onChange();
                }
            }
        }
        clearAndAddAll(rowIndices) {
            const rows = this._rows;
            if (0 < rows.size || 0 < rowIndices.length) {
                rows.clear();
                const parent = this._parent;
                for (let i = 0, imax = rowIndices.length; i < imax; ++i) {
                    const row = parent.get(rowIndices[i]);
                    if (row) {
                        rows.add(row);
                    }
                }
                this.onChange();
            }
        }
        shift(rowIndex, amount) {
            // DO NOTHING
        }
        size() {
            return this._rows.size;
        }
        isEmpty() {
            return this._rows.size <= 0;
        }
        each(iteratee) {
            const rows = this._rows;
            this._parent.each((row, index) => {
                if (rows.has(row)) {
                    if (iteratee(index) === false) {
                        return false;
                    }
                }
                return true;
            });
        }
        toArray() {
            const rows = this._rows;
            const result = [];
            this._parent.each((row, index) => {
                if (rows.has(row)) {
                    result.push([index, row]);
                }
            });
            return result;
        }
        toSortedArray() {
            return this.toArray().sort(COMPARATOR);
        }
        toObject() {
            const rows = this._rows;
            const result = {};
            this._parent.each((row, index) => {
                if (rows.has(row)) {
                    result[index] = row;
                }
            });
            return result;
        }
        toMap() {
            const rows = this._rows;
            const result = new Map();
            this._parent.each((row, index) => {
                if (rows.has(row)) {
                    result.set(index, row);
                }
            });
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableDataTreeSorter extends pixi_js.utils.EventEmitter {
        constructor() {
            super();
        }
        get id() {
            return 0;
        }
        get order() {
            return DTableDataOrder.ASCENDING;
        }
        set order(order) {
            // DO NOTHING
        }
        apply() {
            // DO NOTHING
        }
        unapply() {
            // DO NOTHING
        }
        isApplied() {
            return false;
        }
        get() {
            return null;
        }
        set(comparator) {
            // DO NOTHING
        }
        toDirty() {
            // DO NOTHING
        }
        update() {
            // DO NOTHING
        }
        get indices() {
            return null;
        }
        map(unmappedIndex) {
            return unmappedIndex;
        }
        unmap(index) {
            return index;
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Please note that this data class does not support the sorter.
     */
    class DTableDataTree extends pixi_js.utils.EventEmitter {
        constructor(options) {
            super();
            this._parent = null;
            this._accessor = this.toAccessor(options);
            this._mapped = new DTableDataListMapped(this);
            this._rows = [];
            this._isRowsDirty = false;
            this._supplimentals = [];
            this._flags = new WeakMap();
            this._reverse = !!(options === null || options === void 0 ? void 0 : options.reverse);
            this._selection = this.toSelection(options === null || options === void 0 ? void 0 : options.selection);
            this._filter = new DTableDataTreeFilter(this);
            this._sorter = new DTableDataTreeSorter();
            if (options) {
                // Filter
                const filter = options.filter;
                if (filter) {
                    this._filter.set(filter);
                }
                // Events
                const on = options.on;
                if (on) {
                    for (const name in on) {
                        const handler = on[name];
                        if (handler) {
                            this.on(name, handler);
                        }
                    }
                }
            }
            // Update rows
            this.nodes = options === null || options === void 0 ? void 0 : options.nodes;
        }
        toSelection(options) {
            if (options instanceof pixi_js.utils.EventEmitter) {
                return options;
            }
            else if (isFunction(options)) {
                return options(this);
            }
            return this.newSelection(options);
        }
        newSelection(options) {
            return new DTableDataTreeSelectionImpl(this, options);
        }
        toAccessor(options) {
            return new DTableDataTreeItemAccessor(options);
        }
        bind(parent) {
            this._parent = parent;
        }
        get nodes() {
            return this._nodes;
        }
        set nodes(nodes) {
            this._nodes = nodes;
            this._isRowsDirty = true;
            this._selection.onNodeChange(nodes);
            this._filter.toDirty();
            this.update(true);
        }
        get rows() {
            if (this._isRowsDirty) {
                this._isRowsDirty = false;
                this.updateRows(this._nodes);
            }
            return this._rows;
        }
        get supplimentals() {
            return this._supplimentals;
        }
        get accessor() {
            return this._accessor;
        }
        updateRows(nodes) {
            const rows = this._rows;
            const supplimentals = this._supplimentals;
            const flags = this._flags;
            if (nodes != null) {
                const accessor = this._accessor;
                const irows = this.newRows(nodes, 0, 0, rows, supplimentals, flags, this._reverse, accessor.toChildren, accessor.hasChildren);
                if (irows !== rows.length) {
                    rows.length = irows;
                    supplimentals.length = irows;
                }
            }
            else {
                rows.length = 0;
                supplimentals.length = 0;
            }
        }
        toSupplimental(ilevel, hasChildren, isOpened) {
            return (ilevel << 2) | (hasChildren ? 2 : 0) | (isOpened ? 1 : 0);
        }
        newRows(nodes, irows, ilevel, rows, supplimentals, flags, reverse, toChildren, hasChildren) {
            const nodesLength = nodes.length;
            const istart = reverse ? nodesLength - 1 : 0;
            const idelta = reverse ? -1 : +1;
            for (let i = istart; 0 <= i && i < nodesLength; i += idelta) {
                const node = nodes[i];
                const children = toChildren(node);
                const isOpened = flags.has(node);
                const supplimental = this.toSupplimental(ilevel, hasChildren(node, children), isOpened);
                if (irows < rows.length) {
                    rows[irows] = node;
                    supplimentals[irows] = supplimental;
                }
                else {
                    rows.push(node);
                    supplimentals.push(supplimental);
                }
                irows += 1;
                if (isOpened && children) {
                    irows = this.newRows(children, irows, ilevel + 1, rows, supplimentals, flags, reverse, toChildren, hasChildren);
                }
            }
            return irows;
        }
        update(forcibly) {
            const parent = this._parent;
            if (parent) {
                parent.update(forcibly);
            }
        }
        lock() {
            const parent = this._parent;
            if (parent) {
                parent.lock();
            }
        }
        unlock(callIfNeeded) {
            const parent = this._parent;
            if (parent) {
                parent.unlock(callIfNeeded);
            }
        }
        size() {
            return this.rows.length;
        }
        get(index) {
            const rows = this.rows;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        }
        expand(node) {
            const flags = this._flags;
            if (!flags.has(node)) {
                flags.set(node, 1);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
                return true;
            }
            return false;
        }
        collapse(node) {
            const flags = this._flags;
            if (flags.has(node)) {
                flags.delete(node);
                this._isRowsDirty = true;
                this._filter.toDirty();
                this.update(true);
                return true;
            }
            return false;
        }
        isCollapsed(node) {
            return !this._flags.has(node);
        }
        isExpanded(node) {
            return this._flags.has(node);
        }
        toggle(node) {
            if (this.isExpanded(node)) {
                return this.collapse(node);
            }
            else {
                return this.expand(node);
            }
        }
        /** @deprecated in favor of {@link expand}. */
        open(node) {
            return this.expand(node);
        }
        /** @deprecated in favor of {@link collapse}. */
        close(node) {
            return this.collapse(node);
        }
        /** @deprecated in favor of {@link isExpanded}. */
        isOpened(node) {
            return this.isExpanded(node);
        }
        each(iteratee, ifrom, ito) {
            const rows = this.rows;
            ifrom = ifrom != null ? Math.max(0, ifrom) : 0;
            ito = ito != null ? Math.min(rows.length, ito) : rows.length;
            for (let i = ifrom; i < ito; ++i) {
                const row = rows[i];
                if (iteratee(row, i) === false) {
                    break;
                }
            }
        }
        get selection() {
            return this._selection;
        }
        get filter() {
            return this._filter;
        }
        get sorter() {
            return this._sorter;
        }
        get mapped() {
            return this._mapped;
        }
    }

    class DTableHeaderCellCheck {
        constructor(parent, options) {
            var _a, _b, _c;
            this._parent = parent;
            this._isEnabled = (_a = options === null || options === void 0 ? void 0 : options.enable) !== null && _a !== void 0 ? _a : false;
            this._isFilterable = (_b = options === null || options === void 0 ? void 0 : options.filterable) !== null && _b !== void 0 ? _b : true;
            this._isEmittable = (_c = options === null || options === void 0 ? void 0 : options.emittable) !== null && _c !== void 0 ? _c : true;
        }
        get isEnabled() {
            return this._isEnabled;
        }
        get isFilterable() {
            return this._isFilterable;
        }
        set isFilterable(isFilterable) {
            this._isFilterable = isFilterable;
        }
        get isEmittable() {
            return this._isEmittable;
        }
        set isEmittable(isEmittable) {
            this._isEmittable = isEmittable;
        }
        newIteratee(table, isChecked) {
            const parent = this._parent;
            const column = parent.column;
            const columnIndex = parent.columnIndex;
            if (column != null && columnIndex != null) {
                const getter = column.getter;
                const setter = column.setter;
                if (this._isEmittable) {
                    const data = table.data;
                    return (row, rowIndex) => {
                        if (getter(row, columnIndex) !== isChecked) {
                            setter(row, columnIndex, isChecked);
                            data.emit("change", isChecked, !isChecked, row, rowIndex, columnIndex, data);
                            return true;
                        }
                        return false;
                    };
                }
                else {
                    return (row) => {
                        if (getter(row, columnIndex) !== isChecked) {
                            setter(row, columnIndex, isChecked);
                            return true;
                        }
                        return false;
                    };
                }
            }
            return null;
        }
        execute(isChecked) {
            var _a;
            const table = (_a = this._parent.header) === null || _a === void 0 ? void 0 : _a.table;
            if (table) {
                const iteratee = this.newIteratee(table, isChecked);
                if (iteratee) {
                    let isChanged = false;
                    if (this._isFilterable) {
                        table.data.mapped.each((row, supplimental, index, unmappedIndex) => {
                            if (iteratee(row, unmappedIndex)) {
                                isChanged = true;
                            }
                        });
                    }
                    else {
                        table.data.each((row, index) => {
                            if (iteratee(row, index)) {
                                isChanged = true;
                            }
                        });
                    }
                    if (isChanged) {
                        table.body.update(true);
                    }
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableHeaderCell extends DImage {
        constructor(header, columnIndex, column, options) {
            super(options);
            this._header = header;
            this._column = column;
            this._columnIndex = columnIndex;
            const check = new DTableHeaderCellCheck(this, options === null || options === void 0 ? void 0 : options.check);
            this._check = check;
            this._edge = new DTableCellEdge(this._header, this, columnIndex, this.theme.getEdgeWidth());
            const sortable = column.sorting.enable;
            const checkable = check.isEnabled;
            if (checkable || sortable) {
                this.on(UtilPointerEvent.tap, (e) => {
                    this.onClick(e);
                });
                const state = this.state;
                state.lock();
                state.set(DTableState.SORTABLE, sortable);
                state.set(DTableState.CHECKABLE, checkable);
                state.unlock();
            }
        }
        get column() {
            return this._column;
        }
        get columnIndex() {
            return this._columnIndex;
        }
        get header() {
            return this._header;
        }
        get check() {
            return this._check;
        }
        onDown(e) {
            if (!this._edge.onDown(e)) {
                super.onDown(e);
            }
        }
        onOver(e) {
            super.onOver(e);
            this._edge.onOver(e);
        }
        onOut(e) {
            super.onOut(e);
            this._edge.onOut(e);
        }
        get sorter() {
            let sorter = this._sorter;
            if (sorter == null) {
                const header = this._header;
                if (header) {
                    const table = header.table;
                    if (table) {
                        sorter = table.data.sorter;
                        this._sorter = sorter;
                        this._onSorterChangeBound =
                            this._onSorterChangeBound ||
                                (() => {
                                    this.onSorterChange();
                                });
                        sorter.on("change", this._onSorterChangeBound);
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
            return sorter;
        }
        get comparator() {
            return this._column.sorting.comparator || null;
        }
        onSorterChange() {
            const comparator = this.comparator;
            if (comparator) {
                const sorter = this._sorter;
                if (sorter) {
                    const SORTED_ASCENDING = DTableState.SORTED_ASCENDING;
                    const SORTED_DESCENDING = DTableState.SORTED_DESCENDING;
                    if (sorter.isApplied() && sorter.get() === comparator) {
                        if (sorter.order === DTableDataOrder.ASCENDING) {
                            this.state.set(SORTED_ASCENDING, SORTED_DESCENDING);
                        }
                        else {
                            this.state.set(SORTED_DESCENDING, SORTED_ASCENDING);
                        }
                    }
                    else {
                        this.state.removeAll(SORTED_ASCENDING, SORTED_DESCENDING);
                    }
                }
            }
        }
        toClickPosition(e) {
            var _a;
            const checkWork = ((_a = this._checkWork) !== null && _a !== void 0 ? _a : (this._checkWork = new pixi_js.Point()));
            return e.data.getLocalPosition(this, checkWork).x;
        }
        isCheckClicked(e) {
            if (e instanceof pixi_js.InteractionEvent && this._check.isEnabled) {
                if (this.isSortable) {
                    const image = this.image.get(1);
                    if (image) {
                        const position = this.toClickPosition(e);
                        const object = image.object;
                        if (object != null) {
                            const bound = object.getLocalBounds();
                            const margin = image.margin.horizontal;
                            const x = object.x;
                            return (x + bound.left - margin <= position &&
                                position <= x + bound.right + margin);
                        }
                    }
                }
                else {
                    return true;
                }
            }
            return false;
        }
        onClick(e) {
            if (this.state.isActionable) {
                this.activate(e);
            }
        }
        activate(e) {
            this.onActivate(e);
        }
        onActivate(e) {
            if (!this._edge.isClicked(e)) {
                if (this.isCheckClicked(e)) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
                else {
                    this.doSort(e);
                    this.emit("active", this);
                }
            }
        }
        doSort(e) {
            if (this.isSortable) {
                const comparator = this.comparator;
                if (comparator) {
                    const sorter = this.sorter;
                    if (sorter) {
                        if (sorter.get() === comparator) {
                            if (sorter.order === DTableDataOrder.ASCENDING) {
                                sorter.order = DTableDataOrder.DESCENDING;
                                sorter.apply();
                            }
                            else {
                                sorter.set(null);
                                sorter.apply();
                            }
                        }
                        else {
                            sorter.set(comparator);
                            sorter.order = DTableDataOrder.ASCENDING;
                            sorter.apply();
                        }
                    }
                }
            }
        }
        get isSortable() {
            return this._column.sorting.enable;
        }
        get isResizable() {
            return this._column.resizable;
        }
        get isToggle() {
            return this._check.isEnabled;
        }
        toggle() {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleStart();
                    this.onToggleEnd();
                }
            }
        }
        onToggleStart() {
            this.state.isActive = !this.state.isActive;
        }
        onToggleEnd() {
            if (this.state.isActive) {
                this._check.execute(true);
                this.emit("active", this);
            }
            else {
                this._check.execute(false);
                this.emit("inactive", this);
            }
        }
        onActivateKeyDown(e) {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleStart();
                }
                else {
                    this.state.isPressed = true;
                }
            }
        }
        onActivateKeyUp(e) {
            if (this.state.isActionable) {
                if (this.isToggle) {
                    this.onToggleEnd();
                }
                else {
                    if (this.state.isPressed) {
                        this.activate(e);
                    }
                    this.state.isPressed = false;
                }
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return super.onKeyDown(e);
        }
        onKeyUp(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return super.onKeyUp(e);
        }
        getType() {
            return "DTableHeaderCell";
        }
        destroy() {
            const sorter = this._sorter;
            const onSorterChangeBound = this._onSorterChangeBound;
            if (sorter && onSorterChangeBound) {
                sorter.off("change", onSorterChangeBound);
            }
            this._sorter = undefined;
            this._onSorterChangeBound = undefined;
            super.destroy();
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTableHeader extends DTableRow {
        constructor(table, columns, frozen, offset, options) {
            super(columns, frozen, options);
            this._table = table;
            this._offset = offset;
            this.transform.position.y = offset;
            this.initCells();
        }
        get table() {
            return this._table;
        }
        onParentMove(newX, newY, oldX, oldY) {
            super.onParentMove(newX, newY, oldX, oldY);
            this.transform.position.y = -newY + this._offset;
            this.updateFrozenCellPosition(newX);
        }
        getContentPositionX() {
            const content = this.parent;
            if (content) {
                return content.position.x;
            }
            return 0;
        }
        newCell(columnIndex, column, columns, options) {
            return new DTableHeaderCell(this, columnIndex, column, this.toCellOptions(column, options));
        }
        toCellOptions(column, options) {
            const result = column.header || (options === null || options === void 0 ? void 0 : options.cell);
            if (result != null) {
                if (result.weight === undefined) {
                    result.weight = column.weight;
                }
                if (result.width === undefined) {
                    result.width = column.width;
                }
                if (result.text === undefined) {
                    result.text = {
                        value: column.label
                    };
                }
                else if (result.text.value === undefined) {
                    result.text.value = column.label;
                }
                return result;
            }
            else {
                return {
                    weight: column.weight,
                    width: column.width,
                    text: {
                        value: column.label
                    }
                };
            }
        }
        getType() {
            return "DTableHeader";
        }
    }

    class DTableScrollBar extends DPaneScrollBar {
        getOffsetVerticalStart(size) {
            return size * 0.5 + this._parent.body.position.y;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTable extends DPane {
        constructor(options) {
            super(options);
            const content = this.content;
            const body = this.body;
            content.addChild(body);
            if (body.data.selection.type !== DTableDataSelectionType.NONE) {
                this.on(UtilPointerEvent.tap, (e) => {
                    body.onRowClick(e);
                });
            }
            const header = this.header;
            if (header) {
                content.addChild(header);
            }
            const categories = this.categories;
            for (let i = categories.length - 1; 0 <= i; --i) {
                content.addChild(categories[i]);
            }
            body.update();
        }
        get column() {
            var _a;
            return ((_a = this._column) !== null && _a !== void 0 ? _a : (this._column = this.newColumn()));
        }
        newColumn() {
            var _a;
            return new DTableColumnContainerImpl(this, (_a = this._options) === null || _a === void 0 ? void 0 : _a.columns);
        }
        get columns() {
            return this.column.items;
        }
        get frozen() {
            return this.column.frozen;
        }
        get category() {
            var _a;
            return ((_a = this._category) !== null && _a !== void 0 ? _a : (this._category = this.newCategory()));
        }
        newCategory() {
            var _a;
            const column = this.column;
            return new DTableCategoryContainerImpl(column.items, column.frozen, (_a = this._options) === null || _a === void 0 ? void 0 : _a.category);
        }
        get categories() {
            return this.category.items;
        }
        initContent(content) {
            super.initContent(content);
            content.state.isFocusReverse = true;
        }
        onContentChange() {
            super.onContentChange();
            this.body.update();
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            const scrollbar = this.scrollbar;
            scrollbar.lock();
            const body = this.body;
            body.lock();
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
            body.update();
            body.unlock(true);
            scrollbar.unlock(true);
        }
        onDblClick(e, interactionManager) {
            const result = this.body.onDblClick(e, interactionManager);
            return super.onDblClick(e, interactionManager) || result;
        }
        newScrollBar(options) {
            return new DTableScrollBar(this, options, (isRegionVisible) => {
                this.onScrollBarUpdate(isRegionVisible);
            });
        }
        newContent(options) {
            const result = super.newContent(options);
            // X & Width
            const column = this.column;
            let columnWidth = column.width;
            if (0 < columnWidth) {
                column.on("resize", () => {
                    columnWidth = column.width;
                    const parentWidth = this.width;
                    const parentHeight = this.height;
                    const newWidth = Math.max(parentWidth, columnWidth);
                    const newXMin = parentWidth - newWidth;
                    // The X position must be in [newXMin, 0].
                    if (result.x < newXMin) {
                        result.x = newXMin;
                    }
                    // Force the with reevaluated
                    result.onParentResize(parentWidth, parentHeight, this.padding);
                });
                result.setWidth((p) => {
                    return Math.max(p, columnWidth);
                });
            }
            else {
                result.setWidth("100%");
            }
            // Done
            return result;
        }
        getHeaderOffset() {
            let result = this._headerOffset;
            if (result == null) {
                result = this.newHeaderOffset();
                this._headerOffset = result;
            }
            return result;
        }
        newHeaderOffset() {
            let result = 0;
            const categories = this.categories;
            for (let i = 0, imax = categories.length; i < imax; ++i) {
                result += categories[i].height;
            }
            return result;
        }
        get header() {
            let result = this._header;
            if (result === undefined) {
                result = this.newHeader();
                this._header = result;
            }
            return result;
        }
        hasHeader(options) {
            if (options) {
                const columns = options.columns;
                for (let i = 0, imax = columns.length; i < imax; ++i) {
                    if (columns[i].label != null) {
                        return true;
                    }
                }
            }
            return false;
        }
        newHeader() {
            const options = this._options;
            if (this.hasHeader(options)) {
                const column = this.column;
                return new DTableHeader(this, column.items, column.frozen, this.getHeaderOffset(), options === null || options === void 0 ? void 0 : options.header);
            }
            return null;
        }
        getBodyOffset() {
            var _a;
            return ((_a = this._bodyOffset) !== null && _a !== void 0 ? _a : (this._bodyOffset = this.newBodyOffset()));
        }
        newBodyOffset() {
            var _a, _b;
            return this.getHeaderOffset() + ((_b = (_a = this.header) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0);
        }
        get body() {
            var _a;
            return ((_a = this._body) !== null && _a !== void 0 ? _a : (this._body = this.newBody()));
        }
        newBody() {
            const options = this._options;
            const column = this.column;
            return new DTableBody(column.items, column.frozen, this.getBodyOffset(), this.toBodyOptions(options === null || options === void 0 ? void 0 : options.body, options === null || options === void 0 ? void 0 : options.data));
        }
        toBodyOptions(options, data) {
            if (options != null) {
                if (options.data === undefined && data !== undefined) {
                    if (isArray(data)) {
                        options.data = {
                            rows: data
                        };
                    }
                    else {
                        options.data = data;
                    }
                }
                if (options.height === undefined && options.weight === undefined) {
                    options.weight = 1;
                }
                return options;
            }
            if (isArray(data)) {
                return {
                    data: {
                        rows: data
                    },
                    weight: 1
                };
            }
            else {
                return {
                    data,
                    weight: 1
                };
            }
        }
        get data() {
            return this.body.data;
        }
        getFocusedChildClippingRect(focused, contentX, contentY, contentWidth, contentHeight, width, height, result) {
            super.getFocusedChildClippingRect(focused, contentX, contentY, contentWidth, contentHeight, width, height, result);
            const cell = this.toCell(focused);
            if (cell) {
                // X
                const dx = contentX + this.toFrozenCellX(cell) - result.x;
                if (0 < dx) {
                    result.x += dx;
                    result.width -= dx;
                }
                // Y
                if (cell.parent.parent === this.body) {
                    const dy = this.getBodyOffset();
                    result.y += dy;
                    result.height -= dy;
                }
            }
            // Done
            return result;
        }
        toFrozenCellX(cell) {
            const frozen = this.frozen;
            if (0 < frozen) {
                const cells = cell.parent.children;
                const cellIndex = cells.indexOf(cell);
                if (0 <= cellIndex) {
                    const cellsLength = cells.length;
                    const columnIndex = cellsLength - 1 - cellIndex;
                    if (frozen <= columnIndex) {
                        const cellFrozen = cells[cellsLength - frozen];
                        return cellFrozen.position.x + cellFrozen.width;
                    }
                }
            }
            return 0;
        }
        onKeyDown(e) {
            UtilKeyboardEvent.moveFocusHorizontally(e, this);
            const isArrowUpKey = UtilKeyboardEvent.isArrowUpKey(e);
            const isArrowDownKey = UtilKeyboardEvent.isArrowDownKey(e);
            if (isArrowUpKey || isArrowDownKey) {
                this.onKeyDownArrowUpOrDown(e, isArrowDownKey);
            }
            return super.onKeyDown(e);
        }
        onKeyDownArrowUpOrDown(e, isDown) {
            const layer = DApplications.getLayer(this);
            if (layer == null) {
                return false;
            }
            const focusController = layer.getFocusController();
            const oldFocusable = focusController.get();
            if (oldFocusable == null) {
                return false;
            }
            const oldCell = this.toCell(oldFocusable);
            if (oldCell == null) {
                return false;
            }
            const oldRow = oldCell.parent;
            if (oldRow == null) {
                return false;
            }
            const newRowChild = focusController.find(oldRow, false, false, isDown, this);
            if (newRowChild == null) {
                return false;
            }
            const newCellSibling = this.toCell(newRowChild);
            if (newCellSibling == null) {
                return false;
            }
            const newRow = newCellSibling.parent;
            if (newRow == null) {
                return false;
            }
            const oldCellIndex = oldRow.children.indexOf(oldCell);
            if (oldCellIndex < 0) {
                return false;
            }
            const newCell = newRow.children[oldCellIndex];
            if (newCell == null || newCell === oldCell || !("state" in newCell)) {
                return false;
            }
            const newFocusable = focusController.find(newCell, true, true, isDown, this);
            if (newFocusable == null) {
                return false;
            }
            focusController.focus(newFocusable);
            return true;
        }
        toCell(focused) {
            let current = focused;
            while (current != null) {
                const parent = current.parent;
                if (parent instanceof DTableRow) {
                    if (current instanceof DBase) {
                        return current;
                    }
                    return null;
                }
                current = parent;
            }
            return null;
        }
        getType() {
            return "DTable";
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const toLabel = (item) => {
        const text = item.text;
        if (isString(text)) {
            return text;
        }
        const label = item.label;
        if (isString(label)) {
            return label;
        }
        const name = item.name;
        if (isString(name)) {
            return name;
        }
        return undefined;
    };
    const toTitle = (item) => {
        const title = item.title;
        if (isString(title)) {
            return title;
        }
        return undefined;
    };
    const toImage = (item) => {
        return item.image;
    };
    const toChildren = (item) => {
        return item.children;
    };
    const newChildren = (item) => {
        return (item.children = []);
    };
    class DTreeNodeAccessorImpl {
        constructor(options) {
            var _a, _b, _c, _d, _e;
            this.toLabel = (_a = options === null || options === void 0 ? void 0 : options.toLabel) !== null && _a !== void 0 ? _a : toLabel;
            this.toTitle = (_b = options === null || options === void 0 ? void 0 : options.toTitle) !== null && _b !== void 0 ? _b : toTitle;
            this.toImage = (_c = options === null || options === void 0 ? void 0 : options.toImage) !== null && _c !== void 0 ? _c : toImage;
            this.toChildren = (_d = options === null || options === void 0 ? void 0 : options.toChildren) !== null && _d !== void 0 ? _d : toChildren;
            this.newChildren = (_e = options === null || options === void 0 ? void 0 : options.newChildren) !== null && _e !== void 0 ? _e : newChildren;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * {@link DTreeDataSelection} type.
     */
    const DTreeDataSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTreeDataMappedImpl {
        constructor(parent, reverse) {
            this._parent = parent;
            this._nodes = [];
            this._levels = [];
            this._reverse = reverse;
            this._isDirty = false;
        }
        get nodes() {
            this.update();
            return this._nodes;
        }
        get levels() {
            this.update();
            return this._levels;
        }
        toDirty() {
            this._isDirty = true;
        }
        size() {
            this.update();
            return this._nodes.length;
        }
        each(iteratee, from, to) {
            this.update();
            const nodes = this._nodes;
            const ifrom = from != null ? Math.max(0, from) : 0;
            const ito = to != null ? Math.min(nodes.length, to) : nodes.length;
            for (let i = ifrom; i < ito; ++i) {
                if (iteratee(nodes[i], i) === false) {
                    break;
                }
            }
        }
        update() {
            if (this._isDirty) {
                this._isDirty = false;
                const parent = this._parent;
                const parentNodes = parent.nodes;
                const toChildren = parent.accessor.toChildren;
                const nodes = this._nodes;
                const levels = this._levels;
                const size = this.newNodes(parent, parentNodes, 0, 0, nodes, levels, this._reverse, toChildren);
                if (nodes.length !== size) {
                    nodes.length = size;
                    levels.length = size;
                }
            }
        }
        newNodes(parent, parentNodes, index, level, nodes, levels, reverse, toChildren) {
            const parentNodesLength = parentNodes.length;
            const istart = reverse ? parentNodesLength - 1 : 0;
            const idelta = reverse ? -1 : +1;
            for (let i = istart; 0 <= i && i < parentNodesLength; i += idelta) {
                const parentNode = parentNodes[i];
                if (index < nodes.length) {
                    nodes[index] = parentNode;
                    levels[index] = level;
                }
                else {
                    nodes.push(parentNode);
                    levels.push(level);
                }
                index += 1;
                const children = toChildren(parentNode);
                if (children && parent.isExpanded(parentNode)) {
                    index = this.newNodes(parent, children, index, level + 1, nodes, levels, reverse, toChildren);
                }
            }
            return index;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTreeDataSelectionMultiple extends pixi_js.utils.EventEmitter {
        constructor(parent, options) {
            super();
            this._parent = parent;
            this._nodes = new Set();
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        get type() {
            return DTreeDataSelectionType.MULTIPLE;
        }
        get first() {
            const nodes = this._nodes;
            if (0 < nodes.size) {
                let result = null;
                nodes.forEach((item) => {
                    if (result == null) {
                        result = item;
                    }
                });
                return result;
            }
            return null;
        }
        get last() {
            const nodes = this._nodes;
            if (0 < nodes.size) {
                let result = null;
                nodes.forEach((row) => {
                    result = row;
                });
                return result;
            }
            return null;
        }
        get(index) {
            const nodes = this._nodes;
            if (0 <= index && index < nodes.size) {
                let counter = 0;
                let result = null;
                nodes.forEach((node) => {
                    if (counter === index) {
                        result = node;
                    }
                    counter += 1;
                });
                return result;
            }
            return null;
        }
        add(target) {
            const nodes = this._nodes;
            if (!nodes.has(target)) {
                nodes.add(target);
                this.onChange();
                return true;
            }
            return false;
        }
        remove(target) {
            const nodes = this._nodes;
            if (nodes.has(target)) {
                nodes.delete(target);
                this.onChange();
                return true;
            }
            return false;
        }
        toggle(target) {
            const nodes = this._nodes;
            if (nodes.has(target)) {
                nodes.delete(target);
            }
            else {
                nodes.add(target);
            }
            this.onChange();
            return true;
        }
        clear() {
            const nodes = this._nodes;
            if (0 < nodes.size) {
                nodes.clear();
                this.onChange();
                return true;
            }
            return false;
        }
        clearAndAdd(target) {
            const nodes = this._nodes;
            const size = nodes.size;
            if (size === 1) {
                if (nodes.has(target)) {
                    return false;
                }
                else {
                    nodes.clear();
                    nodes.add(target);
                    this.onChange();
                    return true;
                }
            }
            else {
                nodes.clear();
                nodes.add(target);
                this.onChange();
                return true;
            }
        }
        clearAndAddAll(targets) {
            let isDirty = false;
            const newNodes = new Set();
            const oldNodes = this._nodes;
            for (let i = 0, imax = targets.length; i < imax; ++i) {
                const target = targets[i];
                if (!oldNodes.has(target)) {
                    isDirty = true;
                }
                newNodes.add(target);
            }
            if (!isDirty) {
                oldNodes.forEach((oldItem) => {
                    if (!newNodes.has(oldItem)) {
                        isDirty = true;
                    }
                });
            }
            if (isDirty) {
                this._nodes = newNodes;
                this.onChange();
            }
            return isDirty;
        }
        contains(target) {
            return this._nodes.has(target);
        }
        size() {
            return this._nodes.size;
        }
        isEmpty() {
            return this._nodes.size <= 0;
        }
        each(iteratee) {
            let isCanceled = false;
            this._nodes.forEach((item) => {
                if (!isCanceled) {
                    if (iteratee(item) === false) {
                        isCanceled = true;
                    }
                }
            });
        }
        toArray() {
            const result = [];
            this._nodes.forEach((item) => {
                result.push(item);
            });
            return result;
        }
        onChange() {
            this._parent.update();
            this.emit("change", this);
        }
        onNodeChange(nodes) {
            const oldNodes = this._nodes;
            if (0 < oldNodes.size) {
                const newNodes = this.newNodes(nodes, oldNodes, new Set());
                if (oldNodes.size !== newNodes.size) {
                    this._nodes = newNodes;
                    this.onChange();
                }
            }
        }
        newNodes(items, existing, result) {
            const toChildren = this._parent.accessor.toChildren;
            for (let i = 0, imax = items.length; i < imax; ++i) {
                const item = items[i];
                if (existing.has(item)) {
                    result.add(item);
                }
                const children = toChildren(item);
                if (children) {
                    this.newNodes(children, existing, result);
                }
            }
            return result;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTreeDataSelectionSingle extends pixi_js.utils.EventEmitter {
        constructor(parent, options) {
            super();
            this._parent = parent;
            this._node = null;
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        get type() {
            return DTreeDataSelectionType.SINGLE;
        }
        get first() {
            return this._node;
        }
        get last() {
            return this._node;
        }
        get(index) {
            if (index === 0) {
                return this._node;
            }
            return null;
        }
        add(target) {
            if (this._node !== target) {
                this._node = target;
                this.onChange();
                return true;
            }
            return false;
        }
        remove(target) {
            if (this._node === target) {
                this._node = null;
                this.onChange();
                return true;
            }
            return false;
        }
        toggle(target) {
            if (this._node === target) {
                this._node = null;
            }
            else {
                this._node = target;
            }
            this.onChange();
            return true;
        }
        clear() {
            if (this._node != null) {
                this._node = null;
                this.onChange();
                return true;
            }
            return false;
        }
        clearAndAdd(target) {
            if (this._node === target) {
                return false;
            }
            else {
                this._node = target;
                this.onChange();
                return true;
            }
        }
        clearAndAddAll(targets) {
            if (0 < targets.length) {
                const last = targets[targets.length - 1];
                return this.clearAndAdd(last);
            }
            else {
                return this.clear();
            }
        }
        contains(target) {
            return this._node === target;
        }
        size() {
            return this._node != null ? 1 : 0;
        }
        isEmpty() {
            return this._node == null;
        }
        each(iteratee) {
            const node = this._node;
            if (node != null) {
                iteratee(node);
            }
        }
        toArray() {
            const node = this._node;
            if (node != null) {
                return [node];
            }
            return [];
        }
        onChange() {
            this._parent.update();
            this.emit("change", this);
        }
        onNodeChange(nodes) {
            const oldNode = this._node;
            if (oldNode != null) {
                const newNode = this.newNode(nodes, oldNode);
                if (oldNode !== newNode) {
                    this._node = newNode;
                    this.onChange();
                }
            }
        }
        newNode(items, existing) {
            const toChildren = this._parent.accessor.toChildren;
            for (let i = 0, imax = items.length; i < imax; ++i) {
                const item = items[i];
                if (existing === item) {
                    return item;
                }
                const children = toChildren(item);
                if (children) {
                    const result = this.newNode(children, existing);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTreeDataSelectionNone extends pixi_js.utils.EventEmitter {
        constructor(parent, options) {
            super();
            this._parent = parent;
            // Events
            const on = options === null || options === void 0 ? void 0 : options.on;
            if (on) {
                for (const name in on) {
                    const handler = on[name];
                    if (handler) {
                        this.on(name, handler);
                    }
                }
            }
        }
        get type() {
            return DTreeDataSelectionType.NONE;
        }
        get first() {
            return null;
        }
        get last() {
            return null;
        }
        get(index) {
            return null;
        }
        add(target) {
            return false;
        }
        remove(target) {
            return false;
        }
        toggle(target) {
            return false;
        }
        clear() {
            return false;
        }
        clearAndAdd(target) {
            return false;
        }
        clearAndAddAll(targets) {
            return false;
        }
        contains(target) {
            return false;
        }
        size() {
            return 0;
        }
        isEmpty() {
            return true;
        }
        each(iteratee) {
            // DO NOTHING
        }
        toArray() {
            return [];
        }
        onNodeChange(nodes) {
            // DO NOTHING
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTreeDataImpl {
        constructor(parent, options) {
            this._parent = parent;
            this._nodeToFlag = new WeakMap();
            this._selection = this.toSelection(options);
            this._accessor = new DTreeNodeAccessorImpl(options);
            const mapped = new DTreeDataMappedImpl(this, !!(options === null || options === void 0 ? void 0 : options.reverse));
            this._mapped = mapped;
            const nodes = options === null || options === void 0 ? void 0 : options.nodes;
            if (nodes != null) {
                this._nodes = nodes;
                mapped.toDirty();
            }
            else {
                this._nodes = [];
            }
        }
        toSelection(options) {
            const selection = options === null || options === void 0 ? void 0 : options.selection;
            switch (selection === null || selection === void 0 ? void 0 : selection.type) {
                case DTreeDataSelectionType.NONE:
                case "NONE":
                    return new DTreeDataSelectionNone(this, selection);
                case DTreeDataSelectionType.MULTIPLE:
                case "MULTIPLE":
                    return new DTreeDataSelectionMultiple(this, selection);
                default:
                    return new DTreeDataSelectionSingle(this, selection);
            }
        }
        get nodes() {
            return this._nodes;
        }
        set nodes(nodes) {
            this._nodes = nodes;
            this.update(true);
        }
        get mapped() {
            return this._mapped;
        }
        get accessor() {
            return this._accessor;
        }
        get selection() {
            return this._selection;
        }
        update(forcibly) {
            if (forcibly) {
                this._mapped.toDirty();
                this._selection.onNodeChange(this._nodes);
            }
            this._parent.update(forcibly);
        }
        toggle(target) {
            const nodeToFlag = this._nodeToFlag;
            if (nodeToFlag.has(target)) {
                nodeToFlag.delete(target);
            }
            else {
                nodeToFlag.set(target, 1);
            }
            this._mapped.toDirty();
            this.update();
            return true;
        }
        expand(target) {
            const nodeToFlag = this._nodeToFlag;
            if (!nodeToFlag.has(target)) {
                nodeToFlag.set(target, 1);
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        }
        collapse(target) {
            const nodeToFlag = this._nodeToFlag;
            if (nodeToFlag.has(target)) {
                nodeToFlag.delete(target);
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        }
        expandAll() {
            let isDirty = false;
            const nodeToFlag = this._nodeToFlag;
            this.each((node) => {
                if (!nodeToFlag.has(node)) {
                    nodeToFlag.set(node, 1);
                    isDirty = true;
                }
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        }
        collapseAll() {
            let isDirty = false;
            const nodeToFlag = this._nodeToFlag;
            this.each((node) => {
                if (nodeToFlag.has(node)) {
                    nodeToFlag.delete(node);
                    isDirty = true;
                }
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
                return true;
            }
            return false;
        }
        isCollapsed(target) {
            return !this.isExpanded(target);
        }
        isExpanded(target) {
            return this._nodeToFlag.has(target);
        }
        clear() {
            const nodes = this._nodes;
            if (0 < nodes.length) {
                nodes.length = 0;
                this._mapped.toDirty();
                this._selection.clear();
                this.update();
                return true;
            }
            return false;
        }
        remove(target) {
            let isDirty = false;
            this.each((node, index, nodes) => {
                if (node === target) {
                    nodes.splice(index, 1);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this._selection.remove(target);
                this.update();
                return true;
            }
            return false;
        }
        add(target, parent) {
            let isDirty = false;
            if (parent) {
                const accessor = this._accessor;
                const children = accessor.toChildren(parent);
                if (children) {
                    children.push(target);
                    isDirty = true;
                }
                else {
                    const newChildren = accessor.newChildren(parent);
                    if (newChildren) {
                        newChildren.push(target);
                        isDirty = true;
                    }
                }
            }
            else {
                const nodes = this._nodes;
                if (nodes) {
                    nodes.push(target);
                }
                else {
                    this._nodes = [target];
                }
                isDirty = true;
            }
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return true;
        }
        addBefore(target, sibling) {
            let isDirty = false;
            this.each((node, index, nodes) => {
                if (node === sibling) {
                    nodes.splice(index, 0, target);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return isDirty;
        }
        addAfter(target, sibling) {
            let isDirty = false;
            this.each((node, index, nodes) => {
                if (node === sibling) {
                    nodes.splice(index + 1, 0, target);
                    isDirty = true;
                    return false;
                }
                return true;
            });
            if (isDirty) {
                this._mapped.toDirty();
                this.update();
            }
            return isDirty;
        }
        each(iteratee) {
            const value = this._nodes;
            if (value) {
                this.each_(value, null, iteratee);
            }
        }
        each_(nodes, parent, iteratee) {
            const toChildren = this._accessor.toChildren;
            for (let i = 0, imax = nodes.length; i < imax; ++i) {
                const node = nodes[i];
                if (iteratee(node, i, nodes, parent) === false) {
                    return;
                }
                const children = toChildren(node);
                if (children) {
                    this.each_(children, node, iteratee);
                }
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    /**
     * Tree item states.
     */
    const DTreeItemState = {
        /**
         * A node has children.
         */
        HAS_CHILDREN: "HAS_CHILDREN",
        /**
         * A node is opened.
         */
        OPENED: "OPENED"
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTreeItemText extends DImageBase {
        constructor(data, options) {
            super(options);
            this._data = data;
        }
        newPadding(theme, options, callback) {
            return new DBasePaddingAdjustable(theme, options, callback);
        }
        get node() {
            return this._node;
        }
        get value() {
            return this._node;
        }
        get index() {
            return this._index;
        }
        get data() {
            return this._data;
        }
        toggle() {
            const node = this._node;
            if (node !== undefined) {
                this._data.toggle(node);
            }
        }
        set(node, index, forcibly) {
            var _a;
            const data = this._data;
            const isNodeChanged = forcibly || this._node !== node;
            if (isNodeChanged) {
                this._node = node;
                this._index = index;
                const accessor = data.accessor;
                this.text = accessor.toLabel(node);
                this.title = (_a = accessor.toTitle(node)) !== null && _a !== void 0 ? _a : "";
                this.image = accessor.toImage(node);
            }
            const level = data.mapped.levels[index];
            this._padding.adjLeft(this.theme.getLevelPadding(level));
            const children = data.accessor.toChildren(node);
            const hasChildren = !!(children && 0 < children.length);
            const state = this.state;
            state.lock();
            state.set(DBaseState.ACTIVE, data.selection.contains(node));
            state.remove(DBaseState.DISABLED);
            state.set(DTreeItemState.HAS_CHILDREN, hasChildren);
            state.set(DTreeItemState.OPENED, data.isExpanded(node));
            state.unlock();
            if (isNodeChanged) {
                this.emit("set", node, index, this);
            }
        }
        unset() {
            if (this._node !== undefined) {
                this._node = undefined;
                this._index = undefined;
                this.text = undefined;
                this.title = "";
                this.image = undefined;
                const state = this.state;
                state.lock();
                state.add(DBaseState.DISABLED);
                state.remove(DBaseState.ACTIVE);
                state.unlock();
                this.emit("unset", this);
            }
        }
        onSelect(e, value) {
            const data = this._data;
            const selection = data.selection;
            if (selection.type !== DTreeDataSelectionType.MULTIPLE) {
                selection.clearAndAdd(value);
            }
            else {
                const originalEvent = e && "data" in e ? e.data.originalEvent : e;
                if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.ctrlKey) {
                    selection.toggle(value);
                }
                else if (originalEvent === null || originalEvent === void 0 ? void 0 : originalEvent.shiftKey) {
                    const mapped = data.mapped;
                    const last = selection.last;
                    if (value === last) {
                        selection.clearAndAdd(value);
                    }
                    else {
                        let isFound = false;
                        let isReverse = false;
                        const newSelection = [];
                        mapped.each((node) => {
                            if (isFound) {
                                if (isReverse) {
                                    newSelection.unshift(node);
                                    if (node === value) {
                                        return false;
                                    }
                                }
                                else {
                                    newSelection.push(node);
                                    if (node === last) {
                                        return false;
                                    }
                                }
                            }
                            else {
                                if (node === value) {
                                    isFound = true;
                                    isReverse = false;
                                    newSelection.push(node);
                                }
                                else if (node === last) {
                                    isFound = true;
                                    isReverse = true;
                                    newSelection.push(node);
                                }
                            }
                        });
                        selection.clearAndAddAll(newSelection);
                    }
                }
                else {
                    selection.clearAndAdd(value);
                }
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onKeyDownActivate(e);
            }
            if (UtilKeyboardEvent.isArrowRightKey(e)) {
                const node = this._node;
                if (node !== undefined) {
                    if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                        this._data.expand(node);
                    }
                }
            }
            if (UtilKeyboardEvent.isArrowLeftKey(e)) {
                const node = this._node;
                if (node !== undefined) {
                    if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                        this._data.collapse(node);
                    }
                }
            }
            return super.onKeyDown(e);
        }
        onKeyDownActivate(e) {
            if (this.state.isActionable && this.state.isFocused) {
                const node = this._node;
                if (node !== undefined) {
                    this.onSelect(e, node);
                }
                return true;
            }
            return false;
        }
        getType() {
            return "DTreeItemText";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTreeItemButton extends DTreeItemText {
        constructor(data, options) {
            var _a;
            super(data, options);
            this._when = toEnum((_a = options === null || options === void 0 ? void 0 : options.when) !== null && _a !== void 0 ? _a : DButtonBaseWhen.CLICKED, DButtonBaseWhen);
            this.on(UtilPointerEvent.tap, (e) => {
                this.onClick(e);
            });
        }
        onClick(e) {
            if (this._when === DButtonBaseWhen.CLICKED && this.state.isActionable) {
                this.activate(e);
            }
        }
        onDblClick(e, interactionManager) {
            if (this._when === DButtonBaseWhen.DOUBLE_CLICKED) {
                this.activate(e);
            }
            return super.onDblClick(e, interactionManager);
        }
        activate(e) {
            this.onActivate(e);
        }
        onActivate(e) {
            this.emit("active", this);
        }
        onActivateKeyDown(e) {
            if (this.state.isActionable) {
                this.state.isPressed = true;
            }
        }
        onActivateKeyUp(e) {
            if (this.state.isActionable) {
                if (this.state.isPressed) {
                    this.activate(e);
                }
                this.state.isPressed = false;
            }
        }
        onKeyDown(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyDown(e);
            }
            return super.onKeyDown(e);
        }
        onKeyUp(e) {
            if (UtilKeyboardEvent.isActivateKey(e)) {
                this.onActivateKeyUp(e);
            }
            return super.onKeyUp(e);
        }
        getType() {
            return "DTreeItemButton";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTreeItemNonEditable extends DTreeItemButton {
        onActivate(e) {
            super.onActivate(e);
            const node = this._node;
            if (node !== undefined) {
                if (this.state.is(DTreeItemState.HAS_CHILDREN)) {
                    if (e && "data" in e) {
                        const local = this.toLocal(e.data.global, undefined, DTreeItemNonEditable.WORK_CONTAINS_POINT);
                        if (local.x <= this.padding.getLeft()) {
                            this.toggle();
                        }
                        else {
                            this.onSelect(e, node);
                        }
                    }
                }
                else {
                    this.onSelect(e, node);
                }
            }
        }
        getType() {
            return "DTreeItemNonEditable";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTreeItemUpdater extends DItemUpdater {
        toMapped(data) {
            return data.mapped;
        }
        newItem(data) {
            return new DTreeItemNonEditable(data);
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class DTree extends DPane {
        constructor(options) {
            super(options);
            this.update();
        }
        onContentChange() {
            super.onContentChange();
            this.update();
        }
        onResize(newWidth, newHeight, oldWidth, oldHeight) {
            const updater = this.updater;
            updater.lock();
            super.onResize(newWidth, newHeight, oldWidth, oldHeight);
            updater.update();
            updater.unlock(true);
        }
        get updater() {
            let result = this._updater;
            if (result == null) {
                result = this.newUpdater(this.data, this.content, this._options);
                this._updater = result;
            }
            return result;
        }
        newUpdater(data, content, options) {
            return new DTreeItemUpdater(data, content, content, options === null || options === void 0 ? void 0 : options.updater);
        }
        get data() {
            let result = this._data;
            if (result == null) {
                result = this.toData(this._options);
                this._data = result;
            }
            return result;
        }
        toData(options) {
            const data = (options && (options.data || options.nodes || options.value)) || [];
            if (isArray(data)) {
                return new DTreeDataImpl(this, {
                    nodes: data
                });
            }
            else if ("add" in data) {
                return data;
            }
            else {
                return new DTreeDataImpl(this, data);
            }
        }
        update(forcibly) {
            this.updater.update(forcibly);
        }
        lock() {
            this.updater.lock();
        }
        unlock(callIfNeeded) {
            this.updater.unlock(callIfNeeded);
        }
        get selection() {
            return this.data.selection;
        }
        get value() {
            return this.data.nodes;
        }
        set value(value) {
            this.data.nodes = value;
        }
        get nodes() {
            return this.data.nodes;
        }
        set nodes(nodes) {
            this.data.nodes = nodes;
        }
        toggle(target) {
            return this.data.toggle(target);
        }
        expand(target) {
            return this.data.expand(target);
        }
        collapse(target) {
            return this.data.collapse(target);
        }
        expandAll() {
            return this.data.expandAll();
        }
        collapseAll() {
            return this.data.collapseAll();
        }
        isCollapsed(target) {
            return this.data.isCollapsed(target);
        }
        isExpanded(target) {
            return this.data.isExpanded(target);
        }
        clear() {
            return this.data.clear();
        }
        remove(target) {
            return this.data.remove(target);
        }
        add(target, parent) {
            return this.data.add(target, parent);
        }
        addBefore(target, sibling) {
            return this.data.addBefore(target, sibling);
        }
        addAfter(target, sibling) {
            return this.data.addAfter(target, sibling);
        }
        each(iteratee) {
            return this.data.each(iteratee);
        }
        onKeyDown(e) {
            this.updater.moveFocus(e, this, true, false);
            return super.onKeyDown(e);
        }
        getType() {
            return "DTree";
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */

    var ui = {
        __proto__: null,
        loadAll: loadAll,
        loadMenuItemAll: loadMenuItemAll,
        loadMenuItemExpandable: loadMenuItemExpandable,
        loadMenuItem: loadMenuItem,
        loadMenuSidedItemExpandable: loadMenuSidedItemExpandable,
        loadMenuSidedItem: loadMenuSidedItem,
        deserializeActionValue: deserializeActionValue,
        EShapeActionBases: EShapeActionBases,
        EShapeActionEnvironment: EShapeActionEnvironment,
        EShapeActionExpressions: EShapeActionExpressions,
        EShapeActionMiscExtensions: EShapeActionMiscExtensions,
        EShapeActionOpenDialogExtensions: EShapeActionOpenDialogExtensions,
        EShapeActionOpenExtensions: EShapeActionOpenExtensions,
        EShapeActionOpenOpeners: EShapeActionOpenOpeners,
        EShapeActionRuntimeBase: EShapeActionRuntimeBase,
        EShapeActionRuntimeBlinkBrighten: EShapeActionRuntimeBlinkBrighten,
        EShapeActionRuntimeBlinkColorFill: EShapeActionRuntimeBlinkColorFill,
        EShapeActionRuntimeBlinkColorStroke: EShapeActionRuntimeBlinkColorStroke,
        EShapeActionRuntimeBlinkDarken: EShapeActionRuntimeBlinkDarken,
        EShapeActionRuntimeBlinkOpacity: EShapeActionRuntimeBlinkOpacity,
        EShapeActionRuntimeBlinkVisibility: EShapeActionRuntimeBlinkVisibility,
        EShapeActionRuntimeBlink: EShapeActionRuntimeBlink,
        EShapeActionRuntimeChangeColorBrightness: EShapeActionRuntimeChangeColorBrightness,
        EShapeActionRuntimeChangeColorCode: EShapeActionRuntimeChangeColorCode,
        EShapeActionRuntimeChangeColor: EShapeActionRuntimeChangeColor,
        EShapeActionRuntimeChangeCursor: EShapeActionRuntimeChangeCursor,
        EShapeActionRuntimeChangeTextNumber: EShapeActionRuntimeChangeTextNumber,
        EShapeActionRuntimeChangeTextText: EShapeActionRuntimeChangeTextText,
        EShapeActionRuntimeConditional: EShapeActionRuntimeConditional,
        EShapeActionRuntimeEmitEvent: EShapeActionRuntimeEmitEvent,
        EShapeActionRuntimeGestureLayer: EShapeActionRuntimeGestureLayer,
        EShapeActionRuntimeGestureShape: EShapeActionRuntimeGestureShape,
        EShapeActionRuntimeMiscEmitEvent: EShapeActionRuntimeMiscEmitEvent,
        EShapeActionRuntimeMiscExecute: EShapeActionRuntimeMiscExecute,
        EShapeActionRuntimeMiscExtension: EShapeActionRuntimeMiscExtension,
        EShapeActionRuntimeMiscHtmlElement: EShapeActionRuntimeMiscHtmlElement,
        EShapeActionRuntimeMiscInputInput: EShapeActionRuntimeMiscInputInput,
        EShapeActionRuntimeMiscInputInteger: EShapeActionRuntimeMiscInputInteger,
        EShapeActionRuntimeMiscInputNumber: EShapeActionRuntimeMiscInputNumber,
        EShapeActionRuntimeMiscInputReal: EShapeActionRuntimeMiscInputReal,
        EShapeActionRuntimeMiscInputText: EShapeActionRuntimeMiscInputText,
        EShapeActionRuntimeMiscInput: EShapeActionRuntimeMiscInput,
        EShapeActionRuntimeMiscWriteBoth: EShapeActionRuntimeMiscWriteBoth,
        EShapeActionRuntimeMiscWriteLocal: EShapeActionRuntimeMiscWriteLocal,
        EShapeActionRuntimeMiscWriteRemote: EShapeActionRuntimeMiscWriteRemote,
        EShapeActionRuntimeMiscWrite: EShapeActionRuntimeMiscWrite,
        EShapeActionRuntimeOpenDialogBoolean: EShapeActionRuntimeOpenDialogBoolean,
        EShapeActionRuntimeOpenDialogDate: EShapeActionRuntimeOpenDialogDate,
        EShapeActionRuntimeOpenDialogDatetime: EShapeActionRuntimeOpenDialogDatetime,
        EShapeActionRuntimeOpenDialogExtension: EShapeActionRuntimeOpenDialogExtension,
        EShapeActionRuntimeOpenDialogInteger: EShapeActionRuntimeOpenDialogInteger,
        EShapeActionRuntimeOpenDialogReal: EShapeActionRuntimeOpenDialogReal,
        EShapeActionRuntimeOpenDialogText: EShapeActionRuntimeOpenDialogText,
        EShapeActionRuntimeOpenDialogTime: EShapeActionRuntimeOpenDialogTime,
        EShapeActionRuntimeOpenDialog: EShapeActionRuntimeOpenDialog,
        EShapeActionRuntimeOpen: EShapeActionRuntimeOpen,
        EShapeActionRuntimeShowHideLayer: EShapeActionRuntimeShowHideLayer,
        EShapeActionRuntimeShowHideShape: EShapeActionRuntimeShowHideShape,
        EShapeActionRuntimeShowHide: EShapeActionRuntimeShowHide,
        EShapeActionRuntimeTransformMoveAbsoluteX: EShapeActionRuntimeTransformMoveAbsoluteX,
        EShapeActionRuntimeTransformMoveAbsoluteY: EShapeActionRuntimeTransformMoveAbsoluteY,
        EShapeActionRuntimeTransformMoveForwardOrBackward: EShapeActionRuntimeTransformMoveForwardOrBackward,
        EShapeActionRuntimeTransformMoveLeftOrRight: EShapeActionRuntimeTransformMoveLeftOrRight,
        EShapeActionRuntimeTransformMoveRelativeX: EShapeActionRuntimeTransformMoveRelativeX,
        EShapeActionRuntimeTransformMoveRelativeY: EShapeActionRuntimeTransformMoveRelativeY,
        EShapeActionRuntimeTransformMove: EShapeActionRuntimeTransformMove,
        EShapeActionRuntimeTransformResizeHeightAbsolute: EShapeActionRuntimeTransformResizeHeightAbsolute,
        EShapeActionRuntimeTransformResizeHeightRelative: EShapeActionRuntimeTransformResizeHeightRelative,
        EShapeActionRuntimeTransformResizeSizeAbsolute: EShapeActionRuntimeTransformResizeSizeAbsolute,
        EShapeActionRuntimeTransformResizeSizeRelative: EShapeActionRuntimeTransformResizeSizeRelative,
        EShapeActionRuntimeTransformResizeWidthAbsolute: EShapeActionRuntimeTransformResizeWidthAbsolute,
        EShapeActionRuntimeTransformResizeWidthRelative: EShapeActionRuntimeTransformResizeWidthRelative,
        EShapeActionRuntimeTransformResize: EShapeActionRuntimeTransformResize,
        EShapeActionRuntimeTransformRotateAbsolute: EShapeActionRuntimeTransformRotateAbsolute,
        EShapeActionRuntimeTransformRotateRelative: EShapeActionRuntimeTransformRotateRelative,
        EShapeActionRuntimeTransformRotate: EShapeActionRuntimeTransformRotate,
        EShapeActionRuntimes: EShapeActionRuntimes,
        EShapeActionValueBase: EShapeActionValueBase,
        EShapeActionValueBlinkType: EShapeActionValueBlinkType,
        EShapeActionValueBlink: EShapeActionValueBlink,
        EShapeActionValueChangeColorBrightness: EShapeActionValueChangeColorBrightness,
        EShapeActionValueChangeColorCode: EShapeActionValueChangeColorCode,
        EShapeActionValueChangeColorTarget: EShapeActionValueChangeColorTarget,
        EShapeActionValueChangeColorTypeLegacy: EShapeActionValueChangeColorTypeLegacy,
        EShapeActionValueChangeColorType: EShapeActionValueChangeColorType,
        EShapeActionValueChangeColorTypes: EShapeActionValueChangeColorTypes,
        EShapeActionValueChangeColor: EShapeActionValueChangeColor,
        EShapeActionValueChangeCursor: EShapeActionValueChangeCursor,
        EShapeActionValueChangeTextType: EShapeActionValueChangeTextType,
        EShapeActionValueChangeText: EShapeActionValueChangeText,
        EShapeActionValueDeserializers: EShapeActionValueDeserializers,
        EShapeActionValueEmitEvent: EShapeActionValueEmitEvent,
        EShapeActionValueGestureOperationType: EShapeActionValueGestureOperationType,
        EShapeActionValueGestureType: EShapeActionValueGestureType,
        EShapeActionValueGesture: EShapeActionValueGesture,
        EShapeActionValueMiscEmitEvent: EShapeActionValueMiscEmitEvent,
        EShapeActionValueMiscExecute: EShapeActionValueMiscExecute,
        EShapeActionValueMiscExtension: EShapeActionValueMiscExtension,
        EShapeActionValueMiscHtmlElement: EShapeActionValueMiscHtmlElement,
        EShapeActionValueMiscInput: EShapeActionValueMiscInput,
        EShapeActionValueMiscType: EShapeActionValueMiscType,
        EShapeActionValueMiscWrite: EShapeActionValueMiscWrite,
        EShapeActionValueMisc: EShapeActionValueMisc,
        EShapeActionValueOnInputAction: EShapeActionValueOnInputAction,
        EShapeActionValueOnInputActions: EShapeActionValueOnInputActions,
        EShapeActionValueOpenDialogExtension: EShapeActionValueOpenDialogExtension,
        EShapeActionValueOpenDialogType: EShapeActionValueOpenDialogType,
        EShapeActionValueOpenDialog: EShapeActionValueOpenDialog,
        EShapeActionValueOpenExtension: EShapeActionValueOpenExtension,
        EShapeActionValueOpenType: EShapeActionValueOpenType,
        EShapeActionValueOpen: EShapeActionValueOpen,
        EShapeActionValueOpetyped: EShapeActionValueOpetyped,
        EShapeActionValueShowHideLayer: EShapeActionValueShowHideLayer,
        EShapeActionValueShowHideShape: EShapeActionValueShowHideShape,
        EShapeActionValueShowHideType: EShapeActionValueShowHideType,
        EShapeActionValueShowHide: EShapeActionValueShowHide,
        EShapeActionValueSubtyped: EShapeActionValueSubtyped,
        EShapeActionValueTransformMoveType: EShapeActionValueTransformMoveType,
        EShapeActionValueTransformMove: EShapeActionValueTransformMove,
        EShapeActionValueTransformResizeType: EShapeActionValueTransformResizeType,
        EShapeActionValueTransformResize: EShapeActionValueTransformResize,
        EShapeActionValueTransformRotateType: EShapeActionValueTransformRotateType,
        EShapeActionValueTransformRotate: EShapeActionValueTransformRotate,
        EShapeActionValueTransformType: EShapeActionValueTransformType,
        EShapeActionValueType: EShapeActionValueType,
        EShapeActionValues: EShapeActionValues,
        EShapeAction: EShapeAction,
        EShapeActions: EShapeActions,
        loadShapeAll: loadShapeAll,
        loadShapeBar: loadShapeBar,
        loadShapeButton: loadShapeButton,
        loadShapeCircle: loadShapeCircle,
        loadShapeClipperEx: loadShapeClipperEx,
        isShapeClipperExLoaded: isShapeClipperExLoaded,
        loadShapeConnectorElbow: loadShapeConnectorElbow,
        loadShapeConnectorLine: loadShapeConnectorLine,
        loadShapeEmbedded: loadShapeEmbedded,
        loadShapeGroupShadowed: loadShapeGroupShadowed,
        loadShapeGroup: loadShapeGroup,
        loadShapeImage: loadShapeImage,
        loadShapeLabel: loadShapeLabel,
        loadShapeLineOfCircles: loadShapeLineOfCircles,
        loadShapeLineOfRectangleRoundeds: loadShapeLineOfRectangleRoundeds,
        loadShapeLineOfRectangles: loadShapeLineOfRectangles,
        loadShapeLineOfTriangleRoundeds: loadShapeLineOfTriangleRoundeds,
        loadShapeLineOfTriangles: loadShapeLineOfTriangles,
        loadShapeLine: loadShapeLine,
        loadShapeNull: loadShapeNull,
        loadShapeRectangleRounded: loadShapeRectangleRounded,
        loadShapeRectangle: loadShapeRectangle,
        loadShapeSemicircle: loadShapeSemicircle,
        loadShapeTriangleRounded: loadShapeTriangleRounded,
        loadShapeTriangle: loadShapeTriangle,
        BAR_VERTEX_COUNT: BAR_VERTEX_COUNT,
        BAR_INDEX_COUNT: BAR_INDEX_COUNT,
        buildBarIndex: buildBarIndex,
        buildBarVertexStep: buildBarVertexStep,
        buildBarUv: buildBarUv,
        CIRCLE_VERTEX_COUNT: CIRCLE_VERTEX_COUNT,
        CIRCLE_INDEX_COUNT: CIRCLE_INDEX_COUNT,
        CIRCLE_WORLD_SIZE: CIRCLE_WORLD_SIZE,
        buildCircleIndex: buildCircleIndex,
        buildCircleVertex: buildCircleVertex,
        buildCircleStep: buildCircleStep,
        buildCircleUv: buildCircleUv,
        buildColor: buildColor,
        IMAGE_SDF_VERTEX_COUNT: IMAGE_SDF_VERTEX_COUNT,
        IMAGE_SDF_INDEX_COUNT: IMAGE_SDF_INDEX_COUNT,
        IMAGE_SDF_WORLD_SIZE: IMAGE_SDF_WORLD_SIZE,
        buildImageSdfIndex: buildImageSdfIndex,
        buildImageSdfStep: buildImageSdfStep,
        buildImageSdfVertex: buildImageSdfVertex,
        buildImageSdfUv: buildImageSdfUv,
        toLineOfAnyPointCount: toLineOfAnyPointCount,
        buildLineOfAnyColor: buildLineOfAnyColor,
        toPointCount: toPointCount,
        toLinePointCount: toLinePointCount,
        toLineVertexCount: toLineVertexCount,
        toLineIndexCount: toLineIndexCount,
        buildLineIndex: buildLineIndex,
        buildLineUv: buildLineUv,
        buildLineVertexStep: buildLineVertexStep,
        buildNullIndex: buildNullIndex,
        buildNullVertex: buildNullVertex,
        buildNullStep: buildNullStep,
        buildNullUv: buildNullUv,
        RECTANGLE_ROUNDED_VERTEX_COUNT: RECTANGLE_ROUNDED_VERTEX_COUNT,
        RECTANGLE_ROUNDED_INDEX_COUNT: RECTANGLE_ROUNDED_INDEX_COUNT,
        RECTANGLE_ROUNDED_WORLD_SIZE: RECTANGLE_ROUNDED_WORLD_SIZE,
        buildRectangleRoundedIndex: buildRectangleRoundedIndex,
        buildRectangleRoundedVertex: buildRectangleRoundedVertex,
        buildRectangleRoundedStep: buildRectangleRoundedStep,
        buildRectangleRoundedUv: buildRectangleRoundedUv,
        RECTANGLE_VERTEX_COUNT: RECTANGLE_VERTEX_COUNT,
        RECTANGLE_INDEX_COUNT: RECTANGLE_INDEX_COUNT,
        RECTANGLE_WORLD_SIZE: RECTANGLE_WORLD_SIZE,
        buildRectangleIndex: buildRectangleIndex,
        buildRectangleVertex: buildRectangleVertex,
        buildRectangleStep: buildRectangleStep,
        buildRectangleUv: buildRectangleUv,
        SEMICIRCLE_VERTEX_COUNT: SEMICIRCLE_VERTEX_COUNT,
        SEMICIRCLE_INDEX_COUNT: SEMICIRCLE_INDEX_COUNT,
        SEMICIRCLE_WORLD_SIZE: SEMICIRCLE_WORLD_SIZE,
        buildSemicircleIndex: buildSemicircleIndex,
        buildSemicircleVertex: buildSemicircleVertex,
        buildSemicircleStep: buildSemicircleStep,
        buildSemicircleUv: buildSemicircleUv,
        TEXT_VERTEX_COUNT: TEXT_VERTEX_COUNT,
        TEXT_VERTEX_COUNT_SHIFT: TEXT_VERTEX_COUNT_SHIFT,
        TEXT_INDEX_COUNT: TEXT_INDEX_COUNT,
        TEXT_INDEX_COUNT_SHIFT: TEXT_INDEX_COUNT_SHIFT,
        TEXT_FMIN: TEXT_FMIN,
        toTextBufferCount: toTextBufferCount,
        buildTextIndex: buildTextIndex,
        buildTextStep: buildTextStep,
        buildTextVertex: buildTextVertex,
        TRIANGLE_ROUNDED_VERTEX_COUNT: TRIANGLE_ROUNDED_VERTEX_COUNT,
        TRIANGLE_ROUNDED_INDEX_COUNT: TRIANGLE_ROUNDED_INDEX_COUNT,
        TRIANGLE_ROUNDED_WORLD_SIZE: TRIANGLE_ROUNDED_WORLD_SIZE,
        buildTriangleRoundedIndex: buildTriangleRoundedIndex,
        buildTriangleRoundedVertex: buildTriangleRoundedVertex,
        buildTriangleRoundedStep: buildTriangleRoundedStep,
        buildTriangleRoundedUv: buildTriangleRoundedUv,
        TRIANGLE_VERTEX_COUNT: TRIANGLE_VERTEX_COUNT,
        TRIANGLE_INDEX_COUNT: TRIANGLE_INDEX_COUNT,
        TRIANGLE_WORLD_SIZE: TRIANGLE_WORLD_SIZE,
        buildTriangleIndex: buildTriangleIndex,
        buildTriangleVertex: buildTriangleVertex,
        buildTriangleStep: buildTriangleStep,
        buildTriangleUv: buildTriangleUv,
        BuilderBar: BuilderBar,
        BuilderBase: BuilderBase,
        BuilderCircle: BuilderCircle,
        BuilderImageSdf: BuilderImageSdf,
        BuilderLabel: BuilderLabel,
        BuilderLineOfAny: BuilderLineOfAny,
        BuilderLineOfCircles: BuilderLineOfCircles,
        BuilderLineOfRectangleRoundeds: BuilderLineOfRectangleRoundeds,
        BuilderLineOfRectangles: BuilderLineOfRectangles,
        BuilderLineOfTriangleRoundeds: BuilderLineOfTriangleRoundeds,
        BuilderLineOfTriangles: BuilderLineOfTriangles,
        BuilderLine: BuilderLine,
        BuilderMarkerCircleHead: BuilderMarkerCircleHead,
        BuilderMarkerCircleTail: BuilderMarkerCircleTail,
        BuilderMarkerCircle: BuilderMarkerCircle,
        BuilderMarkerRectangleHead: BuilderMarkerRectangleHead,
        BuilderMarkerRectangleTail: BuilderMarkerRectangleTail,
        BuilderMarkerRectangle: BuilderMarkerRectangle,
        BuilderMarkerTriangleHead: BuilderMarkerTriangleHead,
        BuilderMarkerTriangleTail: BuilderMarkerTriangleTail,
        BuilderMarkerTriangle: BuilderMarkerTriangle,
        BuilderNull: BuilderNull,
        BuilderRectanglePivoted: BuilderRectanglePivoted,
        BuilderRectangleRounded: BuilderRectangleRounded,
        BuilderRectangle: BuilderRectangle,
        BuilderSemicircle: BuilderSemicircle,
        BuilderText: BuilderText,
        BuilderTriangleRounded: BuilderTriangleRounded,
        BuilderTriangle: BuilderTriangle,
        BuilderFlag: BuilderFlag,
        toTransformLocalId: toTransformLocalId,
        toTexture: toTexture,
        toTextureTransformId: toTextureTransformId,
        toTextureUvs: toTextureUvs,
        copyIndex: copyIndex,
        copyStep: copyStep,
        copyUvs: copyUvs,
        copyVertex: copyVertex,
        createBarUploaded: createBarUploaded,
        createButtonUploaded: createButtonUploaded,
        createCircleUploaded: createCircleUploaded,
        createRectanglePivotedUploaded: createRectanglePivotedUploaded,
        createGroupUploaded: createGroupUploaded,
        createImageSdfUploaded: createImageSdfUploaded,
        createImageSdf: createImageSdf,
        createImage: createImage,
        createLabelUploaded: createLabelUploaded,
        createLineOfAnyUploaded: createLineOfAnyUploaded,
        createLineOfCirclesUploaded: createLineOfCirclesUploaded,
        createLineOfRectangleRoundedsUploaded: createLineOfRectangleRoundedsUploaded,
        createLineOfRectanglesUploaded: createLineOfRectanglesUploaded,
        createLineOfTriangleRoundedsUploaded: createLineOfTriangleRoundedsUploaded,
        createLineOfTrianglesUploaded: createLineOfTrianglesUploaded,
        createLineUploaded: createLineUploaded,
        createLine: createLine,
        createNullUploaded: createNullUploaded,
        createRectangleRoundedUploaded: createRectangleRoundedUploaded,
        createRectangleUploaded: createRectangleUploaded,
        createSemicircleUploaded: createSemicircleUploaded,
        createTriangleRoundedUploaded: createTriangleRoundedUploaded,
        createTriangleUploaded: createTriangleUploaded,
        deserializeAll: deserializeAll,
        deserializeBar: deserializeBar,
        deserializeBase: deserializeBase,
        deserializeButton: deserializeButton,
        deserializeCircle: deserializeCircle,
        deserializeConnectorElbow: deserializeConnectorElbow,
        deserializeConnectorLine: deserializeConnectorLine,
        onDeserializedConnectorLine: onDeserializedConnectorLine,
        deserializeEmbeddedAcceptorEdge: deserializeEmbeddedAcceptorEdge,
        deserializeEmbeddedLayer: deserializeEmbeddedLayer,
        deserializeEmbedded: deserializeEmbedded,
        deserializeGradient: deserializeGradient,
        deserializeGroupShadowed: deserializeGroupShadowed,
        deserializeGroup: deserializeGroup,
        deserializeImageSdf: deserializeImageSdf,
        deserializeImage: deserializeImage,
        deserializeLabel: deserializeLabel,
        deserializeLineOfCircles: deserializeLineOfCircles,
        deserializeLineOfRectangleRoundeds: deserializeLineOfRectangleRoundeds,
        deserializeLineOfRectangles: deserializeLineOfRectangles,
        deserializeLineOfTriangleRoundeds: deserializeLineOfTriangleRoundeds,
        deserializeLineOfTriangles: deserializeLineOfTriangles,
        deserializeLine: deserializeLine,
        deserializeNull: deserializeNull,
        deserializeRectanglePivoted: deserializeRectanglePivoted,
        deserializeRectangleRounded: deserializeRectangleRounded,
        deserializeRectangle: deserializeRectangle,
        deserializeSemicircle: deserializeSemicircle,
        deserializeTriangleRounded: deserializeTriangleRounded,
        deserializeTriangle: deserializeTriangle,
        deserialize: deserialize,
        EShapeBarPoints: EShapeBarPoints,
        EShapeBarPosition: EShapeBarPosition,
        EShapeBar: EShapeBar,
        EShapeBaseHitTestData: EShapeBaseHitTestData,
        EShapeBase: EShapeBase,
        EShapeButtonRuntimeActionToggle: EShapeButtonRuntimeActionToggle,
        EShapeButtonRuntimeAction: EShapeButtonRuntimeAction,
        EShapeButtonRuntime: EShapeButtonRuntime,
        EShapeButton: EShapeButton,
        EShapeCircle: EShapeCircle,
        EShapeConnectorElbowPointsFiller: EShapeConnectorElbowPointsFiller,
        EShapeConnectorElbow: EShapeConnectorElbow,
        EShapeConnectorLine: EShapeConnectorLine,
        EShapeEmbeddedAcceptorEdge: EShapeEmbeddedAcceptorEdge,
        EShapeEmbeddedAcceptor: EShapeEmbeddedAcceptor,
        EShapeEmbeddedDatum: EShapeEmbeddedDatum,
        EShapeEmbeddedLayerContainer: EShapeEmbeddedLayerContainer,
        EShapeEmbeddedLayer: EShapeEmbeddedLayer,
        EShapeEmbedded: EShapeEmbedded,
        EShapeEmbeddeds: EShapeEmbeddeds,
        EShapeFillImpl: EShapeFillImpl,
        EShapeGroupFillEditor: EShapeGroupFillEditor,
        EShapeGroupFillViewer: EShapeGroupFillViewer,
        EShapeGroupPoints: EShapeGroupPoints,
        EShapeGroupShadowed: EShapeGroupShadowed,
        EShapeGroupSizeEditor: EShapeGroupSizeEditor,
        EShapeGroupSizeLayout: EShapeGroupSizeLayout,
        EShapeGroupSizeShadowed: EShapeGroupSizeShadowed,
        EShapeGroupSizeViewer: EShapeGroupSizeViewer,
        EShapeGroupStrokeEditor: EShapeGroupStrokeEditor,
        EShapeGroupStrokeViewer: EShapeGroupStrokeViewer,
        EShapeGroupViewer: EShapeGroupViewer,
        EShapeGroup: EShapeGroup,
        EShapeImageSdf: EShapeImageSdf,
        EShapeImage: EShapeImage,
        EShapeLabel: EShapeLabel,
        EShapeLineBaseHitPart: EShapeLineBaseHitPart,
        EShapeLineBase: EShapeLineBase,
        EShapeLineOfAnyPointsFillImpl: EShapeLineOfAnyPointsFillImpl,
        EShapeLineOfAnyPointsImpl: EShapeLineOfAnyPointsImpl,
        EShapeLineOfAnyPointsPointImpl: EShapeLineOfAnyPointsPointImpl,
        EShapeLineOfAnyPointsStrokeImpl: EShapeLineOfAnyPointsStrokeImpl,
        EShapeLineOfCircles: EShapeLineOfCircles,
        EShapeLineOfRectangleRoundeds: EShapeLineOfRectangleRoundeds,
        EShapeLineOfRectangles: EShapeLineOfRectangles,
        EShapeLineOfTriangleRoundeds: EShapeLineOfTriangleRoundeds,
        EShapeLineOfTriangles: EShapeLineOfTriangles,
        EShapeLinePoints: EShapeLinePoints,
        EShapeLine: EShapeLine,
        EShapeLockPart: EShapeLockPart,
        EShapeLock: EShapeLock,
        EShapeNull: EShapeNull,
        EShapePrimitive: EShapePrimitive,
        EShapeRectanglePivoted: EShapeRectanglePivoted,
        EShapeRectangleRounded: EShapeRectangleRounded,
        EShapeRectangle: EShapeRectangle,
        EShapeSemicircle: EShapeSemicircle,
        EShapeStrokeImpl: EShapeStrokeImpl,
        EShapeTextAlignImpl: EShapeTextAlignImpl,
        EShapeTextImpl: EShapeTextImpl,
        EShapeTextOffsetImpl: EShapeTextOffsetImpl,
        EShapeTextOutlineImpl: EShapeTextOutlineImpl,
        EShapeTriangleRounded: EShapeTriangleRounded,
        EShapeTriangle: EShapeTriangle,
        hitTestBBox: hitTestBBox,
        hitTestCircle: hitTestCircle,
        hitTestSemicircle: hitTestSemicircle,
        hitTestRectangleRounded: hitTestRectangleRounded,
        hitTestRectangle: hitTestRectangle,
        hitTestTriangleRounded: hitTestTriangleRounded,
        hitTestTriangleFilled: hitTestTriangleFilled,
        hitTestTriangle: hitTestTriangle,
        isStatic: isStatic,
        toComputed: toComputed,
        toDash: toDash,
        toGradientImageUrl: toGradientImageUrl,
        toGradientSerialized: toGradientSerialized,
        toImageElement: toImageElement,
        toLength: toLength,
        toResized: toResized,
        toScaleInvariant: toScaleInvariant,
        toSizeNormalized: toSizeNormalized,
        toSizeRounded: toSizeRounded,
        toThresholdDefault: toThresholdDefault,
        EShapeAcceptorEdgeSide: EShapeAcceptorEdgeSide,
        EShapeAcceptorEdgeType: EShapeAcceptorEdgeType,
        EShapeAcceptorImpl: EShapeAcceptorImpl,
        EShapeAcceptorType: EShapeAcceptorType,
        EShapeAcceptors: EShapeAcceptors,
        EShapeBufferUnitBuilder: EShapeBufferUnitBuilder,
        EShapeBufferUnit: EShapeBufferUnit,
        EShapeBuffer: EShapeBuffer,
        EShapeCapabilities: EShapeCapabilities,
        EShapeCapabilityContainerImpl: EShapeCapabilityContainerImpl,
        EShapeCapability: EShapeCapability,
        EShapeConnectorBodies: EShapeConnectorBodies,
        EShapeConnectorBodyImpl: EShapeConnectorBodyImpl,
        EShapeConnectorContainerImpl: EShapeConnectorContainerImpl,
        EShapeConnectorEdgeAcceptorImpl: EShapeConnectorEdgeAcceptorImpl,
        EShapeConnectorEdgeContainerImpl: EShapeConnectorEdgeContainerImpl,
        EShapeConnectorEdgeImpl: EShapeConnectorEdgeImpl,
        EShapeConnectors: EShapeConnectors,
        EShapeContainer: EShapeContainer,
        EShapeCopyPart: EShapeCopyPart,
        EShapeCorner: EShapeCorner,
        EShapeDataImpl: EShapeDataImpl,
        EShapeDataMapperImpl: EShapeDataMapperImpl,
        EShapeDataMappingImpl: EShapeDataMappingImpl,
        EShapeDataScopedImpl: EShapeDataScopedImpl,
        EShapeDataSystemImpl: EShapeDataSystemImpl,
        EShapeDataValueExtensions: EShapeDataValueExtensions,
        EShapeDataValueImpl: EShapeDataValueImpl,
        EShapeDataValueOrder: EShapeDataValueOrder,
        EShapeDataValueRangeImpl: EShapeDataValueRangeImpl,
        EShapeDataValueRangeType: EShapeDataValueRangeType,
        EShapeDataValueScope: EShapeDataValueScope,
        EShapeDataValueState: EShapeDataValueState,
        EShapeDataValueType: EShapeDataValueType,
        EShapeDefaults: EShapeDefaults,
        EShapeDeserializers: EShapeDeserializers,
        EShapeOnDeserializeds: EShapeOnDeserializeds,
        EShapeEditor: EShapeEditor,
        EShapeLayerState: EShapeLayerState,
        toPointsBoundary: toPointsBoundary,
        eShapePointsFormatterCurveBezierQuadratic: eShapePointsFormatterCurveBezierQuadratic,
        eShapePointsFormatterCurve: eShapePointsFormatterCurve,
        EShapePointsFormatters: EShapePointsFormatters,
        EShapePointsMarkerBase: EShapePointsMarkerBase,
        EShapePointsMarkerContainerImplNoop: EShapePointsMarkerContainerImplNoop,
        EShapePointsMarkerContainerImpl: EShapePointsMarkerContainerImpl,
        EShapePointsMarkerHead: EShapePointsMarkerHead,
        EShapePointsMarkerNoop: EShapePointsMarkerNoop,
        EShapePointsMarkerTail: EShapePointsMarkerTail,
        EShapePointsMarkerType: EShapePointsMarkerType,
        EShapePointsStyle: EShapePointsStyle,
        EShapePointsStyles: EShapePointsStyles,
        EShapeRendererIteratorDatum: EShapeRendererIteratorDatum,
        EShapeRendererIterator: EShapeRendererIterator,
        EShapeRenderer: EShapeRenderer,
        EShapeResourceManagerDeserializationMode: EShapeResourceManagerDeserializationMode,
        EShapeResourceManagerDeserialization: EShapeResourceManagerDeserialization,
        EShapeResourceManagerSerialization: EShapeResourceManagerSerialization,
        EShapeRuntimeImpl: EShapeRuntimeImpl,
        EShapeRuntimeReset: EShapeRuntimeReset,
        EShapeRuntimes: EShapeRuntimes,
        EShapeStateSetImplObservable: EShapeStateSetImplObservable,
        EShapeState: EShapeState,
        EShapeStrokeSide: EShapeStrokeSide,
        EShapeStrokeStyle: EShapeStrokeStyle,
        EShapeTextAlignHorizontal: EShapeTextAlignHorizontal,
        EShapeTextAlignVertical: EShapeTextAlignVertical,
        EShapeTextDirection: EShapeTextDirection,
        EShapeTextWeight: EShapeTextWeight,
        EShapeTextStyle: EShapeTextStyle,
        EShapeTransformImpl: EShapeTransformImpl,
        EShapeType: EShapeType,
        EShapeUploadedImpl: EShapeUploadedImpl,
        EShapeUploadeds: EShapeUploadeds,
        EShapeUuidMappingImpl: EShapeUuidMappingImpl,
        ESnapperGrid: ESnapperGrid,
        ESnapperResultScale: ESnapperResultScale,
        ESnapperResult: ESnapperResult,
        ESnapperTargetValueType: ESnapperTargetValueType,
        ESnapperTargetValue: ESnapperTargetValue,
        ESnapperTarget: ESnapperTarget,
        ESnapperModifierAnchor: ESnapperModifierAnchor,
        ESnapper: ESnapper,
        DThemes: DThemes,
        FormatNodeA: FormatNodeA,
        FormatNodea: FormatNodea,
        FormatNodeD: FormatNodeD,
        FormatNoded: FormatNoded,
        FormatNodee: FormatNodee,
        FormatNodef: FormatNodef,
        FormatNodefsi: FormatNodefsi,
        FormatNodeg: FormatNodeg,
        FormatNodeH: FormatNodeH,
        FormatNodeh: FormatNodeh,
        FormatNodeM: FormatNodeM,
        FormatNodem: FormatNodem,
        FormatNodemi: FormatNodemi,
        FormatNodeP: FormatNodeP,
        FormatNodep: FormatNodep,
        FormatNodePadding: FormatNodePadding,
        FormatNodeParenthesis: FormatNodeParenthesis,
        FormatNodePlus: FormatNodePlus,
        FormatNodePrecision: FormatNodePrecision,
        FormatNoderd: FormatNoderd,
        FormatNodeRP: FormatNodeRP,
        FormatNoderp: FormatNoderp,
        FormatNodesdt: FormatNodesdt,
        FormatNodeSpace: FormatNodeSpace,
        FormatNodessi: FormatNodessi,
        FormatNodeString: FormatNodeString,
        FormatNodeY: FormatNodeY,
        FormatNodey: FormatNodey,
        FormatNodez: FormatNodez,
        FormatNodes: FormatNodes,
        Character: Character,
        DynamicAtlasItemEmpty: DynamicAtlasItemEmpty,
        DynamicAtlasItemFontAtlas: DynamicAtlasItemFontAtlas,
        DynamicAtlasItemImage: DynamicAtlasItemImage,
        DynamicAtlasItemText: DynamicAtlasItemText,
        DynamicAtlasItemWhite: DynamicAtlasItemWhite,
        DynamicAtlasItem: DynamicAtlasItem,
        DynamicAtlas: DynamicAtlas,
        DynamicFontAtlasCharacterOrigin: DynamicFontAtlasCharacterOrigin,
        DynamicFontAtlasCharacterType: DynamicFontAtlasCharacterType,
        DynamicFontAtlasCharacter: DynamicFontAtlasCharacter,
        DynamicFontAtlasFont: DynamicFontAtlasFont,
        DynamicFontAtlas: DynamicFontAtlas,
        DynamicFontAtlases: DynamicFontAtlases,
        DynamicSDFFontAtlasFont: DynamicSDFFontAtlasFont,
        DynamicSDFFontAtlas: DynamicSDFFontAtlas,
        DynamicSDFFontAtlases: DynamicSDFFontAtlases,
        DynamicSDFFontGenerator: DynamicSDFFontGenerator,
        isArray: isArray,
        isFunction: isFunction,
        isNaN: isNaN$1,
        isNumber: isNumber,
        isObject: isObject,
        isString: isString,
        Lazy: Lazy,
        NumberFormatterImpl: NumberFormatterImpl,
        NumberFormatters: NumberFormatters,
        toCeilingIndex: toCeilingIndex,
        toCloned: toCloned,
        toEnum: toEnum,
        toId: toId,
        toIndexOf: toIndexOf,
        toLabel: toLabel$1,
        toMerged: toMerged,
        toPadded: toPadded,
        toString: toString,
        toSvgTexture: toSvgTexture,
        toSvgUrl: toSvgUrl,
        UtilAlpha: UtilAlpha,
        UtilSvgAtlasBuilder: UtilSvgAtlasBuilder,
        UtilAttachAlign: UtilAttachAlign,
        UtilAttach: UtilAttach,
        UtilCharacterIterator: UtilCharacterIterator,
        UtilClickOutside: UtilClickOutside,
        UtilClipboard: UtilClipboard,
        UtilGestureData: UtilGestureData,
        UtilGestureEasingHistory: UtilGestureEasingHistory,
        UtilGestureEasing: UtilGestureEasing,
        UtilGestureMode: UtilGestureMode,
        UtilGestureModifier: UtilGestureModifier,
        UtilGestureModifiers: UtilGestureModifiers,
        UtilGestureTap: UtilGestureTap,
        UtilGesture: UtilGesture,
        UtilExtract: UtilExtract,
        UtilExtractorCanvas: UtilExtractorCanvas,
        UtilExtractor: UtilExtractor,
        UtilFileDownloader: UtilFileDownloader,
        UtilFileAs: UtilFileAs,
        UtilFileOpener: UtilFileOpener,
        UtilFont: UtilFont,
        UtilHsv: UtilHsv,
        UtilHtmlElementClipperExImpl: UtilHtmlElementClipperExImpl,
        UtilHtmlElementClipperExRectsImpl: UtilHtmlElementClipperExRectsImpl,
        UtilHtmlElementWhen: UtilHtmlElementWhen,
        UtilHtmlElement: UtilHtmlElement,
        UtilInputInput: UtilInputInput,
        UtilInputNumber: UtilInputNumber,
        UtilInputTextArea: UtilInputTextArea,
        UtilInputText: UtilInputText,
        UtilInput: UtilInput,
        UtilKeyboardEvent: UtilKeyboardEvent,
        UtilName: UtilName,
        UtilOverlay: UtilOverlay,
        UtilPointerEvent: UtilPointerEvent,
        UtilRgb: UtilRgb,
        UtilRgba: UtilRgba,
        UtilStateBlinker: UtilStateBlinker,
        UtilTransition: UtilTransition,
        UtilWheelEvent: UtilWheelEvent,
        DAlignHorizontal: DAlignHorizontal,
        DAlignVertical: DAlignVertical,
        DAlignWith: DAlignWith,
        DAnimationBase: DAnimationBase,
        DAnimationEmpty: DAnimationEmpty,
        DAnimationFadeIn: DAnimationFadeIn,
        DAnimationTimings: DAnimationTimings,
        DApplicationLayerOptions: DApplicationLayerOptions,
        DApplicationLayer: DApplicationLayer,
        DApplicationPadding: DApplicationPadding,
        DApplication: DApplication,
        DApplications: DApplications,
        DBaseAutoSet: DBaseAutoSet,
        DBaseAuto: DBaseAuto,
        DBaseBackgroundMeshGeometry: DBaseBackgroundMeshGeometry,
        DBaseBackgroundMesh: DBaseBackgroundMesh,
        DBaseBackgroundSnippet: DBaseBackgroundSnippet,
        DBaseBackground: DBaseBackground,
        DBaseBorderMeshGeometry: DBaseBorderMeshGeometry,
        DBaseBorderMesh: DBaseBorderMesh,
        DBaseBorderSnippet: DBaseBorderSnippet,
        DBaseBorder: DBaseBorder,
        DBaseCorner: DBaseCorner,
        DBaseInteractive: DBaseInteractive,
        DBaseMeshGeometry: DBaseMeshGeometry,
        DBaseOutlineSnippet: DBaseOutlineSnippet,
        DBaseOutline: DBaseOutline,
        DBaseOverflowMaskSimple: DBaseOverflowMaskSimple,
        DBaseOverflowMask: DBaseOverflowMask,
        DBasePaddingAdjustable: DBasePaddingAdjustable,
        DBasePadding: DBasePadding,
        DBasePoint: DBasePoint,
        DBaseReflowableContainer: DBaseReflowableContainer,
        DBaseReflowableImpl: DBaseReflowableImpl,
        DBaseSnippetContainer: DBaseSnippetContainer,
        DBaseStateSetBlinkerDatumImpl: DBaseStateSetBlinkerDatumImpl,
        DBaseStateSetBlinkerImpl: DBaseStateSetBlinkerImpl,
        DBaseStateSetImplObservable: DBaseStateSetImplObservable,
        DBaseStateSetImpl: DBaseStateSetImpl,
        DBaseStateSetSubDatumImp: DBaseStateSetSubDatumImp,
        DBaseStateSetSubImpl: DBaseStateSetSubImpl,
        DBaseStateSetTickerDatumImpl: DBaseStateSetTickerDatumImpl,
        DBaseStateSetTickerImpl: DBaseStateSetTickerImpl,
        DBaseState: DBaseState,
        DBase: DBase,
        DBoard: DBoard,
        DBorderMask: DBorderMask,
        DButtonAmbient: DButtonAmbient,
        DButtonBaseWhen: DButtonBaseWhen,
        DButtonBase: DButtonBase,
        DButtonCheckRight: DButtonCheckRight,
        DButtonCheck: DButtonCheck,
        DButtonColorGradient: DButtonColorGradient,
        DButtonColor: DButtonColor,
        DButtonDanger: DButtonDanger,
        DButtonDate: DButtonDate,
        DButtonDatetime: DButtonDatetime,
        DButtonFileAs: UtilFileAs,
        DButtonFile: DButtonFile,
        DButtonGroup: DButtonGroup,
        DButtonLink: DButtonLink,
        DButtonPrimary: DButtonPrimary,
        DButtonRadioRight: DButtonRadioRight,
        DButtonRadio: DButtonRadio,
        DButtonRedo: DButtonRedo,
        DButtonSecondary: DButtonSecondary,
        DButtonSelect: DButtonSelect,
        DButtonTime: DButtonTime,
        DButtonUndo: DButtonUndo,
        DButton: DButton,
        DCanvasContainer: DCanvasContainer,
        DCanvas: DCanvas,
        DChartAxisBaseBar: DChartAxisBaseBar,
        DChartAxisBaseGuideContainer: DChartAxisBaseGuideContainer,
        DChartAxisBaseOptionParser: DChartAxisBaseOptionParser,
        DChartAxisBaseTickContainer: DChartAxisBaseTickContainer,
        DChartAxisBaseTickMajorGridline: DChartAxisBaseTickMajorGridline,
        DChartAxisBaseTickMajor: DChartAxisBaseTickMajor,
        DChartAxisBaseTickMinor: DChartAxisBaseTickMinor,
        DChartAxisBase: DChartAxisBase,
        DChartAxisContainerImpl: DChartAxisContainerImpl,
        DChartAxisGuideSimpleShapeImpl: DChartAxisGuideSimpleShapeImpl,
        DChartAxisGuideSimple: DChartAxisGuideSimple,
        DChartAxisPosition: DChartAxisPosition,
        DChartAxisTickPosition: DChartAxisTickPosition,
        DChartAxisXDatetime: DChartAxisXDatetime,
        DChartAxisX: DChartAxisX,
        DChartAxisY: DChartAxisY,
        DChartColorSet1: DChartColorSet1,
        DChartColorSet2: DChartColorSet2,
        DChartCoordinateBase: DChartCoordinateBase,
        DChartCoordinateContainerImpl: DChartCoordinateContainerImpl,
        DChartCoordinateContainerSubImpl: DChartCoordinateContainerSubImpl,
        DChartCoordinateDirection: DChartCoordinateDirection,
        DChartCoordinateLinearTick: DChartCoordinateLinearTick,
        DChartCoordinateLinear: DChartCoordinateLinear,
        DChartCoordinateLogTick: DChartCoordinateLogTick,
        DChartCoordinateLog: DChartCoordinateLog,
        DChartCoordinateTransformImpl: DChartCoordinateTransformImpl,
        DChartCoordinateTransformMarkImpl: DChartCoordinateTransformMarkImpl,
        DChartLegendItem: DChartLegendItem,
        DChartLegend: DChartLegend,
        DChartOverview: DChartOverview,
        DChartPlotAreaBase: DChartPlotAreaBase,
        DChartPlotAreaContainer: DChartPlotAreaContainer,
        DChartPlotAreaOnefold: DChartPlotAreaOnefold,
        DChartPlotAreaTwofoldAxisContainer: DChartPlotAreaTwofoldAxisContainer,
        DChartPlotAreaTwofoldCoorinateContainerSub: DChartPlotAreaTwofoldCoorinateContainerSub,
        DChartPlotAreaTwofoldCoorinateContainer: DChartPlotAreaTwofoldCoorinateContainer,
        DChartPlotAreaTwofoldOverflowMaskPrimary: DChartPlotAreaTwofoldOverflowMaskPrimary,
        DChartPlotAreaTwofoldOverflowMaskSecondary: DChartPlotAreaTwofoldOverflowMaskSecondary,
        DChartPlotAreaTwofoldSeriesContainer: DChartPlotAreaTwofoldSeriesContainer,
        DChartPlotAreaTwofoldSubBase: DChartPlotAreaTwofoldSubBase,
        DChartPlotAreaTwofoldSubPrimary: DChartPlotAreaTwofoldSubPrimary,
        DChartPlotAreaTwofoldSubSecondary: DChartPlotAreaTwofoldSubSecondary,
        DChartPlotAreaTwofoldViewTargetPoint: DChartPlotAreaTwofoldViewTargetPoint,
        DChartPlotAreaTwofoldViewTarget: DChartPlotAreaTwofoldViewTarget,
        DChartPlotAreaTwofold: DChartPlotAreaTwofold,
        DChartRegionImplObservable: DChartRegionImplObservable,
        DChartRegionImpl: DChartRegionImpl,
        DChartSelectionContainerImpl: DChartSelectionContainerImpl,
        DChartSelectionGridlineX: DChartSelectionGridlineX,
        DChartSelectionGridlineY: DChartSelectionGridlineY,
        DChartSelectionMarker: DChartSelectionMarker,
        DChartSelectionShapeBase: DChartSelectionShapeBase,
        DChartSelectionSimple: DChartSelectionSimple,
        DChartSelectionSubImpl: DChartSelectionSubImpl,
        DChartSelectionPoint: DChartSelectionPoint,
        DChartSeriesBar: DChartSeriesBar,
        DChartSeriesBaseCoordinateContainer: DChartSeriesBaseCoordinateContainer,
        DChartSeriesBase: DChartSeriesBase,
        DChartSeriesContainerImpl: DChartSeriesContainerImpl,
        DChartSeriesFillComputedImpl: DChartSeriesFillComputedImpl,
        DChartSeriesFillImpl: DChartSeriesFillImpl,
        DChartSeriesLineOfAny: DChartSeriesLineOfAny,
        DChartSeriesLineOfCircles: DChartSeriesLineOfCircles,
        DChartSeriesLineOfRectangleRoundeds: DChartSeriesLineOfRectangleRoundeds,
        DChartSeriesLineOfRectangles: DChartSeriesLineOfRectangles,
        DChartSeriesLineOfTriangleRoundeds: DChartSeriesLineOfTriangleRoundeds,
        DChartSeriesLineOfTriangles: DChartSeriesLineOfTriangles,
        DChartSeriesLine: DChartSeriesLine,
        DChartSeriesExpressionParametersImpl: DChartSeriesExpressionParametersImpl,
        DChartSeriesLinear: DChartSeriesLinear,
        DChartSeriesPaddingComputedImpl: DChartSeriesPaddingComputedImpl,
        DChartSeriesPaddingImpl: DChartSeriesPaddingImpl,
        DChartSeriesPointComputedImpl: DChartSeriesPointComputedImpl,
        DChartSeriesPointImpl: DChartSeriesPointImpl,
        DChartSeriesScalars: DChartSeriesScalars,
        DChartSeriesStrokeComputedImpl: DChartSeriesStrokeComputedImpl,
        DChartSeriesStrokeImpl: DChartSeriesStrokeImpl,
        DChartSeriesHitResult: DChartSeriesHitResult,
        DChart: DChart,
        DColorGradientObservable: DColorGradientObservable,
        DColorGradientPointObservable: DColorGradientPointObservable,
        DColorRecent: DColorRecent,
        DColorRecents: DColorRecents,
        DColorStandard: DColorStandard,
        DColorStandards: DColorStandards,
        DColorType: DColorType,
        DCommandBase: DCommandBase,
        DCommandClear: DCommandClear,
        DCommandCreate: DCommandCreate,
        DCommandSaveAs: DCommandSaveAs,
        DCommandSave: DCommandSave,
        DContent: DContent,
        DControllerCommandImpl: DControllerCommandImpl,
        DControllerFocusImpl: DControllerFocusImpl,
        DControllerKeyboardImpl: DControllerKeyboardImpl,
        DControllers: DControllers,
        DCornerMask: DCornerMask,
        DDiagramBaseControllerOpenType: DDiagramBaseControllerOpenType,
        DDiagramBase: DDiagramBase,
        DDiagramCanvasBase: DDiagramCanvasBase,
        DDiagramCanvasBaseShapeImpl: DDiagramCanvasBaseShapeImpl,
        DDiagramCanvasDataImpl: DDiagramCanvasDataImpl,
        DDiagramCanvasEditorBackground: DDiagramCanvasEditorBackground,
        DDiagramCanvasEditorShapeImpl: DDiagramCanvasEditorShapeImpl,
        DDiagramCanvasEditorSnap: DDiagramCanvasEditorSnap,
        DDiagramCanvasEditor: DDiagramCanvasEditor,
        DDiagramCanvasTileMappingImpl: DDiagramCanvasTileMappingImpl,
        DDiagramCanvasTileMappingPointImpl: DDiagramCanvasTileMappingPointImpl,
        DDiagramCanvasShapeImpl: DDiagramCanvasShapeImpl,
        DDiagramCanvasTickerImpl: DDiagramCanvasTickerImpl,
        DDiagramCanvasTile: DDiagramCanvasTile,
        DDiagramCanvas: DDiagramCanvas,
        DDiagramDataImpl: DDiagramDataImpl,
        DDiagramDataPrivateImpl: DDiagramDataPrivateImpl,
        DDiagramDataRemoteImpl: DDiagramDataRemoteImpl,
        DDiagramEditorThumbnail: DDiagramEditorThumbnail,
        DDiagramEditor: DDiagramEditor,
        DDiagramLayerContainer: DDiagramLayerContainer,
        DDiagramLayer: DDiagramLayer,
        DDiagramLayers: DDiagramLayers,
        DDiagramSerializedVersion: DDiagramSerializedVersion,
        DDiagramShape: DDiagramShape,
        DDiagramSnapshot: DDiagramSnapshot,
        DDiagramTicker: DDiagramTicker,
        DDiagram: DDiagram,
        DDiagrams: DDiagrams,
        DDialogAlign: UtilAttachAlign,
        DDialogCloseOn: DDialogCloseOn,
        DDialogColorGradient: DDialogColorGradient,
        DDialogColor: DDialogColor,
        DDialogConfirmDelete: DDialogConfirmDelete,
        DDialogConfirmDiscard: DDialogConfirmDiscard,
        DDialogConfirmMessage: DDialogConfirmMessage,
        DDialogConfirm: DDialogConfirm,
        DDialogDate: DDialogDate,
        DDialogDatetime: DDialogDatetime,
        DDialogFittedContent: DDialogFittedContent,
        DDialogFitted: DDialogFitted,
        DDialogGestureImpl: DDialogGestureImpl,
        DDialogGestureMode: DDialogGestureMode,
        DDialogInputBoolean: DDialogInputBoolean,
        DDialogInputInteger: DDialogInputInteger,
        DDialogInputReal: DDialogInputReal,
        DDialogInputText: DDialogInputText,
        DDialogInput: DDialogInput,
        DDialogLayeredContent: DDialogLayeredContent,
        DDialogLayeredFooter: DDialogLayeredFooter,
        DDialogLayeredHeaderButtonClose: DDialogLayeredHeaderButtonClose,
        DDialogLayeredHeaderSeparator: DDialogLayeredHeaderSeparator,
        DDialogLayeredHeader: DDialogLayeredHeader,
        DDialogLayered: DDialogLayered,
        DDialogMessage: DDialogMessage,
        DDialogMode: DDialogMode,
        DDialogProcessingMessage: DDialogProcessingMessage,
        DDialogProcessing: DDialogProcessing,
        DDialogSaveAs: DDialogSaveAs,
        DDialogSelectListItemUpdater: DDialogSelectListItemUpdater,
        DDialogSelectListItem: DDialogSelectListItem,
        DDialogSelectList: DDialogSelectList,
        DDialogSelectSearhImpl: DDialogSelectSearhImpl,
        DDialogSelect: DDialogSelect,
        DDialogState: DDialogState,
        DDialogTime: DDialogTime,
        DDialog: DDialog,
        DDropdownBase: DDropdownBase,
        DDropdown: DDropdown,
        DDynamicTextGeometry: DDynamicTextGeometry,
        DDynamicTextMeasureResultCharacter: DDynamicTextMeasureResultCharacter,
        DDynamicTextMeasureResult: DDynamicTextMeasureResult,
        DDynamicTextMeasure: DDynamicTextMeasure,
        DDynamicTextStyleWordWrap: DDynamicTextStyleWordWrap,
        DDynamicTextStyle: DDynamicTextStyle,
        DDynamicText: DDynamicText,
        DExpandableHeader: DExpandableHeader,
        DExpandable: DExpandable,
        DHtmlElementState: DHtmlElementState,
        DHtmlElement: DHtmlElement,
        DImageBaseThemeWrapperOther: DImageBaseThemeWrapperOther,
        DImageBaseThemeWrapperSecondary: DImageBaseThemeWrapperSecondary,
        DImageBaseThemeWrapperTertiary: DImageBaseThemeWrapperTertiary,
        DImageBase: DImageBase,
        DImagePieceAlignImpl: DImagePieceAlignImpl,
        DImagePieceContainerImpl: DImagePieceContainerImpl,
        DImagePieceImpl: DImagePieceImpl,
        DImagePieceLayouterPartBottom: DImagePieceLayouterPartBottom,
        DImagePieceLayouterPartCenter: DImagePieceLayouterPartCenter,
        DImagePieceLayouterPartContainer: DImagePieceLayouterPartContainer,
        DImagePieceLayouterPartLeft: DImagePieceLayouterPartLeft,
        DImagePieceLayouterPartMiddle: DImagePieceLayouterPartMiddle,
        DImagePieceLayouterPartRight: DImagePieceLayouterPartRight,
        DImagePieceLayouterPartTop: DImagePieceLayouterPartTop,
        DImagePieceLayouterPart: DImagePieceLayouterPart,
        DImagePieceLayouter: DImagePieceLayouter,
        DImagePieceMarginImpl: DImagePieceMarginImpl,
        DImagePieceTintImpl: DImagePieceTintImpl,
        DImage: DImage,
        DIndicatorProcessingState: DIndicatorProcessingState,
        DIndicatorProcessing: DIndicatorProcessing,
        DInputAndLabel: DInputAndLabel,
        DInputBooleanButtonOff: DInputBooleanButtonOff,
        DInputBooleanButtonOn: DInputBooleanButtonOn,
        DInputBoolean: DInputBoolean,
        DInputInput: DInputInput,
        DInputIntegerAndLabel: DInputIntegerAndLabel,
        DInputInteger: DInputInteger,
        DInputLabel: DInputLabel,
        DInputNumber: DInputNumber,
        DInputRealAndLabel: DInputRealAndLabel,
        DInputReal: DInputReal,
        DInputSearch: DInputSearch,
        DInputTextAndLabel: DInputTextAndLabel,
        DInputTextArea: DInputTextArea,
        DInputText: DInputText,
        DInput: DInput,
        DItemUpdater: DItemUpdater,
        DLayoutBoard: DLayoutBoard,
        DLayoutClearType: DLayoutClearType,
        DLayoutDirection: DLayoutDirection,
        DLayoutHorizontal: DLayoutHorizontal,
        DLayoutSpace: DLayoutSpace,
        DLayoutVertical: DLayoutVertical,
        DLayout: DLayout,
        DLinkMenuItemId: DLinkMenuItemId,
        DLinkMenu: DLinkMenu,
        DLinkTarget: DLinkTarget,
        DLink: DLink,
        DLinks: DLinks,
        DListDataImpl: DListDataImpl,
        DListDataMappedImpl: DListDataMappedImpl,
        DListDataSelectionMultiple: DListDataSelectionMultiple,
        DListDataSelectionNone: DListDataSelectionNone,
        DListDataSelectionSingle: DListDataSelectionSingle,
        DListDataSelectionType: DListDataSelectionType,
        DListItemAccessorImpl: DListItemAccessorImpl,
        DListItemAmbient: DListItemAmbient,
        DListItemUpdater: DListItemUpdater,
        DListItem: DListItem,
        DList: DList,
        DMapCoordinateEPSG3857: DMapCoordinateEPSG3857,
        DMapCoordinates: DMapCoordinates,
        DMapTilePlane: DMapTilePlane,
        DMapTilePyramidImpl: DMapTilePyramidImpl,
        DMapTileUrlBuilderKokudo: DMapTileUrlBuilderKokudo,
        DMapTileUrlBuilderOsm: DMapTileUrlBuilderOsm,
        DMapTileUrlBuilderOsmfj: DMapTileUrlBuilderOsmfj,
        DMapTilePyramids: DMapTilePyramids,
        DMapTile: DMapTile,
        DMenuAlign: UtilAttachAlign,
        DMenuBarItem: DMenuBarItem,
        DMenuBar: DMenuBar,
        DMenuContext: DMenuContext,
        DMenuItemBase: DMenuItemBase,
        DMenuItemCheckIsCompatible: DMenuItemCheckIsCompatible,
        DMenuItemCheck: DMenuItemCheck,
        DMenuItemExpandableBody: DMenuItemExpandableBody,
        DMenuItemExpandableHeader: DMenuItemExpandableHeader,
        DMenuItemExpandableIsCompatible: DMenuItemExpandableIsCompatible,
        DMenuItemExpandableItemCheck: DMenuItemExpandableItemCheck,
        DMenuItemExpandableItemLink: DMenuItemExpandableItemLink,
        DMenuItemExpandableItemMenu: DMenuItemExpandableItemMenu,
        DMenuItemExpandableItemSeparator: DMenuItemExpandableItemSeparator,
        DMenuItemExpandableItemSpace: DMenuItemExpandableItemSpace,
        DMenuItemExpandableItemText: DMenuItemExpandableItemText,
        DMenuItemExpandable: DMenuItemExpandable,
        DMenuItemExpandables: DMenuItemExpandables,
        DMenuItemLinkIsCompatible: DMenuItemLinkIsCompatible,
        DMenuItemLink: DMenuItemLink,
        DMenuItemMenuIsCompatible: DMenuItemMenuIsCompatible,
        DMenuItemMenuToSubMenuOptions: DMenuItemMenuToSubMenuOptions,
        DMenuItemMenu: DMenuItemMenu,
        DMenuItemSeparatorReflowable: DMenuItemSeparatorReflowable,
        DMenuItemSeparatorIsCompatible: DMenuItemSeparatorIsCompatible,
        DMenuItemSeparator: DMenuItemSeparator,
        DMenuItemSpaceIsCompatible: DMenuItemSpaceIsCompatible,
        DMenuItemSpace: DMenuItemSpace,
        DMenuItemText: DMenuItemText,
        DMenuItem: DMenuItem,
        DMenuItems: DMenuItems,
        DMenuSidedContent: DMenuSidedContent,
        DMenuSidedItemCheck: DMenuSidedItemCheck,
        DMenuSidedItemExpandableItemCheck: DMenuSidedItemExpandableItemCheck,
        DMenuSidedItemExpandableItemLink: DMenuSidedItemExpandableItemLink,
        DMenuSidedItemExpandableItemMenu: DMenuSidedItemExpandableItemMenu,
        DMenuSidedItemExpandableItemSeparator: DMenuSidedItemExpandableItemSeparator,
        DMenuSidedItemExpandableItemSpace: DMenuSidedItemExpandableItemSpace,
        DMenuSidedItemExpandableItemText: DMenuSidedItemExpandableItemText,
        DMenuSidedItemExpandable: DMenuSidedItemExpandable,
        DMenuSidedItemExpandables: DMenuSidedItemExpandables,
        DMenuSidedItemLink: DMenuSidedItemLink,
        DMenuSidedItemMenu: DMenuSidedItemMenu,
        DMenuSidedItemSeparator: DMenuSidedItemSeparator,
        DMenuSidedItemSpace: DMenuSidedItemSpace,
        DMenuSidedItemText: DMenuSidedItemText,
        DMenuSidedSelectionType: DMenuSidedSelectionType,
        DMenuSidedSelection: DMenuSidedSelection,
        DMenuSided: DMenuSided,
        DMenuSideds: DMenuSideds,
        DMenu: DMenu,
        DMenus: DMenus,
        DNoteError: DNoteError,
        DNoteNoItemsFound: DNoteNoItemsFound,
        DNoteSearching: DNoteSearching,
        DNoteSmallError: DNoteSmallError,
        DNoteSmallNoItemsFound: DNoteSmallNoItemsFound,
        DNoteSmallSearching: DNoteSmallSearching,
        DNoteSmall: DNoteSmall,
        DNote: DNote,
        DNotification: DNotification,
        DPaginationButtonLast: DPaginationButtonLast,
        DPaginationButtonNext: DPaginationButtonNext,
        DPaginationButtonPage: DPaginationButtonPage,
        DPaginationButtonPrevious: DPaginationButtonPrevious,
        DPaginationButtonTop: DPaginationButtonTop,
        DPaginationDots: DPaginationDots,
        DPaginationPage: DPaginationPage,
        DPagination: DPagination,
        DPaneScrollBar: DPaneScrollBar,
        DPane: DPane,
        DPickerColorAndAlpha: DPickerColorAndAlpha,
        DPickerColorGradientRecent: DPickerColorGradientRecent,
        DPickerColorGradientView: DPickerColorGradientView,
        DPickerColorGradient: DPickerColorGradient,
        DPickerColor: DPickerColor,
        DPickerDate: DPickerDate,
        DPickerDates: DPickerDates,
        DPickerDatetimeButtonBack: DPickerDatetimeButtonBack,
        DPickerDatetimeButtonDate: DPickerDatetimeButtonDate,
        DPickerDatetimeButtonNext: DPickerDatetimeButtonNext,
        DPickerDatetimeLabelDate: DPickerDatetimeLabelDate,
        DPickerDatetimeLabel: DPickerDatetimeLabel,
        DPickerDatetimeMask: DPickerDatetimeMask,
        DPickerDatetimeMasks: DPickerDatetimeMasks,
        DPickerDatetimeRange: DPickerDatetimeRange,
        DPickerDatetimeSpace: DPickerDatetimeSpace,
        DPickerDatetime: DPickerDatetime,
        DPickerDatetimes: DPickerDatetimes,
        DPickerTimeBoundHours: DPickerTimeBoundHours,
        DPickerTimeBoundMinutes: DPickerTimeBoundMinutes,
        DPickerTimeBoundSeconds: DPickerTimeBoundSeconds,
        DPickerTimeBound: DPickerTimeBound,
        DPickerTimeBounds: DPickerTimeBounds,
        DPickerTimeRange: DPickerTimeRange,
        DPickerTime: DPickerTime,
        DPickerTimes: DPickerTimes,
        DScalarExpressionNodeType: DScalarExpressionNodeType,
        DScalarExpression: DScalarExpression,
        DScalarFunctions: DScalarFunctions,
        DScrollBarHorizontal: DScrollBarHorizontal,
        DScrollBarThumbHorizontal: DScrollBarThumbHorizontal,
        DScrollBarThumbReflowableHorizontal: DScrollBarThumbReflowableHorizontal,
        DScrollBarThumbReflowableVertical: DScrollBarThumbReflowableVertical,
        DScrollBarThumbVertical: DScrollBarThumbVertical,
        DScrollBarThumb: DScrollBarThumb,
        DScrollBarVertical: DScrollBarVertical,
        DScrollBar: DScrollBar,
        DSelectMultiple: DSelectMultiple,
        DSelect: DSelect,
        DShadowImpl: DShadowImpl,
        DSliderHorizontal: DSliderHorizontal,
        DSliderLabel: DSliderLabel,
        DSliderThumb: DSliderThumb,
        DSliderTrackHorizontal: DSliderTrackHorizontal,
        DSliderTrackVertical: DSliderTrackVertical,
        DSliderTrack: DSliderTrack,
        DSliderValue: DSliderValue,
        DSliderVertical: DSliderVertical,
        DSlider: DSlider,
        DTableBodyCellActionDialog: DTableBodyCellActionDialog,
        DTableBodyCellActionMenu: DTableBodyCellActionMenu,
        DTableBodyCellActionPromise: DTableBodyCellActionPromise,
        DTableBodyCellButton: DTableBodyCellButton,
        DTableBodyCellCheck: DTableBodyCellCheck,
        DTableBodyCellColor: DTableBodyCellColor,
        DTableBodyCellDate: DTableBodyCellDate,
        DTableBodyCellDatetime: DTableBodyCellDatetime,
        DTableBodyCellIndex: DTableBodyCellIndex,
        DTableBodyCellInputInteger: DTableBodyCellInputInteger,
        DTableBodyCellInputReal: DTableBodyCellInputReal,
        DTableBodyCellInputTextArea: DTableBodyCellInputTextArea,
        DTableBodyCellInputText: DTableBodyCellInputText,
        DTableBodyCellInputTreeInput: DTableBodyCellInputTreeInput,
        DTableBodyCellInputTreeMarker: DTableBodyCellInputTreeMarker,
        DTableBodyCellInputTree: DTableBodyCellInputTree,
        toLinkOptions: toLinkOptions,
        toUrl: toUrl,
        toChecker: toChecker,
        DTableBodyCellLink: DTableBodyCellLink,
        DTableBodyCellSelectDialog: DTableBodyCellSelectDialog,
        DTableBodyCellSelectMenu: DTableBodyCellSelectMenu,
        DTableBodyCellSelectMultiple: DTableBodyCellSelectMultiple,
        DTableBodyCellSelectPromise: DTableBodyCellSelectPromise,
        DTableBodyCellTextArea: DTableBodyCellTextArea,
        DTableBodyCellText: DTableBodyCellText,
        DTableBodyCellTime: DTableBodyCellTime,
        DTableBodyCellTree: DTableBodyCellTree,
        DTableBodyCells: DTableBodyCells,
        DTableBodyRow: DTableBodyRow,
        DTableBody: DTableBody,
        DTableCategoryCell: DTableCategoryCell,
        DTableCategoryColumnImpl: DTableCategoryColumnImpl,
        DTableCategoryContainerImpl: DTableCategoryContainerImpl,
        DTableCategory: DTableCategory,
        DTableCellEdgeHovered: DTableCellEdgeHovered,
        DTableCellEdge: DTableCellEdge,
        DTableColumnContainerImpl: DTableColumnContainerImpl,
        DTableColumnImpl: DTableColumnImpl,
        DTableColumnType: DTableColumnType,
        DTableColumnUpdate: DTableColumnUpdate,
        DTableDataListFilter: DTableDataListFilter,
        DTableDataListMapped: DTableDataListMapped,
        DTableDataListSelection: DTableDataListSelection,
        DTableDataListSorter: DTableDataListSorter,
        DTableDataList: DTableDataList,
        DTableDataSelectionType: DTableDataSelectionType,
        DTableDataOrder: DTableDataOrder,
        DTableDataTreeFilter: DTableDataTreeFilter,
        DTableDataTreeItemAccessor: DTableDataTreeItemAccessor,
        DTableDataTreeSelectionImpl: DTableDataTreeSelectionImpl,
        DTableDataTreeSorter: DTableDataTreeSorter,
        DTableDataTree: DTableDataTree,
        DTableHeaderCellCheck: DTableHeaderCellCheck,
        DTableHeaderCell: DTableHeaderCell,
        DTableHeader: DTableHeader,
        DTableRow: DTableRow,
        DTableScrollBar: DTableScrollBar,
        DTableState: DTableState,
        DTable: DTable,
        DTextBase: DTextBase,
        DTextPieceAlignImpl: DTextPieceAlignImpl,
        DTextPieceImpl: DTextPieceImpl,
        DTextPieceStyleImpl: DTextPieceStyleImpl,
        DText: DText,
        DTreeDataImpl: DTreeDataImpl,
        DTreeDataMappedImpl: DTreeDataMappedImpl,
        DTreeDataSelectionMultiple: DTreeDataSelectionMultiple,
        DTreeDataSelectionNone: DTreeDataSelectionNone,
        DTreeDataSelectionSingle: DTreeDataSelectionSingle,
        DTreeDataSelectionType: DTreeDataSelectionType,
        DTreeItemButton: DTreeItemButton,
        DTreeItemNonEditable: DTreeItemNonEditable,
        DTreeItemState: DTreeItemState,
        DTreeItemText: DTreeItemText,
        DTreeItemUpdater: DTreeItemUpdater,
        DTreeNodeAccessorImpl: DTreeNodeAccessorImpl,
        DTree: DTree,
        DViewGestureImpl: DViewGestureImpl,
        DViewImpl: DViewImpl,
        DViewTransformImpl: DViewTransformImpl
    };

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    loadAll();
    const global = window;
    global.wcardinal = global.wcardinal || {};
    global.wcardinal.ui = ui;

})(PIXI);
